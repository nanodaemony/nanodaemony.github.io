(window.webpackJsonp=window.webpackJsonp||[]).push([[244],{571:function(t,s,n){"use strict";n.r(s);var a=n(4),_=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_3-二叉堆"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-二叉堆"}},[t._v("#")]),t._v(" 3.二叉堆")]),t._v(" "),s("h5",{attrs:{id:"_1-数据结构与实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据结构与实现"}},[t._v("#")]),t._v(" 1.数据结构与实现")]),t._v(" "),s("h6",{attrs:{id:"_1-存储特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-存储特点"}},[t._v("#")]),t._v(" (1)存储特点")]),t._v(" "),s("p",[t._v("堆形式上是"),s("strong",[t._v("一颗完全二叉树")]),t._v(", 堆的"),s("strong",[t._v("根结点")]),t._v("是堆有序的二叉树中的"),s("strong",[t._v("最大或最小")]),t._v("结点 (大顶堆或小顶堆). "),s("strong",[t._v("堆中")]),t._v("某个节点的值总是"),s("strong",[t._v("大于等于")]),t._v("其子节点的值.")]),t._v(" "),s("p",[t._v("由于堆是完全二叉树, 因此可以方便的存储到"),s("strong",[t._v("数组")]),t._v("中. 为便于清晰地描述节点的"),s("strong",[t._v("位置关系")]),t._v(", 这里"),s("strong",[t._v("不使用数组索引为 0")]),t._v(" 的位置. 位置 "),s("strong",[t._v("k")]),t._v(" 的节点的父节点位置为 "),s("strong",[t._v("k / 2")]),t._v(", 而它的两个子节点的位置分别为 "),s("strong",[t._v("2k 和 2k+1")]),t._v(".")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20210905152143440.png",alt:""}})]),t._v(" "),s("p",[t._v("如果 0 不空出来只需要在计算的时候把 i 值往右偏移一个位置就行了.")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("结点")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("位置")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("结点")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("位置")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("当前结点")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("a[i]")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("左子结点")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("a[2i]")])])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("父结点")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("a[i / 2]")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("右子结点")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("a[2i + 1]")])])])])]),t._v(" "),s("p",[t._v("注意父节点位置这里是"),s("strong",[t._v("整数除")]),t._v(", "),s("strong",[t._v("2 和 3 除以 2 都为 1")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_2-插入元素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-插入元素"}},[t._v("#")]),t._v(" (2)插入元素")]),t._v(" "),s("p",[t._v("当"),s("strong",[t._v("插入")]),t._v("一个元素到堆中时, 它可能"),s("strong",[t._v("不满足堆")]),t._v("的性质, 在这种情况下需要"),s("strong",[t._v("调整堆中元素的位置使之重新变成堆")]),t._v(", 这个过程称为"),s("strong",[t._v("堆化")]),t._v(" (heapify). 在最大堆中, 要堆化一个元素, 需要"),s("strong",[t._v("找到它的父亲结点")]),t._v(", 如果不满足堆的基本性质则"),s("strong",[t._v("交换两个元素的位置")]),t._v(", 重复该过程直到每个结点都满足堆的性质为止.")]),t._v(" "),s("p",[t._v("实现方式就是将"),s("strong",[t._v("新元素")]),t._v("放到"),s("strong",[t._v("数组末尾")]),t._v(", 然后"),s("strong",[t._v("上浮")]),t._v("到合适的位置. 在堆的"),s("strong",[t._v("下一个可用位置(也就是存放元素数组的下一个位置)创建一个空穴")]),t._v(", 否则该堆将不是完全树. 将"),s("strong",[t._v("待插入的元素")]),t._v("与"),s("strong",[t._v("空穴的父结点")]),t._v("进行比较, 如果比父节点小就交换空穴与父节点位置, 空穴"),s("strong",[t._v("上浮")]),t._v(", 循环此过程.")]),t._v(" "),s("p",[t._v("如下面在大顶堆中插入一个新元素 "),s("strong",[t._v("26")]),t._v(": 在二叉堆的下一个可用位置放置一个"),s("strong",[t._v("空穴")]),t._v(", 该空穴值假定为 26, 但是"),s("strong",[t._v("不赋值")]),t._v(", 可以"),s("strong",[t._v("减少比较与交换操作")]),t._v(".")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20210905152518847.png",alt:""}})]),t._v(" "),s("p",[t._v("通过二叉堆的"),s("strong",[t._v("索引")]),t._v("公式可以找到新插入元素的"),s("strong",[t._v("父亲结点")]),t._v(", 然后"),s("strong",[t._v("比较两者大小")]),t._v(", 如果新元素更大则交换两个元素的位置, 这个操作就相当于把该元素"),s("strong",[t._v("上浮")]),t._v("了一下. 如下图中 26 与 16 交换位,  26 上浮.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20210905152632906.png",alt:""}})]),t._v(" "),s("p",[t._v("重复该操作直到 26 到了一个"),s("strong",[t._v("满足堆条件的位置")]),t._v(", 此时就完成了插入的操作, 下图插入 26 完成.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20210905152726918.png",alt:""}})]),t._v(" "),s("h6",{attrs:{id:"_3-删除堆顶元素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-删除堆顶元素"}},[t._v("#")]),t._v(" (3)删除堆顶元素")]),t._v(" "),s("p",[t._v("删除堆中的"),s("strong",[t._v("堆顶元素")]),t._v("就是用"),s("strong",[t._v("最后一个元素替换掉栈顶元素")]),t._v(", 然后把替换后的最后一个元素删除掉, 这样一来元素的总个数也满足条件, 然后只需要把"),s("strong",[t._v("栈顶元素依次往下调整")]),t._v("就好了, 这个操作就叫做 "),s("strong",[t._v("下沉(sink)")]),t._v(". 即从数组"),s("strong",[t._v("顶端删除最大")]),t._v("的元素, 并将数组的"),s("strong",[t._v("最后一个元素放到顶端")]),t._v(", 并让这个元素"),s("strong",[t._v("下沉到合适")]),t._v("的位置.")]),t._v(" "),s("p",[t._v("具体方法是将"),s("strong",[t._v("堆顶元素置换为空穴")]),t._v(", 然后将空穴的"),s("strong",[t._v("两个子结点中较小者")]),t._v("与其交换位置, 直到下沉到对应位置. 但是可能遇到"),s("strong",[t._v("只有一个子结点")]),t._v("的情况, 此时一种解决方法是始终保证算法把每一个结点都"),s("strong",[t._v("看成有两个子结点")]),t._v(". 为了实施这种解法, 当堆的大小为偶数时在每个"),s("strong",[t._v("下沉开始处")]),t._v(", 可将其值"),s("strong",[t._v("大于堆中任何元素的标记")]),t._v("放到堆的"),s("strong",[t._v("终端后面")]),t._v("的位置上. 也就是假想有一个大于或者小于任何元素的结点此时正在堆的"),s("strong",[t._v("最后一个位置")]),t._v("上.")]),t._v(" "),s("p",[t._v("例如删除大顶堆堆顶元素 62. 用数组最后的一个元素"),s("strong",[t._v("替换")]),t._v("掉堆顶元素, 然后删除替换后的最后一个元素并返回堆顶元素 62:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20210905152920589.png",alt:""}})]),t._v(" "),s("p",[t._v("然后比较其孩子结点的大小:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20210905153035706.png",alt:""}})]),t._v(" "),s("p",[t._v("如果"),s("strong",[t._v("不满足堆")]),t._v("的条件, 那么就跟"),s("strong",[t._v("孩子结点中较大")]),t._v("的一个交换位置: 41 ＞ 30, 所以16 与 41 "),s("strong",[t._v("交换")]),t._v("位置.")]),t._v(" "),s("p",[t._v("​"),s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20210905153234772.png",alt:""}}),t._v("​")]),t._v(" "),s("p",[t._v("重复该步骤, 直到 16 到达合适的位置:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20210905153350123.png",alt:""}})]),t._v(" "),s("p",[t._v("完成取出堆顶元素的操作:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20210905153456284.png",alt:""}})]),t._v(" "),s("h6",{attrs:{id:"_4-数组构造堆"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-数组构造堆"}},[t._v("#")]),t._v(" (4)数组构造堆")]),t._v(" "),s("p",[t._v("使用无序的数组构造堆时, 就是"),s("strong",[t._v("不断对每个元素")]),t._v("进行"),s("strong",[t._v("下沉")]),t._v("操作.")]),t._v(" "),s("h5",{attrs:{id:"_2-优先级队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-优先级队列"}},[t._v("#")]),t._v(" 2.优先级队列")]),t._v(" "),s("p",[t._v("Java 中的 PriorityQueue 类可以实现优先级队列, 默认为"),s("strong",[t._v("最小堆")]),t._v(", 与上述相比有一些函数名不一样, 底层还是维护了一个 "),s("strong",[t._v("Object 类型的数组")]),t._v(", 另外如果想要把最小堆变成"),s("strong",[t._v("最大堆")]),t._v("可以给 PriorityQueue 传入自己的"),s("strong",[t._v("比较器")]),t._v(", 例如:")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 默认为最小堆")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PriorityQueue")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" pq "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PriorityQueue")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用Lambda表达式传入比较器转换成最大堆")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PriorityQueue")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" pq2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PriorityQueue")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("blockquote",[s("p",[t._v("优先级队列的应用")])]),t._v(" "),s("p",[t._v("应用有很多:")]),t._v(" "),s("ul",[s("li",[t._v("数据压缩: 赫夫曼编码算法;")]),t._v(" "),s("li",[t._v("最短路径算法: Dijkstra 算法;")]),t._v(" "),s("li",[t._v("最小生成树算法: Prim 算法;")]),t._v(" "),s("li",[t._v("动态数据排序: 动态数据查找第 K 大元素, 前 K 个元素, 中位数值(可以同时维护一个大顶堆和一个小顶堆, 用于找无界数据流的中值);")])]),t._v(" "),s("p",[t._v("‍")])])}),[],!1,null,null,null);s.default=_.exports}}]);