(window.webpackJsonp=window.webpackJsonp||[]).push([[199],{504:function(t,s,a){"use strict";a.r(s);var _=a(7),v=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_10-常见数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-常见数据结构"}},[t._v("#")]),t._v(" 10.常见数据结构")]),t._v(" "),s("h4",{attrs:{id:"数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),s("h5",{attrs:{id:"_1-稀疏数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-稀疏数组"}},[t._v("#")]),t._v(" 1.稀疏数组")]),t._v(" "),s("p",[t._v("需要记录二维数组的场景下, 如果记录的"),s("strong",[t._v("有效信息")]),t._v("较少可以考虑使用"),s("strong",[t._v("稀疏数组")]),t._v(". 比如记录一个"),s("strong",[t._v("棋盘, 地图")]),t._v("等, 如下图的二维数组中很多值是"),s("strong",[t._v("默认值 0")]),t._v(", 浪费存储空间.")]),t._v(" "),s("h4",{attrs:{id:"线性表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线性表"}},[t._v("#")]),t._v(" 线性表")]),t._v(" "),s("p",[s("strong",[t._v("线性表")]),t._v("存储方式分为"),s("strong",[t._v("顺序存储和链式存储")]),t._v(". 顺序存储使用"),s("strong",[t._v("数组")]),t._v("进行存储; 链式存储使用"),s("strong",[t._v("链表")]),t._v("进行存储.")]),t._v(" "),s("h5",{attrs:{id:"_1-数组实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-数组实现"}},[t._v("#")]),t._v(" 1.数组实现")]),t._v(" "),s("p",[t._v("元素在内存中顺序存储. 插入, 删除元素时需要额外移动元素, 效率较低. 查询效率高.")]),t._v(" "),s("h5",{attrs:{id:"_2-单向链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-单向链表"}},[t._v("#")]),t._v(" 2.单向链表")]),t._v(" "),s("p",[t._v("元素在内存中"),s("strong",[t._v("不一定")]),t._v("连续存储. 链表是以"),s("strong",[t._v("结点")]),t._v("方式来存储数据, 每个结点包含 "),s("strong",[t._v("data 域, next 域")]),t._v(", 用于指向下一个结点, 遍历方向只能从头到尾.")]),t._v(" "),s("h5",{attrs:{id:"_3-双向链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-双向链表"}},[t._v("#")]),t._v(" 3.双向链表")]),t._v(" "),s("p",[t._v("双向链表可以"),s("strong",[t._v("向前或者向后")]),t._v("查找.")]),t._v(" "),s("h4",{attrs:{id:"栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[t._v("#")]),t._v(" 栈")]),t._v(" "),s("p",[t._v("栈是一种后进先出 ("),s("strong",[t._v("LIFO")]),t._v(") 的数据结构. 栈的操作端通常被称为"),s("strong",[t._v("栈顶")]),t._v(", 另一端被称为"),s("strong",[t._v("栈底")]),t._v(".")]),t._v(" "),s("p",[t._v("栈的常见应用: 十进制转 N 进制, 行编辑器, 校验括号是否匹配, 中缀表达式转后缀表达式, 表达式求值等.")]),t._v(" "),s("blockquote",[s("p",[t._v("数组实现")])]),t._v(" "),s("p",[t._v("使用可变大小数组实现栈, 容量不够时可以自动"),s("strong",[t._v("扩容")]),t._v(". 使用数组实现栈则数组的第一个位置是"),s("strong",[t._v("栈底")]),t._v(", 数组"),s("strong",[t._v("最后占用")]),t._v("的位置才指向"),s("strong",[t._v("栈顶")]),t._v(", 否则压栈会整体"),s("strong",[t._v("移动")]),t._v("元素位置.")]),t._v(" "),s("p",[t._v("弹栈操作可以将所有的元素依次弹栈即可.")]),t._v(" "),s("blockquote",[s("p",[t._v("链式实现")])]),t._v(" "),s("p",[t._v("需要使用链表的"),s("strong",[t._v("头插法或尾插法")]),t._v("来实现.")]),t._v(" "),s("h4",{attrs:{id:"队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[t._v("#")]),t._v(" 队列")]),t._v(" "),s("p",[t._v("队列是一种先进先出  "),s("strong",[t._v("(FIFO)")]),t._v("  的数据结构. 添加元素在"),s("strong",[t._v("后端")]),t._v(", 出队列在"),s("strong",[t._v("前端")]),t._v(".")]),t._v(" "),s("p",[t._v("双端队列. 能在队列的前端和后端进行添加, 删除与获取操作, 行为上类似于双端栈.")]),t._v(" "),s("p",[t._v("优先级队列. 根据"),s("strong",[t._v("优先级")]),t._v("组织队列中的对象. 对象优先级通过 "),s("strong",[t._v("compareTo()")]),t._v("  方法确定. Java 实现类 "),s("strong",[t._v("PriorityQueue")]),t._v(". 重点是"),s("strong",[t._v("堆")]),t._v("实现.")]),t._v(" "),s("p",[t._v("队列接口实现参考: Queue与Deque接口.")]),t._v(" "),s("h4",{attrs:{id:"符号表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#符号表"}},[t._v("#")]),t._v(" 符号表")]),t._v(" "),s("h5",{attrs:{id:"_1-概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[t._v("#")]),t._v(" 1.概述")]),t._v(" "),s("p",[t._v("符号表是一种"),s("strong",[t._v("存储键值对")]),t._v("的数据结构, 其主要目的是将"),s("strong",[t._v("一个键和一个值")]),t._v("联系起来.")]),t._v(" "),s("p",[t._v("符号表分为"),s("strong",[t._v("有序和无序")]),t._v("两种, 有序符号表主要指支持 min(), max() 等根据键的"),s("strong",[t._v("大小关系")]),t._v("来实现的操作. 有序符号表保证的是"),s("strong",[t._v("键")]),t._v("的有序性, 比较的是键.")]),t._v(" "),s("p",[t._v("符号表有"),s("strong",[t._v("多种实现")]),t._v("方式, "),s("strong",[t._v("树或者散列表")]),t._v("等都可以.")]),t._v(" "),s("h5",{attrs:{id:"_2-实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-实现"}},[t._v("#")]),t._v(" 2.实现")]),t._v(" "),s("blockquote",[s("p",[t._v("符号表实现算法比较")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("算法")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("插入")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("查找")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("是否有序")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("二叉查找树")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("logN")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("logN")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("是")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("2-3 查找树")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("logN")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("logN")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("是")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("拉链法")]),t._v("实现的散列表")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("N/M")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("N/M")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("否")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("线性探测法")]),t._v("实现的散列表")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("否")])])])]),t._v(" "),s("p",[t._v("符号表的各种实现方式优缺点对比.")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("数据结构")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("优点")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("缺点")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("散列表")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("能够快速的"),s("strong",[t._v("查找和插入")]),t._v("常见类型的数据")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("无法进行有序性")]),t._v("相关的操作, 链接与空节点需要额外空间")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("二叉查找树")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("实现简单, 能够进行"),s("strong",[t._v("有序性")]),t._v("的相关操作")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("没有性能上界的保证, 链接需要额外空间")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("平衡二叉查找树")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("最优的"),s("strong",[t._v("查找和插入")]),t._v("效率, 能够进行有序性相关的操作")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("链接需要额外的空间")])])])]),t._v(" "),s("p",[s("strong",[t._v("无序")]),t._v("时应当优先考虑"),s("strong",[t._v("散列表")]),t._v(", 当需要"),s("strong",[t._v("有序")]),t._v("性操作时使用"),s("strong",[t._v("红黑树")]),t._v(".")]),t._v(" "),s("p",[t._v("Java 符号表实现参考: Map接口.")]),t._v(" "),s("h4",{attrs:{id:"散列表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#散列表"}},[t._v("#")]),t._v(" 散列表")]),t._v(" "),s("h5",{attrs:{id:"_1-基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础"}},[t._v("#")]),t._v(" 1.基础")]),t._v(" "),s("p",[t._v("散列表是根据"),s("strong",[t._v("键值(Key value)")]),t._v("  直接进行访问的数据结构, 它通过把"),s("strong",[t._v("键值映射到表中一个位置")]),t._v("来访问记录, 以加快查找的速度. 散列表通过"),s("strong",[t._v("散列函数")]),t._v("将键映射到对应的位置.")]),t._v(" "),s("h5",{attrs:{id:"_2-散列函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-散列函数"}},[t._v("#")]),t._v(" 2.散列函数")]),t._v(" "),s("h6",{attrs:{id:"_1-定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-定义"}},[t._v("#")]),t._v(" (1)定义")]),t._v(" "),s("p",[t._v("散列表中每个"),s("strong",[t._v("键")]),t._v("被映射到从 "),s("strong",[t._v("0 到 TableSize - 1")]),t._v(" 这个范围的某个数, 并被放到合适的单元中, 这个映射关系就是"),s("strong",[t._v("散列函数")]),t._v(". 对于一个大小为 "),s("strong",[t._v("M")]),t._v(" 的散列表, 散列函数能够把任意键转换为  "),s("strong",[t._v("[0, M - 1]")]),t._v("  内的正整数, 该正整数即为 "),s("strong",[t._v("hash")]),t._v(" 值.")]),t._v(" "),s("p",[t._v("散列函数对键进行映射时通常应该满足以下"),s("strong",[t._v("三个特性")]),t._v(":")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("一致性")]),t._v(": 相等的键应当有相等的 hash 值, 两个键相等表示调用 equals() 返回的值相等.")]),t._v(" "),s("li",[s("strong",[t._v("高效性")]),t._v(": 计算应当简便高效, 有必要的话可以把 hash 值缓存起来, 在调用 hash 函数时直接返回.")]),t._v(" "),s("li",[s("strong",[t._v("均匀性")]),t._v(": 所有键的 hash 值应当均匀地分布到 [0, M-1] 之间, 不均匀可能产生很多冲突, 从而导致散列表性能下降.")])]),t._v(" "),s("h6",{attrs:{id:"_2-常见散列函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-常见散列函数"}},[t._v("#")]),t._v(" (2)常见散列函数")]),t._v(" "),s("p",[s("strong",[t._v("除留余数法(取模)可以将整数散列到 [0, M-1] 之间")]),t._v(", 例如一个正整数 k, 计算 k % M 既可得到一个 [0, M-1] 之间的 hash 值. 注意 "),s("strong",[t._v("M 最好是一个素数")]),t._v(", 否则无法利用键包含的所有信息. 例如 M 为 10"),s("sup",[t._v("k")]),t._v(", 那么只能利用键的后 k 位.")]),t._v(" "),s("p",[t._v("对于其它数值形式的键, 可以将其"),s("strong",[t._v("转换成整数")]),t._v("的形式, 然后利用除留余数法. 例如对于"),s("strong",[t._v("浮点数")]),t._v(", 可以将其的"),s("strong",[t._v("二进制形式")]),t._v("转换成整数.")]),t._v(" "),s("p",[s("strong",[t._v("对于多部分组合的类型, 每个部分都需要计算 hash 值, 这些 hash 值都具有同等重要的地位")]),t._v(". 为了达到这个目的, 可以将该类型看成 R 进制的整数, 每个部分都具有不同的"),s("strong",[t._v("权值")]),t._v(".")]),t._v(" "),s("p",[t._v("例如, 字符串的散列函数实现如下:")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" hash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("length")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    hash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("R")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" hash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("charAt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("M")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("再如拥有"),s("strong",[t._v("多个成员")]),t._v("的自定义类的哈希函数如下:")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" hash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("day "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("R")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" month"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("M")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("R")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" year"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("M")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("R 通常取 "),s("strong",[t._v("31")]),t._v(".")]),t._v(" "),s("p",[t._v("Java 中的 "),s("strong",[t._v("hashCode()")]),t._v("  实现了哈希函数, 但是默认使用对象的"),s("strong",[t._v("内存地址值")]),t._v(". 在使用 hashCode() 时, 应当结合除留余数法来使用. 因为"),s("strong",[t._v("内存地址是 32 位整数")]),t._v(", 计算时只需要 "),s("strong",[t._v("31 位")]),t._v("的非负整数, 因此应当屏蔽符号位之后再使用除留余数法.")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" hash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x7fffffff")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("M")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("使用 Java 的 HashMap 等自带的哈希表实现时, 只需要实现 "),s("strong",[t._v("Key 类型")]),t._v("的 hashCode() 方法即可. Java 规定 hashCode() 能够将键均匀分布于所有的 32 位整数, Java 中的 String, Integer 等对象的 hashCode() 都能实现这一点.")]),t._v(" "),s("h5",{attrs:{id:"_3-散列冲突"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-散列冲突"}},[t._v("#")]),t._v(" 3.散列冲突")]),t._v(" "),s("p",[t._v("当两个"),s("strong",[t._v("不同")]),t._v("的键散列到"),s("strong",[t._v("同一个值")]),t._v("的时候 (hash 值相同), 就产生了散列冲突. 解决散列冲突的简单方法有: "),s("strong",[t._v("拉链法和开放定址法")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_1-拉链法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-拉链法"}},[t._v("#")]),t._v(" (1)拉链法")]),t._v(" "),s("p",[t._v("拉链法使用"),s("strong",[t._v("数组 + 链表")]),t._v("来存储 hash 值相同的键, 从而解决冲突(比如 "),s("strong",[t._v("HashMap")]),t._v(" 类).")]),t._v(" "),s("p",[s("strong",[t._v("查找")]),t._v("需要分两步, 首先查找 Key 所在的"),s("strong",[t._v("链表")]),t._v(" (对应的数据槽), 然后在链表中"),s("strong",[t._v("顺序查找")]),t._v(".")]),t._v(" "),s("p",[t._v("对于 N 个键, M 条链表 (N > M), 如果哈希函数能够满足均匀性的条件, 每条链表的"),s("strong",[t._v("长度趋向于 N/M")]),t._v(", 因此未命中的查找和插入操作所需要的比较次数为 ~N/M.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563523769927.png",alt:""}})]),t._v(" "),s("p",[t._v("这个详细可看 "),s("strong",[t._v("HashMap")]),t._v(" 的源码(参考: HashMap源码分析).")]),t._v(" "),s("h6",{attrs:{id:"_2-开放地址法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-开放地址法"}},[t._v("#")]),t._v(" (2)开放地址法")]),t._v(" "),s("p",[s("strong",[t._v("线性探测法")]),t._v("使用"),s("strong",[t._v("空位")]),t._v("来解决冲突, 当冲突发生时, "),s("strong",[t._v("向前探测一个空位")]),t._v("来存储冲突的键.")]),t._v(" "),s("p",[t._v("更常见的是, 单元 h0(x), h1(x), ... 相继被试选, 其中")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hi")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fi")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" mod TableSize"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 且 "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("f")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[s("strong",[t._v("函数 f 是解决冲突解决方法(冲突函数)")]),t._v(" . 此方法中"),s("strong",[t._v("所有的数据都需要放入表")]),t._v("内, 所以"),s("strong",[t._v("需要的表比拉链法散列需要的表更大")]),t._v(". 这样的表叫做"),s("strong",[t._v("探测散列表")]),t._v(".")]),t._v(" "),s("p",[t._v("使用线性探测法, 数组的大小 M 应当"),s("strong",[t._v("大于键的个数 N")]),t._v("(M > N).")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/0dbc4f7d-05c9-4aae-8065-7b7ea7e9709e.gif",alt:""}})]),t._v(" "),s("p",[t._v("有几种常见的冲突解决方案. "),s("strong",[t._v("线性探测法, 平方探测法, 双散列法")]),t._v(".")]),t._v(" "),s("blockquote",[s("p",[t._v("线性探测法")])]),t._v(" "),s("p",[t._v("线性探测法中典型的情形是"),s("strong",[t._v("冲突函数 f 为一次函数")]),t._v(":")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("f(i) = i\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("这相当于相继"),s("strong",[t._v("逐个探测单元")]),t._v("(必要时可以回绕)以查找出一个"),s("strong",[t._v("空")]),t._v("单元.")]),t._v(" "),s("p",[t._v("存在的"),s("strong",[t._v("问题")]),t._v(": 有时候占据的单元会形成一些"),s("strong",[t._v("区块")]),t._v(", 其结果成为"),s("strong",[t._v("一次聚集")]),t._v(", 就是说散列到"),s("strong",[t._v("区块")]),t._v("中的任何关键字都需要"),s("strong",[t._v("多次尝试")]),t._v("才能解决冲突.")]),t._v(" "),s("p",[t._v("线性探测法的成本取决于连续条目的长度, 连续条目也叫"),s("strong",[t._v("聚簇")]),t._v(". 当聚簇很长时, 在查找和插入时也需要进行"),s("strong",[t._v("很多次探测")]),t._v(". "),s("strong",[t._v("装填因子")]),t._v("的选取很重要.")]),t._v(" "),s("p",[s("strong",[t._v("α = N/M")]),t._v(", 把 α 称为"),s("strong",[t._v("使用率")]),t._v(". 理论证明, 当 α 小于 1/2 时探测的预计次数只在 1.5 到 2.5 之间. 为了保证散列表的性能, 应当调整数组的大小, 使得 "),s("strong",[t._v("α 在 [1/4, 1/2]")]),t._v("  之间.")]),t._v(" "),s("blockquote",[s("p",[t._v("平方探测法")])]),t._v(" "),s("p",[t._v("平方探测就是"),s("strong",[t._v("冲突函数为二次")]),t._v("的探测方法, 它是"),s("strong",[t._v("消除")]),t._v("线性探测中"),s("strong",[t._v("一次聚集")]),t._v("问题的散列冲突解决方法.")]),t._v(" "),s("p",[t._v("典型的情形是:")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("f(i) = i * i\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[s("strong",[t._v("定理")]),t._v(": 如果使用"),s("strong",[t._v("平方探测")]),t._v(", 且表的大小是"),s("strong",[t._v("素数")]),t._v(", 那么当表至少有"),s("strong",[t._v("一半是空")]),t._v("的时候, "),s("strong",[t._v("总能够")]),t._v("插入一个新的元素. 即使表被填充的位置仅仅比"),s("strong",[t._v("一半多一个")]),t._v(", 那么插入都"),s("strong",[t._v("可能失败")]),t._v(".")]),t._v(" "),s("p",[t._v("但平方探测也可能产生"),s("strong",[t._v("二次聚集")]),t._v("问题.")]),t._v(" "),s("blockquote",[s("p",[t._v("双散列法")])]),t._v(" "),s("p",[t._v("双散列法冲突函数一般的选择是:")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("f(i) = i * hash2(x)\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("这个公式是说将第二个散列函数应用到 x 并在距离 "),s("strong",[t._v("hash2(x)")]),t._v(" , "),s("strong",[t._v("2 hash2(x)....")]),t._v("  等处进行探测.")]),t._v(" "),s("h5",{attrs:{id:"_4-再散列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-再散列"}},[t._v("#")]),t._v(" 4.再散列")]),t._v(" "),s("p",[t._v("如果散列表装的太满, 那么再插入新元素的时候可能消耗时间很长, 而且可能失败. 解决方法是"),s("strong",[t._v("新建")]),t._v("一个大约 2 倍大的表, 然后扫描整个原始散列表, "),s("strong",[t._v("重新计算元素的新散列值")]),t._v("并装入到新的散列表中, 这个操作就是"),s("strong",[t._v("再散列")]),t._v(". 类似 HashMap 的扩容操作.")]),t._v(" "),s("p",[t._v("再散列显然开销较大.")]),t._v(" "),s("p",[s("strong",[t._v("再散列的策略")]),t._v(":")]),t._v(" "),s("ul",[s("li",[t._v("散列表到一半满就再散列.")]),t._v(" "),s("li",[t._v("当插入元素失败才再散列(比较极端).")]),t._v(" "),s("li",[s("strong",[t._v("途中策略")]),t._v(": 当散列表达到一个"),s("strong",[t._v("装填因子")]),t._v("时进行再散列 (较好).")])]),t._v(" "),s("p",[t._v("‍")])])}),[],!1,null,null,null);s.default=v.exports}}]);