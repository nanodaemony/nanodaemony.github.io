(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{335:function(t,r,_){"use strict";_.r(r);var e=_(7),v=Object(e.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"_1-操作系统基础"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-操作系统基础"}},[t._v("#")]),t._v(" 1.操作系统基础")]),t._v(" "),r("h4",{attrs:{id:"基本概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),r("p",[t._v("操作系统(Operating System, OS) 是管理计算机硬件与软件资源的程序, 是计算机系统的内核与基石.")]),t._v(" "),r("p",[t._v("操作系统分为"),r("strong",[t._v("内核与外壳")]),t._v(". 内核负责管理系统的进程, 内存, 设备驱动程序, 文件和网络系统等等, 决定着系统的性能和稳定性, 是连接应用程序和硬件的桥梁, 内核是能"),r("strong",[t._v("操作硬件")]),t._v("的程序. 外壳可以理解成围绕着内核的"),r("strong",[t._v("应用程序")]),t._v(".")]),t._v(" "),r("h5",{attrs:{id:"_1-操作系统基本特征"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-操作系统基本特征"}},[t._v("#")]),t._v(" 1.操作系统基本特征")]),t._v(" "),r("h6",{attrs:{id:"_1-并发"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-并发"}},[t._v("#")]),t._v(" (1)并发")]),t._v(" "),r("p",[t._v("并发是指宏观上在一段时间内能"),r("strong",[t._v("同时运行多个程序")]),t._v(", 而并行则指同一时刻能运行多个指令. 并行需要硬件支持, 如多流水线, 多核处理器或者分布式计算系统. 操作系统通过引入进程和线程, 使得程序能够并发运行.")]),t._v(" "),r("h6",{attrs:{id:"_2-共享"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-共享"}},[t._v("#")]),t._v(" (2)共享")]),t._v(" "),r("p",[t._v("共享是指系统中的"),r("strong",[t._v("资源")]),t._v("可以被"),r("strong",[t._v("多个并发进程共同使用")]),t._v(".")]),t._v(" "),r("p",[t._v("共享有两种方式: "),r("strong",[t._v("互斥共享和同时共享")]),t._v(". 互斥共享的资源称为"),r("strong",[t._v("临界资源")]),t._v(", 例如打印机等, 在同一时间只允许一个进程访问, 需要用同步机制来实现对临界资源的访问.")]),t._v(" "),r("h6",{attrs:{id:"_3-虚拟"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-虚拟"}},[t._v("#")]),t._v(" (3)虚拟")]),t._v(" "),r("p",[t._v("主要有"),r("strong",[t._v("两种虚拟技术")]),t._v(": "),r("strong",[t._v("时分复用技术和空分复用技术")]),t._v(".")]),t._v(" "),r("p",[r("strong",[t._v("多个进程")]),t._v("能在同一个处理器上并发执行使用了"),r("strong",[t._v("时分复用技术")]),t._v(", 让每个进程轮流占有处理器, 每次只执行一小个时间片并快速切换.")]),t._v(" "),r("p",[r("strong",[t._v("虚拟内存")]),t._v("使用了"),r("strong",[t._v("空分复用技术")]),t._v(", 它将物理内存抽象为地址空间, 每个进程都有各自的地址空间. 地址空间的页被映射到物理内存, 地址空间的页并不需要全部在物理内存中, 当使用到一个没有在物理内存的页时, 执行页面置换算法, 将该页置换到内存中.")]),t._v(" "),r("h6",{attrs:{id:"_4-异步"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-异步"}},[t._v("#")]),t._v(" (4)异步")]),t._v(" "),r("p",[t._v("异步指进程不是一次性执行完毕, 而是走走停停, 以不可知的速度向前推进.")]),t._v(" "),r("h5",{attrs:{id:"_2-操作系统基本功能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-操作系统基本功能"}},[t._v("#")]),t._v(" 2.操作系统基本功能")]),t._v(" "),r("h6",{attrs:{id:"_1-进程管理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-进程管理"}},[t._v("#")]),t._v(" (1)进程管理")]),t._v(" "),r("p",[t._v("进程控制, 进程同步, 进程通信, 死锁处理, 处理机调度等.")]),t._v(" "),r("h6",{attrs:{id:"_2-内存管理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-内存管理"}},[t._v("#")]),t._v(" (2)内存管理")]),t._v(" "),r("p",[t._v("内存分配, 地址映射, 内存保护与共享, 虚拟内存等.")]),t._v(" "),r("h6",{attrs:{id:"_3-文件管理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-文件管理"}},[t._v("#")]),t._v(" (3)文件管理")]),t._v(" "),r("p",[t._v("文件存储空间的管理, 目录管理, 文件读写管理和保护等.")]),t._v(" "),r("h6",{attrs:{id:"_4-设备管理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-设备管理"}},[t._v("#")]),t._v(" (4)设备管理")]),t._v(" "),r("p",[t._v("完成用户的 I/O 请求, 方便用户使用各种设备, 并提高设备的利用率. 主要包括缓冲管理, 设备分配, 设备处理, 虛拟设备等.")]),t._v(" "),r("h4",{attrs:{id:"用户态与内核态🌟"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#用户态与内核态🌟"}},[t._v("#")]),t._v(" 用户态与内核态🌟")]),t._v(" "),r("h5",{attrs:{id:"_1-基础"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础"}},[t._v("#")]),t._v(" 1.基础")]),t._v(" "),r("p",[t._v("根据进程访问资源的特点, 可以把"),r("strong",[t._v("进程")]),t._v("在系统上的运行分为"),r("strong",[t._v("两个级别")]),t._v(":")]),t._v(" "),r("ol",[r("li",[r("strong",[t._v("用户态(user mode)")]),t._v(" : "),r("strong",[t._v("用户态是用户应用程序运行的模式")]),t._v(". 用户态运行的进程可以直接读取用户程序的数据. 应用程序必须依托于内核态运行, 因此用户态的态的"),r("strong",[t._v("操作权限比内核态是要低")]),t._v("的, 如磁盘, 文件等, 访问操作都是"),r("strong",[t._v("受限")]),t._v("的.")]),t._v(" "),r("li",[r("strong",[t._v("内核态(kernel mode)")]),t._v(" : "),r("strong",[t._v("内核态是操作系统内核运行的模式.")]),t._v(" "),r("strong",[r("strong",[t._v("内核态控制计算机的硬件资源, 如硬件设备, 文件系统等等, 并为上层应用程序提供执行环境. 内核态运行的进程几乎可以访问计算机的")])]),t._v("​"),r("strong",[t._v("任何资源, 不受限制")]),t._v(".")])]),t._v(" "),r("p",[t._v("以 4G 大小的"),r("strong",[t._v("内存空间")]),t._v("为例, Linux 为内核代码和数据结构预留了几个"),r("strong",[t._v("页框")]),t._v(", 这些页"),r("strong",[t._v("永远不会")]),t._v("被交换到磁盘上. 从 0x00000000 到 0xc0000000(PAGE_OFFSET) 的线性地址可由用户代码 和 内核代码进行引用(即"),r("strong",[t._v("用户空间")]),t._v("). 从 0xc0000000(PAGE_OFFSET) 到 0xFFFFFFFFF 的线性地址"),r("strong",[t._v("只能由内核代码进行访问")]),t._v("(即"),r("strong",[t._v("内核空间")]),t._v("), 内核代码及其数据结构都必须位于这 1GB 的地址空间中. 这意味着在 4GB 的内存空间中, 只有 3GB 可以用于"),r("strong",[t._v("用户")]),t._v("应用程序.")]),t._v(" "),r("p",[t._v("一个"),r("strong",[t._v("进程只能运行在用户态(usermode)或内核态(kernelmode)下")]),t._v(". 用户程序运行在用户态下, 而系统调用运行在内核态下. 在这两种方式下所用的"),r("strong",[t._v("堆栈不一样")]),t._v(": 用户态下用的是"),r("strong",[t._v("一般的堆栈")]),t._v(", 而内核态下用的是"),r("strong",[t._v("固定大小的堆栈")]),t._v("(一般为一个内存页的大小). 每个进程都有自己的 3G 用户空间, 它们"),r("strong",[t._v("共享 1GB 的内核空间")]),t._v(". 当一个进程从用户空间进入内核空间时, 它"),r("strong",[t._v("就不再有自己的进程空间")]),t._v("了. 这也就是为什么经常说"),r("strong",[t._v("线程上下文切换会涉及到用户态到内核态的切换原因")]),t._v("所在.")]),t._v(" "),r("blockquote",[r("p",[t._v("为什么需要用户态和内核态?")])]),t._v(" "),r("p",[t._v("为什么需要两个模式? 在 CPU 的所有指令中, 有些指令是非常危险的, 如果使用不当将会造成"),r("strong",[t._v("系统崩溃")]),t._v(".")]),t._v(" "),r("p",[t._v("为避免这种情况, CPU 将指令划分为"),r("strong",[t._v("特权级(内核态)指令")]),t._v("和"),r("strong",[t._v("非特权级(用户态)指令")]),t._v(". 将可能引起损害的机器指令作为"),r("strong",[t._v("特权指令")]),t._v(", 并且硬件只有在内核模式下才允许执行特权指令. 这样可以"),r("strong",[t._v("防止操作系统和用户程序受到错误用户程序的影响")]),t._v(". 如果用户模式下系统执行特权指令, 那么硬件会认为这个指令非法而不会执行这个指令, 并将其以"),r("strong",[t._v("陷阱形式")]),t._v("通知给操作系统.")]),t._v(" "),r("h5",{attrs:{id:"_2-上下文切换"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-上下文切换"}},[t._v("#")]),t._v(" 2.上下文切换")]),t._v(" "),r("p",[t._v("多线程编程中一般"),r("strong",[t._v("线程的个数")]),t._v("都多于 CPU 核数, 而一个 CPU 核在任意时刻只能被一个线程使用, 为了让这些线程都能得到有效执行, CPU 可以采取的一种策略是为"),r("strong",[t._v("每个线程分配时间片并轮转的形式")]),t._v(". 当一个线程的"),r("strong",[t._v("时间片")]),t._v("用完的时候就会重新变成就绪状态让给其他线程使用, 这个过程就属于"),r("strong",[t._v("一次上下文切换")]),t._v(".")]),t._v(" "),r("p",[t._v("当前任务在执行完 CPU 时间片切换到另一个任务之前会先"),r("strong",[t._v("保存自己的状态")]),t._v(", 以便下次再切换回这个任务时, 可以再加载这个任务的状态. "),r("strong",[t._v("任务从保存到再加载的过程就是一次上下文切换")]),t._v(". 保存状态的时候会将当前任务在寄存器以及缓存中的"),r("strong",[t._v("数据都刷到内存")]),t._v("中, 恢复的时候又从内存中复制回来.")]),t._v(" "),r("p",[t._v("如果上下文切换过多, 对系统来说就意味着消耗大量的 CPU 时间, 可能造成较大的"),r("strong",[t._v("开销")]),t._v(".")]),t._v(" "),r("p",[r("strong",[t._v("线程上下文切换")]),t._v("过程:")]),t._v(" "),r("p",[t._v("​"),r("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220601215104553.png",alt:""}}),t._v("​")]),t._v(" "),r("blockquote",[r("p",[t._v("如何减少线程上下文切换?")])]),t._v(" "),r("p",[t._v("线程"),r("strong",[t._v("不是越多就越好")]),t._v(", 因为线程上下文切换是有"),r("strong",[t._v("性能损耗")]),t._v("的, 在使用多线程的同时需要考虑如何减少上下文切换. 一般来说有以下几条经验:")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("无锁并发编程")]),t._v(". 多线程竞争时, 会引起上下文切换, 所以多线程处理数据时, 可以用一些办法来"),r("strong",[t._v("避免使用锁")]),t._v(", 如将数据的 ID 按照 Hash 取模分段, 不同的线程处理不同段的数据.")]),t._v(" "),r("li",[r("strong",[t._v("CAS 算法")]),t._v(". Java 的 Atomic 包使用 CAS 算法来更新数据, "),r("strong",[t._v("而不需要加锁")]),t._v(".")]),t._v(" "),r("li",[r("strong",[t._v("控制线程数量")]),t._v(". 避免创建不需要的线程, 线程别创建太多.")]),t._v(" "),r("li",[r("strong",[t._v("协程")]),t._v(". 在单线程里实现多任务的调度, 并在单线程里维持多个任务间的切换. 协程可以看成是"),r("strong",[t._v('用户态自管理的 "线程"')]),t._v(" . "),r("strong",[t._v("不会参与")]),t._v(" CPU 时间调度, 没有均衡分配到时间.")]),t._v(" "),r("li",[t._v("可以考虑应用是 "),r("strong",[t._v("IO 密集型的还是 CPU 密集型")]),t._v("的. 如果是 IO 密集型, 线程可以多一些; 如果是 CPU 密集型, 线程不宜太多.")])]),t._v(" "),r("h5",{attrs:{id:"_3-切换方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-切换方式"}},[t._v("#")]),t._v(" 3.切换方式")]),t._v(" "),r("p",[r("strong",[t._v("用户态切换到内核态的几种方式:")])]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("系统调用")]),t._v(": "),r("strong",[t._v("系统调用")]),t._v("是用户态"),r("strong",[t._v("主动要求")]),t._v("切换到内核态的一种方式, 用户应用程序通过操作系统调用内核为上层应用程序开放的接口来执行程序.")]),t._v(" "),r("li",[r("strong",[t._v("异常")]),t._v(": 当 CPU 在执行用户态的应用程序时发生了某些不可知的"),r("strong",[t._v("异常")]),t._v(", 当前用户态的应用进程就会切换到处理此异常的"),r("strong",[t._v("内核程序")]),t._v("中去.")]),t._v(" "),r("li",[r("strong",[t._v("硬件设备的中断")]),t._v(": 当"),r("strong",[t._v("硬件设备完成用户请求")]),t._v("后, 会向 CPU 发出相应的中断信号, 这时 CPU 会暂停执行下一条即将要执行的指令, 转而去执行与中断信号对应的应用程序. 如果先前执行的指令是用户态下程序的指令, 那么这个转换过程也是用户态到内核台的转换.")])]),t._v(" "),r("h4",{attrs:{id:"并发与并行🌟"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#并发与并行🌟"}},[t._v("#")]),t._v(" 并发与并行🌟")]),t._v(" "),r("h5",{attrs:{id:"_1-并发-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-并发-2"}},[t._v("#")]),t._v(" 1.并发")]),t._v(" "),r("p",[r("strong",[t._v("并发")]),t._v(": 在一段时间内, 多个任务都在交替执行, 但是"),r("strong",[t._v("单位时间内不一定同时")]),t._v("执行. "),r("strong",[t._v("单核处理器也支持并发")]),t._v(", CPU 通过给每个线程分配 "),r("strong",[t._v("CPU 时间片")]),t._v("来实现这个机制. 时间片是 CPU 分配给各个线程的时间, 因为时间片非常短, 所以 CPU 通过"),r("strong",[t._v("不停地切换线程")]),t._v("执行, 让用户"),r("strong",[t._v("感觉多个线程是同时执行")]),t._v("的. 核处理器只能按受一个任务, 就把这多个任务安排"),r("strong",[t._v("轮流")]),t._v("进行, 由于时间间隔较短让人感觉这些任务在同时运行.")]),t._v(" "),r("p",[r("strong",[t._v("为什么用到并发")]),t._v("? 并发编程的本质其实就是利用"),r("strong",[t._v("多线程")]),t._v(", 在多核 CPU 下通过并发编程将多核 CPU 的计算能力发挥到极致以提升性能.")]),t._v(" "),r("p",[r("strong",[t._v("并发的优点")]),t._v(": 充分利用多核 CPU 的计算能力; 方便进行业务拆分, 提升应用性能; 使用多线程不是因为其能提升程序的执行速度, 而是为了更好地利用 CPU 资源. 此外, 面对复杂业务模型, 并行会比串行更适应业务需求.")]),t._v(" "),r("p",[r("strong",[t._v("并发产生的问题")]),t._v(": 高并发场景下, "),r("strong",[t._v("导致频繁的上下文切换")]),t._v(". 临界区线程安全问题, 容易出现死锁, 产生死锁会造成系统功能不可用.")]),t._v(" "),r("h5",{attrs:{id:"_2-并行"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-并行"}},[t._v("#")]),t._v(" 2.并行")]),t._v(" "),r("p",[r("strong",[t._v("并行")]),t._v(": "),r("strong",[t._v("单位时间内")]),t._v(", "),r("strong",[t._v("多个任务同时执行")]),t._v(". 有多个 CPU 时, "),r("strong",[t._v("不同的 CPU")]),t._v(" 同时执行不同的任务, 并行就是多个任务同时运行, 就是甲任务进行的同时, 乙任务也在进行.")]),t._v(" "),r("p",[t._v("​"),r("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220601215438576.png",alt:""}}),t._v("​")]),t._v(" "),r("blockquote",[r("p",[t._v("总结")])]),t._v(" "),r("p",[r("mark",[r("strong",[t._v('并发指的是多个任务交替进行, 而并行则是指真正意义上的 "同时进行". 如果系统只有一个 CPU, 而使用多线程时, 那么真实系统环境下不能并行, 只能通过切换时间片的方式交替进行, 而成为并发执行任务. 真正的并行也只能出现在拥有多个 CPU 的系统中')])]),t._v(".")]),t._v(" "),r("h4",{attrs:{id:"系统调用🌟"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#系统调用🌟"}},[t._v("#")]),t._v(" 系统调用🌟")]),t._v(" "),r("p",[t._v("一般运行的"),r("strong",[t._v("程序基本都是运行在用户态")]),t._v(", 如果需要进行与"),r("strong",[t._v("内核态级别的资源有关的操作")]),t._v("(如"),r("strong",[t._v("文件管理, 进程控制, 内存管理")]),t._v("等), 就需要通过"),r("mark",[r("strong",[t._v("系统调用")])]),t._v("方式向操作系统提出服务请求, 从而"),r("strong",[t._v("陷入内核")]),t._v(", 并由操作系统代为完成.")]),t._v(" "),r("p",[r("strong",[t._v("系统调用就是操作系统为应用程序提供能够访问到内核态资源的接口")]),t._v(".")]),t._v(" "),r("p",[r("strong",[t._v("系统调用")]),t._v("按功能大致可分为如下几类:")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("设备管理")]),t._v(". 完成设备的请求或释放, 以及设备启动等功能.")]),t._v(" "),r("li",[r("strong",[t._v("文件管理")]),t._v(". 完成文件的读, 写, 创建及删除等功能.")]),t._v(" "),r("li",[r("strong",[t._v("进程控制")]),t._v(". 完成进程的创建, 撤销, 阻塞及唤醒等功能.")]),t._v(" "),r("li",[r("strong",[t._v("进程通信")]),t._v(". 完成进程之间的消息传递或信号传递等功能.")]),t._v(" "),r("li",[r("strong",[t._v("内存管理")]),t._v(". 完成内存的分配, 回收以及获取作业占用内存区大小及地址等功能.")])]),t._v(" "),r("p",[t._v("Linux 系统调用实例.")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",{staticStyle:{"text-align":"center"}},[t._v("Task")]),t._v(" "),r("th",{staticStyle:{"text-align":"center"}},[t._v("Commands")])])]),t._v(" "),r("tbody",[r("tr",[r("td",{staticStyle:{"text-align":"center"}},[r("strong",[t._v("进程控制")])]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("fork(); exit(); wait();")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[r("strong",[t._v("进程通信")])]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("pipe(); shmget(); mmap();")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[r("strong",[t._v("文件操作")])]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("open(); read(); write();")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[r("strong",[t._v("设备操作")])]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("ioctl(); read(); write();")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[r("strong",[t._v("信息维护")])]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("getpid(); alarm(); sleep();")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[r("strong",[t._v("安全相关")])]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("chmod(); umask(); chown();")])])])]),t._v(" "),r("p",[t._v("下图是用户程序调用"),r("strong",[t._v("系统调用 open()")]),t._v("  的处理过程.")]),t._v(" "),r("p",[t._v("​"),r("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200915132706394.png",alt:"",title:"系统调用过程"}}),t._v("​")]),t._v(" "),r("h4",{attrs:{id:"操作系统中断"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#操作系统中断"}},[t._v("#")]),t._v(" 操作系统中断")]),t._v(" "),r("h5",{attrs:{id:"_1-中断分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-中断分类"}},[t._v("#")]),t._v(" 1.中断分类")]),t._v(" "),r("h6",{attrs:{id:"_1-外中断"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-外中断"}},[t._v("#")]),t._v(" (1)外中断")]),t._v(" "),r("p",[t._v("由 CPU 执行指令以外的"),r("strong",[t._v("事件引起")]),t._v(", 如 I/O 完成中断, 表示设备输入/输出处理已经完成, 处理器能够发送下一个输入/输出请求. 此外还有时钟中断, 控制台中断等.")]),t._v(" "),r("h6",{attrs:{id:"_2-异常"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-异常"}},[t._v("#")]),t._v(" (2)异常")]),t._v(" "),r("p",[t._v("由 CPU 执行指令的"),r("strong",[t._v("内部事件")]),t._v("引起, 如非法操作码, 地址越界, 算术溢出等.")]),t._v(" "),r("h6",{attrs:{id:"_3-陷入"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-陷入"}},[t._v("#")]),t._v(" (3)陷入")]),t._v(" "),r("p",[t._v("在用户程序中使用"),r("strong",[t._v("系统调用")]),t._v(".")]),t._v(" "),r("p",[t._v("‍")]),t._v(" "),r("p",[t._v("‍")]),t._v(" "),r("h4",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),r("ul",[r("li",[t._v("汤子瀛, 哲凤屏, 汤小丹. 计算机操作系统[M]. 西安电子科技大学出版社, 2001.")]),t._v(" "),r("li",[t._v("史蒂文斯. UNIX 环境高级编程 [M]. 人民邮电出版社, 2014.")]),t._v(" "),r("li",[r("a",{attrs:{href:"https://applied-programming.github.io/Operating-Systems-Notes/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Operating System Notes"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/2_Structures.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Operating-System Structures"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"http://cse.csusb.edu/tongyu/courses/cs460/notes/process.php",target:"_blank",rel:"noopener noreferrer"}},[t._v("Processes"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://www.slideshare.net/rkolahalam/inter-process-communication-presentation1",target:"_blank",rel:"noopener noreferrer"}},[t._v("Inter Process Communication Presentation[1]"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://blogs.cisco.com/datacenter/decoding-ucs-invicta-part-1",target:"_blank",rel:"noopener noreferrer"}},[t._v("Decoding UCS Invicta – Part 1"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://www.ibm.com/developerworks/cn/linux/l-cn-rpmdpkg/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Linux 平台上的软件包管理"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"http://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Linux 之守护进程, 僵死进程与孤儿进程"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://stackoverflow.com/questions/185899/what-is-the-difference-between-a-symbolic-link-and-a-hard-link",target:"_blank",rel:"noopener noreferrer"}},[t._v("What is the difference between a symbolic link and a hard link?"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://idea.popcount.org/2012-12-11-linux-process-states/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Linux process states"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://en.wikipedia.org/wiki/GUID_Partition_Table",target:"_blank",rel:"noopener noreferrer"}},[t._v("GUID Partition Table"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/kevinhg/article/details/7001719",target:"_blank",rel:"noopener noreferrer"}},[t._v("详解 wait 和 waitpid 函数"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/tianlesoftware/article/details/6009110",target:"_blank",rel:"noopener noreferrer"}},[t._v("IDE, SATA, SCSI, SAS, FC, SSD 硬盘类型介绍"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"http://www.mpchunter.com/s3000/akai-ib-301s-scsi-interface-for-s2800s3000/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Akai IB-301S SCSI Interface for S2800,S3000"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://en.wikipedia.org/wiki/Parallel_ATA",target:"_blank",rel:"noopener noreferrer"}},[t._v("Parallel ATA"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"http://www.thessdreview.com/our-reviews/adata-xpg-sx900-256gb-sata-3-ssd-review-expanded-capacity-and-sandforce-driven-speed/4/",target:"_blank",rel:"noopener noreferrer"}},[t._v("ADATA XPG SX900 256GB SATA 3 SSD Review – Expanded Capacity and SandForce Driven Speed"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://blogs.cisco.com/datacenter/decoding-ucs-invicta-part-1",target:"_blank",rel:"noopener noreferrer"}},[t._v("Decoding UCS Invicta – Part 1"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98",target:"_blank",rel:"noopener noreferrer"}},[t._v("硬盘"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"http://www.differencebetween.info/difference-between-sas-and-sata",target:"_blank",rel:"noopener noreferrer"}},[t._v("Difference between SAS and SATA"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/BIOS",target:"_blank",rel:"noopener noreferrer"}},[t._v("BIOS"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://www.cs.rutgers.edu/~pxk/416/notes/13-fs-studies.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("File system design case studies"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://classes.soe.ucsc.edu/cmps111/Fall08/proj4.shtml",target:"_blank",rel:"noopener noreferrer"}},[t._v("Programming Project #4"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"http://web.cs.ucla.edu/classes/fall14/cs111/scribe/11a/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("FILE SYSTEM DESIGN"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=v.exports}}]);