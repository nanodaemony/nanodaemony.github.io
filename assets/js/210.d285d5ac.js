(window.webpackJsonp=window.webpackJsonp||[]).push([[210],{513:function(v,_,t){"use strict";t.r(_);var a=t(7),s=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"_1300-大数据与空间限制题目"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1300-大数据与空间限制题目"}},[v._v("#")]),v._v(" 1300.大数据与空间限制题目")]),v._v(" "),_("h5",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),_("p",[v._v("海量数据问题常见处理方法:")]),v._v(" "),_("ul",[_("li",[v._v("Top K 问题一般都可以考虑堆排序法。")]),v._v(" "),_("li",[v._v("一般空间限制问题，就可以利用"),_("mark",[_("strong",[v._v("时间换空间的思想")])]),v._v("。将操作分成多次，然后每次单独进行处理。只需要保证每次处理互不干扰就行。比如可以对字符串采用取模的方式，第一次只处理取模结果为 0 的数据，第二次只处理取模结果为 1 的数据... 这样就把原来的数据规模降低了。在小内存就能处理了。")]),v._v(" "),_("li",[v._v("大量数判断是否存在，可以"),_("strong",[v._v("用位图的方式，也就是一个位表示一个数")]),v._v("，可以把空间省很多。")]),v._v(" "),_("li",[_("strong",[v._v("位图 BitMap")]),v._v(". 位图是以 "),_("strong",[v._v("bit 位")]),v._v("为单位进行数据存储, 这样每个字节 8 个位就可以表示 8 个数字, 普通的一个 int 占 4 个字节即 32 位, 用了位图之后可以将"),_("strong",[v._v("空间节省 32 倍")]),v._v(". 求解"),_("strong",[v._v("数据重复")]),v._v("的问题, 一般首先考虑"),_("strong",[v._v("位图法")]),v._v(", 比如找出没有出现的数, 找出"),_("strong",[v._v("出现两次")]),v._v("的数, 找出"),_("strong",[v._v("不重复")]),v._v("的电话号码.")]),v._v(" "),_("li",[_("strong",[v._v("分治法")]),v._v(": 将大文件"),_("strong",[v._v("求哈希")]),v._v("进行分别计算, 最后统一计算即可.")])]),v._v(" "),_("h5",{attrs:{id:"如何从大量数据中找出高频词"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何从大量数据中找出高频词"}},[v._v("#")]),v._v(" 如何从大量数据中找出高频词?")]),v._v(" "),_("h6",{attrs:{id:"题目描述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题目描述"}},[v._v("#")]),v._v(" 题目描述")]),v._v(" "),_("p",[v._v("有一个 1GB 大小的文件, 文件里每一行是一个词, "),_("strong",[v._v("每个词的大小不超过 16B")]),v._v(", 内存大小限制是 1MB, 要求返回"),_("strong",[v._v("频数最高的 100 个词(Top 100)")]),v._v(" .")]),v._v(" "),_("h6",{attrs:{id:"解答思路"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解答思路"}},[v._v("#")]),v._v(" 解答思路")]),v._v(" "),_("p",[v._v("由于内存限制, 所以无法直接将大文件的所有词一次读到内存中. 因此, 同样可以采用"),_("strong",[v._v("分治策略")]),v._v(", 把一个大文件分解成多个小文件, 保证每个文件的大小小于 1MB, 进而直接将单个小文件读取到内存中进行处理.")]),v._v(" "),_("p",[_("strong",[v._v("思路如下")]),v._v(":")]),v._v(" "),_("p",[v._v("首先遍历大文件, 对遍历到的每个词 x, 执行 "),_("code",[v._v("hash(x) % 5000")]),v._v("​, 将结果为 i 的词存放到文件 "),_("code",[v._v("a(i)")]),v._v("​ 中. 遍历结束后, 可以得到 5000 个小文件. 每个小文件的大小为 200KB 左右. 如果有的小文件大小仍然超过 1MB, 则采用同样的方式继续进行分解.")]),v._v(" "),_("p",[_("strong",[v._v("接着统计每个小文件中出现频数最高的 100 个词")]),v._v(". 最简单的方式是使用 HashMap 实现. 其中 key 为词, value 为该词出现的频率. 具体方法是: 对于遍历到的词 x, 如果在 map 中不存在, 则执行 "),_("code",[v._v("map.put(x, 1)")]),v._v("​; 若存在, 则执行 "),_("code",[v._v("map.put(x, map.get(x) + 1)")]),v._v("​, 将该词频数加 1.")]),v._v(" "),_("p",[v._v("上面统计了每个小文件单词出现的频数. 接下来, 可以通过维护一个"),_("strong",[v._v("小顶堆")]),v._v("来找出所有词中出现频数最高的 100 个. 具体方法是: 依次遍历每个小文件, 构建一个"),_("strong",[v._v("小顶堆")]),v._v(", 堆大小为 100. "),_("strong",[v._v("如果遍历到的词的出现次数大于堆顶词的出现次数, 则用新词替换堆顶的词")]),v._v(", 然后重新调整为"),_("strong",[v._v("小顶堆")]),v._v(", 遍历结束后, 小顶堆上的词就是出现频数最高的 100 个词.")]),v._v(" "),_("h6",{attrs:{id:"方法总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法总结"}},[v._v("#")]),v._v(" 方法总结")]),v._v(" "),_("ol",[_("li",[v._v("分而治之, 进行哈希取余.")]),v._v(" "),_("li",[v._v("使用 HashMap 统计频数.")]),v._v(" "),_("li",[v._v("求解"),_("strong",[v._v("最大")]),v._v("的 TopN 个, 用"),_("strong",[v._v("小顶堆")]),v._v("; 求解"),_("strong",[v._v("最小")]),v._v("的 TopN 个, 用"),_("strong",[v._v("大顶堆")]),v._v(".")])]),v._v(" "),_("h5",{attrs:{id:"如何找出某一天访问百度网站最多的ip"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何找出某一天访问百度网站最多的ip"}},[v._v("#")]),v._v(" 如何找出某一天访问百度网站最多的IP?")]),v._v(" "),_("h6",{attrs:{id:"题目描述-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题目描述-2"}},[v._v("#")]),v._v(" 题目描述")]),v._v(" "),_("p",[v._v("现有海量日志数据保存在一个超大文件中, 该"),_("strong",[v._v("文件无法直接读入内存")]),v._v(", 要求从中提取某天访问百度次数最多的那个 IP.")]),v._v(" "),_("h6",{attrs:{id:"解答思路-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解答思路-2"}},[v._v("#")]),v._v(" 解答思路")]),v._v(" "),_("p",[v._v("这道题只关心某一天访问百度最多的 IP, 因此, 可以首先对文件进行一次遍历, "),_("strong",[v._v("把这一天访问百度 IP 的相关信息记录到一个单独的大文件中")]),v._v(". 接下来采用的方法与上一题一样, 大致就是先"),_("strong",[v._v("对 IP 进行哈希映射, 接着使用 HashMap 统计重复 IP 的次数, 最后计算出重复次数最多的 IP")]),v._v(".")]),v._v(" "),_("p",[v._v("注: 这里只需要找出出现次数最多的 IP, 可以不必使用堆, 直接用一个变量 max 即可.")]),v._v(" "),_("p",[_("strong",[v._v("找出大文件中的出现次数最多的数字也可以用类似的方法，本质就是将大范围的数据进行分解处理，每次只处理一部分，最后再汇总")]),v._v("。")]),v._v(" "),_("h6",{attrs:{id:"方法总结-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法总结-2"}},[v._v("#")]),v._v(" 方法总结")]),v._v(" "),_("ol",[_("li",[v._v("分而治之, 进行哈希取余.")]),v._v(" "),_("li",[v._v("使用 HashMap 统计频数.")]),v._v(" "),_("li",[v._v("求解"),_("strong",[v._v("最大")]),v._v("的 TopN 个, 用"),_("strong",[v._v("小顶堆")]),v._v("; 求解"),_("strong",[v._v("最小")]),v._v("的 TopN 个, 用"),_("strong",[v._v("大顶堆")]),v._v(".")])]),v._v(" "),_("h5",{attrs:{id:"如何在大量的数据中找出不重复的整数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何在大量的数据中找出不重复的整数"}},[v._v("#")]),v._v(" 如何在大量的数据中找出不重复的整数?")]),v._v(" "),_("h6",{attrs:{id:"题目描述-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题目描述-3"}},[v._v("#")]),v._v(" 题目描述")]),v._v(" "),_("p",[v._v("在 2.5 亿个整数中找出"),_("strong",[v._v("不重复的整数")]),v._v(". 注意: 内存不足以容纳这 2.5 亿个整数.")]),v._v(" "),_("h6",{attrs:{id:"位图法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#位图法"}},[v._v("#")]),v._v(" 位图法")]),v._v(" "),_("p",[_("strong",[v._v("位图")]),v._v("就是用一个或多个 bit 来标记某个元素对应的值, 而键就是该元素. "),_("strong",[v._v("采用位作为单位来存储数据, 可以大大节省存储空间")]),v._v(".")]),v._v(" "),_("p",[v._v("位图通过使用位数组来表示某些元素是否存在. 它可以用于快速查找, 判重, 排序等. 举个例子.")]),v._v(" "),_("p",[v._v("假设要对 "),_("code",[v._v("[0, 7]")]),v._v("​ 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序, 可以采用位图法. 0 ~ 7 范围总共有 8 个数, 只需要 8bit, 即 1 个字节. 首先将每个位都置 0:")]),v._v(" "),_("div",{staticClass:"language-java line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("p",[v._v("然后遍历 5 个元素, 首先遇到 6, 那么将下标为 6 的位的 0 置为 1; 接着遇到 4, 把下标为 4 的位的 0 置为 1:")]),v._v(" "),_("div",{staticClass:"language-java line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("p",[v._v("依次遍历, 结束后, 位数组是这样的:")]),v._v(" "),_("div",{staticClass:"language-java line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("0")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("p",[v._v("每个为 1 的位, 它的下标都表示了一个数:")]),v._v(" "),_("div",{staticClass:"language-java line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("for")]),v._v(" i in "),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("range")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("8")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("if")]),v._v(" bits"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("[")]),v._v("i"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("]")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("==")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v("\n        "),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("print")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("i"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br")])]),_("p",[v._v("这样其实就已经实现了排序.")]),v._v(" "),_("p",[v._v("对于整数相关的算法的求解, "),_("strong",[v._v("位图法")]),v._v("是一种非常实用的算法. 假设 int 整数占用 4B, 即 32bit, 那么可以表示的整数的个数为 2^32.")]),v._v(" "),_("p",[v._v("那么对于这道题, "),_("strong",[v._v("用 2 个 bit 来表示各个数字的状态")]),v._v(":")]),v._v(" "),_("ul",[_("li",[v._v("00 表示这个数字没出现过.")]),v._v(" "),_("li",[_("strong",[v._v("01 表示这个数字出现过一次(即为题目所找的不重复整数)")]),v._v(" .")]),v._v(" "),_("li",[v._v("10 表示这个数字出现了多次.")])]),v._v(" "),_("p",[v._v("那么这 "),_("code",[v._v("2^32")]),v._v("​ 个整数, 总共所需内存为 "),_("code",[v._v("2^32 * 2b = 1GB")]),v._v("​. 因此, 当可用内存超过 1GB 时, 可以采用位图法. 假设内存满足位图法需求, 进行下面的操作:")]),v._v(" "),_("p",[v._v("遍历 2.5 亿个整数, 查看位图中对应的位, 如果是 00, 则变为 01, 如果是 01 则变为 10, 如果是 10 则保持不变. "),_("strong",[v._v("遍历结束后, 查看位图, 把对应位是 01 的整数输出即可")]),v._v(".")]),v._v(" "),_("h6",{attrs:{id:"方法总结-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法总结-3"}},[v._v("#")]),v._v(" 方法总结")]),v._v(" "),_("p",[_("strong",[v._v("判断数字是否重复的问题")]),v._v(", 位图法是一种非常高效的方法.")]),v._v(" "),_("h5",{attrs:{id:"如何在大量的数据中判断一个数是否存在"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何在大量的数据中判断一个数是否存在"}},[v._v("#")]),v._v(" 如何在大量的数据中判断一个数是否存在?")]),v._v(" "),_("h6",{attrs:{id:"题目描述-4"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题目描述-4"}},[v._v("#")]),v._v(" 题目描述")]),v._v(" "),_("p",[v._v("给定 40 亿个不重复的"),_("strong",[v._v("没排过序")]),v._v("的 unsigned int 型整数, 然后再给定一个数, 如何快速判断这个数是否在这 40 亿个整数当中?")]),v._v(" "),_("h6",{attrs:{id:"位图法-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#位图法-2"}},[v._v("#")]),v._v(" 位图法")]),v._v(" "),_("p",[v._v("40 亿个不重复整数, "),_("strong",[v._v("用 40 亿个 bit 来表示")]),v._v(", 初始位均为 0, 那么总共需要内存: "),_("code",[v._v("4000000000b ≈ 512M")]),v._v("​.")]),v._v(" "),_("p",[v._v("读取这 40 亿个整数, 将对应的 bit 设置为 1. 接着读取要查询的数, 查看相应位是否为 1, 如果为 1 表示存在, 如果为 0 表示不存在.")]),v._v(" "),_("p",[_("strong",[v._v("进阶")]),v._v(": 内存限制到 10M. 这个时候可以将所有数据分成 "),_("strong",[v._v("50 个组")]),v._v(", 也就是一个"),_("strong",[v._v("数 num / 67108864 的结果就是其组的序号")]),v._v(", 然后一个组一个组单独使用位图进行寻找.")]),v._v(" "),_("h6",{attrs:{id:"方法总结-4"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法总结-4"}},[v._v("#")]),v._v(" 方法总结")]),v._v(" "),_("p",[_("strong",[v._v("判断数字是否存在, 判断数字是否重复的问题")]),v._v(", 位图法是一种非常高效的方法.")]),v._v(" "),_("h5",{attrs:{id:"如何查询最热门的查询串"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何查询最热门的查询串"}},[v._v("#")]),v._v(" 如何查询最热门的查询串?")]),v._v(" "),_("h6",{attrs:{id:"题目描述-5"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题目描述-5"}},[v._v("#")]),v._v(" 题目描述")]),v._v(" "),_("p",[v._v("搜索引擎会通过"),_("strong",[v._v("日志文件")]),v._v("把用户每次检索使用的所有查询串都记录下来, 每个查询串的"),_("strong",[v._v("长度不超过 255 字节")]),v._v(".")]),v._v(" "),_("p",[v._v("假设目前有 1000w 个记录(这些查询串的重复度比较高, 虽然总数是 1000w, 但如果除"),_("strong",[v._v("去重")]),v._v("后, 则不超过 300w 个). 请统计"),_("strong",[v._v("最热门的 10 个查询串")]),v._v(", 要求使用的内存不能超过 1G. (一个查询串的重复度越高, 说明查询它的用户越多, 也就越热门.)")]),v._v(" "),_("p",[v._v("每个查询串最长为 255B, 1000w 个串需要占用约 2.55G 内存, 因此无法将所有字符串全部读入到内存中处理.")]),v._v(" "),_("h6",{attrs:{id:"分治法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分治法"}},[v._v("#")]),v._v(" 分治法")]),v._v(" "),_("p",[v._v("分治法依然是一个非常实用的方法. "),_("strong",[v._v("划分为多个小文件, 保证单个小文件中的字符串能被直接加载到内存中处理, 然后求出每个文件中出现次数最多的 10 个字符串; 最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串")]),v._v(".")]),v._v(" "),_("p",[v._v("方法可行, 但不是最好, 下面介绍其他方法.")]),v._v(" "),_("h6",{attrs:{id:"hashmap法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hashmap法"}},[v._v("#")]),v._v(" HashMap法")]),v._v(" "),_("p",[v._v("虽然字符串总数比较多, 但去重后"),_("strong",[v._v("不超过 300w")]),v._v(", 因此可以考虑把所有字符串及出现次数保存在一个 HashMap 中, 所占用的空间为 300w*(255+4)≈777M(其中, 4 表示整数占用的 4 个字节). 由此可见, 1G 的内存空间完全够用.")]),v._v(" "),_("p",[_("strong",[v._v("思路如下")]),v._v(":")]),v._v(" "),_("p",[v._v("首先, 遍历字符串, 若不在 map 中, 直接存入 map, value 记为 1; 若在 map 中, 则把对应的 value 加 1, 这一步时间复杂度 "),_("code",[v._v("O(N)")]),v._v("​.")]),v._v(" "),_("p",[v._v("接着遍历 map, 构建一个 10 个元素的"),_("strong",[v._v("小顶堆")]),v._v(", 若遍历到的字符串的出现次数大于堆顶字符串的出现次数, 则进行替换, 并将堆调整为小顶堆.")]),v._v(" "),_("p",[v._v("遍历结束后, 堆中 10 个字符串就是出现次数最多的字符串. 这一步时间复杂度 "),_("code",[v._v("O(Nlog10)")]),v._v("​.")]),v._v(" "),_("h6",{attrs:{id:"前缀树法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前缀树法"}},[v._v("#")]),v._v(" 前缀树法")]),v._v(" "),_("p",[v._v("方法二使用了 HashMap 来统计次数, 当这些"),_("strong",[v._v("字符串有大量相同前缀")]),v._v("时, 可以考虑使用前缀树来统计字符串出现的次数, "),_("strong",[v._v("树的结点保存字符串出现次数, 0 表示没有出现")]),v._v(".")]),v._v(" "),_("p",[_("strong",[v._v("思路如下")]),v._v(":")]),v._v(" "),_("p",[v._v("在遍历字符串时, "),_("strong",[v._v("在前缀树中查找, 如果找到, 则把结点中保存的字符串次数加 1")]),v._v(", 否则为这个字符串构建新结点, 构建完成后把叶子结点中字符串的出现次数置为 1. 最后依然使用小顶堆来对字符串的出现次数进行排序. 前缀树经常被用来统计字符串的出现次数. 它的另外一个大的用途是字符串查找, 判断是否有重复的字符串等.")]),v._v(" "),_("h5",{attrs:{id:"如何统计不同电话号码的个数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何统计不同电话号码的个数"}},[v._v("#")]),v._v(" 如何统计不同电话号码的个数?")]),v._v(" "),_("h6",{attrs:{id:"题目描述-6"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题目描述-6"}},[v._v("#")]),v._v(" 题目描述")]),v._v(" "),_("p",[v._v("已知某个文件内包含一些电话号码, 每个号码为 8 位数字, 统计"),_("strong",[v._v("不同号码的个数")]),v._v(".")]),v._v(" "),_("h6",{attrs:{id:"位图法-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#位图法-3"}},[v._v("#")]),v._v(" 位图法")]),v._v(" "),_("p",[v._v("这道题本质还是求解"),_("mark",[_("strong",[v._v("数据重复")])]),v._v("的问题, 对于这类问题, 一般首先考虑"),_("mark",[_("strong",[v._v("位图法")])]),v._v(".")]),v._v(" "),_("p",[v._v("对于本题, 8 位电话号码可以表示的号码个数为 "),_("code",[v._v("10^8")]),v._v("​ 个, 即 1 亿个. "),_("strong",[v._v("每个号码用一个 bit 来表示, 则总共需要 1 亿个 bit, 内存占用约 100M")]),v._v(".")]),v._v(" "),_("p",[_("strong",[v._v("思路如下")]),v._v(":")]),v._v(" "),_("p",[v._v("申请一个位图数组, 长度为 1 亿, 初始化为 0. 然后遍历所有电话号码, 把号码对应的位图中的位置置为 1. 遍历完成后, 如果 bit 为 1, 则表示这个电话号码在文件中存在, 否则不存在. bit 值为 1 的数量即为不同电话号码的个数.")]),v._v(" "),_("h5",{attrs:{id:"如何从5亿个数中找出中位数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何从5亿个数中找出中位数"}},[v._v("#")]),v._v(" 如何从5亿个数中找出中位数?")]),v._v(" "),_("h6",{attrs:{id:"题目描述-7"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题目描述-7"}},[v._v("#")]),v._v(" 题目描述")]),v._v(" "),_("p",[v._v("从 5 亿个数中找出"),_("strong",[v._v("中位数")]),v._v(". 数据排序后, 位置在最中间的数就是中位数. 当样本数为奇数时, 中位数为 第 "),_("code",[v._v("(N + 1) / 2")]),v._v("​ 个数; 当样本数为偶数时, 中位数为第 "),_("code",[v._v("N / 2")]),v._v("​ 个数与第 "),_("code",[v._v("1 + N / 2")]),v._v("​ 个数的平均值.")]),v._v(" "),_("h6",{attrs:{id:"双堆法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#双堆法"}},[v._v("#")]),v._v(" 双堆法")]),v._v(" "),_("p",[v._v("维护两个堆, 一个大顶堆, 一个小顶堆. 大顶堆中最大的数"),_("strong",[v._v("小于等于")]),v._v("小顶堆中最小的数; "),_("strong",[v._v("保证这两个堆中的元素个数的差不超过 1")]),v._v(".")]),v._v(" "),_("p",[v._v("若数据总数为"),_("strong",[v._v("偶数")]),v._v(", 当这两个堆建好之后, "),_("strong",[v._v("中位数就是这两个堆顶元素的平均值")]),v._v(". 当数据总数为"),_("strong",[v._v("奇数")]),v._v("时, 根据两个堆的大小, "),_("strong",[v._v("中位数一定在数据多的堆的堆顶")]),v._v(".")]),v._v(" "),_("blockquote",[_("p",[v._v("这个解法可以参考力扣 295: "),_("a",{attrs:{href:"https://leetcode.com/problems/find-median-from-data-stream/",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://leetcode.com/problems/find-median-from-data-stream/"),_("OutboundLink")],1)])]),v._v(" "),_("p",[v._v("以上这种方法, 需要把所有数据都加载到内存中. 当数据量很大时, 就不能这样了, 因此这种方法"),_("strong",[v._v("适用于数据量较小的情况")]),v._v(". 5 亿个数, 每个数字占用 4B, 总共需要 2G 内存. 如果可用内存不足 2G, 就不能使用这种方法了, 下面介绍另一种方法.")]),v._v(" "),_("h6",{attrs:{id:"分治法-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分治法-2"}},[v._v("#")]),v._v(" 分治法")]),v._v(" "),_("p",[v._v("分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解.")]),v._v(" "),_("p",[v._v("对于这道题, 顺序读取这 5 亿个数字, 对于读取到的数字 num, "),_("strong",[v._v("如果它对应的二进制中最高位为 1, 则把这个数字写到 f1 中, 否则写入 f0 中")]),v._v(". 通过这一步, 可以把这 5 亿个数"),_("strong",[v._v("划分为两部分")]),v._v(", 而且 f0 中的数都大于 f1 中的数(最高位是符号位).")]),v._v(" "),_("p",[v._v("划分之后, 可以非常容易地知道中位数是在 f0 还是 f1 中. 假设 f1 中有 1 亿个数, 那么中位数一定在 f0 中, 且是在 f0 中, 从小到大排列的第 1.5 亿个数与它后面的一个数的平均值.")]),v._v(" "),_("p",[v._v("提示: 5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值. 若 f1 有一亿个数, 那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值.")]),v._v(" "),_("p",[v._v("对于 f0 可以用次高位的二进制继续将文件一分为二, 如此划分下去, 直到划分后的文件可以被加载到内存中, 把数据加载到内存中以后直接排序, 找出中位数.")]),v._v(" "),_("p",[v._v("**注意: ** 当数据总数为偶数, 如果划分后两个文件中的数据有相同个数, 那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值.")]),v._v(" "),_("h5",{attrs:{id:"两个大文件中找出共同记录"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#两个大文件中找出共同记录"}},[v._v("#")]),v._v(" 两个大文件中找出共同记录")]),v._v(" "),_("h6",{attrs:{id:"题目描述-8"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题目描述-8"}},[v._v("#")]),v._v(" 题目描述")]),v._v(" "),_("p",[v._v("给定 a, b 两个文件, 各存放 50 亿个 url, 每个 url 各占 64 字节, 内存限制是 4G, 找出 a, b 文件共同的 url.")]),v._v(" "),_("h6",{attrs:{id:"分治法-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分治法-3"}},[v._v("#")]),v._v(" 分治法")]),v._v(" "),_("p",[v._v("首先最常想到的方法是读取文件 a, 建立哈希表方便后面查找, 然后再读取文件 b, 遍历文件 b 中每个 url, 对于每个遍历, 都执行查找 hash 表的操作, 若 hash 表中搜索到了, 则说明两文件共有, 存入一个集合. 可以估计每个文件安的大小为 5G×64 =320G, 远远大于内存限制的 4G. 所以不可能将其完全加载到内存中处理.")]),v._v(" "),_("p",[v._v("针对上述问题, 可以采用"),_("strong",[v._v("分治算法的思想")]),v._v(".")]),v._v(" "),_("ul",[_("li",[v._v("遍历文件 a, 对每个 url 求取 "),_("code",[v._v("hash(url) % 1000")]),v._v("​, 然后根据所取得的值将 url 分别存储到 1000 个小文件(记为 a0,a1,...,a999 每个小文件约 300M), 为什么是 1000? 主要根据内存大小和要分治的文件大小来计算, 就大致可以把 320G 大小分为 1000 份, 每份大约 300M(当然, 到底能不能分布尽量均匀, 得看 hash 函数的设计)")]),v._v(" "),_("li",[v._v("遍历文件 b, 采取和 a 相同的方式将 url 分别存储到 1000 个小文件(记为 b0,b1,...,b999). 为什么要这样做? 文件 a 的 hash 映射和文件 b 的 hash 映射函数要保持一致, 这样的话相同的 url 就会保存在对应的小文件中, 比如, 如果 a 中有一个 url 记录 data1 被 hash 到了 a99 文件中, 那么如果 b 中也有相同 url, 则一定被 hash 到了 b99 中. 所以现在问题转换成了: 找出 1000 对小文件中每一对相同的 url("),_("strong",[v._v("不对应的小文件不可能有相同的 url")]),v._v(").")]),v._v(" "),_("li",[v._v("求每对小文件中相同的 url 时, 可以把其中一个小文件的 url 存储到 HashSet 中. 然后遍历另一个小文件的每个 url, 看其是否在刚才构建的 HashSet 中, 如果是那么就是共同的 url, 存到文件里面就可以了.")])]),v._v(" "),_("p",[v._v("其实本质上就是利用哈希，将原来的大文件变相拆分为多个小文件，然后依次统计小文件的共同记录。")]),v._v(" "),_("h6",{attrs:{id:"布隆过滤器法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#布隆过滤器法"}},[v._v("#")]),v._v(" 布隆过滤器法")]),v._v(" "),_("p",[v._v("如果"),_("strong",[v._v("允许有一定的错误率, 可以使用 Bloom filter")]),v._v(", 4G 内存大概可以表示 340 亿 bit. 将其中一个文件中的 url 使用 Bloom filter 映射为这 340 亿 bit, 然后挨个读取另外一个文件的 url, 检查是否与 Bloom filter, 如果是, 那么该 url 应该是共同的 url(注意会有一定的错误率).")]),v._v(" "),_("h5",{attrs:{id:"如果有一个500g的超大文件-里面都是数值-如何对这些数值排序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如果有一个500g的超大文件-里面都是数值-如何对这些数值排序"}},[v._v("#")]),v._v(" 如果有一个500G的超大文件,里面都是数值,如何对这些数值排序?")]),v._v(" "),_("p",[v._v("首先, 对于这个这样一个问题, 肯定不能直接一次性全部将数据加载到内存里面.")]),v._v(" "),_("p",[v._v("解决思路:")]),v._v(" "),_("p",[v._v("(1) "),_("strong",[v._v("先将这个文件里面的值拆分成多个文件, 每个文件大小差不多 512M.")])]),v._v(" "),_("p",[v._v("(2) 在这 1000 个小文件里面的值进行"),_("strong",[v._v("排序去重")]),v._v(". 分两种情况:")]),v._v(" "),_("ul",[_("li",[v._v("如果里面的数值不是很大, 这样拼接 1000 文件数值, 拼接, 去重, 排序. 对于 8G 的内存计算机应该是可以处理的.")]),v._v(" "),_("li",[v._v("文件里面的数值就是非常的大.")])]),v._v(" "),_("p",[v._v("(3) 对于第二种情况的处理也很简单, 对于 1000 小文件, 比如就按升序排序, 不是已经拿到了每个的排序么. 可以把 1000 个文件里面最小的值(也就是第一个)拿出来, 并把他们从这些文件中删除, 拿这些最小值去重排序作为第一个文件,")]),v._v(" "),_("p",[v._v("(4) 重复上面的步骤, 这样也得到 1000 个这样排好序的文件.")]),v._v(" "),_("p",[v._v("举例:")]),v._v(" "),_("p",[v._v("如果有个文件(-1, 5, 2, 1, 4, 3, 2, 4, 5).")]),v._v(" "),_("p",[v._v("第一步: 截取, 每 3 个一个文件得到(-1, 5, 2), (1, 4, 3), (2, 4, 5).")]),v._v(" "),_("p",[v._v("第二步: 去重排序 (-1, 2, 5), (1, 3, 4), (2, 4, 5).")]),v._v(" "),_("p",[v._v("第三步: 拿第一个去重排序得到新的 3 个小文件 (-1, 1, 2), (2, 3, 4), (4, 5).")]),v._v(" "),_("p",[v._v("看到了吧! 按从小到大的顺序就出来了, 这样最后都知道 (-1, 5, 2, 1, 4, 3, 2, 4, 5) 文件从小到大的顺序是 -1, 1, 2, 3, 4, 5.")]),v._v(" "),_("p",[v._v("‍")]),v._v(" "),_("p",[v._v("‍")]),v._v(" "),_("h4",{attrs:{id:"参考资料"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[v._v("#")]),v._v(" 参考资料")]),v._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://www.cnblogs.com/chenhuan001/p/5866916.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("海量数据处理: 十道面试题与十个海量数据处理方法总结 - chenhuan001 - 博客园"),_("OutboundLink")],1)]),v._v(" "),_("li",[_("a",{attrs:{href:"https://blog.csdn.net/qq_21688757/article/details/53993096",target:"_blank",rel:"noopener noreferrer"}},[v._v("大数据和空间限制问题专题(一) - CSDN博客"),_("OutboundLink")],1)]),v._v(" "),_("li",[_("a",{attrs:{href:"https://github.com/ZuoAndroid/Interview-Book/blob/df3b37cf80de59015c6c3651b1e588d9cbeac889/%E9%9D%A2%E8%AF%95%E9%A2%98/2018-03-31-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%88%E5%B8%B8%E8%A7%81%E7%9A%847%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98.md",target:"_blank",rel:"noopener noreferrer"}},[v._v("Interview-Book/2018-03-31-数据分析师常见的7道面试题.md"),_("OutboundLink")],1)])]),v._v(" "),_("p",[v._v("‍")]),v._v(" "),_("p",[v._v("‍")]),v._v(" "),_("p",[v._v("‍")])])}),[],!1,null,null,null);_.default=s.exports}}]);