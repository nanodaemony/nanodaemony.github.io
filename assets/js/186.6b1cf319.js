(window.webpackJsonp=window.webpackJsonp||[]).push([[186],{515:function(_,v,t){"use strict";t.r(v);var s=t(4),r=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"_401-mysql复制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_401-mysql复制"}},[_._v("#")]),_._v(" 401.MySQL复制")]),_._v(" "),v("h4",{attrs:{id:"概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[_._v("#")]),_._v(" 概述")]),_._v(" "),v("p",[_._v("复制解决的基本问题是让一台服务器的数据与其他服务器保持同步. 一台主库的数据可以同步到多台备库上, 备库本身也可以被配置成另外一台服务器的主库. 主库和备库之间可以有多种不同的组合方式.")]),_._v(" "),v("p",[_._v("MySQL支持两种复制方式: "),v("strong",[_._v("基于行的复制和基于语句的复制")]),_._v(". 这两种方式都是通过在"),v("strong",[_._v("主库上记录二进制日志, 在备库重放日志")]),_._v("的方式来实现异步的数据复制. 这意味着在同一时间点备库上的数据可能与主库存在不一致, 并且无法保证主备之间的延迟. 一些大的语句可能导致备库产生几秒, 几分钟甚至几个小时的延迟.")]),_._v(" "),v("p",[_._v("复制通常不会增加主库的开销, 主要是启用二进制日志带来的开销, 但出于备份或及时从崩溃中恢复的目的, 这点开销也是必要的. 除此之外, 每个备库也会对主库增加一些负载(例如网络I/O开销), 尤其当备库请求从主库读取旧的二进制日志文件时, 可能会造成更高的I/O开销. 另外锁竞争也可能阻碍事务的提交. 最后, 如果是从一个高吞吐量(例如5000或更高的TPS)的主库上复制到多个备库, 唤醒多个复制线程发送事件的开销将会累加.")]),_._v(" "),v("h4",{attrs:{id:"复制流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#复制流程"}},[_._v("#")]),_._v(" 复制流程")]),_._v(" "),v("h5",{attrs:{id:"_1-基本流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本流程"}},[_._v("#")]),_._v(" 1.基本流程")]),_._v(" "),v("p",[_._v("基于行的复制和基于语句的复制都有如下复制流程.")]),_._v(" "),v("ul",[v("li",[_._v("在主库上把数据更改记录到二进制日志(Binary Log)中(这些记录被称为二进制日志事件).")]),_._v(" "),v("li",[_._v("备库将主库上的日志复制到自己的中继日志(Relay Log)中.")]),_._v(" "),v("li",[_._v("备库读取中继日志中的事件, 将其重放到备库数据之上.")])]),_._v(" "),v("p",[_._v("下面的图是主节点复制数据给从节点.")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563519695873.png",alt:""}})]),_._v(" "),v("p",[_._v("第一步, 在主库上记录二进制日志. 在每次准备提交事务完成数据更新前, 主库将数据更新的事件记录到二进制日志中. MySQL会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志. 在记录二进制日志后, 主库会告诉存储引擎可以提交事务了.")]),_._v(" "),v("p",[_._v("第二步, 备库将主库的二进制日志复制到其本地的中继日志中. 首先, 备库会启动一个工作线程, 称为I/O线程, I/O线程跟主库建立一个普通的客户端连接, 然后在主库上启动一个特殊的二进制转储(binlog dump)线程(该线程没有对应的SQL命令), 这个二进制转储线程会读取主库上二进制日志中的事件. 它不会对事件进行轮询. 如果该线程追赶上了主库, 它将进入睡眠状态, 直到主库发送信号量通知其有新的事件产生时才会被唤醒, 备库I/O线程会将接收到的事件记录到中继日志中.")]),_._v(" "),v("p",[_._v("第三步, 备库的SQL线程从中继日志中读取事件并在备库执行, 从而实现备库数据的重放更新. 当SQL线程追赶上I/O线程时, 中继日志通常已经在系统缓存中, 所以中继日志的开销很低. SQL线程执行的事件也可以通过配置选项来决定是否写入其自己的二进制日志中, 它对于我们稍后提到的场景非常有用.")]),_._v(" "),v("p",[_._v("这种复制架构实现了获取事件和重放事件的解耦, 允许这两个过程异步进行. 也就是说I/O线程能够独立于SQL线程之外工作. 但这种架构也限制了复制的过程, 其中"),v("strong",[_._v("最重要的一点是在")]),_._v("​**==主库上并发运行的查询在备库只能串行化执行=="),v("strong",[_._v(", 因为")]),_._v("只有一个SQL线程来重放中继日志中的事件**, 这是很多工作负载的性能瓶颈所在.")]),_._v(" "),v("h5",{attrs:{id:"_2-相关线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-相关线程"}},[_._v("#")]),_._v(" 2.相关线程")]),_._v(" "),v("p",[_._v("主要涉及三个线程: "),v("strong",[_._v("binlog 线程, I/O 线程和 SQL 线程")]),_._v(".")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("binlog 线程")]),_._v(": 负责将"),v("strong",[_._v("主服务器上的数据")]),_._v("更改写入"),v("strong",[_._v("二进制日志")]),_._v("(binlog)中.")]),_._v(" "),v("li",[v("strong",[_._v("I/O 线程")]),_._v(": 负责"),v("strong",[_._v("从主服务器上读取二进制日志")]),_._v(", 并写入从服务器的"),v("strong",[_._v("中继日志")]),_._v("(Relay log).")]),_._v(" "),v("li",[v("strong",[_._v("SQL 线程")]),_._v(": 负责"),v("strong",[_._v("读取中继日志")]),_._v(", 解析出主服务器已经执行的数据更改并在"),v("strong",[_._v("从服务器中执行")]),_._v(".")])]),_._v(" "),v("p",[_._v("主库将"),v("strong",[_._v("变更写入 binlog 日志")]),_._v(", 然后从库连接到主库之后, 从库有一个 "),v("strong",[_._v("IO 线程")]),_._v(", 将主库的 binlog 日志"),v("strong",[_._v("拷贝到自己本地")]),_._v(", 写入一个 "),v("strong",[_._v("relay 中继日志")]),_._v("中. 接着从库中有一个 "),v("strong",[_._v("SQL 线程会从中继日志读取 binlog")]),_._v(", 然后执行 binlog 日志中的内容, 也就是在自己"),v("strong",[_._v("本地再次执行一遍 SQL")]),_._v(", 这样就可以保证自己跟主库的数据是一样的.")]),_._v(" "),v("h4",{attrs:{id:"复制配置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#复制配置"}},[_._v("#")]),_._v(" 复制配置")]),_._v(" "),v("p",[_._v("有许多参数来控制复制, 其中一些会对数据安全和性能产生影响. 稍后我们会解释何种规则在何时会失效. 本小节推荐的一种“安全”的配置, 可以最小化问题发生的概率.")]),_._v(" "),v("p",[_._v("在主库上二进制日志最重要的选项是 sync_binlog:")]),_._v(" "),v("p",[_._v("sync_binlog=1\n如果开启该选项, "),v("strong",[_._v("MySQL每次在提交事务前会将二进制日志同步到磁盘上, 保证在服务器崩溃时不会丢失事件")]),_._v(". 如果禁止该选项, 服务器会少做一些工作, 但二进制日志文件可能在服务器崩溃时损坏或丢失信息. 在一个不需要作为主库的备库上, 该选项带来了不必要的开销. 它只适用于二进制日志, 而非中继日志.")]),_._v(" "),v("h4",{attrs:{id:"复制方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#复制方式"}},[_._v("#")]),_._v(" 复制方式")]),_._v(" "),v("h5",{attrs:{id:"_1-基于语句的复制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-基于语句的复制"}},[_._v("#")]),_._v(" 1.基于语句的复制")]),_._v(" "),v("p",[_._v("基于语句的复制模式下, 主库会"),v("strong",[_._v("记录那些造成数据更改的查询 SQL 语句")]),_._v(", 当备库读取并重放这些事件时, 实际上只是"),v("strong",[_._v("把主库上执行过的SQL再执行一遍")]),_._v(".")]),_._v(" "),v("p",[_._v("这种方式最明显的好处是实现相当简单. 理论上讲, 简单地记录和执行这些语句, 能够让主备保持同步. 另一个好处是二进制日志里的事件更加紧凑, 所以相对而言, 基于语句的模式不会使用太多带宽. 一条更新好几兆数据的语句在二进制日志里可能只占几十个字节.")]),_._v(" "),v("p",[_._v("但事实上基于语句的方式可能并不如其看起来那么便利. 因为主库上的数据更新除了执行的语句外, 可能还依赖于其他因素. 例如, 同一条SQL在主库和备库上执行的时间可能稍微或很不相同, 因此在传输的二进制日志中, 除了查询语句, 还包括了一些元数据信息, 如当前的时间戳. 即便如此, 还存在着一些"),v("strong",[_._v("无法被正确复制")]),_._v("的SQL. 例如, 使用 CURRENT_USER() 函数的语句. 存储过程和触发器在使用基于语句的复制模式时也可能存在问题. 另外一个问题是"),v("strong",[_._v("更新必须是串行")]),_._v("的, 这需要更多的锁—, 有时候要特别关注这一点.")]),_._v(" "),v("h5",{attrs:{id:"_2-基于行的复制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-基于行的复制"}},[_._v("#")]),_._v(" 2.基于行的复制")]),_._v(" "),v("p",[_._v("基于行的复制方式会将"),v("strong",[_._v("实际数据记录在二进制日志")]),_._v("中, 跟其他数据库的实现比较相像.")]),_._v(" "),v("p",[_._v("这种方式最大的好处是可以正确地复制每一行. 一些语句可以被更加有效地复制. 由于无须重放更新主库数据的查询, 使用基于行的复制模式能够更高效地复制数据. 保证数据的"),v("strong",[_._v("强一致性")]),_._v(", 且由于记录的是执行后的结果, 在从库上执行还原也会比较快.")]),_._v(" "),v("p",[_._v("但如果一条 SQL 进行了"),v("strong",[_._v("全表更新")]),_._v(", 那么基于行的复制开销会很大, 因为每一行的数据都会被记录到二进制日志中, 这使得二进制日志事件非常庞大, 并且会给主库上记录日志和复制增加额外的负载, 更慢的日志记录则会降低并发度. 相反基于语句的复制则开销小很多.")]),_._v(" "),v("h5",{attrs:{id:"_3-混合复制方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-混合复制方式"}},[_._v("#")]),_._v(" 3.混合复制方式")]),_._v(" "),v("p",[_._v("由于没有哪种模式对所有情况都是完美的, MySQL能够在这两种复制模式间动态切换. 默认情况下使用的是基于语句的复制方式, 但如果发现语句无法被正确地复制, 就切换到基于行的复制模式.")]),_._v(" "),v("h5",{attrs:{id:"_4-选择"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-选择"}},[_._v("#")]),_._v(" 4.选择")]),_._v(" "),v("p",[_._v("不同的复制方式记录的日志格式, 日志数量也会不同.")]),_._v(" "),v("p",[_._v("理论上基于"),v("strong",[_._v("行的复制模式整体上更优")]),_._v(", 并且在实际应用中也适用于大多数场景.")]),_._v(" "),v("ul",[v("li",[_._v("基于语句的方式执行复制的过程基本上就是执行SQL语句. 这意味着所有在服务器上发生的变更都以一种容易理解的方式运行. 这样当出现问题时可以很好地去定位. 但如果正在使用触发器或者存储过程, 就不要使用基于语句的复制模式, 除非能够清楚地确定不会碰到复制问题.")]),_._v(" "),v("li",[_._v("几乎没有基于行的复制模式无法处理的场景. 基于行的复制模式会记录数据变更, 因此在二进制日志中记录的都是实际上在主库上发生了变化的数据.")])]),_._v(" "),v("h4",{attrs:{id:"主从复制问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主从复制问题"}},[_._v("#")]),_._v(" 主从复制问题")]),_._v(" "),v("p",[_._v("主从复制可能出现两个问题:")]),_._v(" "),v("p",[v("strong",[_._v("数据不一致问题")]),_._v(": 如果"),v("strong",[_._v("主库突然宕机")]),_._v(", 然后恰好数据还没同步到从库, 那么有些数据可能在从库上是没有的, 有些数据可能就丢失, 造成数据不一致问题.")]),_._v(" "),v("p",[v("strong",[_._v("同步时延问题")]),_._v(": 就是从库同步主库数据的过程是串行化的, 也就是说主库上并行的操作, 在从库上会串行执行. 所以由于从库从主库拷贝日志以及串行执行 SQL 的特点, 在高并发场景下, 从库的数据一定会比主库慢一些, 是"),v("strong",[_._v("有延时")]),_._v("的. 所以经常出现, 刚写入主库的数据可能是读不到的, 要过几十毫秒甚至几百毫秒才能读取到.")]),_._v(" "),v("h4",{attrs:{id:"复制机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#复制机制"}},[_._v("#")]),_._v(" 复制机制")]),_._v(" "),v("p",[_._v("MySQL 有两个机制复制来解决上述问题, 一个是"),v("strong",[_._v("半同步复制")]),_._v(", 用来解决主库数据丢失问题. 一个是"),v("strong",[_._v("并行复制")]),_._v(", 用来解决主从同步延时问题.")]),_._v(" "),v("p",[v("strong",[_._v("异步复制")]),_._v(": 主库写入一个"),v("strong",[_._v("事务")]),_._v(" COMMIT 提交并执行完之后, 将日志记录到 "),v("strong",[_._v("binlog")]),_._v(", 将结果反馈给"),v("strong",[_._v("客户端")]),_._v(", 最后"),v("strong",[_._v("将日志传输到从库")]),_._v(". 该复制经常遇到的问题是: 因为 binlog 日志是"),v("strong",[_._v("推送")]),_._v("的, 所有主库和从库之间存在一定的"),v("strong",[_._v("延迟")]),_._v(". 这样就会造成很多问题, 比如主库因为磁盘损坏等故障突然崩掉, 导致 binlog 日志不存在, 同时因为延迟 binlog 还没有推送到从库, 从库也就会丢失很多被主库提交的事物, 从而造成"),v("strong",[_._v("主从不一致问题")]),_._v(".")]),_._v(" "),v("p",[v("strong",[_._v("半同步复制")]),_._v(": 主库写入一个"),v("strong",[_._v("事务")]),_._v(" COMMIT 提交并执行完之后, 并"),v("strong",[_._v("不直接将请求反馈给前端应用用户")]),_._v(", 而是等待"),v("strong",[_._v("从库也接收到")]),_._v(" binlog 日志并成功写入中继日志后, 主库才返回 COMMIT 操作成功给客户端. 半同步复制保障了事务执行后, 至少有"),v("strong",[_._v("两份日志记录")]),_._v(", 一份在"),v("strong",[_._v("主库")]),_._v("的 binlog 上, 另一份至少在"),v("strong",[_._v("从库")]),_._v("的中继日志 Relaylog 上, 这样就极大的"),v("strong",[_._v("保证了数据的一致性")]),_._v(".")]),_._v(" "),v("p",[v("strong",[_._v("并行复制")]),_._v(": 指的是从库开启"),v("strong",[_._v("多个线程")]),_._v(", 并行读取 Relaylog 中不同库的日志, 然后"),v("strong",[_._v("并行重放不同库的日志")]),_._v(", 这是"),v("strong",[_._v("库级别的并行")]),_._v(".")]),_._v(" "),v("h4",{attrs:{id:"主从延迟问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主从延迟问题"}},[_._v("#")]),_._v(" 主从延迟问题")]),_._v(" "),v("p",[_._v("一般来说, 如果主从延迟较为严重, 有以下解决方案:")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("分库")]),_._v(", 将一个主库拆分为多个主库, 每个主库的写并发就减少了几倍, 此时主从延迟可以忽略不计.")]),_._v(" "),v("li",[_._v("打开 MySQL 支持的"),v("strong",[_._v("并行复制")]),_._v(", 多个库并行复制. 如果某个库的写入并发就是特别高, 单库写并发达到了 2000/s, 并行复制还是没意义.")]),_._v(" "),v("li",[_._v("某些"),v("strong",[_._v("写后读")]),_._v("的场景可以考虑"),v("strong",[_._v("强制读主库")]),_._v(".")])]),_._v(" "),v("h4",{attrs:{id:"复制拓扑"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#复制拓扑"}},[_._v("#")]),_._v(" 复制拓扑")]),_._v(" "),v("p",[_._v("可以在任意个主库和备库之间建立复制, 只有一个限制: 每一个备库只能有一个主库.")]),_._v(" "),v("p",[_._v("基本原则:")]),_._v(" "),v("ul",[v("li",[_._v("一个MySQL备库实例只能有一个主库.")]),_._v(" "),v("li",[_._v("每个备库必须有一个唯一的服务器ID.")]),_._v(" "),v("li",[_._v("一个主库可以有多个备库(或者相应的, 一个备库可以有多个兄弟备库).")]),_._v(" "),v("li",[_._v("如果打开了log_slave_updates选项, 一个备库可以把其主库上的数据变化传播到其他备库.")])]),_._v(" "),v("h4",{attrs:{id:"读写分离"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#读写分离"}},[_._v("#")]),_._v(" 读写分离")]),_._v(" "),v("p",[_._v("MySQL 的读写分离架构就是: "),v("strong",[_._v("主服务器处理写操作")]),_._v("以及"),v("strong",[_._v("实时性要求比较高的读")]),_._v("操作, 而"),v("strong",[_._v("从服务器处理读")]),_._v("操作. 读写分离是基于上述的"),v("strong",[_._v("主从复制")]),_._v("架构的.")]),_._v(" "),v("p",[_._v("读写分离能提高性能的"),v("strong",[_._v("原因")]),_._v("在于:")]),_._v(" "),v("ul",[v("li",[_._v("主从服务器"),v("strong",[_._v("负责各自的读和写")]),_._v(", 极大程度"),v("strong",[_._v("缓解了锁的争用")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("从服务器")]),_._v("可以"),v("strong",[_._v("使用 MyISAM")]),_._v(", 提升"),v("strong",[_._v("查询性能")]),_._v("以及节约系统开销.")]),_._v(" "),v("li",[_._v("增加冗余, 提高"),v("strong",[_._v("可用性")]),_._v(".")])]),_._v(" "),v("p",[_._v("读写分离常用"),v("strong",[_._v("代理方式")]),_._v("来实现, "),v("strong",[_._v("代理服务器")]),_._v("接收应用层传来的"),v("strong",[_._v("读写请求")]),_._v(", 然后决定转发到哪个服务器, 如下图所示.")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563519716630.png",alt:"1563519716630"}})]),_._v(" "),v("p",[_._v("‍")]),_._v(" "),v("h4",{attrs:{id:"参考资料"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[_._v("#")]),_._v(" 参考资料")]),_._v(" "),v("ul",[v("li",[_._v("《高性能 MySQL 第三版》")])])])}),[],!1,null,null,null);v.default=r.exports}}]);