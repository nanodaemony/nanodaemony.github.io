(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{355:function(_,t,v){"use strict";v.r(t);var s=v(7),r=Object(s.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"_50-网络综合问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_50-网络综合问题"}},[_._v("#")]),_._v(" 50.网络综合问题")]),_._v(" "),t("h5",{attrs:{id:"_1-在浏览器中输入url并按下回车会发生什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-在浏览器中输入url并按下回车会发生什么"}},[_._v("#")]),_._v(" 1.在浏览器中输入URL并按下回车会发生什么?")]),_._v(" "),t("h6",{attrs:{id:"_1-解析url"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-解析url"}},[_._v("#")]),_._v(" (1)解析URL")]),_._v(" "),t("p",[_._v("首先浏览器会解析输入的是 "),t("strong",[_._v("URL")]),_._v(" 还是搜索关键词, 如果不是 URL 就会作为搜索关键词传给默认的搜索引擎.")]),_._v(" "),t("h6",{attrs:{id:"_2-检查hsts列表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-检查hsts列表"}},[_._v("#")]),_._v(" (2)检查HSTS列表")]),_._v(" "),t("p",[_._v('浏览器检查自带的 "'),t("strong",[_._v("预加载 HSTS")]),_._v('(HTTP 严格传输安全)" 列表, 里面包含了浏览器'),t("strong",[_._v("只使用 HTTPS")]),_._v(" 进行连接的网站. 如果请求的网站在"),t("strong",[_._v("这个列表里, 浏览器会使用 HTTPS")]),_._v(" 而不是 HTTP 协议, 否则请求会使用 "),t("strong",[_._v("HTTP 协议")]),_._v("发送.")]),_._v(" "),t("h6",{attrs:{id:"_3-dns查询"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-dns查询"}},[_._v("#")]),_._v(" (3)DNS查询")]),_._v(" "),t("p",[_._v("浏览器"),t("strong",[_._v("检查域名是否在缓存")]),_._v("当中. 如果浏览器缓存中没有, 就去查询本地 Hosts 文件中是否配置了域名.")]),_._v(" "),t("p",[_._v("如果依然没有, 则向 DNS 服务器发送一条 DNS 查询请求. 首先查询本地 DNS 服务器, 如果 DNS 服务器和主机在"),t("strong",[_._v("同一个子网内")]),_._v(", 系统会按照下面的 "),t("strong",[_._v("ARP 过程")]),_._v("对 DNS 服务器进行 "),t("strong",[_._v("ARP 查询")]),_._v(". 如果 "),t("strong",[_._v("DNS 服务器和主机在不同的子网")]),_._v(", 系统会按照下面的 ARP 过程对"),t("strong",[_._v("默认网关进行查询")]),_._v(".")]),_._v(" "),t("h6",{attrs:{id:"_4-arp过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-arp过程"}},[_._v("#")]),_._v(" (4)ARP过程")]),_._v(" "),t("p",[_._v("要想发送 "),t("strong",[_._v("ARP(地址解析协议) 广播")]),_._v(", 需要有一个"),t("strong",[_._v("目标 IP 地址")]),_._v(", 同时还需要知道用于发送 ARP 广播的接口的 "),t("strong",[_._v("MAC 地址")]),_._v(". 首先查询 "),t("strong",[_._v("ARP 缓存")]),_._v(", 如果缓存命中, 返回结果: 目标 IP = MAC.")]),_._v(" "),t("p",[_._v("如果缓存没有命中:")]),_._v(" "),t("ul",[t("li",[_._v("查看"),t("strong",[_._v("路由表")]),_._v(", 看看目标 "),t("strong",[_._v("IP 地址")]),_._v("是不是在本地路由表中的"),t("strong",[_._v("某个子网")]),_._v("内. 是的话使用跟那个子网相连的接口, 否则使用与"),t("strong",[_._v("默认网关相连的接口")]),_._v(".")]),_._v(" "),t("li",[_._v("查询选择的网络接口的 MAC 地址.")]),_._v(" "),t("li",[_._v("发送一个二层 ARP 请求:")])]),_._v(" "),t("p",[t("strong",[_._v("ARP Request:")])]),_._v(" "),t("div",{staticClass:"language-http line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-http"}},[t("code",[_._v("Sender MAC: interface:mac:address:here\nSender IP: interface.ip.goes.here\nTarget MAC: FF:FF:FF:FF:FF:FF (Broadcast)\nTarget IP: target.ip.goes.here\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br"),t("span",{staticClass:"line-number"},[_._v("3")]),t("br"),t("span",{staticClass:"line-number"},[_._v("4")]),t("br")])]),t("p",[_._v("根据连接主机和路由器的硬件类型不同, 可以分为以下几种情况:")]),_._v(" "),t("p",[t("strong",[_._v("直连")]),_._v(": 如果和"),t("strong",[_._v("路由器是直接连接")]),_._v('的, 路由器会返回一个如下的 "ARP Reply".')]),_._v(" "),t("p",[t("strong",[_._v("交换机")]),_._v(":")]),_._v(" "),t("ul",[t("li",[_._v("如果连接到了一个"),t("strong",[_._v("交换机")]),_._v(", 交换机会检查本地 "),t("strong",[_._v("CAM/MAC 表")]),_._v(", 看看哪个端口有要找的那个 MAC 地址, 如果没有找到, 交换机会向所有其它"),t("strong",[_._v("端口广播这个 ARP 请求")]),_._v(".")]),_._v(" "),t("li",[_._v("如果交换机的 MAC/CAM 表中有对应的条目, 交换机会向有想要查询的 MAC 地址的那个端口发送 ARP 请求.")]),_._v(" "),t("li",[_._v('如果路由器也 "连接" 在其中, 它会返回一个 "ARP Reply".')])]),_._v(" "),t("p",[t("strong",[_._v("ARP Reply:")])]),_._v(" "),t("div",{staticClass:"language-http line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-http"}},[t("code",[_._v("Sender MAC: target:mac:address:here\nSender IP: target.ip.goes.here\nTarget MAC: interface:mac:address:here\nTarget IP: interface.ip.goes.here\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br"),t("span",{staticClass:"line-number"},[_._v("3")]),t("br"),t("span",{staticClass:"line-number"},[_._v("4")]),t("br")])]),t("p",[_._v("现在有了 "),t("strong",[_._v("DNS 服务器或者默认网关的 IP 地址")]),_._v(", 可以继续 "),t("strong",[_._v("DNS 请求")]),_._v("了:")]),_._v(" "),t("ul",[t("li",[_._v("使用 53 端口向 DNS 服务器发送 "),t("strong",[_._v("UDP 请求包")]),_._v(", 如果响应包太大, 会使用 "),t("strong",[_._v("TCP 协议")]),_._v(".")]),_._v(" "),t("li",[_._v("如果 DNS 服务器没有找到结果, 它会发送一个"),t("strong",[_._v("递归查询请求")]),_._v(", "),t("strong",[_._v("一层一层向高层 DNS 服务器")]),_._v("做查询, 如果找到会把结果返回.")]),_._v(" "),t("li",[_._v("主机收到 DNS 消息之后也会在本地进行"),t("strong",[_._v("缓存")]),_._v(".")])]),_._v(" "),t("h6",{attrs:{id:"_5-使用套接字tcp连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-使用套接字tcp连接"}},[_._v("#")]),_._v(" (5)使用套接字TCP连接")]),_._v(" "),t("p",[_._v("当浏览器得到了"),t("strong",[_._v("目标服务器的 IP 地址")]),_._v(", 以及 URL 中给出来"),t("strong",[_._v("端口号")]),_._v("(http 协议默认端口号是 80, https 默认端口号是 443), 它会调用"),t("strong",[_._v("系统库函数 socket")]),_._v(", 请求一个 "),t("strong",[_._v("TCP 流套接字")]),_._v(", 对应的参数是 "),t("strong",[_._v("AF_INET/AF_INET6 和 SOCK_STREAM")]),_._v(" .")]),_._v(" "),t("ul",[t("li",[_._v("这个请求首先被交给"),t("strong",[_._v("传输层")]),_._v(", 在传输层请求被封装成 TCP segment. 目标端口会被加入头部, 源端口会在系统内核的动态端口范围内选取(Linux 下是 ip_local_port_range).")]),_._v(" "),t("li",[_._v("TCP segment 被送往"),t("strong",[_._v("网络层")]),_._v(", 网络层会在其中再加入一个 IP 头部, 里面包含了目标服务器的 IP 地址以及本机的 IP 地址, 把它封装成一个 IP packet.")]),_._v(" "),t("li",[_._v("这个 TCP packet 接下来会进入"),t("strong",[_._v("链路层")]),_._v(", 链路层会在"),t("strong",[_._v("封包中加入 frame 头部")]),_._v(", 里面包含了本地内置网卡的 MAC 地址以及"),t("strong",[_._v("网关(本地路由器) 的 MAC 地址")]),_._v(". 与前面一样, 如果内核不知道网关的 MAC 地址, 它必须进行 ARP 广播来查询其地址.")])]),_._v(" "),t("p",[_._v("到现在 "),t("strong",[_._v("TCP 封包")]),_._v("已经准备好了, 可以使用以太网, WIFi, 蜂窝数据网络等进行"),t("strong",[_._v("数据传输")]),_._v(". 最终封包会到达管理"),t("strong",[_._v("本地子网的路由器")]),_._v(". 在那里出发, 它会继续经过"),t("strong",[_._v("自治区域")]),_._v("(AS) 的边界路由器, 其他自治区域, 最终到达目标服务器. 一路上经过的这些路由器会从 IP 数据报头部里提取出目标地址, 并将封包正确地路由到下一个目的地. IP 数据报头部的 TTL 域的值每经过一个"),t("strong",[_._v("路由器就减 1")]),_._v(", 如果封包的 "),t("strong",[_._v("TTL 变为 0")]),_._v(", 或者路由器由于网络拥堵等原因封包队列满了, 那么这个包会被路由器"),t("strong",[_._v("丢弃")]),_._v(".")]),_._v(" "),t("p",[_._v("上面的"),t("strong",[_._v("发送和接受")]),_._v("过程在 "),t("strong",[_._v("TCP 连接期间会发生很多次")]),_._v(":")]),_._v(" "),t("ul",[t("li",[_._v("客户端选择一个初始序列号(ISN), 将设置了 SYN 位的封包发送给服务器端, 表明自己要建立连接并设置了初始序列号.")]),_._v(" "),t("li",[_._v("服务器端接收到 SYN 包, 如果它可以建立连接: 服务器端选择它自己的初始序列号服务器端设置 SYN 位, 表明自己选择了一个初始序列号服务器端把(客户端 ISN + 1) 复制到 ACK 域, 并且设置 ACK 位, 表明自己接收到了客户端的第一个封包.")]),_._v(" "),t("li",[_._v("客户端通过发送下面一个封包来确认这次连接: 自己的序列号 +1 接收端 ACK + 1 设置 ACK 位.")]),_._v(" "),t("li",[_._v("数据通过下面的方式传输: 当一方发送了 N 个 Bytes 的数据之后, 将自己的 SEQ 序列号也增加N另一方确认接收到这个数据包(或者一系列数据包) 之后, 它发送一个 ACK 包, ACK 的值设置为接收到的数据包的最后一个序列号.")]),_._v(" "),t("li",[_._v("关闭连接时: 要关闭连接的一方发送一个 FIN 包另一方确认这个 FIN 包, 并且发送自己的 FIN 包要关闭的一方使用 ACK 包来确认接收到了 FIN.")])]),_._v(" "),t("h6",{attrs:{id:"_6-tls握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-tls握手"}},[_._v("#")]),_._v(" (6)TLS握手")]),_._v(" "),t("ul",[t("li",[_._v('客户端发送一个 "ClientHello" 消息到'),t("strong",[_._v("服务器端")]),_._v(", 消息中同时包含了它的 TLS(Transport Layer Security) 版本, 可用的加密算法和压缩算法.")]),_._v(" "),t("li",[_._v('服务器端向客户端返回一个 "ServerHello" 消息, 消息中包含了服务器端的 TLS 版本, 服务器所选择的加密和压缩算法, 以及 CA 机构签发的服务器公开证书, 证书中包含了公钥. 客户端会使用这个公钥加密接下来的握手过程, 直到协商生成一个新的对称密钥.')]),_._v(" "),t("li",[_._v("客户端根据自己的"),t("strong",[_._v("信任 CA 列表")]),_._v(", "),t("strong",[_._v("验证服务器端的证书是否可信")]),_._v(". 如果认为可信, 客户端会生成一串"),t("strong",[_._v("伪随机数")]),_._v(", 使用服务器的公钥加密它. 这串随机数会"),t("strong",[_._v("被用于生成新的对称密钥")]),_._v(".")]),_._v(" "),t("li",[_._v("服务器端使用自己的私钥解密上面提到的"),t("strong",[_._v("随机数")]),_._v(", 然后使用这串随机数生成自己的对称主密钥.")]),_._v(" "),t("li",[_._v('客户端发送一个 "Finished" 消息给服务器端, 使用对称密钥加密这次通讯的一个散列值.')]),_._v(" "),t("li",[_._v('服务器端生成自己的 hash 值, 然后解密客户端发送来的信息, 检查这两个值是否对应. 如果对应, 就向客户端发送一个 "Finished" 消息, 也使用协商好的对称密钥加密.')]),_._v(" "),t("li",[_._v("从现在开始, 接下来整个 TLS 会话都使用"),t("strong",[_._v("对称秘钥")]),_._v("进行加密, 传输应用层(HTTP) 内容.")])]),_._v(" "),t("h6",{attrs:{id:"_7-http协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-http协议"}},[_._v("#")]),_._v(" (7)HTTP协议")]),_._v(" "),t("p",[_._v("如果浏览器是 Google 的, 它不会使用 HTTP 协议来获取页面信息, 而是会与服务器端发送请求, 商讨使用 SPDY 协议. 如果浏览器使用 HTTP 协议而不支持 SPDY 协议, 它会向服务器发送这样的一个请求:")]),_._v(" "),t("div",{staticClass:"language-http line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-http"}},[t("code",[t("span",{pre:!0,attrs:{class:"token request-line"}},[t("span",{pre:!0,attrs:{class:"token method property"}},[_._v("GET")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token request-target url"}},[_._v("/")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token http-version property"}},[_._v("HTTP/1.1")])]),_._v("\n"),t("span",{pre:!0,attrs:{class:"token header"}},[t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[_._v("Host")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(":")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token header-value"}},[_._v("google.com")])]),_._v("\n"),t("span",{pre:!0,attrs:{class:"token header"}},[t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[_._v("Connection")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(":")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token header-value"}},[_._v("close")])]),_._v("\n[其他头部]\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br"),t("span",{staticClass:"line-number"},[_._v("3")]),t("br"),t("span",{staticClass:"line-number"},[_._v("4")]),t("br")])]),t("p",[_._v('"其他头部" 包含一系列由冒号分割开的键值对, 它们的格式符合 HTTP 协议标准, 它们之间由一个换行符分割开来. 这里假设浏览器没有违反HTTP协议标准的bug, 同时假设浏览器使用 "HTTP/1.1" 协议. HTTP/1.1 定义了 "关闭连接" 的选项 "close", 发送者使用这个选项指示这次连接在响应结束之后会断开. 例如:')]),_._v(" "),t("blockquote",[t("p",[_._v("Connection: close")])]),_._v(" "),t("p",[_._v("在发送完这些请求和头部之后, 浏览器发送一个换行符, 表示要发送的内容已经结束了.")]),_._v(" "),t("p",[_._v("服务器端"),t("strong",[_._v("返回一个响应码")]),_._v(", 指示这次请求的状态, 响应形式如下:")]),_._v(" "),t("div",{staticClass:"language-http line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-http"}},[t("code",[_._v("200 OK\n[响应头部]\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br")])]),t("p",[_._v("然后是一个"),t("strong",[_._v("换行")]),_._v(', 接下来有效载荷(payload), 也就是 "www.google.com" 的 HTML 内容. 服务器下面可能会关闭连接, 如果客户端请求保持连接的话, 服务器端会保持连接打开, 以供之后的请求重用.')]),_._v(" "),t("p",[_._v("如果浏览器发送的 HTTP 头部包含了足够多的信息(例如包含了 Etag 头部), 以至于服务器可以判断出, 浏览器缓存的文件版本自从上次获取之后没有再更改过, 服务器可能会返回这样的响应:")]),_._v(" "),t("div",{staticClass:"language-http line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-http"}},[t("code",[_._v("304 Not Modified\n[响应头部]\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br")])]),t("p",[_._v("这个响应没有有效载荷, "),t("strong",[_._v("浏览器会从自己的缓存中取出想要的内容")]),_._v(".")]),_._v(" "),t("p",[_._v("在解析完 HTML 之后, 浏览器和客户端会重复上面的过程, 直到 "),t("strong",[_._v("HTML 页面引入的所有资源")]),_._v("(图片, CSS, favicon.ico等等) 全部都获取完毕, 区别只是头部的 "),t("strong",[_._v("GET / HTTP/1.1")]),_._v(" 会变成 GET /$(相对 "),t("a",{attrs:{href:"http://www.google.com",target:"_blank",rel:"noopener noreferrer"}},[_._v("www.google.com"),t("OutboundLink")],1),_._v(" 的 URL) HTTP/1.1 .")]),_._v(" "),t("p",[_._v('如果 HTML 引入了 "www.google.com" 域名之外的资源, 浏览器会回到上面解析域名那一步, 按照下面的步骤往下一步一步执行, 请求中的 Host 头部会变成另外的域名.')]),_._v(" "),t("h6",{attrs:{id:"_8-http服务器请求处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-http服务器请求处理"}},[_._v("#")]),_._v(" (8)HTTP服务器请求处理")]),_._v(" "),t("p",[_._v("HTTPD(HTTP Daemon) 在服务器端处理请求并进行响应. 最常见的 HTTPD 有 Linux 上的 "),t("strong",[_._v("Apache 和 nginx")]),_._v(".")]),_._v(" "),t("ul",[t("li",[_._v("HTTPD 接收请求, 并对 URL 进行分析获取请求的 HTTP 方法与路径等.")]),_._v(" "),t("li",[_._v("服务器验证其上已经配置了 google.com 的虚拟主机.")]),_._v(" "),t("li",[_._v("服务器验证 google.com 接受 GET 方法.")]),_._v(" "),t("li",[_._v("服务器验证该用户可以使用 GET 方法(根据 IP 地址, 身份信息等).")]),_._v(" "),t("li",[_._v("如果服务器安装了 URL 重写模块(例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite), 服务器会尝试匹配重写规则, 如果匹配上的话, 服务器会按照规则重写这个请求.")]),_._v(" "),t("li",[_._v('服务器根据请求信息获取相应的响应内容, 这种情况下由于访问路径是 "/" ,会访问首页文件(可以重写这个规则, 但这是最常用的).')]),_._v(" "),t("li",[_._v("服务器会使用指定的处理程序分析处理这个文件, 假如 Google 使用 PHP, 服务器会使用 PHP 解析 index 文件, 并捕获输出, 把 PHP 的输出结果返回给请求者.")])]),_._v(" "),t("h6",{attrs:{id:"_9-浏览器后续操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-浏览器后续操作"}},[_._v("#")]),_._v(" (9)浏览器后续操作")]),_._v(" "),t("p",[_._v("当服务器提供了"),t("strong",[_._v("资源")]),_._v("之后(HTML, CSS, JS, 图片等), 浏览器会执行下面的操作:")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("解析")]),_._v(': HTML, CSS, JS. HTML 解析器的主要工作是对 HTML 文档进行解析, 生成解析树. 通过遍历 DOM 节点树创建一个 "Frame 树" 或 "渲染树", 并计算每个节点的各个 CSS 样式值.')]),_._v(" "),t("li",[t("strong",[_._v("渲染")]),_._v(": 构建 DOM 树 -> 渲染 -> 布局 -> 绘制.")])]),_._v(" "),t("p",[_._v("之后浏览器即可展示渲染出来的请求结果.")]),_._v(" "),t("p",[_._v("‍")])])}),[],!1,null,null,null);t.default=r.exports}}]);