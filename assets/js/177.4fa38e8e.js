(window.webpackJsonp=window.webpackJsonp||[]).push([[177],{626:function(t,s,n){"use strict";n.r(s);var a=n(7),e=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_10-凤凰架构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-凤凰架构"}},[t._v("#")]),t._v(" 10.凤凰架构")]),t._v(" "),s("h3",{attrs:{id:"远程服务调用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#远程服务调用"}},[t._v("#")]),t._v(" 远程服务调用")]),t._v(" "),s("p",[t._v("远程服务将计算机程序的工作范围从单机扩展至网络, 从本地延伸至远程, 是构建分布式系统的首要基础. "),s("strong",[t._v("RPC 和 REST")]),t._v(" 是两种主流远程服务调用方式.")]),t._v(" "),s("h4",{attrs:{id:"远程过程调用rpc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#远程过程调用rpc"}},[t._v("#")]),t._v(" 远程过程调用RPC")]),t._v(" "),s("h5",{attrs:{id:"_1-基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础"}},[t._v("#")]),t._v(" 1.基础")]),t._v(" "),s("p",[t._v("RPC(Remote Procedure Call) 即"),s("strong",[t._v("远程过程调用")]),t._v(", 指位于互不重合的内存地址空间中的两个程序, 在语言层面上, 以同步的方式使用带宽有限的信道来传输程序控制信息. 通俗的说, 它是一种通过网络从远程计算机程序上请求服务, 而不需要了解底层网络技术的协议. RPC 让分布式或微服务系统中不同服务之间的调用像本地调用一样简单.")]),t._v(" "),s("p",[t._v("RPC 其实是基于套接字(Socket)接口的一种进程间通信. 由于 Socket 是各个操作系统都提供的标准接口, 完全有可能把远程方法调用的通信细节隐藏在操作系统底层, 从应用层面上来看可以做到远程调用与本地的进程间通信在编码上完全一致.")]),t._v(" "),s("blockquote",[s("p",[t._v("HTTP与RPC")])]),t._v(" "),s("p",[t._v("RPC 只是一种"),s("strong",[t._v("概念, 一种设计")]),t._v(", 就是为了解决 "),s("strong",[t._v("不同服务之间的调用问题")]),t._v(", 它一般会包含有 "),s("strong",[t._v("传输协议")]),t._v(" 和 "),s("strong",[t._v("序列化协议")]),t._v(" 两部分内容.")]),t._v(" "),s("p",[t._v("HTTP 是"),s("strong",[t._v("一种协议")]),t._v(", RPC 框架"),s("strong",[t._v("可以使用 HTTP 协议作为传输协议")]),t._v("或直接使用 TCP 作为传输协议, 使用不同的协议一般也是为了适应不同的场景.")]),t._v(" "),s("h5",{attrs:{id:"_2-三个基本问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-三个基本问题"}},[t._v("#")]),t._v(" 2.三个基本问题")]),t._v(" "),s("p",[t._v("所有流行过的 RPC 协议, 几乎都变着花样使用各种手段来解决三个基本问题. RPC 的三大问题源自于对"),s("strong",[t._v("本地方法调用")]),t._v("的类比模拟.")]),t._v(" "),s("h6",{attrs:{id:"_1-如何表示数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-如何表示数据"}},[t._v("#")]),t._v(" (1)如何表示数据")]),t._v(" "),s("p",[s("strong",[t._v("这里的数据包括传递给方法的参数以及方法执行后的返回值")]),t._v(".")]),t._v(" "),s("p",[t._v("无论是将参数传递给另外一个进程, 还是从另外一个进程中取回执行结果, 都涉及数据表示问题.")]),t._v(" "),s("p",[t._v("对于进程内的方法调用, 使用程序语言预置和自定义的数据类型, 就很容易解决数据表示问题. 对于远程方法调用, 则完全可能面临交互双方各自使用不同程序语言的情况, 即使只支持一种程序语言的 RPC 协议, 在不同硬件指令集, 不同操作系统下, 同样的数据类型也完全可能有不一样的表现细节, 譬如数据宽度, 字节序的差异等. 有效的做法是将交互双方所涉及的数据转换为某种事先约定好的"),s("strong",[t._v("中立数据流")]),t._v("格式来进行传输, 将数据流转换回不同语言中对应的数据类型来使用. 这个过程其实就是"),s("strong",[t._v("序列化与反序列化")]),t._v(". 每种 RPC 协议都应该要有对应的序列化协议, 譬如: gRPC 的 Protocol Buffers, Java RMI 的 Java 对象序列化流协议.")]),t._v(" "),s("h6",{attrs:{id:"_2-如何传递数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何传递数据"}},[t._v("#")]),t._v(" (2)如何传递数据")]),t._v(" "),s("p",[t._v("传递数据指如何通过网络, 在两个服务的 Endpoint 之间相互操作, 交换数据.")]),t._v(" "),s("p",[t._v('这里"交换数据"通常指的是'),s("strong",[t._v("应用层协议")]),t._v(", 实际传输一般是基于 TCP, UDP 等标准的传输层协议来完成的. 两个服务交互不是只扔个序列化数据流来表示参数和结果就行, 许多在此之外的信息, 譬如异常, 超时, 安全, 认证, 授权, 事务等, 都可能产生双方需要交换信息的需求.")]),t._v(" "),s("p",[t._v('在计算机科学中, 专门有一个名词 "Wire Protocol" 来表示这种两个 Endpoint 之间交换这类数据的行为, 典型的有 SOAP, JRMP. 如果要求足够简单, 双方都是 HTTP Endpoint, 直接使用 HTTP 协议也是可以的(如 JSON-RPC).')]),t._v(" "),s("h6",{attrs:{id:"_3-如何表示方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-如何表示方法"}},[t._v("#")]),t._v(" (3)如何表示方法")]),t._v(" "),s("p",[t._v("确定表示方法在"),s("strong",[t._v("本地方法")]),t._v("调用中并不是太大的问题, 编译器或解释器会根据语言规范, 将调用的方法签名转换为进程空间中子过程入口位置的指针. 不过"),s("strong",[t._v("考虑不同语言")]),t._v('时就比较麻烦, 每种语言的方法签名都可能有差别, 所以 "'),s("strong",[t._v("如何表示同一个方法")]),t._v('", "'),s("strong",[t._v("如何找到对应的方法")]),t._v('" 还是需要一个统一的'),s("strong",[t._v("跨语言的标准")]),t._v("才行.")]),t._v(" "),s("p",[t._v("这个标准可以非常简单, 譬如直接给每个方法都规定一个唯一的, 在任何机器上都绝不重复的编号, 调用时压根不管它是什么方法, 签名是如何定义的, 直接传这个编号就能找到对应的方法. 一种典型的方案是用"),s("strong",[t._v("唯一的绝不重复的编码")]),t._v("方案 UUID(Universally Unique Identifier)来表示方法.")]),t._v(" "),s("h5",{attrs:{id:"_3-常见rpc框架"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-常见rpc框架"}},[t._v("#")]),t._v(" 3.常见RPC框架")]),t._v(" "),s("p",[t._v('由于一直没有一个同时满足以上三点的 "完美RPC协议" 出现, 所以 RPC 领域逐渐进入群雄混战的时代, 距离"统一"越来越远.')]),t._v(" "),s("p",[t._v('已经相继出现过 Thrift(Facebook/Apache), Dubbo(阿里巴巴/Apache), gRPC(Google), brpc(百度/Apache), Arvo(Hadoop), JSON-RPC 2.0 等协议和框架. 这些 RPC 功能, 特点不尽相同, 有的是某种语言私有, 有的支持跨越多种语言, 有的运行在应用层 HTTP 协议之上, 有的直接运行于传输层 TCP/UDP 协议之上, 但并不存在哪一款是"最完美的RPC".')]),t._v(" "),s("p",[t._v('任何一款具有生命力的 RPC 框架, 都不再去追求大而全的"完美", 而是以某个具有'),s("strong",[t._v("针对性的特点")]),t._v("作为主要的发展方向, 举例如下.")]),t._v(" "),s("ul",[s("li",[t._v("朝着"),s("mark",[s("strong",[t._v("面向对象")])]),t._v("发展, 不满足于 RPC 将"),s("strong",[t._v("面向过程")]),t._v("的编码方式带到分布式, 希望在分布式系统中也能够进行跨进程的面向对象编程, 代表为 RMI, .NET Remoting. 这种方式有一个别名叫作分布式对象(Distributed Object).")]),t._v(" "),s("li",[t._v("朝着"),s("mark",[s("strong",[t._v("性能")])]),t._v("发展, 代表为 gRPC 和 Thrift. "),s("strong",[t._v("决定 RPC 性能的主要因素")]),t._v("有两个: "),s("strong",[t._v("序列化效率和信息密度.")]),t._v("  序列化效率很好理解, 序列化输出结果的容量越小, 速度越快, 效率自然越高; 信息密度则取决于协议中有效负载(Payload)所占总传输数据的比例大小, 使用传输协议的层次越高, 信息密度就越低, SOAP 使用 XML 拙劣的性能表现就是前车之鉴. gRPC 和 Thrift 都有自己优秀的专有序列化器, 而传输协议方面, gRPC 是基于 "),s("strong",[t._v("HTTP/2")]),t._v(" 的, 支持多路复用和 Header 压缩,  Thrift 则直接基于传输层的 TCP 协议来实现, 省去了应用层协议的额外开销.")]),t._v(" "),s("li",[t._v("朝着"),s("mark",[s("strong",[t._v("简化")])]),t._v("发展, 代表为 JSON-RPC, 牺牲了功能和效率, 换来的是协议的简单轻便, 接口与格式都更为通用, 尤其适合用于浏览器这类一般不会有额外协议支持, 额外客户端支持的应用场合.")])]),t._v(" "),s("p",[t._v("功能多起来, 协议就会更复杂, 效率一般也会受影响; 要简单易用, 那很多事情就必须遵循约定而不是自行配置; 要重视效率, 那就需要采用二进制的序列化器和较底层的传输协议, 支持的语言范围容易受限. 也正是每一种 RPC 框架都有不完美的地方, 所以才导致不断有新的 RPC 轮子出现, 也决定了在选择框架时, 在获得一些利益的同时, 要付出另外一些代价.")]),t._v(" "),s("p",[t._v("今年 RPC 框架有向更高层次(不仅仅负责调用远程服务, 还管理远程服务)与插件化方向发展的趋势, 不再追求独立地解决 RPC 的全部三个问题(表示数据, 传递数据, 表示方法), 而是将一部分功能设计成扩展点, 让用户自己选择. 框架聚焦于提供核心的, 更高层次的能力, 譬如提供"),s("strong",[t._v("负载均衡, 服务注册, 可观察性")]),t._v("等方面的支持. 这一类框架的代表有 Thrift 与 Dubbo, 尤其是 Dubbo 表现得更为明显. Dubbo 默认有自己的传输协议(Dubbo 协议), 同时也支持其他协议; 默认采用 Hessian2 作为序列化器, 如果有 JSON 的需求则可以替换为 Fastjson; 如果对性能有更高的追求, 可以替换为 Kryo, FST, Protocol Buffers 等效率更好的序列化器; 如果不想依赖其他组件库, 也可以直接使用 JDK 自带的序列化器. 这种设计在一定程度上缓和了 RPC 框架必须取舍, 难以完美的缺憾.")]),t._v(" "),s("h4",{attrs:{id:"表征状态转移rest"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#表征状态转移rest"}},[t._v("#")]),t._v(" 表征状态转移REST")]),t._v(" "),s("h5",{attrs:{id:"_1-基础-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础-2"}},[t._v("#")]),t._v(" 1.基础")]),t._v(" "),s("p",[t._v("REST(Representational State Transfer, "),s("strong",[t._v("表征状态转移")]),t._v("). 即  "),s("strong",[t._v('"资源" 在网络传输中以某种 "表现形式" 进行 "状态转移"')]),t._v(" . "),s("mark",[s("strong",[t._v("面向资源")])]),t._v("是 REST 最明显的特征, 即对于同一个资源的一组不同的操作.")]),t._v(" "),s("p",[t._v('在 REST 提出以前, 人们设计分布式系统服务的唯一方案就只有 RPC, RPC 是将本地的方法调用思路迁移到远程方法调用上, 开发者是围绕"远程方法"去设计两个系统间交互的. 开发一个分布式系统, 并不是就一定要用 RPC. RPC 的三大问题源自于对本地方法调用的类比模拟, 如果把思维从"方法调用"的约束中挣脱, 那在解决参数与结果如何表示, 数据如何传递, 方法如何表示这些问题时都会有焕然一新的视角. 所以 REST 就有用武之地了.')]),t._v(" "),s("p",[t._v("REST 与 RPC 在思想上差异的核心是抽象的目标不一样, 即"),s("strong",[t._v("面向过程的编程思想与面向资源的编程思想")]),t._v("之间的区别.")]),t._v(" "),s("p",[t._v("REST 与 RPC 在概念上的不同是指 REST 并不是一种远程服务调用协议, 甚至可以把定语也去掉, 它就不是一种协议. 协议都带有一定的规范性和强制性, 比如很简单的 JSON-RPC, 也有《JSON-RPC规范》来规定协议的格式细节, 异常, 响应码等信息. 但 REST 并没有定义这些内容, 尽管有一些指导原则, "),s("strong",[t._v("但实际上并不受任何强制的约束")]),t._v('. 常有人批评某个系统接口 "设计得不够RESTful", 其实这句话本身就有些争议, REST 只能说是风格而不是规范或者协议.')]),t._v(" "),s("p",[t._v("尽管有着种种不同, REST 与 RPC 这两种分别面向资源和过程的远程调用方式, 就如同当年面向对象与过程的编程思想一样, 其实不一定谁好谁坏, 都得看使用场景.")]),t._v(" "),s("h5",{attrs:{id:"_2-名词解释与理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-名词解释与理解"}},[t._v("#")]),t._v(" 2.名词解释与理解")]),t._v(" "),s("p",[t._v('如何理解"表征状态转移"?')]),t._v(" "),s("p",[t._v('REST实际上是 "HTT"(Hypertext Transfer) 的进一步抽象, 两者的关系就如同'),s("strong",[t._v("接口与实现类")]),t._v("的关系一般.")]),t._v(" "),s("h6",{attrs:{id:"_1-资源-resource"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-资源-resource"}},[t._v("#")]),t._v(" (1)资源(Resource)")]),t._v(" "),s("p",[t._v('譬如你现在正在阅读一篇名为《如何让富婆爱上我》的文章, 这篇文章的内容本身(你可以将其理解为蕴含的信息, 数据)称之为"资源". 无论你是通过阅读购买的图书或是浏览器上的网页, 无论是在电脑还是手机上阅读, 尽管呈现的样子各不相同, 但其中的'),s("strong",[t._v("信息是不变")]),t._v('的, 你所阅读的仍是同一份"'),s("strong",[t._v("资源")]),t._v('". 资源是以名词为核心来组织的, 首先关注的是'),s("strong",[t._v("名词")]),t._v(".")]),t._v(" "),s("p",[t._v("一个资源既可以是一个集合, 也可以是单个个体. 比如班级 classes 是代表一个集合形式的资源, 而特定的 class 代表单个个体资源. 每种资源都有特定的 URI(统一资源定位符)与之对应, 如果需要获取这个资源, 访问这个 URI 即可, 比如获取特定的班级: /class/12.")]),t._v(" "),s("h6",{attrs:{id:"_2-表征-representation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-表征-representation"}},[t._v("#")]),t._v(" (2)表征(Representation)")]),t._v(" "),s("p",[t._v('当通过浏览器阅读此文章时, 浏览器会向服务端发出 "我需要这个资源的 '),s("strong",[t._v("HTML 格式")]),t._v('" 的请求, 服务端向浏览器返回的这个 HTML 就被称为"'),s("strong",[t._v("表征")]),t._v('" '),s("strong",[t._v(";")]),t._v("  你也可以通过其他方式拿到文章的 PDF, Markdown, TXT 等其他形式的版本, 它们同样是"),s("strong",[t._v("一个资源的多种表征")]),t._v('. 可见 "表征"是指'),s("strong",[t._v("信息与用户交互时的表示形式")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_3-状态-state"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-状态-state"}},[t._v("#")]),t._v(" (3)状态(State)")]),t._v(" "),s("p",[t._v('当读完后想继续看后面的内容时, 你向服务端发出 "给我下一篇文章" 的请求. 但是"下一篇"是个相对概念, 必须依赖 "当前正在阅读的文章是哪一篇" 才能正确回应, 这类在特定语境中才能产生的'),s("strong",[t._v('上下文信息被称为"状态"')]),t._v(" . 平时所说的有状态(Stateful)或无状态(Stateless), 都是"),s("strong",[t._v("只相对于服务端")]),t._v('的, 服务端要完成"取下一篇"的请求, 要么自己记住用户的状态, 如这个用户现在阅读的是哪一篇文章, 这称为有状态; 要么由客户端来记住状态, 在请求的时候明确告诉服务端读完了哪一篇, 现在要读它的下一篇, 这称为无状态.')]),t._v(" "),s("h6",{attrs:{id:"_4-转移-transfer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-转移-transfer"}},[t._v("#")]),t._v(" (4)转移(Transfer)")]),t._v(" "),s("p",[t._v('无论状态是由服务端还是由客户端来提供, "取下一篇文章" 这个行为逻辑只能由服务端来提供, 因为'),s("strong",[t._v("只有服务端拥有该资源及其表征形式")]),t._v(". "),s("strong",[t._v('服务端通过某种方式, 把 "用户当前阅读的文章" 转变成 "下一篇文章", 这就被称为"表征状态转移"')]),t._v(" .")]),t._v(" "),s("p",[t._v("状态转移更多地描述的"),s("strong",[t._v("服务器端资源的状态")]),t._v(", 比如通过"),s("strong",[t._v("增删改查")]),t._v("(通过 HTTP 动词实现)"),s("strong",[t._v("引起资源状态的改变")]),t._v(".")]),t._v(" "),s("p",[t._v("再来几个概念.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("统一接口")]),t._v('(Uniform Interface): 上面说的服务端 "通过某种方式" 让表征状态转移, 那具体是什么方式呢? 比如文章的 URI 超链接地址就是所谓"某种方式"的其中一种方式. URI 的含义是统一资源标识符, 是一个'),s("strong",[t._v("名词")]),t._v(', 如何能表达出"转移"动作的含义呢? 答案是 HTTP 协议中已经提前'),s("strong",[t._v('约定好了一套"统一接口"')]),t._v(" , 它包括 GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS 七种基本操作, 任何一个支持 HTTP 协议的服务器都会遵守这套规定, 对特定的 URI 采取这些操作, 服务器就会"),s("strong",[t._v("触发相应的表征状态转移")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("超文本驱动")]),t._v("(Hypertext Driven): 尽管表征状态转移是由"),s("strong",[t._v("浏览器主动向服务器发出请求")]),t._v('所引发的, 该请求导致了"在浏览器屏幕上显示出了下一篇文章的内容"的结果. 浏览器作为所有网站的通用的客户端, 任何网站的导航(状态转移)行为都不可能是预置于浏览器代码之中, 而是由服务器发出的'),s("strong",[t._v("请求响应信息(超文本)")]),t._v(" 来驱动的. 这点与其他带有客户端的软件有十分本质的区别, 在那些软件中, 业务逻辑往往是预置于程序代码之中的, 有专门的页面控制器(无论在服务端还是在客户端中)来驱动页面的状态转移.")]),t._v(" "),s("li",[s("strong",[t._v("自描述消息")]),t._v("(Self-Descriptive Message): 由于资源的表征可能存在多种"),s("strong",[t._v("不同形态")]),t._v(', 在消息中应当有明确的信息来告知客户端该消息的类型以及应如何处理这条消息. 一种被广泛采用的自描述方法是在名为 "Content-Type" 的 HTTP Header 中标识出互联网媒体类型(MIME type), 譬如 "Content-Type:application/json;charset=utf-8" 说明该资源会以 JSON 的格式来返回, 并使用 UTF-8 字符集进行处理.')])]),t._v(" "),s("h5",{attrs:{id:"_3-restful的系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-restful的系统"}},[t._v("#")]),t._v(" 3.RESTful的系统")]),t._v(" "),s("p",[t._v("一套理想的, 完全满足 REST 风格的系统应该满足以下"),s("strong",[t._v("六大原则")]),t._v(". 注意: 能完全符合 REST 所有指导原则的系统并不多见. 这些原则均出自 Fielding 关于 REST 的论文.")]),t._v(" "),s("h6",{attrs:{id:"_1-客户端与服务端分离-client-server"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-客户端与服务端分离-client-server"}},[t._v("#")]),t._v(" (1)客户端与服务端分离(Client-Server)")]),t._v(" "),s("p",[t._v("将用户界面所关注的逻辑和数据存储所关注的逻辑分离开来, 有助于提高用户界面的跨平台的可移植性. 其实说的是前后端分离.")]),t._v(" "),s("h6",{attrs:{id:"_2-无状态-stateless"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-无状态-stateless"}},[t._v("#")]),t._v(" (2)无状态(Stateless)")]),t._v(" "),s("p",[t._v("无状态是 REST 的一条核心原则, 如果在做服务接口规划时, 觉得 REST 风格的服务怎么设计都感觉别扭, 很可能的一个原因是服务端持有比较重的状态. REST 希望服务端不用负责维护状态, 每一次从客户端发送的"),s("strong",[t._v("请求中, 应包括所有必要的上下文信息, 会话信息也由客户端负责保存维护")]),t._v(", 服务端只依据客户端传递的状态来执行业务处理逻辑, 驱动整个应用的状态变迁. 客户端承担状态维护职责以后, 会产生一些新的问题, 譬如"),s("strong",[t._v("身份认证, 授权等可信问题")]),t._v(", 它们都应有针对性的解决方案.")]),t._v(" "),s("p",[t._v("但必须承认的是, 目前大多数系统都达不到这个要求, 且越复杂, 越大型的系统越是如此. 服务端无状态可以在"),s("strong",[t._v("分布式系统")]),t._v("中获得非常高价值的回报, 但大型系统的上下文状态数量完全可能膨胀到客户端无法承受的程度, 在服务端的内存, 会话, 数据库或缓存等地方持有一定的状态成为一种事实上存在, 并将长期存在, 被广泛使用的主流方案.")]),t._v(" "),s("h6",{attrs:{id:"_3-可缓存-cacheability"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-可缓存-cacheability"}},[t._v("#")]),t._v(" (3)可缓存(Cacheability)")]),t._v(" "),s("p",[t._v('无状态服务虽然提升了系统的可见性, 可靠性和可伸缩性, 但降低了系统的网络性. "降低网络性"的通俗解释是某个功能使用有状态的设计时只需要一次(或少量)请求就能完成, 使用无状态的设计时则可能会需要多次请求, 或者在请求中带有额外冗余的信息. 为了缓解这个矛盾, REST 希望软件系统允许客户端和中间的通信传递者(譬如代理)将部分服务端的应答缓存起来.')]),t._v(" "),s("p",[t._v("当然, 为了缓存能够正确地运作, 服务端的应答中必须直接或间接地表明本身是否可以进行缓存, 可以缓存多长时间, 以避免客户端在将来进行请求的时候得到过时的数据. 运作良好的缓存机制可以减少客户端, 服务端之间的交互, 甚至有些场景中可以完全避免交互, 这就进一步提高了性能.")]),t._v(" "),s("h6",{attrs:{id:"_4-分层系统-layered-system"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-分层系统-layered-system"}},[t._v("#")]),t._v(" (4)分层系统(Layered System)")]),t._v(" "),s("p",[t._v("这里的分层并不是表示层, 服务层, 持久层这种意义上的分层, 而是指客户端一般不需要知道是否直接连接到了最终的服务器, 抑或连接到路径上的中间服务器. 中间服务器可以通过负载均衡和共享缓存的机制提高系统的可扩展性, 这样也便于缓存, 伸缩和安全策略的部署.")]),t._v(" "),s("p",[t._v("该原则的典型应用是内容分发网络(CDN). 比如浏览器加载的一张 Google 的图片可能是通过国内的 CDN 服务器来的, 作为用户完全不需要感知到这一点.")]),t._v(" "),s("h6",{attrs:{id:"_5-统一接口-uniform-interface"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-统一接口-uniform-interface"}},[t._v("#")]),t._v(" (5)统一接口(Uniform Interface)")]),t._v(" "),s("p",[t._v("这是 REST 的另一条核心原则, REST 希望开发者"),s("strong",[t._v("面向资源编程")]),t._v(", 希望软件系统设计的重点放在抽象系统该有哪些资源, 而不是抽象系统该有哪些行为(服务)上.")]),t._v(" "),s("p",[t._v("这条原则可以类比计算机中对文件管理的操作来理解, 管理文件可能会涉及创建, 修改, 删除, 移动等操作, 这些操作数量是可数的, 而且对所有文件都是固定, 统一的. 如果面向资源来设计系统, 同样会具有类似的操作特征, 由于 REST 并没有设计新的协议, 所以这些操作都借用了 HTTP 协议中固有的操作命令来完成.")]),t._v(" "),s("p",[t._v("如果想要在架构设计中合理恰当地利用统一接口, 建议系统应能做到每次请求中都包含资源的 ID, 所有操作均通过资源 ID 来进行; 建议每个资源都应该是自描述的消息; 建议通过超文本来驱动应用状态的转移.")]),t._v(" "),s("h6",{attrs:{id:"_6-按需代码-code-on-demand"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-按需代码-code-on-demand"}},[t._v("#")]),t._v(" (6)按需代码(Code-On-Demand)")]),t._v(" "),s("p",[t._v("按需代码是一条可选原则. 它是指任何按照客户端(譬如浏览器)的请求, 将可执行的软件程序从服务端发送到客户端的技术. 按需代码赋予了客户端无须事先知道所有来自服务端的信息应该如何处理, 如何运行的宽容度.")]),t._v(" "),s("h5",{attrs:{id:"_4-rest的好处与坏处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-rest的好处与坏处"}},[t._v("#")]),t._v(" 4.REST的好处与坏处")]),t._v(" "),s("h6",{attrs:{id:"_1-好处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-好处"}},[t._v("#")]),t._v(" (1)好处")]),t._v(" "),s("ul",[s("li",[t._v("降低服务接口的学习成本. 统一接口是 REST 的重要标志, 它将对资源的标准操作都映射到标准的 HTTP 方法上去, 这些方法对于每个资源的用法都是一致的, 语义都是类似的, 不需要刻意去学习.")]),t._v(" "),s("li",[t._v("资源天然具有集合与层次结构. 以方法为中心抽象的接口, 由于方法是动词, 逻辑上决定了每个接口都是互相独立的; 但以资源为中心抽象的接口, 由于资源是名词, 天然就可以产生集合与层次结构.")]),t._v(" "),s("li",[t._v("REST 绑定于 HTTP 协议. 面向资源编程不是必须构筑在 HTTP 之上, 但 REST 是, 这是缺点, 也是优点.")])]),t._v(" "),s("h6",{attrs:{id:"_2-不足与争议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-不足与争议"}},[t._v("#")]),t._v(" (2)不足与争议")]),t._v(" "),s("ul",[s("li",[t._v("REST 与 HTTP 完全绑定, 不适合应用于要求高性能传输的场景中.")]),t._v(" "),s("li",[t._v('REST 缺乏对资源进行"部分"和"批量"处理的能力.')])]),t._v(" "),s("p",[t._v("是否选用 REST 的 API 设计风格, 需要结合具体的需求场景, 以及团队的设计和开发人员是否能够适应面向资源的思想来设计软件来权衡.")]),t._v(" "),s("h5",{attrs:{id:"_4-restful接口设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-restful接口设计"}},[t._v("#")]),t._v(" 4.RESTful接口设计")]),t._v(" "),s("p",[t._v("RESTful API 可以通过 "),s("strong",[t._v("URL + HTTP 方法")]),t._v("就看出 URL 的作用, 通过请求后得到 "),s("strong",[t._v("HTTP 状态码")]),t._v("(status code)就知道请求"),s("strong",[t._v("结果")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_1-动作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-动作"}},[t._v("#")]),t._v(" (1)动作")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("GET")]),t._v(": 从服务器"),s("strong",[t._v("获取")]),t._v('特定资源. 如 "GET /classes", 获取所有班级.')]),t._v(" "),s("li",[s("strong",[t._v("POST")]),t._v(": 在服务器上"),s("strong",[t._v("创建")]),t._v('一个新的资源. 如 "POST /classes", 创建班级.')]),t._v(" "),s("li",[s("strong",[t._v("PUT")]),t._v(": "),s("strong",[t._v("更新")]),t._v('服务器上的资源(客户端提供更新后的整个资源). 如 "PUT /classes/12", 更新编号为 12 的班级.')]),t._v(" "),s("li",[s("strong",[t._v("DELETE")]),t._v(": 从服务器"),s("strong",[t._v("删除")]),t._v('特定的资源. 如 "DELETE /classes/12", 删除编号为 12 的班级.')]),t._v(" "),s("li",[s("strong",[t._v("PATCH")]),t._v(": 更新服务器上的资源(客户端提供更改的属性, 可以看做作是"),s("strong",[t._v("部分")]),t._v("更新), 使用"),s("strong",[t._v("比较少")]),t._v(".")])]),t._v(" "),s("h6",{attrs:{id:"_2-路径-接口命名"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-路径-接口命名"}},[t._v("#")]),t._v(" (2)路径(接口命名)")]),t._v(" "),s("p",[t._v("一般规范:")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("路径中不能有动词, 只能有名词")]),t._v('. 因为 REST 中资源往往与数据库表对应, 而数据库表都是同种记录的 "集合". 如果 API 调用'),s("strong",[t._v("并不涉及资源")]),t._v("(如计算, 翻译等操作)的话, "),s("strong",[t._v("可以用动词")]),t._v(". 如: GET /calculate?param1=11&param2=33.")]),t._v(" "),s("li",[s("strong",[t._v("不用大写字母")]),t._v(", 建议"),s("strong",[t._v("用中杠 - 不用下杠 _")]),t._v(" . 如邀请码写成 invitation-code 而不是 "),s("s",[t._v("invitation_code")]),t._v(".")])]),t._v(" "),s("p",[s("strong",[t._v("正例")]),t._v(":")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[t._v("GET    /classes: 列出所有班级\nPOST   /classes: 新建一个班级\nGET    /classes/classId: 获取某个指定班级的信息\nPUT    /classes/classId: 更新某个指定班级的信息(一般倾向整体更新)\nPATCH  /classes/classId: 更新某个指定班级的信息(一般倾向部分更新)\nDELETE /classes/classId: 删除某个班级\nGET    /classes/classId/teachers: 列出某个指定班级的所有老师的信息\nGET    /classes/classId/students: 列出某个指定班级的所有学生的信息\nDELETE /classes/classId/teachers/ID: 删除某个指定班级下的指定的老师的信息\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br")])]),s("p",[s("strong",[t._v("反例:")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("/getAllclasses\n/createNewclass\n/deleteAllActiveclasses\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("定义路径时应该分析"),s("strong",[t._v("业务资源的层次结构")]),t._v(". 比如业务针对的范围是学校, 那么学校(/school)是"),s("strong",[t._v("一级")]),t._v("资源; 老师(/school/teachers) 和学生(/school/student) 就是"),s("strong",[t._v("二级")]),t._v("资源.")]),t._v(" "),s("h6",{attrs:{id:"_3-参数与信息过滤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-参数与信息过滤"}},[t._v("#")]),t._v(" (3)参数与信息过滤")]),t._v(" "),s("p",[t._v("如果在查询的时候需要"),s("strong",[t._v("添加特定条件")]),t._v("的话, 建议使用 "),s("strong",[t._v("URL 参数")]),t._v("的形式. 比如要查询 state 状态为 active 并且 name 为 Jack 的班级:")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("GET")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("classes"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("active"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Jack")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h3",{attrs:{id:"事务处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务处理"}},[t._v("#")]),t._v(" 事务处理")]),t._v(" "),s("h4",{attrs:{id:"事务基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务基础"}},[t._v("#")]),t._v(" 事务基础")]),t._v(" "),s("p",[t._v("事务处理几乎在每一个信息系统中都会涉及, 它存在的意义是为了保证系统中所有的数据都是符合期望的, 且相互关联的数据之间不会产生矛盾, 即"),s("strong",[t._v("数据状态的一致性")]),t._v("(Consistency). 按照数据库的经典理论, 要达成这个目标, 需要三方面共同努力来保障即原子性, 隔离性和持久性. 这几个特性合称 ACID.")]),t._v(" "),s("p",[t._v("其实这四种特性并不正交, "),s("mark",[s("strong",[t._v("A, I, D是手段, C是目的")])]),t._v(", 前者是因, 后者是果, 写到一块完全是为了拼凑个单词缩写.")]),t._v(" "),s("p",[t._v("事务的概念虽然最初起源于数据库系统, 但今天已经不再局限于数据库本身了. 所有需要"),s("strong",[t._v("保证数据一致性")]),t._v('的应用场景, 包括但不限于数据库, 事务内存, 缓存, 消息队列, 分布式存储等, 都有可能用到事务. 这里使用"数据源"来泛指所有这些场景中提供与存储数据的逻辑设备.')]),t._v(" "),s("ul",[s("li",[t._v("当一个服务"),s("strong",[t._v("只使用一个数据源")]),t._v("时, 通过 A, I, D 来获得一致性是最经典的做法, 也是相对容易的. 此时, 多个并发事务所读写的数据能够被数据源感知是否存在冲突, 并发事务的读写在时间线上的"),s("strong",[t._v("最终顺序是由数据源")]),t._v('来确定的, 这种事务间一致性被称为"'),s("strong",[t._v("内部一致性")]),t._v('".')]),t._v(" "),s("li",[t._v("当一个服务"),s("strong",[t._v("使用到多个不同的数据源")]),t._v(', 甚至多个不同服务同时涉及多个不同的数据源时, 问题就变得困难了许多. 此时并发执行甚至是先后执行的多个事务, 在时间线上的顺序并不由任何一个数据源来决定, 这种涉及多个数据源的事务间一致性被称为"'),s("strong",[t._v("外部一致性")]),t._v('".')])]),t._v(" "),s("p",[t._v("外部一致性问题通常很难使用 A, I, D 来解决, 因为这样需要付出很大甚至不切实际的代价; 但是"),s("strong",[t._v("外部一致性又是分布式系统中必然会遇到且必须要解决的问题")]),t._v('. 为此要转变观念, 将一致性从"是或否"的二元属性转变为可以按'),s("strong",[t._v("不同强度分开讨论的多元属性")]),t._v(', 在确保代价可承受的前提下获得强度尽可能高的一致性保障, 也正因如此, 事务处理才从一个具体操作上的"编程问题"上升成一个需要全局权衡的"架构问题".')]),t._v(" "),s("p",[t._v("后面通过同一个场景来分析事务.")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Fenix’s Bookstore 是一个在线书店. 当一本书被成功售出时, 需要确保以下三件事情被正确地处理: \n1. 用户的账户扣款; \n2. 商品仓库中减库存, 将商品标识为待配送状态; \n3. 商家的账账户收款.  \n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v('下面将逐一介绍在"'),s("strong",[t._v("单个服务使用单个数据源")]),t._v('", "'),s("strong",[t._v("单个服务使用多个数据源")]),t._v('", "'),s("strong",[t._v("多个服务使用单个数据源")]),t._v('"以及"'),s("strong",[t._v("多个服务使用多个数据源")]),t._v('"下, 可以采用哪些手段来保证数据在以上场景中被正确地读写.')]),t._v(" "),s("h4",{attrs:{id:"本地事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#本地事务"}},[t._v("#")]),t._v(" 本地事务")]),t._v(" "),s("p",[t._v("本地事务(Local Transaction)"),s("strong",[t._v("是指仅操作单一事务资源的, 不需要全局事务管理器进行协调的事务")]),t._v('. 其实本地事务应该翻译成"'),s("strong",[t._v("局部事务")]),t._v('"才好与稍后的"全局事务"相对应, 不过现在"本地事务"的译法似乎已经成为主流, 这里也就不纠结名称了.')]),t._v(" "),s("p",[t._v("本地事务是一种最基础的事务解决方案, 只适用于"),s("strong",[t._v("单个服务使用单个数据源")]),t._v("的场景. 从应用角度看, 它是直接"),s("strong",[t._v("依赖于数据源本身提供的事务能力")]),t._v("来工作的, 在程序代码层面, 最多只能对事务接口做一层标准化的包装(如 JDBC 接口), 并不能深入参与到事务的运作过程中, 事务的开启, 终止, 提交, 回滚, 嵌套, 设置隔离级别, 乃至与应用代码贴近的事务传播方式, 全部都要"),s("strong",[t._v("依赖底层数据源的支持才能工作")]),t._v(", 这一点与后续介绍的 XA, TCC, SAGA 等主要靠应用程序代码来实现的事务有着十分明显的区别. 举个例子, 假设代码调用了 JDBC 中的 Transaction::rollback() 方法, 方法的成功执行也并不一定代表事务就已经被成功回滚, 如果数据表采用的引擎是 MyISAM, 那 rollback() 方法便是一项没有意义的空操作.")]),t._v(" "),s("p",[t._v("因此, 要想深入讨论本地事务, 便不得不越过应用代码的层次, 去了解一些"),s("strong",[t._v("数据库本身的事务实现原理")]),t._v(", 弄明白传统数据库管理系统是如何通过 ACID 来实现事务的.")]),t._v(" "),s("h5",{attrs:{id:"_1-实现原子性和持久性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-实现原子性和持久性"}},[t._v("#")]),t._v(" 1.实现原子性和持久性")]),t._v(" "),s("h6",{attrs:{id:"_1-崩溃恢复"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-崩溃恢复"}},[t._v("#")]),t._v(" (1)崩溃恢复")]),t._v(" "),s("p",[s("strong",[t._v("原子性和持久性")]),t._v("在事务里是密切相关的两个属性: 原子性保证了事务的多个操作要么都生效要么都不生效, 不会存在中间状态; 持久性保证了一旦事务生效, 就不会再因为任何原因而导致其修改的内容被撤销或丢失.")]),t._v(" "),s("p",[t._v("众所周知, 数据必须要成功"),s("strong",[t._v("写入磁盘")]),t._v(', 磁带等持久化存储器后才能拥有持久性, 只存储在内存中的数据, 一旦遇到应用程序忽然崩溃, 或者数据库, 操作系统一侧崩溃, 甚至是机器突然断电宕机等情况就会丢失, 后面将这些意外情况都统称为"崩溃"(Crash). 实现原子性和持久性的最大困难是 '),s("strong",[t._v('"写入磁盘"这个操作并不是原子的, 不仅有"写入"与"未写入"状态, 还客观存在着"正在写"的中间状态')]),t._v(". 由于写入中间状态与崩溃都不可能消除, 所以如果不做额外保障措施的话, 将内存中的数据写入磁盘, 并不能保证原子性与持久性. 下面通过具体事例来说明.")]),t._v(" "),s("p",[t._v("按照前面预设的场景事例, 从书店购买一本书需要修改三个数据, 由于写入存在中间状态, 所以可能出现以下情形.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("未提交事务, 写入后崩溃")]),t._v(": 程序还"),s("strong",[t._v("没修改完三个数据")]),t._v(", 但数据库已经将其中一个或两个数据的变动写入磁盘, 若此时出现崩溃, 一旦重启之后, 数据库必须要有办法"),s("strong",[t._v("得知崩溃前")]),t._v("发生过一次不完整的购物操作, 将已经修改过的数据从磁盘中"),s("strong",[t._v("恢复成没有改过")]),t._v("的样子, 以保证"),s("strong",[t._v("原子性")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("已提交事务, 写入前崩溃")]),t._v(": 程序已经"),s("strong",[t._v("修改完三个数据")]),t._v(", 但数据库还未将全部三个数据的变动都写入磁盘, 若此时出现崩溃, 一旦重启之后, 数据库必须要有办法得知崩溃前发生过一次完整的购物操作, 将还没来得及写入磁盘的那部分数据"),s("strong",[t._v("重新写入")]),t._v(", 以保证"),s("strong",[t._v("持久性")]),t._v(".")])]),t._v(" "),s("p",[t._v('由于写入中间状态与崩溃都是无法避免的, 为了保证原子性和持久性, 就只能在崩溃后采取恢复的补救措施, 这种数据恢复操作被称为"'),s("strong",[t._v("崩溃恢复")]),t._v('"(Crash Recovery).')]),t._v(" "),s("h6",{attrs:{id:"_2-提交日志-commit-logging"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-提交日志-commit-logging"}},[t._v("#")]),t._v(" (2)提交日志(Commit Logging)")]),t._v(" "),s("p",[t._v("为了能够顺利地完成崩溃恢复, 在磁盘中写入数据就不能像程序修改内存中的变量值那样, 直接改变某表某行某列的某个值, 而是"),s("strong",[t._v("必须将修改数据这个操作所需的全部信息, 包括修改什么数据, 数据物理上位于哪个内存页和磁盘块中, 从什么值改成什么值, 等等, 以日志的形式---即以仅进行")]),t._v("​"),s("mark",[s("strong",[t._v("顺序追加的文件写入")])]),t._v("​"),s("strong",[t._v("的形式(这是最高效的写入方式)先记录到磁盘中")]),t._v('. 只有在日志记录全部安全落盘, 数据库在日志中看到代表事务成功提交的"提交记录"(Commit Record)后, '),s("strong",[t._v("才会根据日志上的信息对真正的数据进行修改")]),t._v(', 修改完成后, 再在日志中加入一条"结束记录"(End Record)表示事务已完成持久化, 这种事务实现方法被称为"'),s("strong",[t._v("提交日志")]),t._v('"(Commit Logging).')]),t._v(" "),s("p",[t._v("Commit Logging 保障数据持久性, 原子性的原理并不难理解: "),s("strong",[t._v("首先, 日志一旦成功写入 Commit Record, 那整个事务就是成功的, 即使真正修改数据时崩溃了, 重启后根据已经写入磁盘的日志信息")]),t._v("​"),s("mark",[s("strong",[t._v("恢复现场")])]),t._v("​ "),s("strong",[t._v(", 继续修改数据即可, 这保证了")]),t._v("​"),s("mark",[s("strong",[t._v("持久性")])]),t._v("​ "),s("strong",[t._v("; 其次, 如果日志没有成功写入Commit Record 就发生崩溃, 那整个事务就是失败的, 系统重启后会看到一部分没有 Commit Record 的日志, 将这部分日志标记为")]),t._v("​"),s("mark",[s("strong",[t._v("回滚状态")])]),t._v("​"),s("strong",[t._v("即可, 整个事务就像完全没有发生过一样, 这保证了")]),t._v("​"),s("mark",[s("strong",[t._v("原子性")])]),t._v(".")]),t._v(" "),s("p",[t._v("通过日志实现事务的原子性和持久性是当今的主流方案, 但"),s("strong",[t._v("并不是唯一")]),t._v('的选择. 除日志外, 还有另外一种称为"Shadow Paging"(有的翻译为"影子分页")的事务实现机制, 轻量级数据库 SQLite采用的事务机制就是 Shadow Paging. Shadow Paging 的大体思路是对数据的变动会写到硬盘的数据中, 但不是直接就地修改原先的数据, 而是先复制一份副本, 保留原数据, 修改副本数据. 在事务处理过程中, 被修改的数据会同时存在两份, 一份是修改前的数据, 一份是修改后的数据, 这也是"影子"(Shadow)这个名字的由来. 当事务成功提交, 所有数据的修改都成功持久化之后, 最后一步是修改数据的引用指针, 将引用从原数据改为新复制并修改后的副本, 最后的"修改指针"这个操作将被认为是原子操作, 现代磁盘的写操作的作用可以认为是保证了在硬件上不会出现"改了半个值"的现象. 所以 Shadow Paging 也可以保证原子性和持久性. Shadow Paging 实现事务要比 Commit Logging 更加简单, 但涉及隔离性与并发锁时, Shadow Paging 实现的事务并发能力就相对有限, 因此在高性能的数据库中应用不多.')]),t._v(" "),s("h6",{attrs:{id:"_3-提前写入日志-write-ahead-logging"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-提前写入日志-write-ahead-logging"}},[t._v("#")]),t._v(" (3)提前写入日志(Write-Ahead Logging)")]),t._v(" "),s("p",[t._v("Commit Logging 的原理很清晰, 也确实有一些数据库就是直接采用 Commit Logging 机制来实现事务的, 譬如较具代表性的是阿里的 OceanBase. 但 Commit Logging 存在一个巨大的先天"),s("strong",[t._v("缺陷")]),t._v(": "),s("strong",[t._v("所有对数据的真实修改都必须发生在事务提交以后, 即日志写入了 Commit Record 之后")]),t._v('. 在此之前, 即使磁盘 I/O 有足够空闲, 即使某个事务修改的数据量非常庞大, 占用了大量的内存缓冲区, 无论何种理由, 都决不允许在事务提交之前就修改磁盘上的数据, 这一点是 Commit Logging 成立的前提, 却对提升数据库的性能十分不利. 为此, ARIES 提出了"'),s("strong",[t._v("提前写入日志")]),t._v('"(Write-Ahead Logging) 的日志改进方案, 所谓"提前写入"(Write-Ahead), 就是允许在事务提交之前写入变动数据的意思.')]),t._v(" "),s("p",[t._v("Write-Ahead Logging "),s("strong",[t._v("按照事务提交时点, 将何时写入变动数据")]),t._v("划分为 "),s("strong",[t._v("FORCE")]),t._v(" 和 "),s("strong",[t._v("STEAL")]),t._v(" 两类情况.")]),t._v(" "),s("ul",[s("li",[s("mark",[s("strong",[t._v("FORCE")])]),t._v(": 当事务"),s("strong",[t._v("提交后")]),t._v(", 要求变动数据必须"),s("strong",[t._v("同时完成写入")]),t._v("则称为 FORCE, 如果不强制变动数据必须同时完成写入则称为 NO-FORCE. 现实中"),s("strong",[t._v("绝大多数数据库采用的都是 NO-FORCE 策略")]),t._v(", 因为只要有了日志, 变动数据随时可以持久化, 从优化磁盘 I/O 性能考虑, 没有必要强制数据写入时立即进行.")]),t._v(" "),s("li",[s("mark",[s("strong",[t._v("STEAL")])]),t._v(": 在事务"),s("strong",[t._v("提交前")]),t._v(", "),s("strong",[t._v("允许变动数据提前写入")]),t._v("则称为 STEAL, 不允许则称为 NO-STEAL. 从优化磁盘 I/O 性能考虑, "),s("strong",[t._v("允许数据提前写入")]),t._v(", 有利于利用空闲 I/O 资源, 也有利于节省数据库缓存区的内存.")])]),t._v(" "),s("p",[s("strong",[t._v("Commit Logging 允许 NO-FORCE, 但不允许 STEAL")]),t._v(". 因为假如事务提交前就有部分变动数据写入磁盘, 那一旦事务要回滚, 或者发生了崩溃, 这些提前写入的变动数据就都成了错误.")]),t._v(" "),s("p",[s("strong",[t._v("Write-Ahead Logging 允许 NO-FORCE, 也允许 STEAL")]),t._v(", 它给出的解决办法是增加了另一种被称为 "),s("mark",[s("strong",[t._v("Undo Log 的日志类型")])]),t._v(", 当变动数据写入磁盘前, 必须先记录 Undo Log, 注明修改了哪个位置的数据, 从什么值改成什么值等, 以便在事务回滚或者崩溃恢复时根据 Undo Log 对提前写入的数据变动进行擦除. "),s("strong",[t._v("Undo Log")]),t._v(' 现在一般被翻译为"'),s("mark",[t._v("回滚日志")]),t._v('", 此前记录的用于崩溃恢复时重演数据变动的日志(Commit Log)就相应被命名为 '),s("strong",[t._v("Redo Log")]),t._v(', 一般翻译为"'),s("mark",[t._v("重做日志")]),t._v('". 由于 Undo Log 的加入, Write-Ahead Logging 在崩溃恢复时会经历以下三个阶段.')]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("分析阶段")]),t._v("(Analysis): 该阶段从最后一次检查点(Checkpoint, 可理解为在这个点之前所有应该持久化的变动都已安全落盘)开始扫描日志, 找出所有没有 End Record 的事务, 组成待恢复的事务集合, 这个集合至少会包括事务表(Transaction Table)和脏页表(Dirty Page Table)两个组成部分.")]),t._v(" "),s("li",[s("strong",[t._v("重做阶段")]),t._v("(Redo): 该阶段依据分析阶段中产生的待恢复的事务集合来重演历史(Repeat History), 具体操作是找出所有"),s("strong",[t._v("包含 Commit Record 的日志")]),t._v(", 将这些日志修改的数据写入磁盘, 写入完成后在日志中增加一条 End Record, 然后移出待恢复事务集合.")]),t._v(" "),s("li",[s("strong",[t._v("回滚阶段")]),t._v("(Undo): 该阶段处理经过分析, 重做阶段后剩余的恢复事务集合, 此时剩下的都是"),s("strong",[t._v("需要回滚")]),t._v("的事务, 它们被称为 Loser, 根据 Undo Log 中的信息, 将已经提前写入磁盘的信息重新改写回去, 以达到回滚这些 Loser 事务的目的.")])]),t._v(" "),s("p",[t._v("重做阶段和回滚阶段的操作都应该设计为"),s("strong",[t._v("幂等")]),t._v("的. 为了追求高 I/O 性能, 以上三个阶段无可避免地会涉及非常烦琐的概念和细节(如 Redo Log, Undo Log 的具体数据结构等). Write-Ahead Logging 是 ARIES 理论的一部分, 整套 ARIES 拥有严谨, 高性能等诸多优点, 但这些也是以"),s("strong",[t._v("高度复杂")]),t._v("为代价的.")]),t._v(" "),s("p",[t._v("数据库按照是否允许 FORCE 和 STEAL 可以产生四种组合, 从优化磁盘 I/O 的角度看, "),s("strong",[t._v("NO-FORCE 加 STEAL")]),t._v(" 的组合的性能无疑是最高的; 从算法实现与日志的角度看, NO-FORCE 加 STEAL 的组合的复杂度无疑也是最高的. 这四种组合与 Undo Log, Redo Log 之间的具体关系如图所示.")]),t._v(" "),s("p",[t._v("​"),s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221113152759772.png",alt:"image-20221113152759772"}}),t._v("​")]),t._v(" "),s("h5",{attrs:{id:"_2-实现隔离性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-实现隔离性"}},[t._v("#")]),t._v(" 2.实现隔离性")]),t._v(" "),s("h6",{attrs:{id:"_1-锁分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-锁分类"}},[t._v("#")]),t._v(" (1)锁分类")]),t._v(" "),s("p",[t._v("本节探讨数据库如何实现隔离性. 隔离性保证了每个事务各自读, 写的数据互相独立, 不会彼此影响. 只从定义上就能嗅出隔离性肯定与"),s("strong",[t._v("并发")]),t._v("密切相关, 因为如果没有并发, 所有事务全都是串行的, 那就不需要任何隔离, 或者说这样的访问具备了天然的隔离性. 但现实情况是不可能没有并发, 要如何在并发下实现串行的数据访问呢? 几乎所有人都会回答: "),s("strong",[t._v("加锁同步")]),t._v("! 正确, 现代数据库均提供了以下三种锁.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("写锁")]),t._v("(Write Lock, 也叫作"),s("strong",[t._v("排他锁")]),t._v(", eXclusive Lock, 简写为 X-Lock): 如果数据有加写锁, 就只有持有写锁的事务才能对数据进行写入操作, 数据加持着写锁时, "),s("strong",[t._v("其他事务不能写入数据, 也不能施加读锁")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("读锁")]),t._v("(Read Lock, 也叫作"),s("strong",[t._v("共享锁")]),t._v(", Shared Lock, 简写为 S-Lock): 多个事务可以对同一个数据添加多个读锁, 数据被加上读锁后就不能再被加上写锁, 所以其他事务不能对该数据进行写入, 但仍然可以读取. 对于持有读锁的事务, 如果该数据只有它自己一个事务加了读锁, 则允许直接将其升级为写锁, 然后写入数据.")]),t._v(" "),s("li",[s("strong",[t._v("范围锁")]),t._v("(Range Lock): 对于"),s("strong",[t._v("某个范围")]),t._v('直接加排他锁, 在这个范围内的数据不能被写入. 如下语句是典型的加范围锁的例子. 注意 "范围不能被写入" 与 "一批数据不能被写入" 的差别, 即不要把范围锁理解成一组排他锁的集合. 加了范围锁后, 不仅不能修改该范围内已有的数据, 也不能在该范围内新增或删除任何数据, 后者是一组排他锁的集合无法做到的.')])]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" books "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" price "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FOR")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h6",{attrs:{id:"_2-隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-隔离级别"}},[t._v("#")]),t._v(" (2)隔离级别")]),t._v(" "),s("p",[s("strong",[t._v("串行化")]),t._v("访问提供了最高强度的隔离性, ANSI/ISO SQL-92 标准中定义的最高等级的隔离级别便是可串行化(Serializable). 可串行化完全符合普通程序员对数据竞争加锁的理解, 如果不考虑性能优化的话, "),s("strong",[t._v("对事务所有读, 写的数据全都加上读锁")]),t._v(', 写锁和范围锁即可做到可串行化, "即可" 是简化理解, 实际还是很复杂的, 要分成'),s("strong",[t._v("加锁")]),t._v("(Expanding)和"),s("strong",[t._v("解锁")]),t._v("(Shrinking)两阶段去处理读锁, 写锁与数据间的关系, 称为"),s("strong",[t._v("两阶段锁")]),t._v("(Two-Phase Lock, 2PL). 但数据库不考虑性能肯定是不行的, 并发控制(Concurrency Control)理论决定了隔离程度与并发能力是相互抵触的, 隔离程度越高, 并发访问时的吞吐量就越低. 现代数据库一定会提供除可串行化以外的其他隔离级别供用户使用, 让用户"),s("strong",[t._v("自主调节隔离级别")]),t._v(", 根本目的是让用户可以调节数据库的加锁方式, 取得隔离性与吞吐量之间的平衡.")]),t._v(" "),s("p",[t._v("可串行化的下一个隔离级别是"),s("strong",[t._v("可重复读")]),t._v("(Repeatable Read), "),s("strong",[t._v("可重复读对事务所涉及的数据加读锁和写锁, 且一直持有至事务结束, 但不再加范围锁")]),t._v(". 可重复读比可串行化弱化的地方在于"),s("strong",[t._v("幻读问题")]),t._v("(Phantom Read), 它是指在事务执行过程中, 两个完全相同的范围查询得到了不同的结果集. 譬如现在要准备统计一下书店中售价小于 100 元的书的本数, 可以执行以下第一条 SQL 语句:")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 时间顺序: 1, 事务: T1 */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("count")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" books "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" price "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 时间顺序: 2, 事务: T2 */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INSERT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INTO")]),t._v(" books"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("price"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VALUES")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'深入理解Java虚拟机'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("90")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 时间顺序: 3, 事务: T1 */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("count")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" books "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" price "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("p",[t._v("根据前面对范围锁, 读锁和写锁的定义可知, 假如这条 SQL 语句在同一个事务中重复执行了两次, 且这两次执行之间恰好有另外一个事务在数据库插入了一本小于 100 元的书, 这是会被允许的, 那这两次相同的 SQL 查询就会得到不一样的结果, 原因是"),s("strong",[t._v("可重复读没有范围锁来禁止在该范围内插入新的数据, 这是一个事务受到其他事务影响, 隔离性被破坏的表现")]),t._v(".")]),t._v(" "),s("p",[t._v("注意, 这里的介绍是以 ARIES 理论为讨论目标, 具体的"),s("strong",[t._v("数据库并不一定要完全遵照理论去实现")]),t._v(". 一个例子是 MySQL/InnoDB 的默认隔离级别为可重复读, 但它在只读事务中可以完全避免幻读问题, 譬如上面例子中事务 T1 只有查询语句, 是一个只读事务, 所以上述问题在 MySQL 中并不会出现. 但在"),s("strong",[t._v("读写")]),t._v("事务中, MySQL 仍然会出现幻读问题, 譬如例子中事务 T1 如果在其他事务插入新书后, 不是重新查询一次数量, 而是将所有小于 100 元的书改名, 那就依然会受到新插入书的影响.")]),t._v(" "),s("p",[t._v("可重复读的下一个隔离级别是"),s("strong",[t._v("读已提交")]),t._v("(Read Committed), "),s("strong",[t._v("读已提交对事务涉及的数据加的写锁会一直持续到事务结束, 但加的读锁在查询操作完成后会马上释放")]),t._v(". 读已提交比可重复读弱化的地方在于"),s("strong",[t._v("不可重复读问题")]),t._v("(Non-Repeatable Read), 它是指在事务执行过程中, 对同一行数据的两次查询得到了不同的结果. 譬如笔者要获取书店中《深入理解Java虚拟机》的售价, 同样执行了两条 SQL 语句, 在此两条语句执行之间, 恰好有另外一个事务修改了这本书的价格, 将书的价格从 90 元调整到了 110 元, 如下 SQL 所示:")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 时间顺序: 1, 事务: T1 */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" books "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 时间顺序: 2, 事务: T2 */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),t._v(" books "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" price "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("110")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("COMMIT")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 时间顺序: 3, 事务: T1 */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" books "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("COMMIT")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("p",[t._v("如果隔离级别是读已提交, 这两次重复执行的查询结果就会不一样, 原因是读已提交的隔离级别"),s("strong",[t._v("缺乏贯穿整个事务周期的读锁")]),t._v(", 无法禁止读取过的数据发生变化, 此时事务 T2 中的更新语句可以马上提交成功, 这也是一个事务受到其他事务影响, 隔离性被破坏的表现. 假如隔离级别是可重复读, 由于数据已被事务 T1 施加了读锁且读取后不会马上释放, 所以事务 T2 无法获取到写锁, 更新就会被阻塞, 直至事务 T1 被提交或回滚后才能提交.")]),t._v(" "),s("p",[t._v("读已提交的下一个级别是"),s("strong",[t._v("读未提交")]),t._v("(Read Uncommitted), 它"),s("strong",[t._v("只会对事务涉及的数据加写锁, 且一直持续到事务结束, 但完全不加读锁")]),t._v(". 读未提交比读已提交弱化的地方在于"),s("strong",[t._v("脏读问题")]),t._v("(Dirty Read), 它是指在事务执行过程中, 一个事务读取到了另一个事务未提交的数据. 譬如笔者觉得《深入理解Java虚拟机》从 90 元涨价到 110 元是损害消费者利益的行为, 又执行了一条更新语句把价格改回了 90 元, 在提交事务之前, 同事说这并不是随便涨价, 而是印刷成本上升导致的, 按 90 元卖要亏本, 于是笔者随即回滚了事务, 如下 SQL 所示:")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 时间顺序: 1, 事务: T1 */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" books "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 注意没有COMMIT */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 时间顺序: 2, 事务: T2 */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),t._v(" books "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" price "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("90")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 这条SELECT模拟购书的操作的逻辑 */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 时间顺序: 3, 事务: T1 */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" books "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 时间顺序: 4, 事务: T2 */")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ROLLBACK")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("p",[t._v("不过, 在之前修改价格后, 事务 T1 已经按 90 元的价格卖出了几本. 原因是读未提交在数据上完全不加读锁, 这反而令它能读到其他事务加了写锁的数据, 即上述事务 T1 中两条查询语句得到的结果"),s("strong",[t._v("并不相同")]),t._v('. 如果你不能理解这句话中的"反而"二字, 请再读一次写锁的定义: 写锁禁止其他事务施加读锁, 而不是禁止事务读取数据, 如果事务 T1 读取数据前并不需要加读锁的话, 就会导致事务 T2 未提交的数据也马上能被事务 T1 所读到. 这同样是一个事务受到其他事务影响, 隔离性被破坏的表现. 假如隔离级别是读已提交的话, 由于事务 T2 持有数据的写锁, 所以事务 T1 的第二次查询就无法获得读锁, 而读已提交级别是要求先加读锁后读数据的, 因此 T1 中的查询就会被阻塞, 直至事务 T2 被提交或者回滚后才能得到结果.')]),t._v(" "),s("p",[t._v('理论上还存在更低的隔离级别, 就是"'),s("strong",[t._v("完全不隔离")]),t._v('", 即'),s("strong",[t._v("读, 写锁都不加")]),t._v(". 读未提交会有脏读问题, 但不会有脏写问题(Dirty Write), 即一个事务没提交之前的修改可以被另外一个事务的修改覆盖掉. 脏写已经不单纯是隔离性上的问题了, 它将导致事务的原子性都无法实现, 所以一般谈论隔离级别时不会将完全不隔离纳入讨论范围内, 而是将读未提交视为最低级的隔离级别.")]),t._v(" "),s("p",[t._v("以上四种隔离级别属于数据库理论的"),s("strong",[t._v("基础知识")]),t._v(", 多数大学的计算机课程应该都会讲到, 可惜的是不少教材, 资料将它们当作数据库的某种固有属性或设定来讲解, 导致很多同学只能对这些现象死记硬背. "),s("strong",[t._v("其实不同隔离级别以及幻读, 不可重复读, 脏读等问题都只是表面现象, 是各种锁在不同加锁时间上组合应用所产生的结果, 以锁为手段来实现隔离性才是数据库表现出不同隔离级别的根本原因. 不同的加锁策略是实现不同隔离级别的根本原因, 同时也是不同隔离级别存在不同问题的根本原因.")])]),t._v(" "),s("h6",{attrs:{id:"_3-mvcc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-mvcc"}},[t._v("#")]),t._v(" (3)MVCC")]),t._v(" "),s("p",[t._v("除了都以"),s("strong",[t._v("锁来实现")]),t._v("外, 以上四种隔离级别还有另外一个共同特点, 就是幻读, 不可重复读, 脏读等问题都是"),s("strong",[t._v("由于一个事务在")]),t._v("​"),s("mark",[s("strong",[t._v("读数据")])]),t._v("​"),s("strong",[t._v("的过程中, 受另外一个")]),t._v("​"),s("mark",[s("strong",[t._v("写数据")])]),t._v("​"),s("strong",[t._v("的事务影响而破坏了隔离性")]),t._v(".")]),t._v(" "),s("p",[t._v('针对这种 "一个事务读+另一个事务写" 的隔离问题, 近年来有一种名为"'),s("strong",[t._v("多版本并发控制")]),t._v('"(Multi-Version Concurrency Control, MVCC) 的'),s("mark",[s("strong",[t._v("无锁优化方案")])]),t._v("被主流的商业数据库广泛采用. MVCC 是一种"),s("strong",[t._v("读取优化策略")]),t._v(", 它的 "),s("strong",[t._v('"无锁"特指读取时不需要加锁')]),t._v(".")]),t._v(" "),s("p",[t._v("MVCC 的"),s("mark",[s("strong",[t._v("基本思路是对数据库的任何修改都不会直接覆盖之前的数据, 而是产生一个新版本与老版本共存, 以此达到读取时可以完全不加锁的目的")])]),t._v("​ "),s("strong",[t._v(".")]),t._v('  这里 "版本" 十分关键, 可以将版本理解为数据库中每一行记录都存在两个看不见的字段: CREATE_VERSION 和 DELETE_VERSION, 这两个字段记录的值都是'),s("strong",[t._v("事务 ID")]),t._v(", 事务ID 是一个全局严格递增的数值.")]),t._v(" "),s("p",[t._v("一个"),s("mark",[s("strong",[t._v("事务写入数据")])]),t._v("时, 需要根据以下规则"),s("strong",[t._v("写入数据")]),t._v(".")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("插入数据时")]),t._v(": CREATE_VERSION 记录插入数据的事务 ID, DELETE_VERSION 为空.")]),t._v(" "),s("li",[s("strong",[t._v("删除数据时")]),t._v(": DELETE_VERSION 记录删除数据的事务 ID, CREATE_VERSION 为空.")]),t._v(" "),s("li",[s("strong",[t._v("修改数据时")]),t._v(': 将修改数据视为 "删除旧数据, 插入新数据" 的组合, 即先将原有数据复制一份, 原有数据的 DELETE_VERSION 记录修改数据的事务 ID, CREATE_VERSION 为空. 复制后的新数据的 CREATE_VERSION 记录修改数据的事务 ID, DELETE_VERSION 为空.')])]),t._v(" "),s("p",[t._v("此时, 如有"),s("strong",[t._v("另外")]),t._v("​"),s("mark",[s("strong",[t._v("一个事务要读取")])]),t._v("​"),s("strong",[t._v("这些发生了变化的数据")]),t._v(", 将根据"),s("strong",[t._v("隔离级别")]),t._v("来决定到底应该读取哪个版本的数据.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("隔离级别是可重复读")]),t._v(": 总是"),s("strong",[t._v("读取 CREATE_VERSION 小于或等于当前事务 ID")]),t._v(" 的记录, 在这个前提下, 如果数据仍有多个版本, 则取"),s("strong",[t._v("最新")]),t._v("(事务 ID 最大)的. 这种情况下读到的就是自己的事务刚开始时候的数据版本, 即使中间有其他事务把数据修改了, 也不会影响当前事务读到的数据.")]),t._v(" "),s("li",[s("strong",[t._v("隔离级别是读已提交")]),t._v(": "),s("strong",[t._v("总是取最新的")]),t._v("版本即可, 即最近被提交的那个版本的数据记录. 由于读的是最新的版本数据, 所以当其他事务修改数据后, 当前事务就会读到被修改后的数据. 这与读已提交隔离级别的表现就是一致的.")])]),t._v(" "),s("p",[t._v("另外两个隔离级别都"),s("strong",[t._v("没有必要")]),t._v("用到 MVCC, 因为读未提交直接修改原始数据即可, 其他事务查看数据的时候立刻可以看到, 根本无须版本字段. 可串行化本来的语义就是要阻塞其他事务的读取操作, 而 MVCC 是做读取时的无锁优化的, 自然不会放到一起用.")]),t._v(" "),s("p",[t._v("MVCC 是只针对  "),s("strong",[t._v('"读+写"')]),t._v("  场景的优化, 如果是"),s("strong",[t._v("两个事务同时修改数据")]),t._v(', 即 "写+写" 的情况, 那就没有多少优化的空间了, 此时'),s("strong",[t._v("加锁")]),t._v('几乎是唯一可行的解决方案, 稍微有点讨论余地的是加锁策略是选"乐观加锁"(Optimistic Locking)还是选"悲观加锁"(Pessimistic Locking). 前面的加锁都属于悲观加锁策略, 即认为如果不先加锁再访问数据, 就肯定会出现问题. 相对地, 乐观加锁策略认为事务之间数据存在竞争是偶然情况, 没有竞争才是普遍情况, 这样就不应该在一开始就加锁, 而是应当在出现竞争时再找补救措施. 这种思路也被称为"乐观并发控制"(Optimistic Concurrency Control, OCC), 没有必要迷信什么乐观锁要比悲观锁更快的说法, 这纯粹看竞争的激烈程度, 如果竞争激烈的话, 乐观锁反而更慢.')]),t._v(" "),s("h4",{attrs:{id:"全局事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全局事务"}},[t._v("#")]),t._v(" 全局事务")]),t._v(" "),s("h5",{attrs:{id:"_1-基础-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础-3"}},[t._v("#")]),t._v(" 1.基础")]),t._v(" "),s("p",[t._v("与本地事务相对的是全局事务(Global Transaction), 在一些资料中也将其称为外部事务(External Transaction). 这里全局事务被限定为一种适用于"),s("strong",[t._v("单个服务使用多个数据源场景")]),t._v('的事务解决方案. 请注意, 理论上真正的全局事务并没有"单个服务"的约束, 它本来就是 '),s("strong",[t._v("DTP")]),t._v("(Distributed Transaction Processing, 分布式事务处理)模型中的概念, 但本节讨论的是一种"),s("strong",[t._v("在分布式环境中仍追求强一致性的事务处理方案")]),t._v(', 对于多节点而且互相调用彼此服务的场合(典型的就是现在的微服务系统)是极不合适的, 当前它几乎只实际应用于单服务多数据源的场合中, 为了避免与后续介绍的放弃了 ACID 的弱一致性事务处理方式混淆, 所以这里的全局事务的范围有所缩减, 后续涉及多服务多数据源的事务, 笔者将称其为"分布式事务".')]),t._v(" "),s("h5",{attrs:{id:"_2-xa接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-xa接口"}},[t._v("#")]),t._v(" 2.XA接口")]),t._v(" "),s("p",[t._v("1991 年, 为了解决"),s("strong",[t._v("分布式事务的一致性问题")]),t._v(", X/Open 组织提出了一套名为 X/Open "),s("strong",[t._v("XA")]),t._v("(XA 是eXtended Architecture的缩写)的处理事务架构, 其核心内容是定义了"),s("strong",[t._v("全局的事务管理器")]),t._v("(Transaction Manager, 用于协调全局事务)和"),s("strong",[t._v("局部的资源管理器")]),t._v("(Resource Manager, 用于驱动本地事务)之间的通信接口. "),s("strong",[t._v("XA 接口是双向")]),t._v("的, 能在"),s("strong",[t._v("一个事务管理器和多个资源管理器")]),t._v("(Resource Manager)之间形成通信桥梁, 通过协调"),s("strong",[t._v("多个数据源的一致动作, 实现全局事务的统一提交或者统一回滚")]),t._v(". 现在 Java 代码中还偶尔能看见的 XADataSource, XAResource 都源于此.")]),t._v(" "),s("p",[t._v("不过, XA 是一套语言无关的通用规范, 所以 Java 中专门定义了 JSR 907 Java Transaction API, 基于 "),s("strong",[t._v("XA 模式")]),t._v("在 Java 语言中实现了全局事务处理的标准, 这也是现在所熟知的 JTA. JTA 最主要的两个接口如下.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("事务管理器的接口")]),t._v(": javax.transaction."),s("strong",[t._v("TransactionManager")]),t._v(". 这套接口用于为 Java EE 服务器提供容器事务(由容器自动负责事务管理).")]),t._v(" "),s("li",[s("strong",[t._v("满足XA规范的资源定义接口")]),t._v(": javax.transaction.xa."),s("strong",[t._v("XAResource")]),t._v(". 任何资源(JDBC, JMS 等)如果想要支持 JTA, 只要实现 XAResource 接口中的方法即可.")])]),t._v(" "),s("p",[t._v("JTA 原本是 Java EE 中的技术, 一般情况下应该由 JBoss 等 Java EE 容器来提供支持, 但现在 Atomikos 和 JBossTM 都以 JAR 包的形式实现了 JTA 的接口, 称为 JOTM(Java Open Transaction Manager, Java 开源事务管理器), 使得在 Tomcat, Jetty 等 Java SE 环境下也可以使用 JTA.")]),t._v(" "),s("h5",{attrs:{id:"_3-2pc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2pc"}},[t._v("#")]),t._v(" 3.2PC")]),t._v(" "),s("p",[t._v("现在, 对本章的场景事例做另外一种假设: 如果书店的用户, 商家, 仓库分别处于"),s("strong",[t._v("不同的数据库")]),t._v("中, 其他条件仍与之前相同, 那情况会发生什么变化呢? 假如以声明式事务来编码, 那它与本地事务看起来可能没什么区别, 都是标一个 @Transactional 注解而已, 但如果以"),s("strong",[t._v("编程式事务")]),t._v("来实现的话, 就能在写法上看出差异, 伪代码如下所示:")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("buyBook")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PaymentBill")]),t._v(" bill"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    userTransaction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("begin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    warehouseTransaction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("begin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    businessTransaction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("begin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        userAccountService"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pay")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("bill"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getMoney")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        warehouseService"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("deliver")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("bill"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getItems")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        businessAccountService"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("receipt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("bill"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getMoney")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        userTransaction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("commit")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        warehouseTransaction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("commit")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        businessTransaction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("commit")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Exception")]),t._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        userTransaction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("rollback")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        warehouseTransaction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("rollback")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        businessTransaction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("rollback")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br")])]),s("p",[t._v("这里目的是做三次事务提交, 但实际上代码并不能这样写, 如果在 businessTransaction.commit() 中出现错误, 代码转到 catch 块中执行, 此时 userTransaction 和 warehouseTransaction 已经完成提交, 再去调用 rollback() 方法已经无济于事, 这将导致一部分数据被提交, 另一部分被回滚, 整个事务的"),s("strong",[t._v("一致性也就无法保证")]),t._v("了. 为了解决这个问题, XA 将事务提交拆分成"),s("strong",[t._v("两阶段")]),t._v(".")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("准备阶段")]),t._v(": 又叫作"),s("strong",[t._v("投票阶段")]),t._v(", 在这一阶段, "),s("strong",[t._v("协调者询问事务的所有参与者是否准备好提交")]),t._v(", 参与者如果已经准备好提交则回复 Prepared, 否则回复 Non-Prepared. 这里所说的准备操作跟人类语言中通常理解的准备不同, "),s("strong",[t._v("对于数据库来说, 准备操作是在重做日志(Redo Log)中记录全部事务提交操作所要做的内容, 它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已, 这意味着在做完数据持久化后并不立即释放隔离性, 即仍继续持有锁, 维持数据对其他非事务内观察者的隔离状态")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("提交阶段")]),t._v(": 又叫作"),s("strong",[t._v("执行阶段")]),t._v(", 协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息, 则先"),s("strong",[t._v("自己在本地持久化事务状态为 Commit")]),t._v(", 然后向所有参与者发送 Commit 指令, 让所有参与者"),s("strong",[t._v("立即执行提交操作")]),t._v("; 否则, 任意一个参与者回复了 Non-Prepared 消息, 或任意一个参与者超时未回复时, 协调者"),s("strong",[t._v("将在自己完成事务状态为 Abort 持久化")]),t._v("后, 向所有参与者发送 Abort 指令, 让参与者立即执行"),s("strong",[t._v("回滚")]),t._v("操作. 对于数据库来说, 这个阶段的提交操作应是"),s("strong",[t._v("很轻量")]),t._v("的, 仅仅是持久化一条 Commit Record 而已, 通常能够快速完成, 只有收到 Abort 指令时, 才需要根据"),s("strong",[t._v("回滚日志(Undo Log)")]),t._v(" 清理已提交的数据, 这可能是相对重负载操作.")])]),t._v(" "),s("p",[t._v('以上这两个过程被称为"'),s("strong",[t._v("两段式提交")]),t._v('"(2 Phase Commit, 2PC)协议, 而它能够成功保证一致性还需要一些其他'),s("strong",[t._v("前提条件")]),t._v(".")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("必须假设网络在提交阶段的短时间内是可靠的, 即提交阶段不会丢失消息")]),t._v(". 同时也假设网络通信在全过程都不会出现误差, 即可以丢失消息, 但不会传递错误的消息, XA 的设计目标并不是解决诸如拜占庭将军一类的问题. 在两段式提交中, 投票阶段失败了可以补救(回滚), 提交阶段失败了则无法补救(不再改变提交或回滚的结果, 只能等崩溃的节点重新恢复), 因而此阶段耗时应尽可能短, 这也是为了尽量控制网络风险.")]),t._v(" "),s("li",[s("strong",[t._v("必须假设因为网络分区, 机器崩溃或者其他原因而导致失联的节点最终能够恢复, 不会永久性地处于失联状态")]),t._v(". 由于在准备阶段已经写入了"),s("strong",[t._v("完整的重做日志")]),t._v(", 所以当失联机器一旦恢复, 就能够从日志中找出已准备妥当但并未提交的事务数据, 进而向协调者查询该事务的状态, 确定下一步应该进行提交还是回滚操作.")])]),t._v(" "),s("p",[t._v("请注意, 上面所说的协调者, 参与者通常都是由"),s("strong",[t._v("数据库自己")]),t._v("来扮演的, 不需要应用程序介入. 协调者一般是在"),s("strong",[t._v("参与者之间选举产生")]),t._v(", 而"),s("strong",[t._v("应用程序对于数据库来说只扮演客户端")]),t._v("的角色. 两段式提交的交互时序示意图如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221113163730650.png",alt:"",title:"2PC时序图"}})]),t._v(" "),s("p",[t._v("两段式提交原理简单, 并不难实现, 但有几个非常显著的"),s("strong",[t._v("缺点")]),t._v(".")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("单点问题")]),t._v(": 协调者在两段式提交中具有举足轻重的作用, 协调者等待参与者回复时可以有超时机制, 允许参与者宕机, 但参与者等待协调者指令时无法做超时处理. 一旦"),s("strong",[t._v("协调者宕机")]),t._v("的话, 所有参与者都会受到影响. 如果协调者一直没有恢复, 没有正常发送 Commit 或者 Rollback 的指令, 那所有参与者都必须一直等待.")]),t._v(" "),s("li",[s("strong",[t._v("性能问题")]),t._v(": 在两段式提交过程中, 所有参与者相当于被绑定为一个"),s("strong",[t._v("统一调度的整体")]),t._v(", 期间要经过两次远程服务调用, 三次数据持久化(准备阶段写重做日志, 协调者做状态持久化, 提交阶段在日志写入提交记录), 整个过程将持续到参与者集群中"),s("strong",[t._v("最慢的那一个处理操作")]),t._v("结束为止, 这决定了两段式提交的"),s("strong",[t._v("性能通常都较差")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("一致性风险")]),t._v(": 前面已经提到, 两段式提交的成立是有"),s("strong",[t._v("前提条件")]),t._v('的, 当网络稳定性和宕机恢复能力的假设不成立时, 仍可能出现一致性问题. 宕机恢复能力这一点不必多谈, "'),s("strong",[t._v("FLP不可能原理")]),t._v('"证明了如果宕机最后不能恢复, 那就不存在任何一种分布式协议可以正确地达成一致性结果. 该原理在分布式中是与 CAP 原理齐名的理论. 而网络稳定性带来的一致性风险是指: 尽管提交阶段时间很短, 但这仍是一段明确存在的危险期, 如果协调者在发出准备指令后, 根据收到各个参与者发回的信息确定事务状态是可以提交的, 协调者会先持久化事务状态, 并提交自己的事务, 如果这时候网络忽然断开, 无法再通过网络向所有参与者发出 Commit 指令的话, 就会导致部分数据(协调者的)已提交, 但部分数据(参与者的)未提交, 且没有办法回滚, 产生数据不一致的问题.')])]),t._v(" "),s("h5",{attrs:{id:"_4-3pc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-3pc"}},[t._v("#")]),t._v(" 4.3PC")]),t._v(" "),s("p",[t._v('为了缓解两段式提交协议的一部分缺陷, 具体地说是协调者的单点问题和准备阶段的性能问题, 后续又发展出了"'),s("strong",[t._v("三段式提交")]),t._v('"(3 Phase Commit, 3PC)协议.')]),t._v(" "),s("p",[t._v("三段式提交把原本的两段式提交的"),s("strong",[t._v("准备阶段再细分为两个阶段")]),t._v(", 分别称为 CanCommit, PreCommit, 把提交阶段改称为 DoCommit 阶段. 其中, 新增的 CanCommit 是一个"),s("strong",[t._v("询问")]),t._v("阶段, 即协调者让每个参与的数据库根据自身状态, 评估该事务是否有可能顺利完成. "),s("strong",[t._v("将准备阶段一分为二的理由是这个阶段是重负载的操作")]),t._v(", 一旦协调者发出开始准备的消息, 每个参与者都将马上开始写重做日志, 它们所涉及的数据资源即被锁住, 如果此时某一个参与者宣告无法完成提交, 相当于大家都做了一轮无用功. 所以, 增加一轮询问阶段, 如果都得到了正面的响应, 那事务能够成功提交的把握就比较大了, 这也意味着因某个参与者提交时发生崩溃而导致大家全部回滚的风险相对变小. 因此"),s("strong",[t._v("在事务需要回滚的场景中, 三段式提交的性能通常要比两段式提交好很多, 但在事务能够正常提交的场景中, 两者的性能都很差, 甚至三段式因为多了一次询问, 还要稍微更差一些")]),t._v(".")]),t._v(" "),s("p",[t._v("同样也是由于事务失败回滚概率变小, 在三段式提交中, 如果在 PreCommit 阶段之后发生了协调者宕机, 即参与者没有等到 DoCommit 的消息的话, 默认的操作策略将是提交事务而不是回滚事务或者持续等待, 这就相当于避免了协调者单点问题的风险. 三段式提交的操作时序如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221113164121004.png",alt:"",title:"3PC时序图"}})]),t._v(" "),s("p",[t._v("从以上过程可以看出, 三段式提交"),s("strong",[t._v("对单点问题和回滚时的性能问题有所改善, 但是对一致性风险问题并未有任何改进, 甚至是略有增加的")]),t._v(". 譬如, 进入 PreCommit 阶段之后, 协调者发出的指令不是 Ack 而是 Abort, 而此时因网络问题, 有部分参与者直至超时都未能收到协调者的 Abort 指令的话, 这些参与者将会错误地提交事务, 这就产生了不同参与者之间数据不一致的问题.")]),t._v(" "),s("h4",{attrs:{id:"共享事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#共享事务"}},[t._v("#")]),t._v(" 共享事务")]),t._v(" "),s("p",[t._v("与全局事务里讨论的单个服务使用多个数据源正好相反, 共享事务(Share Transaction)是"),s("strong",[t._v("指多个服务共用同一个数据源")]),t._v('. 这里有必要再强调一次"数据源"与"数据库"的区别: 数据源是指提供数据的逻辑设备, 不必与物理设备一一对应. 在部署应用集群时最常采用的模式是将'),s("strong",[t._v("同一套程序部署到多个中间件服务器上")]),t._v(", 构成多个副本实例来分担流量压力. 它们虽然连接了同一个数据库, 但每个节点配有自己的专属数据源, 通常是中间件以 JNDI 的形式开放给程序代码使用. 在这种情况下, 所有副本实例的数据访问都是完全独立的, 并没有任何交集, 每个节点使用的仍是最简单的本地事务.")]),t._v(" "),s("p",[t._v("本节讨论的是"),s("strong",[t._v("多个服务之间会产生业务交集")]),t._v("的场景, 举个具体例子, 在书店的场景示例中, 假设用户账户, 商家账户和商品仓库都"),s("strong",[t._v("存储于同一个数据库")]),t._v("之中, 但用户, 商家和仓库都部署了独立的微服务, 此时一次购书的业务操作将贯穿三个微服务, 且它们都要在数据库中修改数据. 如果直接将不同数据源视为不同数据库, 那上一节所讲的全局事务和下一节要讲的分布式事务都是可行的, 不过, 针对这种"),s("strong",[t._v("每个数据源连接的都是同一个物理数据库")]),t._v("的特例, 共享事务很有可能成为另一条提高性能, 降低复杂度的途径, 当然, 也很有可能是一个伪需求.")]),t._v(" "),s("p",[t._v("一种理论可行的方案是直接让各个服务"),s("strong",[t._v("共享数据库连接")]),t._v(', 在同一个应用进程中的不同持久化工具(JDBC, ORM, JMS 等)中共享数据库连接并不困难, 某些中间件服务器, 譬如 WebSphere 会内置"可共享连接"功能来专门给予这方面的支持. 但这种共享的前提是数据源的使用者都在同一个进程内, 由于数据库连接的基础是网络连接, 它是与 IP 地址和端口号绑定的, 字面意义上的"不同服务节点共享数据库连接"很难做到, 所以为了实现共享事务, 就必须新增一个 "'),s("strong",[t._v("交易服务器")]),t._v('" 的中间角色, 无论是用户服务, 商家服务还是仓库服务, 都通过同一台交易服务器来与数据库打交道. 如果按照 JDBC 规范来实现交易服务器的对外接口的话, 那它完全可以'),s("strong",[t._v("作为一个独立于各个服务的远程数据库连接池")]),t._v(", 或者直接作为"),s("strong",[t._v("数据库代理")]),t._v("来看待. 此时三个服务所发出的交易请求就有可能做到由交易服务器上的同一个数据库连接, 通过"),s("strong",[t._v("本地事务")]),t._v("的方式完成. 譬如, 交易服务器根据不同服务节点传来的同一个事务 ID, 使用同一个数据库连接来处理跨越多个服务的交易事务, 如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221113164557390.png",alt:""}})]),t._v(" "),s("p",[t._v('之所以强调理论可行, 是因为该方案是与实际生产系统中的压力方向相悖的, 一个服务集群里数据库才是压力最大而又最不容易伸缩拓展的"重灾区", 所以现实中只有类似 ProxySQL, MaxScale 这样用于对多个数据库实例做负载均衡的数据库代理(其实用 ProxySQL 代理单个数据库, 再启用Connection Multiplexing, 已经接近于前面所提及的交易服务器方案了), 而几乎没有反过来代理一个数据库为多个应用提供事务协调的交易服务代理. 这也是说它更有可能是个伪需求的原因, 如果你有充足理由让多个微服务去共享数据库, 就必须找到更加站得住脚的理由来向团队解释拆分微服务的目的是什么才行.')]),t._v(" "),s("p",[t._v("在日常开发中, 上述方案还存在一类更为常见的变种形式: 使用"),s("strong",[t._v("消息队列服务器")]),t._v("来代替交易服务器, 当用户, 商家, 仓库的服务操作业务时, 通过"),s("strong",[t._v("消息将所有对数据库的改动传送到消息队列服务器")]),t._v(', 通过消息的消费者来统一完成由本地事务来保障的持久化操作. 这被称作"'),s("strong",[t._v("单个数据库的消息驱动更新")]),t._v('"(Message-Driven Update of a Single Database).')]),t._v(" "),s("p",[t._v('"共享事务"的提法和这里所列的两种处理方式'),s("strong",[t._v("在实际应用中并不值得提倡")]),t._v(", 鲜有采用这种方式的成功案例. 这里把共享事务列为四种事务类型之一只是为了叙述逻辑的完备, 尽管拆分微服务后仍然共享数据库的情况在现实中并不少见, 但将共享事务作为一种常规的解决方案来考量"),s("strong",[t._v("并不合适")]),t._v(".")]),t._v(" "),s("h4",{attrs:{id:"分布式事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务"}},[t._v("#")]),t._v(" 分布式事务")]),t._v(" "),s("h5",{attrs:{id:"_1-基础-4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础-4"}},[t._v("#")]),t._v(" 1.基础")]),t._v(" "),s("p",[t._v("本节所说的分布式事务(Distributed Transaction)特指"),s("strong",[t._v("多个服务同时访问多个数据源的事务处理机制")]),t._v(', 请注意它与 DTP 模型中"分布式事务"的差异. DTP 模型中的"分布式"是相对于数据源而言的, 并不涉及服务. 本节所指的 '),s("strong",[t._v('"分布式"是相对于服务而言')]),t._v('的, 它更应该被称为"在分布式服务环境下的事务处理机制".')]),t._v(" "),s("p",[s("strong",[t._v("分布式事务")]),t._v("是指事务的参与者, 支持事务的服务器, 资源服务器以及事务管理器分别位于分布式系统的"),s("strong",[t._v("不同节点")]),t._v("上.")]),t._v(" "),s("h5",{attrs:{id:"_2-cap定理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-cap定理"}},[t._v("#")]),t._v(" 2.CAP定理")]),t._v(" "),s("p",[t._v("在 2000 年以前, 人们曾经希望 XA 的事务机制在分布式环境中也能良好应用, 但这个美好的愿望今天已经被 CAP 理论彻底击碎了, 接下来就先从 CAP 与 ACID 的矛盾说起.")]),t._v(" "),s("p",[t._v("CAP 定理(Consistency, Availability, Partition Tolerance Theorem), 是可以被数学推理证明的分布式计算领域所公认的著名定理. 它描述了在一个分布式系统中, 涉及"),s("strong",[t._v("共享数据问题")]),t._v("时, 以下三个特性不可能同时满足"),s("strong",[t._v("一致性")]),t._v("(C: Consistency), "),s("strong",[t._v("可用性")]),t._v("(A: Availability)和"),s("strong",[t._v("分区容忍性")]),t._v("(P: Partition Tolerance), 最多只能同时满足"),s("strong",[t._v("其中两项")]),t._v(".")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220102231018131.png",alt:"",title:"CAP关系"}})]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("一致性")]),t._v("(Consistency): 代表数据在"),s("strong",[t._v("任何时刻, 任何分布式节点中所看到的都是符合预期")]),t._v("的. 指的是"),s("strong",[t._v("多个数据副本")]),t._v("是否能"),s("strong",[t._v("保持一致")]),t._v("的特性, 在一致性的条件下, 系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态. 对系统的一个数据"),s("strong",[t._v("更新成功")]),t._v("之后, 如果所有用户都能够"),s("strong",[t._v("读取到最新的值")]),t._v(", 该系统就被认为具有"),s("strong",[t._v("强一致性")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("可用性")]),t._v("(Availability): "),s("strong",[t._v("代表系统不间断地提供服务的能力")]),t._v(". 理解可用性要先理解与其密切相关的两个指标: "),s("strong",[t._v("可靠性")]),t._v("(Reliability)"),s("strong",[t._v("和可维护性")]),t._v("(Serviceability). 可靠性使用平均无故障时间(Mean Time Between Failure, MTBF)来度量; 可维护性使用平均可修复时间(Mean Time To Repair, MTTR)来度量. 可用性衡量系统可以正常使用的时间与总时间之比, 其表征为: A=MTBF/(MTBF+MTTR), 即可用性是由可靠性和可维护性计算得出的比例值, 譬如 99.9999% 可用, 即代表平均年故障修复时间为 32 秒.")]),t._v(" "),s("li",[s("strong",[t._v("分区容忍性")]),t._v("(Partition Tolerance): "),s("strong",[t._v("网络分区")]),t._v("指分布式系统中的节点被"),s("strong",[t._v("划分为多个区域")]),t._v(", 每个区域"),s("strong",[t._v("内部可以通信")]),t._v(", 但是"),s("strong",[t._v("区域之间无法通信")]),t._v(". 分区容忍性指分布式系统在"),s("strong",[t._v("遇到任何网络分区故障(脑裂)")]),t._v(" 的时候, "),s("strong",[t._v("仍然需要能对外提供一致性和可用性的服务")]),t._v(", 除非是整个网络环境都发生了故障.")])]),t._v(" "),s("p",[t._v("单纯只列概念, CAP 是比较抽象的, 这里仍以书店的例子来说明这三种特性对分布式系统的意义. 假设书店的服务拓扑如图所示, 一个来自最终用户的交易请求, 将交由账号, 商家和仓库服务集群中的某一个节点来完成响应.")]),t._v(" "),s("p",[t._v("​"),s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221113165739787.png",alt:"image-20221113165739787"}}),t._v("​")]),t._v(" "),s("p",[t._v("在这套系统中, 每一个单独的"),s("strong",[t._v("服务节点都有自己的数据库")]),t._v(", 假设某次交易请求分别由  "),s("strong",[t._v('"账号节点1", "商家节点2", "仓库节点N"')]),t._v("  联合进行响应. 当用户购买一件价值 100 元的商品后, 账号节点 1 首先应给该用户账号扣减 100 元货款, 它在自己数据库扣减 100 元很容易, 但它还要把这次交易变动"),s("strong",[t._v("告知本集群")]),t._v("的节点 2 到节点 N, 并要确保能"),s("strong",[t._v("正确变更")]),t._v("商家和仓库集群其他账号节点中的关联数据, 此时将可能面临以下情况.")]),t._v(" "),s("ul",[s("li",[t._v("如果该变动信息没有及时同步给其他账号节点, 将有可能导致用户购买另一商品时, 被分配给另一个节点处理, 由于看到账号上有不正确的余额而错误地发生了原本无法进行的交易, 此为"),s("strong",[t._v("一致性")]),t._v("问题.")]),t._v(" "),s("li",[t._v("如果由于要把该变动信息同步给其他账号节点, 必须暂时停止对该用户的交易服务, 直至数据同步一致后再重新恢复, 将可能导致用户在下一次购买商品时, 因系统暂时无法提供服务而被拒绝交易, 此为"),s("strong",[t._v("可用性")]),t._v("问题.")]),t._v(" "),s("li",[t._v("如果由于账号服务集群中某一部分节点因网络问题, 无法正常与另一部分节点交换账号变动信息, 此时服务集群中无论哪一部分节点对外提供的服务都可能是不正确的. 整个集群不能承受由于部分节点之间的连接中断而不断继续正确地提供服务, 此为"),s("strong",[t._v("分区容忍性")]),t._v("问题.")])]),t._v(" "),s("p",[t._v("以上仅仅分析了用户服务集群自身的 CAP 问题, 对于整个书店站点来说, 它更是面临着来自于用户, 商家和仓库服务集群带来的 CAP 问题. 譬如, 用户账号扣款后, 由于未及时通知仓库服务中的全部节点, 导致另一次交易中看到仓库里有不正确的库存数据而发生超售. 又譬如因涉及仓库中某个商品的交易正在进行, 为了同步用户, 商家和仓库的交易变动, 而暂时锁定该商品的交易服务, 导致可用性问题, 等等.")]),t._v(" "),s("p",[t._v("由于 CAP 定理已有严格的证明, 本节不去探讨为何 CAP 不可兼得, 而是直接分析舍弃 C, A, P 时所带来的不同影响.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("如果放弃分区容忍性")]),t._v("(CA without P). 意味着将假设节点之间的"),s("strong",[t._v("通信永远是可靠")]),t._v("的. "),s("strong",[t._v("永远可靠的通信在分布式系统中必定是不成立的")]),t._v(", 因为只要用到网络来共享数据, 分区现象就始终存在. 在现实中, 最容易找到放弃分区容忍性的例子便是传统的关系数据库集群, 这样的集群虽然依然采用由网络连接的多个节点来协同工作, 但数据却不是通过网络来实现共享的. 因此 P 是"),s("strong",[t._v("无法放弃")]),t._v("的.")]),t._v(" "),s("li",[s("strong",[t._v("如果放弃可用性")]),t._v("(CP without A). 意味着将假设一旦网络发生分区, 节点之间的信息"),s("strong",[t._v("同步时间可以无限制地延长")]),t._v(", 此时, 问题相当于退化到前面的"),s("strong",[t._v("一个系统使用多个数据源")]),t._v("的场景之中, 此时可以通过 2PC/3PC 等手段, 同时获得分区容忍性和一致性. 在现实中, 选择放弃可用性的情况一般出现在对"),s("strong",[t._v("数据质量要求很高")]),t._v("的场合中, HBase 就属于 CP 系统, 假如某个 RegionServer 宕机了, 这个 RegionServer 持有的所有键值范围"),s("strong",[t._v("都将离线")]),t._v(", 直到数据恢复过程完成为止, 这个过程要消耗的时间是无法预先估计的.")]),t._v(" "),s("li",[s("strong",[t._v("如果放弃一致性")]),t._v("(AP without C). 意味着将假设一旦网络发生分区, 节点之间所提供的数据可能"),s("strong",[t._v("不一致")]),t._v(". 选择放弃一致性的 AP 系统是目前设计分布式系统的主流选择, 因为 P 是分布式网络的天然属性, 再不想要也无法丢弃; 而 A 通常是建设分布式的目的, 如果可用性随着节点数量增加反而降低的话, 很多分布式系统可能就失去了存在的价值, 除非银行, 证券这些涉及金钱交易的服务, 宁可中断也不能出错, 否则多数系统是不能容忍节点越多可用性反而越低的. 目前大多数 NoSQL 库和支持分布式的缓存框架都是 AP 系统, 以 Redis 集群为例, 如果某个 Redis 节点出现网络分区, 那仍不妨碍各个节点以自己本地存储的数据对外提供缓存服务, 但这时有可能出现请求分配到不同节点时返回客户端的是不一致的数据的情况.")])]),t._v(" "),s("p",[t._v("对于分布式系统而言, "),s("mark",[t._v("分区容错性是一个基本的需求")]),t._v(", 因为放弃分区容错性 P 就意味着"),s("strong",[t._v("放弃了系统的可拓展性.")]),t._v("  因为对于分布式系统, 网络问题是一个"),s("strong",[t._v("无法避免")]),t._v("的异常情况, 因此分区容错就是分布式系统必然要面对与解决的问题. 当发生网络分区的时候, 如果要继续服务, 那么强一致性和可用性只能二选一. 因此通常需要根据业务特点在 "),s("strong",[t._v("C(一致性) 和 A(可用性)")]),t._v("  之间寻求平衡.")]),t._v(" "),s("p",[t._v("在多个节点之间进行数据同步时:")]),t._v(" "),s("ul",[s("li",[t._v("为了保证一致性("),s("strong",[t._v("CP")]),t._v("), "),s("strong",[t._v("不能访问未同步完成的节点")]),t._v(", 也就失去了部分可用性.")]),t._v(" "),s("li",[t._v("为了保证可用性("),s("strong",[t._v("AP")]),t._v("), "),s("strong",[t._v("允许读取所有节点的数据")]),t._v(", 但是数据可能不一致.")])]),t._v(" "),s("p",[t._v('读到这里, 不知道你是否对"'),s("strong",[t._v("选择放弃一致性的 AP 系统是目前设计分布式系统的主流选择")]),t._v('" 这个结论感到一丝无奈, 本章讨论的话题  '),s("strong",[t._v('"事务" 原本的目的就是获得"一致性", 而在分布式环境中, "一致性" 却不得不成为通常被牺牲, 被放弃的那一项属性')]),t._v(". 但无论如何, 建设信息系统, 终究还是要确保操作结果至少在最终交付的时候是正确的, 这句话的意思是"),s("strong",[t._v("允许数据在中间过程出错(不一致), 但应该在输出时被修正过来")]),t._v('. 为此, 人们又重新给一致性下了定义, 将前面在 CAP, ACID 中讨论的一致性称为"'),s("strong",[t._v("强一致性")]),t._v('"(Strong Consistency), 有时也称为"'),s("strong",[t._v("线性一致性")]),t._v('"(Linearizability, 通常是在讨论共识算法的场景中), 而把牺牲了 C 的 AP 系统又要尽可能获得正确结果的行为称为追求"'),s("strong",[t._v("弱一致性")]),t._v('". 不过, 如果单纯只说"弱一致性"那其实就是"不保证一致性"的意思. 在弱一致性里, 人们又总结出了一种稍微强一点的特例, 被称为"'),s("strong",[t._v("最终一致性")]),t._v('"(Eventual Consistency), 它是'),s("strong",[t._v('指如果数据在一段时间之内没有被另外的操作更改, 那它最终会达到与强一致性过程相同的结果, 有时候面向最终一致性的算法也被称为"乐观复制算法"')]),t._v(" .")]),t._v(" "),s("p",[t._v('在本节讨论的"分布式事务"中, 目标同样也不得不从之前三种事务模式追求的强一致性, '),s("strong",[t._v('降低为追求获得"最终一致性"')]),t._v(' . 由于一致性的定义变动, "事务"一词的含义其实也同样被拓展了, 人们把使用 ACID 的事务称为"'),s("strong",[t._v("刚性事务")]),t._v('", 而把下面将要介绍的几种分布式事务的常见做法统称为"'),s("strong",[t._v("柔性事务")]),t._v('".')]),t._v(" "),s("h5",{attrs:{id:"_3-base"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-base"}},[t._v("#")]),t._v(" 3.BASE")]),t._v(" "),s("p",[s("strong",[t._v("最终一致性")]),t._v('的概念是由 Dan Pritchett 的论文 "Base:An Acid Alternative" 中提出的, 该论文总结了一种独立于 ACID 获得的强一致性之外的, 使用 BASE 来达成一致性目的的途径.')]),t._v(" "),s("p",[t._v("BASE 分别是"),s("strong",[t._v("基本可用性")]),t._v("(Basically Available), "),s("strong",[t._v("柔性事务")]),t._v("(Soft State)和"),s("strong",[t._v("最终一致性")]),t._v("(Eventually Consistent)的缩写. 这篇论文本身作为最终一致性的概念起源, 并系统性地总结了"),s("strong",[t._v("一种针对分布式事务的技术手段")]),t._v(", 是非常有价值的.")]),t._v(" "),s("p",[t._v("BASE 理论是对 CAP 中"),s("strong",[t._v("一致性和可用性权衡")]),t._v("的结果, 它的核心思想是: "),s("strong",[t._v("即使无法做到强一致性, 但每个应用都可以根据自身业务特点, 采用适当的方式来使系统达到最终一致性")]),t._v(".")]),t._v(" "),s("p",[t._v("也就是牺牲数据的"),s("strong",[t._v("一致性")]),t._v("来满足系统的"),s("strong",[t._v("高可用性")]),t._v(", 系统中一部分数据不可用或者不一致时, 仍需要保持系统整体基本可用.")]),t._v(" "),s("h6",{attrs:{id:"_1-基本可用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本可用"}},[t._v("#")]),t._v(" 1.基本可用")]),t._v(" "),s("p",[t._v("基本可用(Basically Available) 指分布式系统在出现故障的时候, 保证"),s("strong",[t._v("核心可用")]),t._v(", 允许"),s("strong",[t._v("损失部分可用性")]),t._v(". 基本可用的例子:")]),t._v(" "),s("ul",[s("li",[t._v("响应时间上的损失. 响应时间变长.")]),t._v(" "),s("li",[t._v("功能上的损失. 如服务降级.")])]),t._v(" "),s("p",[t._v("例如电商在做促销时, 为了保证"),s("strong",[t._v("购物系统的稳定性")]),t._v(", 部分消费者可能会被引导到一个"),s("strong",[t._v("降级的页面")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_2-软状态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-软状态"}},[t._v("#")]),t._v(" 2.软状态")]),t._v(" "),s("p",[s("strong",[t._v("软状态")]),t._v("(Soft State) 指允许系统中的数据存在"),s("strong",[t._v("中间状态")]),t._v(", 并认为该中间状态"),s("strong",[t._v("不会影响系统整体可用性")]),t._v(", 即允许系统不同节点的"),s("strong",[t._v("数据副本之间进行同步的过程存在一定时延")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_3-最终一致性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-最终一致性"}},[t._v("#")]),t._v(" 3.最终一致性")]),t._v(" "),s("p",[s("strong",[t._v("最终一致性")]),t._v("(Eventually Consistent) 强调的是系统中所有的数据副本, 在经过一段时间的同步后, "),s("strong",[t._v("最终能达到一致的状态")]),t._v(". 其本质是需要系统保证最终数据能够达到一致, 而不需要实时保证系统数据的强一致性.")]),t._v(" "),s("p",[s("strong",[t._v("ACID")]),t._v(" 要求"),s("strong",[t._v("强一致性")]),t._v(", 通常运用在"),s("strong",[t._v("传统的数据库系统")]),t._v("上. 而 "),s("strong",[t._v("BASE")]),t._v(" 要求最终一致性, 通过牺牲强一致性来达到可用性, 通常运用在"),s("strong",[t._v("大型分布式系统")]),t._v("中.")]),t._v(" "),s("p",[t._v("工程实践中, 最终一致性存在以下五类主要变种.")]),t._v(" "),s("ul",[s("li",[t._v("因果一致性.")]),t._v(" "),s("li",[t._v("读已之所写.")]),t._v(" "),s("li",[t._v("会话一致性.")]),t._v(" "),s("li",[t._v("单调读一致性.")]),t._v(" "),s("li",[t._v("单调写一致性.")])]),t._v(" "),s("h6",{attrs:{id:"_4-应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-应用"}},[t._v("#")]),t._v(" 4.应用")]),t._v(" "),s("p",[t._v("总的来说, BASE 理论面向的是大型高可用高拓展的分布式系统, 它完全不同于传统事务 ACID 的强一致性模型, 而是提出通过牺牲强一致性来获得可用性, 并允许数据在一段时间内是不一致的, 但最终达到一致性状态.")]),t._v(" "),s("p",[t._v("在实际的分布式场景中, 不同业务单元和组件对一致性的要求是不同的, 因此 ACID 和 BASE 往往会"),s("strong",[t._v("结合在一起使用")]),t._v(".")]),t._v(" "),s("p",[t._v("针对"),s("strong",[t._v("数据库")]),t._v("领域, BASE 思想的主要实现是对"),s("strong",[t._v("业务数据进行拆分")]),t._v(", 让不同的数据分布在不同的机器上, 以提升系统的可用性, 当前主要有以下两种做法:")]),t._v(" "),s("ul",[s("li",[t._v("按"),s("strong",[t._v("功能划分")]),t._v("数据库.")]),t._v(" "),s("li",[s("strong",[t._v("分片")]),t._v("(如开源的 Mycat, Amoeba 等).")])]),t._v(" "),s("p",[t._v("由于拆分后会涉及"),s("strong",[t._v("分布式事务")]),t._v("问题, 所以 eBay 在该 BASE 论文中提到了如何用最终一致性的思路来实现高性能的分布式事务.")]),t._v(" "),s("h5",{attrs:{id:"_4-可靠事件队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-可靠事件队列"}},[t._v("#")]),t._v(" 4.可靠事件队列")]),t._v(" "),s("p",[t._v("Dan Pritchett 的论文不仅提出了 BASE 理论, 还提出了"),s("strong",[t._v("可靠事件队列")]),t._v('的分布式事务解决方案. 继续以书店的场景事例来解释 Dan Pritchett 提出的"'),s("strong",[t._v("可靠事件队列")]),t._v('"的具体做法, 目标仍然是交易过程中正确修改账号, 仓库和商家服务中的数据, 下图列出了修改过程的时序图.')]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221113182436338.png",alt:"",title:"可靠事件队列示例时序图"}})]),t._v(" "),s("p",[t._v("(1)最终用户向书店发送交易请求: 购买一本价值 100 元的《深入理解Java虚拟机》.")]),t._v(" "),s("p",[t._v("(2)书店首先应对用户账号扣款, 商家账号收款, 库存商品出库这三个操作有一个"),s("strong",[t._v("出错概率的先验评估")]),t._v(", 根据"),s("strong",[t._v("出错概率的大小")]),t._v("来安排它们的操作顺序, 这种"),s("strong",[t._v("评估一般直接体现在程序代码中")]),t._v(", 一些大型系统也可能会实现动态排序. 譬如, 根据统计, 最有可能出现的交易异常是用户购买了商品, 但是不同意扣款, 或者账号余额不足; 其次是仓库发现商品库存不够, 无法发货; 风险最低的是收款, 如果到了商家收款环节, 一般就不会出什么意外了. 那最容易出错的就应该最先进行, 即: 账号扣款 -> 仓库出库 -> 商家收款.")]),t._v(" "),s("p",[t._v("(3)账号服务进行扣款业务, 如扣款成功, 则在"),s("strong",[t._v("自己的数据库建立一张消息表")]),t._v(', 里面存入一条消息: "事务 ID: 某 UUID, 扣款: 100元(状态: 已完成), 仓库出库《深入理解Java虚拟机》: 1本(状态: 进行中), 某商家收款: 100元(状态: 进行中)". 注意, 这个步骤中"扣款业务"和"写入消息"是使用'),s("strong",[t._v("同一个本地事务写入账号服务自己的数据库")]),t._v("的.")]),t._v(" "),s("p",[t._v("(4)在系统中建立一个"),s("strong",[t._v("消息服务")]),t._v(", "),s("strong",[t._v("定时轮询消息表")]),t._v(', 将状态是"进行中"的消息同时发送到库存和商家服务节点中去(也可以串行地发, 即一个成功后再发送另一个, 但这里的场景中没必要). 这时候可能产生以下几种情况.')]),t._v(" "),s("ul",[s("li",[t._v("商家和仓库服务"),s("strong",[t._v("都成功完成")]),t._v('了收款和出库工作, 向用户账号服务器返回执行结果, 用户账号服务把消息表中的消息状态从 "进行中" 更新为 "已完成". 整个事务顺利结束, 达到最终一致性的状态.')]),t._v(" "),s("li",[t._v("商家或仓库服务中"),s("strong",[t._v("至少有一个因网络原因")]),t._v(", 未能收到来自用户账号服务的消息. 此时, 由于用户账号服务器中存储的消息状态"),s("strong",[t._v('一直处于 "进行中"')]),t._v(" , 所以消息服务器将在每次轮询的时候持续地向未响应的服务"),s("strong",[t._v("重复发送消息")]),t._v(". 这个步骤的可重复性决定了所有被消息服务器发送的消息都必须具备"),s("strong",[t._v("幂等性")]),t._v(", 通常的设计是让消息带上一个唯一的事务 ID, 以保证一个事务中的出库, 收款动作会且只会被处理一次.")]),t._v(" "),s("li",[t._v("商家或仓库服务有"),s("strong",[t._v("某个或全部无法完成工作")]),t._v(", 譬如仓库发现《深入理解Java虚拟机》没有库存了, 此时, 仍然是持续自动重发消息, 直至操作成功(譬如补充了新库存), 或者被人工介入为止. 由此可见, 可靠事件队列"),s("strong",[t._v("只要第一步业务完成了, 后续就没有失败回滚的概念, 只许成功, 不许失败")]),t._v(".")]),t._v(" "),s("li",[t._v("商家和仓库服务成功完成了收款和出库工作, 但"),s("strong",[t._v("回复的应答消息因网络原因丢失")]),t._v(", 此时, 用户账号服务仍会重新发出下一条消息, 但因操作具备"),s("strong",[t._v("幂等性")]),t._v(", 所以不会导致重复出库和收款, 只会导致商家, 仓库服务器重新发送一条应答消息, 此过程持续自动重复直至双方网络通信恢复正常.")])]),t._v(" "),s("p",[t._v("有一些支持分布式事务的消息框架, 如 RocketMQ, 原生就支持分布式事务操作, 这时候上述第二, 四种情况也可以交由消息框架来保障.")]),t._v(" "),s("p",[t._v("以上这种依靠"),s("mark",[s("strong",[t._v("持续重试")])]),t._v('来保证可靠性的解决方案谈不上是 Dan Pritchett 的首创或独创, 它在计算机的其他领域中已被频繁使用, 也有了专门的名字---"'),s("strong",[t._v("最大努力交付")]),t._v('"(Best-Effort Delivery), 譬如 TCP 协议中未收到 ACK 应答自动重新发包的可靠性保障就属于最大努力交付. 而可靠事件队列还有一种更普通的形式, 被称为"'),s("strong",[t._v("最大努力一次提交")]),t._v('"(Best-Effort 1PC), 指的是'),s("strong",[t._v("将最有可能出错的业务以本地事务的方式完成后, 采用不断重试的方式(不限于消息系统)来促使同一个分布式事务中的其他关联业务全部完成")]),t._v(".")]),t._v(" "),s("h5",{attrs:{id:"_4-tcc事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-tcc事务"}},[t._v("#")]),t._v(" 4.TCC事务")]),t._v(" "),s("p",[t._v('TCC 是另一种常见的分布式事务机制, 它是 "Try-Confirm-Cancel" 三个单词的缩写, 由数据库专家 Pat Helland 的论文 "Life beyond Distributed Transactions: An Apostate’s Opinion" 中提出.')]),t._v(" "),s("p",[t._v("可靠消息队列虽然能保证"),s("strong",[t._v("最终结果")]),t._v("的相对可靠性, 过程也足够简单(相对于 TCC 来说), 但整个过程"),s("strong",[t._v("完全没有任何隔离性")]),t._v('可言, 虽然在一些业务中隔离性是无关紧要的, 但在有些业务中缺乏隔离性就会带来许多麻烦. 譬如书店的场景中, 缺乏隔离性会带来的一个明显问题便是"'),s("strong",[t._v("超售")]),t._v('": 如两个客户在短时间内都成功购买了同一件商品, 而且他们各自购买的数量都不超过目前的库存, 但他们购买的数量'),s("strong",[t._v("之和")]),t._v('却超过了库存. 如果这件事情属于刚性事务, 且隔离级别足够时是可以完全避免的, 譬如, 以上场景就需要"可重复读"(Repeatable Read)的隔离级别, 以保证后面提交的事务会因为无法获得锁而导致失败, 但用可靠消息队列就无法保证这一点.')]),t._v(" "),s("p",[t._v("如果"),s("strong",[t._v("业务需要隔离, 那通常就应该重点考虑 TCC 方案, 该方案天生适用于需要强隔离性的分布式事务中")]),t._v(".")]),t._v(" "),s("p",[t._v("在具体实现上, TCC 较为烦琐, 它是一种"),s("strong",[t._v("业务侵入式较强")]),t._v('的事务方案, 要求业务处理过程必须拆分为 "'),s("strong",[t._v("预留业务资源")]),t._v('" 和 "'),s("strong",[t._v("确认/释放消费资源")]),t._v('" 两个子过程. 如同 TCC 的名字所示, 它分为以下三个阶段.')]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("Try-尝试执行阶段")]),t._v(", 完成所有业务可执行性的检查(保障一致性), 并且"),s("strong",[t._v("预留好全部需要用到的业务资源")]),t._v("(保障隔离性).")]),t._v(" "),s("li",[s("strong",[t._v("Confirm-确认执行阶段")]),t._v(", 不进行任何业务检查, 直接使用 Try 阶段准备的资源来完成业务处理. Confirm 阶段可能会重复执行, 因此本阶段执行的操作需要具备"),s("strong",[t._v("幂等性")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("Cancel-取消执行阶段")]),t._v(", 释放 Try 阶段预留的业务资源. Cancel 阶段可能会重复执行, 因此本阶段执行的操作也需要具备幂等性.")])]),t._v(" "),s("p",[t._v("按照书店的场景, TCC 的执行过程如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221113184347607.png",alt:"",title:"TCC执行时序图"}})]),t._v(" "),s("p",[t._v("(1)最终用户向书店发送交易请求: 购买一本价值 100 元的《深入理解Java虚拟机》.")]),t._v(" "),s("p",[t._v("(2)创建事务, 生成事务 ID, 记录在"),s("strong",[t._v("活动日志")]),t._v("中, 进入 Try 阶段, 进行"),s("strong",[t._v("业务检查和资源准备")]),t._v(".")]),t._v(" "),s("ul",[s("li",[t._v('用户服务: 检查业务可行性, 若可行, 将该用户的 100 元设置为"'),s("strong",[t._v("冻结")]),t._v('"状态, 通知下一步进入 Confirm 阶段; 若不可行, 通知下一步进入 Cancel 阶段.')]),t._v(" "),s("li",[t._v('仓库服务: 检查业务可行性, 若可行, 将该仓库的 1 本《深入理解Java虚拟机》设置为"'),s("strong",[t._v("冻结")]),t._v('"状态, 通知下一步进入 Confirm 阶段; 若不可行, 通知下一步进入 Cancel 阶段.')]),t._v(" "),s("li",[t._v("商家服务: 仅检查业务可行性, 不需要冻结资源.")])]),t._v(" "),s("p",[t._v("(3)如果第 2 步所有业务均反馈业务可行, 将"),s("strong",[t._v("活动日志中的状态记录为 Confirm")]),t._v(", 进入 Confirm 阶段, 完成业务操作.")]),t._v(" "),s("ul",[s("li",[t._v("用户服务: 完成业务操作(扣减那被冻结的 100元).")]),t._v(" "),s("li",[t._v("仓库服务: 完成业务操作(标记那 1 本冻结的书为出库状态, 扣减相应库存).")]),t._v(" "),s("li",[t._v("商家服务: 完成业务操作(收款 100 元).")])]),t._v(" "),s("p",[t._v("(4)第 3 步如果全部完成, 事务正常结束, 如果第 3 步中任何一方出现异常, 不论是业务异常还是网络异常, 都将根据活动日志中的记录, "),s("strong",[t._v("重复执行该服务的 Confirm 操作, 即进行最大努力交付")]),t._v(". 其实这时候成功的概率很大, 所以采用尽最大努力交付的策略.")]),t._v(" "),s("p",[t._v("(5)如果第 2 步有任意一方反馈业务不可行, 或任意一方超时, 则将活动日志的状态记录为 Cancel, 进入 Cancel 阶段.")]),t._v(" "),s("ul",[s("li",[t._v("用户服务: 取消业务操作(释放被冻结的 100 元).")]),t._v(" "),s("li",[t._v("仓库服务: 取消业务操作(释放被冻结的 1 本书).")]),t._v(" "),s("li",[t._v("商家服务: 取消业务操作.")])]),t._v(" "),s("p",[t._v("(6)第 5 步如果全部完成, 事务宣告以失败回滚结束, 如果第 5 步中任何一方出现异常, 不论是业务异常还是网络异常, 都将根据活动日志中的记录, "),s("strong",[t._v("重复执行该服务的 Cancel 操作, 即进行最大努力交付")]),t._v(".")]),t._v(" "),s("p",[t._v("可以看到, "),s("strong",[t._v("无论是成功 Confirm 还是失败后的 Cancel 操作, 都是尽最大努力交付的")]),t._v(".")]),t._v(" "),s("p",[t._v("由上述操作过程可见, TCC 其实有点类似 2PC 的准备阶段和提交阶段, 但 "),s("strong",[t._v("TCC 是在用户代码层面")]),t._v(", 而不是在基础设施层面, 这为它的实现带来了较高的灵活性, 可以根据需要设计资源锁定的粒度. TCC 在业务执行时"),s("strong",[t._v("只操作预留资源")]),t._v(", 几乎不会涉及锁和资源的争用, 具有很高的性能潜力. 但是 TCC 也带来了更高的"),s("strong",[t._v("开发成本和业务侵入性")]),t._v(", 即更高的开发成本和更换事务实现方案的替换成本, 所以通常并不会完全靠裸编码来实现 TCC, 而是基于某些"),s("strong",[t._v("分布式事务中间件")]),t._v("(譬如阿里开源的 "),s("strong",[t._v("Seata")]),t._v(")去完成, 尽量减轻一些编码工作量.")]),t._v(" "),s("h5",{attrs:{id:"_5-saga事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-saga事务"}},[t._v("#")]),t._v(" 5.SAGA事务")]),t._v(" "),s("p",[t._v("TCC 事务具有较强的"),s("strong",[t._v("隔离性")]),t._v(', 避免了"超售"的问题, 而且其性能一般来说是本篇提及的几种柔性事务模式中最高的, 但它仍不能满足所有的场景. TCC 的最主要限制是它的业务侵入性很强, 这里并不是重复上一节提到的它需要开发编码配合所带来的工作量的限制, 而是指它所要求的'),s("strong",[t._v("技术可控性上的约束")]),t._v(". 譬如, 把书店的场景修改如下: 由于中国网络支付日益盛行, 现在用户和商家在书店系统中可以选择不再开设充值账号, 至少不会强求一定要先从银行充值到系统中才能消费, 允许直接在购物时通过 U 盾或扫码支付, 在银行账号中划转货款. 这个需求完全符合国内网络支付盛行的现状, 却给系统的事务设计增加了额外的限制: 如果用户, 商家的账号余额由银行管理的话, 其操作权限和数据结构就不可能再随心所欲地自行定义, 通常也就无法完成冻结款项, 解冻, 扣减这样的操作, 因为银行一般不会配合你的操作. 所以 TCC 中的第一步 Try 阶段往往无法施行.")]),t._v(" "),s("p",[t._v("这时只能考虑采用另外一种柔性事务方案: "),s("strong",[t._v("SAGA 事务")]),t._v('. SAGA 在英文中是 "长篇故事, 长篇记叙, 一长串事件" 的意思.')]),t._v(" "),s("p",[t._v('SAGA 事务模式的历史十分悠久, 还早于分布式事务概念的提出. 它源于 1987 年普林斯顿大学的Hector Garcia-Molina 和 Kenneth Salem 在 ACM 发表的一篇论文 "SAGAS".')]),t._v(" "),s("p",[t._v('文中提出了一种提升"'),s("strong",[t._v("长时间事务")]),t._v('"(Long Lived Transaction)运作效率的方法, 大致思路是'),s("strong",[t._v("把一个大事务分解为可以交错运行的一系列子事务集合")]),t._v(". 原本 SAGA 的目的是避免大事务长时间锁定数据库的资源, 后来才发展成将一个分布式环境中的"),s("strong",[t._v("大事务分解为一系列本地事务")]),t._v("的设计模式.")]),t._v(" "),s("p",[t._v("SAGA 由两部分操作组成.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("将大事务拆分成若干个小事务")]),t._v(", 将整个分布式事务 T 分解为 n 个子事务, 命名为 T1, T2, …, Ti, …, Tn. 每个子事务都应该是或者能被视为"),s("strong",[t._v("原子行为")]),t._v(". 如果分布式事务能够正常提交, 其对数据的影响(即最终一致性)应与连续按顺序成功提交 Ti 等价.")]),t._v(" "),s("li",[s("strong",[t._v("为每一个子事务设计对应的补偿动作")]),t._v(", 命名为 C1, C2, …, Ci, …, Cn. Ti 与 Ci 必须满足以下条件. (1)Ti 与 Ci 都具备幂等性. (2)Ti 与 Ci 满足交换律(Commutative), 即无论先执行 Ti 还是先执行 Ci, 其效果都是一样的. (3)Ci 必须能成功提交, 即不考虑 Ci 本身提交失败被回滚的情形, 如出现就必须持续重试直至成功, 或者被人工介入为止.")])]),t._v(" "),s("p",[t._v("如果 T1 到 Tn 均成功提交, 那事务顺利完成, 否则要采取以下两种"),s("strong",[t._v("恢复策略")]),t._v("之一.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("正向恢复")]),t._v("(Forward Recovery): 如果 Ti 事务提交失败, 则一直"),s("strong",[t._v("对 Ti 进行重试")]),t._v(", 直至成功为止("),s("strong",[t._v("最大努力交付")]),t._v("). 这种恢复方式不需要补偿, "),s("strong",[t._v("适用于事务最终都要成功的场景")]),t._v(", 譬如在别人的银行账号中扣了款, 就一定要给别人发货. 正向恢复的执行模式为: T1, T2, …, Ti(失败), Ti, (重试)…, Ti+1, …, Tn.")]),t._v(" "),s("li",[s("strong",[t._v("反向恢复")]),t._v("(Backward Recovery): 如果 Ti 事务提交失败, 则一直"),s("strong",[t._v("执行 Ci 对 Ti 进行补偿")]),t._v(", 直至成功为止("),s("strong",[t._v("最大努力交付")]),t._v("). 这里要求 Ci 必须(在持续重试后)执行成功. 反向恢复的执行模式为: T1, T2, …, Ti(失败), Ci(补偿), …, C2, C1.")])]),t._v(" "),s("p",[t._v("与 TCC 相比, SAGA "),s("strong",[t._v("不需要为资源设计冻结状态和撤销冻结")]),t._v("的操作, 补偿操作往往要比冻结操作容易实现得多. 譬如, 前面提到的账号余额直接在银行维护的场景, 从银行划转货款到书店系统中, 这步是经由用户支付操作(扫码或 U 盾)来促使银行提供服务; 如果后续业务操作失败, 尽管系统无法要求银行撤销之前的用户转账操作, 但是由书店系统将货款转回到用户账号上作为补偿措施却是完全可行的.")]),t._v(" "),s("p",[s("strong",[t._v("SAGA 必须保证所有子事务都得以提交或者补偿")]),t._v(", 但 SAGA 系统本身也有可能会崩溃, 所以它必须设计成与数据库类似的"),s("strong",[t._v("日志机制")]),t._v("(被称为 SAGA Log)以保证系统恢复后可以追踪到子事务的执行情况, 譬如执行至哪一步或者补偿至哪一步了. 另外, 尽管补偿操作通常比冻结/撤销容易实现, 但保证正向, 反向恢复过程严谨地进行也需要花费不少工夫, 譬如通过服务编排, 可靠事件队列等方式完成, 所以, SAGA 事务通常也不会直接靠裸编码来实现, 一般是在事务中间件的基础上完成, 前面提到的 Seata 就同样支持 SAGA 事务模式.")]),t._v(" "),s("p",[t._v("基于"),s("strong",[t._v("数据补偿来代替回滚")]),t._v('的思路, 还可以应用在其他事务方案上, 这些方案笔者就不再单独展开, 放到这里一起来解释. 举个具体例子, 阿里的 GTS(Global Transaction Service, Seata由GTS开源而来)所提出的 "AT事务模式" 就是这样的应用.')]),t._v(" "),s("p",[t._v("从整体上看, AT 事务是参照了 XA 两段提交协议实现的, 但对于 XA 2PC 的缺陷, 即在准备阶段必须等待所有数据源都返回成功后, 协调者才能统一发出 Commit 命令而导致的木桶效应(所有涉及的锁和资源都需要等待到最慢的事务完成后才能统一释放), AT 事务设计了针对性的解决方案. 大致的做法是在业务数据提交时"),s("strong",[t._v("自动拦截所有 SQL")]),t._v(', 将 SQL 对数据修改前, 修改后的结果分别保存快照, 生成行锁, 通过本地事务一起提交到操作的数据源中, 相当于自动记录了重做和回滚日志. 如果分布式事务成功提交, 那后续清理每个数据源中对应的日志数据即可; 如果分布式事务需要回滚, 就根据日志数据自动产生用于补偿的"逆向 SQL". 基于这种补偿方式, 分布式事务中涉及的每一个数据源都可以单独提交, 然后立刻释放锁和资源. 这种异步提交的模式, 相比 2PC 极大地提升了系统的吞吐量水平, 而代价就是大幅度牺牲了隔离性, 甚至直接影响到了原子性. 因为在缺乏隔离性的前提下, 以补偿代替回滚并不是总能成功的. 譬如, 在本地事务提交之后, 分布式事务完成之前, 该数据被补偿之前又被其他操作修改过, 即出现了脏写(Dirty Wirte), 这时候一旦分布式事务需要回滚, 就不可能再通过自动的逆向 SQL 来实现补偿, 只能由人工介入处理了.')]),t._v(" "),s("p",[t._v('通常来说, 脏写是一定要避免的, 所有传统关系数据库在最低的隔离级别上都仍然要加锁以避免脏写, 因为脏写情况一旦发生, 其实也很难通过人工进行有效处理. 所以 GTS 增加了一个"全局锁"(Global Lock)的机制来实现写隔离, 要求本地事务提交之前, 一定要先拿到针对修改记录的全局锁后才允许提交, 没有获得全局锁之前就必须一直等待. 这种设计以牺牲一定性能为代价, 避免了两个分布式事务中包含的本地事务修改同一个数据的情况, 从而避免脏写. 在读隔离方面, AT 事务默认的隔离级别是读未提交(Read Uncommitted), 这意味着可能产生脏读(Dirty Read). 也可以采用全局锁的方案解决读隔离问题, 但直接阻塞读取的话, 代价就非常大了, 一般不会这样做. 由此可见, 分布式事务中没有一揽子包治百病的解决办法, 因地制宜地选用合适的事务处理方案才是唯一有效的做法.')]),t._v(" "),s("h3",{attrs:{id:"透明多级分流系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#透明多级分流系统"}},[t._v("#")]),t._v(" 透明多级分流系统")]),t._v(" "),s("p",[t._v('现代互联网系统, "'),s("strong",[t._v("分流")]),t._v('"是必须要考虑的设计, 分流所使用手段数量之多, 涉及场景之广, 可能连它的开发者都未必能全部意识到. "分布广阔" 源于 "多级", "意识不到" 谓之 "透明", 也即的主题"'),s("strong",[t._v("透明多级分流系统")]),t._v('"(Transparent Multilevel Diversion System)的来由.')]),t._v(" "),s("p",[t._v("当请求从浏览器出发, 在域名服务器的指引下找到系统的入口, 经过网关, 负载均衡器, 缓存, 服务集群等一系列设施, 最后触及末端存储于数据库服务器中的信息, 然后逐级返回到用户的浏览器之中. 这其中要经过很多技术部件, 系统设计者应该意识到不同的设施与部件在系统中有各自不同的价值.")]),t._v(" "),s("ul",[s("li",[t._v("有一些部件位于"),s("strong",[t._v("客户端或网络的边缘")]),t._v(", 能够迅速响应用户的请求, 避免给后方的 I/O 与 CPU 带来压力, 典型如本地缓存, 内容分发网络, 反向代理等.")]),t._v(" "),s("li",[t._v("有一些部件的"),s("strong",[t._v("处理能力能够线性拓展, 易于伸缩")]),t._v(", 可以使用较小的代价堆叠机器来获得与用户数量相匹配的并发性能, 应尽量作为业务逻辑的主要载体, 典型如集群中能够自动扩缩的服务节点.")]),t._v(" "),s("li",[t._v("有一些部件"),s("strong",[t._v("稳定服务")]),t._v("对系统运行有全局性的影响, 要时刻保持容错备份, 维护高可用性, 典型如服务注册中心, 配置中心.")]),t._v(" "),s("li",[t._v("有一些设施是天生的单点部件, 只能依靠升级机器本身的网络, 存储和运算性能来提升处理能力, 如位于系统入口的"),s("strong",[t._v("路由, 网关或者负载均衡器")]),t._v("(它们都可以做集群, 但一次网络请求中"),s("strong",[t._v("无可避免至少有一个是单点的部件")]),t._v("), 位于请求调用链末端的传统关系数据库等, 都是典型的单点部件.")])]),t._v(" "),s("p",[t._v("对系统进行流量规划时, 应该充分理解这些部件的价值差异, 有两条简单的原则能适用于系统设计.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("第一条原则是尽可能减少单点部件")]),t._v(". 如果某些单点是无可避免的, 则应尽最大限度减少到达单点部件的流量. 在系统中往往会有多个部件能够处理, 响应用户请求, 譬如要获取一张存储在数据库的用户头像图片, 浏览器缓存, 内容分发网络, 反向代理, Web 服务器, 文件服务器, 数据库都可能提供这张图片. 恰如其分地"),s("strong",[t._v("引导请求分流至最合适的组件中, 避免绝大多数流量汇集到单点部件(如数据库)")]),t._v(" , 同时依然能够或在绝大多数时候保证处理结果的准确性, 使单点系统在出现故障时自动而迅速地实施补救措施, 这便是系统架构中多级分流的意义.")]),t._v(" "),s("li",[s("strong",[t._v("另一条更关键的原则是奥卡姆剃刀原则")]),t._v(". 应对多级分流的手段有全面的理解与充分的准备, 同时清晰地意识到这些设施并不是越多越好. 在实际构建系统时, 应当在有明确需求, 真正必要的时候再去考虑部署它们. "),s("strong",[t._v("不是每一个系统都要追求高并发, 高可用的, 根据系统的用户量, 峰值流量和团队本身的技术与运维能力来考虑如何部署这些设施才是合理的做法, 在能满足需求的前提下, 最简单的系统就是最好的系统")]),t._v(".")])]),t._v(" "),s("p",[t._v("本章将会根据"),s("strong",[t._v("流量从客户端发出到服务端")]),t._v("处理这个过程中所流经的与"),s("strong",[t._v("功能无关的技术部件")]),t._v("为线索, 解析每个部件的透明工作原理与起到的分流作用.")]),t._v(" "),s("p",[t._v("下面所讲述的"),s("strong",[t._v("客户端缓存, 域名解析, 传输链路, 内容分发网络, 负载均衡, 服务端缓存")]),t._v(', 都是为了达成 "透明分流" 这个目标所采用的工具与手段, 高可用架构, 高并发则是通过 "透明分流" 所获得的价值.')]),t._v(" "),s("h4",{attrs:{id:"客户端缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#客户端缓存"}},[t._v("#")]),t._v(" 客户端缓存")]),t._v(" "),s("p",[t._v('浏览器的缓存机制早已存在, 在 HTTP 协议设计之初, 便确定了服务端与客户端之间 "无状态"(Stateless) 的交互原则, 即要求每次请求是独立的, 每次请求无法感知也不能依赖另一个请求的存在, 这既简化了 HTTP 服务器的设计, 也为其水平扩展能力留下了广袤的空间. 但无状态并不只有好的一面, 由于每次请求都是独立的, 服务端不保存此前请求的状态和资源, 所以也不可避免地导致其携带了重复的数据, 导致网络性能降低.')]),t._v(" "),s("p",[t._v("HTTP "),s("strong",[t._v("协议对此问题的解决方案便是客户端缓存")]),t._v(', 在 HTTP 从 1.0 到 1.1, 再到 2.0 版本的演进中, 逐步形成了现在被称为 "状态缓存", "强制缓存" 和 "协商缓存" 的 HTTP 缓存机制.')]),t._v(" "),s("p",[t._v("状态缓存是指不经过服务器, 客户端直接根据缓存信息对目标网站的状态判断, 以前只有 301/Moved Permanently (永久重定向)这一种; 后来在 RFC6797 中增加了 HSTS 机制, 用于避免依赖 301/302 跳转 HTTPS 时可能产生的降级中间人劫持, 这也属于另一种状态缓存. 由于状态缓存所涉内容只有这么一点, 后续就只聚焦讨论"),s("strong",[t._v("强制缓存与协商缓存")]),t._v("两种机制.")]),t._v(" "),s("p",[t._v("无论是"),s("strong",[t._v("强制缓存还是协商缓存, 原理都是在服务器对客户端请求的")]),t._v("​"),s("mark",[s("strong",[t._v("响应中附带一些条件")])]),t._v("​ "),s("strong",[t._v(", 要求客户端在遇到相同的请求时, 先判断一下条件是否满足, 如果满足, 就直接用上一次服务器给予的响应来代替, 不必重新访问")]),t._v(". 这两种缓存机制的区别是它们采用了"),s("strong",[t._v("不同的判断条件来解决资源在客户端和服务器间的一致性问题")]),t._v(".")]),t._v(" "),s("h5",{attrs:{id:"_1-强制缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-强制缓存"}},[t._v("#")]),t._v(" 1.强制缓存")]),t._v(" "),s("p",[t._v("HTTP 的强制缓存对一致性问题的处理策略就如它的名字一样, 十分直接: 假设在某个时点到来以前, 譬如收到响应后的 10 分钟内, 资源的内容和状态"),s("strong",[t._v("一定不会被改变")]),t._v(", 因此客户端可以无须经过任何请求, 在该时点前一直持有和使用该资源的本地缓存副本.")]),t._v(" "),s("p",[t._v("根据约定, 强制缓存在浏览器的地址输入, 页面链接跳转, 新开窗口, 前进和后退中均可生效, 但在"),s("strong",[t._v("用户主动刷新页面时应当自动失效")]),t._v(". HTTP 协议中设有以下两类 Header 实现强制缓存.")]),t._v(" "),s("h6",{attrs:{id:"_1-expires"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-expires"}},[t._v("#")]),t._v(" (1)Expires")]),t._v(" "),s("p",[t._v("Expires 是 HTTP/1.0 协议中开始提供的 Header, 后面跟随一个"),s("strong",[t._v("截止时间参数")]),t._v(". 当服务器返回某个资源时带有该 Header, 意味着"),s("strong",[t._v("服务器承诺资源在截止时间之前不会发生变动, 浏览器可直接缓存该数据, 不再重新发请求")]),t._v(", 示例:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token response-status"}},[s("span",{pre:!0,attrs:{class:"token http-version property"}},[t._v("HTTP/1.1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token status-code number"}},[t._v("200")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token reason-phrase string"}},[t._v("OK")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Expires")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("Wed, 8 Apr 2020 07:28:00 GMT")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("Expires 是 HTTP 协议最初版本中提供的缓存机制, 设计非常直观易懂, 但它至少存在以下几个明显"),s("strong",[t._v("问题")]),t._v(":")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("受限于客户端的本地时间")]),t._v(". 譬如在收到响应后, 客户端修改了本地时间, 将时间前后调整几分钟, 就可能会造成缓存"),s("strong",[t._v("提前失效或超期持有")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("无法处理涉及用户身份的私有资源")]),t._v(". 譬如某些资源被登录用户缓存在自己的浏览器上是合理的, 但如果被代理服务器或者内容分发网络缓存起来, 则可能被其他未认证的用户所获取.")]),t._v(" "),s("li",[s("strong",[t._v('无法描述 "不缓存" 的语义')]),t._v('. 譬如浏览器为了提高性能, 往往会自动在当次会话中缓存某些 MIME 类型的资源, 在 HTTP/1.0 的服务器中就缺乏强制手段不允许浏览器缓存某个资源. 以前为了实现这类功能, 通常不得不使用脚本, 或手工在资源后面增加时间戳(譬如 "xx.js?t=1586359920", "xx.jpg?t=1586359350") 来保证每次资源都会重新获取.')])]),t._v(" "),s("h6",{attrs:{id:"_2-cache-control"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-cache-control"}},[t._v("#")]),t._v(" (2)Cache-Control")]),t._v(" "),s("p",[t._v("Cache-Control 是 HTTP/1.1 协议中定义的"),s("strong",[t._v("强制缓存 Header")]),t._v(", 它的语义比 Expires 丰富了很多, 如果 Cache-Control 和 Expires "),s("strong",[t._v("同时存在")]),t._v(", 并且语义存在冲突(譬如 Expires 与 max-age/s-maxage 冲突)的话, 规定"),s("strong",[t._v("必须以 Cache-Control 为准")]),t._v(".")]),t._v(" "),s("p",[t._v("Cache-Control 的使用示例如下:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token response-status"}},[s("span",{pre:!0,attrs:{class:"token http-version property"}},[t._v("HTTP/1.1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token status-code number"}},[t._v("200")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token reason-phrase string"}},[t._v("OK")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Cache-Control")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("max-age=600")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("Cache-Control 在客户端的请求 Header 或服务器的响应 Header 中都可以存在, 它定义了一系列参数, 其标准的参数主要如下.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("max-age 和 s-maxage")]),t._v(": max-age 后面跟随一个以秒为单位的数字, 表明"),s("strong",[t._v("相对于请求时间")]),t._v("(在 Date Header 中会注明请求时间)"),s("strong",[t._v("多少秒以内缓存是有效的")]),t._v(", 即多少秒以内不需要重新从服务器中获取资源. 相对时间避免了 Expires 中采用的"),s("strong",[t._v("绝对时间")]),t._v('可能受客户端时钟影响的问题. s-maxage 中的 "s" 是 "share" 的缩写, 意味 "共享缓存" 的有效时间, 即允许被 CDN, 代理等持有的缓存有效时间, 用于提示 CDN 这类服务器应在何时让缓存失效.')]),t._v(" "),s("li",[s("strong",[t._v("public 和 private")]),t._v(": 指明"),s("strong",[t._v("是否涉及用户身份的私有资源")]),t._v(", 如果是 public, 则可以被代理, CDN 等缓存; 如果是 private, 则只能由用户的"),s("strong",[t._v("客户端")]),t._v("进行私有缓存.")]),t._v(" "),s("li",[s("strong",[t._v("no-cache 和 no-store")]),t._v(": no-cache 指明该资源"),s("strong",[t._v("不应该被缓存")]),t._v(", 哪怕是同一个会话中对同一个 URL 地址的请求, 也必须从服务端获取, "),s("strong",[t._v("令强制缓存完全失效")]),t._v(", 但此时"),s("strong",[t._v("协商缓存机制依然是生效")]),t._v("的; no-store 不强制会话中相同 URL 资源的重复获取, 但禁止浏览器, CDN 等以任何形式保存该资源.")]),t._v(" "),s("li",[s("strong",[t._v("no-transform")]),t._v(": 禁止以任何形式"),s("strong",[t._v("修改资源")]),t._v(". 譬如某些 CDN, 透明代理支持自动 GZip 压缩图片或文本, 以提升网络性能, 而 no-transform 禁止这样的行为, 它不允许 Content-Encoding, Content-Range, Content-Type 进行任何形式的修改.")]),t._v(" "),s("li",[s("strong",[t._v("min-fresh 和 only-if-cached")]),t._v(": 这两个参数是仅用于客户端的请求 Header. min-fresh 后面跟随一个以秒为单位的数字, 用于"),s("strong",[t._v("建议")]),t._v("服务器能返回一个不少于该时间的缓存资源(即包含 max-age 且不少于 min-fresh 的数字). only-if-cached 表示客户端要求不给它发送资源的具体内容, 此时客户端仅能使用事先缓存的资源来进行响应, 若缓存不能命中, 就直接返回 503/Service Unavailable 错误.")]),t._v(" "),s("li",[s("strong",[t._v("must-revalidate 和 proxy-revalidate")]),t._v(": must-revalidate 表示在资源过期后, 一定要从服务器中进行获取, 即超过了 max-age 的时间后, 就等同于 no-cache 的行为, proxy-revalidate 用于提示"),s("strong",[t._v("代理")]),t._v(", CDN 等设备资源过期后的缓存行为, 除对象不同外, 语义与 must-revalidate 完全一致.")])]),t._v(" "),s("h5",{attrs:{id:"_2-协商缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-协商缓存"}},[t._v("#")]),t._v(" 2.协商缓存")]),t._v(" "),s("p",[s("strong",[t._v("强制缓存是基于时效性的")]),t._v(", 但无论是人还是服务器, 其实多数情况下并没有什么把握去承诺某项资源多久不会发生变化. 另外一种"),s("strong",[t._v("基于变化检测的缓存机制")]),t._v(", 在一致性上会有比强制缓存更好的表现, 但需要一次变化检测的交互开销, "),s("strong",[t._v("性能上就会略差一些")]),t._v(', 这种基于检测的缓存机制, 通常被称为 "'),s("strong",[t._v("协商缓存")]),t._v('".')]),t._v(" "),s("p",[t._v("注意在 HTTP 中的"),s("strong",[t._v("协商缓存与强制缓存并没有互斥性")]),t._v(", 这两套机制是"),s("strong",[t._v("并行工作")]),t._v("的. 譬如当强制缓存存在时, 直接从强制缓存中返回资源, 无须进行变动检查; 而当强制缓存"),s("strong",[t._v("超过时效")]),t._v("或被禁止(no-cache/must-revalidate) 时, "),s("strong",[t._v("协商缓存仍可以正常工作")]),t._v(".")]),t._v(" "),s("p",[t._v("协商缓存有两种变动检查机制, 分别是根据"),s("strong",[t._v("资源的修改时间进行检查, 以及根据资源唯一标识是否发生变化进行检查")]),t._v(", 它们都是靠"),s("strong",[t._v("一组成对出现的请求, 响应 Header 来实现")]),t._v("的.")]),t._v(" "),s("h6",{attrs:{id:"_1-last-modified和if-modified-since"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-last-modified和if-modified-since"}},[t._v("#")]),t._v(" (1)Last-Modified和If-Modified-Since")]),t._v(" "),s("p",[t._v("Last-Modified 是服务端的响应 Header, 用于告诉客户端这个资源的"),s("strong",[t._v("最后修改时间")]),t._v(". 对于带有这个 Header 的资源, 当客户端需要再次请求时, 会通过 If-Modified-Since 把之前收到的资源"),s("strong",[t._v("最后修改时间发送回服务端")]),t._v(".")]),t._v(" "),s("p",[t._v("如果此时服务端发现资源在该时间后"),s("strong",[t._v("没有被修改过")]),t._v(", 就返回一个 304/Not Modified 的响应, 无须附带消息体, 即可达到节省流量的目的, 如下所示:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token response-status"}},[s("span",{pre:!0,attrs:{class:"token http-version property"}},[t._v("HTTP/1.1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token status-code number"}},[t._v("304")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token reason-phrase string"}},[t._v("Not Modified")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Cache-Control")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("public, max-age=600")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Last-Modified")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("Wed, 8 Apr 2020 15:31:30 GMT")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("如果此时服务端发现资源在"),s("strong",[t._v("该时间之后有变动")]),t._v(", 就会返回 200/OK 的完整响应, 在消息体中包含最新的资源, 如下所示:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token response-status"}},[s("span",{pre:!0,attrs:{class:"token http-version property"}},[t._v("HTTP/1.1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token status-code number"}},[t._v("200")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token reason-phrase string"}},[t._v("OK")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Cache-Control")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("public, max-age=600")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Last-Modified")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("Wed, 8 Apr 2020 15:31:30 GMT")])]),t._v("\n\nContent\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("h6",{attrs:{id:"_2-etag和if-none-match"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-etag和if-none-match"}},[t._v("#")]),t._v(" (2)ETag和If-None-Match")]),t._v(" "),s("p",[t._v("ETag 是服务端的"),s("strong",[t._v("响应 Header")]),t._v(", 用于告诉客户端这个资源的"),s("strong",[t._v("唯一标识")]),t._v(". HTTP 服务端可以根据自己的意愿来选择如何生成这个标识, 譬如 Apache 服务端的 ETag 值默认是对文件的索引节点(INode), 大小和最后修改时间进行哈希计算后得到的.")]),t._v(" "),s("p",[t._v("对于带有这个 Header 的资源, 当客户端需要"),s("strong",[t._v("再次请求")]),t._v("时, 会通过 "),s("strong",[t._v("If-None-Match")]),t._v(" 把之前收到的"),s("strong",[t._v("资源唯一标识发送回服务端")]),t._v(".")]),t._v(" "),s("p",[t._v("如果此时服务端计算后发现资源的唯一标识与上传回来的"),s("strong",[t._v("标识一致")]),t._v(", 说明资源"),s("strong",[t._v("没有被修改过")]),t._v(", 就返回一个 304/Not Modified 的响应, 无须附带消息体, 即可达到节省流量的目的, 如下所示:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token response-status"}},[s("span",{pre:!0,attrs:{class:"token http-version property"}},[t._v("HTTP/1.1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token status-code number"}},[t._v("304")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token reason-phrase string"}},[t._v("Not Modified")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Cache-Control")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("public, max-age=600")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("ETag")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v('"28c3f612-ceb0-4ddc-ae35-791ca840c5fa"')])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("如果此时服务端发现资源的唯一标识"),s("strong",[t._v("有变动")]),t._v(", 就会返回 200/OK 的完整响应, 在消息体中包含最新的资源, 如下所示:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token response-status"}},[s("span",{pre:!0,attrs:{class:"token http-version property"}},[t._v("HTTP/1.1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token status-code number"}},[t._v("200")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token reason-phrase string"}},[t._v("OK")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Cache-Control")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("public, max-age=600")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("ETag")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v('"28c3f612-ceb0-4ddc-ae35-791ca840c5fa"')])]),t._v("\n\nContent\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[s("strong",[t._v("ETag 是 HTTP 中一致性最强的缓存机制")]),t._v(". 譬如 Last-Modified 标注的最后修改只能精确到秒级, 如果某些文件在 1s 以内被"),s("strong",[t._v("修改多次")]),t._v("的话, 它将不能准确标注文件的修改时间; 又如果某些文件会被"),s("strong",[t._v("定期生成, 可能内容并没有任何变化")]),t._v(", 但 Last-Modified 却改变了, 导致文件无法有效使用缓存, 这些情况 Last-Modified 都有可能产生资源一致性问题, 只能使用 ETag 解决.")]),t._v(" "),s("p",[s("strong",[t._v("ETag 也是 HTTP 中性能最差的缓存机制")]),t._v(", 在每次请求时, 服务端都必须对资源进行哈希计算, 相比简单获取一下修改时间, 开销要大了很多. ETag 和 Last-Modified 是"),s("strong",[t._v("允许一起使用")]),t._v("的, 服务端会优先验证 ETag, 在 ETag 一致的情况下, 再去对比 Last-Modified, 这是为了防止有一些 HTTP 服务端未将文件修改日期纳入哈希范围内.")]),t._v(" "),s("p",[t._v("所以呀, 一致性也是需要吃性能的.")]),t._v(" "),s("p",[t._v("到这里为止, HTTP 的协商缓存机制已经能很好地适用于通过 URL 获取"),s("strong",[t._v("单个资源")]),t._v('的场景, 为什么要强调"单个资源"呢? 在 HTTP 协议的设计中, 一个 URL 地址是有可能提供'),s("strong",[t._v("多份不同版本的资源")]),t._v("的, 譬如, 一段文字的不同语言版本, 一个文件的不同编码格式版本, 一份数据的不同压缩方式版本等等. 因此针对请求的缓存机制, 也必须能够提供对应的支持. 为此, HTTP 协议设计了以"),s("strong",[t._v("Accept")]),t._v("(Accept, Accept-Language, Accept-Charset, Accept-Encoding) 开头的一套"),s("strong",[t._v("请求 Header")]),t._v(" 和对应的以 "),s("strong",[t._v("Content")]),t._v("(Content-Language, Content-Type, Content-Encoding) 开头的"),s("strong",[t._v("响应 Header")]),t._v(", 这些 Header 被称为 HTTP 的"),s("strong",[t._v("内容协商机制")]),t._v(".")]),t._v(" "),s("p",[t._v("与之对应的, 对于一个 URL 能够获取"),s("strong",[t._v("多个资源")]),t._v("的场景, 缓存也同样需要有明确的"),s("strong",[t._v("标识来获知根据什么内容返回给用户正确的资源")]),t._v(". 此时就要用到 Vary Header, Vary 后面应该跟随一组其他 Header 的名字, 譬如:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token response-status"}},[s("span",{pre:!0,attrs:{class:"token http-version property"}},[t._v("HTTP/1.1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token status-code number"}},[t._v("200")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token reason-phrase string"}},[t._v("OK")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Vary")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("Accept, User-Agent")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("以上响应的含义是应该根据 MIME 类型和浏览器类型来缓存资源, 获取资源时也需要根据请求 Header 中对应的字段来筛选出适合的资源版本.")]),t._v(" "),s("p",[t._v("根据约定, 协商缓存不仅在浏览器的地址输入, 页面链接跳转, 新开窗口, 前进, 后退中生效, 而且在用户主动刷新页面(F5)时"),s("strong",[t._v("同样是生效")]),t._v('的, 只有用户强制刷新(Ctrl+F5)或明确禁用缓存(譬如在 DevTools 中设定)时才会失效, 此时客户端向服务端发出的请求会自动带有 "Cache-Control:no-cache".')]),t._v(" "),s("h4",{attrs:{id:"域名解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#域名解析"}},[t._v("#")]),t._v(" 域名解析")]),t._v(" "),s("h5",{attrs:{id:"_1-基础-5"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础-5"}},[t._v("#")]),t._v(" 1.基础")]),t._v(" "),s("p",[t._v("DNS 的作用是将便于人类理解的域名地址转换为便于计算机处理的 IP 地址, 世界根域名服务器的 ZONE 文件只有 2MB 大小, 甚至可以打印出来物理备份, DNS 系统的设计是十分牛的.")]),t._v(" "),s("p",[t._v("域名解析对于大多数信息系统来说是必不可少的组件, 却是没有太高存在感, 通常不会受重点关注的设施.")]),t._v(" "),s("h5",{attrs:{id:"_2-域名解析流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-域名解析流程"}},[t._v("#")]),t._v(" 2.域名解析流程")]),t._v(" "),s("p",[t._v("当访问某个网址域名时, 譬如以 "),s("a",{attrs:{href:"http://www.icyfenix.com.cn",target:"_blank",rel:"noopener noreferrer"}},[t._v("www.icyfenix.com.cn"),s("OutboundLink")],1),t._v(" 为例, 如果没有缓存的话, 都会先经过 DNS 服务器的解析翻译, 找到域名对应的 IP 地址才能开始通信, 这项操作是"),s("strong",[t._v("操作系统自动完成")]),t._v('的, 一般不需要用户程序介入. 不过, DNS 服务器并不是一次性将 "www.icyfenix.com.cn" 直接解析成 IP 地址, 需要经历一个'),s("strong",[t._v("递归")]),t._v("的过程.")]),t._v(" "),s("p",[t._v('首先 DNS 会将域名还原为 "www.icyfenix.com.cn.", 注意最后多了一个点 ".", 它是 ".root" 的含义. 早期的域名必须带有这个点才能被 DNS 正确解析, 如今几乎所有的操作系统, DNS 服务器都可以'),s("strong",[t._v("自动")]),t._v("补上结尾的点号, 下面开始按如下步骤解析.")]),t._v(" "),s("p",[t._v("(1) 客户端先检查"),s("strong",[t._v("本地的 DNS 缓存")]),t._v(", 查看是否存在存活着的该域名的地址记录. DNS 是以"),s("strong",[t._v("存活时间")]),t._v("(Time to Live, TTL) 来衡量缓存的有效情况的, 所以如果某个域名改变了 IP 地址, DNS 服务器并"),s("strong",[t._v("没有任何机制去通知缓存了该地址的机器去更新或失效掉缓存")]),t._v(", 只能依靠 TTL 超期后的"),s("strong",[t._v("重新获取来保证一致性")]),t._v(". 后续每一级 DNS 查询的过程都会有类似的缓存查询操作, 届时将不再重复叙述.")]),t._v(" "),s("p",[t._v("(2) 客户端将地址发送给本机操作系统中配置的本地 DNS(Local DNS), 这个本地 DNS 服务器可以由用户手工设置, 也可以在 DHCP 分配或拨号时从 PPP 服务器中自动获取到.")]),t._v(" "),s("p",[t._v('(3) 本地 DNS 收到查询请求后, 会按照 "是否有 '),s("a",{attrs:{href:"http://www.icyfenix.com.cn",target:"_blank",rel:"noopener noreferrer"}},[t._v("www.icyfenix.com.cn"),s("OutboundLink")],1),t._v(' 的权威服务器" -> "是否有 icyfenix.com.cn 的权威服务器" -> "是否有 com.cn 的权威服务器" -> "是否有 cn 的权威服务器" 的顺序, 依次查询自己的地址记录, 如果都没有查询到, 就会一直找到'),s("strong",[t._v("最后点号代表的根域名服务器为止")]),t._v(". 这个步骤里涉及两个重要名词.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("权威域名服务器")]),t._v("(Authoritative DNS): 负责翻译"),s("strong",[t._v("特定域名")]),t._v('的 DNS 服务器, "权威" 意味着域名应该翻译出怎样的结果是由这个服务器决定的. DNS 翻译域名时无须像查电话本一样刻板地一对一翻译, 根据来访机器, 网络链路, 服务内容等各种信息, 可以玩出很多花样. 权威 DNS 的灵活应用, 在内容分发网络, 服务发现中都有所应用.')]),t._v(" "),s("li",[s("strong",[t._v("根域名服务器")]),t._v("(Root DNS): 固定的, "),s("strong",[t._v("无须查询")]),t._v("的顶级域名(Top-Level Domain)服务器, 可以"),s("strong",[t._v("默认它们已内置在操作系统代码之中")]),t._v(". 全世界一共有 13 组根域名服务器, 每一组根域名都通过任播的方式建立了一大群镜像. 选择 13 是由于 DNS 主要采用 UDP 传输协议(在需要稳定性保证的时候也可以采用 TCP)来进行数据交换, 未分片的 UDP 数据包在 IPv4 下的最大有效值为 512 字节, 最多可以存放 13 组地址记录.")])]),t._v(" "),s("p",[t._v("(4)现在假设"),s("strong",[t._v("本地 DNS 是全新")]),t._v("的, 上面不存在任何域名的权威服务器记录, 所以当 DNS 查询请求按步骤 3 的顺序一直查到"),s("strong",[t._v("根域名")]),t._v('服务器之后, 它将会得到 "cn的权威服务器" 的地址记录, 然后通过 "cn的权威服务器", 得到 "com.cn的权威服务器" 的地址记录, 以此类推, 最后找到能够解释 "www.icyfenix.com.cn" 的权威服务器地址.')]),t._v(" "),s("p",[t._v('(5)通过 "'),s("a",{attrs:{href:"http://www.icyfenix.com.cn",target:"_blank",rel:"noopener noreferrer"}},[t._v("www.icyfenix.com.cn"),s("OutboundLink")],1),t._v(" 的"),s("strong",[t._v("权威服务器")]),t._v('", 查询 '),s("a",{attrs:{href:"http://www.icyfenix.com.cn",target:"_blank",rel:"noopener noreferrer"}},[t._v("www.icyfenix.com.cn"),s("OutboundLink")],1),t._v(" 的地址记录. 地址记录并"),s("strong",[t._v("不一定就是指 IP 地址")]),t._v(", 在 RFC 规范中有定义的地址记录类型已经多达数十种, 譬如 IPv4 下的 IP 地址为 A 记录, IPv6 下的 AAAA 记录, 主机别名 CNAME 记录, 等等.")]),t._v(" "),s("p",[t._v("前面提到过, 每种记录类型中还可以包括"),s("strong",[t._v("多条记录")]),t._v(", 以一个域名下配置多条不同的 A 记录为例, 此时"),s("strong",[t._v("权威服务器可以根据自己的策略来进行选择")]),t._v(", 典型的应用是智能线路: 根据"),s("strong",[t._v("访问者所处的不同地区")]),t._v("(譬如华北, 华南, 东北), 不同服务商(譬如电信, 联通, 移动)等因素来确定返回"),s("strong",[t._v("最合适的 A 记录")]),t._v(", 将访问者路由到最合适的数据中心, 达到智能加速的目的.")]),t._v(" "),s("h5",{attrs:{id:"_3-域名解析的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-域名解析的问题"}},[t._v("#")]),t._v(" 3.域名解析的问题")]),t._v(" "),s("p",[t._v("DNS 系统多级分流的设计使得 DNS 系统能够经受住全球网络流量不间断的冲击, 但也并非全无缺点. 典型的问题是"),s("strong",[t._v("响应速度")]),t._v(", 在极端情况下, 即各级服务器均无缓存时, 域名解析可能导致每个域名都必须递归多次才能查询到结果, 明显影响传输的响应速度, 极端时 DNS 查询可达上百毫秒.")]),t._v(" "),s("p",[t._v('有一种 "DNS预取" (DNS Prefetching)的前端优化手段可用来避免这类问题: 如果网站后续要使用来自其他域的资源, 那就在网页加载时生成一个 link 请求, '),s("strong",[t._v("促使浏览器提前对该域名进行预解释")]),t._v(", 譬如下面代码所示:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[t._v('<link rel="dns-prefetch" href="//domain.not-icyfenx.cn">\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("而另一种可能更严重的缺陷是 DNS 的分级查询意味着"),s("strong",[t._v("每一级都有可能受到中间人攻击")]),t._v("的威胁, 产生被劫持的风险. 要攻陷位于递归链条顶层的服务器(譬如根域名服务器, cn 权威服务器)和链路是非常困难的, 它们都有很专业的安全防护措施. 但很多位于递归链底层或来自本地运营商的本地 DNS 服务器的安全防护则相对松懈, 甚至不少地区的运营商自己就会主动劫持, 专门返回一个错的 IP, 通过在这个 IP 上代理用户请求, 给特定类型的资源(主要是 HTML)注入广告, 以此牟利.")]),t._v(" "),s("p",[t._v("为此, 最近几年出现了另一种新的 DNS 工作模式: "),s("strong",[t._v("HTTPDNS")]),t._v("(也称为 DNS over HTTPS, DoH). 它将原本的 DNS 解析服务开放为一个"),s("strong",[t._v("基于 HTTPS 协议的查询服务")]),t._v(", 替代基于 UDP 传输协议的 DNS 域名解析, 通过"),s("strong",[t._v("程序代替操作系统")]),t._v('直接从权威 DNS 或可靠的本地 DNS 获取解析数据, 从而绕过传统本地 DNS. 这样做的好处是完全免去了 "中间商赚差价" 的环节, 不再惧怕底层的域名劫持, 有效避免本地 DNS 不可靠导致的域名生效缓慢, 来源 IP 不准确, 产生的智能线路切换错误等问题.')]),t._v(" "),s("h4",{attrs:{id:"传输链路"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#传输链路"}},[t._v("#")]),t._v(" 传输链路")]),t._v(" "),s("p",[t._v("经过客户端缓存的节流, DNS 服务的解析指引, 程序发出的请求流量便正式离开客户端, 踏上以服务器为目的地的旅途了, 这个过程就是本节的主角: "),s("strong",[t._v("传输链路")]),t._v(".")]),t._v(" "),s("p",[t._v("可能不少人的第一直觉会认为传输链路是开发者完全不可控的因素, 网络路由跳点的数量, 运营商铺设线路的质量决定了线路带宽的大小, 速率的高低. 然而事实并非如此, 程序发出的请求能否与"),s("strong",[t._v("应用层, 传输层协议提倡的方式相匹配")]),t._v(", 也会对传输的效率有极大影响. 最容易体现这点的是那些"),s("strong",[t._v("前端网页的优化技巧")]),t._v(", 只要简单搜索一下, 就能找到很多以优化链路传输为目的的前端设计原则, 譬如经典的雅虎 YSlow-23 条规则中与传输相关的内容如下.")]),t._v(" "),s("ul",[s("li",[t._v("减少请求数量(Minimize HTTP Requests): 请求每次都需要建立通信链路进行数据传输, 这些开销很昂贵, 减少请求的数量可有效提高访问性能, 对于前端开发者, 可用于减少请求数量的手段包括: (1)雪碧图(CSS Sprite); (2)CSS, JS文件合并/内联(Concatenation/Inline); (3)分段文档(Multipart Document); (4)媒体(图片, 音频)内联(Data Base64 URI); (5)合并Ajax请求(Batch Ajax Request).")]),t._v(" "),s("li",[t._v("扩大并发请求数(Split Components Across Domain): 对于每个域名, 浏览器一般支持 6 个并发请求. 如果希望更快地加载大量图片或其他资源, 需要进行域名分片(Domain Sharding), 将图片同步到不同主机或者同一个主机的不同域名上.")]),t._v(" "),s("li",[t._v("启用压缩传输(GZip Component): 启用压缩能够大幅度减少需要在网络上传输的内容的大小, 节省网络流量.")]),t._v(" "),s("li",[t._v("避免页面重定向(Avoid Redirect): 当页面发生了重定向, 就会造成整个文档的传输延迟. 在 HTML 文档到达之前, 页面中不会呈现任何东西, 降低了用户体验.")]),t._v(" "),s("li",[t._v("按重要性调节资源优先级(Put Stylesheet at the Top, Put Script at the Bottom): 将重要的, 马上就要使用的, 对客户端展示影响大的资源, 放在 HTML 的头部, 以便优先下载.")])]),t._v(" "),s("p",[t._v("这些原则在今天仍有一定价值, 但若干年后再回头看它们, 其中多数原则大概率会变成 Tricks, 甚至成了"),s("strong",[t._v("反模式")]),t._v('. 导致这种变化的原因是 HTTP 协议还在持续发展, 从 HTTP/1.0 和 HTTP/1.1, 到2015 年发布的 HTTP/2, 再到 2019 年的 HTTP/3, HTTP 协议本身的变化使得 "适合 HTTP 传输的请求" 的特征也在不断变化.')]),t._v(" "),s("h5",{attrs:{id:"_1-连接数优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-连接数优化"}},[t._v("#")]),t._v(" 1.连接数优化")]),t._v(" "),s("p",[t._v("HTTP(特指 HTTP/3 以前)是以 TCP 为传输层的应用层协议, 但 HTTP over TCP 这种搭配只能说是 TCP 在当今网络中统治性地位所造就的结果, 而不能说它们两者的配合就是合适的. HTTP 传输对象的主要特征是数量多, 时间短, 资源小, 切换快. 另一方面, TCP 协议要求必须在"),s("strong",[t._v("三次握手")]),t._v('完成之后才能开始数据传输, 这是一个可能以高达"百毫秒"为计时尺度的事件; 另外, TCP 还有'),s("strong",[t._v("慢启动")]),t._v("的特性, 使得刚刚建立连接时的传输速度是最低的, 后面再逐步加速直至稳定. 由于 TCP 协议本身是面向"),s("strong",[t._v("长时间, 大数据")]),t._v("传输来设计的, 在长时间尺度下, 它建立连接的高昂成本才不至于成为瓶颈, 它的稳定性和可靠性的优势才能展现出来. 因此, 可以说 HTTP over TC P这种搭配在目标特征上确实是有"),s("strong",[t._v("矛盾")]),t._v("的, 以至于 HTTP/1.x 时代, "),s("strong",[t._v("大量短而小的 TCP 连接导致了网络性能的瓶颈")]),t._v(".")]),t._v(" "),s("p",[t._v('为了缓解 HTTP 与 TCP 之间的矛盾, 开发者们一方面致力于减少发出的请求数量, 另一方面也致力于增加客户端到服务端的连接数量, 这就是上面 Yslow 规则中 "减少请求数量" 与 "扩大并发请求数" 两条优化措施的根本依据所在.')]),t._v(" "),s("p",[t._v("在另一方面, HTTP 的设计者们并不是没有尝试过在协议层面去解决连接成本过高的问题, 即使 HTTP 协议的最初版本(指 HTTP/1.0) 就已经支持了"),s("strong",[t._v("连接复用技术")]),t._v(", 即今天大家所熟知的"),s("strong",[t._v("持久连接")]),t._v("(Persistent Connection), 也称为"),s("strong",[t._v("连接 Keep-Alive 机制")]),t._v(". 持久连接的原理是让"),s("strong",[t._v("客户端对同一个域名长期持有一个或多个不会用完即断的 TCP 连接")]),t._v(". 典型做法是在客户端维护一个 FIFO 队列, 在每次"),s("strong",[t._v("取完数据之后一段时间内先不自动断开连接")]),t._v(", 以便在获取下一个资源时直接复用, 避免创建 TCP 连接的成本.")]),t._v(" "),s("p",[t._v('但是, 连接复用技术依然是不完美的, 最明显的副作用是 "'),s("strong",[t._v("队首阻塞")]),t._v('"(Head-of-Line Blocking)问题. 请设想以下场景: 浏览器有 10 个资源需要从服务器中获取, 此时它将 10 个资源放入队列, 入列顺序只能按照浏览器遇见这些资源的先后顺序来决定. 但如果这 10 个资源中的第 1 个就让服务器陷入长时间运算状态会怎样呢? 当它的请求被发送到服务端之后, 服务端开始计算, 而运算结果出来之前 TCP 连接中并没有任何数据返回, 此时后面 9 个资源都必须'),s("strong",[t._v("阻塞等待")]),t._v(". 因为服务端虽然可以并行处理另外 9 个请求(譬如第 1 个是复杂运算请求, 消耗 CPU 资源, 第 2 个是数据库访问, 消耗数据库资源, 第 3 个是访问某张图片, 消耗磁盘 I/O 资源, 这就很适合并行), 但问题是处理结果无法及时返回客户端, 服务端不能因为哪个请求先完成就返回哪个, 更不可能将所有要返回的资源混杂到一起交叉传输, 原因是"),s("strong",[t._v("只使用一个 TCP 连接")]),t._v("来传输多个资源的话, 如果顺序乱了, 客户端就很难区分哪个数据包归属哪个资源了.")]),t._v(" "),s("p",[t._v('2014 年, IETF 发布的 RFC 7230 中提出了名为 "'),s("strong",[t._v("HTTP管道")]),t._v('"(HTTP Pipelining) 的复用技术, 试图在 HTTP 服务器中也建立类似客户端的 FIFO 队列, 让客户端一次将所有要请求的资源名单全部发给服务端, 由服务端来安排返回顺序, 管理传输队列. 无论队列维护在服务端还是客户端, 其实都无法完全避免队首阻塞的问题, 但由于服务端能够较为准确地评估资源消耗情况, 进而能够更紧凑地安排资源传输, 保证队列中两项工作之间尽量减少空隙, 甚至做到并行化传输, 从而提升链路传输的效率. 可是, 由于 HTTP 管道需要多方共同支持, 协调起来相当复杂, '),s("strong",[t._v("推广得并不算成功")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("队首阻塞问题一直持续到第二代的 HTTP 协议")]),t._v(", 即 HTTP/2 发布后才算是被比较完美地解决. 在 HTTP/1.x 中, "),s("strong",[t._v("HTTP 请求就是传输过程中最小粒度的信息单位")]),t._v("了, 所以如果将多个请求切碎, 再混杂在一块传输, 客户端势必难以分辨, 重组出有效信息. 而在 HTTP/2 中, "),s("strong",[t._v("帧(Frame) 才是最小粒度的信息单位")]),t._v(", 它可以用来描述各种数据, 譬如请求的 Headers, Body, 或用来做控制标识, 譬如打开流, 关闭流. 这里说的流(Stream)是一个逻辑上的"),s("strong",[t._v("数据通道")]),t._v("概念, "),s("strong",[t._v("每个帧都附带一个流 ID 以标识这个帧属于哪个流")]),t._v(". 这样, "),s("strong",[t._v("在同一个 TCP 连接中传输的多个数据帧就可以根据流 ID 轻易区分开来, 在客户端毫不费力地将不同流中的数据重组出不同 HTTP 请求和响应报文来")]),t._v(". 这项设计是 HTTP/2 的最重要的技术特征一, 被称为 "),s("strong",[t._v("HTTP/2 多路复用")]),t._v("(HTTP/2 Multiplexing)技术.")]),t._v(" "),s("p",[t._v("有了多路复用的支持, "),s("strong",[t._v("HTTP/2 就可以对每个域名只维持一个 TCP 连接")]),t._v("(One Connection Per Origin) 并以"),s("strong",[t._v("任意顺序传输任意数量的资源")]),t._v("了, 这样可以减轻服务器的连接压力. 更重要的是, 没有 TCP 连接数的压力, 就无须刻意压缩 HTTP 请求, 所有通过合并, 内联文件(无论是图片, 样式, 脚本)以减少请求数的需求"),s("strong",[t._v("都不再成立")]),t._v(", 甚至会被当作徒增副作用的反模式.")]),t._v(" "),s("p",[t._v("也有人认为 HTTP 请求少一些总是好的, 减少请求数量, 最起码也减少了传输中耗费的 Header. 这里必须先承认一个事实, 在 HTTP 传输中的 Header 占传输成本的"),s("strong",[t._v("比重是相当大")]),t._v("的, 对于许多小资源, 甚至可能出现 Header 的容量比 Body 还要大, 以至于在 HTTP/2 中必须专门考虑如何进行 Header 压缩的问题. 但是, 以下几个因素决定了通过合并资源文件减少请求数, 对节省 Header 成本并没有太大帮助.")]),t._v(" "),s("ul",[s("li",[t._v("Header 的传输成本在 Ajax(尤其是只返回少量数据的请求)请求中是比重很大的开销, 但在图片, 样式, 脚本这些静态资源的请求中, 通常并不占主要地位.")]),t._v(" "),s("li",[t._v("在 HTTP/2 中 Header 压缩的原理是基于"),s("strong",[t._v("字典编码的信息复用")]),t._v(". 简而言之, 同一个连接上产生的请求和响应越多, 动态字典积累得越全, 头部压缩效果也就越好. 所以 HTTP/2 是单域名单连接的机制, 合并资源和域名分片"),s("strong",[t._v("反而不利于提升 Header 压缩效果")]),t._v(".")]),t._v(" "),s("li",[t._v("与 HTTP/1.x 相比, HTTP/2 本身变得"),s("strong",[t._v("更适合传输小资源")]),t._v(", 譬如传输 1000 张 10KB 的小图, HTTP/2 肯定要比 HTTP/1.x 快, 但传输 10 张 1000KB 的大图, 则大概率 HTTP/1.x 会更快些. 这是 TCP 连接数量(相当于多点下载)的影响, 但更多是由 TCP 协议可靠传输机制导致的, "),s("strong",[t._v("一个错误的 TCP 包会导致所有的流都必须等待这个包重传成功")]),t._v(", 这是 HTTP/3 要解决的问题. 因此, 把小文件合并成大文件, 在 HTTP/2 下是毫无益处的.")])]),t._v(" "),s("h5",{attrs:{id:"_2-传输压缩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-传输压缩"}},[t._v("#")]),t._v(" 2.传输压缩")]),t._v(" "),s("p",[t._v("这里讨论传输链路中的压缩. 同时也是为了解决上一节的问题: 如何不以断开 TCP 连接为标志来判断资源已传输完毕.")]),t._v(" "),s("p",[t._v("HTTP 很早就支持了 "),s("strong",[t._v("GZip 压缩")]),t._v(", 因为 HTTP 传输的内容主要是文本数据, 譬如 HTML, CSS, Script 等, 而对于文本数据启用压缩的收益是非常高的, 传输数据量一般会降至原有的 20% 左右. 对于那些"),s("strong",[t._v("不适合压缩")]),t._v("的资源, Web 服务器能根据 MIME 类型自动判断是否对响应进行压缩, 这样, 已经采用过压缩算法存储的资源, 如 JPEG, PNG 图片, 便"),s("strong",[t._v("不会被二次压缩")]),t._v(", 空耗性能.")]),t._v(" "),s("p",[t._v("不过, 大概就没有多少人想过"),s("strong",[t._v("压缩与之前提到的用于节约 TCP 的持久连接机制是存在冲突的")]),t._v('. 现代的 Web 服务器处理能力有了大幅提升, 都是由服务器对符合条件的请求在输出时进行 "'),s("strong",[t._v("即时压缩")]),t._v('"(On-The-Fly Compression), 整个压缩过程全部在内存的数据流中完成, 不必等资源压缩完成再返回响应, 这样可以显著提高 "首字节时间"(Time To First Byte, TTFB), 改善 Web 性能体验. 而这个过程中唯一不好的地方就是服务器再也'),s("strong",[t._v("没有办法给出 Content-Length 这个响应 Header")]),t._v(" 了, 因为输出 Header 时服务器还不知道压缩后资源的确切大小.")]),t._v(" "),s("p",[t._v("到这里, 大家了解即时压缩与持久连接的冲突在哪了吗? "),s("strong",[t._v("持久连接机制不再依靠 TCP 连接是否关闭来判断资源请求是否结束, 它会重用同一个连接以便向同一个域名请求多个资源, 这样客户端就必须要有除了关闭连接之外的其他机制来判断一个资源什么时候算传递完毕")]),t._v(", 这个机制最初(在 HTTP/1.0 时)就只有 Content-Length, 即依靠请求 Header 中明确给出资源的"),s("strong",[t._v("长度判断")]),t._v(", 传输到达该长度即宣告一个资源的传输已结束. 由于"),s("strong",[t._v("启用即时压缩后就无法给出 Content-Length")]),t._v(" 了, 如果是 HTTP/1.0 的话, "),s("strong",[t._v("持久连接和即时压缩只能二选一")]),t._v(". 依靠 Content-Length 来判断传输结束的缺陷, 不仅仅在于即时压缩这一种场景, 譬如对于"),s("strong",[t._v("动态内容")]),t._v("(Ajax, PHP, JSP等输出), 服务器也同样无法事先得知 Content-Length.")]),t._v(" "),s("p",[t._v('HTTP/1.1 版本中修复了这个缺陷, 增加了另一种 "'),s("strong",[t._v("分块传输编码")]),t._v('"(Chunked Transfer Encoding) 的资源结束判断机制, 彻底解决了 Content-Length 与持久连接的冲突问题. 分块编码的原理相当简单: 在响应 Header 中加入 "'),s("strong",[t._v("Transfer-Encoding:chunked")]),t._v('" 之后, 就代表这个响应报文将采用'),s("strong",[t._v("分块编码")]),t._v('. 此时, 报文中的 Body 需要改为用一系列 "分块" 来传输. 每个分块包含十六进制的长度值和对应长度的数据内容, 长度值独占一行, 数据从下一行开始, 最后以一个'),s("strong",[t._v("长度值为 0 的分块来表示资源结束")]),t._v(". 举个具体例子:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token response-status"}},[s("span",{pre:!0,attrs:{class:"token http-version property"}},[t._v("HTTP/1.1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token status-code number"}},[t._v("200")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token reason-phrase string"}},[t._v("OK")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Date")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("Sat, 11 Apr 2020 04:44:00 GMT")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Transfer-Encoding")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("chunked")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Connection")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("keep-alive")])]),t._v("\n\n25\nThis is the data in the first chunk\n\n1C\nand this is the second one\n\n3\ncon\n\n8\n\nsequence\n\n0\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br")])]),s("p",[t._v("根据分块长度可知, 前两个分块包含显式的回车换行符(CRLF, 即 \\r\\n 字符).")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[t._v('"This is the data in the first chunk\\r\\n"      (37 字符 => 十六进制: 0x25)\n"and this is the second one\\r\\n"               (28 字符 => 十六进制: 0x1C)\n"con"                                          (3  字符 => 十六进制: 0x03)\n"sequence"                                     (8  字符 => 十六进制: 0x08)\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("所以解码后的内容为:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[t._v("This is the data in the first chunk\nand this is the second one\nconsequence\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("一般来说, Web 服务器给出的数据分块大小应该(但并不强制)是一致的, 而不是如例子中那样随意. "),s("strong",[t._v("HTTP/1.1 通过分块传输解决了即时压缩与持久连接并存的问题")]),t._v(", 到了 HTTP/2, 由于"),s("strong",[t._v("多路复用和单域名单连接的设计, 已经无须再刻意去提持久连接机制")]),t._v("了, 但数据压缩仍然有节约传输带宽的重要价值.")]),t._v(" "),s("h5",{attrs:{id:"_3-快速udp网络连接-http3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-快速udp网络连接-http3"}},[t._v("#")]),t._v(" 3.快速UDP网络连接(HTTP3)")]),t._v(" "),s("p",[t._v("HTTP 是应用层协议, 其设计原本不应该过多地考虑底层的传输细节, 从职责上讲, 持久连接, 多路复用, 分块编码这些能力, 已经或多或少超过了应用层的范畴. 要从根本上改进 HTTP, 必须直接"),s("strong",[t._v("替换掉 HTTP over TCP 的根基")]),t._v(", 即 TCP 传输协议, 这便是"),s("strong",[t._v("最新一代 HTTP/3 协议的设计重点")]),t._v(".")]),t._v(" "),s("p",[t._v('推动替换 TCP 协议的先驱者是 Google. 2013 年, Google 在它的服务器(如 Google.com, YouTube.com 等)及 Chrome 浏览器上同时启用了名为 "'),s("strong",[t._v("快速 UDP 网络连接")]),t._v('"(Quick UDP Internet Connection, '),s("strong",[t._v("QUIC")]),t._v(") 的全新传输协议. 2015 年, Google 将 QUIC 提交给 IETF, 并在 IETF 的推动下对 QUIC 进行重新规范化(为以示区别, 业界习惯将此前的版本称为 gQUIC, 将规范化后的版本称为 iQUIC), 使其"),s("strong",[t._v("不仅能满足 HTTP 传输协议, 日后还能支持 SMTP, DNS, SSH, Telnet, NTP 等多种其他上层协议")]),t._v(". 2018 年末, IETF 正式批准了 "),s("mark",[s("strong",[t._v("HTTP over QUIC")])]),t._v("  使用 "),s("mark",[s("strong",[t._v("HTTP/3")])]),t._v(" 的版本号, 将其确立为最新一代的互联网标准.")]),t._v(" "),s("p",[t._v("从名字上就能看出 QUIC 会"),s("strong",[t._v("以 UDP 协议为基础")]),t._v(", 而 UDP 协议没有丢包自动重传的特性, 因此 QUIC 的"),s("strong",[t._v("可靠传输能力并不是由底层协议提供, 而是完全由自己实现")]),t._v(". 由 QUIC 自己实现的好处是能"),s("strong",[t._v("对每个流做单独的控制")]),t._v(", 如果在一个流中发生错误, 协议栈仍然可以独立地继续为其他流提供服务. 这对提高易出错链路的性能非常有用, 因为在大多数情况下, TCP 协议接到数据包丢失或损坏通知之前, "),s("strong",[t._v("可能已经收到了大量的正确数据, 但是在纠正错误之前, 其他的正常请求都会等待甚至被重发")]),t._v(", 这也是 HTTP/2 "),s("strong",[t._v("未能解决传输大文件慢的根本原因")]),t._v(".")]),t._v(" "),s("p",[t._v("QUIC 的另一个设计目标是"),s("strong",[t._v("面向移动设备")]),t._v("的专门支持, 由于以前 TCP, UDP 传输协议在设计时根本不可能设想到今天移动设备盛行的场景, 因此肯定不会有任何专门的支持. QUIC 在移动设备上的优势体现在"),s("strong",[t._v("网络切换时的响应速度")]),t._v("上, 譬如当移动设备在不同 Wi-Fi 热点之间切换, 或者从 Wi-Fi 切换到移动网络时, 如果使用 TCP 协议, 现存的"),s("strong",[t._v("所有连接都必定会超时, 中断, 然后根据需要重新创建")]),t._v(". 这个过程会带来很高的延迟, 因为超时和重新握手都需要大量时间. 为此, QUIC 提出了"),s("mark",[s("strong",[t._v("连接标识符")])]),t._v("的概念, 该"),s("strong",[t._v("标识符可以唯一地标识客户端与服务器之间的连接, 而无须依靠 IP 地址")]),t._v(". 这样, 切换网络后, 只需向服务端发送一个包含此标识符的数据包即可重用既有的连接, 因为即使用户的 IP 地址发生变化, "),s("strong",[t._v("原始连接的连接标识符依然是有效的")]),t._v(".")]),t._v(" "),s("p",[t._v("无论是 TCP 协议还是 HTTP 协议, 都已经存在了数十年. 它们在积累了大量用户的同时, 也承载了很重的技术惯性, 要使 HTTP 从 TCP 迁移走, 即使由 Google 和 IETF 来推动依然不是一件容易的事情. 一个最显著的问题是互联网"),s("strong",[t._v("基础设施中的许多中间设备")]),t._v(", 都只面向 TCP 协议去建造, 仅对 UDP 提供很基础的支持, 有的甚至完全阻止 UDP 的流量. 因此, Google 在 Chromium 的网络协议栈中"),s("strong",[t._v("同时启用了 QUIC 和传统 TCP 连接, 并在 QUIC 连接失败时以零延迟回退到 TCP 连接")]),t._v(", 尽可能让用户无感知地扩大 QUIC 的使用面.")]),t._v(" "),s("p",[t._v("目前网络链路传输领域正处于新旧交替的时代, 许多既有设备, 程序, 知识都会在未来几年时间里出现重大更新.")]),t._v(" "),s("h4",{attrs:{id:"内容分发网络"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内容分发网络"}},[t._v("#")]),t._v(" 内容分发网络")]),t._v(" "),s("p",[t._v("前几节介绍了客户端缓存, 域名解析, 链路优化, 本节讨论它们的一个经典的综合运用案例: "),s("strong",[t._v("内容分发网络")]),t._v("(Content Distribution Network, CDN).")]),t._v(" "),s("p",[t._v("如果把某个互联网系统比喻为一家企业, 那内容分发网络就是它遍布世界各地的"),s("strong",[t._v("分支销售机构")]),t._v(". 假设现在有客户要买一块 CPU, 那么订机票飞到美国加州 Intel 总部肯定是不合适的, 到本地电脑城找个装机铺才是通常的做法, 在此场景中, 内容分发网络就相当于电脑城里的本地经销商.")]),t._v(" "),s("p",[t._v("内容分发网络是一种十分"),s("strong",[t._v("透明")]),t._v("的应用.")]),t._v(" "),s("p",[t._v("如果抛却其他影响服务质量的因素, 仅从网络传输的角度看, 一个互联网系统的"),s("strong",[t._v("速度")]),t._v("取决于以下四个因素.")]),t._v(" "),s("ul",[s("li",[t._v("网站服务器接入网络运营商的链路所能提供的出口带宽.")]),t._v(" "),s("li",[t._v("用户客户端接入网络运营商的链路所能提供的入口带宽.")]),t._v(" "),s("li",[t._v("从网站到用户经过的不同运营商之间的互联节点的带宽, 一般来说两个运营商之间只有固定的若干个点是互通的, 所有跨运营商之间的交互都要经过这些点.")]),t._v(" "),s("li",[t._v("从网站到用户的物理链路传输时延. 爱打游戏的读者应该都清楚, 延迟(Ping值)比带宽更重要.")])]),t._v(" "),s("p",[t._v("以上四个因素, 除了第二个只能通过换一个更好的宽带才能改善之外, "),s("strong",[t._v("其余三个都能通过内容分发网络来显著改善")]),t._v(". 一个运作良好的内容分发网络, 能为互联网系统解决跨运营商, 跨地域物理距离所导致的时延问题, 能为网站流量带宽起到分流, 减负的作用.")]),t._v(" "),s("p",[t._v('举个例子, 如果不是有遍布全国乃至全世界的阿里云 CDN 网络支持, 哪怕把杭州所有带宽全部让给淘宝的机房, 恐怕也撑不住全国乃至全球用户在双十一期间的疯狂"围殴".')]),t._v(" "),s("p",[t._v("内容分发网络的工作过程, 主要涉及"),s("strong",[t._v("路由解析, 内容分发, 负载均衡和 CDN 应用")]),t._v("四个方面, 由于下一节会专门讨论负载均衡的内容, 所以这部分在本节暂不涉及, 下面逐一了解其余三个方面.")]),t._v(" "),s("h5",{attrs:{id:"_1-路由解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-路由解析"}},[t._v("#")]),t._v(" 1.路由解析")]),t._v(" "),s("p",[t._v('DNS 域名解析时, 翻译域名无须像查电话本一样刻板地一对一翻译, 根据来访机器, 网络链路, 服务内容等各种信息, 可以玩出很多"花样", '),s("strong",[t._v("内容分发网络将用户请求路由到它的资源服务器上就是依靠 DNS 服务器来实现的")]),t._v(".")]),t._v(" "),s("p",[t._v("一次"),s("strong",[t._v("没有")]),t._v("内容分发网络参与的用户访问, 其解析过程如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221119131342973.png",alt:"",title:"没有CDN参与的DNS解析过程"}})]),t._v(" "),s("p",[t._v('那么, 有内容分发网络介入会发生什么变化呢? 这里先看一段对网站 "nano.cn." 进行 DNS 查询的真实'),s("strong",[t._v("应答记录")]),t._v(", 这个网站就是通过国内的内容分发网络对位于 GitHub Pages 上的静态页面进行加速的. 通过 dig 或 host 命令, 能够很方便地得到 DNS 服务器的返回结果(结果中头 4 个 IP 的城市地址是手工加入的, 后面的其他记录就不一个一个查了), 如下所示:")]),t._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dig")]),t._v(" nano.cn\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" DiG "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9.11")]),t._v(".3-1ubuntu1.8-Ubuntu "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" nano.cn\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" global options: +cmd\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" Got answer:\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" -"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v("HEADER"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<-")]),t._v(" opcode: QUERY, status: NOERROR, id: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60630")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" flags: qr rd ra"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" QUERY: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(", ANSWER: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("17")]),t._v(", AUTHORITY: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(", ADDITIONAL: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" OPT PSEUDOSECTION:\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" EDNS: version: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(", flags:"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" udp: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("65494")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" QUESTION SECTION:\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("nano.cn.                   IN      A\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" ANSWER SECTION:\nnano.cn.            "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("600")]),t._v("     IN      CNAME   nano.cn.cdn.dnsv1.com.\nnano.cn.cdn.dnsv1.com. "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("599")]),t._v("  IN      CNAME   4yi4q4z6.dispatch.spcdntip.com.\n4yi4q4z6.dispatch.spcdntip.com.  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" IN  A  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("101.71")]),t._v(".72.192  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 浙江宁波市")]),t._v("\n4yi4q4z6.dispatch.spcdntip.com.  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" IN  A  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("113.200")]),t._v(".16.234 "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 陕西省榆林市")]),t._v("\n4yi4q4z6.dispatch.spcdntip.com.  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" IN  A  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("116.95")]),t._v(".25.196  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 内蒙古自治区呼和浩特市")]),t._v("\n4yi4q4z6.dispatch.spcdntip.com.  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" IN  A  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("116.178")]),t._v(".66.65  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 新疆维吾尔自治区乌鲁木齐市")]),t._v("\n4yi4q4z6.dispatch.spcdntip.com.  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" IN  A  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("118.212")]),t._v(".234.144\n4yi4q4z6.dispatch.spcdntip.com.  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" IN  A  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("211.91")]),t._v(".160.228\n4yi4q4z6.dispatch.spcdntip.com.  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" IN  A  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("211.97")]),t._v(".73.224\n4yi4q4z6.dispatch.spcdntip.com.  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" IN  A  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("218.11")]),t._v(".8.232\n4yi4q4z6.dispatch.spcdntip.com.  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" IN  A  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("221.204")]),t._v(".166.70\n4yi4q4z6.dispatch.spcdntip.com.  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" IN  A  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("14.204")]),t._v(".74.140\n4yi4q4z6.dispatch.spcdntip.com.  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" IN  A  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("43.242")]),t._v(".166.88\n4yi4q4z6.dispatch.spcdntip.com.  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" IN  A  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("59.80")]),t._v(".39.110\n4yi4q4z6.dispatch.spcdntip.com.  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" IN  A  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("59.83")]),t._v(".204.12\n4yi4q4z6.dispatch.spcdntip.com.  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" IN  A  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("59.83")]),t._v(".204.14\n4yi4q4z6.dispatch.spcdntip.com.  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" IN  A  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("59.83")]),t._v(".218.235\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" Query time: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("74")]),t._v(" msec\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" SERVER: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("127.0")]),t._v(".0.53"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#53(127.0.0.53)")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" WHEN: Sat Apr "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("22")]),t._v(":33:56 CST "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2020")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" MSG SIZE  rcvd: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("152")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br"),s("span",{staticClass:"line-number"},[t._v("25")]),s("br"),s("span",{staticClass:"line-number"},[t._v("26")]),s("br"),s("span",{staticClass:"line-number"},[t._v("27")]),s("br"),s("span",{staticClass:"line-number"},[t._v("28")]),s("br"),s("span",{staticClass:"line-number"},[t._v("29")]),s("br"),s("span",{staticClass:"line-number"},[t._v("30")]),s("br"),s("span",{staticClass:"line-number"},[t._v("31")]),s("br"),s("span",{staticClass:"line-number"},[t._v("32")]),s("br"),s("span",{staticClass:"line-number"},[t._v("33")]),s("br"),s("span",{staticClass:"line-number"},[t._v("34")]),s("br"),s("span",{staticClass:"line-number"},[t._v("35")]),s("br"),s("span",{staticClass:"line-number"},[t._v("36")]),s("br")])]),s("p",[t._v('根据以上解析信息, DNS 服务为 "nano.cn." 的查询结果先返回了一个 '),s("strong",[t._v("CNAME 记录")]),t._v("(nano.cn.cdn.dnsv1.com.), 递归查询该 CNAME 时, 返回了另一个看起来更奇怪的 CNAME(4yi4q4z6.dispatch.spcdntip.com.). 继续查询后, 这个 CNAME 返回了"),s("strong",[t._v("十几个")]),t._v("位于全国不同地区的 A 记录, 很明显, 这些 A 记录就是分布在全国各地, 存有本站缓存的 CDN 节点.")]),t._v(" "),s("p",[t._v("CDN 路由解析的具体工作流程如下.")]),t._v(" "),s("ul",[s("li",[t._v('架设好 "nano.cn." 的服务器后, 在 CDN 服务商上将服务器的 IP 地址注册为 "'),s("strong",[t._v("源站")]),t._v('", 注册后会得到一个 '),s("strong",[t._v("CNAME")]),t._v(', 即本例中的 "nano.cn.cdn.dnsv1.com.".')]),t._v(" "),s("li",[t._v("在购买域名的 DNS 服务商上将得到的 CNAME "),s("strong",[t._v("注册为一条 CNAME 记录")]),t._v(".")]),t._v(" "),s("li",[t._v("当第一位用户来访时, 将首先发生一次未命中缓存的 DNS 查询, "),s("strong",[t._v("域名服务商解析出 CNAME 后")]),t._v(", 返回给本地 DNS, 之后链路解析的"),s("strong",[t._v("主导权就开始由内容分发网络")]),t._v("的调度服务接管了.")]),t._v(" "),s("li",[t._v("本地 DNS 查询 CNAME 时, 由于"),s("strong",[t._v("能解析该 CNAME 的权威服务器只有 CDN 服务商所架设的权威 DNS, 这个 DNS 服务将根据一定的均衡策略和参数")]),t._v(", 如拓扑结构, 容量, 时延等, 在全国各地能提供服务的 CDN 缓存节点中挑选一个最适合的, 并将它的 IP 代替源站的 IP 地址, 返回给本地 DNS.")]),t._v(" "),s("li",[t._v("浏览器从本地 DNS 拿到 IP 地址后, "),s("strong",[t._v("将该 IP 当作源站服务器")]),t._v("来进行访问, 此时该 IP 的 CDN 节点上可能有, 也可能没有缓存过源站的资源.")]),t._v(" "),s("li",[t._v("经过"),s("strong",[t._v("内容分发后的 CDN 节点")]),t._v(", 就有能力代替源站向用户提供所请求的资源了.")])]),t._v(" "),s("p",[t._v("以上步骤的时序图如下.")]),t._v(" "),s("p",[t._v("​"),s("img",{attrs:{src:"/img/%E9%80%8F%E6%98%8E%E5%A4%9A%E7%BA%A7%E5%88%86%E6%B5%81%E7%B3%BB%E7%BB%9F-%E6%9C%89%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C%E5%8F%82%E4%B8%8E%E7%9A%84%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B--20230212200030-hq0vrxu.png",alt:"透明多级分流系统-有内容分发网络参与的用户访问的解析过程-",title:"有CDN的DNS解析过程"}}),t._v("​")]),t._v(" "),s("h5",{attrs:{id:"_2-内容分发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-内容分发"}},[t._v("#")]),t._v(" 2.内容分发")]),t._v(" "),s("p",[t._v("在 DNS 服务器的协助下, 无论是对用户还是服务器, 内容分发网络都可以是"),s("strong",[t._v("完全透明")]),t._v("的, 如在两者都不知情的情况下, "),s("strong",[t._v("由 CDN 的缓存节点接管了用户向服务器发出资源请求")]),t._v(".")]),t._v(" "),s("p",[t._v("后面随之而来的问题是"),s("strong",[t._v("缓存节点中必须有用户想要请求的资源副本")]),t._v(', 才可能代替源站来响应用户请求. 这里面又包括两个子问题: "'),s("strong",[t._v("如何获取源站资源")]),t._v('"和"如何管理(更新)资源(保证一致性)". '),s("strong",[t._v('CDN 获取源站资源的过程被称为 "内容分发"')]),t._v(' , "内容分发网络"的名字正是由此而来, 这也是 CDN 的核心价值.')]),t._v(" "),s("p",[t._v("目前主要有以下两种主流的内容分发方式.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("主动分发")]),t._v("(Push): 分发由"),s("strong",[t._v("源站主动发起")]),t._v(", 将内容从源站或其他资源库"),s("strong",[t._v("推送")]),t._v("到用户边缘的各个 CDN 缓存节点上. 这个推送的操作没有什么业界标准可循, 可以选择任何传输方式(HTTP, FTP, P2P, 等等), 任何推送策略(满足特定条件, 定时, 人工, 等等), 任何推送时间, 只要与后面说的更新策略相匹配即可. 由于主动分发通常需要源站, CDN 服务双方提供程序 API 接口层面的配合, 所以它对源站并不是透明的, 只对用户一侧单向透明. "),s("strong",[t._v("主动分发一般用于网站要预载大量资源的场景")]),t._v(". 譬如在双十一之前的一段时间内, 淘宝, 京东等各个网络商城会把未来活动中所要用到的资源推送到 CDN 缓存节点中, 特别常用的资源甚至会直接缓存到你的手机 App 的存储空间或浏览器的 localStorage 上.")]),t._v(" "),s("li",[s("strong",[t._v("被动回源")]),t._v("(Pull): 被动回源由"),s("strong",[t._v("用户访问所触发")]),t._v(", 是全自动, "),s("strong",[t._v("双向透明")]),t._v("的资源缓存过程. 当某个资源首次被用户请求的时候, 若 CDN 缓存节点"),s("strong",[t._v("发现自己没有该资源")]),t._v(", 就会"),s("strong",[t._v("实时从源站中获取, 这时资源的响应时间可粗略认为是资源从源站到 CDN 缓存节点的时间, 加上资源从 CDN 发送到用户的时间之和")]),t._v(". 因此, 被动回源的"),s("strong",[t._v("首次访问")]),t._v("通常比较慢(但由于 CDN 的网络条件一般远高于普通用户, 并不一定比用户直接访问源站更慢), 不适合应用于数据量较大的资源. 被动回源的优点是可以做到完全的双向透明, 不需要源站在程序上做任何配合, 使用起来非常方便. 这种分发方式是小型站点使用 CDN 服务的主流选择, 如果不是自建 CDN, 而是购买阿里云, 腾讯云的 CDN 服务的站点, 多数采用的就是这种方式.")])]),t._v(" "),s("p",[t._v('对于 "CDN 如何管理(更新)资源 "这个问题, 同样没有统一的标准可言, 尽管在 HTTP 协议中, 关于缓存的 Header 定义中确实有对 CDN 这类共享缓存的一些指引性参数的定义, 譬如 Cache-Control 的 s-maxage, 但是否要遵循, 完全'),s("strong",[t._v("取决于 CDN 本身的实现策略")]),t._v(". 因此, 对 CDN 缓存的管理不存在通用的准则.")]),t._v(" "),s("p",[t._v("现在, 最常见的做法是"),s("strong",[t._v("超时被动失效与手工主动失效相结合")]),t._v(". 超时被动失效是指给予"),s("strong",[t._v("缓存资源一定的生存期")]),t._v(", 超过了生存期就在下次请求时"),s("strong",[t._v("重新被动回源一次")]),t._v(". 而手工主动失效是指 CDN 服务商一般会提供"),s("strong",[t._v("处理失效缓存的接口")]),t._v(", 在网站更新时, 由持续集成的流水线自动调用该接口来实现缓存更新.")]),t._v(" "),s("h5",{attrs:{id:"_3-cdn应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-cdn应用"}},[t._v("#")]),t._v(" 3.CDN应用")]),t._v(" "),s("p",[t._v("CDN 最初是为了"),s("strong",[t._v("快速分发静态资源")]),t._v("而设计的, 但今天的 CDN 所能做的事情已经远远超越了最初的目标, 限于这部分应用太多, 无法展开逐一细说, 这里只能对现在 CDN 可以做的事情简要列举.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("加速静态资源分发")]),t._v(": 这是 CDN 的本职工作. 如图片或一些前端的静态资源可以放到 CDN 中.")]),t._v(" "),s("li",[s("strong",[t._v("安全防御")]),t._v(": CDN 在广义上可以视作网站的堡垒机, 源站只对 CDN 提供服务, 由 CDN 来对外界其他用户提供服务, 这样恶意攻击者就不容易直接威胁源站. CDN 对某些攻击手段的防御, 如对 DDoS 攻击的防御尤其有效. 但需注意, 将安全都寄托在 CDN 上本身是不安全的, 一旦源站真实 IP 被泄漏, 就会面临很高的风险.")]),t._v(" "),s("li",[s("strong",[t._v("协议升级")]),t._v(": 不少 CDN 提供商都同时对接(代售 CA 的)SSL 证书服务, 可以实现源站是基于 HTTP 协议的, 而"),s("strong",[t._v("对外开放的网站是基于 HTTPS")]),t._v(" 的. 同理, 可以实现源站到 CDN 是 HTTP/1.x 协议, CDN 提供的外部服务是 HTTP/2 或 HTTP/3 协议; 实现源站是基于 IPv4 网络的, CDN 提供的外部服务支持 IPv6 网络, 等等.")]),t._v(" "),s("li",[s("strong",[t._v("状态缓存")]),t._v(": CDN 不仅可以缓存源站的资源, 还可以缓存源站的状态, 譬如可以通过 CDN 缓存源站的 301/302 状态让客户端直接跳转, 也可以通过 CDN 开启 HSTS, 通过 CDN 进行 OCSP 装订加速 SSL 证书访问, 等等. 有一些情况下甚至可以配置 CDN 对任意状态码(譬如404) 进行一定时间的缓存, 以减轻源站压力, 但这个操作应当慎重, 且在网站状态发生改变时要及时刷新缓存.")]),t._v(" "),s("li",[s("strong",[t._v("修改资源")]),t._v(": CDN 可以在返回资源给用户的时候"),s("strong",[t._v("修改资源")]),t._v("的任何内容, 以实现不同的目的. 譬如, 可以对源站未压缩的资源自动压缩并修改 Content-Encoding, 以节省用户的网络带宽消耗, 可以对源站未启用客户端缓存的内容加上缓存 Header, 自动启用客户端缓存, 可以修改 CORS 的相关 Header, 为源站不支持跨域的资源提供跨域能力, 等等.")]),t._v(" "),s("li",[s("strong",[t._v("访问控制")]),t._v(": CDN 可以实现 IP 黑/白名单功能, 如根据不同的来访 IP 提供不同的响应结果, 根据 IP 的访问流量来实现 QoS 控制, 根据 HTTP 的 Referer 来实现防盗链, 等等.")]),t._v(" "),s("li",[s("strong",[t._v("注入功能")]),t._v(": CDN 可以在不修改源站代码的前提下, 为源站注入各种功能.")])]),t._v(" "),s("h4",{attrs:{id:"负载均衡"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡"}},[t._v("#")]),t._v(" 负载均衡")]),t._v(" "),s("p",[t._v("在互联网时代的早期, 网站流量还相对较小, 业务也相对简单, 单台服务器便可满足访问需要, 但现在一般实际用于生产的系统, 几乎都离不开集群部署. 信息系统不论是单体架构多副本还是微服务架构, 不论是为了实现高可用还是为了获得高性能, 都需要"),s("strong",[t._v("利用多台机器来扩展服务能力, 希望用户的请求不管连接到哪台机器上, 都能得到相同的处理")]),t._v(". 另一方面, 如何构建和调度服务集群这件事, 又必须对用户保持足够的"),s("strong",[t._v("透明")]),t._v(', 即使请求背后是由一千台, 一万台机器来共同响应的, 也无须用户关心, 他们只需要记住一个域名地址即可. 调度后方的多台机器, 以统一的接口对外提供服务, 承担此职责的技术组件被称为"'),s("strong",[t._v("负载均衡")]),t._v('"(Load Balancing).')]),t._v(" "),s("p",[t._v("真正大型系统的负载均衡过程往往是"),s("strong",[t._v("多级")]),t._v('的. 譬如, 在各地建有多个机房, 或机房有不同网络链路入口的大型互联网站, 会从 DNS 解析开始, 通过 "域名" -> "CNAME" -> "负载调度服务" -> "就近的数据中心入口" 的路径, 先将来访地用户根据 IP 地址(或其他条件)分配到一个合适的数据中心中, 然后才到各式负载均衡. 在 DNS 层面的负载均衡与 DNS 智能线路, 内容分发网络等在工作原理上是类似的, 差别只是数据中心能提供的不只是缓存, 而是全方位的服务能力. 由于这种方式此前已经详细讲解过, 后续讨论的"负载均衡"就只聚焦于'),s("strong",[t._v("网络请求进入数据中心入口之后")]),t._v("的其他级次的负载均衡.")]),t._v(" "),s("p",[t._v("无论在网关内部建立了多少级的负载均衡, 从形式上来说都可以分为两种: "),s("strong",[t._v("四层负载均衡和七层负载均衡")]),t._v(". 在详细介绍它们是什么以及如何工作之前, 先来建立两个总体的印象.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("四层负载均衡的优势是性能高, 七层负载均衡的优势是功能强")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("做多级混合负载均衡, 通常应是低层负载均衡在前, 高层负载均衡在后")]),t._v(".")])]),t._v(" "),s("p",[t._v('这里所说的 "四层", "七层" 指的是经典的 '),s("strong",[t._v("OSI 七层模型中的第四层传输层和第七层应用层")]),t._v(". 可以参考网络相关内容.")]),t._v(" "),s("p",[t._v('现在所说的 "'),s("strong",[t._v("四层负载均衡")]),t._v('" 其实是'),s("strong",[t._v("多种均衡器工作模式")]),t._v("的统称,  "),s("strong",[t._v('"四层" 是说这些工作模式的共同特点是')]),t._v("​"),s("mark",[s("strong",[t._v("维持同一个 TCP 连接")])]),t._v("​ "),s("strong",[t._v(", 而不是说它只工作在第四层")]),t._v(". 事实上, 这些模式主要都工作在"),s("strong",[t._v("第二层")]),t._v("(数据链路层, "),s("strong",[t._v("改写 MAC 地址")]),t._v(")和"),s("strong",[t._v("第三层")]),t._v("(网络层, "),s("strong",[t._v("改写 IP 地址")]),t._v(")上, 单纯只处理第四层(传输层, 可以改写 TCP, UDP 等协议的内容和端口)的数据无法做到负载均衡的转发, 因为 OSI 的下三层是媒体层(Media Layer), 上四层是"),s("strong",[t._v("主机层")]),t._v("(Host Layer), 既然"),s("strong",[t._v("流量都已经到达目标主机上了, 也就谈不上什么流量转发, 最多只能做代理")]),t._v('. 但出于习惯和方便, 现在几乎所有的资料都把它们统称为四层负载均衡, 如果在某些资料上看见"二层负载均衡""三层负载均衡"的表述, 应该了解这是在描述它们工作的具体层次, 与这里说的"四层负载均衡"并不是同一类意思.')]),t._v(" "),s("p",[t._v("下面将介绍几种常见的"),s("strong",[t._v("四层负载均衡")]),t._v("的工作模式.")]),t._v(" "),s("h5",{attrs:{id:"_1-数据链路层负载均衡"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据链路层负载均衡"}},[t._v("#")]),t._v(" 1.数据链路层负载均衡")]),t._v(" "),s("p",[t._v("数据链路层传输的内容是"),s("strong",[t._v("数据帧")]),t._v("(Frame), 譬如常见的以太网帧, ADSL 宽带的 PPP 帧等. 这里讨论的上下文里, 目标就是"),s("strong",[t._v("以太网帧")]),t._v(". 以太网帧结构参考网络部分.关于以太网帧结构中的各数据项的含义, 本节中只需注意  "),s("strong",[t._v('"MAC目标地址" 和 "MAC源地址"')]),t._v("  两项即可. "),s("strong",[t._v("由于每一块网卡都有独立的 MAC 地址, 通过以太网帧上的这两个地址可以告诉交换机, 此帧是从连接在交换机上的哪个端口的网卡发出, 送至哪块网卡的")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("数据链路层负载均衡所做的工作, 是")]),t._v("​"),s("mark",[s("strong",[t._v("修改请求的数据帧中的 MAC 目标地址")])]),t._v("​ "),s("strong",[t._v(', 让用户原本发送给负载均衡器的请求的数据帧, 被二层交换机根据新的 MAC 目标地址转发到服务器集群中对应的服务器(后文称为"真实服务器", Real Server)的网卡上, 这样真实服务器就获得了一个原本目标并不是发送给它的数据帧')]),t._v(".")]),t._v(" "),s("p",[t._v("由于二层负载均衡器在转发请求过程中"),s("strong",[t._v("只修改了帧的 MAC 目标地址")]),t._v(", 不涉及更上层协议(没有修改 Payload 的数据), 所以在更上层(第三层)看来, 所有数据都是"),s("strong",[t._v("未曾改变过")]),t._v("的. 由于第三层的数据包, 即 IP 数据包中包含了源(客户端)和目标(均衡器)的 IP 地址, 只有真实服务器保证自己的 IP 地址与数据包中的目标 IP 地址一致, 这个数据包才能被正确处理. 因此, 使用这种负载均衡模式时, "),s("strong",[t._v("需要把真实物理服务器集群中所有机器的虚拟 IP 地址(Virtual IP Address, VIP)配置成与负载均衡器的虚拟 IP 一样, 才能使经均衡器转发后的数据包在真实服务器中顺利地使用")]),t._v(". 也正是因为实际处理请求的真实物理服务器 IP 和数据请求中的目的 IP 是一致的, 所以响应结果就"),s("strong",[t._v("不再需要通过负载均衡器进行地址交换")]),t._v(", 而是可将响应结果的数据包"),s("strong",[t._v("直接从真实服务器返回给用户的客户端")]),t._v(", 避免负载均衡器网卡带宽成为瓶颈, 因此数据链路层负载均衡的"),s("strong",[t._v("效率是相当高")]),t._v("的. 此模式从请求到响应的过程如下所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221119140932762.png",alt:"",title:"数据链路层负载均衡"}})]),t._v(" "),s("p",[t._v("在上述"),s("strong",[t._v("只有请求经过负载均衡器, 而服务的响应无须从负载均衡器原路返回")]),t._v('的工作模式中, 整个请求, 转发, 响应的链路形成了一个 "'),s("strong",[t._v("三角关系")]),t._v('", 所以这种负载均衡模式也常被形象地称为 "'),s("strong",[t._v("三角传输模式")]),t._v('"(Direct Server Return, DSR), 也称为"单臂模式"(Single Legged Mode)或 "直接路由"(Direct Routing).')]),t._v(" "),s("p",[t._v("虽然数据链路层负载均衡的效率很高, 但它并不能适用于所有场合, 除了无法适用于那些需要感知应用层协议信息的负载均衡场景外(所有的四层负载均衡器都无法适用, 具体将在后续介绍七层负载均衡器时一并解释), 它在"),s("strong",[t._v("网络侧")]),t._v("受到的约束也很大. 二层负载均衡器直接改写目标 MAC 地址的工作原理决定了它"),s("strong",[t._v("与真实服务器的通信必须是二层可达")]),t._v("的, 通俗地说就是必须位于"),s("strong",[t._v("同一个子网")]),t._v("当中, 无法跨 VLAN. 所以, 优势(效率高)和劣势(不能跨子网)共同决定了"),s("strong",[t._v("数据链路层负载均衡最适合作为数据中心的第一级均衡设备")]),t._v(", 用来连接其他的下级负载均衡器.")]),t._v(" "),s("h5",{attrs:{id:"_2-网络层负载均衡"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-网络层负载均衡"}},[t._v("#")]),t._v(" 2.网络层负载均衡")]),t._v(" "),s("p",[t._v("OSI七层模型的第三层网络层传输的单位是"),s("strong",[t._v("分组数据包")]),t._v("(Packet), 这是一种在分组交换网络(Packet Switching Network, PSN)中传输的结构化数据单位. 以 IP 协议为例, 一个 IP 数据包由"),s("strong",[t._v("头部")]),t._v("(Header)和"),s("strong",[t._v("荷载")]),t._v("(Payload)两部分组成, Header 的长度最大为 60 字节, 其中包括 20 字节的固定数据和最长不超过 40 字节的可选数据. 分组数据包的具体 Header 格式参考网络部分.")]),t._v(" "),s("p",[t._v("本节只要知道在 IP 分组数据包的 Header 中带有"),s("strong",[t._v("源和目标的 IP 地址")]),t._v("即可. 源和目标 IP 地址说明了数据是从"),s("strong",[t._v("分组交换网络中哪台机器发送到哪台机器")]),t._v("的, 可以沿用与二层改写 MAC 地址相似的思路, 通过"),s("strong",[t._v("改变这里面的 IP 地址")]),t._v("来实现数据包的转发. 具体有两种常见的修改方式.")]),t._v(" "),s("p",[s("strong",[t._v("第一种是保持原数据包不变")]),t._v(", 新创建一个数据包, 把原数据包的 Header 和 Payload 整体作为新数据包的 "),s("strong",[t._v("Payload")]),t._v(", 并在这个新数据包的 Header 中写入真实服务器的 IP 作为目标地址, 然后把它发送出去. 经过三层交换机的转发, 真实服务器收到数据包后, 必须在"),s("strong",[t._v("接收入口处设计一个针对性的拆包机制")]),t._v(', 把由负载均衡器自动添加的那层 Header 扔掉, 还原出原数据包来进行使用. 这样, 真实服务器就同样拿到了一个原本不是发给它(目标 IP 不是它)的数据包, 达到了流量转发的目的. 当时还没有流行起 "禁止套娃" 的梗, 所以设计者将这种"套娃式"的传输称为 "'),s("strong",[t._v("IP隧道")]),t._v('" (IP Tunnel)传输, 也是相当的形象.')]),t._v(" "),s("p",[t._v("尽管因为要封装新的数据包, IP 隧道转发模式的效率比直接路由模式的效率低, 但由于并没有修改原数据包中的任何信息, 所以 IP 隧道转发模式仍然具备"),s("strong",[t._v("三角传输")]),t._v("的特性, 即负载均衡器转发来的请求, 可以由真实服务器去直接应答, 无须经过负载均衡器原路返回. 而且由于 IP 隧道工作在网络层, 所以可以"),s("strong",[t._v("跨越 VLAN")]),t._v(", 因此摆脱了直接路由模式中网络侧的约束. 此模式从请求到响应的过程如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221119144407460.png",alt:"",title:"网络层负载均衡"}})]),t._v(" "),s("p",[t._v('当然, 这种转发模式也有缺点. 第一个缺点是它要求真实服务器必须支持 "IP隧道协议" (IP Encapsulation), 即它得学会'),s("strong",[t._v("自己拆包")]),t._v("扔掉一层 Header, 这个其实并不是什么大问题, 现在几乎所有的 Linux 系统都支持 I P隧道协议. 另外一个缺点是这种模式仍"),s("strong",[t._v("必须通过专门的配置")]),t._v(', 必须保证所有的真实服务器与负载均衡器有相同的虚拟 IP 地址, 因为回复该数据包时, 需要使用这个虚拟 IP 作为响应数据包的源地址, 这样客户端收到这个数据包时才能正确解析. 这个限制就相对麻烦一些, 它与 "透明" 的原则冲突, 需由系统管理员介入.')]),t._v(" "),s("p",[t._v("而且, 对服务器进行虚拟 IP 的配置并不是在任何情况下都可行的, 尤其是当几个服务"),s("strong",[t._v("共用一台物理服务器")]),t._v("的时候, 此时就必须考虑第二种修改方式---"),s("strong",[t._v("改变目标数据包")]),t._v(": 直接修改数据包 Header 中的"),s("strong",[t._v("目标地址")]),t._v(", 修改后原本由用户发给负载均衡器的数据包也会被三层交换机转发到真实服务器的网卡上, 而且因为没有经过IP隧道的额外包装, 也就"),s("strong",[t._v("无须再拆包")]),t._v("了. 但问题是这种模式是通过修改目标 IP 地址才到达真实服务器的, 如果真实服务器直接将应答包返回客户端, 即这个应答数据包的源 IP 是真实服务器的 IP, 也即均衡器修改以后的 IP 地址, 则客户端"),s("strong",[t._v("不可能认识该 IP")]),t._v(", 自然就无法正常处理这个应答了. 因此, "),s("strong",[t._v("只有让应答流量继续回到负载均衡器")]),t._v(", 由负载均衡器把应答包的源 IP "),s("strong",[t._v("改回自己的 IP")]),t._v(', 再发给客户端, 才能保证客户端与真实服务器之间的正常通信. 这种处理类似在家里, 公司, 学校上网时, 由一台路由器带着一群内网机器上网的"'),s("strong",[t._v("网络地址转换")]),t._v('"(Network Address Translation, NAT)操作. 这种负载均衡模式的确被称为 '),s("strong",[t._v("NAT 模式")]),t._v(", 此时负载均衡器就相当于家里, 公司, 学校的上网"),s("strong",[t._v("路由器")]),t._v(". 对 NAT 模式的负载均衡器的运维十分简单, 只要机器将自己的网关地址设置为均衡器地址, 就无须再进行任何额外设置了. 此模式从请求到响应的过程如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221119170651069.png",alt:""}})]),t._v(" "),s("p",[t._v("在流量压力比较大的时候, NAT 模式的负载均衡会带来较大的"),s("strong",[t._v("性能损失")]),t._v(", 比起直接路由和 IP 隧道模式, 甚至会出现数量级上的下降. 这点是显而易见的, 由负载均衡器代表整个服务集群来进行应答, 各个服务器的响应数据都会互相争抢均衡器的出口带宽, 这就与在家里用 NAT 上网, 若有人在下载, 打游戏可能会觉得卡顿是一个道理, 此时整个系统的"),s("strong",[t._v("瓶颈很容易就出现在负载均衡器")]),t._v("上.")]),t._v(" "),s("p",[s("strong",[t._v("还有一种更加彻底的 NAT 模式")]),t._v(": 即负载均衡器在转发时, 不仅会修改目标 IP 地址, 还会"),s("strong",[t._v("修改源  IP 地址")]),t._v(", 这样源地址就改成负载均衡器自己的 IP, 称作 Source NAT(SNAT). 这样做的好处是真实服务器无须配置网关就能够让应答流量经过正常的三层路由回到负载均衡器上, 做到彻底的透明. 但是缺点是由于做了 SNAT, 真实服务器处理请求时就无法拿到客户端的 IP 地址, 从真实服务器的视角来看, 所有的流量都来自于负载均衡器, 这样有一些需要根据目标 IP 进行控制的业务逻辑就无法进行了.")]),t._v(" "),s("h5",{attrs:{id:"_3-应用层负载均衡"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-应用层负载均衡"}},[t._v("#")]),t._v(" 3.应用层负载均衡")]),t._v(" "),s("p",[t._v('前面的四层负载均衡工作模式都属于"转发", 即直接将承载着 TCP 报文的底层数据格式(IP 数据包或以太网帧)转发到真实服务器上, 此时'),s("strong",[t._v("客户端与响应请求的真实服务器维持着同一条 TCP 通道")]),t._v(". 但工作在四层之后的负载均衡模式就无法再转发了, 只能"),s("strong",[t._v("代理")]),t._v(", 此时"),s("strong",[t._v("真实服务器, 负载均衡器, 客户端三者之间由两条独立的 TCP 通道来维持通信")]),t._v(". 转发与代理的区别如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221119171812100.png",alt:"",title:"应用层负载均衡"}})]),t._v(" "),s("p",[t._v('"代理" 这个词, 根据 "'),s("strong",[t._v("哪一方能感知到")]),t._v('" 的原则, 可以分为 "正向代理", "反向代理" 和 "透明代理" 三类.')]),t._v(" "),s("p",[s("strong",[t._v("正向代理")]),t._v("就是通常简称的代理, 指在"),s("strong",[t._v("客户端设置")]),t._v("的, 代表客户端与服务器通信的代理服务, 它是"),s("strong",[t._v("客户端可知, 而对服务器透明")]),t._v("的.")]),t._v(" "),s("p",[s("strong",[t._v("反向代理")]),t._v("是指在"),s("strong",[t._v("服务器侧设置")]),t._v("的, 代表真实服务器与客户端通信的代理服务, 此时它"),s("strong",[t._v("对客户端来说是透明的")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("透明代理")]),t._v("则是指对双方都透明的, 配置在网络中间设备上的代理服务, 譬如架设在路由器上的透明翻墙代理.")]),t._v(" "),s("p",[t._v("根据以上定义, 七层负载均衡器属于"),s("strong",[t._v("反向代理")]),t._v("的一种.")]),t._v(" "),s("p",[t._v("如果只论网络性能, 七层负载均衡器肯定比不过四层负载均衡器, 它比四层负载均衡器"),s("strong",[t._v("至少多一轮 TCP 握手")]),t._v(", 有着跟 NAT 转发模式一样的"),s("strong",[t._v("带宽问题")]),t._v(", 而且通常要耗费更多的 CPU, 因为可用的解析规则远比四层丰富. 所以如果用七层负载均衡器去做下载站, 视频站这种流量应用是不合适的, "),s("strong",[t._v("起码不能作为第一级均衡器")]),t._v(". 但是, 如果网站的"),s("strong",[t._v("性能瓶颈不是网络性能")]),t._v(", 而是整个服务集群对外所体现出来的服务性能, 那么七层负载均衡器就有它的用武之地了. 因为"),s("strong",[t._v("七层负载均衡器工作在应用层, 可以感知应用层通信的具体内容, 往往能够做出更明智的决策, 玩出更多的花样")]),t._v(".")]),t._v(" "),s("p",[t._v("举个例子, 四层负载均衡器就像银行的自助排号机, 转发效率高且不知疲倦, 每一个到达银行的客户根据排号机的顺序, 选择对应的窗口接受服务; 而七层负载均衡器就像银行"),s("strong",[t._v("大堂经理")]),t._v(", 他会先确认客户需要办理的业务, 再安排排号. 对于理财, 存取款等业务, 大堂经理会根据银行内部资源进行统一协调处理, 以加快客户业务办理流程; 而对于无须柜台办理的业务, 大堂经理会直接自行处理. 回到七层负载均衡器中, "),s("strong",[t._v("反向代理能够实现静态资源缓存")]),t._v(", 所以对于静态资源的请求, 反向代理会直接返回, 而无须转发到真实服务器.")]),t._v(" "),s("p",[t._v('这里简单列举一些七层代理可以实现的功能, 以便对它的"功能强大"有个直观的感受.')]),t._v(" "),s("ul",[s("li",[t._v("所有 CDN 可以做的缓存方面的工作(CDN 根据物理位置就近返回这类优化链路的工作除外), 七层负载均衡器全都可以实现, 譬如静态资源缓存, 协议升级, 安全防护, 访问控制等等.")]),t._v(" "),s("li",[t._v("七层负载均衡器可以实现"),s("strong",[t._v("更智能化的路由")]),t._v(". 譬如根据 Session 路由, 以实现亲和性的集群; 根据 URL 路由, 实现专职化服务(此时就相当于网关的职责); 甚至根据用户身份路由, 实现对部分用户的特殊服务(如某些站点的贵宾服务器), 等等.")]),t._v(" "),s("li",[t._v("某些安全攻击可以由七层负载均衡器来抵御, 譬如一种常见的 DDoS 手段是 SYN Flood 攻击, 即攻击者控制众多客户端, 使用虚假 IP 地址对同一目标大量发送 SYN 报文. 从技术原理上看, 由于四层负载均衡器"),s("strong",[t._v("无法感知")]),t._v("上层协议的内容, 这些 SYN 攻击都会被转发到后端的真实服务器上; 而七层负载均衡器下这些 SYN 攻击会在负载均衡设备上被"),s("strong",[t._v("过滤掉")]),t._v(", 不会影响到后面服务器的正常运行. 类似地, 可以在七层负载均衡器上设定多种策略, 譬如过滤特定报文, 以防御如 SQL 注入等应用层面的特定攻击手段.")]),t._v(" "),s("li",[t._v("在很多微服务架构的系统中, "),s("strong",[t._v("链路治理")]),t._v("措施都需要在七层中进行, 譬如"),s("strong",[t._v("服务降级, 熔断, 异常注入")]),t._v(", 等等. 譬如, 一台服务器只有出现"),s("strong",[t._v("物理层面或系统层面")]),t._v("的故障, 导致无法应答 TCP 请求时才能被四层负载均衡器感知, 进而被剔除出服务集群. 如果一台服务器能够应答, 只是一直在报 500 错, 那四层负载均衡器对此是完全无能为力的, 只能由七层负载均衡器来解决.")])]),t._v(" "),s("h5",{attrs:{id:"_4-均衡策略与实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-均衡策略与实现"}},[t._v("#")]),t._v(" 4.均衡策略与实现")]),t._v(" "),s("p",[t._v('负载均衡的两大职责是 "选择谁来处理用户请求" 和 "将用户请求转发过去". 前面仅介绍了后者, 即请求的转发或代理过程. 前者是指均衡器所采取的均衡策略, 由于这一块涉及的均衡算法太多, 笔者无法逐一展开, 所以本节仅从功能和应用的角度去介绍一些常见的均衡策略.')]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("轮询均衡")]),t._v("(Round Robin): 每一次来自网络的请求轮流分配给内部的服务器, 从 1 至 N 然后重新开始. 此种均衡算法适合于服务器集群中的所有服务器都有"),s("strong",[t._v("相同的软硬件配置")]),t._v("并且平均服务请求相对均衡的情况.")]),t._v(" "),s("li",[s("strong",[t._v("权重轮询均衡")]),t._v("(Weighted Round Robin): 根据服务器的"),s("strong",[t._v("不同处理能力")]),t._v(", 给每个服务器分配不同的"),s("strong",[t._v("权值")]),t._v(", 使其能够接受相应权值数的服务请求. 譬如: 设置服务器 A 的权值为 1, B 的权值为 3, C 的权值为 6, 则服务器 A, B, C 将分别接收到 10%, 30%, 60% 的服务请求. 此种均衡算法能确保高性能的服务器得到更多的使用率, 避免低性能的服务器负载过重.")]),t._v(" "),s("li",[s("strong",[t._v("随机均衡")]),t._v("(Random): 把来自客户端的请求"),s("strong",[t._v("随机分配")]),t._v("给内部的多个服务器, 在数据量足够大的场景下能达到相对均衡的分布.")]),t._v(" "),s("li",[s("strong",[t._v("权重随机均衡")]),t._v("(Weighted Random): 此种均衡算法类似于权重轮询算法, 不过在分配处理请求时是随机选择的过程.")]),t._v(" "),s("li",[s("strong",[t._v("一致性哈希均衡")]),t._v("(Consistency Hash): 将请求中的某些数据(可以是 "),s("strong",[t._v("MAC, IP")]),t._v(" 地址, 也可以是更上层协议中的某些"),s("strong",[t._v("参数信息")]),t._v(")作为特征值来计算需要落在的节点, "),s("strong",[t._v("算法一般会保证同一个特征值每次都一定落在相同的服务器上")]),t._v(". 这里的一致性是指保证当服务集群某个真实服务器出现故障时, 只影响该服务器的哈希值, 而不会导致整个服务器集群的哈希键值重新分布.")]),t._v(" "),s("li",[s("strong",[t._v("响应速度均衡")]),t._v("(Response Time): 负载均衡设备对内部各服务器发出一个探测请求(例如Ping), 然后根据内部各服务器对探测请求的最快响应时间来决定哪一台服务器响应客户端的服务请求. 此种均衡算法能较好地反映服务器的当前运行状态, 但最快响应时间仅仅指的是负载均衡设备与服务器之间的最快响应时间, 而不是客户端与服务器之间的最快响应时间.")]),t._v(" "),s("li",[s("strong",[t._v("最少连接数均衡")]),t._v("(Least Connection): 客户端的每一次请求服务在服务器停留的时间可能会有较大差异, 随着工作时间增加, 如果采用简单的轮询或随机均衡算法, 每一台服务器上的连接进程可能会产生极大的不平衡, 并不能达到真正的负载均衡. 最少连接数均衡算法会对内部需负载的每一台服务器有一个数据记录, 记录当前该服务器正在处理的"),s("strong",[t._v("连接数量")]),t._v(", 当有新的服务连接请求时, 将把当前请求分配给连接数最少的服务器, 使均衡更加符合实际情况, 使负载更加均衡. 此种均衡策略适合"),s("strong",[t._v("长时处理")]),t._v("的请求服务, 如 FTP 传输.")])]),t._v(" "),s("p",[t._v("从"),s("strong",[t._v("实现")]),t._v('角度来看, 负载均衡器的实现分为 "软件均衡器" 和 "硬件均衡器" 两类. 在软件均衡器方面, 又分为直接建设在'),s("strong",[t._v("操作系统内核的均衡器")]),t._v("和"),s("strong",[t._v("应用程序形式")]),t._v("的均衡器两种. 前者的代表是LVS(Linux Virtual Server), 后者的代表有 "),s("strong",[t._v("Nginx")]),t._v(", HAProxy, KeepAlived 等. 前者性能会更好, 因为无须在内核空间和应用空间中来回复制数据包; 而后者的优势是选择广泛, 使用方便, 功能不受限于内核版本.")]),t._v(" "),s("p",[t._v("在硬件均衡器方面, 往往会直接采用应用"),s("strong",[t._v("专用集成电路")]),t._v("(Application Specific Integrated Circuit, ASIC) 来实现, 有专用处理芯片的支持, 避免操作系统层面的损耗, 以达到最高的性能. 这类均衡器的代表就是著名的 F5 和 A10 公司的负载均衡产品.")]),t._v(" "),s("h4",{attrs:{id:"服务端缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务端缓存"}},[t._v("#")]),t._v(" 服务端缓存")]),t._v(" "),s("p",[t._v("透明多级分流系统的逻辑思路是以流量从客户端中发出为起始, 以流量到达服务器集群中真正处理业务的节点为终结, 探索该过程中与业务无关的通用组件. 事实上很难清楚界定服务端缓存到底算不算与业务逻辑无关.")]),t._v(" "),s("p",[t._v("为系统引入缓存之前, 第一件事情是确认系统"),s("strong",[t._v("是否真的需要缓存")]),t._v('. 很多人会有意无意地把硬件中常用于区分不同产品档次, "多多益善"的缓存(如 CPU 的 L1/2/3 缓存, 磁盘缓存, 等等)代入软件开发中去, 实际上这两者差别很大, '),s("strong",[t._v("在软件开发中引入缓存的负面作用要明显大于硬件缓存带来的负面作用")]),t._v(": 从开发角度来说, 引入缓存会提高系统复杂度, 因为要考虑缓存的失效, 更新, 一致性等问题(硬件缓存也有这些问题, 只是不需要由开发者去考虑, 主流的 ISA 也都没有提供任何直接操作缓存的指令); 从运维角度来说, 缓存会掩盖一些缺陷, 让问题在更久的时间以后, 出现在距离发生现场更远的位置上; 从安全角度来说, 缓存可能会泄漏某些保密数据, 也是容易受到攻击的薄弱点.")]),t._v(" "),s("p",[t._v("冒着上述种种风险, 仍能说服你引入缓存的理由, 总结起来无外乎以下两种.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("为缓解 CPU 压力而引入缓存")]),t._v(": 譬如把方法运行结果存储起来, 把原本要实时计算的内容提前算好, 对一些公用的数据进行复用, 这可以节省 CPU 算力, 顺带提升响应性能.")]),t._v(" "),s("li",[s("strong",[t._v("为缓解 I/O 压力而引入缓存")]),t._v(": 譬如把原本对网络, 磁盘等较慢介质的读写访问变为对"),s("strong",[t._v("内存")]),t._v("等较快介质的访问, 将原本对单点部件(如数据库)的读写访问变为对可扩缩部件(如缓存中间件)的访问, 顺带提升响应性能.")])]),t._v(" "),s("p",[t._v("请注意, "),s("strong",[t._v('缓存虽然是典型以空间换时间来提升性能的手段, 但它的出发点是缓解 CPU 和 I/O 资源在峰值流量下的压力, "顺带" 而非 "专门" 地提升响应性能')]),t._v(". 这里的言外之意是如果可以通过增强 CPU, I/O 本身的性能(譬如扩展服务器的数量)来满足需要的话, 那"),s("strong",[t._v("升级硬件")]),t._v("往往是更好的解决方案, 即使需要一些额外的投入成本, 也通常要优于引入缓存后可能带来的风险.")]),t._v(" "),s("h5",{attrs:{id:"_1-缓存属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-缓存属性"}},[t._v("#")]),t._v(" 1.缓存属性")]),t._v(" "),s("p",[t._v('有不少软件系统最初的缓存功能是以 HashMap 或者 ConcurrentHashMap 为起点演进的. 当开发人员发现系统中某些资源的构建成本比较高, 而这些资源又有被重复使用的可能时, 会很自然地产生 "'),s("strong",[t._v("循环再利用")]),t._v('" 的想法, 将它们放到 Map 容器中, 待下次需要时取出重用, 避免重新构建, 这种原始朴素的复用就是最基本的缓存. 不过, 一旦专门把"缓存"看作一项技术基础设施, 一旦它有了'),s("strong",[t._v("通用, 高效, 可统计, 可管理")]),t._v("等方面的需求, 其中要考虑的因素就变得复杂起来.")]),t._v(" "),s("p",[t._v("通常, 设计或选择缓存至少会考虑以下四个维度的属性.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("吞吐量")]),t._v(": 缓存的吞吐量使用 OPS 值(每秒操作数, Operation per Second, ops/s)来衡量, 反映了对缓存进行并发读, 写操作的效率, 即缓存本身的工作效率高低.")]),t._v(" "),s("li",[s("strong",[t._v("命中率")]),t._v(": "),s("strong",[t._v("缓存的命中率即成功从缓存中返回结果次数与总请求次数的比值")]),t._v(", 反映了引入缓存的价值高低, 命中率越低, 引入缓存的收益越小, 价值越低.")]),t._v(" "),s("li",[s("strong",[t._v("扩展功能")]),t._v(": 即缓存除了基本读写功能外, 还提供哪些额外的管理功能, 譬如最大容量, 失效时间, 失效事件, 命中率统计, 等等.")]),t._v(" "),s("li",[s("strong",[t._v("分布式缓存")]),t._v(': 缓存可分为 "进程内缓存" 和 "分布式缓存" 两大类, 前者只为节点本身提供服务, 无网络访问操作, 速度快但缓存的数据不能在各服务节点中共享, 后者则相反.')])]),t._v(" "),s("h6",{attrs:{id:"_1-吞吐量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-吞吐量"}},[t._v("#")]),t._v(" (1)吞吐量")]),t._v(" "),s("p",[t._v("缓存的吞吐量只在"),s("strong",[t._v("并发场景")]),t._v("中才有统计的意义, 因为若不考虑并发, 即使是最原始的, 以 HashMap 实现的缓存, 访问效率也已经是常量时间复杂度(即 O(1)), 其中涉及碰撞, 扩容等场景的处理属于数据结构基础, 这里不再展开. 但 HashMap 并不是线程安全的容器, 如果要让它在多线程并发下正确地工作, 就要用 Collections.synchronizedMap 进行包装, 这相当于给 Map 接口的所有访问方法都自动加全局锁; 或者改用 ConcurrentHashMap 来实现, 这相当于给 Map 的访问分段加锁(从 JDK 8 起已取消分段加锁, 改为 CAS + Synchronized 锁单个元素). 无论采用怎样的实现方法, 这些线程安全措施都会带来一定的"),s("strong",[t._v("吞吐量损失")]),t._v(".")]),t._v(" "),s("p",[t._v("进一步, 如果只比较吞吐量, 完全不去考虑命中率, 淘汰策略, 缓存统计, 过期失效等功能如何实现, 那 JDK 8 改进之后的 ConcurrentHashMap 基本上就是能找到的"),s("strong",[t._v("吞吐量最高")]),t._v("的缓存容器了. 可是在很多场景里, 以上提及的功能至少有一两项是必须的, 不可能完全不考虑, 这才涉及不同缓存方案的权衡问题.")]),t._v(" "),s("p",[t._v("目前业界主流进程内的缓存实现方案包括 Caffeine, ConcurrentLinkedHashMap, LinkedHashMap, Guava Cache, Ehcache 和 Infinispan Embedded 等.")]),t._v(" "),s("p",[t._v("在这种"),s("strong",[t._v("并发读写")]),t._v("的场景中, 吞吐量受多方面因素的共同影响, 譬如, 怎样设计数据结构以尽可能避免数据竞争, 存在竞争风险时怎样处理同步(主要有使用锁实现的悲观同步和使用 CAS 实现的乐观同步), 如何避免伪共享现象(False Sharing, 这也算是典型缓存提升开发复杂度的例子)发生, 等等. 其中尽可能避免竞争是最关键的, 无论如何实现同步都不会比无须同步更快.")]),t._v(" "),s("p",[t._v("下面以 Caffeine 为例, 介绍一些如何"),s("strong",[t._v("避免竞争, 提高吞吐量")]),t._v("的缓存设计.")]),t._v(" "),s("p",[t._v("缓存中最主要的数据竞争源于"),s("strong",[t._v("读取数据")]),t._v(", 同时也会伴随着对数据状态的"),s("strong",[t._v("写入操作")]),t._v(", 而写入数据的同时, 又会伴随着数据状态的读取操作. 譬如, 读取时要同时更新数据的最近访问时间和访问计数器的状态, 以实现缓存的淘汰策略; 又或者读取时要同时判断数据的超期时间等信息, 以实现失效重加载等其他扩展功能. 对以上伴"),s("strong",[t._v("随读写操作而来的状态维护操作")]),t._v(", 有两种可选择的处理思路. 一种是以 Guava Cache 为代表的"),s("strong",[t._v("同步处理")]),t._v("机制, 即在访问数据时一并完成缓存淘汰, 统计, 失效等状态变更操作, 通过"),s("strong",[t._v("分段加锁")]),t._v("等优化手段来尽量减少竞争. 另一种是以 Caffeine 为代表的"),s("strong",[t._v("异步日志提交机制")]),t._v(", 这种机制参考了经典的数据库设计理论, 将数据的读, 写过程看作"),s("strong",[t._v("日志")]),t._v("(即对数据的操作指令)的提交过程. 尽管日志也涉及写入操作, 有并发的数据变更就必然面临锁竞争, 但异步提交的日志已经将原本在 Map 内的锁转移到日志的追加写操作上, 日志里腾挪优化的余地就比在 Map 中要大得多.")]),t._v(" "),s("p",[t._v("在 Caffeine 的实现中, 设有专门的"),s("strong",[t._v("环形缓存区")]),t._v("(Ring Buffer, 也常称作 Circular Buffer)来记录由于数据读取而产生的状态变动日志. 为进一步减少竞争, Caffeine 给每条线程(对线程取哈希值, 哈希值相同的使用同一个缓冲区)都设置了一个专用的环形缓冲.")]),t._v(" "),s("ul",[s("li",[t._v("环形缓冲: 所谓环形缓冲, 并非 Caffeine 的专有概念, 它是一种"),s("strong",[t._v("拥有读, 写两个指针")]),t._v('的数据复用结构, 有非常广泛的应用. 举个例子, 譬如一台计算机通过键盘输入, 并通过 CPU 读取 "HELLO WIKIPEDIA" 这个长 14 字节的单词, 通常需要一个至少 14 字节的缓冲区才行. 但如果是环形缓冲结构, '),s("strong",[t._v("读取和写入就应当一起进行")]),t._v(", 在读取指针之前的位置均可以重复使用, 理想情况下, 只要读取指针不落后于写入指针一整圈, 这个缓冲区就可以持续工作下去, 能容纳无限多个新字符. 否则, 就必须阻塞写入操作去等待读取清空缓冲区.")])]),t._v(" "),s("p",[t._v("从 Caffeine 读取数据时, 数据本身会在其内部的 "),s("strong",[t._v("ConcurrentHashMap")]),t._v(" 中直接返回, 而数据的"),s("strong",[t._v("状态信息变更就存入环形缓冲")]),t._v("中, 由"),s("strong",[t._v("后台线程异步处理")]),t._v(". 如果异步处理的速度跟不上状态变更的速度, 导致缓冲区满了, 那此后接收的状态的变更信息就会直接被丢弃, 直至缓冲区重新空闲. 通过"),s("strong",[t._v("环形缓冲和容忍有损失的状态变更")]),t._v(", Caffeine 大幅降低了由于数据读取而导致的垃圾收集和锁竞争, 因此 Caffeine 的读取性能几乎能与 ConcurrentHashMap 的读取性能相同.")]),t._v(" "),s("p",[t._v("向 Caffeine 写入数据时, 将使用传统的有界队列(ArrayQueue)来存放状态变更信息, 写入带来的状态变更是无损的, 不允许丢失任何状态, 这是考虑到许多状态的默认值必须通过写入操作来完成初始化, 因此写入会有一定的性能损失. 根据 Caffeine 官方给出的数据, 相比ConcurrentHashMap,  Caffeine 在写入时大约会慢 10% 左右.")]),t._v(" "),s("h6",{attrs:{id:"_2-命中率与淘汰策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-命中率与淘汰策略"}},[t._v("#")]),t._v(" (2)命中率与淘汰策略")]),t._v(" "),s("p",[t._v("有限的物理存储决定了"),s("strong",[t._v("任何缓存的容量都不可能是无限")]),t._v("的, 所以缓存需要在消耗空间与节约时间之间取得平衡, 这要求缓存必须能够自动或人工淘汰掉缓存中的"),s("strong",[t._v("低价值数据")]),t._v(". 考虑到由人工管理的缓存淘汰主要取决于开发者如何编码, 不能一概而论, 这里只讨论由缓存"),s("strong",[t._v("自动进行淘汰")]),t._v('的情况. 笔者所说的 "缓存如何自动地实现淘汰低价值目标", 现在被称为'),s("strong",[t._v("缓存的淘汰策略")]),t._v(", 也常称作替换策略或清理策略.")]),t._v(" "),s("p",[t._v("在了解缓存如何实现自动淘汰低价值数据之前, 首先要"),s("strong",[t._v('定义怎样的数据才算是 "低价值"')]),t._v(" . 由于缓存的通用性, 这个问题的答案必须是"),s("strong",[t._v("与具体业务逻辑无关")]),t._v("的, 只能从"),s("strong",[t._v("缓存工作过程收集到的统计结果")]),t._v("来确定数据是否有价值, 通用的统计结果包括但不限于"),s("strong",[t._v("数据何时进入缓存, 被使用过多少次, 最近什么时候被使用")]),t._v(", 等等. 一旦确定选择何种统计数据, 就决定了如何通用地, 自动地判定缓存中每个数据的价值高低, 也相当于决定了缓存的淘汰策略是如何实现的.")]),t._v(" "),s("p",[t._v("目前, 最基础的淘汰策略实现方案有以下三种.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("FIFO")]),t._v("(First In First Out): "),s("strong",[t._v("优先淘汰最早进入被缓存的数据")]),t._v(". FIFO 的实现十分简单, 但一般来说它并不是优秀的淘汰策略, 越是频繁被用到的数据, 往往会越早存入缓存之中. 如果采用这种淘汰策略, 很可能会大幅降低缓存的命中率.")]),t._v(" "),s("li",[s("strong",[t._v("LRU")]),t._v("(Least Recent Used): "),s("strong",[t._v("优先淘汰最久未被访问过的数据")]),t._v(". LRU 通常会采用 "),s("strong",[t._v("HashMap 加 LinkedList")]),t._v(" 的双重结构(如 LinkedHashMap)来实现, 以 HashMap 来提供访问接口, 保证常量时间复杂度的读取性能, 以 LinkedList 的链表元素顺序来"),s("strong",[t._v("表示数据的时间顺序")]),t._v(", 每次缓存命中时把返回对象调整到 LinkedList 开头, 每次缓存淘汰时从链表末端开始清理数据. 对大多数的缓存场景来说, LRU 明显要比 FIFO 策略合理, 尤其适合用来处理"),s("strong",[t._v("短时间内频繁访问的热点对象")]),t._v(". 但是如果一些热点数据在系统中被频繁访问, 只是最近一段时间因为某种原因未被访问过, 那么这些热点数据此时就会有被 LRU 淘汰的风险, 换句话说, LRU 依然可能错误淘汰价值更高的数据.")]),t._v(" "),s("li",[s("strong",[t._v("LFU")]),t._v("(Least Frequently Used): "),s("strong",[t._v("优先淘汰最不经常使用的数据")]),t._v(". LFU 会给每个数据添加一个"),s("strong",[t._v("访问计数器")]),t._v(", 每访问一次就加 1, 需要淘汰时就"),s("strong",[t._v("清理计数器数值最小的那批数据")]),t._v(". LFU 可以解决上面 LRU 中热点数据间隔一段时间不访问就被淘汰的问题, 但同时它又引入了两个新的问题. 第一个问题是需要对每个缓存的数据专门维护一个计数器, 每次访问都要"),s("strong",[t._v("更新")]),t._v(", 但这样做会带来高昂的维护开销; 另一个问题是"),s("strong",[t._v("不便于处理随时间变化的热度变化")]),t._v(", 譬如某个曾经频繁访问的数据现在不需要了, 但很难自动将它清理出缓存.")])]),t._v(" "),s("p",[t._v("缓存的淘汰策略直接影响缓存的命中率, 没有一种策略是完美的, 能够满足系统全部需求的. 不过, 随着淘汰算法的不断发展, 近年来的确出现了许多相对性能更好, 也更复杂的新算法. 以 LFU 为例, 针对它存在的两个问题, 近年来提出的 TinyLFU 和 W-TinyLFU 算法就会有更好的效果.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("TinyLFU")]),t._v("(Tiny Least Frequently Used): TinyLFU 是 LFU 的改进版本. 为了缓解 LFU 每次访问都要修改计数器所带来的性能负担, TinyLFU 会首先"),s("strong",[t._v("采用 Sketch 对访问数据进行分析")]),t._v('. 所谓 Sketch 是统计学上的概念, 指用少量的样本数据来估计全体数据的特征, 这种做法显然牺牲了一定程度的准确性, 但是只要样本数据与全体数据具有相同的概率分布, Sketch 得出的结论仍不失为一种高效与准确之间权衡的有效结论. 借助 Count-Min Sketch算法(可视为布隆过滤器的一种等价变形结构), TinyLFU 可以用相对小得多的记录频率和空间来近似地找出缓存中的低价值数据. 为了解决 LFU 不便于处理随时间变化的热度变化问题,  TinyLFU 采用了基于 "'),s("strong",[t._v("滑动时间窗")]),t._v('" 的热度衰减算法, 简单理解就是每隔一段时间, 便会把计数器的数值减半, 以此解决 "旧热点" 数据难以清除的问题.')]),t._v(" "),s("li",[s("strong",[t._v("W-TinyLFU")]),t._v("(Windows-TinyLFU): W-TinyLFU 也是 TinyLFU 的改进版本. 上面提到的 TinyLFU 在减少计数器维护频率的同时, 也带来了无法很好地应对稀疏突发访问的问题. 所谓稀疏突发访问是指有一些绝对频率较小, 但突发访问频率很高的数据, 譬如某些运维性质的任务, 也许一天, 一周只会在特定时间运行一次, 其余时间都不会用到, 此时 TinyLFU 就很难让这类元素通过 Sketch 的过滤, 因为它们无法在运行期间积累到足够高的频率. 鉴于应对短时间的突发访问是 LRU 的强项, W-TinyLFU 结合了 LRU 和 LFU 的优点, 从整"),s("strong",[t._v("体上看它是 LFU 策略, 从局部实现上看它又是 LRU 策略")]),t._v(". 具体做法是"),s("strong",[t._v("将新记录暂时放入一个名为 Window Cache 的前端 LRU 缓存里面, 让这些对象可以在 Window Cache 中累积热度, 如果能通过 TinyLFU 的过滤器, 再进入名为 Main Cache 的主缓存中存储")]),t._v(", 主缓存根据数据的访问频繁程度分为不同的段(LFU 策略, 实际上 W-TinyLFU 只分了两段), 但单独从某一段来看又是基于 LRU 策略去实现的(称为 Segmented LRU). 每当前一段缓存满了之后, 会将低价值数据淘汰到后一段中去存储, 直至最后一段也满了之后, 该数据会被彻底清理出缓存.")])]),t._v(" "),s("p",[t._v("这些改进算法比基础版本的 LFU 复杂了很多. 有时候为了取得理想的效果, 采用较为复杂的淘汰策略是不得已的选择.")]),t._v(" "),s("h6",{attrs:{id:"_3-扩展功能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-扩展功能"}},[t._v("#")]),t._v(" (3)扩展功能")]),t._v(" "),s("p",[t._v('一般来说, 一套标准的 Map 接口(或者 javax.cache.Cache 接口)就可以满足缓存访问的基本需要, 不过在 "访问" 之外, 专业的缓存往往还会提供很多'),s("strong",[t._v("额外的功能")]),t._v(". 简要列举如下.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("加载器")]),t._v(': 许多缓存都有 "CacheLoader" 之类的设计, 加载器可以让缓存从只能被动存储外部放入的数据, 变为能够主动通过加载器去加载指定 Key 值的数据, 加载器也是实现自动刷新功能的基础前提.')]),t._v(" "),s("li",[s("strong",[t._v("淘汰策略")]),t._v(": 有些缓存的淘汰策略是固定的, 也有一些缓存能够支持用户自己根据需要选择不同的淘汰策略.")]),t._v(" "),s("li",[s("strong",[t._v("失效策略")]),t._v(": 要求缓存的数据在一定时间后自动失效(移出缓存)或自动刷新(使用加载器重新加载).")]),t._v(" "),s("li",[s("strong",[t._v("事件通知")]),t._v(": 缓存可能会提供一些事件监听器, 让你在数据状态变动(如失效, 刷新, 移除)时进行一些额外操作. 有的缓存还提供了对缓存数据本身的监视能力(Watch 功能).")]),t._v(" "),s("li",[s("strong",[t._v("并发级别")]),t._v(": 对于通过分段加锁来实现的缓存(以 Guava Cache 为代表), 往往会提供并发级别的设置, 可以简单将其理解为缓存内部是使用多个 Map 来分段存储数据的, 并发级别用于计算出使用 Map 的数量. 如果将并发级别这个参数设置得过大, 会引入更多的 Map, 需要额外维护这些 Map 而导致更大的时间和空间上的开销; 如果设置得过小, 又会导致在访问时产生线程阻塞, 因为多个线程更新同一个 ConcurrentMap 的同一个值时会产生锁竞争.")]),t._v(" "),s("li",[s("strong",[t._v("容量控制")]),t._v(": 缓存通常都支持指定初始容量和最大容量, 初始容量的目的是减少扩容频率, 这与 Map 接口本身的初始容量含义是一致的. 最大容量类似于控制 Java 堆的 -Xmx 参数, 当缓存接近最大容量时, 会自动清理低价值的数据.")]),t._v(" "),s("li",[s("strong",[t._v("引用方式")]),t._v(": 支持将数据设置为软引用或者弱引用, 提供引用方式的设置是为了将缓存与 JVM  的垃圾收集机制联系起来.")]),t._v(" "),s("li",[s("strong",[t._v("统计信息")]),t._v(": 提供诸如缓存命中率, 平均加载时间, 自动回收计数等统计信息.")]),t._v(" "),s("li",[s("strong",[t._v("持久化")]),t._v(": 支持将缓存的内容存储到数据库或者磁盘中, 进程内缓存提供持久化功能的作用不大, 但分布式缓存大多都会考虑提供持久化功能.")])]),t._v(" "),s("p",[t._v("至此, 本节已简要介绍了缓存的三项属性: 吞吐量, 命中率和扩展功能, 这里将几款主流进程内的缓存方案整理成表如下.")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}}),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("ConcurrentHashMap")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("Ehcache")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("Guava Cache")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("Caffeine")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("访问性能")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("最高")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("一般")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("良好")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("优秀 接近于ConcurrentHashMap")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("淘汰策略")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("无")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("支持多种淘汰策略如: FIFO, LRU, LFU")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("LRU")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("W-TinyLFU")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("扩展功能")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("只提供基础的访问接口")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("并发级别控制; 失效策略; 容量控制; 事件通知; 统计信息...")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("大致同左")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("大致同左")])])])]),t._v(" "),s("h6",{attrs:{id:"_4-分布式缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-分布式缓存"}},[t._v("#")]),t._v(" (4)分布式缓存")]),t._v(" "),s("p",[t._v("相比缓存数据在进程内存中读写的速度, 一旦涉及"),s("strong",[t._v("网络访问, 由网络传输, 数据复制, 序列化和反序列化")]),t._v("等操作所导致的延迟要比内存访问高得多, 所以"),s("strong",[t._v("对分布式缓存来说, 处理与网络相关的操作是对吞吐量影响更大的因素")]),t._v(", 往往也是比淘汰策略, 扩展功能更重要的关注点, 这也决定了尽管有 Ehcache, Infinispan 这类能同时支持分布式部署和进程内部署的缓存方案, 但通常进程内缓存和分布式缓存选型时会有完全不同的候选对象及考察点.")]),t._v(" "),s("p",[t._v("在决定使用哪种分布式缓存前, 首先必须确定自己的需求是什么.")]),t._v(" "),s("p",[s("strong",[t._v("(1)从访问的角度来说")]),t._v(", 如果是频繁更新但甚少读取的数据, 通常是不会有人把它拿去做缓存的, 因为这样做没有收益. 对于甚少更新但频繁读取的数据, 理论上更适合做"),s("strong",[t._v("复制式缓存")]),t._v("; 对于更新和读取都较为频繁的数据, 理论上更适合做"),s("strong",[t._v("集中式缓存")]),t._v(". 下面笔者简要介绍这两种分布式缓存形式的差别与代表性产品.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("复制式缓存")]),t._v(': 复制式缓存可以看作 "能够支持分布式的进程内缓存", 它的工作原理与 Session 复制类似. '),s("strong",[t._v("缓存中所有数据在分布式集群的每个节点里面都有一份副本")]),t._v(", 读取数据时无须网络访问, 直接从当前节点的进程内存中返回, 理论上可以做到与进程内缓存一样高的读取性能; 但当数据发生变化时, 就必须"),s("strong",[t._v("遵循复制协议")]),t._v(", 将变更同步到集群的每个节点中, 复制性能随着节点的增加呈现平方级下降, 变更数据的代价十分高昂. 复制式缓存的代表是 JBossCache, 这是 JBoss 针对企业级集群设计的缓存方案, 支持 JTA 事务, 依靠 JGroup 进行集群节点间的数据同步. 以 JBossCache 为代表的复制式缓存曾有一段短暂的兴盛期, 但今天基本上已经很难再见到使用这种缓存形式的大型信息系统了. JBossCache 被淘汰的主要原因是"),s("strong",[t._v("写入性能太差")]),t._v(', 它在小规模集群中同步数据尚算差强人意, 但在大规模集群下, 很容易因网络同步的速度跟不上写入速度, 进而导致在内存中累计大量待重发对象, 最终引发 OutOfMemory 崩溃. 为了缓解复制式同步的写入效率问题, JBossCache 的继任者 Infinispan 提供了另一种分布式同步模式(这种同步模式的名字叫作"分布式"), 允许用户配置数据需要复制的副本数量, 譬如集群中有八个节点, 可以要求每个数据只保存四份副本, 此时, 缓存的总容量相当于传统复制模式的一倍. 如果要访问的数据在本地缓存中没有存储, Infinispan 完全有能力感知网络的拓扑结构, 知道应该到哪些节点中寻找数据.')]),t._v(" "),s("li",[s("strong",[t._v("集中式缓存")]),t._v(": 集中式缓存是目前分布式缓存的"),s("strong",[t._v("主流形式")]),t._v(", 它的"),s("strong",[t._v("读, 写都需要网络访问")]),t._v(", 好处是不会随着集群节点数量的增加而产生额外的负担, 坏处是读, 写都不再可能达到进程内缓存那样的高性能. 集中式缓存还有一个必须提到的关键特点, 它与使用缓存的应用分处在"),s("strong",[t._v("独立的进程空间")]),t._v("中. 其好处是能够为异构语言提供服务, 譬如用 C 语言编写的 Memcached 完全可以毫无障碍地为 Java 语言编写的应用提供缓存服务; 但坏处是如果要缓存对象等复杂类型的话, 基本上只能靠"),s("strong",[t._v("序列化")]),t._v("来支撑具体语言的类型系统(支持 Hash 类型的缓存, 可以部分模拟对象类型), 不仅有序列化的成本, 还很容易导致传输成本的显著增加. 举个例子, 假设某个有 100 个字段的大对象的其中 1 个字段的值发生变更, 通常缓存不得不把整个对象所有内容重新序列化传输出去才能实现更新, 因此, 一般"),s("strong",[t._v("集中式缓存更提倡直接缓存原始数据类型而不是对象")]),t._v(". 相比之下, JBossCache 通过它的字节码自审(Introspection)功能和树状存储结构(TreeCache), 做到了自动跟踪, 处理对象的部分变动, 当用户修改了对象中某些字段的数据时, 缓存只会同步对象中真正变更的那部分数据. 如今 "),s("strong",[t._v("Redis")]),t._v(" 广为流行, 基本上已经打败了 Memcached 及其他集中式缓存框架, 成为集中式缓存的"),s("strong",[t._v("首选")]),t._v(', 甚至可以说成为分布式缓存的实质上的首选, 几乎到了不必管读取, 写入哪种操作更频繁, 都可以用 Redis 的程度. 也因如此, 之前说到哪些数据适合用复制式缓存, 哪些数据适合用集中式缓存时, 笔者都在开头加了个拗口的"理论上". 尽管 Redis 最初设计的本意是 NoSQL 数据库而不是专门用来做缓存的, 可今天它确实已经成为许多分布式系统中不可或缺的基础设施, 广泛用作缓存的实现方案.')])]),t._v(" "),s("p",[s("strong",[t._v("(2)从数据一致性角度来说")]),t._v(", 缓存本身也有集群部署的需求, 理论上应该认真考虑一下是"),s("strong",[t._v("否能接受不同节点取到的缓存数据可能存在差异")]),t._v("的情况. 譬如刚刚放入缓存中的数据, 另外一个节点马上访问却发现未能读到; 刚刚更新缓存中的数据, 另外一个节点在短时间内读取到的仍是旧的数据, 等等. 根据分布式缓存集群"),s("strong",[t._v("能否保证数据一致性")]),t._v(', 可以将它分为 AP 和 CP 两种类型. 此处又一次出现了"理论上", 是因为在实际开发中通常'),s("strong",[t._v("不会把追求强一致性的数据使用缓存来处理")]),t._v(", 可以这样做, 但没必要(可类比 MESI 等缓存一致性协议). 譬如, Redis 集群就是"),s("strong",[t._v("典型的 AP 式")]),t._v(", 有着高性能, 高可用等特点, 却"),s("strong",[t._v("并不保证强一致性")]),t._v('. 而对于能够保证强一致性的 ZooKeeper, Doozerd, etcd 等分布式协调框架, 通常不会有人将它们当作"缓存框架"来使用, 这些分布式协调框架的吞吐量相对 Redis 来说是非常有限的. 不过 ZooKeeper, Doozerd, etcd 倒是常与 Redis 及其他分布式缓存搭配工作, 用来实现通知, 协调, 队列, 分布式锁等功能.')]),t._v(" "),s("p",[t._v("分布式缓存与进程内缓存各有所长, 也各有局限, "),s("strong",[t._v("它们是互补而非互斥的关系")]),t._v(", 如有需要, 完全可以将两者搭配使用, 构成"),s("strong",[t._v("透明多级缓存")]),t._v('(Transparent Multilevel Cache, TMC), 如下图所示. 先不考虑 "透明" 的话, 多级缓存是很好理解的, 使用进程内缓存做'),s("strong",[t._v("一级缓存")]),t._v(", 分布式缓存做"),s("strong",[t._v("二级缓存")]),t._v(", 如果能在一级缓存中查询到结果就直接返回, 否则便到二级缓存中去查询, 再将二级缓存中的结果回填到一级缓存, 以后再访问该数据就没有网络请求了. 如果二级缓存也查询不到, 就发起对最终数据源的查询, 将结果回填到一, 二级缓存中去.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221120143602525.png",alt:"",title:"透明多级缓存TMC"}})]),t._v(" "),s("h5",{attrs:{id:"_2-缓存风险"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-缓存风险"}},[t._v("#")]),t._v(" 2.缓存风险")]),t._v(" "),s("p",[t._v("缓存不是多多益善, 它有利有弊, 是真正在必须使用时才考虑的解决方案. 本节将介绍几种常见的缓存风险及其应对办法.")]),t._v(" "),s("h6",{attrs:{id:"_1-缓存穿透"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-缓存穿透"}},[t._v("#")]),t._v(" (1)缓存穿透")]),t._v(" "),s("p",[s("strong",[t._v("缓存的目的是缓解 CPU 或者 I/O 的压力")]),t._v(", 譬如对数据库做缓存, 大部分流量都从缓存中直接返回, 只有缓存未能命中的数据请求才会流到数据库中, 这样数据库压力自然就减小了. 但是如果查询的数据在数据库中根本不存在, 缓存里自然也不会有, 这类请求的流量每次都不会命中, 且"),s("strong",[t._v("每次都会触及末端的数据库")]),t._v(", 缓存就起不到缓解压力的作用了, 这种"),s("strong",[t._v("查询不存在的数据的现象被称为缓存穿透")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("缓存穿透有可能是业务逻辑本身就存在的固有问题, 也有可能是恶意攻击所导致")]),t._v(". 为了解决缓存穿透问题, 通常会采取下面两种办法.")]),t._v(" "),s("ul",[s("li",[t._v("对于业务逻辑本身不能避免的缓存穿透, 可以"),s("strong",[t._v("约定在一定时间内对返回为空的 Key 值进行缓存")]),t._v("(注意是正常返回但是结果为空, 不应把抛异常的也当作空值来缓存), 使得在一段时间内缓存最多被穿透"),s("strong",[t._v("一次")]),t._v(". 如果后续业务在数据库中对该 Key 值插入了新记录, 那应当在插入之后"),s("strong",[t._v("主动清理")]),t._v("掉缓存的 Key 值. 如果业务时效性允许的话, 也可以对缓存设置一个"),s("strong",[t._v("较短的超时时间")]),t._v("来自动处理.")]),t._v(" "),s("li",[s("strong",[t._v("对于恶意攻击导致的缓存穿透")]),t._v(", 通常会在缓存之前设置一个"),s("strong",[t._v("布隆过滤器")]),t._v("来解决. 所谓恶意攻击是指请求者刻意构造数据库中肯定不存在的 Key 值, 然后发送大量请求进行查询. 布隆过滤器是用最小的代价来判断某个元素是否存在于某个集合的办法. 如果布隆过滤器给出的判定结果是请求的数据不存在, 直接返回即可, 连缓存都不必去查. 虽然维护布隆过滤器本身需要一定的成本, 但比起攻击造成的资源损耗仍然是值得的.")])]),t._v(" "),s("h6",{attrs:{id:"_2-缓存击穿"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-缓存击穿"}},[t._v("#")]),t._v(" (2)缓存击穿")]),t._v(" "),s("p",[t._v("缓存的基本工作原理是"),s("strong",[t._v("首次从真实数据源加载数据, 完成加载后回填入缓存, 以后其他相同的请求就从缓存中获取数据, 以缓解数据源的压力")]),t._v(". 如果缓存中"),s("strong",[t._v("某些热点数据忽然因某种原因失效")]),t._v("了, 譬如"),s("strong",[t._v("由于超期而失效, 此时又有多个针对该数据的请求同时发送过来, 这些请求将全部未能命中缓存, 到达真实数据源中, 导致其压力剧增, 这种现象被称为缓存击穿")]),t._v(".")]),t._v(" "),s("p",[t._v("要避免缓存击穿问题, 通常会采取下面两种办法.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("加锁同步")]),t._v(", 以请求该数据的 Key 值为锁, 使得只有第一个请求可以流入真实的数据源中, 对其他线程则采取阻塞或重试策略. 如果是进程内缓存出现问题, 施加普通互斥锁即可, 如果是分布式缓存中出现问题, 就施加分布式锁, 这样数据源就不会同时收到大量针对同一个数据的请求了.")]),t._v(" "),s("li",[t._v("热点数据由代码来手动管理. 缓存击穿是仅针对热点数据自动失效才引发的问题, 对于这类数据, 可以直接由开发者通过代码来有计划地完成更新, 失效, 避免由缓存的策略自动管理.")])]),t._v(" "),s("h6",{attrs:{id:"_3-缓存雪崩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-缓存雪崩"}},[t._v("#")]),t._v(" (3)缓存雪崩")]),t._v(" "),s("p",[t._v("缓存击穿是针对"),s("strong",[t._v("单个热点数据失效")]),t._v(", 由大量请求击穿缓存而给真实数据源带来压力. 还有一种可能更普遍的情况, 即不是针对单个热点数据的大量请求, 而是由于"),s("strong",[t._v("大批不同的数据在短时间内一起失效, 导致这些数据的请求都击穿缓存到达数据源, 同样令数据源在短时间内压力剧增")]),t._v(".")]),t._v(" "),s("p",[t._v("出现这种情况, 往往是因为系统有专门的缓存"),s("strong",[t._v("预热功能")]),t._v(", 或者大量公共数据是由某一次冷操作加载的, 使得由此载入缓存的"),s("strong",[t._v("大批数据具有相同的过期时间, 在同一时刻一起失效")]),t._v("; 也可能是因为缓存服务由于某些原因崩溃后重启, 造成大量数据同时失效. 这种现象被称为缓存雪崩.")]),t._v(" "),s("p",[t._v("要避免缓存雪崩问题, 通常会采取下面三种办法.")]),t._v(" "),s("ul",[s("li",[t._v("提升缓存系统可用性, 建设分布式缓存的集群.")]),t._v(" "),s("li",[t._v("启用透明"),s("strong",[t._v("多级缓存")]),t._v(", 这样各个服务节点一级缓存中的数据通常会具有不一样的加载时间, 也就分散了它们的过期时间.")]),t._v(" "),s("li",[t._v("将缓存的生存期从固定时间改为"),s("strong",[t._v("一个时间段内的随机时间")]),t._v(", 譬如原本是 1h 过期, 在缓存不同数据时, 可以设置生存期为 55min 到 65min 之间的某个随机时间.")])]),t._v(" "),s("h6",{attrs:{id:"_4-缓存污染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-缓存污染"}},[t._v("#")]),t._v(" (4)缓存污染")]),t._v(" "),s("p",[s("strong",[t._v("缓存污染是指缓存中的数据与真实数据源中的数据不一致的现象")]),t._v(". 尽管缓存通常不追求强一致性, 但这显然不能等同于不要求缓存和数据源间的最终一致性.")]),t._v(" "),s("p",[s("strong",[t._v("缓存污染多数是由开发者更新缓存不规范造成的")]),t._v(", 譬如从缓存中获得了某个对象, 更新了对象的属性, 但最后因为某些原因, 譬如后续业务发生异常回滚了, 最终没有成功写入数据库, 导致缓存的数据是新的, 数据库中的数据是旧的.")]),t._v(" "),s("p",[t._v("为了尽可能地提高使用缓存时的一致性, 目前已经有很多更新缓存时可以遵循的"),s("strong",[t._v("设计模式")]),t._v(", 譬如 Cache Aside, Read/Write Through, Write Behind Caching 等. 其中最简单, 成本最低的 Cache Aside 模式是指:")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("读数据时, 先读缓存, 如果没有, 再读数据源, 然后将数据放入缓存, 再响应请求")]),t._v(";")]),t._v(" "),s("li",[s("strong",[t._v("写数据时, 先写数据源, 然后失效(而不是更新)掉缓存")]),t._v(".")])]),t._v(" "),s("p",[t._v("读数据方面一般不会出错, 但是写数据时, 就有必要专门强调两点. 一是"),s("strong",[t._v("先后顺序是先数据源后缓存")]),t._v(". 试想一下, 如果采用先失效缓存后写数据源的顺序, 那一定存在一段时间缓存已经删除完毕, 但数据源还未修改完成的情况, 此时新的查询请求到来, 缓存未能命中, 就会直接流到真实数据源中. 这样请求读到的数据依然是"),s("strong",[t._v("旧数据")]),t._v(", 随后又重新回填到缓存中. 当数据源的修改完成后, 结果出现数据源中是新数据, 而缓存中是旧数据的情况. 另一点是"),s("strong",[t._v("应当失效缓存")]),t._v(", 而不是去尝试更新缓存. 这很容易理解, 如果去更新缓存, 更新过程中数据源又被其他请求再次修改的话, 缓存又要面临处理多次赋值的复杂时序问题. 所以直接失效缓存, "),s("strong",[t._v("等下次用到该数据时自动回填")]),t._v(", 期间无论数据源中的值被改了多少次都不会造成任何影响.")]),t._v(" "),s("p",[t._v("Cache Aside 模式依然不能保证在一致性上绝对不出问题, 否则就无须设计出 Paxos 这样复杂的共识算法了. 典型的出错场景是如果某个数据是"),s("strong",[t._v("从未被缓存过")]),t._v("的, 请求会直接流到真实数据源中, 如果数据源中的写操作发生在查询请求之后, 结果回填到缓存之前, 也会出现缓存中回填的内容与数据库的实际数据不一致的情况. 但这种情况发生的概率是很低的, "),s("strong",[t._v("Cache Aside 模式仍然是以低成本更新缓存, 并且获得相对可靠结果的解决方案")]),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"架构安全性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#架构安全性"}},[t._v("#")]),t._v(" 架构安全性")]),t._v(" "),s("p",[t._v('即使只限定在 "软件架构设计" 这个语境下, 系统安全仍然是一个很大的话题. 计算机系统安全, 不仅仅是指 "防御系统被黑客攻击" 这样狭隘的安全, 还至少应包括(不限于)以下这些问题的具体解决方案.')]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("认证")]),t._v("(Authentication): 系统如何正确"),s("strong",[t._v("分辨出操作用户的真实身份")]),t._v("?")]),t._v(" "),s("li",[s("strong",[t._v("授权")]),t._v("(Authorization): 系统如何"),s("strong",[t._v("控制一个用户该看到哪些数据, 操作哪些功能")]),t._v("?")]),t._v(" "),s("li",[s("strong",[t._v("凭证")]),t._v("(Credential): 系统如何保证它与用户之间的承诺是双方当时"),s("strong",[t._v("真实意图的体现")]),t._v(", 是准确, 完整且不可抵赖的?")]),t._v(" "),s("li",[s("strong",[t._v("保密")]),t._v("(Confidentiality): 系统如何保证敏感数据无法被包括系统管理员在内的内外部人员所窃取, 滥用?")]),t._v(" "),s("li",[s("strong",[t._v("传输")]),t._v("(Transport Security): 系统如何保证通过网络传输的信息"),s("strong",[t._v("无法被第三方窃听")]),t._v(", 篡改和冒充?")]),t._v(" "),s("li",[s("strong",[t._v("验证")]),t._v("(Verification): 系统如何确保提交到每项服务中的数据是"),s("strong",[t._v("合乎规则")]),t._v("的, 不会对系统稳定性, 数据一致性, 正确性产生风险?")])]),t._v(" "),s("p",[t._v("与安全相关的问题, 一般不会直接创造价值, 解决起来又烦琐复杂, 费时费力, 很容易被开发人员忽略, 但庆幸的是这些问题基本上也都是与具体系统, 具体业务无关的"),s("strong",[t._v("通用性")]),t._v("问题, 这意味着它们往往会存在业界通行的, 已被验证过是行之有效的解决方案, 甚至已经形成行业标准, 不需要开发者自己从头去构思如何解决.")]),t._v(" "),s("p",[t._v("本章会围绕系统安全的"),s("strong",[t._v("标准方案")]),t._v(", 逐一探讨以上问题的处理办法. 此外, 还有其他一些与安全相关的内容主要是由管理, 运维, 审计领域为主导, 尽管也需要软件架构和开发人员的配合参与, 但不列入本章的讨论范围之内, 譬如安全审计, 系统备份与恢复, 信息系统安全法规与制度, 计算机防病毒制度, 保护私有信息规则等.")]),t._v(" "),s("h4",{attrs:{id:"认证"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#认证"}},[t._v("#")]),t._v(" 认证")]),t._v(" "),s("p",[t._v('认证, 授权和凭证可以说是一个系统中最基础的安全设计, 哪怕再简陋的信息系统, 大概也不可能忽略 "用户登录" 功能. 信息系统为用户提供服务之前, 总是希望先弄清楚  '),s("strong",[t._v('"你是谁"(认证), "你能干什么"(授权)以及 "你如何证明"(凭证)')]),t._v(' 这三个基本问题. 然而, 这三个基本问题又不像部分开发者认为的那样, 只是一个 "系统登录" 功能, 仅仅是校验一下用户名, 密码是否正确这么简单. 账户和权限作为一种必须最大限度保障安全和隐私, 同时又要兼顾各个系统模块甚至系统间共享访问的基础主数据, 它的存储, 管理与使用都面临一系列复杂的问题.')]),t._v(" "),s("p",[t._v("对于某些大规模的信息系统, 账户和权限的管理往往要由专门的"),s("strong",[t._v("基础设施")]),t._v("来负责, 譬如微软的活动目录(Active Directory, AD)或轻量目录访问协议(Lightweight Directory Access Protocol, LDAP), 跨系统的共享使用甚至会用到区块链技术.")]),t._v(" "),s("p",[t._v('另外还有一个认知偏差: 尽管 "认证" 是解决 "你是谁" 的问题, 但这里的 "你" 并不一定是指人, 也可能是指外部的代码, '),s("strong",[t._v("即第三方的类库或者服务")]),t._v(".")]),t._v(" "),s("p",[t._v('最初, 对代码认证的重要程度甚至高于对最终用户的认证, 譬如在早期的 Java 系统里, 安全认证默认是特指 "代码级安全", 即是否信任要在电脑中运行的代码. 这是由 Java 当时的主要应用形式--- Java Applets 所决定的: 类加载器从远端下载一段字节码, 以 Applets 的形式在用户的浏览器中运行, 由于 Java 操控计算机资源的能力要远远强于 JavaScript, 因此必须先确保这些代码不会损害用户的计算机. 这一阶段的安全观念催生了现在仍然存在于 Java 技术体系中的 "安全管理器"(java.lang.SecurityManager), "代码权限许可" (java.lang.RuntimePermission)等概念. 如今, 对外部类库和服务的认证需求依然普遍, 但相比起五花八门的最终用户认证来说, 代码认证的研究方向已经很固定, 基本上都统一到'),s("strong",[t._v("证书签名")]),t._v("上.")]),t._v(" "),s("p",[t._v("在本节中, 认证的范围只限于对"),s("strong",[t._v("最终用户的认证")]),t._v(", 而代码认证会安排在后面讲解.")]),t._v(" "),s("h5",{attrs:{id:"_1-认证的标准"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-认证的标准"}},[t._v("#")]),t._v(" 1.认证的标准")]),t._v(" "),s("p",[t._v('B/S 系统对最终用户认证的需求使得 "安全认证" 的重点逐渐从 "代码级安全" 转为 "用户级安全", 即你是否信任正在操作的用户.')]),t._v(" "),s("p",[t._v("一个架构安全性的经验原则: 以标准规范为指导, 以标准接口去实现. 安全涉及的问题很麻烦, 但解决方案已相当成熟, 对于 99% 的系统来说, 在安全上不去做轮子, 不去想发明创造, 严格遵循标准, "),s("strong",[t._v("就是最恰当的安全设计")]),t._v(".")]),t._v(" "),s("p",[t._v("主流的有三种认证方式, 具体含义和应用场景列举如下.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("通信信道上的认证")]),t._v(": 你和我"),s("strong",[t._v("建立通信连接之前, 要先证明你是谁")]),t._v(". 在网络传输(Network)场景中的典型应用是基于 "),s("strong",[t._v("SSL/TLS 传输安全层")]),t._v("的认证.")]),t._v(" "),s("li",[s("strong",[t._v("通信协议上的认证")]),t._v(": 你请求"),s("strong",[t._v("获取我的资源之前, 要先证明你是谁")]),t._v(". 在互联网(Internet)场景中的典型应用是基于 "),s("strong",[t._v("HTTP 协议")]),t._v("的认证.")]),t._v(" "),s("li",[s("strong",[t._v("通信内容上的认证")]),t._v(": 你使用"),s("strong",[t._v("我提供的服务之前, 要先证明你是谁")]),t._v(". 在万维网(World Wide Web)场景中的典型应用是基于 "),s("strong",[t._v("Web 内容")]),t._v("的认证.")])]),t._v(" "),s("p",[t._v("关于"),s("strong",[t._v("通信信道")]),t._v("上的认证, 由于内容较多, 又与后续介绍"),s("strong",[t._v("微服务安全方面")]),t._v("的话题密切相关, 所以将独立放到后面介绍, 而且 J2EE 中的 Client-Cert 其实并不是用于 TLS 的, 以它引出 TLS 并不合适. 下面重点了解基于"),s("strong",[t._v("通信协议和通信内容")]),t._v("的两种认证方式.")]),t._v(" "),s("h6",{attrs:{id:"_1-http认证"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-http认证"}},[t._v("#")]),t._v(" (1)HTTP认证")]),t._v(" "),s("p",[s("strong",[t._v("认证方案")]),t._v("(Authentication Scheme), 指生成用户身份凭证的某种方法, 这个概念最初源于 HTTP 协议的认证框架(Authentication Framework).")]),t._v(" "),s("p",[t._v("IETF 在 RFC 7235 中定义了 HTTP 协议的通用认证框架, 要求所有支持 HTTP 协议的服务器, 在未授权的用户意图访问服务端保护区域的资源时, 应返回 401 Unauthorized 的状态码, 同时应在响应报文头里附带以下两个分别代表网页认证和代理认证的 Header 之一, 告知客户端应该采取何种方式产生"),s("strong",[t._v("能代表访问者身份的凭证信息")]),t._v(":")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("WWW-Authenticate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("<认证方案> realm=<保护区域的描述信息>")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Proxy-Authenticate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("<认证方案> realm=<保护区域的描述信息>")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("接收到该响应后, 客户端必须遵循服务端指定的认证方案, 在请求资源的报文头中加入"),s("strong",[t._v("身份凭证信息")]),t._v(", 由服务端核实通过后才会允许该请求正常返回, 否则将返回 403 Forbidden 错误. 请求头报文应包含以下 Header 项之一:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Authorization")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("<认证方案> <凭证内容>")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Proxy-Authorization")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("<认证方案> <凭证内容>")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v('HTTP 认证框架提出认证方案是希望能把认证 "'),s("strong",[t._v("要产生身份凭证")]),t._v('" 的目的与 "'),s("strong",[t._v("具体如何产生凭证")]),t._v('" 的实现分离开来, 无论客户端通过生物信息(指纹, 人脸), 用户密码, 数字证书抑或其他方式来生成凭证, 都属于如何生成凭证的具体实现, 都可以包含在 HTTP 协议预设的框架之内. HTTP 认证框架的工作流程如下图所示.')]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221126173246589.png",alt:"",title:"HTTP认证框架工作流程"}})]),t._v(" "),s("p",[t._v('以上概念性的介绍可能会有些枯燥抽象, 下面以最基础的认证方案 "'),s("strong",[t._v("HTTP Basic认证")]),t._v('" 为例来介绍认证是如何工作的. HTTP Basic 认证是一种主要以'),s("strong",[t._v("演示为目的")]),t._v("的认证方案, 也应用于一些不要求安全性的场合, 譬如家里的路由器登录等. Basic 认证产生用户身份凭证的方法是让用户"),s("strong",[t._v("输入用户名和密码")]),t._v(', 经过 Base64 编码 "加密" 后作为身份凭证. 譬如请求资源 "GET/admin" 后, 浏览器会收到来自服务端的如下响应:')]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token response-status"}},[s("span",{pre:!0,attrs:{class:"token http-version property"}},[t._v("HTTP/1.1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token status-code number"}},[t._v("401")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token reason-phrase string"}},[t._v("Unauthorized")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Date")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("Mon, 24 Feb 2020 16:50:53 GMT")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("WWW-Authenticate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v('Basic realm="example from icyfenix.cn"')])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("此时浏览器必须询问最终用户, 即弹出 HTTP Basic 认证对话框, 要求提供用户名和密码.")]),t._v(" "),s("p",[t._v('用户在对话框中输入密码信息, 譬如输入用户名 "icyfenix", 密码 "123456", 浏览器会将字符串 "icyfenix:123456" 编码为 "aWN5ZmVuaXg6MTIzNDU2", 然后发送给服务端, HTTP 请求如下所示:')]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token request-line"}},[s("span",{pre:!0,attrs:{class:"token method property"}},[t._v("GET")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token request-target url"}},[t._v("/admin")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token http-version property"}},[t._v("HTTP/1.1")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Authorization")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("Basic aWN5ZmVuaXg6MTIzNDU2")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("服务端接收到请求, 解码后检查用户名和密码"),s("strong",[t._v("是否合法")]),t._v(', 如果合法就返回 "/admin" 的资源, 否则就返回 403 Forbidden 错误, 禁止下一步操作. 注意 Base64 只是一种'),s("strong",[t._v("编码方式")]),t._v(", 并非任何形式的加密, 所以 Basic 认证的风险是显而易见的.")]),t._v(" "),s("p",[t._v("除 Basic 认证外, IETF 还定义了很多种可用于实际生产环境的认证方案, 列举如下.")]),t._v(" "),s("ul",[s("li",[t._v("Digest: RFC 7616, HTTP 摘要认证, 可视为 Basic 认证的改良版本. 针对 Base64 明文发送的风险, Digest 认证把"),s("strong",[t._v("用户名和密码加盐")]),t._v("(一个被称为 Nonce 的变化值作为盐值)后再通过 MD5/SHA 等哈希算法取摘要发送出去. 但是这种认证方式依然是不安全的, 无论客户端使用何种加密算法加密, 无论是否采用了 Nonce 这样的动态盐值去抵御重放和冒认, 遇到"),s("strong",[t._v("中间人攻击")]),t._v("时依然存在显著的安全风险.")]),t._v(" "),s("li",[t._v("Bearer: RFC 6750, 基于 OAuth 2 规范来完成认证. OAuth 2 是一个同时涉及认证与授权的协议.")]),t._v(" "),s("li",[t._v("HOBA(HTTP Origin-Bound Authentication): RFC 7486, 一种基于自签名证书的认证方案. 基于"),s("strong",[t._v("数字证书")]),t._v("的信任关系主要有两类模型: 一类是采用 CA(Certification Authority, 认证机构)层次结构的模型, 由 CA 中心签发证书; 另一种是以 IETF 的 Token Binding 协议为基础的 OBC(Origin Bound Certificate, 原产地证书)自签名证书模型.")])]),t._v(" "),s("p",[s("strong",[t._v("HTTP 认证框架中的认证方案是允许自行扩展的")]),t._v(", 并不要求一定由 RFC 规范来定义, 只要用户代理(User Agent, 通常是浏览器, 泛指任何使用 HTTP 协议的程序)能够识别这种私有的认证方案即可. 因此, 很多厂商也扩展了"),s("strong",[t._v("自己的认证方案")]),t._v(".")]),t._v(" "),s("ul",[s("li",[t._v("AWS4-HMAC-SHA256: 亚马逊 AWS 基于 HMAC-SHA256 哈希算法的认证.")]),t._v(" "),s("li",[t._v("NTLM/Negotiate: 微软公司 NT LAN Manager(NTLM) 用到的两种认证方式.")]),t._v(" "),s("li",[t._v('Windows Live ID: 微软公司开发并提供的"统一登入"认证.')]),t._v(" "),s("li",[t._v("Twitter Basic: Twitter 改良的 HTTP 基础认证.")])]),t._v(" "),s("h6",{attrs:{id:"_2-web认证"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-web认证"}},[t._v("#")]),t._v(" (2)Web认证")]),t._v(" "),s("p",[t._v("IETF 为 HTTP 认证框架设计了可插拔(Pluggable)的认证方案, 原本是希望能涌现出各式各样的认证方案去支持不同的应用场景. 尽管上节列举了一些还算常用的认证方案, 但目前的信息系统, 尤其是在系统对终端用户的认证场景中, "),s("strong",[t._v("直接采用 HTTP 认证框架的比例其实十分低")]),t._v('. 因为 HTTP 是"超文本传输协议", 传输协议的根本职责是把资源从服务端传输到客户端, 至于资源具体是什么内容, 只能由客户端自行解析驱动. 以 HTTP 协议为基础的认证框架也'),s("strong",[t._v("只能面向传输协议而不是具体传输内容来设计")]),t._v(", 如果用户想要从服务器中下载文件, 弹出一个 HTTP 服务器的对话框, 让用户登录是可接受的; 但如果用户想访问信息系统中的具体服务, 肯定希望身份认证是由系统本身的功能去完成, 而不是由 HTTP 服务器来负责认证. 这种"),s("strong",[t._v('依靠内容而不是传输协议来实现的认证方式, 在万维网里被称为 "Web认证"')]),t._v(" , 由于实现形式上"),s("strong",[t._v("登录表单")]),t._v('占了绝对的主流, 因此通常也被称为"'),s("strong",[t._v("表单认证")]),t._v('"(Form Authentication).')]),t._v(" "),s("p",[t._v("直至 2019 年以前, 表单认证都没有什么行业标准可循, 如表单是什么样, 其中的用户字段, 密码字段, 验证码字段是否要在客户端加密, 采用何种方式加密, 接受表单的服务地址是什么等, 都完全由服务端与客户端的开发者"),s("strong",[t._v("自行协商决定")]),t._v('. "没有标准的约束"反倒成了表单认证的一大优点, 它允许五花八门的页面, 各种程序语言, 框架或开发者本身都可以自行决定认证的全套交互细节.')]),t._v(" "),s("p",[t._v('开篇提到 "遵循规范, 别造轮子就是最恰当的安全", 这里又将表单认证的高自由度说成是一大优点, 好话都给说全了. 这里提倡用'),s("strong",[t._v("标准规范去解决安全领域的共性问题")]),t._v(", 这条原则完全没有必要与界面是否美观合理, 操作流程是否灵活便捷这些应用需求对立起来. 譬如, 想要支持密码或扫码等多种登录方式, 想要支持图形验证码来驱逐爬虫与机器人, 想要支持在登录表单提交之前进行必要的表单校验, 等等, 这些需求十分具体, 不具备写入标准规范的通用性, 却具备足够的合理性, 应当在实现层面去满足. 同时, 如何控制权限保证不产生越权操作, 如何传输信息保证内容不被窃听篡改, 如何加密敏感内容保证即使泄漏也不被逆推出明文等, 这些问题已有通行的解决方案, 并明确定义在规范之中, 也应当在"),s("strong",[t._v("架构层面去遵循")]),t._v(".")]),t._v(" "),s("p",[t._v("表单认证与 HTTP 认证不一定是完全对立的, 两者有不同的关注点, 可以结合使用. 以常见的登录功能为例, 页面表单通常是一个自行设计的 Vue.js 页面, 但认证的整个交互过程遵循 OAuth 2 规范的密码模式.")]),t._v(" "),s("p",[t._v("2019 年 3 月, 万维网联盟(World Wide Web Consortium, W3C) 批准了由 FIDO(Fast IDentity Online, 一个安全, 开放, 防钓鱼, 无密码认证标准的联盟)领导起草的世界首份 "),s("strong",[t._v("Web 内容认证")]),t._v('的标准 "'),s("strong",[t._v("WebAuthn")]),t._v('", 这里也许有读者会感到矛盾与奇怪, 不是刚说了 Web 表单是什么样, 要不要验证码, 登录表单是否在客户端校验等是十分具体的需求, 不太可能定义在规范上吗? 确实如此, 所以 WebAuthn 彻底抛弃了传统的密码登录方式, 改为'),s("strong",[t._v("直接采用生物识别")]),t._v("(指纹, 人脸, 虹膜, 声纹)或者"),s("strong",[t._v("实体密钥")]),t._v("(以 USB, 蓝牙, NFC 连接的物理密钥容器)来作为身份凭证, 从根本上消灭了用户输入错误产生的校验需求和防止机器人模拟产生的验证码需求等问题, 甚至可以省掉表单界面.")]),t._v(" "),s("p",[t._v("WebAuthn 相对复杂, 硬件方面, 要求用带有 TouchID 的 MacBook, 或者其他支持指纹,  FaceID 验证的手机; 软件方面, 直至 iOS 13.6, iPhone 和 iPad 仍未支持 WebAuthn, 但 Android 和 Mac OS 系统中的 Chrome, 以及 Windows 的 Edge 浏览器都已经支持使用 WebAuthn 了.")]),t._v(" "),s("p",[t._v('WebAuthn 规范涵盖了 "注册" 与 "认证" 两大流程.')]),t._v(" "),s("p",[t._v("先来看"),s("strong",[t._v("注册流程")]),t._v(", 它大致有以下步骤.")]),t._v(" "),s("p",[t._v("(1)用户进入系统的注册页面, 这个页面的格式, 内容和用户注册时需要填写的信息均不包含在 WebAuthn 标准的定义范围内.")]),t._v(" "),s("p",[t._v("(2)当用户填写完信息, 点击提交注册信息的按钮后, 服务端先暂存用户提交的数据, 生成一个"),s("strong",[t._v("随机字符串")]),t._v("(在规范中称作 Challenge)和用户的 UserID(在规范中称作凭证 ID), 并返回客户端.")]),t._v(" "),s("p",[t._v("(3)客户端的 WebAuthn API 接收到 Challenge 和 UserID 后, 把这些信息发送给验证器(Authenticator). 验证器可理解为用户设备上 TouchID, FaceID, 实体密钥等认证设备的统一接口.")]),t._v(" "),s("p",[t._v("(4)验证器提示用户进行验证, 如果支持多种认证设备, 还会提示用户选择一个想要使用的设备. 验证的结果是生成一个密钥对(公钥和私钥), 由验证器存储私钥, 用户信息以及当前的域名. 然后使用私钥对 Challenge 进行签名, 并将签名结果, UserID 和公钥一起返回客户端.")]),t._v(" "),s("p",[t._v("(5)浏览器将验证器返回的结果转发给服务器.")]),t._v(" "),s("p",[t._v("(6)服务器核验信息, 检查 UserID 与之前发送的是否一致, 并用公钥解密后得到的结果与之前发送的 Challenge 作对比, 一致即表明注册通过, 由服务端存储该 UserID 对应的公钥.")]),t._v(" "),s("p",[t._v("以上步骤的时序图如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221126214946671.png",alt:"",title:"WebAuthn注册流程时序图"}})]),t._v(" "),s("p",[s("strong",[t._v("登录流程")]),t._v("与注册流程类似, 大致可以分为以下步骤.")]),t._v(" "),s("p",[t._v("(1)用户访问登录页面, 填入用户名后即可点击登录按钮.")]),t._v(" "),s("p",[t._v("(2)服务器返回随机字符串 Challenge, 用户 UserID.")]),t._v(" "),s("p",[t._v("(3)浏览器将 Challenge 和 UserID 转发给"),s("strong",[t._v("验证器")]),t._v(".")]),t._v(" "),s("p",[t._v("(4)验证器提示"),s("strong",[t._v("用户进行认证操作")]),t._v(". 由于在注册阶段验证器已经"),s("strong",[t._v("存储了该域名的私钥和用户信息")]),t._v(", 所以如果域名和用户都相同的话, 就不需要生成密钥对了, 直接以存储的"),s("strong",[t._v("私钥加密 Challenge")]),t._v(", 然后返回浏览器.")]),t._v(" "),s("p",[t._v("(5)服务端接收到浏览器转发来的被私钥加密的 Challenge, 并以此前注册时存储的"),s("strong",[t._v("公钥进行解密")]),t._v(", 如果解密成功则宣告登录成功.")]),t._v(" "),s("p",[t._v("WebAuthn 采用"),s("strong",[t._v("非对称加密")]),t._v("的公钥, 私钥替代传统的密码, 这是非常理想的认证方案. 私钥是保密的, "),s("strong",[t._v("只有验证器需要知道它")]),t._v(", 连用户本人都不需要知道, 也就没有人为泄漏的可能. 公钥是公开的, 可以被任何人看到或存储. 公钥可用于验证私钥生成的签名, 但不能用来签名, 除了得知私钥外, 没有其他途径能够生成可被公钥验证为有效的签名, 这样服务器就可以通过公钥是否能够解密来判断最终用户的身份是否合法.")]),t._v(" "),s("p",[t._v("WebAuthn 还"),s("strong",[t._v("解决了传统密码在网络传输上的风险问题")]),t._v(", 因为无论密码是否在客户端进行加密以及如何加密, 对防御中间人攻击来说都是没有意义的. 更值得夸赞的是, WebAuthn 为登录过程带来极大的便捷性, 不仅注册和验证的用户体验十分优秀, 而且彻底避免了用户在一个网站上泄漏密码, 所有使用相同密码的网站都受到攻击的问题, 这个优点使得用户无须再为每个网站想不同的密码.")]),t._v(" "),s("p",[t._v("当前的 WebAuthn 还很年轻, 普及率暂时还很有限, 但相信几年之内它必定会发展成 Web 认证的主流方式, 被大多数网站和系统所支持.")]),t._v(" "),s("h5",{attrs:{id:"_2-认证的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-认证的实现"}},[t._v("#")]),t._v(" 2.认证的实现")]),t._v(" "),s("p",[t._v("了解了业界标准的"),s("strong",[t._v("认证规范")]),t._v("以后, 本节将简要介绍一下在 Java 技术体系内通常是如何实现安全认证的.")]),t._v(" "),s("p",[t._v("在今时今日, 实际活跃于 Java 安全领域的是两个私有的(私有的意思是不由 JSR 所规范的, 即没有 java/javax.* 作为包名)的安全框架: "),s("strong",[t._v("Apache Shiro")]),t._v(" 和 "),s("strong",[t._v("Spring Security")]),t._v(".")]),t._v(" "),s("p",[t._v("相较而言, Apache Shiro 更便捷易用, 而 Spring Security 的功能则更复杂强大一些. 只从目标上看, 两个安全框架提供的功能都很类似, 大致包括以下四类.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("认证功能")]),t._v(": 以 HTTP 协议中定义的各种认证, 表单等认证方式确认用户身份.")]),t._v(" "),s("li",[s("strong",[t._v("安全上下文")]),t._v(": 用户获得认证之后, 要开放一些接口, 让应用可以得知该用户的基本资料, 拥有的权限, 角色等等.")]),t._v(" "),s("li",[s("strong",[t._v("授权功能")]),t._v(": 判断并控制认证后的用户对什么资源拥有哪些操作许可.")]),t._v(" "),s("li",[s("strong",[t._v("密码的存储与验证")]),t._v(': 密码是"烫手的山芋", 无论是存储, 传输还是验证都应谨慎处理.')])]),t._v(" "),s("h4",{attrs:{id:"授权"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#授权"}},[t._v("#")]),t._v(" 授权")]),t._v(" "),s("p",[t._v("授权这个概念通常伴随着认证, 审计, 账号一同出现, 并称为 "),s("strong",[t._v("AAAA")]),t._v("(Authentication, Authorization, Audit, Account, 也有一些领域把 Account 解释为计费的意思).")]),t._v(" "),s("p",[t._v("授权行为在程序中的应用非常广泛, 给某个类或某个方法设置范围控制符("),s("code",[t._v("public, protected, private, <Package>")]),t._v("​)在本质上也是一种授权(访问控制)行为. 而在安全领域中所说的授权就更具体一些, 通常涉及以下两个相对独立的问题.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("确保授权的过程可靠")]),t._v(": 对于单一系统来说, 授权的过程是比较容易控制的, 以前很多语境上提到授权, 实质上讲的都是访问控制, 但理论上两者是应该分开的. 在涉及多方的系统中, 授权过程则是一个比较困难却必须严肃对待的问题: 如何既能让第三方系统访问到所需的资源, 又能保证其不泄露用户的敏感数据呢? 常用的"),s("strong",[t._v("多方授权协议主要有 OAuth 2")]),t._v(" 和 SAML 2.0.")]),t._v(" "),s("li",[s("strong",[t._v("确保授权的结果可控")]),t._v(": 授权的结果用于对程序功能或资源的访问控制(Access Control), 成理论体系的权限控制模型有很多, 譬如自主访问控制(Discretionary Access Control, DAC), 强制访问控制(Mandatory Access Control, MAC), 基于属性的访问控制(Attribute-Based Access Control, ABAC), 还有最为常用的基于角色的访问控制(Role-Based Access Control, RBAC).")])]),t._v(" "),s("p",[t._v("这里只介绍日常开发中最常用到的 RBAC 和 OAuth 2 这两种访问控制和授权方案.")]),t._v(" "),s("h5",{attrs:{id:"_1-rbac"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-rbac"}},[t._v("#")]),t._v(" 1.RBAC")]),t._v(" "),s("p",[t._v('所有的访问控制模型, 实质上都是在解决同一个问题: "'),s("strong",[t._v("谁(User)拥有什么权限(Authority)去操作(Operation)哪些资源(Resource)")]),t._v(' ".')]),t._v(" "),s("p",[t._v("这个问题初看起来并不难, 一种直观的解决方案就是在"),s("strong",[t._v("用户对象")]),t._v("上设定一些权限, 当用户使用资源时, 检查是否有对应的操作权限即可. 很多著名的安全框架, 譬如 Spring Security 的访问控制本质上就是这么做的. 不过, 这种"),s("strong",[t._v("把权限直接关联在用户身上")]),t._v("的简单设计, 在复杂系统上确实会导致一些比较烦琐的问题. 试想一下, 如果某个系统涉及成百上千的资源, 又有成千上万的用户, 若要为每个用户访问每个资源都分配合适的权限, 必定导致巨大的操作量和极高的出错概率, 这也正是 RBAC 所关注的问题之一.")]),t._v(" "),s("p",[t._v("为了避免对每一个用户设定权限, RBAC "),s("strong",[t._v("将权限从用户身上剥离")]),t._v(', 改为绑定到"'),s("strong",[t._v("角色")]),t._v('"(Role)上, 将权限控制变为对 "'),s("strong",[t._v("角色拥有操作哪些资源的许可")]),t._v('" 这个逻辑表达式的值是否为真的求解过程. RBAC 的主要元素的关系如下图表示.')]),t._v(" "),s("p",[t._v("​"),s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221126191558867.png",alt:"image-20221126191558867",title:"RBAC的主要元素的关系示意图"}}),t._v("​")]),t._v(" "),s("p",[t._v('"许可" 是抽象权限的具象化体现, 权限在 RBAC 系统中的含义是 "允许何种操作作用于哪些资源之上", 这句话的具体实例即为 "许可". 提出许可这个概念的目的其实与提出角色的目的是完全一致的, 只是更为抽象. '),s("strong",[t._v("角色为的是解耦用户与权限之间的多对多关系, 而许可为的是解耦操作与资源之间的多对多关系")]),t._v(", 譬如不同的数据都能够有增, 删, 改等操作, 如果将数据与操作搅和在一起也会面临配置膨胀问题.")]),t._v(" "),s("p",[t._v("采用 RBAC 不仅是为了"),s("strong",[t._v("简化配置操作")]),t._v(', 还天然地满足了计算机安全中的 "'),s("strong",[t._v("最小特权原则")]),t._v('"(Least Privilege). 在 RBAC 模型中, 角色拥有许可的数量是根据完成该角色工作职责所需的最小权限来赋予的, 最典型的例子是操作系统权限管理中的用户组, 根据对不同角色的职责分工, 如管理员(Administrator), 系统用户(System), 验证用户(Authenticated User), 普通用户(User), 来宾用户(Guest)等分配各自的权限, 既保证用户能够正常工作, 也避免用户出现越权操作的风险. 当'),s("strong",[t._v("用户的职责发生变化时, 在系统中就体现为它所隶属的角色被改变")]),t._v(', 譬如将 "普通用户角色" 改变 "管理员角色", 从而迅速让该用户具备管理员的多个细分权限, 降低权限分配错误的风险.')]),t._v(" "),s("p",[t._v("RBAC 还允许对不同角色之间定义关联与约束关系, 进一步强化它的抽象描述能力. 如不同的角色之间可以有"),s("strong",[t._v("继承性")]),t._v(", 典型的是 RBAC-1 模型的角色权限继承关系. 譬如描述开发经理应该和开发人员一样具有代码提交的权限, 描述开发人员都应该和任何公司员工一样具有食堂就餐的权限, 就可以直接将食堂就餐赋予到公司员工的角色上, 把代码提交赋予到开发人员的角色上, 再让开发人员的角色从公司员工派生, 开发经理的角色从开发人员中派生.")]),t._v(" "),s("p",[t._v("不同角色之间也可以具有"),s("strong",[t._v("互斥性")]),t._v(", 典型的是 RBAC-2 模型的角色职责分离关系. 互斥性要求权限被赋予角色时, 或角色被赋予用户时应遵循的强制性职责分离规定. 举个例子, 角色的互斥约束可限制同一用户只能分配到一组互斥角色集合中至多一个角色, 譬如不能让同一名员工既当会计, 也当出纳, 否则资金安全无法保证. 角色的基数约束可限制某一个用户拥有的最大角色数目, 譬如不能让同一名员工包揽产品, 设计, 开发, 测试角色, 否则产品质量无法保证.")]),t._v(" "),s("p",[s("strong",[t._v("建立访问控制模型的基本目的是管理垂直权限和水平权限")]),t._v(". 垂直权限即功能权限, 譬如前面提到的审稿编辑有通过审核的权限, 开发经理有代码提交的权限, 出纳有从账户提取资金的权限, 这一类某个角色完成某项操作的许可, 都可以直接翻译为功能权限. 由于实际应用与权限模型具有高度对应关系, 将权限从具体的应用中抽离出来, 放到通用的模型中是相对容易的, Spring Security, Apache Shiro 等权限框架就是这样的抽象产物, 大多数系统都能采用这些权限框架来管理功能权限.")]),t._v(" "),s("p",[t._v("与此相对, 水平权限即数据权限, 但管理起来要困难许多. 譬如用户 A, B 都属于同一个角色, 但它们各自在系统中产生的数据完全有可能是私有的, A 访问或删除了 B 的数据也照样属于越权. 一般来说, 数据权限是很难抽象与通用的, 仅在角色层面控制并不能满足全部业务的需要, 很多时候只能具体到用户, 甚至要具体管理到发生数据的某一行, 某一列之上, 因此数据权限基本只能由信息系统自主完成, 并不存在能放之四海皆准的通用数据权限框架.")]),t._v(" "),s("p",[s("strong",[t._v("Kubernetes 完全遵循了 RBAC 来进行服务访问控制")]),t._v(", Spring Security 也参考了(但并没有完全遵循) RBAC 来设计它的访问控制功能. 在 Spring Security 的设计里, 用户和角色都可以拥有权限, 譬如在它的 HttpSecurity 接口就同时有 hasRole() 和 hasAuthority() 方法. Spring Security 的访问控制模型如下图所示, 可与前面 RBAC 的关系图对比一下.")]),t._v(" "),s("p",[t._v("​"),s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221126192132821.png",alt:"image-20221126192132821",title:"Spring Security的访问控制模型"}}),t._v("​")]),t._v(" "),s("p",[t._v('从实现角度来看, Spring Security 中的角色和权限的差异很小, 它们完全共享同一套存储结构, 唯一的差别仅是角色会在存储时自动带上 "ROLE_" 前缀罢了. 但从使用角度来看, 角色和权限的差异可以很大, 用户可以自行决定系统中许可是只能对应到角色身上, 还是可以让用户也拥有某些角色中没有的权限. 这一点不符合 RBAC 的思想, 但其实这是一种创新而非破坏, 在 Spring Security 的文档上说得很清楚: 这取决于你自己如何使用.')]),t._v(" "),s("p",[t._v("补充: 角色和权限的核心差异取决于用户打算如何使用这些特性, 在框架层面它们的差别是极小的, 基本采用了完全相同的方式来进行处理.")]),t._v(" "),s("p",[t._v("通过 RBAC 很容易控制最终用户在广义和精细级别上能够做什么, 可以指定用户是管理员, 专家用户或普通用户, 并使角色和访问权限与组织中员工的身份职位保持一致, 仅根据需要为员工完成工作的最低限度来分配权限. 这些都是大量软件系统, 长时间积累下来的经验, 将这些经验运用在软件产品上, 绝大多数情况下要比自己发明, 创造一个新的轮子更加安全.")]),t._v(" "),s("h5",{attrs:{id:"_2-oauth-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-oauth-2"}},[t._v("#")]),t._v(" 2.OAuth 2")]),t._v(" "),s("p",[t._v("再来看看相对更复杂烦琐的 OAuth 2 认证授权协议. OAuth 2 是在 RFC 6749 中定义的国际标准, 在 RFC 6749 正文的第一句就阐明了 OAuth 2 是"),s("strong",[t._v("面向解决第三方应用(Third-Party Application)的认证授权协议")]),t._v(". 如果系统并不涉及第三方, 譬如单体架构的系统中如果就既不为第三方提供服务, 也不使用第三方的服务, 那引入 OAuth 2 其实并无必要. 为什么强调第三方? 在多方系统授权过程具体会有什么问题需要专门制订一个标准协议来解决呢?")]),t._v(" "),s("p",[t._v("下面举个现实的例子来解释.")]),t._v(" "),s("p",[t._v("譬如你现在正在阅读的这个网站(https://icyfenix.cn), 它的建设和更新的大致流程是: 作者以 Markdown 形式写好了某篇文章, 上传到由 GitHub 提供的代码仓库, 接着由 Travis-CI 提供的持续集成服务会检测到该仓库发生了变化, 触发一次 Vuepress 编译活动, 生成目录和静态的 HTML 页面, 然后推送回 GitHub Pages(GitHub 提供的一项主页托管服务), 再触发国内的 CDN 缓存刷新. 这个过程要能顺利进行, 就存在一系列必须解决的"),s("strong",[t._v("授权问题")]),t._v(", Travis-CI 只有得到了我的明确授权, GitHub 才能同意它读取代码仓库中的内容, 问题是它该如何获得我的授权呢? 一种最简单的方案是把我的用户账号和密码都告诉 Travis-CI, 但这显然导致了以下这些问题.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("密码泄漏")]),t._v(": 如果 Travis-CI 被黑客攻破, 将导致我的 GitHub 密码同时被泄漏.")]),t._v(" "),s("li",[s("strong",[t._v("访问范围")]),t._v(": Travis-CI 将有能力读取, 修改, 删除, 更新我放在 GitHub 上的所有代码仓库, 而我并不希望它修改, 删除文件.")]),t._v(" "),s("li",[s("strong",[t._v("授权回收")]),t._v(": 只有修改密码才能回收我授予给 Travis-CI 的权力, 可是我在 GitHub 的密码只有一个, 授权的应用除了 Travis-CI 之外却还有许多, 修改密码意味着所有别的第三方应用程序会全部失效.")])]),t._v(" "),s("p",[t._v("以上列举的这些问题, 也正是 OAuth 2 所要解决的问题, 尤其是要求"),s("strong",[t._v("第三方系统在没有支持 HTTPS 传输安全的环境下依然能够解决这些问题")]),t._v(", 这并非易事.")]),t._v(" "),s("p",[t._v("OAuth 2 给出了多种解决办法, 这些办法的共同特征是"),s("mark",[s("strong",[t._v("以令牌(Token)代替用户密码作为授权的凭证")])]),t._v(". 有了令牌之后, 哪怕令牌被泄漏, 也不会导致密码的泄漏; 令牌上可以设定访问资源的范围以及"),s("strong",[t._v("时效性")]),t._v("; 每个应用都持有独立的令牌, 任何一个失效都不会波及其他. 这样上面提出的三个问题就都解决了.")]),t._v(" "),s("p",[t._v("加令牌后的整个授权流程如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221126193420623.png",alt:"",title:"OAuth2-加令牌后的授权流程"}})]),t._v(" "),s("p",[t._v("这个流程图里面涉及了 OAuth 2 中的几个关键术语, 通过前面那个具体的上下文语境来解释其含义, 这对理解后续几种认证流程十分重要.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("第三方应用")]),t._v('(Third-Party Application): 需要得到授权访问我的资源的那个应用, 即此场景中的 "Travis-CI".')]),t._v(" "),s("li",[s("strong",[t._v("授权服务器")]),t._v("(Authorization Server): 能够根据我的意愿"),s("strong",[t._v("提供授权")]),t._v('(授权之前肯定已经进行了必要的认证过程, 但它与授权可以没有直接关系)的服务器, 即此场景中的 "GitHub".')]),t._v(" "),s("li",[s("strong",[t._v("资源服务器")]),t._v('(Resource Server): 能够提供第三方应用所需资源的服务器, 它与认证服务可以是相同的服务器, 也可以是不同的服务器, 即此场景中的 "我的代码仓库".')]),t._v(" "),s("li",[s("strong",[t._v("资源所有者")]),t._v('(Resource Owner): 拥有授权权限的人, 即此场景中的 "我".')]),t._v(" "),s("li",[s("strong",[t._v("操作代理")]),t._v("(User Agent): 指用户用来访问服务器的"),s("strong",[t._v("工具")]),t._v(", 对于人类用户来说, 这个通常是指浏览器, 但在微服务中一个服务经常会作为另一个服务的用户, 此时指的可能就是 HttpClient, RPCClient 或者其他访问途径.")])]),t._v(" "),s("p",[t._v('"用令牌代替密码" 确实是解决问题的好方法, 但这充其量只能算个思路, 距离可实施的步骤还是不够具体的, 流程图中的  '),s("strong",[t._v('"要求/同意授权", "要求/同意发放令牌", "要求/同意开放资源"')]),t._v("  的服务请求, 响应该如何设计, 这就是执行步骤的关键了. 对此, OAuth 2 一共提出了"),s("strong",[t._v("四种不同的授权方式")]),t._v("(这也是 OAuth 2 复杂烦琐的主要原因), 分别为:")]),t._v(" "),s("ul",[s("li",[t._v("授权码模式(Authorization Code);")]),t._v(" "),s("li",[t._v("隐式授权模式(Implicit);")]),t._v(" "),s("li",[t._v("密码模式(Resource Owner Password Credentials);")]),t._v(" "),s("li",[t._v("客户端模式(Client Credentials).")])]),t._v(" "),s("h6",{attrs:{id:"_1-授权码模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-授权码模式"}},[t._v("#")]),t._v(" (1)授权码模式")]),t._v(" "),s("p",[t._v("授权码模式是四种模式中"),s("strong",[t._v("最严谨")]),t._v("的, 它考虑到了几乎所有敏感信息泄漏的预防和后果. 具体的调用时序图如下图所示.")]),t._v(" "),s("p",[t._v("​"),s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221126214920309.png",alt:"image-20221126214920309",title:"OAuth2-授权码模式的调用时序图"}}),t._v("​")]),t._v(" "),s("p",[t._v("开始进行授权过程以前, "),s("strong",[t._v("第三方应用先要到授权服务器上进行注册")]),t._v(". 所谓注册, 是指向认证服务器提供一个"),s("strong",[t._v("域名地址")]),t._v(", 然后从授权服务器中获取 "),s("strong",[t._v("ClientID 和 ClientSecret")]),t._v(", 以便能够顺利完成如下授权过程.")]),t._v(" "),s("p",[t._v("(1)第三方应用将资源所有者(用户)导向授权服务器的"),s("strong",[t._v("授权页面")]),t._v(", 并向授权服务器提供 ClientID 及用户同意授权后的"),s("strong",[t._v("回调 URI")]),t._v(", 这是第一次客户端页面转向.")]),t._v(" "),s("p",[t._v("(2)授权服务器根据 ClientID "),s("strong",[t._v("确认第三方应用的身份")]),t._v(", 用户在授权服务器中决定是否同意向该身份的应用进行授权, 注意, 用户认证的过程未定义在此步骤中, 在此之前应该已经完成.")]),t._v(" "),s("p",[t._v("(3)如果用户同意授权, 授权服务器将转向第三方应用在第 (1) 步调用中提供的回调 URI, 并附带上一个授权码和获取令牌的地址作为参数, 这是第二次客户端页面转向.")]),t._v(" "),s("p",[t._v("(4)第三方应用通过回调地址收到授权码, 然后将授权码与自己的 ClientSecret 一起作为参数, 通过服务器向授权服务器提供的获取令牌的服务地址发起请求, 换取令牌. 该服务器的地址应与注册时提供的域名处于同一个域中.")]),t._v(" "),s("p",[t._v("(5)授权服务器核对授权码和 ClientSecret, 确认无误后, 向第三方应用授予令牌. 令牌可以是一个或两个, 其中必定要有的是"),s("strong",[t._v("访问令牌(Access Token)")]),t._v(" , 可选的是刷新令牌(Refresh Token). 访问令牌用于到资源服务器获取资源, 有效期较短; 刷新令牌用于在访问令牌失效后重新获取, 有效期较长.")]),t._v(" "),s("p",[t._v("(6)资源服务器根据访问令牌所允许的权限, 向第三方应用提供资源.")]),t._v(" "),s("p",[t._v("这个过程已经考虑到了"),s("strong",[t._v("几乎所有合理的意外情况")]),t._v(", 笔者再举几个最容易遇到的意外状况, 以便更好地理解为何要这样设计 OAuth 2.")]),t._v(" "),s("p",[s("strong",[t._v("(1)会不会有其他应用冒充第三方应用骗取授权?")])]),t._v(" "),s("p",[t._v('ClientID 代表一个第三方应用的"用户名", 这项信息是可以'),s("strong",[t._v("完全公开")]),t._v('的. 但 ClientSecret 应当只有应用自己知道, 这代表了第三方应用的 "密码". 在第 (5) 步发放令牌时, 调用者必须能够提供 ClientSecret 才能成功完成. 只要第三方应用妥善保管好 ClientSecret, 就没有人能够冒充它.')]),t._v(" "),s("p",[s("strong",[t._v("(2)为什么要先发放授权码, 再用授权码换令牌?")])]),t._v(" "),s("p",[t._v("这是因为客户端转向(通常就是一次 HTTP 302 重定向)对于用户是可见的, 换言之, 授权码可能会暴露给用户以及用户机器上的其他程序, 但由于用户并没有 ClientSecret, 而"),s("strong",[t._v("只有授权码是无法换取到令牌的")]),t._v(", 所以避免了令牌在传输转向过程中被泄漏的风险.")]),t._v(" "),s("p",[s("strong",[t._v("(3)为什么要设计一个时限较长的刷新令牌和时限较短的访问令牌? 不能直接把访问令牌的时间调长吗?")])]),t._v(" "),s("p",[t._v("这是为了缓解 OAuth 2 在实际应用中的一个主要缺陷, 通常访问令牌一旦发放, 除非超过了令牌中的有效期, 否则很难(需要付出较大代价)有其他方式让它失效, 所以"),s("strong",[t._v("访问令牌的时效性一般设计的比较短")]),t._v(", 譬如几个小时, 如果还需要继续用, 那就定期用"),s("strong",[t._v("刷新令牌去更新")]),t._v(', 这样授权服务器就可以在更新过程中决定是否要继续给予授权. 至于为什么说很难让它失效, 在后面 "凭证" 小节中进行解释.')]),t._v(" "),s("p",[t._v("尽管授权码模式是严谨的, 但是它还不够好, 这不仅仅体现在它那"),s("strong",[t._v("繁复的调用过程")]),t._v('上, 还体现在它对第三方应用提出了一个 "貌似不难" 的要求: '),s("strong",[t._v("第三方应用必须有应用服务器")]),t._v(", 因为第 (4) 步要发起服务端转向, 而且要求"),s("strong",[t._v("服务端的地址必须与注册时提供的地址在同一个域")]),t._v("内. 不要觉得要求一个系统有应用服务器是理所当然的事情, 比如用 GitPage 就没有任何应用服务器的支持, 里面使用到了 Gitalk 作为每篇文章的留言板, 它对 GitHub 来说照样是第三方应用, 需要 OAuth 2 授权来解决. 除基于浏览器的应用外, 现在越来越普遍的是移动或桌面端的客户端 Web 应用(Client-Side Web Application), 譬如现在大量基于 Cordova, Electron, Node-Webkit.js 的 PWA 应用, 它们都"),s("strong",[t._v("没有应用服务器")]),t._v("的支持. 由于有这样的实际需求, 因此引出了 OAuth 2 的第二种授权模式: "),s("strong",[t._v("隐式授权")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_2-隐式授权模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-隐式授权模式"}},[t._v("#")]),t._v(" (2)隐式授权模式")]),t._v(" "),s("p",[s("strong",[t._v("隐式授权省略掉了通过授权码换取令牌的步骤")]),t._v(", 整个授权过程"),s("strong",[t._v("都不需要服务端支持")]),t._v(", 一步到位. 代价是在隐式授权中, 授权服务器"),s("strong",[t._v("不会再去验证第三方应用的身份")]),t._v(", 因为已经没有应用服务器了,  ClientSecret 没有人保管, 也就没有存在的意义. 但其实还是会限制第三方应用的回调 URI 地址必须与注册时提供的域名一致, 尽管有可能被 DNS 污染之类的攻击所攻破. 同样, 隐式授权也不能避免令牌暴露给资源所有者, 不能避免用户机器上可能出现的意图不轨的其他程序, HTTP 的中间人攻击等风险了.")]),t._v(" "),s("p",[t._v("隐式授权的调用时序如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221126214904591.png",alt:"image-20221126214904591",title:"OAuth2-隐式授权模式的调用时序图"}})]),t._v(" "),s("p",[t._v("在上述交互过程里, 隐式模式与授权码模式的"),s("strong",[t._v("显著区别是授权服务器在得到用户授权后, 直接返回了访问令牌")]),t._v(", 这显著降低了安全性, 但 OAuth 2 仍然努力以尽可能地做到相对安全, 譬如在前面提到的隐私授权中, 尽管不需要用到服务端, 但仍然需要在注册时提供回调域名, 此时会要求该域名与接受令牌的服务处于同一个域内. 此外, 同样基于安全考虑, "),s("strong",[t._v("在隐私模式中明确禁止发放刷新令牌")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_3-密码模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-密码模式"}},[t._v("#")]),t._v(" (3)密码模式")]),t._v(" "),s("p",[t._v("前面所说的授权码模式和隐私模式属于"),s("strong",[t._v("纯粹的授权模式")]),t._v(", 它们与认证没有直接联系, 即认证与授权是互相独立的过程. 但在"),s("strong",[t._v("密码模式里, 认证和授权就被整合到同一个过程中")]),t._v(".")]),t._v(" "),s("p",[t._v("密码模式原本的设计意图是"),s("strong",[t._v("仅限用于用户对第三方应用是高度可信任的场景中")]),t._v(", 因为用户需要"),s("strong",[t._v("把密码明文提供给第三方应用")]),t._v(', 由第三方以此向授权服务器获取令牌. 这种高度可信的第三方是极为罕见的, 尽管在介绍 OAuth 2 的材料中, 经常举的例子是 "操作系统作为第三方应用向授权服务器申请资源", 但在真实应用中极少遇到这样的情况, 合理性依然十分有限.')]),t._v(" "),s("p",[t._v('一般来说, 如果要采用密码模式, 那 "第三方" 属性就必须弱化, 把 "第三方" 视作系统中'),s("strong",[t._v("与授权服务器相对独立的子模块")]),t._v(", 在物理上独立于授权服务器部署, 但是在逻辑上与授权服务器仍同属一个系统, 这样将认证和授权一并完成的密码模式才会有合理的应用场景.")]),t._v(" "),s("p",[t._v("理解了密码模式的用途, 它的调用过程就很容易理解了, 就是"),s("strong",[t._v("第三方应用拿着用户名和密码向授权服务器换令牌而已")]),t._v(".")]),t._v(" "),s("p",[t._v("具体调用时序图如下图所示.")]),t._v(" "),s("p",[t._v('密码模式下"如何保障安全"的职责无法由OAuth 2来承担, 只能由用户和第三方应用来自行保障, 尽管OAuth 2在规范中强调"此模式下, 第三方应用不得保存用户的密码", 但这并没有任何技术上的约束力.')]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221126214847238.png",alt:"",title:"OAuth2-密码模式的调用时序图"}})]),t._v(" "),s("h6",{attrs:{id:"_4-客户端模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-客户端模式"}},[t._v("#")]),t._v(" (4)客户端模式")]),t._v(" "),s("p",[t._v("客户端模式是四种模式中最简单的, 它只涉及两个主体: "),s("strong",[t._v("第三方应用和授权服务器")]),t._v('. 如果严谨一点, 现在称 "第三方应用" 其实已经不合适了, 因为已经没有了 "第二方" 的存在, 资源所有者, 操作代理在客户端模式中都是不必出现的, 甚至严格来说叫 "授权" 都已不太恰当, 资源所有者都没有了, 也就不会有谁授予谁权限的过程.')]),t._v(" "),s("p",[s("strong",[t._v("客户端模式是指第三方应用(行文一致考虑, 还是继续沿用这个称呼)以自己的名义, 向授权服务器申请资源许可")]),t._v(". 此模式通常用于管理操作或者自动处理类型的场景中. 举个具体例子, 譬如笔者开了一家叫Fenix’s Bookstore的书店, 因为小本经营, 不像京东那样全国多个仓库可以调货, 因此必须保证只要客户成功购买, 书店就必须有货可发, 不允许超卖. 但有顾客下了订单又拖着不付款的情况, 导致部分货物处于冻结状态. 所以Fenix’s Bookstore中有一个订单清理的定时服务, 自动清理超过两分钟还未付款的订单. 在这个场景里, 订单肯定是属于下单用户自己的资源, 如果把订单清理服务看作一个独立的第三方应用的话, 它是不可能向下单用户去申请授权来删掉订单的, 而是应该直接以自己的名义向授权服务器申请一个能清理所有用户订单的授权. 客户端模式的调用时序图如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221126215936219.png",alt:""}})]),t._v(" "),s("p",[t._v("微服务架构并"),s("strong",[t._v("不提倡同一个系统的各服务间有默认的信任关系")]),t._v(", 所以服务之间调用也需要先进行认证授权, 然后才能通信. 此时, "),s("strong",[t._v("客户端模式便是一种常用的服务间认证授权的解决方案")]),t._v(".")]),t._v(" "),s("h4",{attrs:{id:"凭证"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#凭证"}},[t._v("#")]),t._v(" 凭证")]),t._v(" "),s("p",[t._v("OAuth 2 中, 每一种授权模式的最终目标都是拿到"),s("strong",[t._v("访问令牌")]),t._v(", 但从未涉及过拿回来的"),s("strong",[t._v("令牌应该长什么样子")]),t._v(". 反而还挖了一些坑没有填, 比如为何说 OAuth 2 的一个主要缺陷是"),s("strong",[t._v("令牌难以主动失效")]),t._v(".")]),t._v(" "),s("p",[t._v("这里讨论的主角是"),s("strong",[t._v("令牌")]),t._v(", 同时还会讨论如果不使用 OAuth 2, 如何以最传统的方式完成认证, 授权.")]),t._v(" "),s("p",[t._v('对 "'),s("strong",[t._v("如何承载认证授权信息")]),t._v('" 这个问题的不同看法, 代表了软件架构对待共享状态信息的两种不同思路: '),s("strong",[t._v("状态应该维护在服务端, 还是在客户端")]),t._v("之中? 在分布式系统崛起以前, 这个问题原本已有了较为统一的结论, 即以 HTTP 协议的 "),s("strong",[t._v("Cookie-Session")]),t._v(" 机制为代表的服务端状态存储在分布式崛起前的三十年中都是主流的解决方案. 不过到了最近十年, 由于分布式系统中共享数据必然会受到 CAP 不兼容原理的打击限制, 迫使人们重新去审视之前已基本放弃掉的客户端状态存储, 这就让原本只在多方系统中采用的 "),s("strong",[t._v("JWT")]),t._v(" 令牌方案, 在分布式系统中也有了另一块用武之地.")]),t._v(" "),s("p",[t._v("所以本节将围绕 Cookie-Session 和 JWT 之间的相同与不同而展开.")]),t._v(" "),s("h5",{attrs:{id:"_1-cookie-session"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-cookie-session"}},[t._v("#")]),t._v(" 1.Cookie-Session")]),t._v(" "),s("p",[t._v("HTTP 协议是一种"),s("strong",[t._v("无状态")]),t._v("的传输协议, 无状态是指"),s("strong",[t._v("协议对事务处理没有上下文的记忆能力")]),t._v(", 每一个请求都是完全独立的. 肯定有许多人并没有意识到 HTTP 协议无状态的重要性, 也就是为什么要设计成无状态的?")]),t._v(" "),s("p",[t._v("假如你做了一个简单的网页, 其中包含 1 个 HTML, 2 个 Script 脚本, 3 个 CSS, 还有 10 张图片, 若要这个网页成功展示在用户屏幕前, 需要完成 16 次与服务端的交互来获取上述资源, 由于网络传输等各种因素的影响, 服务器发送的"),s("strong",[t._v("顺序与客户端请求的先后并没有必然的联系")]),t._v(", 按照可能出现的响应顺序, 理论上最多会有 P(16, 16) = 20922789888000 种可能性. 试想一下, 如果 HTTP 协议"),s("strong",[t._v("不是设计成无状态的")]),t._v(", 这 16 次请求每一次都有依赖关联, 先调用哪一个, 先返回哪一个, 都会对结果产生影响的话, 那协调工作会多么复杂.")]),t._v(" "),s("p",[t._v("可是, HTTP 协议的无状态特性又有悖于最常见的网络应用场景, 典型就是"),s("strong",[t._v("认证授权")]),t._v(", 系统总得要获知用户身份才能提供合适的服务, 因此也希望 HTTP 能有一种手段, 让服务器至少能够"),s("strong",[t._v("区分出发送请求的用户是谁")]),t._v(". 为了实现这个目的, RFC 6265 规范定义了 HTTP 的"),s("strong",[t._v("状态管理机制")]),t._v(", 在 HTTP 协议中增加了 "),s("strong",[t._v("Set-Cookie 指令")]),t._v(", 该指令的含义是以"),s("strong",[t._v("键值对的方式向客户端发送一组信息, 此信息将在此后一段时间内的每次 HTTP 请求中, 以名为 Cookie 的 Header 附带着重新发给服务端, 以便服务端区分来自不同客户端的请求")]),t._v(". 一个典型的 Set-Cookie 指令如下所示:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Set-Cookie")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("id=nano; Expires=Wed, 21 Feb 2020 07:28:00 GMT; Secure; HttpOnly")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("收到该指令以后, 客户端再对"),s("strong",[t._v("同一个域")]),t._v('的请求回传时就会自动附带键值对信息 "id=icyfenix", 譬如以下代码所示:')]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token request-line"}},[s("span",{pre:!0,attrs:{class:"token method property"}},[t._v("GET")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token request-target url"}},[t._v("/index.html")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token http-version property"}},[t._v("HTTP/2.0")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Host")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("nanodaemon.cn")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Cookie")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("id=nano")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("根据每次请求传到服务端的 Cookie, 服务端就能分辨出请求来自于哪一个用户. 由于 Cookie 是放在"),s("strong",[t._v("请求头")]),t._v("上的, 属于额外的传输负担, 不应该携带过多的内容, 而且放在 Cookie 中"),s("strong",[t._v("传输并不安全")]),t._v(', 容易被中间人窃取或被篡改, 所以通常不会设置例子中 "id=nano" 这样的明文信息.')]),t._v(" "),s("p",[t._v("一般来说, 系统会把"),s("strong",[t._v("状态信息保存在服务端")]),t._v(", 在 Cookie 里只传输一个"),s("strong",[t._v("无字面意义的, 不重复的字符串")]),t._v(", 习惯上以 sessionid 或者 jsessionid 为名, 然后服务端会把这个"),s("strong",[t._v("字符串作为 Key, 以 Key/Entity 的结构存储每一个在线用户的上下文状态")]),t._v(", 再辅以一些"),s("strong",[t._v("超时自动清理")]),t._v("之类的管理措施. 这种服务端的状态管理机制就是今天大家非常熟悉的 "),s("strong",[t._v("Session")]),t._v(", Cookie-Session 也即最传统但今天依然广泛应用于大量系统中的, 由"),s("strong",[t._v("服务端与客户端联动来完成的状态管理机制")]),t._v(".")]),t._v(" "),s("p",[t._v('Cookie-Session 方案在本章的主题"安全性"上其实是有一定先天优势的: '),s("strong",[t._v("状态信息都存储于服务端, 只要依靠客户端的同源策略和 HTTPS 的传输层安全, 保证 Cookie 中的键值不被窃取而出现被冒认身份的情况, 就能完全规避掉信息在传输过程中被泄漏和篡改的风险")]),t._v(". Cookie-Session 方案的另一大优点是服务端有主动的状态管理能力, 可根据自己的意愿随时修改, 清除任意上下文信息, 譬如很轻易就能实现强制某用户下线的功能.")]),t._v(" "),s("p",[s("strong",[t._v("Session-Cookie 在单节点的单体服务环境中是最合适的方案")]),t._v(", 但当需要"),s("strong",[t._v("水平扩展")]),t._v("服务能力, 要部署集群时就比较麻烦了, 由于 Session 存储在服务器的内存中, 当"),s("strong",[t._v("服务器水平拓展成多节点")]),t._v("时, 当考虑分布式的数据同步时, 设计者必须在以下三种方案中选择其一.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("牺牲集群的一致性")]),t._v(", 让负载均衡器采用亲和式的负载均衡算法, 譬如根据用户 IP 或者 Session 来分配节点, 每一个特定用户发出的所有请求都一直被分配到其中某一个节点来提供服务, 每个节点都不重复地保存着一部分用户的状态, 如果这个节点崩溃了, 里面的用户状态便完全丢失.")]),t._v(" "),s("li",[s("strong",[t._v("牺牲集群的可用性")]),t._v(", 让各个节点之间采用"),s("strong",[t._v("复制式")]),t._v("的 Session, 每一个节点中的 Session 变动都会发送到组播地址的其他服务器上, 这样即使某个节点崩溃了, 也不会中断某个用户的服务, 但 Session 之间组播复制的同步代价高昂, 节点越多时, 同步成本越高.")]),t._v(" "),s("li",[s("strong",[t._v("牺牲集群的分区容忍性")]),t._v(", 让普通的服务节点中不再保留状态, 将上下文集中放在一个"),s("strong",[t._v("所有服务节点")]),t._v("都能访问到的数据节点中进行存储. 此时的矛盾是"),s("strong",[t._v("数据节点成为单点")]),t._v(", 一旦数据节点损坏或出现网络分区, 整个集群将都不能再提供服务.")])]),t._v(" "),s("p",[t._v("只要在分布式系统中共享信息, CAP 就不可兼得, 所以分布式环境中的状态管理一定会受到 CAP 的限制, 无论怎样都不可能完美. 但如果只是解决分布式下的认证授权问题, 并顺带解决少量状态的问题, 就"),s("strong",[t._v("不一定只能依靠共享信息去实现")]),t._v(". 这句话的言外之意是接下来的 JWT 令牌与 Cookie-Session 并不是完全对等的解决方案, JWT 令牌只用来"),s("strong",[t._v("处理认证授权问题")]),t._v(", 充其量只能"),s("strong",[t._v("携带少量非敏感的信息")]),t._v(", 是 Cookie-Session 在"),s("strong",[t._v("认证授权问题上的替代品")]),t._v(", 而"),s("strong",[t._v("不能说 JWT 要比 Cookie-Session 更先进, 更不可能说 JWT 可以全面取代 Cookie-Session 机制")]),t._v(".")]),t._v(" "),s("h5",{attrs:{id:"_2-jwt"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-jwt"}},[t._v("#")]),t._v(" 2.JWT")]),t._v(" "),s("p",[t._v("Cookie-Session 机制在分布式环境下会遇到 CAP 不可兼得的问题, 而在"),s("strong",[t._v("多方系统")]),t._v("中, 就更不可能谈 Session 层面的数据共享了, 哪怕服务端之间能共享数据, 客户端的 Cookie 也"),s("strong",[t._v("没法跨域")]),t._v(". 所以不得不重新捡起最初被抛弃的思路, "),s("strong",[t._v("当服务器存在多个, 客户端只有一个时, 把状态信息存储在客户端, 每次随着请求发回服务器去")]),t._v(". 前面说过, 这样做的缺点是无法携带大量信息, 而且有泄漏和篡改的安全风险. "),s("strong",[t._v("信息量受限的问题并没有太好的解决办法, 不过要确保信息不被中间人篡改则还是可以实现的, JWT 便是这个问题的标准答案")]),t._v(".")]),t._v(" "),s("p",[t._v("JWT(JSON Web Token)定义于 RFC 7519 标准之中, 是目前广泛使用的一种"),s("strong",[t._v("令牌格式")]),t._v(", 尤其经常"),s("strong",[t._v("与 OAuth 2 配合")]),t._v("应用于分布式的, 涉及多方的应用系统中. 介绍 JWT 的具体构成之前, 先来直观地看一下它是什么样子的, 如下图所示.")]),t._v(" "),s("p",[t._v("​"),s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221127140146305.png",alt:"image-20221127140146305"}}),t._v("​")]),t._v(" "),s("p",[t._v("以上截图来自 JWT 官网(https://jwt.io) 的示例. 右边的 JSON 结构是 JWT 令牌中携带的信息, 左边的字符串呈现了 JWT 令牌的本体. 它最常见的使用方式是"),s("strong",[t._v("附在名为 Authorization 的 Header 发送给服务端")]),t._v(", 前缀在 RFC 6750 中被规定为 "),s("strong",[t._v("Bearer")]),t._v('. 如果你没有忘记 "认证方案" 与 "OAuth 2" 的内容, 那看到 Authorization 这个 Header 与 Bearer 这个'),s("strong",[t._v("前缀")]),t._v("时, 便应意识到它是 "),s("strong",[t._v("HTTP 认证框架中的 OAuth 2 认证方案")]),t._v(". 如下代码展示了一次采用 JWT 令牌的 HTTP 实际请求:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token request-line"}},[s("span",{pre:!0,attrs:{class:"token method property"}},[t._v("GET")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token request-target url"}},[t._v("/restful/products/1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token http-version property"}},[t._v("HTTP/1.1")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Host")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("icyfenix.cn")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Connection")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("keep-alive")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Authorization")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("Bearer \\\\ eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJpY3lmZW5peCIsInNjb3BlIjpbIkFMTCJdLCJleHAiOjE1ODQ5NDg5NDcsImF1dGhvcml0aWVzIjp    bIlJPTEVfVVNFUiIsIlJPTEVfQURNSU4iXSwianRpIjoiOWQ3NzU4NmEtM2Y0Zi00Y2JiLTk5MjQtZmUyZjc3ZGZhMzNkIiwiY2xpZW50X2lkIjoiYm9va3N0b3JlX2Zyb250ZW5kIiwidXNlcm5hbWUiOiJpY3lmZW5peCJ9.539WMzbjv63wBtx4ytYYw_Fo1ECG_9vsgAn8bheflL8")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("前面的 JWT 格式图中右边的状态信息是对令牌使用 Base64URL 转码后得到的"),s("strong",[t._v("明文")]),t._v(", 请特别注意是明文, "),s("strong",[t._v("JWT 只解决篡改的问题, 并不解决泄漏的问题, 因此令牌默认是不加密的")]),t._v(". 如果自己要加密也不难做到, 接收时自行解密即可, 但这样做其实没有太大意义, 具体原因将在后面阐述.")]),t._v(" "),s("p",[t._v("从明文中可以看到 JWT 令牌是以 JSON 结构(毕竟名字就叫 JSON Web Token)存储的, 该结构总体上可划分为"),s("strong",[t._v("三个部分")]),t._v(', 每个部分间用点号 "." 分隔开. 第一部分是'),s("strong",[t._v("令牌头")]),t._v("(Header), 内容如下所示:")]),t._v(" "),s("div",{staticClass:"language-json line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"alg"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"HS256"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"typ"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"JWT"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("它描述了"),s("strong",[t._v("令牌的类型")]),t._v("(统一为 typ:JWT) 以及"),s("strong",[t._v("令牌签名的算法")]),t._v(", 示例中 HS256 为 HMAC SHA256 算法的缩写, 其他各种系统支持的签名算法则可以参考 JWT 官网.")]),t._v(" "),s("p",[s("strong",[t._v("散列消息认证码")]),t._v(': 后面经常会在某种哈希算法前出现 "HMAC" 的前缀, 这是指'),s("strong",[t._v("散列消息认证码")]),t._v("(Hash-based Message Authentication Code, HMAC). 可以简单将它理解为一种"),s("strong",[t._v("带有密钥的哈希摘要算法")]),t._v(", 其实现形式上通常是把密钥以加盐方式混入, 与内容一起做哈希摘要.")]),t._v(" "),s("p",[t._v("HMAC 哈希与普通哈希算法的差别是普通的哈希算法通过 Hash 函数结果易变性保证了原有内容未被篡改, 而 "),s("strong",[t._v("HMAC 不仅保证了内容未被篡改, 还保证了该哈希确实是由密钥的持有人所生成")]),t._v("的. 如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221218203101601.png",alt:""}})]),t._v(" "),s("p",[t._v("令牌的第二部分是"),s("strong",[t._v("负载")]),t._v('(Payload), 这是令牌真正需要向服务端传递的信息. 针对认证问题, 负载至少应该包含能够告知服务端"'),s("strong",[t._v("这个用户是谁")]),t._v('"的信息; 针对授权问题, 令牌至少应该包含能够告知服务端"'),s("strong",[t._v("这个用户拥有什么角色/权限")]),t._v('"的信息. JWT 的负载部分是可以'),s("strong",[t._v("完全自定义")]),t._v("的, 根据具体要解决的问题不同, 设计自己所需要的信息, 只是总容量不能太大, 毕竟要受到 HTTP Header 大小的限制. 一个 JWT 负载的例子如下所示:")]),t._v(" "),s("div",{staticClass:"language-json line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"username"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"icyfenix"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"authorities"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ROLE_USER"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ROLE_ADMIN"')]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"scope"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ALL"')]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"exp"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1584948947")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"jti"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"9d77586a-3f4f-4cbb-9924-fe2f77dfa33d"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"client_id"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bookstore_frontend"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br")])]),s("p",[t._v("JWT 在 RFC 7519 中推荐(非强制约束)了七项声明名称, 如需要用到这些内容, "),s("strong",[t._v("建议字段名与官方的保持一致")]),t._v(".")]),t._v(" "),s("ul",[s("li",[t._v("iss(Issuer): 签发人.")]),t._v(" "),s("li",[t._v("exp(Expiration Time): 令牌过期时间.")]),t._v(" "),s("li",[t._v("sub(Subject): 主题.")]),t._v(" "),s("li",[t._v("aud(Audience): 令牌受众.")]),t._v(" "),s("li",[t._v("nbf(Not Before): 令牌生效时间.")]),t._v(" "),s("li",[t._v("iat(Issued At): 令牌签发时间.")]),t._v(" "),s("li",[t._v("jti(JWT ID): 令牌编号.")])]),t._v(" "),s("p",[t._v("令牌的第三部分是"),s("strong",[t._v("签名")]),t._v("(Signature), 签名的意思是: 使用在对象头中公开的特定签名算法, 通过特定的"),s("strong",[t._v("密钥")]),t._v("(由服务器进行保密, 不能公开)对前面两部分内容进行加密计算, 以例子里使用的 JWT 默认的 HMAC SHA256 算法为例, 将通过以下公式产生签名值:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[t._v('HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload) , secret)\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[s("strong",[t._v("签名的意义在于确保负载中的信息是可信的")]),t._v(", 没有被篡改的, 也没有在传输过程中丢失任何信息的. 因为被签名的内容哪怕发生了一个字节的变动, 也会导致整个签名发生显著变化. 此外, 由于"),s("strong",[t._v("签名这件事情只能由认证授权服务器完成")]),t._v("(只有它知道密钥), 任何人都无法在篡改后重新计算出合法的签名值, 所以服务端才能够完全信任客户端传上来的 JWT 中的负载信息.")]),t._v(" "),s("p",[t._v("JWT 默认的签名算法 HMAC SHA256 是一种"),s("strong",[t._v("带密钥的哈希摘要算法")]),t._v(", 加密与验证过程均只能由"),s("strong",[t._v("中心化")]),t._v("的授权服务来提供, 所以这种方式一般只适合于授权服务与应用服务处于同一个进程中的单体应用. 在多方系统或者授权服务与资源服务分离的分布式应用中, 通常会采用"),s("strong",[t._v("非对称加密算法")]),t._v("来进行签名, 这时候除了授权服务端持有的可以用于签名的私钥外, 还会对其他服务器公开一个公钥, 公开方式一般遵循 JSON Web Key 规范. 公钥不能用来签名, 但是能被其他服务用于验证签名是否由私钥所签发. 这样其他服务器就能不依赖授权服务器, 无须远程通信即可独立判断 JWT 令牌中的信息的真伪.")]),t._v(" "),s("p",[t._v("JWT 令牌是"),s("strong",[t._v("多方系统中一种优秀的凭证载体")]),t._v(", 它不需要任何一个服务节点保留任何一点状态信息, 就能够保障认证服务与用户之间的承诺是双方当时真实意图的体现, 是"),s("strong",[t._v("准确, 完整, 不可篡改, 且不可抵赖")]),t._v("的. 同时, 由于 JWT 本身可以携带少量信息, 这十分有利于 RESTful API 的设计, 能够较容易地做成无状态服务, 在做水平扩展时就不需要像前面 Cookie-Session 方案那样考虑如何部署的问题. 现实中也确实有一些项目直接采用 JWT 来承载上下文以实现完全无状态的服务端, 这能获得任意加入或移除服务节点的巨大便利, 天然具备完美的水平扩缩能力. 譬如, 在调试代码时随时都可以重启服务, 重启后, 客户端仍然能毫无感知地继续操作流程; 而对于有状态的系统, 就必须通过重新登录, 进行前置业务操作来为服务端重建状态. 尽管大型系统中只使用 JWT 来维护上下文状态, 服务端完全不持有状态是不太现实的, 不过将热点的服务单独抽离出来做成无状态, 仍是一种有效提升系统吞吐能力的架构技巧.")]),t._v(" "),s("p",[t._v("但是, JWT 也并非没有缺点的完美方案, 它存在以下几个经常被提及的"),s("strong",[t._v("缺点")]),t._v(".")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("令牌难以主动失效")]),t._v(": JWT 令牌一旦签发, 理论上就和认证服务器再没有什么瓜葛了, 在到期之前就会"),s("strong",[t._v("始终有效")]),t._v(', 除非服务器部署额外的逻辑去处理失效问题, 这对某些管理功能的实现是很不利的. 譬如一种颇为常见的需求是: 要求一个用户只能在一台设备上登录, 在 B 设备登录后, 之前已经登录过的 A 设备就应该自动退出. 如果采用 JWT, 就必须设计一个"黑名单"的额外的逻辑, 用来把要主动失效的令牌集中存储起来, 而无论这个黑名单是实现在 Session, Redis 或者数据库中, 都会让服务'),s("strong",[t._v("退化成有状态服务")]),t._v(", 降低了 JWT 本身的价值, 但"),s("strong",[t._v("黑名单")]),t._v("在使用 JWT 时依然是很常见的做法, 需要维护的黑名单一般是很小的状态量, 在许多场景中还是有存在价值的.")]),t._v(" "),s("li",[s("strong",[t._v("相对更容易遭受重放攻击")]),t._v(": 首先说明 Cookie-Session 也是有重放攻击问题的, 只是因为 Session 中的数据控制在服务端手上, 在应对重放攻击时会相对主动一些. 要在 JWT 层面解决重放攻击问题需要付出比较大的代价, 无论是加入"),s("strong",[t._v("全局序列号")]),t._v("(HTTPS 协议的思路), Nonce 字符串(HTTP Digest 验证的思路), 挑战应答码(当下网银动态令牌的思路), 还是缩短令牌有效期强制频繁刷新令牌, 在真正应用时都"),s("strong",[t._v("很麻烦")]),t._v(". 真要处理重放攻击, 建议的解决方案是在"),s("strong",[t._v("信道层次")]),t._v("(譬如启用 HTTPS)上解决, 而不在服务层次(譬如在令牌或接口其他参数上增加额外逻辑)上解决.")]),t._v(" "),s("li",[s("strong",[t._v("只能携带相当有限的数据")]),t._v(": HTTP 协议并没有强制约束 Header 的最大长度, 但是各种服务器, 浏览器都会有自己的约束, 譬如 Tomcat 就要求 Header 最大不超过 8KB, 而在 Nginx 中则默认为 4KB, 因此在令牌中存储过多的数据不仅耗费传输带宽, 还有额外的出错风险.")]),t._v(" "),s("li",[s("strong",[t._v("必须考虑令牌在客户端如何存储")]),t._v(": 严谨地说, 这个并不是 JWT 的问题而是"),s("strong",[t._v("系统设计")]),t._v("的问题. 如果授权之后, 操作完关掉浏览器就结束了, 那把令牌放到内存里面, 压根不考虑持久化那是最理想的方案. 但并不是谁都能忍受一个网站关闭之后下次就一定强制要重新登录的. 这样的话, 想想客户端该把令牌存放到哪里? Cookie? localStorage? Indexed DB? 它们"),s("strong",[t._v("都有泄漏的可能")]),t._v(", 而令牌一旦泄漏, 别人就可以冒充用户的身份做任何事情.")]),t._v(" "),s("li",[s("strong",[t._v("无状态也不总是好的")]),t._v(": 这个其实也不是 JWT 的问题. 如果不能想象无状态会有什么不好的话, 这里可以提个需求: 请基于无状态 JWT 的方案, 做一个在线用户实时统计功能.")])]),t._v(" "),s("h4",{attrs:{id:"保密"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#保密"}},[t._v("#")]),t._v(" 保密")]),t._v(" "),s("p",[t._v("保密是加密和解密的统称, 是指以某种特殊的算法改变原有的信息数据, 使得未授权的用户即使获得了已加密的信息, 但因不知解密的方法, 或知晓解密的算法但缺少解密所需的必要信息, 仍然无法了解数据的真实内容.")]),t._v(" "),s("p",[t._v('按照需要保密的信息所处的环节不同, 可以划分为"信息在客户端时的保密", "信息在传输时的保密"和"信息在服务端时的保密"三类, 或者进一步概括为"'),s("strong",[t._v("端的保密")]),t._v('"和"'),s("strong",[t._v("链路的保密")]),t._v('"两类. 这里把最复杂, 最有效, 又早有标准解决方案的"传输环节"单独提取出来, 放到下一节去讨论, 本节将重点讨论密码等敏感信息如何保障安全等级, 是否应该从客户端开始加密, 应该如何存储及如何验证等常见的安全保密问题.')]),t._v(" "),s("h5",{attrs:{id:"_1-保密的强度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-保密的强度"}},[t._v("#")]),t._v(" 1.保密的强度")]),t._v(" "),s("p",[t._v("保密是有成本的, 追求越高的安全等级, 就要付出越多的工作量与算力消耗. 以用户登录为例, 列举几种不同强度的保密手段, 并讨论它们的防御关注点与弱点.")]),t._v(" "),s("p",[t._v("1)"),s("strong",[t._v("以摘要代替明文")]),t._v(": 如果密码本身比较复杂, 那一次简单的哈希摘要至少可以保证即使传输过程中有信息泄漏, 也不会被逆推出原信息; 即使密码在一个系统中泄漏了, 也不至于威胁到其他系统的使用. 但这种处理不能防止弱密码被彩虹表攻击所破解.")]),t._v(" "),s("p",[t._v("2)"),s("strong",[t._v("先加盐值再做哈希是应对弱密码的常用方法")]),t._v(": 盐值可以为弱密码建立一道防御屏障, 一定程度上防御已有的彩虹表攻击, 但不能阻止加密结果被监听, 窃取后, 攻击者直接发送加密结果给服务端进行"),s("strong",[t._v("冒认")]),t._v(".")]),t._v(" "),s("p",[t._v("3)"),s("strong",[t._v("将盐值变为动态值能有效防止冒认")]),t._v(": 如果每次密码向服务端传输时都掺入了动态的盐值, 让每次加密的结果都不同, 那即使传输给服务端的加密结果被窃取了, 也不能冒用来进行另一次调用. 尽管在双方通信均可能泄漏的前提下协商出只有通信双方才知道的保密信息是完全可行的, 但这样协商出盐值的过程将变得极为"),s("strong",[t._v("复杂")]),t._v(", 而且每次协商只保护一次操作, 也难以阻止对其他服务的重放攻击.")]),t._v(" "),s("p",[t._v("4)"),s("strong",[t._v("给服务加入动态令牌")]),t._v(", 在网关或其他流量公共位置建立校验逻辑, 这样服务端在愿意付出集群中分发令牌信息等代价的前提下, 可以做到防止重放攻击, 但是依然不能解决传输过程中被嗅探而泄漏信息的问题.")]),t._v(" "),s("p",[t._v("5)"),s("strong",[t._v("启用 HTTPS")]),t._v(" 可以防御链路上的恶意嗅探, 也在通信层面解决了重放攻击的问题. 但是依然有因客户端被攻破"),s("strong",[t._v("产生伪造根证书")]),t._v("的风险, 因服务端被攻破产生的证书泄漏而被中间人冒认的风险, 因 CRL 更新不及时或者 OCSP Soft-fail 产生吊销证书被冒用的风险, 以及因 TLS 的版本过低或密码学套件选用不当产生加密强度不足的风险.")]),t._v(" "),s("p",[t._v("6)为了抵御上述风险, 保密强度还要进一步提升, 譬如银行会使用独立于客户端的存储证书的"),s("strong",[t._v("物理设备")]),t._v("(俗称的U盾)来避免根证书被客户端中的恶意程序窃取伪造; 大型网站涉及账号, 金钱等操作时, 会使用"),s("strong",[t._v("双重验证")]),t._v("开辟一条独立于网络的信息通道(如手机验证码, 电子邮件)来显著提高冒认的难度.")]),t._v(" "),s("p",[t._v('听了上述这些逐步升级的保密措施, 你应该能对"更高安全强度同时也意味着更多代价"有更具体的理解, 不是任何一个网站, 系统, 服务都需要无限拔高的安全性. 也许这时候你会好奇另一个问题: 安全的强度有尽头吗? 存不存在某种绝对安全的保密方式? 答案可能出乎多数人的意料, 确实是有的. 信息论之父香农严格证明了'),s("strong",[t._v("一次性密码")]),t._v("(One Time Password)的绝对安全性. 但是使用一次性密码必须有个前提, 就是已经提前安全地把密码或密码列表传达给对方. 譬如, 给你的朋友送去一本存储了完全随机密码的密码本, 然后每次使用其中一条密码来进行加密通信, 用完一条丢弃一条, 理论上这样可以做到绝对的安全, 但显然这种绝对安全对于互联网没有任何的可行性.")]),t._v(" "),s("h5",{attrs:{id:"_2-客户端加密"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-客户端加密"}},[t._v("#")]),t._v(" 2.客户端加密")]),t._v(" "),s("p",[t._v("关于客户端在用户登录, 注册类场景里是否需要对密码进行加密的问题一直存有争议. 笔者的观点很明确: "),s("strong",[t._v("为了保证信息不被黑客窃取而做客户端加密没有太大意义, 对绝大多数的信息系统来说, 启用 HTTPS 可以说是唯一的实际可行的方案")]),t._v(". 但是, 为了保证密码不在服务端被滥用, 在客户端就开始加密还是很有意义的. 大网站被拖库的事情层出不穷, 密码明文被写入数据库, 被输出到日志中之类的事情也屡见不鲜, 做系统设计时就应该把明文密码这种东西当成是最烫手的山芋来看待, 越早消灭掉越好.")]),t._v(" "),s("p",[t._v("为什么客户端加密对防御泄密没有意义? 原因是网络通信并非由发送方和接收方点对点进行的, 客户端"),s("strong",[t._v("无法决定用户送出的信息能不能到达服务端")]),t._v(", 或者会经过怎样的"),s("strong",[t._v("路径")]),t._v('到达服务端, 在传输链路必定是不安全的假设前提下, 无论客户端做什么防御措施, 最终都会沦为"马其诺防线". 比如中间人攻击是通过劫持客户端到服务端之间的某个节点, 包括但不限于代理(通过 HTTP 代理返回赝品), 路由器(通过路由导向赝品), DNS 服务(直接将你机器的 DNS 查询结果替换为赝品地址)等, 来给你访问的页面或服务注入恶意的代码, 极端情况下, 甚至可能会取代你要访问的整个服务或页面, 此时不论你在页面上设计了多么精巧严密的加密措施, 都不会起到任何保护作用, 而攻击者只需劫持路由器, 或在局域网内其他机器释放 ARP 病毒便有可能完成攻击.')]),t._v(" "),s("p",[t._v('对于"不应把明文传递到服务端"的观点, 也是有一些不同意见的. 譬如其中一种保存明文密码的理由是便于客户端做动态加盐, 因为只有在服务端存储了明文, 或者某种盐值/密钥是固定的加密结果的情况下, 才能每次用新的盐值重新加密来与客户端传上来的加密结果进行比对. 笔者的建议是每次从服务端请求动态盐值, 在客户端加盐传输的做法通常都得不偿失, 因为客户端无论是否动态加盐, 都不可能代替 HTTPS. 真正防御性的密码加密存储确实应该在服务端中进行, 但这是为了降低服务端被攻破而批量泄漏密码的风险, 并不是为了增加传输过程的安全.')]),t._v(" "),s("h5",{attrs:{id:"_3-密码存储和验证"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-密码存储和验证"}},[t._v("#")]),t._v(" 3.密码存储和验证")]),t._v(" "),s("p",[t._v("本节介绍一个普通安全强度的信息系统是如何"),s("strong",[t._v("将密码从客户端传输到服务端, 然后存储到数据库")]),t._v('的全过程. "普通安全强度"是指在具有一定保密安全性的基础上, 尽量避免消耗过多的运算资源, 这样后续验证起来也相对便捷. 对多数信息系统来说, 只要配合一定的密码规则约束, 譬如密码要求长度, 特殊字符等, 再配合 HTTPS 传输, 已足以抵御大多数风险了. 即使用户采用了弱密码, 客户端通信被监听, 服务端被拖库, 泄漏了存储的密文和盐值等问题同时发生, 也能够最大限度避免用户明文密码被逆推出来.')]),t._v(" "),s("p",[t._v("下面先介绍密码创建的过程.")]),t._v(" "),s("p",[t._v("1)用户在客户端注册, 输入明文密码: 123456.")]),t._v(" "),s("div",{staticClass:"language-json line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[t._v("password = "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("123456")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("2)客户端对用户密码进行简单的"),s("strong",[t._v("哈希摘要")]),t._v('运算, 可选的算法有 MD2/4/5, SHA1/256/512, BCrypt, PBKDF1/2, 等等. 为了突出"简单"的哈希摘要, 这里故意没有排除掉 MD 这类已经有了高效碰撞手段的算法.')]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("client_hash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MD5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("password"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// e10adc3949ba59abbe56e057f20f883e")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("3)为了防御"),s("strong",[t._v("彩虹表攻击, 应加盐处理")]),t._v(", 客户端加盐只取固定的字符串即可, 如实在不安心, 也可用伪动态的盐值.")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("client_hash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MD5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MD5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("password"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" salt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// SALT = $2a$10$o5L.dWYEjZjaejOmN3x4Qu")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("4)假设攻击者截获了客户端发出的信息, 得到了摘要结果和采用的盐值, 那攻击者就可以枚举遍历所有 8 位字符以内的弱密码, 然后对每个密码再进行加盐计算, 就得到一个针对固定盐值的对照彩虹表. 为了应对这种暴力破解, 并不提倡在盐值上做动态化, 更理想的方式是引入"),s("strong",[t._v("慢哈希函数")]),t._v("来解决.")]),t._v(" "),s("p",[t._v("慢哈希函数是指执行时间可以调节的哈希函数, 通常是以控制调用次数来实现的. BCrypt 算法就是一种典型的慢哈希函数, 它做哈希计算时接受盐值 Salt 和执行成本 Cost 两个参数. 如果将 BCrypt 的执行时间控制在 0.1 秒完成一次哈希计算的话, 按照 1 秒生成 10 个哈希值的速度, 算完所有的 10 位大小写字母和数字组成的弱密码大概需要 P(62,10)/(3600"),s("em",[t._v("24")]),t._v("365)/0.1 = 1237204169 年时间.")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("client_hash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BCrypt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MD5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("password"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" salt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// MFfTW3uNI4eqhwDkG7HP9p2mzEUu/r2")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("5)下一步将"),s("strong",[t._v("哈希值")]),t._v('传输到服务端, 在服务端只需防御被拖库后针对固定盐值的批量彩虹表攻击. 具体做法是为每一个密码(指客户端传来的哈希值)产生一个随机的盐值. 建议采用"密码学安全伪随机数生成器"(Cryptographically Secure Pseudo-Random Number Generator, CSPRNG) 来生成一个'),s("strong",[t._v("长度与哈希值长度相等的随机字符串")]),t._v(". 对于 Java 语言, 从 Java 7 起提供了 java.security.SecureRandom 类, 用于支持 CSPRNG 字符串生成.")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SecureRandom")]),t._v(" random "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SecureRandom")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("byte")]),t._v(" server_salt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("byte")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("36")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nrandom"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("nextBytes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("server_salt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// tq2pdxrblkbgp8vt8kbdpmzdh1w8bex")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("6)将"),s("strong",[t._v("动态盐值混入客户端传来的哈希值再做一次哈希, 产生最终的密文")]),t._v(", 并和上一步随机生成的盐值一起写入同一条数据库记录中. 由于慢哈希算法占用大量处理器资源, 笔者并不推荐在服务端中采用. 这个过程以伪代码表示如下:")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("server_hash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("SHA256")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("client_hash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" server_salt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 55b4b5815c216cf80599990e78")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("cd8974a1e384d49fbde7776d096e1dd436f67\n"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DB")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("save")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("server_hash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" server_salt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("以上加密存储的过程相对复杂, 但是运算压力最大的过程(慢哈希)是在客户端完成的, 对服务端压力很小, 也不惧怕因网络通信被截获而"),s("strong",[t._v("导致明文密码泄漏")]),t._v(".")]),t._v(" "),s("p",[t._v("密码存储后, 以后"),s("strong",[t._v("验证的过程")]),t._v("与加密是类似的, 具体步骤如下所示.")]),t._v(" "),s("p",[t._v("1)客户端: 用户在登录页面中输入密码明文, 123456, 经过与注册相同的加密过程, 向服务端传输加密后的结果.")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("authentication_hash = MFfTW3uNI4eqhwDkG7HP9p2mzEUu/r2\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("2)服务端: 接收到客户端传输上来的"),s("strong",[t._v("哈希值")]),t._v(", 从数据库中取出登录用户对应的密文和盐值, 采用相同的哈希算法, 对客户端传来的哈希值, 服务端存储的盐值计算摘要结果.")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("SHA256")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("authentication_hash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" server_salt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 55b4b5815c216cf80599990")]),t._v("\n    e781cd8974a1e384d49fbde7776d096e1dd436f67\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("3)比较上一步的结果和数据库储存的哈希值是否相同, 如果相同说明密码正确, 反之说明密码错误.")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("authentication "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compare")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" server_hash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// yes")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h4",{attrs:{id:"传输"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#传输"}},[t._v("#")]),t._v(" 传输")]),t._v(" "),s("p",[t._v("前文中已经为传输安全层挖了不少坑, 譬如: 基于信道的认证是怎样实现的? 为什么 HTTPS 是绝大部分信息系统防御通信被窃听和篡改的唯一可行手段? 传输安全层难道不也是一种自动化的加密吗? 为何说无论客户端如何加密都不能代替 HTTPS?")]),t._v(" "),s("p",[t._v('本节将以"'),s("strong",[t._v("假设链路上的安全得不到保障, 攻击者如何摧毁之前认证, 授权, 凭证, 保密中所提到的种种安全机制")]),t._v('"为场景, 讲解传输安全层所要解决的问题, 同时也是对前面这些疑问的回答.')]),t._v(" "),s("h5",{attrs:{id:"_1-摘要-加密与签名"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-摘要-加密与签名"}},[t._v("#")]),t._v(" 1.摘要, 加密与签名")]),t._v(" "),s("p",[t._v('这里从 JWT 令牌的一小段"题外话"来引出现代密码学算法的三种主要用途: '),s("strong",[t._v("摘要, 加密与签名")]),t._v(". JWT 令牌携带信息的可信度源自于它是被签过名的信息, 是令牌签发者真实意图的体现, 因此是不可篡改的. 为什么有签名就能够让负载中的信息变得不可篡改和不可抵赖呢? 要解释"),s("strong",[t._v("数字签名")]),t._v("(Digital Signature), 必须先从密码学算法的另外两种基础应用 "),s("strong",[t._v('"摘要"和"加密"')]),t._v(" 说起.")]),t._v(" "),s("p",[t._v("摘要也称为数字摘要(Digital Digest)或数字指纹(Digital Fingerprint). JWT 令牌中默认的"),s("strong",[t._v("签名信息")]),t._v("是对"),s("strong",[t._v("令牌头, 负载和密钥")]),t._v("三者通过令牌头中指定的哈希算法(HMAC SHA256)计算出来的摘要值, 如下所示:")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("signature "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Hash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("base64UrlEncode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("header"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"."')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("base64UrlEncode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("payload"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" secret"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("理想的哈希算法都具备两个特性. 一是"),s("strong",[t._v("易变性")]),t._v(", 这是指算法的输入端发生了任何一点细微变动, 都会使得输出端的结果产生极大的变化. 这个特性常被用来做"),s("strong",[t._v("校验")]),t._v(", 以保证信息未被篡改, 譬如互联网上下载大文件, 常会附有一个哈希校验码, 以确保下载下来的文件没有因网络或其他原因与原文件产生任何偏差. 二是"),s("strong",[t._v("不可逆性")]),t._v(", 摘要的运算过程是单向的, 不可能从摘要的结果中逆向还原出输入值来. 世间的信息有无穷多种, 而摘要的结果无论其位数是 32, 128, 512 位, 甚至更多位, 都是一个有限的数字, 因此输入数据与输出的摘要结果必然不是一一对应的关系.")]),t._v(" "),s("p",[t._v("由这两个特性可见, "),s("strong",[t._v("摘要的意义是在源信息不泄漏的前提下辨别其真伪")]),t._v(". 易变性保证了可以从公开的特征上甄别出信息是否来自于源信息, 不可逆性保证了不会从公开的特征暴露出源信息, 这与今天用作身份甄别的指纹, 面容和虹膜的生物特征是具有高度可比性的. 在一些场合中, 摘要也会被借用来做加密(如保密中介绍的慢哈希 Bcrypt 算法)和签名(如 JWT 签名中的 HMAC SHA256 算法), 但在严格意义上看, 摘要与这两者有本质的区别.")]),t._v(" "),s("p",[t._v("加密与摘要的本质区别在于"),s("strong",[t._v("加密是可逆的")]),t._v(", 逆过程就是解密. 在经典密码学时代, 加密的安全主要依靠机密性来保证, 即依靠保护加密算法或算法的执行参数不被泄漏来保障信息的安全. 而"),s("strong",[t._v("现代密码学不依靠机密性")]),t._v(", 加解密算法都是完全公开的, 它的安全是建立在"),s("strong",[t._v("特定问题的计算复杂度")]),t._v("之上, 具体是指算法根据输入端计算输出结果耗费的算力资源很小, 但根据输出端的结果反过来推算原本的输入时耗费的算力就极其庞大. 以大数的质因数分解为例, 可以轻而易举地(以O(nlogn)的复杂度)计算出两个大素数的乘积, 譬如:")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("97667323933")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("128764321253")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("12576066674829627448049")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("根据算术基本定理, 质因数的分解形式是唯一的, 且前面计算条件中给出的运算因子已经是质数, 所以12576066674829627448049 的分解形式就只有唯一的形式, 即上面所示的唯一答案. 然而如何对大数进行质因数分解, 迄今还没有找到多项式时间的算法, 甚至无法确切地知道这个问题属于哪个复杂度类(Complexity Class). 所以尽管这个过程在理论上一定是可逆的, "),s("strong",[t._v("但实际上算力差异决定了逆过程无法实现")]),t._v(".")]),t._v(" "),s("p",[t._v("根据加密与解密是否采用同一个密钥, 可将现代密码学算法分为"),s("strong",[t._v("对称加密算法和非对称加密算法")]),t._v("两大类型, 这两类算法各有明确的优劣势与应用场景. 对称加密算法的缺点显而易见, 加密和解密使用相同的密钥, 当通信的成员数量增加时, 为保证"),s("strong",[t._v("两两通信都采用独立的密钥")]),t._v(", 密钥数量与成员数量的平方成正比, 这必然面临"),s("strong",[t._v("密钥管理")]),t._v('的难题. 而更尴尬的难题是当通信双方原本不存在安全的信道时, 如何将一个只能让通信双方才能知道的密钥传输给对方? 如果有通道可以安全地传输密钥, 那为何不使用现有的通道传输信息? 这个"鸡蛋悖论"曾在很长的时间里严重阻碍了密码学在真实世界的推广应用.')]),t._v(" "),s("p",[t._v("非对称加密算法从根本上解决了密钥分发的难题, 它将密钥分成"),s("strong",[t._v("公钥和私钥")]),t._v(". 公钥可以完全公开, 无须安全传输的保证. 私钥由用户自行保管, 不参与任何通信传输. 根据这两个密钥加解密方式的不同, 使得算法可以提供两种不同的功能.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("公钥加密, 私钥解密, 这种就是加密, 用于向私钥所有者发送信息")]),t._v(", 这个信息可能被他人篡改, 但是无法被他人得知. 如果甲想给乙发一个安全保密的数据, 那么甲乙应该各有一个私钥, 甲先用乙的公钥加密这段数据, 再用自己的私钥加密这段加密后的数据, 最后发给乙, 这样确保了内容既不会被读取, 也不能被篡改.")]),t._v(" "),s("li",[s("strong",[t._v("私钥加密, 公钥解密, 这种就是签名, 用于让所有公钥所有者验证私钥所有者的身份")]),t._v(", 并且防止私钥所有者发布的内容被篡改. 但是它不用于保证内容不被他人获得.")])]),t._v(" "),s("p",[t._v("这两种用途在理论上肯定是成立的, 在现实中却一般不成立. 单靠非对称加密算法, 既做不了加密也做不了签名. 因为不论是加密还是解密, "),s("strong",[t._v("非对称加密算法的计算复杂度都相当高")]),t._v(", 其性能比对称加密要差上好几个数量级(不是好几倍). 加解密性能不仅影响速度, 还导致现行的非对称加密算法都没有支持分组加密模式. 这句话的含义是: 由于明文长度与密钥长度在安全上具有相关性, 通俗地说, 多长的密钥决定了它能加密多长的明文, 如果明文太短就需要进行填充, 太长就需要进行分组. 因非对称加密本身的效率所限, 难以支持分组, 所以主流的非对称加密算法都只能加密不超过密钥长度的数据, 这也决定了"),s("strong",[t._v("非对称加密不能直接用于大量数据的加密")]),t._v(".")]),t._v(" "),s("p",[t._v("在加密方面, 现在一般会结合对称与非对称加密的优点, 以"),s("strong",[t._v("混合加密")]),t._v("来保护信道安全, 具体做法是用"),s("strong",[t._v('非对称加密来安全地传递少量数据给通信的另一方, 再以这些数据为密钥, 采用对称加密来安全高效地大量加密传输数据, 这种由多种加密算法组合的应用形式称为"密码学套件"')]),t._v(' . 非对称加密在这个场景中发挥的作用称为"密钥协商".')]),t._v(" "),s("p",[t._v("在签名方面, 现在一般会结合"),s("strong",[t._v("摘要与非对称加密")]),t._v("的优点, 以"),s("strong",[t._v("对摘要结果做加密")]),t._v("的形式来保证签名的适用性. 由于对任何长度的输入源做摘要之后都能得到固定长度的结果, 所以"),s("strong",[t._v("只要对摘要的结果进行签名, 即相当于对整个输入源进行了背书, 保证一旦内容遭到篡改, 摘要结果就会变化, 签名也就马上失效了")]),t._v(".")]),t._v(" "),s("p",[t._v("下表汇总了前面提到的三种算法, 并列举了它们的主要特征, 用途和局限性.")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("类型")]),t._v(" "),s("th",[t._v("特点")]),t._v(" "),s("th",[t._v("常见实现")]),t._v(" "),s("th",[t._v("主要用途")]),t._v(" "),s("th",[t._v("主要局限")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("哈希摘要")]),t._v(" "),s("td",[t._v("1.不可逆, 即不能解密, 所以不是加密算法, 只是一些场景把它当做加密算法使用; 2.易变性, 一点变动就会造成输出结果的大幅度变化; 3.无论输入长度多少, 输出长度固定(2的N次幂)")]),t._v(" "),s("td",[t._v("MD5/6, SHA256/512等")]),t._v(" "),s("td",[t._v("摘要")]),t._v(" "),s("td",[t._v("无法解密")])]),t._v(" "),s("tr",[s("td",[t._v("对称加密")]),t._v(" "),s("td",[t._v("1.加密和解密是一样的秘钥; 2.设计难度相对较小, 执行速度相对较快; 3.加密明文长度不受限制")]),t._v(" "),s("td",[t._v("DES, AES, RC4")]),t._v(" "),s("td",[t._v("加密")]),t._v(" "),s("td",[t._v("要解决如何把秘钥安全的传递给解密者")])]),t._v(" "),s("tr",[s("td",[t._v("非对称加密")]),t._v(" "),s("td",[t._v("1.加密和解密用的不同的秘钥; 2.明文长度不能超过公钥长度")]),t._v(" "),s("td",[t._v("RSA, BCDSA")]),t._v(" "),s("td",[t._v("签名, 传递秘钥")]),t._v(" "),s("td",[t._v("性能与加密明文的长度受限")])])])]),t._v(" "),s("p",[t._v("现在再回到开篇关于 JWT 令牌的几个问题中来. 有了哈希摘要, 对称和非对称加密算法, JWT 令牌的签名就能保证负载中的信息不可篡改, 不可抵赖吗? 其实还是不行的, 在这个场景里, 数字签名的安全性仍存在一个致命的漏洞: 公钥虽然是公开的, 但在网络世界里 "),s("strong",[t._v('"公开"')]),t._v(" 具体是一种什么操作? 如何保证每一个获取公钥的服务, 拿到的公钥就是授权服务器希望它拿到的?")]),t._v(" "),s("p",[t._v("在网络传输是不可信任的前提下, "),s("strong",[t._v("公钥在网络传输过程中可能已经被篡改")]),t._v(", 如果获取公钥的网络请求被攻击者截获并篡改, 返回了攻击者自己的公钥, 那以后攻击者就可以用自己的私钥来签名, 让资源服务器无条件信任它的所有行为了. 现实世界中可以通过打电话, 发邮件, 短信息, 登报纸, 同时发布在多个网站上等很多网络通信之外的途径来公开公钥, 但在程序与网络的世界中, 就必须找到一种可信任的公开方法, 而且这种方法"),s("strong",[t._v("不能依赖加密")]),t._v('来实现, 否则又将陷入"蛋鸡"问题之中.')]),t._v(" "),s("h5",{attrs:{id:"_2-数字证书"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-数字证书"}},[t._v("#")]),t._v(" 2.数字证书")]),t._v(" "),s("p",[t._v('当无法以"签名"的手段来'),s("strong",[t._v("达成信任")]),t._v("时, 就只能求助于其他途径. 不妨先想一想真实的世界中大家是如何达成信任的, 其实不外乎以下两种.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("基于共同私密信息的信任")]),t._v(". 譬如某个陌生号码找你, 说是你的老同学, 生病了要找你借钱. 你能够信任他的方式是向对方询问一些你们两个应该知道, 且只有你们两个知道的私密信息, 如果对方能够回答出来, 他有可能真的是你的老同学, 否则他十有八九就是个骗子.")]),t._v(" "),s("li",[s("strong",[t._v("基于权威公证人的信任")]),t._v(". 如果有个陌生人找你, 说他是警察, 让你把存款转到他们的安全账号上. 你能够信任他的方式是去一趟公安局, 如果公安局担保他确实是个警察, 那他有可能真的是警察, 否则他十有八九就是个骗子.")])]),t._v(" "),s("p",[t._v("现实网络世界并不能假设授权服务器和资源服务器是互相认识的, 所以通常不太会采用第一种方式, 而第二种就是目前"),s("strong",[t._v("保证公钥可信分发的标准, 即公开密钥基础设施(Public Key Infrastructure, PKI)")]),t._v(" .")]),t._v(" "),s("p",[s("strong",[t._v("公开密钥基础设施")]),t._v(": 又称公开密钥基础架构, 公钥基础建设, 公钥基础设施, 公开密钥基础建设或公钥基础架构, 是一组由硬件, 软件, 参与者, 管理政策与流程组成的基础架构, 其目的在于创造, 管理, 分配, 使用, 存储以及撤销数字证书.")]),t._v(" "),s("p",[t._v("在密码学中, 公开密钥基础建设借着"),s("strong",[t._v("数字证书认证中心")]),t._v("(Certificate Authority, CA)将用户的"),s("strong",[t._v("个人身份跟公开密钥链接在一起")]),t._v(", 且每个证书中心用户的身份必须是唯一的. 链接关系通过注册和发布过程创建, 根据担保级别的差异, 创建过程可由 CA 的各种软件或在人为监督下完成. PKI 的确定链接关系的这一角色称为注册管理中心(Registration Authority, RA). RA 确保公开密钥和个人身份链接, 可以防抵赖.")]),t._v(" "),s("p",[t._v('咱们不必纠缠于 PKI 概念上的内容, 只要知道里面定义的"'),s("strong",[t._v("数字证书认证中心")]),t._v('"相当于前面例子中"'),s("strong",[t._v("权威公证人")]),t._v('"的角色, 是负责发放和管理数字证书的权威机构即可. 任何人都可以签发证书, 只是不权威罢了. CA 作为受信任的第三方, 承担公钥体系中公钥的合法性检验的责任. 在网络世界, 在假设所有网络传输都有可能被截获冒认的前提下, "去 CA 中心进行认证"本身也是一种网络操作, 这与之前的"去获取公钥"本质上不是没什么差别吗? 其实还是有差别的, 世间公钥成千上万不可枚举, 而权威的 CA 中心则应是'),s("strong",[t._v("可数")]),t._v('的, "可数"意味着可以不通过网络, 而是在浏览器与操作系统出厂时就预置好, 或者'),s("strong",[t._v("提前安装好")]),t._v("(如银行的证书), 一般计算机上已经存储了各种根证书.")]),t._v(" "),s("p",[t._v("到这里出现了本节的主角之一: "),s("strong",[t._v("证书")]),t._v("(Certificate). "),s("strong",[t._v("证书是权威 CA 中心对特定公钥信息的一种公证载体, 也可以理解为权威 CA 对特定公钥未被篡改的签名背书")]),t._v(". 由于客户的机器上已经预置了这些权威 CA 中心本身的证书(称为 CA 证书或者"),s("strong",[t._v("根证书")]),t._v("), 所以我们能够在"),s("strong",[t._v("不依靠网络的前提下, 使用根证书里面的公钥信息对其所签发的证书中的签名进行确认")]),t._v(". 到此, 终于打破了鸡生蛋, 蛋生鸡的循环, 使得整套数字签名体系有了坚实的逻辑基础.")]),t._v(" "),s("p",[t._v("PKI 中采用的证书格式是 "),s("strong",[t._v("X.509 标准格式")]),t._v(", 它定义了证书中应该包含哪些信息, 并描述了这些信息是如何编码的, 其中最关键的就是"),s("strong",[t._v("认证机构的数字签名和公钥信息")]),t._v("两项内容.")]),t._v(" "),s("p",[t._v("一个数字证书具体包含以下内容.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("版本号")]),t._v("(Version): 指出该证书使用了哪种版本的 X.509 标准(版本 1, 2 或 3), 版本号会影响证书中的一些特定信息, 目前的版本为 3.")])]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Version")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("3 (0x2)")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("ul",[s("li",[s("strong",[t._v("序列号")]),t._v("(Serial Number): 由证书颁发者分配的证书的"),s("strong",[t._v("唯一标识符")]),t._v(".")])]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[t._v("Serial Number: 04:00:00:00:00:01:15:4b:5a:c3:94\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("ul",[s("li",[s("strong",[t._v("签名算法标识符")]),t._v("(Signature Algorithm ID): 用于签发证书的算法标识, 由对象标识符加上相关的参数组成, 用于"),s("strong",[t._v("说明本证书所用的数字签名算法")]),t._v(". 譬如, SHA1 和 RSA 的对象标识符就用来说明该数字签名是利用 RSA 对 SHA1 的摘要结果进行加密.")])]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[t._v("Signature Algorithm: sha1WithRSAEncryption\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("ul",[s("li",[s("strong",[t._v("认证机构的数字签名")]),t._v("(Certificate Signature): 这是使用"),s("strong",[t._v("证书发布者私钥")]),t._v("生成的签名, 以确保这个证书在发放之后没有被篡改过.")]),t._v(" "),s("li",[s("strong",[t._v("认证机构")]),t._v("(Issuer Name): 证书颁发者的可识别名.")])]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Issuer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("C=BE, O=GlobalSign nv-sa, CN=GlobalSign Organization Validation CA\n    - SHA256 - G2")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("ul",[s("li",[s("strong",[t._v("有效期限")]),t._v("(Validity Period): 证书起始日期和时间以及终止日期和时间; 指明证书在这两个时间内有效.")])]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[t._v("Validity\n    Not Before: Nov 21 08:00:00 2020 GMT\n    Not After : Nov 22 07:59:59 2021 GMT\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("ul",[s("li",[s("strong",[t._v("主题信息")]),t._v("(Subject): "),s("strong",[t._v("证书持有人唯一的标识符")]),t._v("(Distinguished Name), 这个名字在整个互联网上应该是唯一的, "),s("strong",[t._v("通常使用的是网站的域名")]),t._v(".")])]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Subject")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("C=CN, ST=GuangDong, L=Zhuhai, O=Awosome-Fenix, CN=*.icyfenix.cn")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("ul",[s("li",[s("strong",[t._v("公钥信息")]),t._v("(Public-Key): 包括"),s("strong",[t._v("证书持有人的公钥, 算法")]),t._v("(指明密钥属于哪种密码系统)的标识符和其他相关的密钥参数.")])]),t._v(" "),s("h5",{attrs:{id:"_3-传输安全层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-传输安全层"}},[t._v("#")]),t._v(" 3.传输安全层")]),t._v(" "),s("p",[t._v('至此, 数字签名的安全性已经可以完全自洽了, 但这条信任链十分复杂与烦琐, 如果从确定加密算法, 生成密钥, 公钥分发, CA认证, 核验公钥, 签名到验证, 每一个步骤都要由最终用户来完成的话, 这种意义的"安全"估计只能一直是存于实验室中的阳春白雪. 如何把这套烦琐的技术体系'),s("strong",[t._v("自动化地应用")]),t._v("于无处不在的网络通信之中, 便是本节的主题.")]),t._v(" "),s("p",[t._v("在计算机科学里, "),s("strong",[t._v("隔离复杂性的最有效手段(没有之一)就是分层")]),t._v(", 如果一层不够就再加一层, 这点在网络中更是体现得淋漓尽致. OSI 模型, TCP/IP 模型将网络从物理特性(比特流)开始, 逐层封装隔离, 到了 HTTP 协议这种面向应用的协议里, 使用者就已经不会去关心网卡/交换机如何处理数据帧, MAC 地址; 不会去关心 ARP 如何做地址转换; 不会去关心 IP 寻址, TCP 传输控制等细节.")]),t._v(" "),s("p",[t._v("想要在网络世界中让用户"),s("strong",[t._v("无感知地实现安全通信, 最合理的做法就是在传输层之上, 应用层之下加入专门的安全层")]),t._v("来实现, 这样对上层原本基于 HTTP 的 Web 应用来说, 影响甚至是无法察觉的. 构建传输安全层的想法早在 1994 年, 就已经有公司开始着手去实践了.")]),t._v(" "),s("ul",[s("li",[t._v("1994 年, 网景(Netscape)公司开发了 "),s("strong",[t._v("SSL 协议")]),t._v("(Secure Sockets Layer)的1.0版, 这是构建传输安全层的起源, 但是 SSL 1.0 从未正式对外发布过.")]),t._v(" "),s("li",[t._v("1995 年, Netscape 把 SSL 升级到 2.0 版, 正式对外发布, 但是刚刚发布不久就被发现有严重漏洞, 所以并未大规模使用.")]),t._v(" "),s("li",[t._v("1996 年, 修补好漏洞的 SSL 3.0 对外发布, 这个版本得到了广泛应用, 很快成为Web网络安全层的事实标准.")]),t._v(" "),s("li",[t._v("1999 年, 互联网标准化组织接替 Netscape, 将 SSL 改名为 "),s("strong",[t._v("TLS(Transport Layer Security)后作为传输安全层的国际标准")]),t._v(". 第一个正式的版本是 TLS 1.0, 该版 TLS 的生命周期极长, 直至 2020 年, 各大主流浏览器才刚刚宣布同时停止对 TLS 1.0/1.1 的支持. 而讽刺的是, 由于停止后许多政府网站被无法被浏览, 此时又正值新冠肺炎疫情(COVID-19)爆发期, Firefox 紧急发布公告宣布撤回该改动, TLS 1.0 的生命还在顽强延续.")]),t._v(" "),s("li",[t._v("2006 年, TLS 的第一个升级版 1.1 发布(RFC 4346), 但却沦为被遗忘的孩子, 很少人使用, 甚至到了 TLS 1.1 从来没有已知的协议漏洞被提出的程度.")]),t._v(" "),s("li",[t._v("2008 年, TLS 1.2 标准发布, 迄今"),s("strong",[t._v("超过 90% 的互联网 HTTPS 流量是由 TLS 1.2")]),t._v(" 所支持的, 现在仍在使用的浏览器几乎都完美支持了该协议.")]),t._v(" "),s("li",[t._v("2018 年, 最新的 TLS 1.3 发布, 比起前面版本相对温和的升级, TLS 1.3 做出了一些激烈的改动, 修改了从 1.0 起一直没有大变化的"),s("strong",[t._v("两轮四次(2-RTT)握手")]),t._v(", "),s("strong",[t._v("首次连接仅需一轮(1-RTT)握手即可完成, 在连接复用支持时, 甚至将 TLS 1.2 原本的 1-RTT 下降到 0-RTT, 显著提升了访问速度")]),t._v(".")])]),t._v(" "),s("p",[t._v("接下来以 TLS 1.2 为例, 介绍传输安全层是如何保障所有信息都是第三方无法窃听(加密传输), 无法篡改(一旦篡改通信算法会立刻发现), 无法冒充(证书验证身份)的. TLS 1.2 在"),s("strong",[t._v("传输之前的握手过程一共需要进行上下两轮, 共计四次通信")]),t._v(", 时序图如下图所示.")]),t._v(" "),s("div",[s("img",{staticStyle:{zoom:"35%"},attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221222233135346-1723100.png",alt:"image-20221222233135346"}})]),t._v(" "),s("h6",{attrs:{id:"_1-客户端请求-client-hello"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-客户端请求-client-hello"}},[t._v("#")]),t._v(" (1)客户端请求: Client Hello")]),t._v(" "),s("p",[t._v("客户端向服务器请求进行加密通信, 在这个请求里面, 它会以"),s("strong",[t._v("明文")]),t._v("的形式, 向服务端提供以下信息.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("支持的协议版本")]),t._v(", 譬如 TLS 1.2. 但是要注意, 1.0 至 3.0 分别代表 SSL 1.0 至 3.0, TLS 1.0 则是3.1, 一直到 TLS 1.3 的 3.4.")]),t._v(" "),s("li",[t._v("一个"),s("strong",[t._v("客户端生成的 32 字节随机数")]),t._v(", 这个随机数将稍后"),s("strong",[t._v("用于产生加密的密钥")]),t._v(".")]),t._v(" "),s("li",[t._v("一个可选的 SessionID, 注意不要和前面的 Cookie-Session 机制混淆了, 这个 SessionID 是指传输安全层的 Session, 是为了 TLS 的"),s("strong",[t._v("连接复用")]),t._v("而设计的.")]),t._v(" "),s("li",[t._v("一系列支持的"),s("strong",[t._v("密码学算法套件")]),t._v(", 例如 TLS_RSA_WITH_AES_128_GCM_SHA256, 代表密钥交换算法是 RSA, 加密算法是 AES128-GCM, 消息认证码算法是 SHA256.")]),t._v(" "),s("li",[t._v("一系列支持的数据压缩算法.")]),t._v(" "),s("li",[t._v('其他可扩展的信息, 为了保证协议的稳定性, 后续对协议的功能扩展大多都添加到这个变长结构中. 譬如 TLS 1.0 中由于发送的数据并不包含服务器的域名地址, 导致一台服务器只能安装一张数字证书, 这对虚拟主机来说很不方便, 所以 TLS 1.1 起就增加了名为"Server Name"的扩展信息, 以便一台服务器给不同的站点安装不同的证书.')])]),t._v(" "),s("h6",{attrs:{id:"_2-服务器回应-server-hello"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-服务器回应-server-hello"}},[t._v("#")]),t._v(" (2)服务器回应: Server Hello")]),t._v(" "),s("p",[t._v("服务器接收到客户端的通信请求后, 如果客户端声明支持的协议版本和加密算法组合与服务端相匹配的话, 就向客户端发出回应. 如果不匹配, 将会返回一个握手失败的警告提示. 这次回应同样以明文发送, 包括以下信息.")]),t._v(" "),s("ul",[s("li",[t._v("服务端确认使用的 TLS 协议版本.")]),t._v(" "),s("li",[s("strong",[t._v("第二个 32 字节的随机数, 稍后用于产生加密的密钥")]),t._v(".")]),t._v(" "),s("li",[t._v("一个 SessionID, 以后可通过连接"),s("strong",[t._v("复用")]),t._v("减少一轮握手.")]),t._v(" "),s("li",[t._v("服务端在列表中选定的密码学算法套件.")]),t._v(" "),s("li",[t._v("服务端在列表中选定的数据压缩算法.")]),t._v(" "),s("li",[t._v("其他可扩展的信息.")]),t._v(" "),s("li",[t._v("如果协商出的加密算法组合是依赖证书认证的, 服务端还要发送出自己的 X.509 证书, 而证书中的公钥是什么, 也必须根据协商的加密算法组合来决定.")]),t._v(" "),s("li",[t._v("密钥协商消息, 这部分内容对于不同密码学套件有着不同的价值, 譬如对于 ECDH+anon 这样的密钥协商算法组合(基于椭圆曲线的 ECDH 算法可以在双方通信都公开的情况下协商出一组只有通信双方知道的密钥)就不需要依赖证书中的公钥, 而是通过 Server Key Exchange 消息协商出密钥.")])]),t._v(" "),s("h6",{attrs:{id:"_3-客户端确认-client-handshake-finished"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-客户端确认-client-handshake-finished"}},[t._v("#")]),t._v(" (3)客户端确认: Client Handshake Finished")]),t._v(" "),s("p",[t._v("由于密码学套件的组合复杂多样, 这里仅以 RSA 算法为密钥交换算法为例介绍后续过程.")]),t._v(" "),s("p",[t._v("客户端收到服务器应答后, "),s("strong",[t._v("先要验证服务器的证书合法性")]),t._v('. 如果证书不是可信机构颁布的, 或者证书中信息存在问题, 譬如域名与实际域名不一致, 证书已经过期, 通过在线证书状态协议得知证书已被吊销, 等等, 都会向访问者显示一个"证书不可信任"的警告, 由用户自行选择是否还要继续通信. 如果证书没有问题, 客户端就会从证书中取出服务器的公钥, 并向服务器发送以下信息.')]),t._v(" "),s("ul",[s("li",[t._v('客户端证书(可选). 部分服务端并不是面向全公众, 而是只对特定的客户端提供服务, 此时客户端需要发送它自身的证书来证明身份. 如果不发送, 或者验证不通过, 服务端可自行决定是否要继续握手, 或者返回一个握手失败的信息. 客户端需要证书的 TLS 通信也称为"双向 TLS"(Mutual TLS, 常简写为 mTLS), 这是云原生基础设施的主要认证方法, 也是基于信道认证的最主流形式.')]),t._v(" "),s("li",[s("strong",[t._v("第三个 32 字节的随机数")]),t._v(", 这个随机数不再是明文发送, 而是以"),s("strong",[t._v("服务端传过来的公钥加密, 被称为PreMasterSecret")]),t._v(", 它将与前两次发送的随机数一起, 根据特定算法计算出 48 字节的 MasterSecret, "),s("strong",[t._v("这个 MasterSecret 即后续内容传输时的对称加密算法所采用的私钥")]),t._v(".")]),t._v(" "),s("li",[t._v("编码改变通知, 表示随后的信息都将用双方商定的加密方法和密钥发送.")]),t._v(" "),s("li",[t._v("客户端握手结束通知, 表示客户端的握手阶段已经结束. 这一项同时也是前面发送的所有内容的哈希值, 以供服务器校验.")])]),t._v(" "),s("h6",{attrs:{id:"_4-服务端确认-server-handshake-finished"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-服务端确认-server-handshake-finished"}},[t._v("#")]),t._v(" (4)服务端确认: Server Handshake Finished")]),t._v(" "),s("p",[t._v("服务端向客户端回应最后的确认通知, 包括以下信息.")]),t._v(" "),s("ul",[s("li",[t._v("编码改变通知, 表示随后的信息都将用"),s("strong",[t._v("双方商定的加密方法和密钥发送")]),t._v(".")]),t._v(" "),s("li",[t._v("服务器握手结束通知, 表示服务器的握手阶段已经结束. 这一项同时也是前面发送的所有内容的哈希值, 以供客户端校验.")])]),t._v(" "),s("p",[t._v("至此, "),s("strong",[t._v("整个 TLS 握手阶段")]),t._v("宣告完成, 一个安全的连接就已成功建立. 每一个连接建立时, 客户端和服务端均通过上面的握手过程协商出了许多信息, 譬如一个只有双方才知道的随机产生的密钥, 传输过程中要采用的对称加密算法(例子中的 AES128), 压缩算法等, 此后该连接的通信将使用此密钥和加密算法进行加密, 解密和压缩. 这种处理方式"),s("strong",[t._v("对上层协议的功能是完全透明的")]),t._v(", 虽然在传输性能上会有下降, 但在"),s("strong",[t._v("功能上完全不会感知到 TLS 的存在")]),t._v('. 建立在这层传输安全层之上的 HTTP 协议, 被称为 "'),s("strong",[t._v("HTTP over SSL/TLS")]),t._v('", 也即大家所熟知的 HTTPS.')]),t._v(" "),s("p",[t._v('从上面握手协商的过程中还可以得知, HTTPS 并非只有"启用了 HTTPS"和"未启用 HTTPS"的差别, 采用不同的协议版本, 不同的密码学套件, 证书是否有效, 服务端/客户端面对无效证书时的处理策略等都导致了不同 HTTPS 站点的安全强度的不同, 因此'),s("strong",[t._v("并不能说只要启用了 HTTPS 就必能安枕无忧")]),t._v(".")]),t._v(" "),s("h4",{attrs:{id:"验证"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#验证"}},[t._v("#")]),t._v(" 验证")]),t._v(" "),s("p",[t._v('数据验证与程序如何编码是密切相关的, 许多开发者都不会把它归入安全的范畴之中. 但请细想一下, 关注"你是谁"(认证), "你能做什么"(授权)等问题是很合理的安全, 关注"你做得对不对"(验证)不也同样合理吗? 从数量来讲, 数据验证不严谨而导致的安全问题比其他安全攻击导致的安全问题要多得多; 而从风险上讲, 由数据质量导致的问题, 风险有高有低, 真遇到高风险的数据问题时, 面临的损失不一定就比被黑客拖库来得小.')]),t._v(" "),s("p",[t._v("相比其他富有挑战性的安全措施, 如防御与攻击两者缠斗的精彩, 数学, 心理, 社会工程和计算机等跨学科知识的结合运用, 数据验证确实有些无聊, 枯燥, 这项常规的工作在日常的开发中贯穿于代码的各个层次, 每个程序员都肯定写过. 但这种常见的代码反而是"),s("strong",[t._v("迫切需要被架构约束")]),t._v("的, "),s("strong",[t._v("缺失的校验影响数据质量, 过度的校验不会使得系统更加健壮, 某种意义上反而会制造垃圾代码, 甚至带来副作用")]),t._v(". 请来看看下面这个实际的段子.")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('前  端: 提交一份用户数据(姓名:某, 性别:男, 爱好:女, 签名:xxx, 手机:xxx, 邮箱:null)\n控制器: 发现邮箱是空的, 抛ValidationException("邮箱没填")\n前  端: 已修改, 重新提交\n安  全: 发送验证码时发现手机号少一位, 抛RemoteInvokeException("无法发送验证码")\n前  端: 已修改, 重新提交\n服务层: 邮箱怎么有重复啊, 抛BusinessRuntimeException("不允许开小号")\n前  端: 已修改, 重新提交\n持久层: 签名字段超长了插不进去, 抛SQLException("插入数据库失败, SQL: xxx")\n...\n前  端: 你们这些管挖坑不管埋的后端, 各种异常都往前抛! \n用  户: 这系统牙膏厂生产的? \n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br")])]),s("p",[t._v("最基础的数据问题可以在前端做表单校验来处理, 但服务端验证肯定也是要做的, 看完了上面的段子后, 那么服务端应该"),s("strong",[t._v("在哪一层做校验")]),t._v("呢? 可能会有这样的答案.")]),t._v(" "),s("ul",[s("li",[t._v("在控制器层做, 在服务层不做. 理由是从服务开始会有同级重用, 出现 ServiceA.foo(params) 调用 ServiceB.bar(params) 时, 就会对 params 重复校验两次.")]),t._v(" "),s("li",[t._v("在服务层做, 在控制器层不做. 理由是无业务含义的格式校验已在前端表单验证处理过, 有业务含义的校验, 放在控制器层无论如何都不合适.")]),t._v(" "),s("li",[t._v("在控制器层, 服务层各做各的. 控制器层做格式校验, 服务层做业务校验, 听起来很合理, 但这其实就是上面段子中被嘲笑的行为.")]),t._v(" "),s("li",[t._v("还有其他一些意见, 譬如在持久层做校验, 理由是持久层是最终入口, 把守好写入数据库的质量最重要.")])]),t._v(" "),s("p",[t._v("上述的讨论大概不会有统一, 正确的结论, 但是在 Java 里确实有验证的标准做法, 笔者"),s("strong",[t._v("提倡的做法是把校验行为从分层中剥离出来, 不是在哪一层做, 而是在 Bean 上做")]),t._v(", 即 "),s("strong",[t._v("Java Bean Validation")]),t._v(". 从 2009 年 JSR 303 的 1.0, 到 2013 年 JSR 349 更新的 1.1, 到目前最新的 2017 年发布的 JSR 380, 均定义了 Bean 验证的全套规范. "),s("strong",[t._v("单独将验证提取, 封装")]),t._v(", 可以获得不少好处:")]),t._v(" "),s("ul",[s("li",[t._v("对于无业务含义的格式验证, 可以做到预置.")]),t._v(" "),s("li",[t._v("对于有业务含义的业务验证, 可以做到"),s("strong",[t._v("重用")]),t._v(", 一个 Bean 被多个方法用作参数或返回值是很常见的, 针对 Bean 做校验比针对方法做校验更有价值.")]),t._v(" "),s("li",[t._v("利于集中管理, 譬如统一认证的异常体系, 统一做国际化, 统一给客户端的返回格式, 等等.")]),t._v(" "),s("li",[t._v("避免对输入数据的防御污染到业务代码, 如果你的代码里有很多下面这样的条件判断, 就应该考虑重构了:")])]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 一些已执行的逻辑")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("someParam "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RuntimeExcetpion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"客官不可以!"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("ul",[s("li",[t._v("利于"),s("strong",[t._v("多个校验器统一执行")]),t._v(", 统一返回校验结果, 避免用户踩地雷, 挤牙膏式的试错体验.")])]),t._v(" "),s("p",[t._v("据笔者所知, 国内的项目使用 Bean Validation 的并不少见, 但多数程序员都只使用到它的内置约束注解(Built-In Constraint)来做一些与业务逻辑无关的通用校验, 即下面这堆注解:")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@NotNull")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@AssertTrue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@AssertFalse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Min")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Max")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@DecimalMin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@DecimalMax")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Negative")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@NegativeOrZero")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Positive")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@PositiveOrZeor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Szie")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Digits")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Pass")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@PastOrPresent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Future")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@FutureOrPresent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Pattern")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@NotEmpty")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@NotBlank")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Email")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("但是与业务相关的校验往往才是最复杂的校验, 将简单的校验交给 Bean Validation, 而把复杂的校验留给自己, 这简直是买椟还珠的程序员版本. 其实"),s("strong",[t._v("以 Bean Validation 的标准方式来做业务校验才是非常优雅")]),t._v("的. 下面是例子:")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * 创建新的用户\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@POST")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Response")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("createUser")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Valid")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@UniqueAccount")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Account")]),t._v(" user"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CommonResponse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("op")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" service"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("createAccount")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("user"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * 更新用户信息\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@PUT")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@CacheEvict")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"#user.username"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Response")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("updateUser")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Valid")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@AuthenticatedAccount")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@NotConflictAccount")]),t._v(" \n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Account")]),t._v(" user"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CommonResponse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("op")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" service"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("updateAccount")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("user"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br")])]),s("p",[t._v("注意其中的三个自定义校验注解, 它们的含义分别是:")]),t._v(" "),s("ul",[s("li",[t._v("@UniqueAccount: 传入的用户对象必须是唯一的, 不与数据库中任何已有用户的名称, 手机, 邮箱重复.")]),t._v(" "),s("li",[t._v("@AuthenticatedAccount: 传入的用户对象必须与当前登录的用户一致.")]),t._v(" "),s("li",[t._v("@NotConflictAccount: 传入的用户对象中的信息与其他用户是无冲突的, 譬如将一个注册用户的邮箱, 修改成与另外一个已存在的注册用户一致的值, 这便是冲突.")])]),t._v(" "),s("p",[t._v("这里的需求很容易理解, 注册新用户时, 应约束不与任何已有用户的关键信息重复; 而修改自己的信息时, 只能与自己的信息重复, 而且只能修改当前登录用户的信息. 这些约束规则"),s("strong",[t._v("不仅仅为这两个方法服务")]),t._v(", 还可能在用户资源的其他入口被使用到, 甚至在其他分层的代码中被使用到, 在 Bean 上做校验就能一揽子地覆盖上述这些使用场景. 下面代码是这三个自定义注解对应校验器的实现类:")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AuthenticatedAccountValidator")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AccountValidation")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Aut")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("henticatedAccount"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("initialize")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AuthenticatedAccount")]),t._v(" constraintAnnotation"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        predicate "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" c "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AuthenticAccount")]),t._v(" loginUser "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AuthenticAccount")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n                "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SecurityContextHolder")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getContext")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getAuthentication")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getPrincipal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("equals")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("loginUser"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UniqueAccountValidator")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AccountValidation")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UniqueAccount")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("initialize")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UniqueAccount")]),t._v(" constraintAnnotation"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        predicate "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" c "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("repository"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("existsByUsernameOrEmailOrTelephone\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getUsername")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getEmail")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getTelephone")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NotConflictAccountValidator")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AccountValidation")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NotCon")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("flictAccount"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("initialize")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NotConflictAccount")]),t._v(" constraintAnnotation"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        predicate "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" c "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Collection")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Account")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" collection "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" repository"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("findByUsernameOrEmailOrT"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("elephone")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getUsername")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getEmail")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getTelephone")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将用户名, 邮件, 电话改成与现有信息完全不重复的, 或者只与自己重复的, 就不算冲突")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" collection"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isEmpty")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("collection"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("size")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v("  collection"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("iterator")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("equals")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br"),s("span",{staticClass:"line-number"},[t._v("25")]),s("br"),s("span",{staticClass:"line-number"},[t._v("26")]),s("br")])]),s("p",[t._v("这样业务校验便和业务逻辑完全分离开来, 在需要校验时用 @Valid 注解自动触发, 或者通过代码手动触发执行, 具体可根据实际项目的要求, 将这些注解应用于控制器, 服务层, 持久层等任何层次的代码之中. 此外, 对于校验结果不满足时的提示信息, 也可以统一处理, 如提供默认值, 国际化支持(这里没做), 统一的客户端返回格式(创建一个用于 ConstraintViolationException 的异常处理器来实现, 代码中有但这里没有贴出来), 以及批量执行全部校验, 避免给用户带来挤牙膏式的体验.")]),t._v(" "),s("p",[t._v("对于 Bean 与 Bean 校验器, 笔者另外有两条编码建议. 第一条是对校验项预置好默认的提示信息, 这样当校验不通过时用户能获得明确的修正提示, 以下是代码示例:")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/**\n * 表示一个用户的信息是无冲突的\n * \n * "无冲突"是指该用户的敏感信息与其他用户不重合, 譬如将一个注册用户的邮箱, 修改成与另外一个已\n *  存在的注册用户一致的值, 这便是冲突\n */')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Documented")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Retention")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("RUNTIME")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Target")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("FIELD")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("METHOD")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("PARAMETER")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("TYPE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Constraint")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("validatedBy "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AccountValidation"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("NotConflictAccountValidator")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@interface")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NotConflictAccount")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("message")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"用户名称, 邮箱, 手机号码与现存用户产生重复"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Class")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("groups")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Class")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Payload")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("payload")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br")])]),s("p",[t._v("另外一条建议是将"),s("strong",[t._v("不带业务含义的格式校验注解放到 Bean 的类定义")]),t._v("之上, 将带业务逻辑的校验放到 Bean 的类定义的外面. 这两者的区别是放在类定义中的注解能够自动运行, 而放到类外面的注解需要明确标出才会运行. 譬如用户账号实体中的部分代码为:")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Account")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BaseEntity")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@NotEmpty")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("message "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"用户不允许为空"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" username"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@NotEmpty")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("message "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"用户姓名不允许为空"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" avatar"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Pattern")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("regexp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1\\\\d{10}"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" message "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"手机号格式不正确"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" telephone"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Email")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("message "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"邮箱格式不正确"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" email"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br")])]),s("p",[t._v("这些校验注解都直接放在类定义中, 每次执行校验的时候它们都会被运行. 由于 Bean Validation 是 Java 的标准规范, 它执行的频率可能比编写代码的程序所预想的更高, 譬如使用 Hibernate 来做持久化时, 便会自动执行 Data Object 上的校验注解. 对于那些不带业务含义的注解, 运行是不需要其他外部资源参与的, 即不会调用远程服务, 访问数据库, 这种校验重复执行也不会产生什么成本.")]),t._v(" "),s("p",[t._v("但带业务逻辑的校验, 通常就需要外部资源参与执行, 这不仅仅是多消耗一点时间和运算资源的问题, 由于很难保证依赖的每个服务都是幂等的, 重复执行校验很可能会带来额外的副作用. 因此应该放到外面让使用者自行判断是否触发.")]),t._v(" "),s("p",[t._v('还有一些 "需要触发一部分校验" 的非典型情况, 譬如 "新增" 操作 A 时需要执行全部校验规则, "修改" 操作 B 时希望不校验某个字段, "删除"操 作 C 时希望改变某一条校验规则, 这时就要启用'),s("strong",[t._v("分组校验")]),t._v('来处理, 设计一套 "新增", "修改", "删除" 这样的标识类, 置入校验注解的 groups 参数中去实现.')]),t._v(" "),s("h3",{attrs:{id:"分布式共识"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式共识"}},[t._v("#")]),t._v(" 分布式共识")]),t._v(" "),s("p",[t._v("本部分介绍几种有代表性的分布式共识算法, 这是分布式环境中操作共享数据的理论基础.")]),t._v(" "),s("p",[t._v("思考一个问题: 如果你有一份很重要的数据, 要确保它长期存储在电脑上不会丢失, 你会怎么做?")]),t._v(" "),s("p",[t._v("很简单, 答案就是去买几块硬盘, 在不同硬盘上多备份几个副本. 假设一块硬盘每年损坏的概率是 5%, 把文件复制到另一块备份盘上, 两块硬盘同时损坏而丢失数据的概率就只有 0.25%, 如果使用三块硬盘存储则丢失数据的概率是 0.00125%, 四块是 0.0000625 %, 换言之, 四块硬盘就可以保证数据在一年内有超过 99.9999% 的概率是安全可靠的.")]),t._v(" "),s("p",[t._v("要保障软件系统的可靠性, 采用的办法与上面使用多个硬盘的方法并没有什么区别.")]),t._v(" "),s("p",[t._v("单个节点的系统宕机导致数据无法访问的原因可能有很多, 譬如程序出错, 硬件损坏, 网络分区, 电源故障, 等等, 而且宕机的概率可能还高于 5%, 这决定了软件系统也必须有"),s("strong",[t._v("多台机器, 并且它们拥有一致的数据副本")]),t._v(", 才有可能对外提供可靠的服务.")]),t._v(" "),s("p",[t._v("在软件系统里, 要保障系统的可用性, 面临的困难与硬盘备份面临的困难又有着本质的区别. 硬盘之间是孤立的, 不需要互相通信, 备份数据是静态的, 初始化后状态就不会发生改变, 由人工进行的文件复制操作, 很容易就保障了数据在各个备份盘中的一致性. 然而在分布式系统中, "),s("strong",[t._v("必须考虑动态的数据如何在不可靠的网络通信条件下, 依然能在各个节点之间正确复制的问题")]),t._v(".")]),t._v(" "),s("p",[t._v("所以将问题进行修改: 如果你有一份会随时变动的数据, 要确保它正确地存储于网络中的几台不同机器之上, 你会怎么做?")]),t._v(" "),s("p",[t._v('相信最容易想到的答案一定是"'),s("strong",[t._v("数据同步")]),t._v('": 每当数据发生变化, 把变化情况在各个节点间的复制视作一种事务性的操作, 只有系统里每一台机器都反馈成功, 完成磁盘写入后, 数据的变化才宣告成功. 使用 2PC/3PC 就可以实现这种同步操作. 一种真实的数据同步应用场景是'),s("strong",[t._v("数据库的主从全同步复制")]),t._v("(Fully Synchronous Replication), 譬如 MySQL 集群, 它在进行全同步复制时, 会等待所有 Slave 节点的 Binlog 都完成写入后, 才会提交 Master 节点的事务. (这个场景中 Binlog 本身就是要同步的状态数据, 不应将它看作指令日志的集合.) 然而这里有一个明显的缺陷, 尽管可以确保 Master 节点和 Slave 节点中的数据是"),s("strong",[t._v("绝对一致")]),t._v("的, 但任何一个 Slave 节点因为"),s("strong",[t._v("任何原因未响应均会阻塞整个事务")]),t._v(", 每增加一个 Slave 节点, 都会造成整个系统可用性风险增加一分.")]),t._v(" "),s("p",[t._v("以"),s("strong",[t._v("同步")]),t._v("为代表的数据复制方法, 被称为"),s("strong",[t._v("状态转移")]),t._v("(State Transfer), 是较符合人类思维的可靠性保障手段, 但通常要以"),s("strong",[t._v("牺牲可用性")]),t._v("为代价. 在建设分布式系统的时候, 往往不能承受这样的代价, 一些关键系统, 在必须保障数据正确可靠的前提下, 也对可用性有非常高的要求, 譬如系统要保证数据达到 99.999999% 可靠, 同时系统自身也要达到 99.999% 可用的程度.")]),t._v(" "),s("p",[t._v("这就引出了第三个问题: 如果有一份会"),s("strong",[t._v("随时变动")]),t._v("的数据, 要确保它正确地存储于网络中的几台不同机器之上, 并且要尽可能保证数据是"),s("strong",[t._v("随时可用")]),t._v("的, 你会怎么做?")]),t._v(" "),s("p",[s("strong",[t._v("可靠性与可用性")]),t._v("的矛盾造成了增加机器数量反而带来可用性的降低. 为缓解这个矛盾, 在分布式系统里主流的数据复制方法是以"),s("strong",[t._v("操作转移")]),t._v("(Operation Transfer)为基础的. 想要改变数据的状态, 除了直接将目标状态赋予它之外, 还有另一种常用的方法是通过某种操作, "),s("strong",[t._v("令源状态转换为目标状态")]),t._v(". 能够使用确定的操作促使状态间产生确定的转移结果的计算模型, 在计算机科学中被称为"),s("strong",[t._v("状态机")]),t._v("(State Machine).")]),t._v(" "),s("p",[s("strong",[t._v("状态机有一个特性")]),t._v(": 任何初始状态一样的状态机, 如果执行的"),s("strong",[t._v("命令序列一样, 则最终达到的状态也一样")]),t._v(". 如果将此特性应用在多参与者的协商共识上, 可以理解为系统中"),s("strong",[t._v("存在多个具有完全相同的状态机(参与者), 这些状态机能最终保持一致的关键就是起始状态完全一致和执行命令序列完全一致")]),t._v(".")]),t._v(" "),s("p",[t._v("根据状态机的特性, 要让多台机器的最终状态一致, 只要确保它们的初始状态是一致的, 并且接收到的操作指令序列也是一致的即可, 无论这个操作指令是新增, 修改, 删除抑或其他任何可能的程序行为, 都可以理解为要将一连串的"),s("strong",[t._v("操作日志")]),t._v("正确地广播给各个分布式节点. 在广播指令与指令执行期间, "),s("strong",[t._v("允许系统内部状态存在不一致的情况")]),t._v(", 即并不要求所有节点的每一条指令都是同时开始, 同步完成的, 只要求在此期间的内部状态不能被外部观察到, 且当操作指令序列执行完毕时, "),s("strong",[t._v("所有节点的最终状态是一致的")]),t._v(", 则这种模型就被称为"),s("strong",[t._v("状态机复制")]),t._v("(State Machine Replication).")]),t._v(" "),s("p",[t._v('考虑到分布式环境下网络分区现象是不可能消除的, 甚至允许不再追求系统内所有节点在任何情况下的数据状态都一致, 而是采用 "'),s("strong",[t._v("少数服从多数")]),t._v('" 的原则, 一旦系统中'),s("strong",[t._v("过半数的节点完成了状态的转换, 就认为数据的变化已经被正确地存储在了系统中")]),t._v(", 这样就可以容忍少数(通常是不超过半数)的节点失联, 减弱增加机器数量对系统整体可用性的影响, 这种思想在分布式中被称为  "),s("strong",[t._v('"Quorum 机制"')]),t._v(" .")]),t._v(" "),s("p",[t._v("根据上述讨论, 需要设计出一种算法, 能够让分布式系统内部暂时容忍不同的状态, 但最终保证大多数节点的状态达成一致; 同时, 能够让分布式系统在外部看来始终表现出整体一致的结果. 这个让系统各节点不受局部的网络分区, 机器崩溃, 执行性能或者其他因素影响, 都能最终表现出整体一致的过程, 就被称为各个节点的"),s("strong",[t._v("协商共识")]),t._v("(Consensus).")]),t._v(" "),s("p",[s("strong",[t._v("需要注意共识与一致性的区别")]),t._v(": "),s("mark",[s("strong",[t._v("一致性是指数据不同副本之间的差异, 而共识是指达成一致性的方法与过程")])]),t._v(".")]),t._v(" "),s("h4",{attrs:{id:"paxos"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#paxos"}},[t._v("#")]),t._v(" Paxos")]),t._v(" "),s("blockquote",[s("p",[t._v("世界上只有一种共识协议, 就是 Paxos, 其他所有共识算法都是 Paxos 的退化版本. --- Mike Burrows, Google Chubby")])]),t._v(" "),s("p",[t._v("Paxos 是由 Leslie Lamport 提出的一种"),s("strong",[t._v("基于消息传递的协商共识算法")]),t._v(', 是当今分布式系统最重要的理论基础, 几乎就是"共识"二字的代名词. 这个极高的评价出自于提出 Raft 算法的论文, 更显分量十足. 虽然所言有些夸张, 但是如果没有 Paxos, 那后续的 Raft, ZAB 等算法, ZooKeeper, etcd 等分布式协调框架, Hadoop, Consul 等在此基础上的各类分布式应用都很可能会延后好几年面世.')]),t._v(" "),s("h5",{attrs:{id:"_1-paxos的诞生"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-paxos的诞生"}},[t._v("#")]),t._v(" 1.Paxos的诞生")]),t._v(" "),s("p",[t._v('为了解释清楚 Paxos 算法, Lamport 虚构了一个名为 "Paxos" 的希腊城邦, 这个城邦没有一个中心化的专职立法机构, 而是靠着"兼职议会"来完成立法, 无法保证所有城邦居民都能够及时了解新的法律提案, 也无法保证居民会及时为提案投票.')]),t._v(" "),s("p",[t._v("Paxos 算法的目标就是让城邦能够在每一位居民都"),s("strong",[t._v("不承诺一定会及时参与")]),t._v("的情况下, 依然可以按照少数服从多数的原则, 最终达成一致意见. 但是 Paxos 算法并不考虑拜占庭将军问题, 即假设信息可能丢失也可能延迟, 但不会被错误传递.")]),t._v(" "),s("p",[t._v("2006 年, 在 Google 的 Chubby, Megastore 以及 Spanner 等分布式系统都使用 Paxos 解决了分布式共识的问题, 并将其整理成正式的论文发表之后, Paxos 算法一夜间成为计算机科学分布式这条分支中最炙手可热的概念, 开始被学术界众人争相研究.")]),t._v(" "),s("h5",{attrs:{id:"_2-算法流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-算法流程"}},[t._v("#")]),t._v(" 2.算法流程")]),t._v(" "),s("p",[t._v("本节中 Paxos 均特指最早的 Basic Paxos 算法. Paxos 算法将分布式系统中的"),s("strong",[t._v("节点分为三类")]),t._v(".")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("提案节点")]),t._v(": 称为 "),s("strong",[t._v("Proposer")]),t._v(", 提出对某个值进行设置操作的节点, 设置值这个行为就被称为"),s("strong",[t._v("提案")]),t._v("(Proposal), 值一旦设置成功, 就是不会丢失也不可变的. 注意, Paxos 是典型的"),s("strong",[t._v("基于操作转移模型来设计的算法")]),t._v(', 不要把这里的"设置值"类比成程序中变量赋值操作, 而应该'),s("strong",[t._v("类比成")]),t._v("​"),s("mark",[s("strong",[t._v("日志记录")])]),t._v("​"),s("strong",[t._v("操作")]),t._v(', 在 Raft 算法中就直接把"提案"叫作 "日志" 了.')]),t._v(" "),s("li",[s("strong",[t._v("决策节点")]),t._v(": 称为 "),s("strong",[t._v("Acceptor")]),t._v(", 是"),s("strong",[t._v("应答提案")]),t._v("的节点, 决定该提案是否可被投票, 是否可被接受. "),s("strong",[t._v("提案一旦得到过半数决策节点的接受, 即称该提案被批准(Accept)")]),t._v(" . 提案被批准即意味着该值不能被更改, 也不会丢失, 且最终所有节点都会接受它.")]),t._v(" "),s("li",[s("strong",[t._v("记录节点")]),t._v(": 称为 "),s("strong",[t._v("Learner")]),t._v(", 不参与提案, 也不参与决策, 只是"),s("strong",[t._v("单纯地从提案, 决策节点中学习已经达成共识的提案")]),t._v(". 譬如少数派节点从网络分区中恢复时, 将会进入这种状态.")])]),t._v(" "),s("p",[t._v("在使用 Paxos 算法的分布式系统里, 所有的节点都是"),s("strong",[t._v("平等")]),t._v("的, 它们都可以承担以上某一种或多种的角色, 不过为了便于确保有明确的多数派, "),s("strong",[t._v("决策节点的数量应该被设定为奇数个")]),t._v(", 且在系统初始化时, 网络中每个节点都应该知道整个网络"),s("strong",[t._v("所有决策节点的数量, 地址")]),t._v("等信息.")]),t._v(" "),s("p",[t._v('在分布式环境下, 如果说各个节点"就某个值(提案)达成一致", 指的是  '),s("strong",[t._v('"不存在某个时刻有一个值为 A, 另一个时刻又为 B 的情景"')]),t._v(" . 解决这个问题的复杂度主要来源于以下"),s("strong",[t._v("两个方面因素")]),t._v("的共同影响.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("系统内部各个节点通信是不可靠的")]),t._v(", 不论是对于系统中企图设置数据的提案节点抑或是决定是否批准设置操作的决策节点, 其发出, 收到的信息可能延迟送达, 可能丢失, 但不去考虑消息有传递错误的情况.")]),t._v(" "),s("li",[s("strong",[t._v("系统外部各个用户访问是可并发的")]),t._v(", 如果系统只会有一个用户, 或者每次只对系统进行串行访问, 那单纯地应用 Quorum 机制, 少数节点服从多数节点, 就足以保证值被正确地读写.")])]),t._v(" "),s("p",[t._v('第一点是网络通信中客观存在的现象, 也是所有共识算法都要重点解决的问题. 对于第二点, 详细解释如下. 现在讨论的是 "分布式环境下并发操作的共享数据" 的问题, 即使先不考虑是否在分布式的环境下, 只考虑并发操作, 假设有一个变量 i 当前在系统中存储的数值为 2, 同时有外部请求 A, B 分别对系统发送操作指令, "把 i 的值加 1" 和 "把 i 的值乘 3", 如果不加任何并发控制, 将可能得到 "(2+1)×3=9" 与 "2×3+1=7" 这两种可能的结果. 因此, '),s("strong",[t._v("对同一个变量的并发修改必须先加锁后操作")]),t._v(", 不能让 A, B 的请求被交替处理. 而在分布式的环境下, 由于要同时考虑到分布式系统内可能在任何时刻出现的通信故障, 如果一个节点在取得锁之后, 在释放锁之前发生崩溃失联, 这将导致整个操作被无限期的等待所阻塞, 因此算法中的加锁就不完全等同于并发控制中以互斥量来实现的加锁, 还必须提供一个其他节点能抢占锁的机制, 以避免因通信问题而出现死锁.")]),t._v(" "),s("p",[t._v("为了解决这个问题, "),s("strong",[t._v("分布式环境中的锁必须是可抢占的")]),t._v(".")]),t._v(" "),s("p",[t._v('Paxos 算法包括两个阶段, 第一阶段 "'),s("mark",[s("strong",[t._v("准备")])]),t._v('"(Prepare) 就相当于上面'),s("strong",[t._v("抢占锁")]),t._v("的过程. 如果某个提案节点准备发起提案, 必须先向所有的"),s("strong",[t._v("决策节点广播一个许可申请")]),t._v("(称为 Prepare 请求). 提案节点的 Prepare 请求中会附带一个"),s("strong",[t._v("全局唯一且单调递增的数字 n 作为提案 ID")]),t._v(", 决策节点收到后, 将会给予提案节点"),s("mark",[s("strong",[t._v("两个承诺与一个应答")])]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("两个承诺")]),t._v("是指:")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("承诺不会再接受提案 ID 小于或等于 n 的 Prepare 请求")]),t._v(";")]),t._v(" "),s("li",[s("strong",[t._v("承诺不会再接受提案 ID 小于 n 的 Accept 请求")]),t._v(".")])]),t._v(" "),s("p",[s("strong",[t._v("一个应答")]),t._v("是指:")]),t._v(" "),s("ul",[s("li",[t._v("在不违背以前的承诺的前提下, 回复已经批准过的提案中 ID 最大的那个提案所设定的值和提案 ID, 如果该值从来没有被任何提案设定过, 则返回空值. 如果违反此前做出的承诺, 即收到的提案 ID 并不是决策节点收到的最大的 ID, 那允许直接对此 Prepare 请求不予理会.")])]),t._v(" "),s("p",[t._v("当提案节点收到了"),s("strong",[t._v("多数派决策节点的应答")]),t._v('(称为 Promise 应答)后, 就可以开始第二阶段的 "'),s("mark",[s("strong",[t._v("批准")])]),t._v('"(Accept) 过程, 这时有如下两种可能的结果:')]),t._v(" "),s("ul",[s("li",[t._v("如果提案节点发现所有响应的决策节点此前都没有批准过该值(即为空), 那说明它是"),s("strong",[t._v("第一个")]),t._v('设置值的节点, 可以随意地决定要设定的值, 将自己选定的值与提案 ID 组成一个二元组 " '),s("strong",[t._v("(id,value)")]),t._v(' ", 再次广播给全部决策节点(称为 '),s("strong",[t._v("Accept 请求")]),t._v(");")]),t._v(" "),s("li",[t._v("如果提案节点发现响应的决策节点中已经有"),s("strong",[t._v("至少一个节点的应答中包含值")]),t._v("了, 那它就不能够随意取值, 而是必须无条件地从应答中找出提案 ID 最大的那个值并"),s("strong",[t._v("接收")]),t._v(', 组成一个二元组 " '),s("strong",[t._v("(id,maxAcceptValue)")]),t._v(' ", 再次广播给全部决策节点(称为 Accept 请求).')])]),t._v(" "),s("p",[t._v("当每一个决策节点收到 Accept 请求时, 都会在不违背以前的承诺的前提下, 接收并"),s("strong",[t._v("持久化当前提案 ID 和提案附带的值.")]),t._v("  如果违反此前做出的承诺, 即收到的提案 ID 并不是决策节点收到过的最大的 ID, 那允许直接对此 Accept 请求不予理会.")]),t._v(" "),s("p",[t._v("当提案节点收到了多数派决策节点的应答(称为 Accepted 应答)后, "),s("strong",[t._v("协商结束, 共识决议形成, 然后将形成的决议发送给所有记录节点进行学习")]),t._v(". 整个过程的时序图如下所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221114231920165.png",alt:"",title:"Paxos算法时序图"}})]),t._v(" "),s("h5",{attrs:{id:"_3-工作实例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-工作实例"}},[t._v("#")]),t._v(" 3.工作实例")]),t._v(" "),s("p",[t._v("Paxos 理解起来比较难, 下面以一个具体例子来讲解 Paxos.")]),t._v(" "),s("p",[t._v("假设一个分布式系统有五个节点, 分别命名为 S1, S2, S3, S4, S5, 五个节点都同时扮演着"),s("strong",[t._v("提案节点和决策节点")]),t._v("的角色. 这里只讨论正常通信的场景, 不涉及网络分区. 此时, 有"),s("strong",[t._v("两个并发的请求")]),t._v("希望将同一个值分别设定为 X (由 S1 作为提案节点提出)和 Y (由 S5 作为提案节点提出), 以 P 代表准备阶段, 以 A 代表批准阶段, 这时可能发生以下几种情况.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("情况一")]),t._v(": 整个系统对取值为 X 达成共识. 譬如, S1 选定的提案 ID 是 3.1(全局唯一 ID 加上节点编号), 先取得了"),s("strong",[t._v("多数派决策")]),t._v("节点的 Promise 和 Accepted 应答, 此时 S5 选定提案 ID 为 4.5, 发起 Prepare 请求, 收到的多数应答中至少会包含 1 个此前"),s("strong",[t._v("应答")]),t._v("过 S1 的决策节点, 假设是 S3, 那么 S3 提供的 Promise 中必将包含 S1 已设定好的值 X, S5 就必须"),s("strong",[t._v("无条件")]),t._v('地用 X 代替 Y 作为自己提案的值, 由此整个系统对 "'),s("strong",[t._v("取值为X")]),t._v('" 这个事实达成一致, 如下图所示.')])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221115225427658.png",alt:"image-20221115225427658"}})]),t._v(" "),s("ul",[s("li",[t._v("情况二: 事实上, 对于情况一, X 被选定为最终值是"),s("strong",[t._v("必然结果")]),t._v(", 但从图中可以看出, X 被选定为最终值并不是必须得到多数派的共同批准, 而是只取决于 S5 提案时 Promise 应答中是否已包含了批准过 X 的决策节点, 如下图所示, S5 发起提案的 Prepare 请求时, X 并未获得多数派批准, 但由于 S3 已经批准, 所以最终共识的结果仍然是 X.")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221115230040725.png",alt:"image-20221115230040725"}})]),t._v(" "),s("ul",[s("li",[t._v("情况三: 另外一种可能的结果是 S5 提案时 Promise 应答中"),s("strong",[t._v("并未包含批准过 X 的决策节点")]),t._v(", 譬如应答 S5 提案时, 节点 S1 已经批准了 X, 节点 S2, S3 未批准但返回了 Promise 应答, 此时 S5 以更大的提案 ID 获得了 S3, S4, S5 的 Promise 应答, 由于这三个节点均未批准过任何值, 所以 S3 将"),s("strong",[t._v("不再接收来自 S1 的 Accept 请求")]),t._v(", 因为它的提案 ID 已经不是最大的了, 这三个节点将批准 Y 的取值, 整个系统最终会对  "),s("strong",[t._v('"取值为Y"')]),t._v("  达成一致, 如下图所示.")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221115230105027.png",alt:"image-20221115230105027"}})]),t._v(" "),s("ul",[s("li",[t._v("情况四: 从情况三可以推导出另一种极端的情况, 如果两个提案节点"),s("strong",[t._v("交替使用")]),t._v("更大的提案 ID, 使得准备阶段成功, 批准阶段失败, 那么这个过程理论上可以无限持续下去, 形成"),s("strong",[t._v("活锁")]),t._v("(Live Lock), 如下图所示. 在算法实现中会引入"),s("strong",[t._v("随机超时时间")]),t._v("来避免活锁的产生.")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221115230658871.png",alt:"image-20221115230658871"}})]),t._v(" "),s("p",[t._v("虽然 Paxos 是以复杂著称的算法, 但以上介绍都是基于 "),s("strong",[t._v("Basic Paxos")]),t._v(", 以正常流程(未出现网络分区等异常), 通俗方式讲解的 Paxos 算法, 并未涉及严谨的逻辑和数学原理, 也未讨论 Paxos 的推导证明过程, 理解起来应该不算太困难.")]),t._v(" "),s("p",[t._v("Basic Paxos 的价值在于开拓了分布式共识算法的发展思路, 但由于它有如下缺陷, "),s("strong",[t._v("一般不会直接用于实践")]),t._v(": Basic Paxos 只能对"),s("strong",[t._v("单个值形成决议")]),t._v(", 并且决议的形成至少"),s("strong",[t._v("需要两次网络请求和应答(准备和批准阶段各一次)")]),t._v(" , 高并发情况下将产生较大的网络开销, 极端情况下甚至可能形成活锁. 总之, Basic Paxos 是一种很学术化但对工业化并不友好的算法, 现在几乎只用来做理论研究, 实际的应用都是基于 "),s("strong",[t._v("Multi Paxos 和 Fast Paxos")]),t._v(" 算法.")]),t._v(" "),s("h4",{attrs:{id:"multi-paxos"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#multi-paxos"}},[t._v("#")]),t._v(" Multi Paxos")]),t._v(" "),s("p",[t._v("接下来介绍 Multi Paxos 以及一些与它的"),s("strong",[t._v("理论等价的算法(如 Raft, ZAB 等算法)")]),t._v(" .")]),t._v(" "),s("p",[t._v('Basic Paxos 可能存在活锁问题, 即两个提案节点争相提出自己的提案, 抢占同一个值的修改权限, 导致整个系统在持续性地"反复横跳", 外部看起来就像被锁住了一样. 此外, 分布式共识的复杂性主要来源于网络的不可靠与请求的可并发两大因素, 活锁问题与许多 Basic Paxos 异常场景中所遭遇的麻烦, '),s("strong",[t._v("都可以看作源于任何一个提案节点都能够完全平等地, 与其他节点并发地提出提案而带来的复杂问题")]),t._v(".")]),t._v(" "),s("p",[t._v("为此, Lamport 提出了一种 Paxos 的改进版本--- "),s("strong",[t._v("Multi Paxos 算法")]),t._v(", 希望能够找到一种两全其美的办法, 既"),s("strong",[t._v('不破坏 Paxos 中"众节点平等"的原则, 又能在提案节点中实现主次之分, 限制每个节点都有不受控的提案权利')]),t._v(". 这两个目标听起来似乎是矛盾的, 但现实世界中的选举就很符合这种在平等节点中挑选意见领袖的情景.")]),t._v(" "),s("p",[t._v("Multi Paxos 对 Basic Paxos 的核心改进是"),s("strong",[t._v('增加了 "选主" 的过程')]),t._v(", 提案节点会通过定时轮询(心跳), "),s("strong",[t._v("确定当前网络中的所有节点里是否存在一个主提案节点")]),t._v(", 一旦没有发现主节点, 节点就会在心跳超时后使用 Basic Paxos 中定义的"),s("strong",[t._v("准备(A), 批准(P)的两轮网络交互过程")]),t._v(", 向所有其他节点广播自己希望"),s("strong",[t._v("竞选主节点")]),t._v('的请求, 希望整个分布式系统对 "'),s("strong",[t._v("由我作为主节点")]),t._v('" 这件事情协商达成一致共识, 如果得到了决策节点中多数派的批准, 便宣告'),s("strong",[t._v("竞选成功")]),t._v(". 所以就是"),s("strong",[t._v("基于 Basic Paxos 算法的流程进行选主")]),t._v(", 由于选主并不是频繁触发的, 所以性能 OK.")]),t._v(" "),s("p",[t._v("选主完成之后, 除非主节点失联之后发起重新竞选, 否则从此往后, 就"),s("strong",[t._v("只有主节点本身才能够提出提案")]),t._v(". 此时, 无论哪个提案节点接收到客户端的操作请求, 都会将请求转发给主节点来完成提案, 而"),s("strong",[t._v("主节点提案时, 就无须再次经过准备过程")]),t._v(", 因为可以认为在经过选举时的那一次准备之后, 后续的提案都是对相同提案 ID 的一连串的批准过程. 也可以通俗理解为"),s("strong",[t._v("选主过后, 就不会再有其他节点与它竞争, 相当于处于无并发的环境当中的有序操作, 所以此时系统中要对某个值达成一致, 只需要进行一次批准的交互即可")]),t._v(", 整体时序图如下.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221115231650096.png",alt:"",title:"Multi-Paxos算法时序图"}})]),t._v(" "),s("p",[t._v("可能有人注意到这时候的二元组(id, value)已经变成了"),s("strong",[t._v("三元组(id, i, value)")]),t._v(" , 这是因为需要给"),s("strong",[t._v("主节点")]),t._v('增加一个"'),s("strong",[t._v("任期编号")]),t._v('", 这个编号必须是'),s("strong",[t._v("严格单调递增")]),t._v("的, 以应付主节点陷入网络分区后重新恢复, 但另外一部分节点仍然有多数派, 且已经完成了重新选主的情况, 此时必须"),s("strong",[t._v("以任期编号大的主节点为准")]),t._v('. 节点有了选主机制的支持后, 在整体来看, 就可以进一步简化节点角色, 不去区分提案, 决策和记录节点, 而是统统以"'),s("strong",[t._v("节点")]),t._v('"来代替, 节点只有'),s("strong",[t._v("主(Leader)和从(Follower)")]),t._v(" 的区别, 此时协商共识的时序图如图6-7所示.")]),t._v(" "),s("p",[t._v('下面换一个角度来重新思考 "分布式系统中如何对某个值达成一致" 这个问题, 可以把该问题划分为三个子问题来考虑, 可以证明(具体证明就不列在这里了, 感兴趣的读者可参考 Raft 的论文)当以下三个问题同时被解决时, 即等价于达成共识:')]),t._v(" "),s("ul",[s("li",[t._v("如何选主(Leader Election);")]),t._v(" "),s("li",[t._v("如何把数据复制到各个节点上(Entity Replication);")]),t._v(" "),s("li",[t._v("如何保证过程是安全的(Safety).")])]),t._v(" "),s("p",[t._v('尽管选主问题还涉及许多工程上的细节, 譬如心跳, 随机超时, 并行竞选等, 但只论原理的话, 如果你已经理解了 Paxos 算法的操作步骤, 相信对选主并不会有什么疑惑, 因为这本质上仅仅是分布式系统对"谁来当主节点"这件事情达成的共识而已, 我们在前一节已经讲述了分布式系统该如何对一件事情达成共识, 这里就不再赘述了, 下面直接来解决数据(Paxos 中的提案, Raft 中的日志)在网络各节点间的复制问题.')]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221115232435118.png",alt:"",title:"Multi-Paxos算法-有选主机制的协商共识时序图"}})]),t._v(" "),s("p",[t._v('在正常情况下, 客户端向主节点发起一个操作请求, 譬如提出 "将某个值设置为 X", 此时主节点将 X 写入自己的'),s("strong",[t._v("变更日志")]),t._v(", 但"),s("strong",[t._v("先不提交")]),t._v(", 接着在下一次心跳包中把"),s("strong",[t._v("变更 X 的信息广播给所有的从节点")]),t._v(', 并要求从节点回复 "'),s("strong",[t._v("确认收到")]),t._v('" 的消息, 从节点收到信息后, 将操作'),s("strong",[t._v("写入自己的变更日志")]),t._v(', 然后向主节点发送 "'),s("strong",[t._v("确认签收")]),t._v('" 的消息, '),s("strong",[t._v("主节点收到过半数的签收消息后, 提交自己的变更")]),t._v(", 应答客户端并且给从节点广播可以提交的消息, 从节点收到提交消息后提交自己的变更, 至此, 数据在节点间的复制宣告完成.")]),t._v(" "),s("p",[t._v("在异常情况下, 网络出现了"),s("strong",[t._v("分区")]),t._v(", 部分节点失联, 但只要仍能正常工作的节点的数量能够满足多数派("),s("strong",[t._v("过半数")]),t._v(")的要求, 分布式系统就可以正常工作, 这时的数据复制过程如下.")]),t._v(" "),s("p",[t._v("(1) 假设有 S1, S2, S3, S4, S5 五个节点, S1 是主节点, 由于网络故障, 导致 S1, S2 和 S3, S4, S5 之间彼此无法通信, 形成"),s("strong",[t._v("网络分区")]),t._v(".")]),t._v(" "),s("p",[t._v("(2) 一段时间后, S3, S4, S5 三个节点中的某一个(譬如是 S3)最先达到心跳超时的阈值, 获知当前分区中已经"),s("strong",[t._v("不存在主节点")]),t._v(", 则它向所有节点发出自己要"),s("strong",[t._v("竞选的广播")]),t._v(", 并收到了 S4, S5 节点的批准响应, 加上自己一共三票, 即得到了"),s("strong",[t._v("多数派的批准")]),t._v(", 竞选成功, 此时系统中会同时存在 S1 和 S3 "),s("strong",[t._v("两个主节点")]),t._v(", 但由于网络分区, 它们"),s("strong",[t._v("不会")]),t._v("知道对方的存在.")]),t._v(" "),s("p",[t._v("(3) 这种情况下, 客户端发起操作请求.")]),t._v(" "),s("ul",[s("li",[t._v("如果客户端连接到了 S1, S2 其中之一, 都将由 S1 处理, 但由于操作只能获得最多"),s("strong",[t._v("两个节点")]),t._v("的响应, 不构成多数派的批准, 所以任何变更都"),s("strong",[t._v("无法成功提交")]),t._v(".")]),t._v(" "),s("li",[t._v("如果客户端连接到了 S3, S4, S5 其中之一, 都将由 S3 处理, 此时操作可以获得"),s("strong",[t._v("最多三个节点")]),t._v("的响应, 构成多数派的批准, 是"),s("strong",[t._v("有效")]),t._v("的, 变更可以被提交, 即系统可以继续提供服务.")]),t._v(" "),s("li",[t._v("事实上, 以上两种情景很少能够并存. 网络分区是由于软, 硬件或者网络故障而导致的, 内部网络出现了分区, 但两个分区仍然能分别与外部网络的客户端正常通信的情况甚为少见. 更多的场景是"),s("strong",[t._v("算法能容忍网络里下线了一部分节点")]),t._v(", 按照这个例子来说, 如果下线了两个节点, 系统仍能正常工作, 如果下线了三个节点, 那剩余的两个节点就不可能继续提供服务了.")])]),t._v(" "),s("p",[t._v("(4) 假设现在故障恢复, 分区解除, 五个节点可以"),s("strong",[t._v("重新通信")]),t._v(":")]),t._v(" "),s("ul",[s("li",[t._v("S1 和 S3 都向所有节点发送心跳包, 从各自的心跳中可以得知"),s("strong",[t._v("两个主节点里 S3 的任期编号更大")]),t._v(", 它是最新的, 此时五个节点均只承认 S3 是唯一的主节点.")]),t._v(" "),s("li",[t._v("S1, S2 "),s("strong",[t._v("回滚")]),t._v("它们所有未被提交的变更.")]),t._v(" "),s("li",[t._v("S1, S2 从主节点发送的心跳包中获得它们失联期间发生的所有变更, 将"),s("strong",[t._v("变更提交并写入本地磁盘")]),t._v(".")]),t._v(" "),s("li",[t._v("此时分布式系统各节点的状态达成"),s("strong",[t._v("最终一致")]),t._v(".")])]),t._v(" "),s("p",[t._v('下面来看第三个问题: "'),s("strong",[t._v("如何保证过程是安全的")]),t._v('". 选主和数据复制都是很具体的行为, 但是"安全"就很模糊, 什么算安全或算不安全?')]),t._v(" "),s("p",[t._v('在分布式理论中, Safety 和 Liveness 两种属性是有预定义的术语, 在专业的资料中一般翻译成"协定性"和"终止性", 这两个概念也是由 Lamport 最先提出, 当时给出的定义如下.')]),t._v(" "),s("ul",[s("li",[t._v("协定性(Safety): 所有的坏事都不会发生.")]),t._v(" "),s("li",[t._v("终止性(Liveness): 所有的好事都终将发生, 但不知道是什么时候.")])]),t._v(" "),s("p",[t._v("这里不去纠结严谨的定义, 仍通过举例来说明它们的含义.")]),t._v(" "),s("p",[t._v("譬如以选主问题为例, 协定性保证了选主的结果一定有且只有唯一的一个主节点, 不可能同时出现两个主节点; 而终止性则要保证选主过程一定可以在某个时刻结束. 由前面对活锁的介绍可知, 在终止性这个属性上选主问题是存在理论上的瑕疵的, "),s("strong",[t._v("可能会由于活锁而导致一直无法选出明确的主节点")]),t._v(", 所以 Raft 论文中只写了对 Safety 的保证, 但由于"),s("strong",[t._v("工程实现")]),t._v("上的处理, 现实中几乎不可能会出现终止性的问题.")]),t._v(" "),s("p",[t._v("以上这种把共识问题分解为  "),s("strong",[t._v('"选主", "复制"和"安全"')]),t._v('  三个问题来思考, 解决的思路, 即 "Raft算法", 后来成为 etcd, LogCabin, Consul 等重要分布式程序的实现基础, ZooKeeper 的 ZAB 算法与 Raft 的思路也非常类似, 这些算法都被认为是 Multi Paxos 的'),s("strong",[t._v("等价派生实现")]),t._v(".")]),t._v(" "),s("h4",{attrs:{id:"gossip协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gossip协议"}},[t._v("#")]),t._v(" Gossip协议")]),t._v(" "),s("p",[t._v('Paxos, Raft, ZAB 等分布式算法经常会被称作"'),s("strong",[t._v("强一致性")]),t._v('"的分布式共识协议, 但它的意思其实是: "尽管系统内部节点可以存在不一致的状态, 但从系统外部看来, 不一致的情况并不会被观察到, 所以整体上看系统是强一致性的".')]),t._v(" "),s("p",[t._v('与它们相对的, 还有另一类被冠以"'),s("strong",[t._v("最终一致性")]),t._v('"的分布式共识协议, 这表明系统中'),s("strong",[t._v("不一致的状态有可能会在一定时间内被外部直接观察到")]),t._v(". 一种典型且极为常见的最终一致的分布式系统就是 "),s("strong",[t._v("DNS 系统")]),t._v(", 在各节点缓存的 TTL 到期之前, 都有可能与真实的域名翻译结果不一致.")]),t._v(" "),s("p",[t._v('本节将介绍在比特币网络和许多重要分布式框架中都有应用的另一种具有代表性的 "'),s("strong",[t._v("最终一致性")]),t._v('" 的分布式共识协议: '),s("strong",[t._v("Gossip 协议")]),t._v(".")]),t._v(" "),s("p",[t._v("Gossip 的特点: 要同步的信息如同流言一般传播扩散.")]),t._v(" "),s("p",[t._v('虽然习惯也把 Gossip 称作"共识协议", 但首先必须强调它并不是直接与 Paxos, Raft 这些共识算法等价的, 只是基于 Gossip 之上可以通过某些方法去实现与 Paxos, Raft 相类似的目标而已.')]),t._v(" "),s("p",[t._v("一个最典型的例子是比特币网络中使用了 Gossip 协议, 用于在各个分布式节点中互相同步区块头和区块体的信息, 这是整个网络能够正常交换信息的基础, "),s("strong",[t._v("但并不能称作共识")]),t._v('; 然后比特币使用工作量证明(Proof of Work, PoW)来对 "这个区块由谁来记账" 这一件事情在全网达成共识, 这样这个目标才可以认为与 Paxos, Raft 的目标是一致的.')]),t._v(" "),s("p",[t._v("下面来了解 Gossip 的具体工作过程. 相比 Paxos, Raft 等算法, Gossip 的过程十分简单, 它可以看作以下两个步骤的简单循环.")]),t._v(" "),s("ul",[s("li",[t._v("如果有某一项信息需要在整个网络的所有节点中传播, 那从"),s("strong",[t._v("信息源")]),t._v("开始, 选择一个固定的传播周期(譬如 1 秒), 随机"),s("strong",[t._v("选择它相连接的 k 个节点(称为 Fan-Out)来传播消息")]),t._v(".")]),t._v(" "),s("li",[t._v("每一个节点收到消息后, 如果这个消息是它之前没有收到过的, 则在下一个周期内, 该节点将向除了发送消息给它的那个节点外的其他相邻的 k 个节点"),s("strong",[t._v("发送相同的消息")]),t._v(", 直到最终网络中所有节点都收到了消息. 尽管这个过程需要一定时间, 但是理论上最终网络的所有节点都会拥有相同的消息.")])]),t._v(" "),s("p",[t._v("根据 Gossip 的过程描述, 很容易发现 Gossip 对网络节点的连通性和稳定性"),s("strong",[t._v("几乎没有任何要求")]),t._v(", 它一开始就将网络某些节点只能与一部分节点部分连通(Partially Connected Network)而不是以全连通网络(Fully Connected Network)作为前提; 能够容忍网络上节点随意地增加或减少, 随意地宕机或重启; 新增加或重启的节点的状态最终会与其他节点同步达成一致. Gossip 把网络上所有节点都视为"),s("strong",[t._v("平等而普通")]),t._v("的一员, 没有任何中心化节点或主节点的概念, 这些特点使得 Gossip 具有极强的鲁棒性, 而且非常适合在公众互联网中应用.")]),t._v(" "),s("p",[t._v("同时也很容易找到 Gossip 的缺点. 消息最终是通过多个轮次的散播到达全网的, 因此它必然会"),s("strong",[t._v("存在全网各节点状态不一致")]),t._v("的情况, 而且由于是随机选取发送消息的节点, 所以尽管可以在整体上测算出统计学意义上的传播速率, 但对于个体消息来说, 无法准确地预计需要多长时间才能达成全网一致. 另外一个缺点是"),s("strong",[t._v("消息的冗余")]),t._v(", 同样是由于随机选取发送消息的节点, 所以就不可避免地存在消息重复发送给同一节点的情况, 增加了网络的传输压力, 也给消息节点带来了额外的处理负载.")]),t._v(" "),s("p",[s("strong",[t._v("达到一致性耗费的时间与网络传播中消息冗余量这两个缺点存在一定对立, 如果要改善其中一个, 就会恶化另外一个")]),t._v(", 由此, Gossip 设计了两种可能的消息传播模式: 反熵(Anti-Entropy)和传谣(Rumor-Mongering). 熵是生活中少见但科学中很常用的概念, 它代表着事物的混乱程度. 反熵的意思就是反混乱, 以提升网络各个节点之间的相似度为目标. 所以在反熵模式下, 会同步节点的全部数据, 以消除各节点之间的差异, 目标是使整个网络各节点完全一致. 但是, 在节点本身就会发生变动的前提下, 这个目标将使得整个网络中消息的数量非常庞大, 给网络带来巨大的传输开销. 而传谣模式是以传播消息为目标, 只发送新到达节点的数据, 即只对外发送变更消息, 这样消息数据量将显著缩减, 网络开销也相对减小.")]),t._v(" "),s("h3",{attrs:{id:"从类库到服务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从类库到服务"}},[t._v("#")]),t._v(" 从类库到服务")]),t._v(" "),s("p",[t._v('微服务架构的一个重要设计原则是 "'),s("strong",[t._v("通过服务来实现独立自治的组件")]),t._v('"(Componentization via Service), 强调应采用"'),s("strong",[t._v("服务")]),t._v('"(Service)而不是"'),s("strong",[t._v("类库")]),t._v('"(Library)来构建组件化的程序, 这两者的差别在于'),s("strong",[t._v("类库是在编译期静态链接到程序中的, 通过调用本地方法来使用其中的功能, 而服务是进程外组件, 通过调用远程方法来使用其中的功能")]),t._v(".")]),t._v(" "),s("p",[t._v("采用服务来构建程序, 获得的收益是"),s("strong",[t._v('软件系统"整体"与"部分"在物理层面的真正隔离')]),t._v(", 这对构筑可靠的大型软件系统来说无比珍贵, 但另一面, 其付出的代价也不容忽视, 微服务架构在"),s("strong",[t._v("复杂性与执行性能")]),t._v("方面做出了极大的让步. 在一套由多个微服务相互调用才能正常运作的分布式系统中, 每个节点都互相扮演着服务的生产者与消费者的多重角色, 形成了一套复杂的网状调用关系, 此时, 至少有(但不限于)以下三个问题是必须考虑并得到妥善解决的.")]),t._v(" "),s("ul",[s("li",[t._v("对消费者来说, "),s("strong",[t._v("外部的服务由谁提供? 具体在什么网络位置?")])]),t._v(" "),s("li",[t._v("对生产者来说, "),s("strong",[t._v("内部哪些服务需要暴露? 哪些应当隐藏? 应当以何种形式暴露服务? 以什么规则在集群中分配请求?")])]),t._v(" "),s("li",[t._v("对调用过程来说, "),s("strong",[t._v("如何保证每个远程服务都接收到相对平均的流量, 获得尽可能高的服务质量与可靠性?")])])]),t._v(" "),s("p",[t._v("这三个问题的解决方案, 在微服务架构中通常被称为  "),s("strong",[t._v('"服务发现", "服务的网关路由"和"服务的负载均衡"')]),t._v(" .")]),t._v(" "),s("h4",{attrs:{id:"服务发现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务发现"}},[t._v("#")]),t._v(" 服务发现")]),t._v(" "),s("p",[t._v("类库封装被大规模使用, 令计算机可以通过位于不同模块的方法调用来组装复用指令序列, 打开了软件达到更大规模的一扇大门. 无论是编译期链接的 C, C++ 语言, 还是运行期链接的 Java 语言, 都要通过"),s("strong",[t._v("链接器")]),t._v("(Linker)将代码里的"),s("strong",[t._v("符号引用转换为模块入口或进程内存地址的直接引用")]),t._v(". 而服务化的普及, 令软件系统得以通过分布于"),s("strong",[t._v("网络")]),t._v("中不同机器的互相协作来复用功能, 这是软件发展规模的第二次飞跃, 此时, "),s("strong",[t._v("如何确定目标方法的确切位置")]),t._v(', 便是与编译链接有着等同意义的研究课题, 解决该问题的过程被称作"'),s("strong",[t._v("服务发现")]),t._v('"(Service Discovery).')]),t._v(" "),s("h5",{attrs:{id:"_1-服务发现的意义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-服务发现的意义"}},[t._v("#")]),t._v(" 1.服务发现的意义")]),t._v(" "),s("p",[t._v("所有的远程服务调用都是使用"),s("strong",[t._v("全限定名, 端口号与服务标识")]),t._v("所构成的"),s("strong",[t._v("三元组")]),t._v("来确定一个远程服务的精确坐标的. "),s("strong",[t._v("全限定名代表了网络中某台主机的精确位置, 端口号代表了主机上某一个提供了 TCP/UDP 网络服务的程序, 服务标识则代表了该程序所提供的某个具体的方法入口")]),t._v('. 其中 "全限定名, 端口号" 的含义对所有的远程服务来说都是一致的, 而"服务标识"则与具体的应用层协议相关, 不同协议具有不同形式的标识. 譬如 REST 的远程服务, 标识是 URL 地址; RMI 的远程服务, 标识是 Stub 类中的方法; SOAP 的远程服务, 标识是 WSDL 中定义方法, 等等.')]),t._v(" "),s("p",[t._v('远程服务标识的多样性, 决定了"服务发现"也可以有两种不同的理解, 一种是以 '),s("strong",[t._v("UDDI")]),t._v(' 为代表的"百科全书式"的服务发现, 上至提供服务的企业信息(企业实体, 联系地址, 分类目录等), 下至服务的程序接口细节(方法名称, 参数, 返回值, 技术规范等)都在服务发现的管辖范围之内; 另一种是类似于 DNS 这样"门牌号码式"的服务发现, 只满足从某个代表服务提供者的全限定名到服务实际主机 IP 地址的翻译转换, 并不关心服务具体是哪个厂家提供的, 也不关心服务有几个方法, 各自由什么参数构成, 它默认这些细节信息是服务消费者本身已完全了解的, 此时服务坐标就可以退化为更简单的"全限定名+端口号". 当今, '),s("strong",[t._v("后一种服务发现占主流地位, 本文后续所说的服务发现, 如无说明, 均是特指后者")]),t._v(".")]),t._v(" "),s("p",[t._v("原本服务发现只依赖 DNS 将一个全限定名翻译为一至多个 IP 地址或者 SRV 等其他类型的记录便可, 位于 DNS 之后的"),s("strong",[t._v("负载均衡器")]),t._v("也实质上承担了一部分服务发现的职责, 完成了外部 IP 地址到各个服务内部实际 IP 的转换. 这种做法在软件追求不间断长时间运行的时代是很合适的, 但随着微服务的逐渐流行, 服务的非正常宕机, 重启和正常的上线, 下线变得越发频繁, 仅靠 DNS 服务器和负载均衡器等基础设施逐渐疲于应对, 无法跟上服务变动的步伐了. 人们最初是尝试使用 ZooKeeper 这样的分布式 K/V 框架, 通过软件自身来完成服务注册与发现, ZooKeeper 也的确曾短暂统治过远程服务发现, 是微服务早期的主流选择, 但 ZooKeeper 毕竟是"),s("strong",[t._v("很底层的分布式工具, 还需要用户自己做相当多的工作才能满足服务发现的需求")]),t._v(". 到了 2014 年, 在 Netflix 内部经受过长时间实际考验的, 专门用于服务发现的 Eureka 宣布开源, 并很快被纳入 Spring Cloud, 成为 Spring 默认的远程服务发现的解决方案, 从此 Java 程序员无须再在服务注册这件事情上花费太多的力气. 到 2018 年, Spring Cloud Eureka 进入维护模式以后, HashiCorp 的 Consul 和阿里巴巴的 "),s("strong",[t._v("Nacos")]),t._v(" 很快就从 Eureka 手上接过传承的衣钵.")]),t._v(" "),s("p",[t._v("到这个阶段, 服务发现框架已经发展得相当成熟, 考虑到了几乎方方面面的问题, 不仅支持通过 DNS 或者 HTTP 请求进行符号与实际地址的转换, 支持各种各样的"),s("strong",[t._v("服务健康检查方式, 还支持集中配置, K/V存储, 跨数据中心的数据交换等多种功能")]),t._v(", 可算是应用自身去解决服务发现的一个顶峰. 如今, 云原生时代来临, 基础设施的灵活性得到大幅度增强, 最初的使用基础设施来透明化地做服务发现的方式又重新被人们所重视, 如何在基础设施和网络协议层面, 对应用尽可能无感知, 方便地实现服务发现是目前服务发现的一个主要发展方向.")]),t._v(" "),s("h5",{attrs:{id:"_2-可用与可靠"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-可用与可靠"}},[t._v("#")]),t._v(" 2.可用与可靠")]),t._v(" "),s("p",[t._v("本节笔者并不打算介绍具体某一种服务发现工具的具体功能与操作, 而是会分析服务发现的"),s("strong",[t._v("通用的共性设计")]),t._v(', 探讨对比时下服务发现最常见的不同形式. 这里要讨论的第一个问题是"'),s("strong",[t._v("服务发现")]),t._v('"具体是指进行过什么操作? 这其实包含三个必需的过程.')]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("服务的注册")]),t._v("(Service Registration): 当服务启动的时候, 它应该通过某些形式(如调用 API, 产生事件消息, 在 ZooKeeper/etcd 的指定位置记录, 存入数据库, 等等)"),s("strong",[t._v("将自己的坐标信息通知到服务注册中心")]),t._v(", 这个过程可能由"),s("strong",[t._v("应用程序本身")]),t._v("来完成, 称为"),s("strong",[t._v("自注册模式")]),t._v(", 譬如 Spring Cloud 的 @EnableEurekaClient 注解; 也可能由"),s("strong",[t._v("容器编排框架或第三方注册工具")]),t._v("来完成, 称为"),s("strong",[t._v("第三方注册模式")]),t._v(", 譬如 Kubernetes 和 Registrator.")]),t._v(" "),s("li",[s("strong",[t._v("服务的维护")]),t._v("(Service Maintaining): 尽管服务发现框架通常都有提供下线机制, 但并没有什么办法保证每次服务都能优雅地下线(Graceful Shutdown)而不是由于宕机, 断网等原因突然失联. 所以服务发现框架必须"),s("strong",[t._v("自己保证所维护的服务列表的正确性")]),t._v(", 以避免告知消费者服务的坐标后, 得到的服务却不能使用的尴尬情况. 现在的服务发现框架, 往往都能支持多种协议(HTTP, TCP 等), 多种方式(长连接, 心跳, 探针, 进程状态等)去"),s("strong",[t._v("监控服务是否健康存活, 将不健康的服务自动从服务注册表中剔除")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("服务的发现")]),t._v("(Service Discovery): 这里的发现是特指狭义上"),s("strong",[t._v("消费者从服务发现框架中, 把一个符号")]),t._v("(譬如 Eureka 中的 ServiceID, Nacos 中的服务名, 或者通用的 FQDN)"),s("strong",[t._v("转换为服务实际坐标的过程")]),t._v(", 这个过程现在一般是通过 HTTP API 请求或者 DNS Lookup 操作来完成, 也有一些相对少用的方式, 譬如 Kubernetes 也支持注入环境变量来做服务发现.")])]),t._v(" "),s("p",[t._v("以上三点只是列举了"),s("strong",[t._v("服务发现必须提供的功能")]),t._v(", 在此之余还会有一些可选的"),s("strong",[t._v("扩展功能")]),t._v(", 譬如在服务发现时进行的"),s("strong",[t._v("负载均衡, 流量管控, 键值存储, 元数据管理, 业务分组")]),t._v("等等. 这里以服务发现为样本, 展示分布式环境里"),s("strong",[t._v("可用性与一致性的矛盾")]),t._v(". 从 CAP 定理开始, 到分布式共识算法, 我们已在理论上探讨过多次在服务的可用性和数据的可靠性之间的取舍, 但"),s("strong",[t._v("服务发现却面临着两者都难以舍弃的困境")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("服务发现既要高可用, 也要高可靠")]),t._v("是由它在整个系统中所处的位置所决定的. 在"),s("strong",[t._v("概念模型")]),t._v("里, 服务发现的位置如下图所示: 服务提供者在服务注册中心中注册, 续约和下线自己的真实坐标, 服务消费者根据某种符号从服务注册中心获取到真实坐标, 无论是服务注册中心, 服务提供者还是服务消费者, 它们都是系统服务中的一员, 相互间的关系应是对等的.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221224183219760.png",alt:"",title:"概念模型中的服务发现"}})]),t._v(" "),s("p",[t._v("但在真实的系统里, 注册中心的地位是特殊的, 不能完全视其为一个普通的服务. "),s("strong",[t._v("注册中心不依赖其他服务, 但被所有其他服务共同依赖, 是系统中最基础的服务")]),t._v("(地位与配置中心类似, 现在服务发现框架也开始同时提供配置中心的功能, 以避免配置中心又去专门摆弄出一集群的节点来), 几乎没有可能在业务层面进行容错. 这意味着"),s("strong",[t._v("服务注册中心一旦崩溃, 整个系统都不再可用, 因此, 必须尽最大努力保证服务发现的可用性")]),t._v(". 实际用于生产的分布式系统, 服务注册中心都是以"),s("strong",[t._v("集群")]),t._v("的方式进行部署的, 通常使用三个或者五个节点(最多七个, 一般也不会更多了, 否则日志复制的开销太高)来保证高可用, 如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221224184309920.png",alt:"image-20221224184309920",title:"真实系统中的服务发现"}})]),t._v(" "),s("p",[t._v("同时, 也请注意到上图中各服务注册中心节点之间的"),s("strong",[t._v("复制")]),t._v("(Replicate)字样, 用户当然期望在服务注册中心"),s("strong",[t._v("一直可用")]),t._v(", 永远健康的同时, 也能够在访问每一个节点时取到"),s("strong",[t._v("可靠一致的数据")]),t._v(", 而不是从注册中心拿到的服务地址可能已经下线, 但这"),s("strong",[t._v("两个需求就构成了 CAP 矛盾, 不可能同时满足")]),t._v(".")]),t._v(" "),s("p",[t._v("这里以最有代表性的 Netflix "),s("strong",[t._v("Eureka")]),t._v(" 和 Hashicorp "),s("strong",[t._v("Consul")]),t._v(" 为例.")]),t._v(" "),s("p",[t._v("Eureka 的选择是"),s("strong",[t._v("优先保证高可用性")]),t._v(", 相对牺牲系统中服务状态的一致性. Eureka 的各个节点间采用"),s("strong",[t._v("异步复制")]),t._v("来交换服务注册信息, 当有新服务注册进来时, 并不需要等待信息在其他节点复制完成, 而是马上在该服务发现节点宣告服务可见, 只是不保证在其他节点上多长时间后才会可见. 同时, 当有旧的服务发生变动, 譬如下线或者断网, 只会由"),s("strong",[t._v("超时机制")]),t._v("来控制何时从哪一个服务注册表中移除, "),s("strong",[t._v("变动信息不会实时同步给所有服务端与客户端")]),t._v(". 这样的设计使得不论是 Eureka 的服务端还是客户端, 都能够持有自己的服务注册表缓存, 并以 TTL(Time to Live)机制来进行更新, 哪怕服务注册中心完全崩溃, 客户端仍然可以维持最低限度的可用. Eureka 的服务发现模型适合于"),s("strong",[t._v("节点关系相对固定, 服务一般不会频繁上下线的系统")]),t._v(", 以较小的同步代价换取了最高的可用性; Eureka 能够选择这种模型的底气在于万一客户端拿到了已经发生变动的错误地址, 也能够通过 Ribbon 和 Hystrix 模块配合来兜底, 实现"),s("strong",[t._v("故障转移(Failover)或者快速失败(Failfast)")]),t._v(" .")]),t._v(" "),s("p",[t._v("Consul 的选择是"),s("strong",[t._v("优先保证高可靠性")]),t._v(", 相对牺牲系统服务发现的可用性. Consul 采用 Raft 算法, 要求"),s("strong",[t._v("多数节点写入成功后服务的注册或变动才算完成")]),t._v(", 严格地保证了在集群外部读取到的服务发现结果的"),s("strong",[t._v("一致性")]),t._v("; 同时采用 Gossip 协议, 支持多数据中心之间更大规模的服务同步. Consul 优先保证高可靠性在一定程度上是基于产品现实情况而做的技术决策, 它不像 Netflix OSS 那样有着全家桶式的微服务组件, 万一从服务发现中取到错误地址, 就没有其他组件为它兜底了. Eureka 与 Consul 的差异带来的影响主要不在于服务注册的快慢(当然, 快慢确实是有差别), 而在于你如何看待以下这件事情:")]),t._v(" "),s("p",[t._v("假设系统形成了 A, B 两个"),s("strong",[t._v("网络分区")]),t._v("后, A 区的服务只能从区域内的服务发现节点获取 A 区的服务坐标, B 区的服务只能取到在 B 区的服务坐标, 这对你的系统会有什么影响?")]),t._v(" "),s("ul",[s("li",[t._v("如果这件事情对你并没有太大的影响, 甚至有可能还是有益的, 就应该"),s("strong",[t._v("倾向于选择 AP 式")]),t._v("的服务发现. 譬如假设 A, B 就是不同的机房, 是机房间的网络交换机导致服务发现集群出现的分区问题, 但每个分区中的服务仍然能独立提供完整且正确的服务能力, 此时尽管不是有意为之, 但网络分区在事实上避免了跨机房的服务请求, 反而带来了服务调用链路优化的效果.")]),t._v(" "),s("li",[t._v("如果这件事情对系统影响非常大, 甚至可能带来比整个系统宕机更坏的结果, 就应该"),s("strong",[t._v("倾向于选择 CP 式")]),t._v("的服务发现. 譬如系统中大量依赖了集中式缓存, 消息总线, 或者其他有状态的服务, 一旦这些服务全部或者部分被分隔到某一个分区中, 会对整个系统的操作的正确性产生直接影响的话, 与其最后弄出一堆数据错误, 还不如直接停机.")])]),t._v(" "),s("h5",{attrs:{id:"_3-注册中心实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-注册中心实现"}},[t._v("#")]),t._v(" 3.注册中心实现")]),t._v(" "),s("p",[t._v("可用性与一致性的矛盾, 是分布式系统永恒的话题, 在服务发现这个场景里, "),s("strong",[t._v("权衡的主要关注点是相对更能容忍服务列表不可用的后果, 还是服务数据不准确的后果")]),t._v(', 其次才到性能高低, 功能是否强大, 使用是否方便等因素. 有了选择权衡, 很自然就引来了一个"务实"的话题, 现在有那么多服务发现框架, 哪一款最好? 或者说应该如何挑选适合的服务发现框架? 当下, 直接以服务发现, 服务注册中心为目标的组件库, 或者间接用来实现这个目标的工具主要有以下三类.')]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("在分布式 K/V 存储框架上自己开发的服务发现")]),t._v(', 典型代表是 ZooKeeper, Doozerd, etcd. 这些 K/V 框架提供了分布式环境下读写操作的共识算法, etcd 采用的是 Raft 算法, ZooKeeper 采用的是 ZAB 算法, 这也是一种 Multi Paxos 的派生算法, 所以采用这种方案, 就不必纠结 CP 还是 AP 的问题, 它们都是 CP 的(也曾有公司采用 Redis 来做服务发现, 这种自然是 AP 的). 这类框架的宣传语中往往会主动提及"高可用性", 潜台词是"在保证一致性和分区容忍性的前提下, 尽最大努力实现最高的可用性", 譬如 etcd 的宣传语就是"高可用的集中配置和服务发现"(Highly-Available Key Value Store for Shared Configuration and Service Discovery). 这些 K/V 框架的一个共同特点是在'),s("strong",[t._v("整体较高复杂度的架构和算法的外部, 维持着极为简单的应用接口")]),t._v(", 只有基本的 CRUD 和 Watch 等少量 API, 所以要在上面完成功能齐全的服务发现, "),s("strong",[t._v("很多基础的能力, 譬如服务如何注册, 如何做健康检查等都必须自己去实现")]),t._v(', 如今一般也只有"大厂"才会直接基于这些框架去做服务发现了.')]),t._v(" "),s("li",[s("strong",[t._v("以基础设施(主要是指DNS服务器)来实现服务发现")]),t._v(", 典型代表是 SkyDNS, CoreDNS. 在 Kubernetes 1.3 之前的版本使用 SkyDNS 作为默认的 DNS 服务, 其工作原理是从 API Server 中"),s("strong",[t._v("监听集群服务的变化")]),t._v(", 然后根据服务生成 NS, SRV 等 DNS 记录存放到 etcd 中, kubelet 会设置每个 Pod 的 DNS 服务的地址为 SkyDNS 的地址, 需要调用服务时, 只需查询 DNS 把域名转换成 IP 列表便可实现分布式的服务发现. 在 Kubernetes 1.3 之后, SkyDNS 不再是默认的 DNS 服务器, 而是由只将 DNS 记录存储在内存中的 KubeDNS 代替, 到了 1.11 版, 就更推荐采用扩展性很强的 CoreDNS, 此时可以通过各种插件来决定是否要采用 etcd 存储, 重定向, 定制 DNS 记录, 记录日志等等. 采用这种方案, 是 CP 还是 AP 就取决于"),s("strong",[t._v("后端采用何种存储")]),t._v(", 如果是基于 etcd 实现, 那自然是 CP 的, 如果是基于内存异步复制的方案实现, 那就是 AP 的(仅针对 DNS 服务器本身, 不考虑本地 DNS 缓存的 TTL 刷新). "),s("strong",[t._v("以基础设施来做服务发现, 好处是对应用透明")]),t._v(", 任何语言, 框架, 工具都肯定支持 HTTP, DNS, 所以完全不受程序技术选型的约束, 但坏处是透明的并不一定是简单的, 你必须自己考虑如何去做客户端负载均衡, 如何调用远程方法等这些问题, 而且必须遵循或者说受限于这些基础设施本身所采用的实现机制, 譬如服务健康检查里, 服务的缓存期限就应该由 TTL 决定, 这是 DNS 协议所规定的, 如果想改用 KeepAlive 长连接来实时判断服务是否存活就相对麻烦.")]),t._v(" "),s("li",[s("strong",[t._v("专门用于服务发现的框架和工具")]),t._v(", 典型代表是 "),s("strong",[t._v("Eureka, Consul 和 Nacos")]),t._v(". 在这一类框架中, 用户可以自己决定是 CP 还是 AP, 譬如 CP 的 Consul, AP 的 Eureka, 还有同时支持 CP 和 AP 的 Nacos("),s("strong",[t._v('Nacos采用类 Raft 协议实现 CP, 采用自研的 Distro 协议实现 AP, 这里"同时"是"都支持"的意思, 但必须二取其一, 不是说 CAP 全能满足')]),t._v("). 将它们划归一类是因为它们"),s("strong",[t._v("对应用并不是透明")]),t._v("的, 尽管 Consul 的主体逻辑是在服务进程之外, 以边车的形式提供; 尽管 Consul, Nacos 也支持基于 DNS 的服务发现; 尽管这些框架都基本做到了以声明代替编码, 譬如在 Spring Cloud 中只改动 pom.xml, 配置文件和注解即可实现, 但它们"),s("strong",[t._v("依然是可以被应用程序感知的")]),t._v(". 所以或多或少还需要考虑程序语言, 技术框架的集成问题. 但这个特点其实并不全是坏处, 譬如采用 Eureka 做服务注册, 那在远程调用服务时就可以用 OpenFeign 做客户端, 因为它们本身就已做好了集成, 写个声明式接口就能运行; 在做负载均衡时可以采用 Ribbon 做客户端, 需要换均衡算法时改个配置就成. "),s("strong",[t._v('这些"不透明"实际上都为编码开发带来了一定便捷, 但前提是你选用的语言和框架必须支持')]),t._v(".")])]),t._v(" "),s("h4",{attrs:{id:"网关路由"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网关路由"}},[t._v("#")]),t._v(" 网关路由")]),t._v(" "),s("p",[t._v("网关(Gateway)在计算机科学中, 尤其是在计算机网络中很常见, 用于表示位于内部区域边缘, 与外界进行交互的某个物理或逻辑设备, 譬如家里的路由器就属于家庭内网与互联网之间的网关.")]),t._v(" "),s("h5",{attrs:{id:"_1-网关的职责"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-网关的职责"}},[t._v("#")]),t._v(" 1.网关的职责")]),t._v(" "),s("p",[t._v('在单体架构下, 一般不太强调"网关"这个概念, 为各个单体系统的副本分发流量的负载均衡器实质上扮演了内部服务与外部请求之间的网关角色. 在微服务环境中, 网关的存在感就极大地增强了, 甚至成为微服务集群中必不可少的设施之一. 其中原因并不难理解: 微服务架构下, 每个服务节点都可能由不同团队负责, 都有着自己独立的, 互不相同的接口, 如果服务集群缺少一个'),s("strong",[t._v("统一对外交互的代理人角色")]),t._v(", 那外部的服务消费者就必须知道所有微服务节点在集群中的精确坐标, 这样消费者会受到服务集群的"),s("strong",[t._v("网络限制")]),t._v("(不能确保集群中每个节点都有外网连接), "),s("strong",[t._v("安全限制")]),t._v("(不仅是服务节点的安全, 外部自身也会受到如浏览器同源策略的约束), "),s("strong",[t._v("依赖限制")]),t._v("(服务坐标这类信息不属于对外接口承诺的内容, 随时可能变动, 不应该依赖它), 就算是调用服务的程序员, 也不会愿意记住每一个服务的坐标位置来编写代码. 由此可见, 微服务中网关的首要职责就是"),s("strong",[t._v("作为统一的出口对外提供服务, 将外部访问网关地址的流量, 根据适当的规则路由到内部集群中正确的服务节点之上")]),t._v(', 因此, 微服务中的网关, 也常被称为"'),s("strong",[t._v("服务网关")]),t._v('"或者"'),s("strong",[t._v("API 网关")]),t._v('", 微服务中的网关首先应该是个路由器, 在满足此前提的基础上, 还可以根据需要作为流量过滤器来使用, 以提供某些额外的'),s("strong",[t._v("可选职能")]),t._v(", 譬如安全, 认证, 授权, 限流, 监控, 缓存, 等等.")]),t._v(" "),s("p",[t._v("简言之:")]),t._v(" "),s("p",[s("strong",[t._v("网关 = 路由器(基础职能) + 过滤器(可选职能)")])]),t._v(" "),s("p",[t._v('针对"路由器"这个基础职能, 服务网关主要考量的是能够支持路由的"网络协议层次"和"性能与可用性"这两方面的因素. 网络协议层次是指负载均衡中介绍过的四层流量转发与七层流量代理. 仅从技术实现角度来看, 对于路由这项工作, 负载均衡器与服务网关在实现上是没有什么差别的, 很多服务网关本身就是基于老牌的负载均衡器来实现的, 譬如基于 Nginx, HAProxy 开发的 Ingress Controller, 基于 Netty 开发的 Zuul 2.0 等; 但从目的角度来看, '),s("strong",[t._v("负载均衡器与服务网关会有一些区别, 具体在于前者是为了根据均衡算法对流量进行平均地路由, 后者是为了根据流量中的")]),t._v("​"),s("mark",[s("strong",[t._v("某种特征")])]),t._v("​"),s("strong",[t._v("进行正确地路由")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("网关必须能够识别流量中的特征, 这意味着网关能够支持的网络通信协议的层次将会直接限制后端服务节点能够选择的服务通信方式")]),t._v(". 如果服务集群只提供像 etcd 这样直接基于 TCP 访问的服务, 那只部署四层网关便可满足, 网关以 IP 报文中源地址, 目标地址为特征进行路由; 如果服务集群要提供 "),s("strong",[t._v("HTTP")]),t._v(" 服务, 那就必须部署一个"),s("strong",[t._v("七层网关")]),t._v(", 网关以 HTTP 报文中的 "),s("strong",[t._v("URL, Header 等信息为特征进行路由")]),t._v("; 如果服务集群还要提供更上层的 WebSocket, SOAP 等服务, 那就必须要求网关同样能够支持这些上层协议, 才能从中提取到特征.")]),t._v(" "),s("p",[t._v("举个例子, 以下是一段基于 SpringCloud 实现的 Netflix Zuul 网关的配置, Zuul 是 HTTP 网关, /restful/accounts/ "),s("strong",[t._v("和 /restful/pay/")]),t._v("  是 HTTP 中的 "),s("strong",[t._v("URL 的特征")]),t._v(", 而配置中的 serviceId 就是路由的"),s("strong",[t._v("目标服务")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("routes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("account")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /restful/accounts/"),s("span",{pre:!0,attrs:{class:"token important"}},[t._v("**")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("serviceId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" account\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("stripPrefix")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("false")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("sensitiveHeaders")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"*"')]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("payment")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /restful/pay/"),s("span",{pre:!0,attrs:{class:"token important"}},[t._v("**")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("serviceId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" payment\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("stripPrefix")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("false")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("sensitiveHeaders")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"*"')]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br")])]),s("p",[t._v("今天围绕微服务的各种技术仍处于快速发展期, 笔者"),s("strong",[t._v("不提倡针对每一种工具, 框架本身去记忆配置细节")]),t._v(", 也就是说, 无须纠结上面配置的确切写法, 每个指令的含义. 如果从根本上理解了"),s("strong",[t._v("网关的原理")]),t._v(", 参考一下技术手册, 很容易就能够将上面的信息改写成 Kubernetes Ingress Controller, Istio VirtualServer 或其他服务网关所需的配置形式.")]),t._v(" "),s("p",[t._v("网关的另一个主要关注点是它的"),s("strong",[t._v("性能与可用性")]),t._v(". 由于网关是"),s("strong",[t._v("所有服务对外的总出口, 是流量必经之地, 所以网关的路由性能将导致全局的, 系统性的影响")]),t._v(", 如果经过网关路由会有 1 毫秒的性能损失, 就意味着整个系统所有服务的响应延迟都会增加 1 毫秒. 网关的性能与它的工作模式和自身实现算法都有关系, 但毫无疑问工作模式是最关键的因素, 如果能够采用 DSR 三角传输模式, 在实现原理上就决定了性能一定会比代理模式来的强(DSR, IP Tunnel, NAT, 代理等这些都是网络基础知识). 不过, 因为今天 REST 和 JSON-RPC 等基于 HTTP 协议的服务接口在对外部提供的服务中占绝对主流的地位, 所以"),s("strong",[t._v("讨论的服务网关默认都必须支持七层路由")]),t._v(", 通常默认无法直接进行流量转发, 只能采用"),s("strong",[t._v("代理模式")]),t._v(". 在这个前提约束下, 网关的性能主要取决于它们如何代理网络请求, 也即它们的"),s("strong",[t._v("网络 I/O 模型")]),t._v(", 下面正好借这个场景介绍一下网络 I/O 的基础知识.")]),t._v(" "),s("h5",{attrs:{id:"_2-网络i-o模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-网络i-o模型"}},[t._v("#")]),t._v(" 2.网络I/O模型")]),t._v(" "),s("p",[t._v("在套接字接口抽象下, 网络 I/O 的出入口就是 "),s("strong",[t._v("Socket 的读和写")]),t._v(", Socket 在操作系统接口中被抽象为"),s("strong",[t._v("数据流")]),t._v(", 而网络 I/O 可以理解为对流的操作. 每一次网络访问, 从远程主机返回的数据会先存放到操作系统"),s("strong",[t._v("内核的缓冲区")]),t._v("中, 然后"),s("strong",[t._v("从内核的缓冲区复制到应用程序的地址空间")]),t._v(', 所以当发生一次网络请求时, 将会按顺序经历"'),s("strong",[t._v("等待数据从远程主机到达缓冲区")]),t._v('"和"'),s("strong",[t._v("将数据从缓冲区复制到应用程序地址空间")]),t._v('"两个阶段, 根据实现这两个阶段的不同方法, 人们把网络 I/O 模型总结为两类, 五种模型: 两类是指'),s("strong",[t._v("同步 I/O 与异步 I/O")]),t._v(", 五种是指在同步 I/O 中又划分出"),s("strong",[t._v("阻塞 I/O, 非阻塞 I/O, 多路复用 I/O, 信号驱动 I/O 四种细分模型以及异步 I/O 模型")]),t._v(".")]),t._v(" "),s("p",[t._v("先解释一下同步和异步, 阻塞和非阻塞的概念. "),s("strong",[t._v("同步")]),t._v("是指调用端在发出请求之后, 得到结果之前必须一直等待, 与之相对的就是异步, 发出调用请求之后将立即返回, 不会马上得到处理结果, 结果将通过状态变化和回调来通知调用者. "),s("strong",[t._v("阻塞和非阻塞")]),t._v('是针对请求处理过程而言, 指在收到调用请求之后, 返回结果之前, 当前处理线程是否会被挂起. 这种概念上的叙述可能还是不太好理解, 这里以"你如何领到盒饭"为情景, 将之类比解释如下.')]),t._v(" "),s("p",[t._v("(1) 异步 I/O(Asynchronous I/O): 你外卖订了个盒饭, 付款之后你自己该干嘛干嘛, 饭送到时骑手自然会打电话通知你. 异步 I/O 中数据到达缓冲区后, 不需要由调用进程主动进行从缓冲区复制数据的操作, 而是复制完成后由操作系统向线程发送信号, 所以它一定是"),s("strong",[t._v("非阻塞")]),t._v("的.")]),t._v(" "),s("p",[t._v("(2) 同步 I/O(Synchronous I/O): 比如你自己去饭堂打饭, 这时可能有如下情形发生.")]),t._v(" "),s("ul",[s("li",[t._v("阻塞 I/O(Blocking I/O): 你去饭堂打饭, 发现饭还没做好, 只能等待(线程休眠), 直到饭做好, 这就是被阻塞了. 阻塞 I/O 是最直观的 I/O 模型, 逻辑清晰, 也比较节省 CPU 资源, 但缺点是线程休眠所带来的上下文切换, 这是一种需要切换到内核态的重负载操作, 不应当频繁进行.")]),t._v(" "),s("li",[t._v("非阻塞 I/O(Non-Blocking I/O): 你去饭堂, 发现饭还没做好, 你就回去了, 然后每隔 10 分钟来一次饭堂看饭是否做好, 一直重复, 直到饭做好. 非阻塞 I/O 能够避免线程休眠, 对于一些很快就能返回结果的请求, 非阻塞 I/O 可以节省切换上下文切换的消耗, 但是对于较长时间才能返回的请求, 非阻塞 I/O 反而白白浪费了 CPU 资源, 所以目前并不太常用.")]),t._v(" "),s("li",[t._v("多路复用 I/O(Multiplexing I/O): 多路复用 I/O 本质上是阻塞 I/O 的一种, 但是它的好处是可以在"),s("strong",[t._v("同一条阻塞线程上处理多个不同端口的监听")]),t._v(". 仍以去食堂打饭为例, 比如你代表整个宿舍去饭堂打饭, 去到饭堂, 发现饭还没做好, 还是继续等待, 其中某个舍友的饭好了, 你就马上把那份饭送回去, 然后继续等待其他舍友的饭做好. "),s("strong",[t._v("多路复用 I/O 是目前高并发网络应用的主流")]),t._v(", 它还可以细分为 select, epoll, kqueue 等不同实现.")]),t._v(" "),s("li",[t._v('信号驱动 I/O(Signal-Driven I/O): 你去到饭堂, 发现饭还没做好, 但你跟厨师很熟, 跟他说饭做好了叫你, 然后你就回去了, 等收到厨师通知后, 你再去饭堂把饭拿回宿舍. 这里厨师的通知就是那个"'),s("strong",[t._v("信号")]),t._v('", 信号驱动 I/O 与异步 I/O 的区别是"'),s("strong",[t._v("从缓冲区获取数据")]),t._v('"这个步骤的处理, 前者收到的通知是可以开始进行复制操作了, 即要你自己从饭堂拿回宿舍, 在复制完成之前线程处于阻塞状态, 所以它仍属于同步 I/O 操作, 而后者收到的通知是复制操作已经完成, 即外卖小哥已经把饭送到了.')])]),t._v(" "),s("p",[t._v("显然, "),s("strong",[t._v("异步 I/O 模型是最方便")]),t._v("的, 但前提是系统支持异步操作. "),s("strong",[t._v("异步 I/O 受限于操作系统")]),t._v(", Windows NT 内核早在 3.5 以后, 就通过 IOCP 实现了真正的异步 I/O 模型. 而 Linux 系统是在 "),s("strong",[t._v("Linux Kernel 2.6 才首次引入, 目前还不算很完善, 因此在 Linux 系统下实现高并发网络编程时仍以多路复用 I/O 模型模式为主")]),t._v(".")]),t._v(" "),s("p",[t._v("回到服务网关的话题上, 有了网络 I/O 模型的知识, 就可以在理论上定性分析不同七层网关的性能差异了. 七层服务网关处理一次请求代理时, 包含"),s("strong",[t._v("两组网络操作")]),t._v(", 分别是"),s("strong",[t._v("作为服务端对外部请求的应答和作为客户端对内部服务的请求")]),t._v(", 理论上这两组网络操作可以采用不同的模型去完成, 但一般没有必要这样做.")]),t._v(" "),s("p",[t._v('以 Zuul 网关为例, 在 Zuul 1.0 时, 它采用的是阻塞 I/O 模型来进行最经典的"一条线程对应一个连接"(Thread-per-Connection)的方式来代理流量. 采用阻塞 I/O 模型意味着它会有线程休眠, 就有上下文切换的成本, 所以如果后端服务普遍属于计算密集型(CPU Bound, 可以通俗理解为服务耗时比较长, 主要消耗在 CPU 上)时, 这种模型能够相对节省网关的 CPU 资源, 但如果后端服务普遍都是 I/ O密集型(I/O Bound, 可以理解为服务都很快返回, 主要消耗在 I/O 上), 它就会由于频繁的上下文切换而降低性能. Zuul 2.0 版本最大的改进就是'),s("strong",[t._v("基于 Netty Server 实现了异步 I/O 模型")]),t._v("来处理请求, 大幅度减少了线程数, 获得了更高的性能和更低的延迟. 根据 Netflix 官方给出的数据, Zuul 2.0 大约要比 Zuul 1.0 快上 20% 左右. 还有一些网关甚至支持自行配置, 或者根据环境选择不同的网络 I/O 模型, 典型代表就是 Nginx, 它可以支持在配置文件中指定 select, poll, epoll, kqueue 等并发模型.")]),t._v(" "),s("p",[t._v("网关还有最后一点必须关注的是它的"),s("strong",[t._v("可用性问题")]),t._v(". 任何系统的网络调用过程中都至少会有一个"),s("strong",[t._v("单点")]),t._v("存在, 这是由用户只通过"),s("strong",[t._v("唯一的地址")]),t._v("去访问系统所决定的. 即使是淘宝, 亚马逊这样全球多数据中心部署的大型系统也不例外. 对于更普遍的小型系统来说, 作为后端对外服务代理人角色的网关经常被视为整个系统的入口, 往往很容易成为网络访问中的单点, 这时候它的可用性就尤为重要. 由于"),s("strong",[t._v("网关的地址具有唯一性")]),t._v(", 所以不能像之前服务发现那些注册中心那样, 用集群的方式解决问题. 在网关的可用性方面, 应该考虑到以下几点.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("网关应尽可能轻量")]),t._v(", 尽管网关作为服务集群统一的出入口, 可以很方便地实现安全, 认证, 授权, 限流, 监控等功能, 但给网关附加这些功能时还是要仔细权衡, 取得功能性与可用性之间的平衡, 过度增加网关的功能是危险的.")]),t._v(" "),s("li",[t._v("网关选型时, 应该尽可能"),s("strong",[t._v("选择较成熟的产品")]),t._v("实现, 譬如 Nginx Ingress Controller, KONG, Zuul 这些经过长期考验的产品, 而不能一味只考虑性能选择最新的产品, 性能与可用性之间的平衡也需要权衡.")]),t._v(" "),s("li",[t._v("在需要高可用的生产环境中, "),s("strong",[t._v("应当考虑在网关之前部署负载均衡器或者等价路由器")]),t._v("(ECMP), 让那些更成熟健壮的设施(往往是硬件物理设备)去充当整个系统的入口地址, 这样网关也可以进行扩展.")])]),t._v(" "),s("h5",{attrs:{id:"_3-bff网关"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-bff网关"}},[t._v("#")]),t._v(" 3.BFF网关")]),t._v(" "),s("p",[t._v("提到网关的"),s("strong",[t._v("唯一性, 高可用与扩展")]),t._v(', 这里介绍一下近年来随着微服务一起火起来的概念"'),s("strong",[t._v("BFF")]),t._v('"(Backend for Frontend), 如下图所示. 这个概念目前还没有特别权威的中文翻译, 在讨论的上下文里, 它的意思是: '),s("strong",[t._v("网关不必为所有的前端提供无差别的服务, 而是应该针对不同的前端, 聚合不同的服务, 提供不同的接口和网络访问协议支持")]),t._v(". 譬如, 运行于浏览器的 Web 程序, 由于浏览器一般只支持 HTTP 协议, 服务网关就应提供 REST 等基于 HTTP 协议的服务, 但同时也可以针对运行于桌面系统的程序部署另外一套网关, 它能与 Web 网关有完全不同的技术选型, 能提供基于更高性能协议(如 gRPC)的接口以提供更好的体验. 在网关这种边缘节点上, 针对同样的后端集群, 裁剪, 适配, 聚合出适应不一样的前端的服务, 有助于后端的稳定, 也有助于前端的赋能.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221224224735740.png",alt:"",title:"BFF网关"}})]),t._v(" "),s("h4",{attrs:{id:"客户端负载均衡"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#客户端负载均衡"}},[t._v("#")]),t._v(" 客户端负载均衡")]),t._v(" "),s("p",[t._v('先来弄清楚几个容易混淆的相似概念, 分别是本章中频繁提到的服务发现, 网关路由, 负载均衡以及在后面将会介绍的服务容错. 这几个技术名词都带有"从服务集群中寻找到一个合适的服务来调用"的含义, 笔者会通过以下具体场景来说明它们之间的差别.')]),t._v(" "),s("p",[t._v("假设你身处广东, 要上 Fenix’s Bookstore 购买一本书, 在程序业务逻辑里, 购书的其中一个关键步骤是调用商品出库服务来完成货物准备, 在代码中该服务的调用请求为:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[t._v("PATCH https://warehouse:8080/restful/stockpile/3\n{amount: -1}\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("假设 Fenix’s Bookstore 是个大书店, 在北京, 武汉, 广州均部署有服务集群机房, 你的购物请求从浏览器发出后, 服务端按顺序发生如下事件.")]),t._v(" "),s("p",[t._v("(1)首先是将 warehouse 这个服务名称转换为恰当的"),s("strong",[t._v("服务地址")]),t._v(', "恰当"是个宽泛的描述, 一种典型的"恰当"便是因调用请求来自广东, 优先分配给物理传输距离最短的广州机房来应答. 其实按常理来说这次出库服务的调用应该是集群内的流量, 而不是用户浏览器直接发出的请求, 所以尽管结果没有不同, 但更接近实际的情况是用户访问首页时已经被 DNS 服务器分配到了广州机房, 请求出库服务时, 应优先选择'),s("strong",[t._v("同机房的服务")]),t._v("进行调用, 此时请求变为:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[t._v("PATCH https://guangzhou-ip-wan:8080/restful/stockpile/3\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("(2)广州机房的服务网关将该"),s("strong",[t._v("请求与配置中的特征进行比对")]),t._v(", 由 URL 中的 /restful/stockpile/** 得知该请求访问的是商品出库服务, 因此将请求的 IP 地址转换为内网中 warehouse 服务集群的入口地址:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[t._v("PATCH https://warehouse-gz-lan:8080/restful/stockpile/3\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("(3)集群中部署了多个 warehouse 服务, 收到调用请求后, 负载均衡器要在多个服务中根据某个标准(均衡策略)——可能是随机挑选, 也可能是按顺序轮询, 还可能是选择此前调用次数最少的那个, 等等, 找出要响应本次调用请求的服务, 称其为 warehouse-gz-lan-node1.")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[t._v("PATCH https://warehouse-gz-lan-node1:8080/restful/stockpile/3\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("(4)如果访问 warehouse-gz-lan-node1 服务, 没有返回需要的结果, 而是抛出 500 错.")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token response-status"}},[s("span",{pre:!0,attrs:{class:"token http-version property"}},[t._v("HTTP/1.1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token status-code number"}},[t._v("500")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token reason-phrase string"}},[t._v("Internal Server Error")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("(5)根据预置的"),s("strong",[t._v("故障转移策略")]),t._v(", 重新将调用分配给能够提供服务的其他节点, 称其为 warehouse-gz-lan-node2.")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[t._v("PATCH https://warehouse-gz-lan-node2:8080/restful/stockpile/3\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("(6)warehouse-gz-lan-node2 服务返回商品出库成功.")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token response-status"}},[s("span",{pre:!0,attrs:{class:"token http-version property"}},[t._v("HTTP/1.1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token status-code number"}},[t._v("200")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token reason-phrase string"}},[t._v("OK")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("以上过程从整体上看, 步骤 1, 2, 3, 5, 分别对应了"),s("strong",[t._v("服务发现, 网关路由, 负载均衡和服务容错")]),t._v(", 从细节上看, 其中部分职责又是有"),s("strong",[t._v("交叉")]),t._v('的, 并不是服务注册中心就只关心服务发现, 网关只关心路由, 负载均衡器只关心流量负载均衡. 譬如, 在步骤 1 的服务发现的过程中, "根据请求来源的物理位置来分配机房"的操作本质上是根据请求中的特征(地理位置)进行'),s("strong",[t._v("流量分发")]),t._v(", 这实际是一种路由行为. 在实际系统中, DNS 服务器(DNS 智能线路), 服务注册中心(如 Eureka 等框架中的 Region, Zone 概念)或者负载均衡器(可用区负载均衡, 如 AWS 的 NLB, 或 Envoy 的 Region, Zone, Sub-zone)中都有可能实现这种路由行为.")]),t._v(" "),s("p",[t._v("此外, 你是否感觉到以上网络调用过程似乎过于烦琐了, 一个从广州机房内网发出的服务请求, 绕到了网络边缘的网关, 负载均衡器这些设施上, 再被分配回内网中另外一个服务去响应, 不仅消耗了带宽, 降低了性能, 也增加了链路上的风险和运维的复杂度. 可是, 如果流量不经过这些设施, 它们相应的职责就无法发挥作用, 譬如不经过负载均衡器的话, 连请求应该具体交给哪一个服务去处理都无法确定, 这有办法简化吗?")]),t._v(" "),s("h5",{attrs:{id:"_1-客户端负载均衡器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-客户端负载均衡器"}},[t._v("#")]),t._v(" 1.客户端负载均衡器")]),t._v(" "),s("p",[t._v("对于任何一个大型系统, 负载均衡器都是必不可少的设施. 以前, 负载均衡器大多只部署在整个服务集群的前端, 负责将用户的请求分流到各个服务进行处理, 这种经典的部署形式现在被称为集中式的负载均衡. 随着微服务日渐流行, 服务集群收到的请求来源不再局限于外部, 而是"),s("strong",[t._v("越来越多的来源于集群内部的某个服务")]),t._v(", 并由集群内部的另一个服务进行响应, 对于"),s("strong",[t._v("这类流量的负载均衡")]),t._v(", 既有的方案依然是可行的, 但针对内部流量的特点, 直接在服务集群内部消化掉, 肯定是更合理且更受开发者青睐的办法. "),s("strong",[t._v("由此一种全新的, 独立位于每个服务前端的, 分散式的负载均衡方式")]),t._v("逐渐流行起来, 这就是本节要讨论的主角: "),s("strong",[t._v("客户端负载均衡器")]),t._v("(Client-Side Load Balancer), 如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221224231255417-1894778.png",alt:"",title:"客户端负载均衡器"}})]),t._v(" "),s("p",[t._v('客户端负载均衡器的理念提出以后, 此前的集中式负载均衡器也有了一个方便与它对比的名字--"服务端负载均衡器"(Server-Side Load Balancer). 从上图中能够清晰地看到客户端负载均衡器的特点, 也是它与服务端负载均衡器的关键差别所在: '),s("mark",[s("strong",[t._v("客户端均衡器是和服务实例一一对应的, 而且与服务实例并存于同一个进程内")])]),t._v(". 这个特点能为它带来很多好处.")]),t._v(" "),s("ul",[s("li",[t._v("负载均衡器与服务之间的信息交换是进程内的方法调用, 不存在任何额外的网络开销.")]),t._v(" "),s("li",[t._v("不依赖集群边缘的设施, 所有"),s("strong",[t._v("内部流量都仅在服务集群的内部循环")]),t._v(', 避免了前文那样, 集群内部流量要"绕场一周"的尴尬局面.')]),t._v(" "),s("li",[t._v("分散式的负载均衡器意味着天然避免了集中式的单点问题, 它的带宽资源将不会像集中式负载均衡器那样敏感, 这在以七层负载均衡器为主流, 不能通过 IP 隧道和三角传输这样的方式节省带宽的微服务环境中显得更具优势.")]),t._v(" "),s("li",[t._v("客户端负载均衡器更加"),s("strong",[t._v("灵活")]),t._v(", 能够针对每一个服务实例单独设置均衡策略等参数, 例如访问哪个服务, 是否需要具备亲和性, 选择服务的策略是随机, 轮询, 加权还是最小连接, 等等, 都可以单独设置而不影响其他服务.")])]),t._v(" "),s("p",[t._v("但是客户端负载均衡器也存在不少缺点.")]),t._v(" "),s("ul",[s("li",[t._v("它与服务运行于"),s("strong",[t._v("同一个进程")]),t._v("内, 意味着它的选型受到服务所使用的"),s("strong",[t._v("编程语言的限制")]),t._v(", 譬如用 Go 开发的微服务就不太可能搭配 Spring Cloud 的负载均衡器来使用, 而为每种语言都实现对应的能够支持复杂网络情况的负载均衡器是非常难的. 客户端负载均衡器的这个缺陷有违于微服务中技术异构不应受到限制的原则.")]),t._v(" "),s("li",[t._v("从个体服务来看, 由于是共用一个进程, "),s("strong",[t._v("负载均衡器的稳定性会直接影响整个服务进程的稳定性")]),t._v(", 消耗的 CPU, 内存等资源也同样影响到服务的可用资源. 从集群整体来看, 在服务数量达成千乃至上万规模时, 客户端负载均衡器消耗的资源总量是相当多的.")]),t._v(" "),s("li",[t._v("由于请求的来源可能是集群中任意一个服务节点, 而不再是统一来自集中式负载均衡器, 使得内部"),s("strong",[t._v("网络安全和信任关系变得复杂")]),t._v(", 当攻破任何一个服务时, 更容易通过该服务突破集群中的其他部分.")]),t._v(" "),s("li",[t._v("服务集群的拓扑关系是动态的, 每一个客户端均衡器必须持续跟踪其他服务的健康状况, 以实现上线新服务, 下线旧服务, 自动剔除失败服务, 自动重连恢复服务等负载均衡器必须具备的功能. 由于这些操作都需要通过访问服务注册中心来完成, 数量庞大的客户端负载均衡器一直持续轮询服务注册中心, 也会带来不小的负担.")])]),t._v(" "),s("h5",{attrs:{id:"_2-代理负载均衡器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-代理负载均衡器"}},[t._v("#")]),t._v(" 2.代理负载均衡器")]),t._v(" "),s("p",[t._v("在 Java 领域, 客户端均衡器中最具代表性的产品是 Netflix "),s("strong",[t._v("Ribbon")]),t._v(" 和 Spring Cloud "),s("strong",[t._v("LoadBalancer")]),t._v(", 随着微服务的流行, 它们在 Java 微服务中已积聚了相当可观的使用者. 直到最近两三年, "),s("strong",[t._v("服务网格")]),t._v('(Service Mesh)开始逐渐盛行, 另外一种被称为"'),s("strong",[t._v("代理客户端负载均衡器")]),t._v('"(Proxy Client-Side Load Balancer, 后文简称"'),s("strong",[t._v("代理均衡器")]),t._v('")的'),s("strong",[t._v("客户端负载均衡器变体形式")]),t._v("开始引起不同编程语言的微服务开发者的共同关注, 它弥补了此前客户端负载均衡器的大多数缺陷. 代理均衡器对此前的客户端负载均衡器的改进是"),s("strong",[t._v("将原本嵌入在服务进程中的负载均衡器提取出来, 作为一个进程之外, 同一 Pod 之内的特殊服务, 放到边车代理中去实现")]),t._v(", 它的流量关系如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221224231825391-1895107.png",alt:"",title:"代理负载均衡器"}})]),t._v(" "),s("p",[t._v("虽然代理均衡器与服务实例不再是进程内通信, 而是通过"),s("strong",[t._v("网络协议栈进行数据交换")]),t._v(", 数据要经过操作系统的协议栈, 要进行打包拆包, 计算校验和, 维护序列号等网络数据的收发步骤, 比之前的客户端均衡器确实多增加了一系列处理步骤. 不过, "),s("strong",[t._v("Kubernetes 严格保证了同一个 Pod 中的容器不会跨越不同的节点")]),t._v(", 这些容器共享同一个网络名称空间, 因此代理均衡器与服务实例的交互, 实质上是对"),s("strong",[t._v("本机回环设备的访问")]),t._v(", 仍然要比真正的网络交互高效且稳定得多. 代理均衡器付出的代价较小, 但从服务进程中分离出来所获得的收益却是非常显著的.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("代理均衡器不再受编程语言的限制")]),t._v(". 开发一个支持 Java, Go, Python 等所有微服务应用服务的"),s("strong",[t._v("通用代理均衡器")]),t._v("具有很高的性价比. 集中不同编程语言的使用者的力量, 更容易打造出能面对复杂网络情况的, 高效健壮的负载均衡器. 即使退一步说, 独立于服务进程的均衡器也不会由于自身的稳定性影响到服务进程的稳定.")]),t._v(" "),s("li",[s("strong",[t._v("在服务拓扑感知方面, 代理均衡器也更有优势")]),t._v(". 由于边车代理接受"),s("strong",[t._v("控制平面的统一管理")]),t._v(", 当服务节点拓扑关系发生变化时, 控制平面就会主动向边车代理发送更新服务清单的控制指令, 这避免了此前客户端负载均衡器必须长期主动轮询服务注册中心所造成的浪费.")]),t._v(" "),s("li",[s("strong",[t._v("在安全性, 可观测性上, 由于边车代理都是一致的实现")]),t._v(", 有利于在服务间建立双向 mTLS 通信, 也有利于对整个调用链路给出更详细的统计信息.")])]),t._v(" "),s("p",[t._v("总体而言, "),s("strong",[t._v("边车代理这种通过同一个 Pod 的独立容器实现的负载均衡器是目前处理微服务集群内部流量最理想的方式")]),t._v(", 只是服务网格本身仍是初生事物, 还不够成熟, 对操作系统, 网络和运维方面的知识要求也较高, 但有理由相信随着时间的推移, 未来这将会是微服务的主流通信方式.")]),t._v(" "),s("h5",{attrs:{id:"_3-地域与区域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-地域与区域"}},[t._v("#")]),t._v(" 3.地域与区域")]),t._v(" "),s("p",[t._v("最后再谈一个与负载均衡相关, 但又不只应用于负载均衡的概念: "),s("strong",[t._v("地域与区域")]),t._v(". 你是否注意到在微服务相关的许多设施中, 都带有 Region, Zone 参数, 如前文中提到的服务注册中心 Eureka 的 Region, Zone, 边车代理 Envoy 中的 Region, Zone, Sub-zone, 而且几乎所有云计算设备都有类似的概念. Region 和 Zone 是公有云计算先驱亚马逊 AWS 提出的概念, 它们的含义如下.")]),t._v(" "),s("p",[s("strong",[t._v("Region 是地域的意思")]),t._v(", 譬如华北, 东北, 华东, 华南, 这些都是地域范围. 面向全球或全国的大型系统的服务集群往往会部署在多个不同地域, 大型系统就是通过"),s("strong",[t._v("不同地域的机房")]),t._v("来缩短用户与服务器之间的物理距离, 以提升响应速度, 对于小型系统, 地域一般就只在异地容灾时才会涉及. 需要注意, "),s("strong",[t._v("不同地域之间是没有内网连接")]),t._v("的, 所有流量都只能通过公网相连, 如果"),s("strong",[t._v("微服务的流量跨越了地域, 实际就跟调用外部服务商提供的互联网服务没有任何差别")]),t._v("了. 所以集群内部流量是不会跨地域的, "),s("strong",[t._v("服务发现, 负载均衡器默认也是不会支持跨地域的服务发现和负载均衡")]),t._v("的.")]),t._v(" "),s("p",[s("strong",[t._v("Zone 是区域的意思")]),t._v(", 它是"),s("strong",[t._v("可用区域")]),t._v("(Availability Zone)的简称. 区域指在地理上位于"),s("strong",[t._v("同一地域")]),t._v("内, 但"),s("strong",[t._v("电力和网络是互相独立的物理区域")]),t._v(", 譬如在华东的上海, 杭州, 苏州的不同机房就是同一个地域的几个可用区域. 同一个地域的"),s("strong",[t._v("可用区域之间具有内网连接")]),t._v(", 流量不占用公网带宽, 因此区域是微服务集群内流量能够触及的最大范围. 但你的应用是只部署在同一区域内, 还是部署到几个不同可用区域中, 要取决于你是否有做异地双活的需求, 以及对网络延时的容忍程度.")]),t._v(" "),s("ul",[s("li",[t._v('如果追求高可用, 譬如希望系统在某个地区发生电力或者骨干网络中断时仍然可用, 那可以考虑将系统部署在多个区域中. 注意异地容灾和异地双活的差别: 容灾是非实时的同步, 而双活是实时或者准实时的, 跨地域或者跨区域做容灾都可以, 但一般只能跨区域做双活, 当然, 也可以将它们结合起来使用, 即"两地三中心"模式.')]),t._v(" "),s("li",[t._v("如果你追求低延迟, 譬如对时间有高要求的 SLA 应用, 或者网络游戏服务器等, 那就应该考虑将系统的所有服务都部署在同一个区域中, 因为尽管内网连接不受限于公网带宽, 但毕竟机房之间的专线容量也是有限的, 难以跟机房内部的交换机相比, 延时也受物理距离, 网络跳点数量等因素的影响.")])]),t._v(" "),s("p",[t._v("可用区域对应城市级别的区域的范围, 但在一些场景中仍是过大了, 即使是同一个区域中的机房, 也可能存在具有差异的不同子网络, 所以在部分微服务框架也提供了 Group, Sub-zone 等参数做进一步的细分控制, 这些参数的意思通常是加权或优先访问同一个子区域的服务, 但如果子区域中没有合适的, 则仍然会访问到可用区域中的其他服务.")]),t._v(" "),s("p",[t._v("地域和区域原本是云计算中的概念, 对于一些中小型的微服务系统, 尤其是非互联网的企业信息系统, 很多仍然没有使用云计算设施, 只部署在某个专有机房内部, 只为特定人群提供服务, 这就不需要涉及地理上地域, 区域的概念了. 此时完全可以自己灵活延拓 Region, Zone 参数的含义, 达到优化虚拟化基础设施流量的目的. 譬如, 将服务发现的区域设置与 Kubernetes 的标签, 选择器配合, 实现内部服务请求其他服务时, 优先使用同一个节点中提供的服务进行应答, 以降低真实的网络消耗.")]),t._v(" "),s("h3",{attrs:{id:"流量治理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#流量治理"}},[t._v("#")]),t._v(" 流量治理")]),t._v(" "),s("p",[s("strong",[t._v("容错性设计")]),t._v("(Design for Failure)是微服务的另一个"),s("strong",[t._v("核心原则")]),t._v(", 也是笔者书中反复强调的"),s("strong",[t._v("开发观念转变")]),t._v(". 不过, 即使已经有一定的心理准备, 大多数首次将微服务架构引入实际生产系统的开发者, 在服务发现, 网关路由等支持下, 踏出了服务化的第一步以后, 很可能仍会经历一段阵痛期, 随着"),s("strong",[t._v("拆分出的服务越来越多")]),t._v(", 随之而来会面临以下两个问题的困扰.")]),t._v(" "),s("ul",[s("li",[t._v("由于某一个服务的崩溃, 导致所有用到这个服务的其他服务都无法正常工作, 一个点的错误经过层层传递, 最终波及调用链上与此有关的所有服务, 这便是"),s("strong",[t._v("雪崩效应")]),t._v(". "),s("strong",[t._v("如何防止雪崩效应便是微服务架构容错性设计原则的具体实践, 否则服务化程度越高, 整个系统反而越不稳定")]),t._v(".")]),t._v(" "),s("li",[t._v("服务虽然没有崩溃, 但由于处理能力有限, 面临超过预期的突发请求时, "),s("strong",[t._v("大部分请求直至超时都无法完成处理")]),t._v(". 这种现象产生的后果与交通堵塞类似, 如果一开始没有得到及时的治理, 后面就需要很长时间才能使全部服务都恢复正常.")])]),t._v(" "),s("p",[t._v("本章将围绕以上两个问题, 提出"),s("strong",[t._v("服务容错, 流量控制")]),t._v("等一系列解决方案. 这些措施并不是孤立的, 它们相互之间存在很多联系, 其中许多功能必须与此前介绍过的服务注册中心, 服务网关, 负载均衡器配合才能实现. 理清楚这些技术措施背后的逻辑链条, 是了解它们工作原理的捷径.")]),t._v(" "),s("h4",{attrs:{id:"服务容错"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务容错"}},[t._v("#")]),t._v(" 服务容错")]),t._v(" "),s("p",[t._v('Martin Fowler 与 James Lewis 提出的"微服务的九个核心特征"是构建微服务系统的指导性原则, 但不是技术规范, 没有严格的约束力. 在实际构建系统时, 其中多数特征可能会有或多或少的妥协, 譬如分散治理, 数据去中心化, 轻量级通信机制, 演进式设计, 等等. 但也'),s("strong",[t._v("有一些特征是不能妥协的")]),t._v(", 其中的典型就是: 容错性设计.")]),t._v(" "),s("p",[s("strong",[t._v("容错性设计不能妥协的原因是分布式系统的不可靠性")]),t._v('. 一个大的服务集群中, 程序可能崩溃, 节点可能宕机, 网络可能中断, 这些"意外情况"其实全部都在"意料之中". 原本信息系统设计成分布式架构的主要动力之一就是为了提升系统的可用性, 最低限度也必须保证将原有系统重构为分布式架构之后, 可用性不下降才行. 如果服务集群中出现任何一点差错都能让系统面临"千里之堤溃于蚁穴"的风险, 那分布式恐怕就没有机会成为一种可用的系统架构形式了.')]),t._v(" "),s("h5",{attrs:{id:"_1-容错策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-容错策略"}},[t._v("#")]),t._v(" 1.容错策略")]),t._v(" "),s("p",[t._v("要落实容错性设计这条原则, 除了要从思想观念上转变过来, "),s("strong",[t._v("正视程序必然是会出错的")]),t._v(", 并对它进行有计划的防御之外, 还必须了解一些常用的"),s("strong",[t._v("容错策略和容错设计模式")]),t._v(", 作为具体设计与编码实践的指导. 这里的"),s("strong",[t._v("容错策略")]),t._v('指的是 "'),s("strong",[t._v("面对故障, 我们该做些什么")]),t._v('", 而'),s("strong",[t._v("容错设计模式")]),t._v('指的是 "'),s("strong",[t._v("要实现某种容错策略, 我们该如何去做")]),t._v('".')]),t._v(" "),s("p",[t._v("常见的"),s("strong",[t._v("容错策略")]),t._v("有以下几种.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("故障转移")]),t._v("(Failover): 高可用的服务集群中, 多数的服务--尤其是那些经常被其他服务所依赖的关键路径上的服务, 均会部署"),s("strong",[t._v("多个副本")]),t._v(". 这些副本可能部署在不同的节点(避免节点宕机), 网络交换机(避免网络分区)甚至可用区(避免整个地区发生灾害或电力, 骨干网故障)中. "),s("strong",[t._v("故障转移是指如果调用的服务器出现故障, 系统不会立即向调用者返回失败结果, 而是自动切换到其他服务副本, 尝试通过其他副本返回成功调用的结果, 从而保证整体的高可用性")]),t._v(". 故障转移的容错策略应该有一定的"),s("strong",[t._v("调用次数限制")]),t._v(', 譬如允许最多重试三个服务, 如果三个服务都发生报错, 那还是会返回调用失败. 原因不仅是因为重试是有执行成本的, 更是因为过度的重试反而可能让系统处于更加不利的状况. 譬如有以下服务调用链: "A → B → C". 假设 A 的超时阈值为 100ms, 而 B 调用 C 花费 60ms, 如果不幸失败了, 此时做故障转移其实已经没有太大意义了, 因为即使下一次调用能够返回正确结果, 也很可能同样需要耗费 60ms 时间, 时间总和已经触及 A 服务的超时阈值, 所以在这种情况下故障转移反而对系统是不利的.')]),t._v(" "),s("li",[s("strong",[t._v("快速失败")]),t._v("(Failfast): 还有另外一些业务场景是不允许做故障转移的, 因为故障转移策略能够实施的前提是服务具备"),s("strong",[t._v("幂等性")]),t._v(". 对于非幂等的服务, 重复调用就可能产生脏数据, 而脏数据带来的麻烦远大于单纯的某次服务调用失败, 此时就应该以"),s("strong",[t._v("快速失败作为首选的容错策略")]),t._v(". 譬如, 在支付场景中, 需要调用银行的扣款接口, 如果该接口返回的结果是网络异常, 程序很难判断到底是扣款指令发送给银行时出现的网络异常, 还是银行扣款后返回结果给服务时出现的网络异常. 为了避免重复扣款, 此时最恰当可行的方案就是尽快让服务报错, 坚决避免重试, 尽快抛出异常, "),s("strong",[t._v("由调用者自行处理")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("安全失败")]),t._v("(Failsafe): 在一个调用链路中的服务通常也有"),s("strong",[t._v("主路和旁路")]),t._v("之分, 换句话说, 并不是每个服务都是不可或缺的, "),s("strong",[t._v("有部分服务失败了也不影响核心业务的正确性")]),t._v(". 譬如开发基于 Spring 管理的应用程序时, 通过扩展点, 事件或者 AOP 注入的逻辑往往就属于旁路逻辑, 典型的有审计, 日志, 调试信息, 等等. "),s("strong",[t._v("属于旁路逻辑的另一个显著特征是后续处理不会依赖其返回值, 或者它的返回值是什么都不会影响后续处理的结果")]),t._v(", 譬如只是将返回值记录到数据库, 而不使用它参与最终结果的运算. 对这类逻辑, 一种理想的容错策略是即使旁路逻辑实际调用失败了, 也当作正确的来返回, 如果需要返回值的话, 系统就自动返回一个符合要求的数据类型的对应零值, 然后自动记录一条服务调用出错的日志备查即可, 这种策略被称为"),s("strong",[t._v("安全失败策略")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("沉默失败")]),t._v("(Failsilent): 如果大量的请求需要等到超时或者长时间处理后才宣告失败, 很容易由于某个远程服务的请求堆积而消耗大量的线程, 内存, 网络等资源, 进而影响到整个系统的稳定. 面对这种情况, 一种合理的失败策略是当请求失败后, 就"),s("strong",[t._v("默认服务提供者一定时间内无法再对外提供服务, 不再向它分配请求流量, 将错误隔离开来, 避免对系统其他部分产生影响, 此即为沉默失败策略")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("故障恢复")]),t._v("(Failback): 故障恢复一般不单独存在, 而是作为其他容错策略的"),s("strong",[t._v("补充措施")]),t._v(". 一般在微服务管理框架中, 如果设置容错策略为故障恢复的话, 通常默认会采用快速失败加上故障恢复的策略组合. 故障恢复是指当服务调用出错之后, "),s("strong",[t._v("将该次调用失败的信息存入一个消息队列中, 然后由系统自动开始异步重试调用")]),t._v(". 故障恢复策略一方面可以尽力促使失败的调用最终能够被正常执行, 另一方面也可以为服务注册中心和负载均衡器及时提供服务恢复的"),s("strong",[t._v("通知信息")]),t._v(". 故障恢复显然也是要求服务必须具备幂等性的, 由于它的重试是在后台异步进行, 即使最后调用成功了, 原来的请求也早已响应完毕, "),s("strong",[t._v("所以故障恢复策略一般用于对实时性要求不高的主路逻辑")]),t._v(", 同时也适合处理那些不需要返回值的旁路逻辑. 为了避免内存中异步调用任务堆积, 故障恢复与故障转移一样, 应该有最大重试次数的限制.")])]),t._v(" "),s("p",[t._v('上面五种以 "Fail" 开头的策略是针对'),s("strong",[t._v("调用失败时如何进行弥补")]),t._v("的, 以下两种策略则是在"),s("strong",[t._v("调用之前就开始考虑如何获得最大的成功概率")]),t._v(".")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("并行调用")]),t._v('(Forking): 并行调用策略很符合人们日常对一些重要环节进行的 "双重保险" 的处理思路, 它是指一开始就同时向多个服务副本发起调用, 只要有其中任何一个返回成功, 那调用便宣告成功, 这是一种在关键场景中使用更高的执行成本换取执行时间和成功概率的策略.')]),t._v(" "),s("li",[s("strong",[t._v("广播调用")]),t._v("(Broadcast): 广播调用与并行调用是相对应的, 都是同时发起多个调用, 但并行调用是任何一个调用结果返回成功便宣告成功, 广播调用则要求所有的请求"),s("strong",[t._v("全部成功")]),t._v(', 这次调用才算成功, 任何一个服务提供者出现异常都算调用失败. 广播调用通常用于实现 "刷新分布式缓存" 这类的操作.')])]),t._v(" "),s("p",[t._v("容错策略并非计算机科学独有的, 在交通, 能源, 航天等很多领域都有容错性设计, 也会使用到上面这些策略, 并在自己的行业领域中进行解读与延伸. 这里介绍的容错策略并非全部, 只是最常见的几种, 这里将它们各自的优缺点, 应用场景总结如下表.")]),t._v(" "),s("blockquote",[s("p",[t._v("常见容错策略优缺点及应用场景对比表")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("容错策略")]),t._v(" "),s("th",[t._v("优点")]),t._v(" "),s("th",[t._v("缺点")]),t._v(" "),s("th",[t._v("应用场景")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("故障转移")]),t._v(" "),s("td",[t._v("系统自动处理, 调用者对失败的信息不可见")]),t._v(" "),s("td",[t._v("增加调用时间, 额外的资源开销")]),t._v(" "),s("td",[t._v("调用幂等服务; 对调用时间不敏感的场景")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("快速失败")]),t._v(" "),s("td",[t._v("调用者对有失败的处理完全控制权; 不依赖服务的幂等性")]),t._v(" "),s("td",[t._v("调用者必须正确处理失败逻辑, 如果一味只是对外抛异常, 容易引起雪崩")]),t._v(" "),s("td",[t._v("调用非幂等的服务; 超时阈值较低的场景")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("安全失败")]),t._v(" "),s("td",[t._v("不影响主路逻辑")]),t._v(" "),s("td",[t._v("只适用于旁路调用")]),t._v(" "),s("td",[t._v("调用链中的旁路服务")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("沉默失败")]),t._v(" "),s("td",[t._v("控制错误不影响全局")]),t._v(" "),s("td",[t._v("出错的地方将在一段时间内不可用")]),t._v(" "),s("td",[t._v("频繁超时的服务")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("故障恢复")]),t._v(" "),s("td",[t._v("调用失败后自动重试, 也不影响主路逻辑")]),t._v(" "),s("td",[t._v("重试任务可能产生堆积, 重试仍然可能失败")]),t._v(" "),s("td",[t._v("调用链中的旁路服务; 对实时性要求不高的主路逻辑也可")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("并行调用")]),t._v(" "),s("td",[t._v("尽可能在最短时间内活动最高的成功率")]),t._v(" "),s("td",[t._v("消耗额外的机器资源, 大部分调用可能是无用功")]),t._v(" "),s("td",[t._v("资源充足且对失败容忍度低 的场景")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("广播调用")]),t._v(" "),s("td",[t._v("支持同时对批量的服务提供者发起调用")]),t._v(" "),s("td",[t._v("资源消耗大, 失败概率高")]),t._v(" "),s("td",[t._v("只适用于批量操作的场景")])])])]),t._v(" "),s("h5",{attrs:{id:"_2-容错设计模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-容错设计模式"}},[t._v("#")]),t._v(" 2.容错设计模式")]),t._v(" "),s("p",[t._v("为了"),s("strong",[t._v("实现各式各样的容错策略")]),t._v(", 开发人员总结出了一些被实践证明是有效的"),s("strong",[t._v("服务容错设计模式")]),t._v(", 譬如微服务中常见的"),s("strong",[t._v("断路器模式, 舱壁隔离模式, 重试模式")]),t._v("等等, 以及将在后面介绍的"),s("strong",[t._v("流量控制模式")]),t._v(", 如滑动时间窗模式, 漏桶模式, 令牌桶模式, 等等.")]),t._v(" "),s("h6",{attrs:{id:"_1-断路器模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-断路器模式"}},[t._v("#")]),t._v(" (1)断路器模式")]),t._v(" "),s("p",[t._v("断路器模式是微服务架构中最基础的容错设计模式, 以 Hystrix 这种服务治理工具为例, 人们往往忽略了它的服务隔离, 请求合并, 请求缓存等其他服务治理职能, 直接将它称为微服务断路器或者熔断器.")]),t._v(" "),s("p",[t._v("断路器的基本思路很简单, 就是通过"),s("strong",[t._v("代理(断路器对象)来一对一(一个远程服务对应一个断路器对象)地接管服务调用者的远程请求")]),t._v(". "),s("strong",[t._v('断路器会持续监控并统计服务返回的成功, 失败, 超时, 拒绝等各种结果, 当出现故障(失败, 超时, 拒绝)的次数达到断路器的阈值时, 它的状态就自动变为"OPEN"')]),t._v(" , 后续此断路器代理的远程访问都将"),s("strong",[t._v("直接返回调用失败")]),t._v(", 而不会发出真正的远程服务请求. 通过断路器对远程服务的熔断, 避免因持续的失败或拒绝而消耗资源, 以及因持续的超时而堆积请求, 最终达到"),s("strong",[t._v("避免雪崩效应")]),t._v("的目的. 由此可见, 断路器本质是一种"),s("strong",[t._v("快速失败策略")]),t._v("的实现方式, 它的工作过程可以通过下图来表示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221225181436015.png",alt:"",title:"断路器模式时序图"}})]),t._v(" "),s("p",[t._v("从调用序列来看, 断路器就是一种"),s("strong",[t._v("有限状态机")]),t._v(". 断路器模式就是根据自身状态变化自动调整代理请求策略的过程, 一般要设置以下三种状态.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("CLOSED")]),t._v(": 表示断路器关闭, 此时的远程请求会"),s("strong",[t._v("真正发送给服务提供者")]),t._v(". 断路器刚刚建立时默认处于这种状态, 此后将持续监视远程请求的数量和执行结果, 决定是否进入 OPEN 状态.")]),t._v(" "),s("li",[s("strong",[t._v("OPEN")]),t._v(": 表示断路器开启, 此时不会进行远程请求, "),s("strong",[t._v("直接向服务调用者返回调用失败的信息")]),t._v(", 以实现快速失败策略.")]),t._v(" "),s("li",[s("strong",[t._v("HALF OPEN")]),t._v(': 这是一种中间状态. 断路器必须带有自动的故障恢复能力, 当进入 OPEN 状态一段时间以后, 将"自动"(一般是由下一次请求而不是计时器触发的, 所以这里的自动带引号)切换到 HALF OPEN 状态. 在该状态下, 断路器会'),s("strong",[t._v("放行一次")]),t._v("远程调用, 然后根据这次调用的结果, 转换为 CLOSED 或者 OPEN 状态, 以实现断路器的"),s("strong",[t._v("弹性恢复")]),t._v(".")])]),t._v(" "),s("p",[t._v("这些状态的转换逻辑与条件如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221225184107802.png",alt:"image-20221225184107802",title:"断路器的状态转换逻辑"}})]),t._v(" "),s("p",[t._v("OPEN 和 CLOSED 状态的含义是十分清晰的, 与生活中电路的断路器并没有什么差别, 值得讨论的是这两者的转换条件是什么? 最简单直接的方案是只要遇到一次调用失败, 就默认以后所有的调用都会失败, 即断路器直接进入 OPEN 状态, 但这样做的效果很差, 虽然避免了故障扩散和请求堆积, 但系统稳定性很差. 现实中, 比较可行的办法是在"),s("strong",[t._v("同时满足以下两个条件")]),t._v("时, 将断路器状态转变为 OPEN:")]),t._v(" "),s("ul",[s("li",[t._v("一段时间(譬如 10s 以内)"),s("strong",[t._v("内请求数量达到一定阈值")]),t._v("(譬如 20 个请求). 这个条件的意思是如果请求本身就很少, 就用不着断路器介入;")]),t._v(" "),s("li",[t._v("一段时间(譬如 10s 以内)内"),s("strong",[t._v("请求的故障率(发生失败, 超时, 拒绝的统计比例)到达一定阈值")]),t._v("(譬如 50%). 这个条件的意思是如果请求本身都能正确返回, 也用不着断路器介入.")])]),t._v(" "),s("p",[t._v("当同时满足以上两个条件时, 断路器就会转变为 OPEN 状态. 括号中举例的数值是 Netflix Hystrix 的默认值, 其他服务治理的工具, 譬如 Resilience4j, Envoy 等也同样会包含类似的设置.")]),t._v(" "),s("p",[t._v("借着断路器的上下文, 顺带讲一下服务治理中两个常见的易混淆概念: "),s("strong",[t._v("服务熔断和服务降级之间的联系与差别")]),t._v(". (1) 断路器的作用是"),s("strong",[t._v("自动进行服务熔断")]),t._v(', 这是一种快速失败的容错策略的实现方法. 在快速失败策略明确反馈了故障信息给上游服务以后, 上游服务必须能够主动处理调用失败的后果, 而不是坐视故障扩散. 这里的"处理"指的是一种典型的服务降级逻辑, 降级逻辑可以包括, 但不应该仅限于把异常信息抛到用户界面, 而应该尽力通过其他路径解决问题, 譬如把原本要处理的业务记录下来, 留待以后重新处理是最低限度的通用降级逻辑. 举个例子: 你女朋友有事想召唤你, 打你手机没人接, 响了几声气冲冲地挂断后(快速失败), 又打了你另外三个不同朋友的手机号(故障转移), 都还是没能找到你(重试超过阈值). 这时候她生气地在微信上给你留言"三分钟不回电话就分手", 以此来与你取得联系. 在这个不太"吉利"的故事里, 女朋友给你留言这个行为便是服务降级逻辑. (2) '),s("strong",[t._v("服务降级")]),t._v("不一定是在出现错误后才被动执行的, 在许多场景中, 人们所谈论的降级更可能是指需要"),s("strong",[t._v("主动迫使服务进入降级逻辑的情况")]),t._v(". 譬如, 出于应对可预见的峰值流量, 或者系统检修等原因, 要关闭系统部分功能或部分旁路服务, 这时候就有可能主动迫使这些服务降级. 当然, 此时服务降级就不一定是出于服务容错的目的了, 更可能属于下一节要讲的流量控制的范畴.")]),t._v(" "),s("h6",{attrs:{id:"_2-舱壁隔离模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-舱壁隔离模式"}},[t._v("#")]),t._v(" (2)舱壁隔离模式")]),t._v(" "),s("p",[t._v("介绍了服务熔断和服务降级, 再来看看另一个微服务治理中常见的概念: "),s("strong",[t._v("服务隔离")]),t._v(". "),s("strong",[t._v("舱壁隔离模式是常用的实现服务隔离的设计模式")]),t._v('. "舱壁"这个词来自造船业的舶来品, 它原本的意思是设计舰船时, 要在每个区域设计独立的水密舱室, 一旦某个舱室进水, 也只是影响这个舱室中的货物, 而不至于让整艘舰船沉没. 这种思想很符合'),s("strong",[t._v("容错策略中的失败静默策略")]),t._v(".")]),t._v(" "),s("p",[t._v('调用外部服务的故障大致可以分为"'),s("strong",[t._v("失败")]),t._v('"(如 400 Bad Request, 500 Internal Server Error 等错误), "'),s("strong",[t._v("拒绝")]),t._v('"(如 401 Unauthorized, 403 Forbidden 等错误)以及"'),s("strong",[t._v("超时")]),t._v('"(如 408 Request Timeout, 504 Gateway Timeout 等错误)三大类, 其中 '),s("strong",[t._v('"超时"引起的故障更容易给调用者带来全局性的风险')]),t._v(". 这是由于目前主流的网络访问大多是"),s("strong",[t._v("基于 TPR 并发模型")]),t._v("(Thread per Request)来实现的, 只要请求一直不结束(无论是以成功结束还是以失败结束), 就要一直占用着某个线程不能释放. 而线程是典型的整个系统的全局性资源, 尤其是在 Java 这类将线程映射为操作系统内核线程来实现的语言环境中, "),s("strong",[t._v("为了不让某一个远程服务的局部失败演变成全局失败, 就必须设置某种止损方案, 这便是服务隔离的意义")]),t._v(".")]),t._v(" "),s("p",[t._v("看一个更具体的场景, 当分布式系统所依赖的"),s("strong",[t._v("某个服务")]),t._v('"服务I"发生了超时, 假设平均 1s 内对该服务的调用会发生 50 次, 这就意味着该服务如果长时间不结束的话, 每秒会有 '),s("strong",[t._v("50 条用户线程被阻塞")]),t._v(". 如果这样的访问量一直持续, 这里按 Tomcat 默认的 HTTP 超时时间(20s)来计算, 20s 内将会阻塞 1000 条用户线程, 此后才陆续会有用户线程因超时被"),s("strong",[t._v("释放出来")]),t._v(", 回到 Tomcat 的全局线程池中. "),s("strong",[t._v("一般 Java 应用的线程池最大线程连接数会设置到 200～400")]),t._v(', 这意味着此时系统在外部将表现为所有服务的全面瘫痪, 而不是只有涉及"服务I"的功能不可用, 因为 Tomcat 已经没有任何空余的线程来为其他请求提供服务了.')]),t._v(" "),s("p",[t._v("对于这类情况, 一种可行的解决办法是为"),s("strong",[t._v("每个服务单独设立线程池")]),t._v(', 这些线程池默认不预置活动线程, 只用来控制单个服务的最大连接数. 譬如, 对出问题的 "服务I" 设置了一个最大线程数为 5 的线程池, 这时候它的超时故障最多只会阻塞5条用户线程, 而不至于影响全局. 此时, 其他不依赖"服务I"的用户线程依然能够正常对外提供服务.')]),t._v(" "),s("p",[t._v("使用局部的线程池来控制服务的最大连接数有许多好处, 当服务出问题时可以隔离影响, 当服务恢复后可以通过"),s("strong",[t._v("清理局部线程池, 瞬间恢复该服务的调用")]),t._v(", 而如果是 Tomcat 的全局线程池被占满, 再恢复就会十分麻烦. 但是, 局部线程池有一个显著的弱点, 它额外增加了 CPU 的开销, 因为"),s("strong",[t._v("每个独立的线程池都要进行排队, 调度和下文切换工作")]),t._v(". 根据 Netflix 官方给出的数据, 一旦启用 Hystrix 线程池来进行服务隔离, 大概会为每次服务调用增加约 3～10ms 的延时, 如果调用链中有 20 次远程服务调用, 那每次请求就要多付出 60～200ms 的代价来换取服务隔离的安全保障.")]),t._v(" "),s("p",[t._v("为应对这种情况, 还有一种更轻量的控制服务最大连接数的办法: "),s("strong",[t._v("信号量机制")]),t._v("(Semaphore). 如果不考虑清理线程池, 客户端主动中断线程这些额外的功能, 仅仅是为了控制一个服务并发调用的最大次数, 可以只为"),s("strong",[t._v("每个远程服务维护一个线程安全的计数器, 并不需要建立局部线程池")]),t._v(". 具体做法是当服务开始调用时计数器加 1, 服务返回结果后计数器减 1, 一旦计数器超过设置的阈值就立即开始"),s("strong",[t._v("限流")]),t._v(", 在回落到阈值范围之前都不再允许请求. 由于不需要承担线程的排队, 调度, 切换工作, 所以单纯维护一个作为计数器的信号量的性能损耗, 相对于局部线程池来说几乎可以忽略不计.")]),t._v(" "),s("p",[t._v("以上介绍的是从微观, 服务调用的角度应用舱壁隔离设计模式, 舱壁隔离模式还可以在更高层, 更宏观的场景中使用, 不是按调用线程, 而是按功能, 按子系统, 按用户类型等条件来隔离资源. 譬如, 根据用户等级, 用户是否为 VIP, 用户来访的地域等各种因素, 将请求分流到独立的服务实例去, 这样即使某一个实例完全崩溃了, 也只是影响到其中某一部分的用户, 以尽可能控制波及范围. 一般来说会选择在"),s("strong",[t._v("服务调用端或者边车代理上实现服务层面的隔离")]),t._v(", 在 DNS 或者网关处实现系统层面的隔离.")]),t._v(" "),s("h6",{attrs:{id:"_3-重试模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-重试模式"}},[t._v("#")]),t._v(" (3)重试模式")]),t._v(" "),s("p",[t._v("这里以"),s("strong",[t._v("重试模式")]),t._v("来介绍"),s("strong",[t._v("故障转移和故障恢复")]),t._v("这两种容错策略的主流实现方案.")]),t._v(" "),s("p",[t._v("故障转移和故障恢复策略都需要对服务进行"),s("strong",[t._v("重复调用")]),t._v(", 差别是这些重复调用可能是"),s("strong",[t._v("同步")]),t._v("的, 也可能是后台"),s("strong",[t._v("异步")]),t._v("进行; 可能会重复调用同一个服务, 也可能会调用到服务的其他副本. 无论具体是通过怎样的方式调用, 调用的服务实例是否相同, 都可以归结为重试设计模式的应用范畴. "),s("strong",[t._v("重试模式适合解决系统中的瞬时故障")]),t._v(", 简单地说就是有可能自己恢复(Resilient, 称为自愈, 也叫作回弹性)的临时性失灵, 如网络抖动, 服务的临时过载(典型的如返回了 503 Bad Gateway 错误)这些都属于瞬时故障. 重试模式实现并不困难, 即使完全不考虑框架的支持, 靠程序员自己编写十几行代码也能够完成. 在实践中, 重试模式面临的"),s("strong",[t._v("风险反而大多来源于太过简单而导致的滥用")]),t._v(". 当判断是否应该且是否能够对一个服务进行重试时, 应同时满足以下几个前提条件.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("仅在主路逻辑的关键服务上进行同步的重试")]),t._v(", 而非关键的服务, 一般不把重试作为首选容错方案, 尤其不该进行同步的重试.")]),t._v(" "),s("li",[s("strong",[t._v("仅对由瞬时故障导致的失败进行重试")]),t._v(". 尽管很难精确判定一个故障是否属于可自愈的瞬时故障, 但从 HTTP 的"),s("strong",[t._v("状态码")]),t._v("上至少可以获得一些初步的结论. 譬如, 当发出的请求收到了 401 Unauthorized 响应, 说明服务本身是可用的, 只是你没有权限调用, 这时候再去重试就没有任何意义. 功能完善的服务治理工具会提供具体的重试策略配置(如 Envoy 的 Retry Policy), 可以根据包括 HTTP 响应码在内的各种具体条件来设置不同的重试参数.")]),t._v(" "),s("li",[s("strong",[t._v("仅对具备幂等性的服务进行重试")]),t._v(". 如果服务调用者和提供者不属于同一个团队, 那服务是否幂等其实也是一个难以精确判断的问题, 但仍可以找到一些总体上通用的原则. 譬如, RESTful 服务中的 POST 请求是非幂等的, 而 GET, HEAD, OPTIONS, TRACE 由于不会改变资源状态, 所以应该被设计成幂等的; PUT 请求一般也是幂等的, 因为 n 个 PUT 请求会覆盖相同的资源 n–1 次; DELETE 也可看作是幂等的, 同一个资源首次删除会得到 200 OK 响应, 此后应该得到 204 No Content 响应. 这些都是 HTTP 协议中定义的通用的指导原则, 虽然对于具体服务如何实现并无强制约束力, 但在建设系统时, 遵循业界惯例本身就是一种良好的习惯.")]),t._v(" "),s("li",[s("strong",[t._v("重试必须有明确的终止条件")]),t._v(", 常用的终止条件有两种. (1) "),s("strong",[t._v("超时终止")]),t._v(": 并不限于重试, 所有调用远程服务都应该有超时机制以避免无限期的等待. 这里只是强调重试模式更加应该配合超时机制来使用, 否则重试对系统很可能是有害的, 笔者已经在前面介绍故障转移策略时举过具体的例子, 这里就不重复了. (2) "),s("strong",[t._v("次数终止")]),t._v(': 重试必须要有一定限度, 不能无限制地做下去, 通常最多只重试 2～5 次. 重试不仅会给调用者带来负担, 对于服务提供者也同样是负担, 所以应避免将重试次数设得太大. 此外, 如果服务提供者返回的响应头中带有 Retry-After, 即使它没有强制约束力, 也应该充分尊重服务端的要求, 做个"有礼貌"的调用者.')])]),t._v(" "),s("p",[t._v("由于重试模式可以在网络链路的"),s("strong",[t._v("多个环节")]),t._v("中去实现, 譬如"),s("strong",[t._v("客户端发起调用时自动重试, 网关中自动重试, 负载均衡器中自动重试")]),t._v(", 等等, 而且现在的微服务框架都足够便捷, 只许设置一两个开关参数就可以开启对某个服务甚至全部服务的重试机制. 所以, 对于没有太多经验的程序员, 有可能根本意识不到其中会带来多大的负担. 这里举个具体例子: 一套基于 Netflix OSS 建设的微服务系统, 如果同时在 Zuul, Feign 和 Ribbon 上"),s("strong",[t._v("都打开了重试")]),t._v("功能, 且不考虑重试被超时终止的话, "),s("strong",[t._v("那总重试次数就相当于它们的重试次数的乘积")]),t._v(". 假设它们都重试 4 次, 且 Ribbon 可以转移 4 个服务副本来计算, 理论上最多会产生高达 4×4×4×4 = 256 次调用请求.")]),t._v(" "),s("p",[s("strong",[t._v("熔断, 隔离, 重试, 降级, 超时")]),t._v("等概念都是建立具有韧性的微服务系统所必需的保障措施. 目前, 这些措施的正确运作主要还是依靠开发人员对"),s("strong",[t._v("服务逻辑")]),t._v("的了解, 以及运维人员的经验去静态调整配置参数和阈值. 但是面对能够自动扩缩(Auto Scale)的大型分布式系统, 静态的配置越来越难以起到良好的效果, 这就需要系统不仅要有能力自动根据服务负载来调整服务器的数量规模, 还要有能力根据服务调用的统计结果, 或者启发式搜索的结果来自动变更容错策略和参数. 当然, 这方面研究现在还处于各大厂商在内部分头摸索的初级阶段, 是服务治理的未来重要发展方向之一.")]),t._v(" "),s("p",[t._v("本节的容错策略和容错设计模式, 最终目的均是为了"),s("strong",[t._v("避免服务集群中某个节点的故障导致整个系统发生雪崩效应")]),t._v(", 但仅仅做到容错, 只让故障不扩散是远远不够的, 还希望系统或者至少系统的核心功能能够表现出"),s("strong",[t._v("最佳的响应能力")]),t._v(", 不受或少受硬件资源, 网络带宽和系统中一两个缓慢服务的拖累.")]),t._v(" "),s("p",[t._v("下面将面向如何解决集群中的"),s("strong",[t._v("短板效应")]),t._v(", 去讨论服务质量, 流量管控等话题.")]),t._v(" "),s("h4",{attrs:{id:"流量控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#流量控制"}},[t._v("#")]),t._v(" 流量控制")]),t._v(" "),s("p",[t._v("任何一个系统的运算, 存储, 网络资源都不是无限的, 当系统资源不足以支撑外部超过预期的突发流量时, 便应该有所取舍, "),s("strong",[t._v("建立面对超额流量自我保护的机制")]),t._v(', 这个机制就是微服务中常说的"'),s("strong",[t._v("限流")]),t._v('". 在介绍限流的具体细节前, 我们先一起来做一道小学三年级难度的四则运算场景应用题:')]),t._v(" "),s("p",[t._v("已知条件:")]),t._v(" "),s("p",[t._v("(1)系统中一个业务操作需要调用 10 个服务协作来完成;")]),t._v(" "),s("p",[t._v("(2)该业务操作的总超时时间是 10s;")]),t._v(" "),s("p",[t._v("(3)每个服务的处理时间平均是 0.5s;")]),t._v(" "),s("p",[t._v("(4)集群中每个服务均部署了 20 个实例副本.")]),t._v(" "),s("p",[t._v("求解以下问题:")]),t._v(" "),s("p",[t._v("单个用户访问, 完成一次业务操作, 需要耗费系统多少处理器时间?")]),t._v(" "),s("ul",[s("li",[t._v("答: 0.5×10=5")])]),t._v(" "),s("p",[t._v("集群中每个服务每秒最大能处理多少个请求?")]),t._v(" "),s("ul",[s("li",[t._v("答: (1÷0.5)×20=40")])]),t._v(" "),s("p",[t._v("假设不考虑顺序且请求分发是均衡的, 在保证不超时的前提下, 整个集群能持续承受最多每秒多少笔业务操作?")]),t._v(" "),s("ul",[s("li",[t._v("答: 40×10÷5=80")])]),t._v(" "),s("p",[t._v("如果集群在一段时间内持续收到 100 TPS 的业务请求, 会出现什么情况?")]),t._v(" "),s("ul",[s("li",[t._v("答: 这就超纲了小学水平, 得看架构师的本事了.")])]),t._v(" "),s("p",[t._v("对于最后这个问题, 如果仍然按照小学生的解题思路, 最大处理能力为 80 TPS 的系统遇到 100 TPS 的请求时, 应该能完成其中的 80 TPS, 也即有 20 TPS 的请求"),s("strong",[t._v("失败或被拒绝")]),t._v("才对, 这是最理想的情况. 但事实上, 如果不做任何处理, 更可能出现的结果是这 100 个请求中的每一个都开始了处理, 只是大部分请求完成了其中 10 次服务调用中的 8 次或者 9 次, 就会超时退出, 导致"),s("strong",[t._v("多数服务调用被白白浪费掉")]),t._v(", 没有几个请求能够走完整个业务操作. 譬如早期的 12306 系统就明显存在这样的问题, 全国人民都上去抢票的结果是全国人民谁都买不上票. 为了避免这种状况出现, 一个健壮的系统需要"),s("strong",[t._v("做到恰当的流量控制")]),t._v(", 更具体地说, 它需要妥善解决以下三个问题.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("依据什么限流")]),t._v(": 对于要不要控制流量, 要控制哪些流量, 控制力度有多大等操作, 由于无法在系统设计阶段静态地给出确定的结论, 必须根据系统此前一段时间的"),s("strong",[t._v("运行状况")]),t._v(", 甚至未来一段时间的预测情况来动态决定.")]),t._v(" "),s("li",[s("strong",[t._v("具体如何限流")]),t._v(": 要解决系统具体是如何做到允许一部分请求通行, 而另外一部分流量实行受控制的失败降级的问题, 就必须了解并掌握常用的服务限流算法和设计模式.")]),t._v(" "),s("li",[s("strong",[t._v("超额流量如何处理")]),t._v(": 对于超额流量可以有不同的处理策略, 例如可以直接"),s("strong",[t._v("返回失败")]),t._v("(如 429 Too Many Requests), 或者迫使它们进入降级逻辑, 这种策略被称为"),s("strong",[t._v("否决式限流")]),t._v("; 也可以让请求"),s("strong",[t._v("排队等待")]),t._v(", 暂时阻塞一段时间后再继续处理, 这种被称为"),s("strong",[t._v("阻塞式限流")]),t._v(".")])]),t._v(" "),s("h5",{attrs:{id:"_1-流量统计指标"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-流量统计指标"}},[t._v("#")]),t._v(" 1.流量统计指标")]),t._v(" "),s("p",[t._v("要做流量控制, 首先要弄清楚到底"),s("strong",[t._v("哪些指标能反映系统的流量压力大小")]),t._v('. 相较而言, 容错的统计指标是明确的, 容错的触发条件基本上只取决于请求的故障率, 发生失败, 拒绝与超时都算作故障. 但限流的统计指标就不那么明确了, 那么限流中的"流"到底指什么呢? 要解答这个问题, 需要先来理清经常用于衡量服务流量压力, 但又容易混淆的三个指标的定义.')]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("每秒事务数")]),t._v("(Transaction per Second, TPS): TPS 是衡量信息系统"),s("strong",[t._v("吞吐量的最终标准")]),t._v('. "事务"可以理解为一个'),s("strong",[t._v("逻辑上具备原子性的业务操作")]),t._v('. 譬如你在书店买了一本书, 将要进行支付, "支付"就是一笔业务操作, 无论支付成功还是不成功, 这个操作在逻辑上是'),s("strong",[t._v("原子")]),t._v("的, 即逻辑上不可能让你买本书时成功支付了前面 200 页, 又失败了后面 300 页.")]),t._v(" "),s("li",[s("strong",[t._v("每秒请求数")]),t._v("(Hit per Second, HPS): HPS 是指"),s("strong",[t._v("每秒从客户端发向服务端的请求数")]),t._v('(请将 Hit 理解为 Request 而不是 Click, 国内某些翻译把它理解为"每秒点击数", 多少有点望文生义的嫌疑). '),s("strong",[t._v("如果只要一个请求就能完成一笔业务, 那 HPS 与 TPS 是等价的")]),t._v(", 但在一些场景(尤其常见于网页中)里, 一笔业务可能需要多次请求才能完成. 譬如你在书店买了一本书要进行支付, 尽管逻辑上它是原子操作, 但在技术实现上, 除非你能在银行开的商城中购物并直接扣款, 否则这个操作就很难在一次请求里完成, 总要经过显示支付二维码, 扫码付款, 校验支付是否成功等过程, 中间不可避免地会发生"),s("strong",[t._v("多次请求")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("每秒查询数")]),t._v("(Query per Second, QPS): QPS 是指"),s("strong",[t._v("一台服务器能够响应的查询次数")]),t._v(". 如果"),s("strong",[t._v("只有一台服务器来应答请求, 那 QPS 和 HPS 是等价")]),t._v("的, 但在分布式系统中, 一个请求的响应往往要由后台"),s("strong",[t._v("多个服务节点")]),t._v("共同协作来完成. 譬如你在书店买了一本书要进行支付, 尽管扫描支付二维码时客户端只发送了一个请求, 但这背后的服务端很可能需要向仓储服务发送请求以确认库存信息避免超卖, 向支付服务发送指令划转货款请求, 向用户服务发送修改用户的购物积分请求等, "),s("strong",[t._v("这里面每次内部访问都要消耗掉一次或多次查询数")]),t._v(".")])]),t._v(" "),s("p",[t._v("以上这三个指标都是基于"),s("strong",[t._v("调用计数")]),t._v("的指标, 在整体目标上当然最希望能够基于 TPS 来限流, 因为信息系统最终是为人类用户来提供服务的, 用户不关心业务到底是由多少个请求, 多少个后台查询共同协作来实现. 但是, 系统的业务五花八门, 不同的业务操作给系统带来的压力往往差异巨大, 不具备可比性. 更关键的是, "),s("strong",[t._v("流量控制是针对用户实际操作场景来限流的")]),t._v(', 这不同于压力测试场景中无间隙(最多有些集合点)的全自动化操作, 真实业务操作的耗时无可避免地受限于用户交互带来的不确定性, 譬如前面例子中"扫描支付二维码"这个步骤, 如果用户掏出手机扫描二维码前先顺便回了两条短信息, 那整个付款操作就要持续更长时间. 此时, 如果按照业务开始时计数器加 1, 业务结束时计数器减 1, 通过限制最大 TPS 来限流的话, 就不能准确地反映出系统所承受的压力, 所以直接针对 TPS 来限流实际上是'),s("strong",[t._v("很难操作")]),t._v("的.")]),t._v(" "),s("p",[t._v("目前, "),s("strong",[t._v("主流系统大多倾向使用 HPS 作为首选的限流指标")]),t._v(", 它是相对容易观察统计的, 而且能够在一定程度上反应系统当前以及接下来一段时间的压力. "),s("strong",[t._v("但限流指标并不存在任何必须遵循的权威法则, 根据系统的实际需要, 哪怕完全不选择基于调用计数的指标都是有可能的")]),t._v(". 譬如下载, 视频, 直播等 I/O 密集型系统, 往往会把每次请求和响应报文的大小, 而不是调用次数作为限流指标, 譬如只允许单位时间通过 100MB 的流量. 又譬如网络游戏等基于长连接的应用, 可能会把登录用户数作为限流指标, 当连接用户数超过一定阈值时就会让你在登录前排队等候.")]),t._v(" "),s("h5",{attrs:{id:"_2-限流设计模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-限流设计模式"}},[t._v("#")]),t._v(" 2.限流设计模式")]),t._v(" "),s("p",[t._v("与容错模式类似, 对于具体如何限流, 也有一些常用的设计模式可以参考使用, 这里介绍"),s("strong",[t._v("流量计数器, 滑动时间窗, 漏桶和令牌桶四种限流设计模式")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_1-流量计数器模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-流量计数器模式"}},[t._v("#")]),t._v(" (1)流量计数器模式")]),t._v(" "),s("p",[t._v("做限流最容易想到的一种方法就是设置一个"),s("strong",[t._v("计算器, 根据当前时刻的流量计数结果是否超过阈值来决定是否限流")]),t._v(". 譬如在前面的场景应用题中, 计算得出该系统能承受的最大持续流量是 80 TPS, 那就可以通过控制"),s("strong",[t._v("任何一秒内的业务请求次数来限流, 超过 80 次就直接拒绝掉超额部分")]),t._v(". 这种做法很直观, 也确实有些简单的限流是这样实现的, 但它并不严谨, 以下两个结论就可以证明这个观点.")]),t._v(" "),s("p",[t._v("(1)即使每一秒的统计流量都没有超过 80 TPS, 也不能说明系统没有遇到过大于 80 TPS 的流量压力.")]),t._v(" "),s("p",[t._v("可以想象如下场景, 如果系统"),s("strong",[t._v("连续两秒都收到 60 TPS 的访问请求")]),t._v(", 但这两个 60 TPS 请求分别是在前 1 秒里面的后 0.5s, 以及后 1s 中的前面 0.5s 所发生的. 这样虽然每个周期的流量都不超过 80 TPS 请求的阈值, 但是系统确实曾经在 1s 内发生了超过阈值的 120 TPS 请求.")]),t._v(" "),s("p",[t._v("(2)即使连续若干秒的统计流量都超过了 80 TPS, 也不能说明流量压力就一定超过了系统的承受能力.")]),t._v(" "),s("p",[t._v("可以想象如下场景, 如果在 10s 的时间片段中, 前 3s TPS 平均值到了 100, 而后 7s 的平均值是 30 左右, 此时系统是否能够处理完这些请求而不产生超时失败呢? 答案是可以的, 因为条件中给出的超时时间是 10s, 而最慢的请求也能在 8s 左右处理完毕. 如果只基于固定时间周期来控制请求阈值为 80 TPS, 反而会误杀一部分请求, 导致部分请求出现原本不必要的失败.")]),t._v(" "),s("p",[t._v("流量计数器的"),s("strong",[t._v("缺陷根源在于它只是针对时间点进行离散的统计")]),t._v(', 为了弥补该缺陷, 一种名为"滑动时间窗"的限流模式被设计出来, 它可以实现'),s("strong",[t._v("平滑的基于时间片段统计")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_2-滑动时间窗模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-滑动时间窗模式"}},[t._v("#")]),t._v(" (2)滑动时间窗模式")]),t._v(" "),s("p",[s("strong",[t._v("滑动窗口算法")]),t._v("(Sliding Window Algorithm)在计算机科学的很多领域中都有成功的应用, 譬如编译原理中的窥孔优化(Peephole Optimization), TCP 协议的阻塞控制(Congestion Control)等都使用到滑动窗口算法. 对分布式系统来说, 无论是服务容错中对服务响应结果的统计, 还是流量控制中对服务请求数量的统计, 都经常要用到滑动窗口算法. 关于这个算法的运作过程, 建议你发挥想象力, 在脑海中构造如下场景: 在不断向前流淌的时间轴上, 漂浮着一个固定大小的窗口, 窗口与时间一起平滑地向前滚动. "),s("strong",[t._v("任何时刻静态地通过窗口内观察到的信息, 都等价于一段长度与窗口大小相等, 动态流动中时间片段的信息")]),t._v('. 由于窗口观察的目标都是时间轴, 所以它被形象地称为"滑动时间窗模式".')]),t._v(" "),s("p",[t._v("举个更具体的例子, 假如准备观察的时间片段为 10s, 并以 1s 为统计精度的话, 那可以设定一个长度为 10 的数组(设计通常是以双头队列去实现, 这里简化一下)和一个每秒触发 1 次的定时器. 假如准备通过统计结果进行限流和容错, 并定下限流阈值是最近 10s 内收到的外部请求不超过 500 个, 服务熔断的阈值是最近 10s 内故障率不超过 50%, 那每个数组元素(下图称为 Buckets)中就应该存储请求的总数(实际是通过明细相加得到)及其中成功, 失败, 超时, 拒绝的明细数, 具体如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221225214350183-1975832.png",alt:"",title:"滑动窗口模式示意"}})]),t._v(" "),s("p",[t._v("当频率固定每秒一次的定时器被唤醒时, 它应该完成以下几项工作, 这也是滑动时间窗的工作过程.")]),t._v(" "),s("p",[t._v("(1)将数组"),s("strong",[t._v("最后一位的元素丢弃")]),t._v(', 并把所有元素都后移一位, 然后在数组第一位插入一个新的空元素. 这个步骤即为"滑动窗口".')]),t._v(" "),s("p",[t._v("(2)将计数器中所有"),s("strong",[t._v("统计信息写入第一位的空元素")]),t._v("中.")]),t._v(" "),s("p",[t._v("(3)对数组中所有元素进行统计, 并复位清空计数器的数据以供下一个统计周期使用.")]),t._v(" "),s("p",[t._v("滑动时间窗口模式的限流完全弥补了流量计数器的缺陷, 可以保证在"),s("strong",[t._v("任意时间片段内")]),t._v(", 只需经过简单的调用计数比较, 就能控制请求次数一定不会超过限流的阈值, 这在"),s("strong",[t._v("单机限流或者分布式服务单点网关中的限流中很常用")]),t._v(". 不过, 这种限流模式也有缺点, 它通常"),s("strong",[t._v("只适用于否决式限流")]),t._v(", 超过阈值的流量就必须强制失败或降级, 很难进行阻塞等待处理, 也就很难在细粒度上对流量曲线进行整形, "),s("strong",[t._v("起不到削峰填谷")]),t._v("的作用. 下面继续介绍两种适用于"),s("strong",[t._v("阻塞式限流")]),t._v("的限流模式.")]),t._v(" "),s("h6",{attrs:{id:"_3-漏桶模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-漏桶模式"}},[t._v("#")]),t._v(" (3)漏桶模式")]),t._v(" "),s("p",[t._v("在计算机网络中, 术语流量整形(Traffic Shaping)用于描述如何"),s("strong",[t._v("限制网络设备的流量突变, 使得网络报文以比较均匀的速度向外发送")]),t._v(". "),s("strong",[t._v("流量整形通常都需要用到缓冲区来实现, 当报文的发送速度过快时, 首先在缓冲区中暂存, 然后在控制算法的调节下均匀地发送这些被缓冲的报文")]),t._v(". 常用的控制算法有"),s("strong",[t._v("漏桶算法")]),t._v("(Leaky Bucket Algorithm)和"),s("strong",[t._v("令牌桶算法")]),t._v("(Token Bucket Algorithm)两种, 这两种算法的思路截然相反, 但达到的效果又是相似的.")]),t._v(" "),s("p",[t._v('所谓漏桶, 做个类比就是"一个水池, 每秒以 X 升的速度注水, 同时又以 Y 升的速度出水, 问水池什么时候装满", 问题中的奇怪水池. 如果把请求当作水, "水"来了都先放进池子里, 水池同时又以额定的速度出"水", 让请求进入系统中. 这样如果一段时间内注水速度过快的话, 水池还能充当缓冲区, 让出水口的速度不至于过快. 不过, 由于请求总是有'),s("strong",[t._v("超时时间")]),t._v("的, 所以缓冲区大小也必须是有限度的, 当注水速度持续超过出水速度一段时间以后, 水池终究会被灌满, 此时, 从网络的流量整形的角度看体现为"),s("strong",[t._v("部分数据包被丢弃")]),t._v(", 而从信息系统的角度看则体现为有"),s("strong",[t._v("部分请求会遭遇失败和降级")]),t._v(".")]),t._v(" "),s("p",[t._v("漏桶在代码实现上非常简单, 它其实就是一个以"),s("strong",[t._v("请求对象作为元素的先入先出队列")]),t._v("(FIFO Queue), 队列长度就相当于漏桶的大小, "),s("strong",[t._v("当队列已满时便拒绝新的请求进入")]),t._v(". 漏桶实现起来很容易, 难点在于如何确定漏桶的两个参数: "),s("strong",[t._v("桶的大小和水的流出速率")]),t._v(". 如果桶设置得太大, 那服务依然可能遭遇流量过大的冲击, 不能完全发挥限流的作用; 如果设置得太小, 那很可能误杀掉一部分正常的请求, 这种情况与流量计数器模式中举过的例子是一样的. "),s("strong",[t._v("流出速率在漏桶算法中一般是个固定值")]),t._v(", 对类似本节开头场景应用题中那样固定拓扑结构的服务是很合适的, 但同时也应该明白那是经过最大限度简化的场景, "),s("strong",[t._v("现实中系统的处理速度往往受到其内部拓扑结构变化和动态伸缩的影响, 所以能够支持变动请求处理速率的令牌桶算法可能会更受程序员的青睐")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_4-令牌桶模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-令牌桶模式"}},[t._v("#")]),t._v(" (4)令牌桶模式")]),t._v(" "),s("p",[t._v("如果说漏桶是小学应用题中的奇怪水池, 那令牌桶就是去银行办事时摆在门口的那台"),s("strong",[t._v("排队机")]),t._v(". 它与漏桶一样都是基于缓冲区的限流算法, 只是方向刚好相反, "),s("strong",[t._v("漏桶是从水池里向系统发送请求, 令牌桶则是系统往排队机中放入令牌")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("假设要限制系统在 X 秒内最大请求次数不超过 Y, 那就每间隔 X/Y 时间往桶中放一个令牌, 当有请求进来时, 首先要从桶中取得一个准入的令牌, 然后才能进入系统进行处理")]),t._v(". 任何时候, 一旦请求进入桶中却发现没有令牌可取了, 就应该马上宣告失败或进入服务降级逻辑. 与漏桶类似, 令牌桶同样有"),s("strong",[t._v("最大容量")]),t._v(", 这意味着当系统比较空闲时, 桶中令牌累积到一定程度就不再无限增加, 此时预存在桶中的令牌便是请求最大缓冲的余量. 上面这段话, 可以转化为以下步骤来指导程序编码.")]),t._v(" "),s("p",[t._v("(1) 让系统以一个由限流"),s("strong",[t._v("目标决定的速率")]),t._v("向桶中注入令牌, 譬如要控制系统的访问不超过 100 次, 速率即设定为 1/100 = 10(ms).")]),t._v(" "),s("p",[t._v("(2) 桶中最多可以存放 N 个令牌, N 的具体数量由"),s("strong",[t._v("超时时间和服务处理能力")]),t._v("共同决定. 如果桶已满, 第 N+1 个进入的令牌会被"),s("strong",[t._v("丢弃")]),t._v("掉.")]),t._v(" "),s("p",[t._v("(3) 请求到时先从桶中取走 1 个令牌, 如果桶已空就进入"),s("strong",[t._v("降级逻")]),t._v("辑.")]),t._v(" "),s("p",[t._v("令牌桶模式的实现看似比较复杂, 每间隔固定时间就要放新的令牌到桶中, 但其实并不需要真的用一个专用线程或者定时器来做这件事情, 只要在令牌中"),s("strong",[t._v("增加一个时间戳记录")]),t._v(", 每次获取令牌前, "),s("strong",[t._v("比较一下时间戳与当前时间, 就可以轻易计算出这段时间需要放多少令牌进去, 然后一次放完全部令牌即可")]),t._v(", 所以真正编码并不会显得复杂.")]),t._v(" "),s("h5",{attrs:{id:"_3-分布式限流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-分布式限流"}},[t._v("#")]),t._v(" 3.分布式限流")]),t._v(" "),s("p",[t._v("本节再向实际的信息系统前进一步, 讨论"),s("strong",[t._v("分布式系统中的限流问题")]),t._v(". 此前讨论的限流算法和模式全部是针对整个系统的限流, 总是有意无意地假设或默认系统只提供一种业务操作, 或者所有业务操作的消耗都是等价的, 并不涉及不同业务请求进入系统的服务"),s("strong",[t._v("集群")]),t._v("后, 分别会调用哪些服务, 每个服务节点处理能力有何差别等问题. 那些限流算法, 直接使用在单体架构的集群上是完全可行的, 但到了微服务架构下, 它们就最多只能应用于集群最"),s("strong",[t._v("入口处的网关")]),t._v("上, 对整个服务集群进行流量控制, "),s("strong",[t._v("而无法细粒度地管理流量在内部微服务节点中的流转情况")]),t._v(". 所以前面介绍的限流模式都统称为"),s("strong",[t._v("单机限流")]),t._v(", "),s("strong",[t._v("把能够精细控制分布式集群中每个服务消耗量的限流算法称为分布式限流")]),t._v(".")]),t._v(" "),s("p",[t._v("这两种限流算法实现上的"),s("strong",[t._v("核心差别在于如何管理限流的统计指标")]),t._v(", 单机限流很好办, 因为指标都存储在服务的内存中, 而分布式限流的目的就是要让各个服务节点协同限流, 无论是将限流功能封装为专门的远程服务, 抑或是在系统采用的分布式框架中提供专门的限流支持, "),s("strong",[t._v("都需要将原本在每个服务节点自己内存中的统计数据开放出来")]),t._v(", 让全局的限流服务可以访问到才行.")]),t._v(" "),s("p",[t._v("一种常见的简单分布式限流方法是将所有服务的"),s("strong",[t._v("统计结果都存入集中式缓存(如 Redis)"),s("strong",[t._v("​"),s("strong",[s("strong",[t._v("中, 以实现在集群内的共享, 并通过")])]),t._v("​")]),t._v("分布式锁, 信号量")]),t._v("等机制, 解决这些数据读写访问时并发控制的问题. 在可以共享统计数据的前提下, 原本用于单机的限流模式理论上也是可以应用于分布式环境中的, 可是其代价也显而易见: "),s("strong",[t._v("每次服务调用都必须额外增加一次网络开销")]),t._v(", 所以这种方法的效率肯定是不高的, 流量压力大时, 限流本身还会显著降低系统的处理能力.")]),t._v(" "),s("p",[t._v("只要集中存储统计信息, 就不可避免地会产生网络开销, 所以为了缓解这里产生的性能损耗, 一种可以考虑的办法是在"),s("strong",[t._v("令牌桶限流模式")]),t._v('基础上进行"'),s("strong",[t._v("货币化改造")]),t._v('", 即不把令牌看作只有准入和不准入的"通行证", 而看作'),s("strong",[t._v('数值形式的"货币额度"')]),t._v(' . 当请求进入集群时, 首先在 API 网关处领取一定数额的"货币", 为了体现不同等级用户重要性的差别, 他们的'),s("strong",[t._v("额度可以有所差异")]),t._v(", 譬如让 VIP 用户的额度更高甚至是无限的. 将用户 A 的额度表示为 Quanity(A). 由于任何一个服务在响应请求时都需要消耗集群一定量的处理资源, 所以访问每个服务时都要求"),s("strong",[t._v('消耗一定量的"货币"')]),t._v(" , 假设服务 X 要消耗的额度表示为 Cost(X), 那当用户 A 访问了 N 个服务以后, 他剩余的额度 Limit(N) 表示为:")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Limit(N) = Quanity(A) - Cost(1X) - Cost(2X) - ... - Cost(NX)\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("此时可以把剩余额度 Limit(N) 作为内部限流的指标, 规定在任何时候, 一旦剩余额度 Limit(N) 小于或等于 0, 就不再允许访问其他服务了. 此时必须先"),s("strong",[t._v("发生一次网络请求, 重新向令牌桶申请一次额度")]),t._v(", 成功后才能继续访问, 不成功则进入降级逻辑. 除此之外的任何时刻, 即 "),s("strong",[t._v("LimitN")]),t._v(" 不为零时, 都无须额外的网络访问, 因为计算 Limit(N) 是完全可以在本地完成的. 这里其实就是由单机令牌桶的一次发放一个令牌升级为一次对一个机器发放 N 张令牌, 减少因为每次获取令牌而产生的网络操作.")]),t._v(" "),s("p",[t._v("基于额度的限流方案对限流的"),s("strong",[t._v("精确度有一定的影响")]),t._v(", 可能存在业务操作已经进行了一部分服务调用, 却无法从令牌桶中再获取到新额度, 最终因 "),s("strong",[t._v('"资金链断裂"而导致业务操作失败')]),t._v(". 这种失败的代价是比较高昂的, 它白白浪费了部分已经完成了的服务资源, 但总体来说, 它仍是一种并发性能和限流效果上都"),s("strong",[t._v("相对折衷可行")]),t._v('的分布式限流方案. 上一节提到过, 对于分布式系统来说, 容错是必须要有, 无法妥协的措施. 但限流与容错不一样, 做分布式限流从不追求"越彻底越好", 往往需要权衡方案付出的代价与得到的收益.')]),t._v(" "),s("h3",{attrs:{id:"可靠通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可靠通信"}},[t._v("#")]),t._v(" 可靠通信")]),t._v(" "),s("p",[t._v("微服务提倡"),s("strong",[t._v("分散治理")]),t._v("(Decentralized Governance), 不追求统一的技术平台, 提倡让团队有自由选择的权利, 不受制于语言和技术框架. 在开发阶段构建服务时, 分散治理打破了由技术栈带来的约束, 好处是不言自明的. 但在运维阶段部署服务时, 尤其是在考量安全问题时, 由 Java, Go, Python, Node.js 等多种语言和框架共同组成的微服务系统, "),s("strong",[t._v("出现安全漏洞的概率肯定要比只采用其中某种语言, 某种框架所构建的单体系统更高")]),t._v(". 为了避免由于单个服务节点出现漏洞被攻击者突破, 进而导致整个系统和内网都遭到入侵, 就必须打破一些传统的安全观念, 以构筑更加可靠的"),s("strong",[t._v("服务间通信机制")]),t._v(".")]),t._v(" "),s("h4",{attrs:{id:"零信任网络"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#零信任网络"}},[t._v("#")]),t._v(" 零信任网络")]),t._v(" "),s("p",[t._v("长期以来, 主流的网络安全观念提倡根据某类与"),s("strong",[t._v("宿主机相关的特征")]),t._v(", 譬如机器所处的位置, 机器的 IP 地址, 子网等, 把网络划分为不同的区域, 不同的区域对应不同的风险级别和允许访问的网络资源权限, 将安全防护措施集中部署在"),s("strong",[t._v("各个区域的边界之上")]),t._v(", 重点"),s("strong",[t._v("关注跨区域的网络流量")]),t._v(". VPN, DMZ, 防火墙, 内网, 外网等概念, 都可以说是因此而生, 这种安全模型今天被称为"),s("strong",[t._v("基于边界的安全模型")]),t._v('(Perimeter-Based Security Model, 后文简称"'),s("strong",[t._v("边界安全")]),t._v('").')]),t._v(" "),s("p",[t._v("边界安全是完全合情合理的做法, 但是安全不可能是绝对的, 必须在"),s("strong",[t._v("可用性和安全性之间权衡取舍")]),t._v(', 否则一台关掉电源拔掉网线, 完全不能对外提供服务的"服务器"无疑就是最为安全的. 边界安全着重对经过网络区域边界的流量进行检查, 对可信任区域(内网)内部机器之间的流量则给予直接信任或者较为宽松的处理策略, 减小了安全设施对整个应用系统复杂度的影响以及网络传输性能的额外损耗, 这当然是很合理的.')]),t._v(" "),s("p",[t._v("不过, 今天单纯的边界安全已不足以满足大规模微服务系统技术异构和节点膨胀的发展需要. "),s("strong",[t._v("边界安全的核心问题")]),t._v("在于边界上的防御措施即使自身能做到永远滴水不漏, 牢不可破, 也很难保证"),s("strong",[t._v('内网中它所尽力保护的某一台服务器不会成为"猪队友"')]),t._v(' , 一旦"可信的"网络区域中的某台服务器被攻陷, 那边界安全措施就成了马其诺防线, 攻击者很快就能以一台机器为跳板, 侵入整个内网, 这是边界安全基因决定的固有缺陷, 从边界安全被提出的第一天起, 这就是已经预料到的问题. 微服务时代需要转变开发观念, '),s("strong",[t._v("承认服务总是会出错的")]),t._v(", 同时也必须转变安全观念, "),s("strong",[t._v("承认一定会有被攻陷的服务")]),t._v(", 为此需要寻找到与之匹配的"),s("strong",[t._v("新的网络安全模型")]),t._v(".")]),t._v(" "),s("p",[t._v("2010 年, Forrester Research 的首席分析师 John Kindervag 提出了"),s("strong",[t._v("零信任安全模型")]),t._v('(Zero-Trust Security Model, 后文简称"'),s("strong",[t._v("零信任安全")]),t._v('")的概念, 最初提出时叫作"零信任架构"(Zero-Trust Architecture), 这个概念当时并没有引发太大的关注, 但随着微服务架构的日渐兴盛, 越来越多的开发和运维人员注意到零信任安全模型与微服务所追求的安全目标是高度吻合的.')]),t._v(" "),s("h5",{attrs:{id:"_1-零信任安全模型的特征"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-零信任安全模型的特征"}},[t._v("#")]),t._v(" 1.零信任安全模型的特征")]),t._v(" "),s("p",[s("strong",[t._v("零信任安全的中心思想是不应当以某种固有特征来自动信任任何流量, 除非明确得到了能代表请求来源(不一定是人, 更可能是另一台服务器)的身份凭证, 否则一律不会有默认的信任关系")]),t._v('. 在 2019 年, Google 发表了一篇在安全与研发领域里都备受关注的论文 "BeyondProd:A New Approach to Cloud-Native Security", 此文详细列举了传统的基于边界的网络安全模型与云原生时代下基于零信任网络的安全模型之间的差异, 并描述了要完成边界安全模型到零信任安全模型的迁移所要实现的具体需求点, 这里将其翻译转述为如下表所示内容.')]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("传统网络安全模型与云原生时代零信任安全模型对比")])])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("传统, 边界安全模型")]),t._v(" "),s("th",[t._v("云原生, 零信任安全模型")]),t._v(" "),s("th",[t._v("具体需求")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("基于防火墙等设施, 认为边界内可信")]),t._v(" "),s("td",[t._v("服务到服务通信需认证, 环境内的服务之间默认没有信任")]),t._v(" "),s("td",[t._v("保护网络边界(仍然有效); 服务之间默认没有互信")])]),t._v(" "),s("tr",[s("td",[t._v("用于特定的 IP 和硬件(机器)")]),t._v(" "),s("td",[t._v("资源利用率更高, 重用, 共享效果更好, 包括 IP 和硬件")]),t._v(" "),s("td",[t._v("受信任的机器运行来源已知的代码")])]),t._v(" "),s("tr",[s("td",[t._v("基于 IP 的身份")]),t._v(" "),s("td",[t._v("基于服务的身份")]),t._v(" "),s("td",[t._v("同上")])]),t._v(" "),s("tr",[s("td",[t._v("服务运行在已知的, 可预期的服务器上")]),t._v(" "),s("td",[t._v("服务运行在环境中的任何地方, 包括私有云/公有云混合部署")]),t._v(" "),s("td",[t._v("同上")])]),t._v(" "),s("tr",[s("td",[t._v("安全相关的需求由应用来实现, 每个应用单独实现")]),t._v(" "),s("td",[t._v("由基础设施来实现, 基础设施中集成了共享的安全性要求")]),t._v(" "),s("td",[t._v("集中策略实施点, 一致地应用到所有服务")])]),t._v(" "),s("tr",[s("td",[t._v("对服务如何构建, 评审, 实施的安全需求的约束力较弱")]),t._v(" "),s("td",[t._v("安全相关的需求一致地应用到所有服务")]),t._v(" "),s("td",[t._v("同上")])]),t._v(" "),s("tr",[s("td",[t._v("安全组件的可观测性较弱")]),t._v(" "),s("td",[t._v("有安全策略及其是否生效的全局视图")]),t._v(" "),s("td",[t._v("同上")])]),t._v(" "),s("tr",[s("td",[t._v("发布不标准, 发布频率较低")]),t._v(" "),s("td",[t._v("标准化的构建和发布流程, 每个微服务变更独立, 变更更频繁")]),t._v(" "),s("td",[t._v("简单, 自动, 标准化的变更发布流程")])]),t._v(" "),s("tr",[s("td",[t._v("工作负载通常为虚拟机部署或部署到物理主机, 并使用物理机或管理程序进行隔离")]),t._v(" "),s("td",[t._v("封装的工作负载及其进程在共享的操作系统中运行, 并由管理平台提供的某种机制来进行隔离")]),t._v(" "),s("td",[t._v("在共享的操作系统的工作负载之间进行隔离")])])])]),t._v(" "),s("p",[t._v("上表系统地阐述了零信任安全在微服务, 云原生环境中的具体落地过程, 整篇论文(除了介绍 Google 自己的实现框架外)就是以此为主线来展开论述的, 但由于表格过于简单, 论文原文写的较为分散晦涩, 笔者按照自己的理解将其中的主要观点转述如下.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("零信任网络不等同于放弃在边界上的保护设施")]),t._v(": 虽然防火墙等位于网络边界的设施是属于边界安全而不是零信任安全的概念, 但它仍然是一种提升安全性的有效且必要的做法. 在微服务集群的前端部署防火墙, 把内部服务节点间的流量与来自互联网的流量隔离开来, 这种做法无论何时都是值得提倡的, 至少能够让内部服务避开来自互联网未经授权流量的饱和攻击, 如最典型的 DDoS(拒绝服务攻击).")]),t._v(" "),s("li",[s("strong",[t._v("身份只来源于服务")]),t._v(": 传统应用一般是部署在特定的服务器上, 这些机器的 IP, MAC 地址很少会发生变化, 此时系统的拓扑状态是相对静态的. 基于这个前提, 安全策略才会使用 IP 地址, 主机名等作为身份标识符(Identifier), 无条件信任具有特性身份表示的服务. 在如今的微服务系统, 尤其是在云原生环境中的微服务系统中, 虚拟化基础设施已得到大范围应用, 这使得服务所部署的 IP 地址, 服务实例的数量随时都可能发生变化, 因此"),s("strong",[t._v("身份只能来源于服务本身所能够出示的身份凭证(通常是数字证书)")]),t._v(" , 而不再是服务所在的 IP 地址, 主机名或者其他特征.")]),t._v(" "),s("li",[s("strong",[t._v("服务之间没有固有的信任关系")]),t._v(": 这点决定了只有"),s("strong",[t._v("已知的, 明确授权的调用者才能访问服务")]),t._v(', 阻止攻击者通过某个服务节点中的代码漏洞来越权调用其他服务. 如果某个服务节点被成功入侵, 这一原则可阻止攻击者扩大其入侵范围, 与微服务设计模式中使用断路器, 舱壁隔离实现容错来避免雪崩效应类似, 在安全方面也应当采用这种"互不信任"的模式来减小入侵危害的影响范围.')]),t._v(" "),s("li",[s("strong",[t._v("集中, 共享的安全策略实施点")]),t._v(': 这点与微服务的"分散治理"刚好相反, 微服务提倡每个服务自己独立地负责自身所有的功能性与非功能性需求. 而 Google 这个观点相当于为分散治理原则做了一个补充--分散治理, 但涉及安全的非功能性需求(如身份管理, 安全传输层, 数据安全层)最好除外. 一方面, 要写出高度安全的代码极为不易, 为此付出的精力甚至可能远高于业务逻辑本身. 另一方面, 也是更重要的一个方面是, 让服务各自处理安全问题很容易出现实现不一致或者出现漏洞时要反复修改多处地方的情况. 还有一些安全问题如果不立足于全局是很难彻底解决的. 因此 Google 明确提出应该有集中式的"安全策略实施点"(原文中称之为 Choke Point), '),s("strong",[t._v("安全需求应该从微服务的应用代码下沉至云原生的基础设施里")]),t._v(', 这也契合其论文的标题 "Cloud-Native Security".')]),t._v(" "),s("li",[s("strong",[t._v("受信的机器运行来源已知的代码")]),t._v(": 这点限制了服务"),s("strong",[t._v("只能使用认证过的代码和配置")]),t._v(", 并且只能运行在认证过的环境中. 分布式软件系统除了促使软件架构发生重大变化之外, 也使软件的发布流程发生较大的改变, 使其严重依赖"),s("strong",[t._v("持续集成与持续部署")]),t._v("(Continuous Integration/Continuous Delivery, "),s("strong",[t._v("CI/CD")]),t._v('). 从开发人员编写代码, 到自动化测试, 自动集成, 再到漏洞扫描, 最后发布上线, 这整套 CI/CD 流程被称作"'),s("strong",[t._v("软件供应链")]),t._v('"(Software Supply Chain). 安全不仅仅局限于软件运行阶段, 曾经有过 XCodeGhost 风波这种针对软件供应链的有影响力的攻击事件, 即在编译阶段将恶意代码嵌入软件当中, 只要安装了此软件的用户就可能触发恶意代码. 为此, '),s("strong",[t._v("零信任安全针对软件供应链的每一步都加入了安全控制策略")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("自动化, 标准化的变更管理")]),t._v(": 这点也是为何提倡通过基础设施而不是应用代码去实现安全功能的另一个重要理由. 如果将安全放在应用上, 由于应用本身的分散治理, 决定了安全也必然是难以统一和标准化的. 做不到标准化就意味着做不到自动化, 相反一套独立于应用的安全基础设施, 可以让运维人员轻松了解基础设施变更对安全性的影响, 也可以在几乎不影响生产环境的情况下发布安全补丁程序.")]),t._v(" "),s("li",[s("strong",[t._v("强隔离性的工作负载")]),t._v(': "工作负载"的概念贯穿了 Google 内部的 Borg 系统与后来的 Kubernetes 系统, 它是指在虚拟化技术支持下运行的一组能够协同提供服务的镜像. 容器化仅仅是虚拟化的一个子集. 与传统虚拟机相比, '),s("strong",[t._v("容器的隔离能力是有所降低的")]),t._v(", 这种设计对性能非常有利, 却对安全相对不利, 因此在强调安全性的应用里, 会有专门关注强隔离性的容器运行工具出现.")])]),t._v(" "),s("h5",{attrs:{id:"_2-google的实践探索"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-google的实践探索"}},[t._v("#")]),t._v(" 2.Google的实践探索")]),t._v(" "),s("p",[t._v("Google 认为"),s("strong",[t._v("零信任安全模型的最终目标是实现整个基础设施之上的自动化安全控制, 服务所需的安全能力可以与服务自身一起, 以相同方式自动进行伸缩扩展")]),t._v('. 对于程序来说, 做到安全是日常, 风险是例外(Secure by Default and Insecure by Exception); 对于人类来说, 做到袖手旁观是日常, 主动干预是例外(Human Actions Should Be by Exception,Not Routine), 这的确是很美好的愿景, 只是这种"喊口号"式的目标在软件发展史上曾提出过多次, 却一直难以真正达成, 原因是安全不可能是绝对的, 而是有成本的. 很显然, 零信任网络模型之所以在今天才被真正严肃地讨论, 并不是因为它本身有多么巧妙, 有什么此前没有想到的好办法, 而是受制于前文提到的边界安全模型的"合理之处", 即"安全设施对整个应用系统复杂度的影响, 以及网络传输性能的额外损耗".')]),t._v(" "),s("p",[t._v("那零信任安全模型要实现这个目标要付出的代价是什么呢? 笔者将按照 Google 论文所述来回答这个问题: 为了保护服务集群内的代码与基础设施, Google 设计了一系列内部工具, 才最终得以实现前面所说的那些安全原则.")]),t._v(" "),s("ul",[s("li",[t._v('为了在网络边界上保护内部服务免受 DDoS 攻击, 设计了名为 Google Front End(名字意为"最终用户访问请求的终点")的'),s("strong",[t._v("边缘代理")]),t._v(", 负责保证此后所有流量都在 TLS 之上传输, 并自动将流量路由到适合的可用区域之中.")]),t._v(" "),s("li",[t._v("为了强制身份只来源于服务, 设计了名为 Application Layer Transport Security(应用层传输安全)的服务认证机制, 这是一个用于双向认证和传输加密的系统, 可以自动将服务与它的身份标识符绑定, 使得所有服务间流量都不必再使用服务名称, 主机 IP 来判断对方的身份.")]),t._v(" "),s("li",[t._v('为了确保服务间不再有默认的信任关系, 设计了 Service Access Policy(服务访问策略)来管理一个服务向另一个服务发起请求时所需提供的认证, 鉴权和审计策略, 并支持全局视角的访问控制与分析, 以满足"集中, 共享的安全策略实施点"的原则.')]),t._v(" "),s("li",[t._v("为了实现仅以受信的机器运行来源已知的代码, 设计了名为 Binary Authorization(二进制授权)的部署时检查机制, 确保在软件供应链的每一个阶段, 都符合内部安全检查策略, 并对此进行授权与鉴权. 同时设计了名为 Host Integrity(宿主机完整性)的机器安全启动程序, 在创建宿主机时自动验证包括 BIOS, BMC, Bootloader 和操作系统内核的数字签名.")]),t._v(" "),s("li",[t._v("为了工作负载能够具有强隔离性, 设计了名为 gVisor 的轻量级虚拟化方案, 这个方案与此前由 Intel 发起的 Kata Containers 的思路异曲同工. 目的都是弥补容器共享操作系统内核而导致隔离性不足的安全缺陷, 做法都是为每个容器提供一个独立的虚拟 Linux 内核, 譬如 gVisor 是用 Go 实现了一个名为 Sentry 的能够提供传统操作系统内核功能的进程. 严格来说, 无论是 gVisor 还是 Kata Containers, 尽管披着容器运行时的外衣, 但本质上都是轻量级虚拟机.")])]),t._v(" "),s("p",[t._v("作为一名普通的软件开发者, 看完 Google 关于零信任安全的论文, 或者听完这些简要的转述, 了解到即使 "),s("strong",[t._v("Google 也须花费如此庞大的精力才能做到零信任安全")]),t._v(", 最有可能的感受大概不是对零信任安全心生向往, 而是准备对它挥手告别了.")]),t._v(" "),s("p",[t._v("在微服务时代以前, "),s("strong",[t._v("传统的软件系统与研发模式的确很难承受零信任安全模型引发的代价, 只有到了云原生时代, 虚拟化的基础设施长足发展, 能将复杂性隐藏于基础设施之内, 开发者不需要为达成每一条安全原则而专门开发或引入可感知的安全设施; 只有容器与虚拟化网络的性能足够高, 可以弥补安全隔离与安全通信的额外损耗的前提下, 零信任网络的安全模型才有生根发芽的土壤")]),t._v(".")]),t._v(" "),s("p",[t._v("零信任安全模型在引入了比边界安全更细致, 更复杂的安全措施的同时, 也强调自动与透明的重要性, 既要保证系统各个微服务之间能安全通信, 也要保证不削弱微服务架构本身的设计原则, 譬如集中式的安全并不抵触分散治理原则, 安全机制并不影响服务的自动伸缩和有效的封装, 等等. 总而言之, "),s("strong",[t._v('只有零信任安全模型的成本在开发与运维上都是可接受的, 它才不会变成仅仅具备理论可行性的"大饼", 不会给软件带来额外的负担')]),t._v(". 如何构建零信任网络安全模型是一个非常大而且比较前沿的话题, 下一节将从实践角度出发, 更具体, 更量化地展示零信任安全模型的价值与权衡.")]),t._v(" "),s("h4",{attrs:{id:"服务安全"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务安全"}},[t._v("#")]),t._v(" 服务安全")]),t._v(" "),s("p",[t._v("本节将从实践和编码的角度出发, 介绍在微服务时代(以 Spring Cloud 为例)和云原生时代(以 Istio over Kubernetes 为例)分别是"),s("strong",[t._v("如何实现安全传输, 认证和授权")]),t._v("的, 通过这两者的对比, 探讨"),s("strong",[t._v("在微服务架构下如何将业界的安全技术标准引入并实际落地, 实现零信任网络下安全的服务访问")]),t._v(".")]),t._v(" "),s("h5",{attrs:{id:"_1-建立信任"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-建立信任"}},[t._v("#")]),t._v(" 1.建立信任")]),t._v(" "),s("p",[t._v("零信任网络里不存在默认的信任关系, 一切服务调用, 资源访问成功与否, 均需以调用者与提供者间已建立的信任关系为前提. 此前曾讨论过, 真实世界里, 能够达成信任的基本途径不外乎"),s("strong",[t._v("基于共同私密信息的信任和基于权威公证人的信任")]),t._v("两种; 网络世界里, 因为客户端和服务端之间一般没有什么共同私密信息, 所以真正能采用的就"),s("strong",[t._v("只能是基于权威公证人的信任, 这种信任有个标准的名字: 公开密钥基础设施")]),t._v("(Public Key Infrastructure, PKI).")]),t._v(" "),s("p",[t._v("PKI 是构建传输安全层(Transport Layer Security, TLS)的必要基础. 在任何网络设施都不可信任的假设前提下, 无论是 DNS 服务器, 代理服务器, 负载均衡器还是路由器, 传输路径上的每一个节点都有可能监听或者篡改通信双方传输的信息. 要保证通信过程不受到中间人攻击的威胁, "),s("strong",[t._v("启用 TLS 对传输通道本身进行加密, 让发送者发出的内容只有接受者可以解密是唯一具备可行性的方案")]),t._v(". 建立 TLS 传输, 说起来似乎不复杂, 只要在"),s("strong",[t._v("部署服务器时预置好 CA 根证书, 以后用该 CA 为部署的服务签发 TLS 证书")]),t._v('便是. 但落到实际操作上, 这事情就属于典型的"必须集中在基础设施中自动进行的安全策略实施点", 面对数量庞大且能够自动扩缩的服务节点, 依赖运维人员手工去部署和轮换根证书必定是难以为继的. 除了随服务节点动态扩缩而来的运维压力外, 微服务中 TLS 认证的频次也显著高于传统的应用, 比起公众互联网中主流单向的 TLS 认证, 在'),s("strong",[t._v("零信任网络中, 往往要启用双向 TLS 认证")]),t._v("(Mutual TLS Authentication, 常简写为 "),s("strong",[t._v("mTLS")]),t._v("), 即不仅要确认服务端的身份, 还要确认调用者的身份.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("单向 TLS 认证")]),t._v(": 只需要"),s("strong",[t._v("服务端提供证书")]),t._v(", 客户端通过服务端证书验证服务器的身份, 但"),s("strong",[t._v("服务器并不验证客户端的身份")]),t._v(". 单向 TLS 用于"),s("strong",[t._v("公开的服务")]),t._v(", 即任何客户端都被允许连接到服务进行访问, 它保护的重点是"),s("strong",[t._v("客户端免遭冒牌服务器的欺骗")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("双向 TLS 认证")]),t._v(": 客户端, 服务端"),s("strong",[t._v("双方都要提供证书")]),t._v(", 双方各自通过对方提供的证书来"),s("strong",[t._v("验证对方的身份")]),t._v(". 双向 TLS 用于"),s("strong",[t._v("私密的服务")]),t._v(", 即服务只允许特定身份的客户端访问, 它除了可以"),s("strong",[t._v("保护客户端不连接到冒牌服务器外, 也可以保护服务端不遭到非法用户的越权访问")]),t._v(".")])]),t._v(" "),s("p",[t._v("对于以上提到的围绕 TLS 而展开的密钥生成, 证书分发, 签名请求(Certificate Signing Request, CSR), 更新轮换等操作起来非常烦琐的流程, 稍有疏忽就会产生安全漏洞, 所以尽管理论上可行, 但实践中如果没有自动化的基础设施的支持, 仅靠应用程序和运维人员的努力, 是很难成功实施零信任安全模型的. 下面结合书店的例子, 聚焦于 "),s("strong",[t._v('"认证"和"授权"')]),t._v(" 这两个最基本的安全需求, 看它们在微服务架构下, 有或者没有基础设施支持时, 是如何实现的.")]),t._v(" "),s("h5",{attrs:{id:"_2-认证"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-认证"}},[t._v("#")]),t._v(" 2.认证")]),t._v(" "),s("p",[t._v("根据认证的目标对象可以把认证分为两种类型: 一种是以"),s("strong",[t._v("机器作为认证对象")]),t._v(", 即访问服务的流量来源是另外一个服务, 称为"),s("strong",[t._v("服务认证")]),t._v('(Peer Authentication, 直译过来是"节点认证"); 另一种是以'),s("strong",[t._v("人类作为认证对象")]),t._v(", 即访问服务的流量来自于最终用户, 称为"),s("strong",[t._v("请求认证")]),t._v("(Request Authentication). 无论哪一种认证, 无论是否有基础设施的支持, 均要有可行的方案来确定服务调用者的身份, 建立起信任关系才能调用服务.")]),t._v(" "),s("h6",{attrs:{id:"_1-服务认证"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-服务认证"}},[t._v("#")]),t._v(" (1)服务认证")]),t._v(" "),s("p",[t._v("Istio 版本的书店采用了双向 TLS 认证作为服务调用双方的身份认证手段. 得益于 Istio 提供的基础设施的支持, 我们不需要 Google Front End, Application Layer Transport Security 这些安全组件, 也不需要部署 PKI 和 CA, 甚至"),s("strong",[t._v("无须改动任何代码就可以启用 mTLS 认证")]),t._v(". 不过, Istio 毕竟是新生事物, 在你准备在生产系统中启用 mTLS 之前, 要先想一下"),s("strong",[t._v("是否整个服务集群全部节点都受 Istio 管理")]),t._v("? 如果每一个服务提供者, 调用者均受 Istio 管理, 那 mTLS 就是"),s("strong",[t._v("最理想的认证方案")]),t._v(". 只需要参考以下简单的 PeerAuthentication CRD 配置, 即可对某个 Kubernetes 名称空间范围内"),s("strong",[t._v("所有的流量")]),t._v("均启用 mTLS:")]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" security.istio.io/v1beta1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" PeerAuthentication\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" authentication"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("mtls\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("namespace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" bookstore"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("servicemesh\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("mtls")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("mode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" STRICT\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br")])]),s("p",[s("strong",[t._v("如果分布式系统还没有达到完全云原生的程度")]),t._v(", 其中仍存在部分不受 Istio 管理(即"),s("strong",[t._v("未注入边车")]),t._v(')的服务端或者客户端(这是颇为常见的),  也可以将 mTLS 传输声明为"'),s("strong",[t._v("宽容模式")]),t._v('"(Permissive Mode). 宽容模式的含义是受 Istio 管理的服务会允许'),s("strong",[t._v("同时接收纯文本和 mTLS 两种流量")]),t._v(", 纯文本流量仅用于与那些不受 Istio 管理的节点进行交互, 需要"),s("strong",[t._v("自行解决纯文本流量的认证问题")]),t._v("; 而对于服务网格内部的流量, 就可以使用 mTLS 认证. 宽容模式为普通微服务向服务网格迁移提供了良好的灵活性, 让运维人员能够逐个服务进行 mTLS 升级, 原本没有启用 mTLS 的服务在启用 mTLS 时甚至可以不中断现存已建立的纯文本传输连接, 完全不会被最终用户感知到. 一旦所有服务都完成迁移, 便可将整个系统设置为严格 TLS 模式, 即上面代码中的 mode:STRICT.")]),t._v(" "),s("p",[t._v("在 Spring Cloud 版本的书店实现里, 因为没有基础设施的支持, 一切"),s("strong",[t._v("认证工作就不得不在应用层面")]),t._v("去实现. 这里选择的方案是"),s("strong",[t._v("借用 OAuth 2 协议的客户端模式来进行认证")]),t._v(", 其大体思路分为如下两步.")]),t._v(" "),s("ul",[s("li",[t._v("每一个要调用服务的客户端都与认证服务器约定好一组只有自己知道的"),s("strong",[t._v("密钥")]),t._v("(Client Secret), 这个约定过程应该由运维人员在线下自行完成, 通过参数传给服务, "),s("strong",[t._v("而不是由开发人员在源码或配置文件中直接设定")]),t._v(". 密钥就是"),s("strong",[t._v("客户端的身份证明")]),t._v(", 客户端调用服务时, 会先使用该密钥向"),s("strong",[t._v("认证服务器申请 JWT 令牌, 然后通过令牌证明自己的身份, 最后访问服务")]),t._v('. 如以下代码所示, 它定义了五个客户端, 其中后面四个是集群内部的微服务, 均使用客户端模式, 且注明了授权范围是"SERVICE", 第一个是前端代码的微服务, 使用密码模式, 授权范围是"BROWSER".')])]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * 客户端列表\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Client")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" clients "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Arrays")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("asList")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Client")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bookstore_frontend"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bookstore_secret"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("GrantType")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("PASSWORD")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("GrantType")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("REFRESH_TOKEN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Scope")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("BROWSER")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 微服务一共有Security微服务, Account微服务, Warehouse微服务, Payment微服务四个客户端")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果正式使用, 这部分信息应该做成可以配置的, 以便快速增加微服务的类型. clientSecret")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 也不应该出现在源码中, 应由外部配置传入")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Client")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"account"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"account_secret"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("GrantType")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CLIENT_")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CREDENTIALS")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Scope")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SERVICE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Client")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"warehouse"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"warehouse_secret"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("GrantType")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CLIENT_")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CREDENTIALS")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Scope")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SERVICE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Client")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"payment"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"payment_secret"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("GrantType")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CLIENT_")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CREDENTIALS")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Scope")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SERVICE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Client")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"security"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"security_secret"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("GrantType")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CLIENT_")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CREDENTIALS")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Scope")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SERVICE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br")])]),s("ul",[s("li",[t._v("每一个对外提供服务的"),s("strong",[t._v("服务端")]),t._v(", 都扮演着 "),s("strong",[t._v("OAuth 2 中的资源服务器")]),t._v("的角色, 它们均声明为要求提供客户端模式的"),s("strong",[t._v("凭证")]),t._v(", 如以下代码所示.")])]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ClientCredentialsResourceDetails")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("clientCredentialsResourceDetails")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ClientCredentialsResourceDetails")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("客户端要调用受保护的服务, 就必须先"),s("strong",[t._v("出示能证明调用者身份的 JWT 令牌")]),t._v(", 否则就会遭到拒绝, 这个操作本质上是授权, 但是在授权过程中已实现了服务的身份认证.")]),t._v(" "),s("p",[t._v("由于每一个微服务都"),s("strong",[t._v("同时具有服务端和客户端两种身份")]),t._v(", 既消费其他服务, 也提供服务供别人消费, 所以在每个微服务中都应包含(放在公共 infrastructure 工程里)这些代码. Spring Security 提供的过滤器自动拦截请求, 驱动认证及授权检查的执行, 申请和验证 JWT 令牌等操作无论是开发期对程序员, 还是运行期对用户都能做到相对透明. 尽管如此, 以上做法仍然是一种"),s("strong",[t._v("应用层面")]),t._v("的, 不加密传输的解决方案. 前文提到在零信任网络中, 面对可能的中间人攻击, "),s("strong",[t._v("TLS 是唯一可行的办法")]),t._v(", 言下之意是即使应用层的认证能一定程度上保护服务不被身份不明的客户端越权调用, 但对传输过程中内容被监听, 篡改, 以及被攻击者在传输途中拿到 JWT 令牌后去冒认调用者身份调用其他服务等却是无法防御的. 简言之, "),s("strong",[t._v("这种方案不适用于零信任安全模型, 只能在默认内网节点间具备信任关系的边界安全模型上良好工作")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_2-用户认证"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-用户认证"}},[t._v("#")]),t._v(" (2)用户认证")]),t._v(" "),s("p",[t._v("对于来自"),s("strong",[t._v("最终用户的请求认证")]),t._v(", Istio版本的书店仍然能做到单纯"),s("strong",[t._v("依靠基础设施")]),t._v("解决问题, 整个认证过程无须应用程序参与(生成 JWT 令牌还是在应用中生成的, 因为书店并没有使用独立的用户认证服务器, 只有应用本身才拥有用户信息). 当来自最终用户的请求进入"),s("strong",[t._v("服务网格")]),t._v("时, Istio 会自动根据配置中的 JWKS(JSON Web Key Set)验证令牌的合法性, 如果令牌没有被篡改过且在有效期内, 就信任负载中的用户身份, 并从令牌的 Iss 字段中获得 Principal.")]),t._v(" "),s("p",[t._v("JWKS 之前没有提到, 它代表一个"),s("strong",[t._v("密钥仓库")]),t._v(". 在分布式系统中, JWT 应采用非对称的签名算法(RSA SHA256, ECDSA SHA256等, 默认的 HMAC SHA256 属于对称加密), 由认证服务器使用私钥对负载进行签名, 再由资源服务器使用公钥对签名进行验证. 常与 JWT 配合使用的 JWK(JSON Web Key)就是一种"),s("strong",[t._v("存储密钥的纯文本格式")]),t._v(", 本质上和 "),s("strong",[t._v("JKS")]),t._v("(Java Key Storage), "),s("strong",[t._v("P12")]),t._v("(Predecessor of PKCS#12), "),s("strong",[t._v("PEM")]),t._v("(Privacy Enhanced Mail)这些常见的"),s("strong",[t._v("密钥格式")]),t._v("在功能上并没有什么差别. JKWS 顾名思义就是一组 JWK 的集合, 支持 JKWS 的系统, 能通过 JWT 令牌 Header 中的 KID(Key ID) 来自动匹配出应该使用哪个 JWK 来验证签名.")]),t._v(" "),s("p",[t._v("以下是 Istio 版本的书店中的"),s("strong",[t._v("用户认证配置")]),t._v(', 其中 "jwks" 字段配置的就是 JWKS(实际生产中并'),s("strong",[t._v("不推荐")]),t._v("这样做, 应该使用 jwksUri 来配置一个 JWKS 地址, 以方便密钥轮换), 根据这里配置的"),s("strong",[t._v("密钥信息")]),t._v(", Istio 就能够验证请求中附带的 JWT 是否合法.")]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" security.istio.io/v1beta1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" RequestAuthentication\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" authentication"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("jwt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("token\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("namespace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" bookstore"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("servicemesh\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("jwtRules")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("issuer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"icyfenix@gmail.com"')]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# Envoy默认只认"Bearer"作为JWT前缀, 之前其他地方用的都是小写, 这里专门兼容一下')]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("fromHeaders")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Authorization\n            "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("prefix")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bearer "')]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 在rsa-key目录下放了用来生成这个JWKS的证书, 最初是用java keytool生成的jks")]),t._v("\n                格式"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 一般转jwks都是用pkcs12或者pem格式"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 为方便使用也一起附带了\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("jwks")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),s("span",{pre:!0,attrs:{class:"token scalar string"}},[t._v('\n            {\n                "keys": [\n                    {\n                        "e": "AQAB",\n                        "kid": "bookstore-jwt-kid",\n                        "kty": "RSA",\n                        "n": "i-htQPOTvNMccJjOkCAzd3YlqBElURzkaeRLDoJYskyU59Jd\n                        GO-p_q4JEH0DZOM2BbonGI4lIHFkiZLO4IBBZ5j2P7U6QYURt6-Ayj\n                        S6RGw9v_wFdIRlyBI9D3EO7u8rCA4RktBLPavfEc5BwYX2Vb9wX6N63\n                        tV48cP1CoGU0GtIq9HTqbEQs5KVmme5n4XOuzxQ6B2AGaPBJgdq_\n                        K0ZWDkXiqPz6921X3oiNYPCQ22bvFxb4yFX8ZfbxeYc-1rN7PaUsK\n                        009qOx-qRenHpWgPVfagMbNYkm0TOHNOWXqukxE-soCDI_Nc--\n                        1khWCmQ9E2B82ap7IXsVBAnBIaV9WQ"\n                  }\n              ]')]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("forwardOriginalToken")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br"),s("span",{staticClass:"line-number"},[t._v("25")]),s("br"),s("span",{staticClass:"line-number"},[t._v("26")]),s("br"),s("span",{staticClass:"line-number"},[t._v("27")]),s("br"),s("span",{staticClass:"line-number"},[t._v("28")]),s("br"),s("span",{staticClass:"line-number"},[t._v("29")]),s("br"),s("span",{staticClass:"line-number"},[t._v("30")]),s("br"),s("span",{staticClass:"line-number"},[t._v("31")]),s("br"),s("span",{staticClass:"line-number"},[t._v("32")]),s("br")])]),s("p",[t._v("Spring Cloud 版本的书店就略微麻烦一些, 它依然是采用 JWT 令牌作为用户身份凭证的载体, 认证过程依然在 Spring Security 的过滤器里中自动完成, 因讨论重点不在 Spring Security 的过滤器工作原理, 所以详细过程就不展开了, 主要路径是: 过滤器 → 令牌服务 → 令牌实现. Spring Security 已经做好了认证所需的绝大部分工作, 真正要开发者去"),s("strong",[t._v("编写的代码是令牌的具体实现")]),t._v(", 即代码中名为 RSA256PublicJWTAccessToken 的实现类. 它的作用是加载 Resource 目录下的"),s("strong",[t._v("公钥证书")]),t._v(" public.cert(注意, "),s("strong",[t._v("不要将密码, 密钥, 证书这类敏感信息打包到程序")]),t._v("中, 示例代码只是为了演示, 实际生产应该由运维人员管理密钥), 验证请求中的 JWT 令牌是否合法.")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Named")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RSA256PublicJWTAccessToken")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("JWTAccessToken")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RSA256PublicJWTAccessToken")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UserDetailsService")]),t._v(" userDetailsService"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throws")]),t._v(" \n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("IOException")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("userDetailsService"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Resource")]),t._v(" resource "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ClassPathResource")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"public.cert"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" publicKey "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FileCopyUtils")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("copyToByteArray")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("resource"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getInputStream")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setVerifierKey")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("publicKey"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br")])]),s("p",[t._v("如果 JWT 令牌合法, Spring Security 的过滤器就会放行调用请求, 并从令牌中提取出 Principal, 放到自己的安全上下文中 (即SecurityContextHolder.getContext()). 开发实际项目时, 可以根据需要自行决定 Principal 的具体形式, 既可以像 Istio 中那样直接从令牌中取出来, 以字符串形式原样存放, 节省一些数据库或者缓存的查询开销; 也可以统一做些额外的转换处理, 以方便后续业务使用, 譬如将 Principal 自动转换为系统中的用户对象. 书店的转换操作是在 JWT 令牌的父类 JWTAccessToken 中完成的. 可见尽管由应用自己来做请求验证会有一定的代码量和侵入性, 但自由度确实会更高一些.")]),t._v(" "),s("h5",{attrs:{id:"_3-授权"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-授权"}},[t._v("#")]),t._v(" 3.授权")]),t._v(" "),s("p",[t._v("经过认证之后, "),s("strong",[t._v("合法的调用者就有了可信任的身份")]),t._v(", 此时就已经不再需要区分调用者到底是机器(服务)还是人类(最终用户)了, 只"),s("strong",[t._v("根据其身份角色来进行权限访问控制")]),t._v("即可, 即常说的 "),s("strong",[t._v("RBAC")]),t._v('. 不过为了更便于理解, 书店提供的示例代码仍然沿用此前的思路, 分别针对来自"服务"和"用户"的流量来控制权限和访问范围.')]),t._v(" "),s("p",[t._v("举个具体例子, 如果准备把一部分微服务视为"),s("strong",[t._v("私有服务")]),t._v(", 限制它只接收来自集群内部其他服务的请求, 把另外一部分微服务视为"),s("strong",[t._v("公共服务")]),t._v(", 允许它接收来自集群外部的最终用户发出的请求; 又或者想要控制一部分服务只能由"),s("strong",[t._v("移动应用")]),t._v("调用, 另外一部分服务只能由浏览器调用. "),s("strong",[t._v("那一种可行的方案就是为不同的调用场景设立角色")]),t._v(", 进行授权控制(另一种常用的方案是做 BFF 网关).")]),t._v(" "),s("p",[t._v("在 Istio 版本的书店中, 通过以下配置, 限制了来自 bookstore-servicemesh 名称空间的"),s("strong",[t._v("内部流量")]),t._v("只允许访问 accounts, products, pay 和 settlements 四个端点的 GET, POST, PUT, PATCH 方法, 而对于来自 istio-system 名称空间(Istio Ingress Gateway 所在的名称空间)的外部流量就"),s("strong",[t._v("不作限制")]),t._v(", 直接放行.")]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" security.istio.io/v1beta1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" AuthorizationPolicy\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" authorization"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("peer\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("namespace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" bookstore"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("servicemesh\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("action")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ALLOW\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("rules")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("from")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("source")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("namespaces")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bookstore-servicemesh"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("to")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("operation")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("paths")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n              "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" /restful/accounts/*\n              "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" /restful/products*\n              "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" /restful/pay/*\n              "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" /restful/settlements*\n            "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("methods")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"GET"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"POST"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"PUT"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"PATCH"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("from")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("source")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("namespaces")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"istio-system"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br")])]),s("p",[t._v("但对外部的请求(不来自 bookstore-servicemesh 名称空间的流量), 又进行了另外一层控制, 如果请求中没有包含有效的登录信息, 就限制不允许访问 accounts, pay 和 settlements 三个端点, 如以下配置所示:")]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" security.istio.io/v1beta1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" AuthorizationPolicy\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" authorization"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("request\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("namespace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" bookstore"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("servicemesh\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("action")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" DENY\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("rules")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("from")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("source")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("notRequestPrincipals")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"*"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("notNamespaces")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bookstore-servicemesh"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("to")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("operation")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("paths")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n              "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" /restful/accounts/*\n              "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" /restful/pay/*\n              "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" /restful/settlements*\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br")])]),s("p",[t._v("Istio 已经提供了比较完善的目标匹配工具, 如上面配置中用到的源 from, 目标 to, 还有未用到的条件匹配 when, 以及其他如通配符, IP, 端口, 名称空间, JWT 字段等. 要说灵活和功能强大, 肯定还是不可能跟在应用中由代码实现的授权相媲美, 但对绝大多数场景已经够用了. 在便捷性, 安全性, 无侵入, 统一管理等方面, Istio 这种在基础设施上实现授权的方案显然要更具优势.")]),t._v(" "),s("p",[t._v("在 Spring Cloud 版本的书店中, 授权控制自然还是使用 Spring Security, 通过"),s("strong",[t._v("应用程序代码")]),t._v("来实现的. 常见的 Spring Security 授权方法有两种. 一种是使用它的 ExpressionUrlAuthorizationConfigurer, 即类似如下编码所示的写法来进行集中配置, 这与 Istio 的 AuthorizationPolicy CRD 中的写法在体验上是比较相似的, 也是几乎所有 Spring Security 资料中都有介绍的最主流方式, 适合对批量端点进行控制.")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("http"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("authorizeRequests")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("antMatchers")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/restful/accounts/**"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hasScope")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Scope")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("BROWSER")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("antMatchers")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/restful/pay/**"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hasScope")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Scope")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SERVICE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("另一种写法, 即示例代码中采用的方法, 是通过 Spring 的全局方法级安全(Global Method Security)以及 JSR 250 的 @RolesAllowed 注解来做授权控制. 这种写法对代码的"),s("strong",[t._v("侵入性更强")]),t._v(", 要以注解的形式分散写到每个服务甚至每个方法中, 但好处是能以更方便的形式做出更加精细的控制效果. 譬如要控制服务中某个方法只允许来自服务或者浏览器的调用, 那直接在该方法上标注 @PreAuthorize 注解即可, 还支持 SpEL 表达式来做条件. 表达式中用到的 SERVICE, BROWSER 代表授权范围, 是在声明客户端列表时传入的.")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * 根据用户名称获取用户详情\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@GET")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Path")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/{username}"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Cacheable")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"#username"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@PreAuthorize")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("\"#oauth2.hasAnyScope('SERVICE','BROWSER')\"")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Account")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getUser")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@PathParam")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"username"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" username"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" service"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("findAccountByUsername")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("username"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * 创建新的用户\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@POST")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@CacheEvict")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"#user.username"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@PreAuthorize")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("\"#oauth2.hasAnyScope('BROWSER')\"")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Response")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("createUser")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Valid")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@UniqueAccount")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Account")]),t._v(" user"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CommonResponse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("op")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" service"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("createAccount")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("user"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br")])]),s("h3",{attrs:{id:"可观测性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可观测性"}},[t._v("#")]),t._v(" 可观测性")]),t._v(" "),s("p",[t._v("随着分布式架构渐成主流, 可观测性(Observability)一词也日益频繁地被人提起. 学术界一般会将可观测性分解为"),s("strong",[t._v("三个更具体的方向")]),t._v("进行研究, 分别是"),s("strong",[t._v("事件日志, 链路追踪和聚合度量")]),t._v(', 这三个方向各有侧重, 又不完全独立, 它们天然就有重合或者可以结合之处. 2017 年的分布式追踪峰会结束后, Peter Bourgon 的文章 "Metrics,Tracing,and Logging" 系统地阐述了这三者的定义, 特征, 以及它们之间的关系与差异. 这里将它们的特征转述如下.')]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("日志")]),t._v("(Logging): 日志的职责是记录"),s("strong",[t._v("离散事件")]),t._v(', 通过这些记录分析出程序的行为, 譬如曾经调用过什么方法, 曾经操作过哪些数据等等. 输出日志很容易, 但收集和分析日志可能会很复杂, 面对成千上万的集群节点, 面对迅速滚动的事件信息, 面对以 TB 计算的文本, 传输与归集并不简单. 对大多数程序员来说, 分析日志也许就是最常遇见也最有实践可行性的"大数据系统"了.')]),t._v(" "),s("li",[s("strong",[t._v("追踪")]),t._v("(Tracing): 单体系统时代追踪的范畴基本只局限于栈追踪(Stack Tracing), 例如调试程序时, 在 IDE 打个断点, 看到的调用栈视图上的内容便是追踪; 编写代码时, 处理异常调用了 Exception::printStackTrace() 方法, 它输出的堆栈信息也是追踪. 微服务时代, 追踪就不只局限于调用栈了, "),s("strong",[t._v("一个外部请求需要内部若干服务的联动响应, 这时候完整的调用轨迹将跨越多个服务, 同时包括服务间的网络传输信息与各个服务内部的调用堆栈信息")]),t._v(', 因此, 分布式系统中的追踪在国内常被称为"'),s("strong",[t._v("全链路追踪")]),t._v('"(后文简称"链路追踪"), 许多资料中也称它为"分布式追踪"(Distributed Tracing). 追踪的主要'),s("strong",[t._v("目的是排查故障, 如分析调用链的哪一部分, 哪个方法出现错误或阻塞, 输入输出是否符合预期")]),t._v(", 等等.")]),t._v(" "),s("li",[s("strong",[t._v("度量")]),t._v("(Metrics): "),s("strong",[t._v("度量是指对系统中某一类信息的统计聚合")]),t._v(". 譬如证券市场的每一只股票都会定期公布财务报表, 通过财报上的营收, 净利, 毛利, 资产, 负载等一系列数据来体现过去一个财务周期中公司的经营状况, 这便是一种"),s("strong",[t._v("信息聚合")]),t._v(". Java 天生自带一种基本的度量, 即由虚拟机直接提供的 JMX(Java Management eXtensions)度量, 诸如内存大小, 各分代的用量, 峰值的线程数, 垃圾收集的吞吐量, 频率等都可以从 JMX 中获得. 度量的主要目的是"),s("strong",[t._v("监控")]),t._v("(Monitoring)和"),s("strong",[t._v("预警")]),t._v("(Alert), 如在某些度量指标达到风险阈值时触发事件, 以便自动处理或者提醒管理员介入.")])]),t._v(" "),s("p",[t._v("在工业界, 目前针对可观测性的产品已经是一片红海, 经过多年角逐, "),s("strong",[t._v("日志, 度量")]),t._v("两个领域的胜利者算是基本尘埃落定. "),s("strong",[t._v("日志收集和分析大多被统一到 Elastic Stack(ELK) 技术栈")]),t._v("上, 如果说未来还能出现什么变化的话, 也就是其中的 Logstash 有被 Fluentd 取代的趋势, 让 ELK 变成 EFK, 但整套 Elastic Stack 技术栈的地位已是相当稳固. "),s("strong",[t._v("度量方面")]),t._v(", 跟随 Kubernetes 统一容器编排的步伐, "),s("strong",[t._v("Prometheus")]),t._v(" 也击败了度量领域里以 Zabbix 为代表的众多前辈, 即将成为"),s("strong",[t._v("云原生时代度量监控的事实标准")]),t._v(', 虽然从市场角度来说 Prometheus 还没有达到 Kubernetes 那种"拔剑四顾, 举世无敌"的程度, 但是从社区活跃度上看, Prometheus 已占有绝对的优势, 在 Google 和 CNCF 的推动下, 未来可期.')]),t._v(" "),s("p",[t._v("Kubernetes 与 Prometheus 的关系: (1) Kubernetes 是 CNCF 第一个孵化成功的项目, Prometheus 是 CNCF 第二个孵化成功的项目. (2) Kubernetes 起源于 Google 的编排系统 Borg, Prometheus 起源于 Google 为 Borg 做的度量监控系统 BorgMon.")]),t._v(" "),s("p",[t._v("追踪方面的情况与日志, 度量有所不同, "),s("strong",[t._v("追踪是与具体网络协议, 程序语言密切相关")]),t._v("的. 收集日志不必关心这段日志是由 Java 还是由 Golang 程序输出的, 对程序来说它们就只是一段"),s("strong",[t._v("非结构化文本")]),t._v("而已, 同理, 度量对程序来说也只是一个个聚合的数据指标而已. 但链路追踪不一样, 各个服务之间是使用 HTTP 还是 gRPC 来进行通信会直接影响追踪的实现, 各个服务是使用 Java, Golang 还是 Node.js 来编写, 也会直接影响进程内调用栈的追踪方式. "),s("strong",[t._v("这种特性决定了追踪工具本身有较强的侵入性")]),t._v(", 通常是以"),s("strong",[t._v("插件式的探针")]),t._v("来实现; 也决定了追踪领域很难出现一家独大的情况, 通常要有多种产品来针对不同的语言和网络进行追踪. 近年来各种链路追踪产品层出不穷, 市面上主流的工具既有像 Datadog 这样的一揽子商业方案, 也有 AWS X-Ray 和 Google Stackdriver Trace 这样的云计算厂商产品, 还有像 SkyWalking, Zipkin, Jaeger 这样来自开源社区的优秀产品.")]),t._v(" "),s("h4",{attrs:{id:"事件日志"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件日志"}},[t._v("#")]),t._v(" 事件日志")]),t._v(" "),s("p",[s("strong",[t._v("日志用于记录系统运行期间发生过的离散事件")]),t._v(". 相信没有哪一个生产系统能够缺少日志功能, 然而却常常被人忽略. 打印日志是为了日后从中得到有价值的信息, 而今天只要稍微复杂点的系统, 尤其是复杂的分布式系统, 就很难只依靠 tail, grep, awk 来从日志中挖掘信息了, 往往还要有专门的全局查询和可视化功能. 此时, 从打印日志到分析查询之间, 还隔着"),s("strong",[t._v("收集, 缓冲, 聚合, 加工, 索引, 存储")]),t._v("等若干个步骤.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221228221921722.png",alt:"image-20221228221921722",title:"日志处理过程"}})]),t._v(" "),s("p",[t._v("这一整个链条中涉及大量值得注意的细节, 复杂性并不亚于任何一项技术或业务功能的实现. 接下来将以此为线索, 以最成熟的 Elastic Stack 技术栈为例, 介绍该链条每个步骤的目的与方法.")]),t._v(" "),s("h5",{attrs:{id:"_1-输出"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-输出"}},[t._v("#")]),t._v(" 1.输出")]),t._v(" "),s("p",[t._v('好的日志应该能做到像"流水账"一样, 无有遗漏地记录信息, '),s("strong",[t._v("格式统一, 内容恰当")]),t._v('. 其中"恰当"是一个难点, 它要求日志'),s("strong",[t._v("不应该过多, 也不应该过少")]),t._v('. "多与少"一般不针对输出的日志行数, 通常不以数量来衡量日志是否恰当, 而是以内容来衡量. 不该出现的内容不要有, 该有的不要少.')]),t._v(" "),s("p",[t._v('下面先列出一些常见的"'),s("strong",[t._v("不应该有")]),t._v('"的例子.')]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("避免打印敏感信息")]),t._v(". 不应该将密码, 银行账号, 身份证件这些敏感信息打到日志里. 一旦这些敏感信息随日志流到了后续的索引, 存储, 归档等步骤中, 清理起来将非常麻烦. 不过, 日志中应当"),s("strong",[t._v("包含必要的非敏感信息")]),t._v(", 譬如当前用户的 ID(最好是内部 ID, 避免登录名或用户名称), 有些系统会直接用 MDC(Mapped Diagnostic Context, 映射诊断上下文)将用户 ID 自动打印在日志模板(Pattern Layout)上.")]),t._v(" "),s("li",[s("strong",[t._v("避免引用慢操作")]),t._v(". 日志中打印的信息应该是在上下文中可以直接取到的, 如果当前上下文中根本没有这项数据, 需要专门调用远程服务或者从数据库获取, 又或者需要通过大量计算才能取到的话, 那应该先考虑把这项信息放到日志中是不是必要且恰当的.")]),t._v(" "),s("li",[s("strong",[t._v("避免打印追踪诊断信息")]),t._v('. 日志中不要打印方法输入参数, 输出结果, 方法执行时长之类的调试信息. 这个观点是反直觉的, 不少公司甚至会将其作为最佳实践来提倡, 但是笔者仍坚持将其归入反模式中. 日志的职责是记录事件, 追踪诊断应由追踪系统去处理, 哪怕贵公司完全没有开发追踪诊断方面功能的打算, 笔者也建议使用 BTrace 或者 Arthas 这类 "On-The-Fly" 的工具来解决. 之所以将其归为反模式, 是因为上面说的敏感信息, 慢操作等的主要源头就是这些原本想用于调试的日志. 譬如, 当前方法入口参数有个 User 对象, 如果要输出这个对象, 常见做法是将它序列化成 JSON 字符串然后打到日志里, 这时候 User 里面的 Password 字段, BankCard 字段就很容易被暴露出来; 再譬如, 当前方法的返回值是个映射, 开发期的调试数据只做了三五个实体, 觉得遍历一下把具体内容打到日志里面没什么问题, 但到了生产期, 这个映射里面有可能存放了'),s("strong",[t._v("成千上万")]),t._v("个实体, 这时候打印日志就相当于引用慢操作.")]),t._v(" "),s("li",[s("strong",[t._v("避免误导他人")]),t._v(". 日志中给日后调试除错的人挖坑是十分恶劣却又常见的行为. 相信程序员并不是专门要去误导别人, 只是很可能会无意识地这样做了. 譬如明明已经在逻辑中妥善处理好了某个异常, 却习惯性地调用 printStackTrace() 方法, 把堆栈打到日志中, 一旦这个方法附近出现问题, 由其他人来除错的话, 很容易会盯着这段堆栈去找线索而浪费大量时间.")])]),t._v(" "),s("p",[t._v('下面是日志中"不应该少"的内容例子.')]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("处理请求时的 Trace ID")]),t._v(". 服务收到请求时, 如果该请求没有附带 TraceID, 就应该自动生成唯一的 TraceID 来对请求进行标记, 并使用 "),s("strong",[t._v("MDC 自动输出")]),t._v("到日志. "),s("strong",[t._v("TraceID 会贯穿整条调用链, 目的是通过它把请求在分布式系统各个服务中的执行过程串联起来")]),t._v(". TraceID 通常也会随着请求的响应返回到客户端, 如果响应内容出现了异常, 用户便能通过此 ID 快速找到与问题相关的日志. TraceID 是链路追踪里的概念, 类似的还有用于标识进程内调用状况的 SpanID, 在 Java 程序中这些都可以用 Spring Cloud Sleuth 来自动生成. TraceID 会在分布式跟踪中发挥最大的作用, 在单体系统, 将 TraceID 记录到日志并返回给最终用户, 对快速定位错误也仍然十分有价值.")]),t._v(" "),s("li",[s("strong",[t._v("系统运行过程中的关键事件")]),t._v(". 日志的职责就是记录事件, 譬如进行了哪些操作, 发生了与预期不符的情况, 运行期间出现未能处理的异常或警告, 定期自动执行的任务等等, 都应该在日志中完整地记录下来. "),s("strong",[t._v("原则上程序中发生的事件只要有价值就应该去记录")]),t._v(", 但应判断清楚事件的重要程度, 选定相匹配的日志级别. 至于如何快速处理大量日志, 这是后面步骤要考虑的问题, 如果输出日志实在太频繁以至于影响性能, 应由运维人员去调整全局或单个类的日志级别来解决.")]),t._v(" "),s("li",[s("strong",[t._v("启动时输出配置信息")]),t._v(". 与避免输出诊断信息不同, 对于"),s("strong",[t._v("系统启动时或者检测到配置中心变化时更新的配置, 应将非敏感的配置信息输出到日志中")]),t._v(", 譬如连接的数据库, 临时目录的路径等, 因为"),s("strong",[t._v("初始化配置的逻辑一般只会执行一次, 不便于诊断时复现, 所以应该输出到日志中")]),t._v(".")])]),t._v(" "),s("h5",{attrs:{id:"_2-收集与缓冲"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-收集与缓冲"}},[t._v("#")]),t._v(" 2.收集与缓冲")]),t._v(" "),s("p",[t._v("写日志是在服务节点中进行的, 但不可能在每个节点都单独建设日志查询功能. 这不是资源或工作量的问题, 而是分布式系统处理一个请求要跨越多个服务节点, 为了能看到跨节点的全部日志, "),s("strong",[t._v("就要有能覆盖整个链路的全局日志系统")]),t._v(". 这个需求决定了每个节点输出日志到文件后, 必须将"),s("strong",[t._v("日志文件统一收集起来集中存储, 索引, 由此便催生了专门的日志收集器")]),t._v(".")]),t._v(" "),s("p",[t._v("最初, ELK 中的日志收集与后面的加工聚合的职责都是由 Logstash 来承担的, Logstash 除了部署在各个节点中作为收集的客户端(Shipper)外, 还同时设有独立部署的节点, 扮演归集转换日志的服务端(Master)的角色. Logstash 有良好的插件化设计, 支持收集, 转换, 输出的插件化定制, 应对多重角色本身并没有什么困难. 但是Logstash 与它的插件是基于 JRuby 编写的, 要跑在单独的 Java 虚拟机进程上, 而且 Logstash 默认的堆大小是 1GB. 对于归集部分(Master)这种消耗并不是什么问题, 但作为每个节点都要部署的日志收集器就显得太过负重了. 后来, Elastic.co 公司将所有需要在服务节点中处理的工作整理成以 Libbeat 为核心的 Beats 框架, 并使用 Golang 重写了一个功能较少, 却更"),s("strong",[t._v("轻量高效的日志收集器, 这就是今天流行的 Filebeat")]),t._v(".")]),t._v(" "),s("p",[t._v("现在的 Beats 已经是一个很大的家族了, 除了 Filebeat 外, Elastic.co 还提供了用于收集 Linux 审计数据的 Auditbeat, 用于无服务计算架构的 Functionbeat, 用于心跳检测的 Heartbeat, 用于聚合度量的 Metricbeat, 用于收集 Linux Systemd Journald 日志的 Journalbeat, 用于收集 Windows 事件日志的 Winlogbeat, 用于网络包嗅探的 Packetbeat, 等等, 如果再加上大量由社区维护的 Community Beats, 几乎能想到的数据都可以被收集到, 以至于 ELK 也可以在一定程度上代替度量和追踪系统, 实现它们的部分职能, 这对于中小型分布式系统来说是便利的, 但对于大型系统, 建议还是让专业的工具去做专业的事情.")]),t._v(" "),s("p",[t._v("日志收集器不仅要保证能"),s("strong",[t._v("覆盖全部数据来源, 还要尽力保证日志数据的连续性")]),t._v(", 这其实并不容易做到. 譬如淘宝这类大型的互联网系统, 每天的日志量超过了 10000TB(10PB) 量级, 日志收集器的部署实例数能到达百万量级, 此时归集到系统中的日志要与实际产生的日志"),s("strong",[t._v("保持绝对的一致性是非常困难")]),t._v("的, 也不应该为此付出过高成本. 换言之, "),s("strong",[t._v("日志不追求绝对的完整精确, 只追求在代价可承受的范围内尽可能地保证较高的数据质量")]),t._v(". 一种最常用的缓解压力的做法是将日志接收者从 Logstash 和 Elasticsearch 转移至抗压能力更强的队列缓存, 譬如在 Logstash 之前架设一个 Kafka 或者 Redis 作为"),s("strong",[t._v("缓冲层")]),t._v(", 面对突发流量, Logstash 或 Elasticsearch 处理能力出现瓶颈时自动削峰填谷, 甚至当它们短时间停顿时, 也"),s("strong",[t._v("不会丢失")]),t._v("日志数据.")]),t._v(" "),s("h5",{attrs:{id:"_3-加工与聚合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-加工与聚合"}},[t._v("#")]),t._v(" 3.加工与聚合")]),t._v(" "),s("p",[t._v("在将日志集中收集之后, 存入 Elasticsearch 之前, 一般还要对它们进行"),s("strong",[t._v("加工转换和聚合处理")]),t._v(". 这是因为日志是非结构化数据, 一行日志中通常会包含多项信息, 如果不做处理, 那在 Elasticsearch 中就只能以"),s("strong",[t._v("全文检索")]),t._v("的原始方式去使用日志, 既不利于统计对比, 也不利于条件过滤. 举个具体例子, 下面是一行 Nginx 服务器的 Access 日志, 代表了一次页面访问操作:")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[t._v('14.123.255.234 - - [19/Feb/2020:00:12:11 +0800] "GET /index.html HTTP/1.1" 200 \n    1314 "https://icyfenix.cn" "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/\n    537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36"\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("在这一行日志里面, 包含了 10 项独立数据项.")]),t._v(" "),s("p",[t._v("Logstash 的基本职能是把"),s("strong",[t._v("日志行中的非结构化数据, 通过 Grok 表达式语法转换为结构化数据")]),t._v(", 进行结构化的同时, 还可能会根据需要, 调用其他插件来完成"),s("strong",[t._v("时间处理")]),t._v("(统一时间格式), "),s("strong",[t._v("类型转换")]),t._v("(如字符串, 数值的转换), "),s("strong",[t._v("查询归类")]),t._v("(譬如将 IP 地址根据地理信息库按省市归类)等额外处理工作, 然后以 "),s("strong",[t._v("JSON 格式输出到 Elasticsearch 中")]),t._v("(这是最普遍的输出形式, Logstash 输出也有很多插件, 可以具体定制不同的格式). 有了这些经过 Logstash 转换, 已经结构化的日志, Elasticsearch 便可针对"),s("strong",[t._v("不同的数据项来建立索引, 进行条件查询, 统计, 聚合等操作")]),t._v("了.")]),t._v(" "),s("p",[t._v("提到聚合, 这也是 Logstash 的另一个常见职能. 日志中存储的是"),s("strong",[t._v("离散事件")]),t._v(", 离散的意思是每个事件都是相互独立的, 譬如有 10 个用户访问服务, 他们的操作所产生的事件都会在日志中分别记录. 如果想从离散的日志中获得统计信息, 譬如想知道这些用户中正常返回(200 OK)的有多少, 出现异常的(500 Internal Server Error)的有多少, 再生成一个可视化统计图表, 一种解决方案是通过 Elasticsearch 本身的处理能力做"),s("strong",[t._v("实时的聚合统计")]),t._v(", 这很便捷, 不过要消耗 Elasticsearch 服务器的运算资源. 另一种解决方案是在"),s("strong",[t._v("收集日志后自动生成某些常用的, 固定的聚合指标")]),t._v(", 这种聚合就会在 Logstash 中通过"),s("strong",[t._v("聚合插件")]),t._v("来完成. 这两种聚合方式都有不少实际应用, 前者一般用于即席查询, 后者用于固定查询.")]),t._v(" "),s("h5",{attrs:{id:"_4-存储与查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-存储与查询"}},[t._v("#")]),t._v(" 4.存储与查询")]),t._v(" "),s("p",[t._v("经过"),s("strong",[t._v("收集, 缓冲, 聚合, 加工的日志数据")]),t._v(", 终于可以"),s("strong",[t._v("放入 Elasticsearch 中索引存储")]),t._v("了. Elasticsearch 是整个 Elastic Stack 技术栈的核心, 其他步骤的工具, 如 Filebeat, Logstash, Kibana 都有替代品, 有自由选择的余地, 唯独 Elasticsearch 在日志分析这方面完全没有什么值得一提的竞争者, 几乎就是解决此问题的唯一答案. 这样的结果与 Elasticsearch 本身是一款优秀产品有关, 然而更关键的是 Elasticsearch 的优势正好与日志分析的需求完美契合.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("从数据特征的角度看")]),t._v(", 日志是典型的基于时间的数据流, 但它与其他时间数据流, 譬如新浪微博, 微信朋友圈这种社交网络数据又稍有区别: 日志虽然增长速度很快, 但已写入的数据几乎没有再发生变动的可能. 日志的数据特征决定了所有用于"),s("strong",[t._v("日志分析的 Elasticsearch 都会使用时间范围作为索引")]),t._v(", 根据实际数据量的大小, 范围可能是按月, 按周或者按日, 按时. 以按日索引为例, 由于能准确地预知明天, 后天的日期, 因此全部索引都可以"),s("strong",[t._v("预先创建")]),t._v(', 这免去了动态创建的寻找节点, 创建分片, 在集群中广播变动信息等开销. 又由于所有新的日志都是"今天"的日志, 所以只要建立"logs_current"这样的索引别名来指向当前索引, 就能避免代码因日期而变动.')]),t._v(" "),s("li",[s("strong",[t._v("从数据价值的角度看")]),t._v(", 日志基本只会以"),s("strong",[t._v("最近的数据")]),t._v("为检索目标, 随着时间推移, 早期的数据将逐渐失去价值. 这点决定了可以很容易区分出"),s("strong",[t._v("冷数据和热数据")]),t._v(", 进而对不同数据采用不同的硬件策略. 譬如为热数据配备 SSD 磁盘和更好的处理器, 为冷数据配备 HDD 磁盘和较弱的处理器, 甚至可以放到更为廉价的对象存储(如阿里云的 OSS, AWS 的 S3 等)中归档. 注意, 本节的主题是日志在"),s("strong",[t._v("可观测性")]),t._v("方面的作用, 另外还有一些基于日志的其他类型应用, 譬如从日志记录的事件中"),s("strong",[t._v("挖掘业务热点, 分析用户习惯")]),t._v('等, 这属于真正的大数据挖掘的范畴, 并不在这里讨论 "价值" 的范围之内, 事实上它们更可能采用的技术栈是 HBase 与 Spark 的组合, 而不是 Elastic Stack.')]),t._v(" "),s("li",[s("strong",[t._v("从数据使用的角度看")]),t._v(", 分析日志很依赖"),s("strong",[t._v("全文检索和即席查询")]),t._v(', 对实时性的要求是处于实时与离线两者之间的"近实时", 即不强求日志产生后立刻能查到, 但不能接受日志产生之后按小时甚至按天的频率来更新, 这些检索能力和近实时性, 也正好都是 Elasticsearch 的强项.')])]),t._v(" "),s("p",[t._v('Elasticsearch 只提供了 API 层面的查询能力, 通常与同样出自 Elastic.co 的 Kibana 一起搭配使用, 可以将 Kibana 视为 Elastic Stack 的 GUI 部分. 尽管 Kibana 只负责图形界面和展示, 但它提供的能力远不止在界面上执行 Elasticsearch 的查询那么简单. Kibana 宣传的核心能力是"探索数据并可视化", 即对存储在 Elasticsearch 中的数据进行'),s("strong",[t._v("检索, 聚合, 统计后, 定制形成各种图形, 表格, 指标, 统计, 以此观察系统的运行状态, 找出日志事件中潜藏的规律和隐患")]),t._v('. 按 Kibana 官方的宣传语来说就是"一张图片胜过千万行日志".')]),t._v(" "),s("h4",{attrs:{id:"链路追踪"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链路追踪"}},[t._v("#")]),t._v(" 链路追踪")]),t._v(" "),s("p",[t._v('现代分布式链路追踪公认的起源是 Google 在 2010 年发表的论文 "Dapper:a Large-Scale Distributed Systems Tracing Infrastructure". 这篇论文介绍了 Google 从 2004 年开始使用的分布式追踪系统 Dapper 的实现原理. 此后业界所有有名的追踪系统, 无论是国外 Twitter 的 Zipkin, Naver 的 Pinpoint, 抑或是阿里的鹰眼, 大众点评的 CAT 都受到 Dapper 论文的直接影响.')]),t._v(" "),s("p",[t._v("从广义上讲, 一个完整的"),s("strong",[t._v("分布式追踪系统应该由数据收集, 数据存储和数据展示")]),t._v("三个相对独立的子系统构成, 而从狭义上讲, "),s("strong",[t._v("追踪则只是特指链路追踪数据的收集部分")]),t._v(". 譬如 Spring Cloud Sleuth 就属于狭义的追踪系统, 通常会搭配 Zipkin(用于数据展示)和 Elasticsearch(用于数据存储)来组合使用, 而上文提到的那些追踪系统大多都属于"),s("strong",[t._v("广义")]),t._v('的追踪系统, 也常被称为 "APM系统"(Application Performance Management).')]),t._v(" "),s("h5",{attrs:{id:"_1-追踪与跨度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-追踪与跨度"}},[t._v("#")]),t._v(" 1.追踪与跨度")]),t._v(" "),s("p",[t._v('为了有效地进行分布式追踪, Dapper 提出了"追踪"与"跨度"两个概念. 从客户端发起请求抵达系统的边界开始, 记录请求流经的每一个服务, 直到向客户端返回响应为止, 这整个过程就称为一次"追踪"(Trace, 为了不产生混淆, 后文就直接使用英文 Trace 来指代了). 由于每次 Trace 都可能会调用数量不定, 坐标不定的多个服务, 为了能够记录具体调用了哪些服务, 以及调用顺序, 开始时点, 执行时长等信息, 每次开始调用服务前都要先埋入一个调用记录, 这个记录称为一个"'),s("strong",[t._v("跨度")]),t._v('"(Span). Span 的数据结构应该足够简单, 以便能放在日志或者网络协议的报文头里; 也应该足够完备, 起码应含有时间戳, 起止时间, Trace 的 ID, 当前 Span 的 ID, 父 Span 的 ID 等能够满足追踪需要的信息. 每一次 Trace 实际上都是由若干个有顺序, 有层级关系的 Span 所组成的一棵"追踪树"(Trace Tree).')]),t._v(" "),s("p",[t._v("从目标来看, "),s("strong",[t._v("链路追踪的目的是为排查故障和分析性能提供数据支持")]),t._v(", 若系统在对外提供服务的过程中, 能持续地接收请求并处理响应, 同时能持续地生成 Trace, 按次序整理好 Trace 中每一个 Span 所记录的调用关系, 便能绘制出一幅"),s("strong",[t._v("系统的服务调用拓扑图")]),t._v(". 根据拓扑图中 Span 记录的时间信息和响应结果(正常或异常返回)就可以定位到缓慢或者出错的服务; 将 Trace 与历史记录进行对比统计, 就可以从系统整体层面分析服务性能, 定位性能优化的目标.")]),t._v(" "),s("p",[t._v("从实现来看, 为每次服务调用记录 Trace 和 Span, 并以此构成追踪树结构, 听着好像没那么复杂, 然而考虑到实际情况, 追踪系统在功能性和非功能性上都面临不小的挑战. 功能上的挑战来源于服务的"),s("strong",[t._v("异构性")]),t._v(", 各个服务可能采用不同的程序语言, 服务间交互可能采用不同的网络协议, 每兼容一种场景, 都会增加功能实现方面的工作量. 而"),s("strong",[t._v("非功能性的挑战")]),t._v("则具体来源于以下这四个方面.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("低性能损耗")]),t._v(": 分布式追踪不能对服务本身产生明显的性能负担. 追踪的主要目的之一就是寻找性能缺陷, 越慢的服务越是需要追踪, 所以工作场景都是性能敏感的地方.")]),t._v(" "),s("li",[s("strong",[t._v("对应用透明")]),t._v(": 追踪系统通常是运维期才加入的系统, 应该尽量以非侵入或者少侵入的方式来实现追踪, 对开发人员做到透明化.")]),t._v(" "),s("li",[s("strong",[t._v("随应用扩缩")]),t._v(": 现代的分布式服务集群都有根据流量压力自动扩缩的能力, 这要求当业务系统扩缩时, 追踪系统也能自动跟随, 不需要运维人员人工参与.")]),t._v(" "),s("li",[s("strong",[t._v("持续的监控")]),t._v(": 要求追踪系统必须能够 7×24 小时工作, 否则就难以定位到系统偶尔抖动的行为.")])]),t._v(" "),s("h5",{attrs:{id:"_2-数据收集"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-数据收集"}},[t._v("#")]),t._v(" 2.数据收集")]),t._v(" "),s("p",[t._v("目前, 追踪系统根据"),s("strong",[t._v("数据收集方式的差异")]),t._v(", 可分为三种主流的实现方式, "),s("strong",[t._v("分别是基于日志的追踪")]),t._v("(Log-Based Tracing), "),s("strong",[t._v("基于服务的追踪")]),t._v("(Service-Based Tracing)"),s("strong",[t._v("和基于边车代理的追踪")]),t._v("(Sidecar-Based Tracing), 分别介绍如下.")]),t._v(" "),s("h6",{attrs:{id:"_1-基于日志的追踪"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-基于日志的追踪"}},[t._v("#")]),t._v(" (1)基于日志的追踪")]),t._v(" "),s("p",[t._v("基于日志的追踪的思路是将 Trace, Span 等信息"),s("strong",[t._v("直接输出到应用日志")]),t._v("中, 然后随着所有节点的日志归集过程"),s("strong",[t._v("汇聚到一起, 再从全局日志信息中反推出完整的调用链拓扑关系")]),t._v(". 日志追踪对网络消息完全没有侵入性, 对应用程序只有很少量的侵入性, 对性能影响也非常低. 但其缺点是"),s("strong",[t._v("直接依赖于日志归集过程")]),t._v(", 日志本身不追求绝对的连续与一致, 这也使得基于日志的追踪往往不如其他两种追踪实现精准. 另外, 业务服务的调用与日志的归集并不是同时完成的, 也通常不由同一个进程完成, 有可能业务调用已经顺利结束了, 但由于日志归集不及时或者精度丢失, 导致"),s("strong",[t._v("日志出现延迟或缺失记录, 进而产生追踪失真")]),t._v(". 这也是前面介绍 Elastic Stack 时提到的观点, ELK 在日志, 追踪和度量方面都可以发挥作用, 这对中小型应用确实有一定便利, 但是大型系统最好还是选择由专业的工具做专业的事. 日志追踪的代表产品是 Spring Cloud Sleuth, 下面是一段由 Sleuth 在调用时"),s("strong",[t._v("自动生成的日志记录")]),t._v(", 可以从中观察到 TraceID, SpanID, 父 SpanID 等追踪信息.")]),t._v(" "),s("div",{staticClass:"language-plaintext line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-plaintext"}},[s("code",[t._v("# 以下为调用端的日志输出: \nCreated new Feign span [Trace: cbe97e67ce162943, Span: bb1798f7a7c9c142,\n    Parent: cbe97e67ce162943, exportable:false]\n2019-06-30 09:43:24.022 [http-nio-9010-exec-8] DEBUG o.s.c.s.i.web.client.\n    feign.TraceFeignClient - The modified request equals GET http://localhost:\n    9001/product/findAll HTTP/1.1\n\nX-B3-ParentSpanId: cbe97e67ce162943\nX-B3-Sampled: 0\nX-B3-TraceId: cbe97e67ce162943\nX-Span-Name: http:/product/findAll\nX-B3-SpanId: bb1798f7a7c9c142\n\n# 以下为服务端的日志输出: \n[findAll] to a span [Trace: cbe97e67ce162943, Span: bb1798f7a7c9c142, Parent: \n    cbe97e67ce162943, exportable:false]\nAdding a class tag with value [ProductController] to a span [Trace: \n    cbe97e67ce162943, Span: bb1798f7a7c9c142, Parent: cbe97e67ce162943, \n    exportable:false]\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br")])]),s("h6",{attrs:{id:"_2-基于服务的追踪"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-基于服务的追踪"}},[t._v("#")]),t._v(" (2)基于服务的追踪")]),t._v(" "),s("p",[t._v("基于"),s("strong",[t._v("服务的追踪是目前最常见的追踪实现方式")]),t._v(", 被 Zipkin, SkyWalking, Pinpoint 等主流追踪系统广泛采用. 服务追踪的实现思路是通过"),s("strong",[t._v("某些手段给目标应用注入追踪探针(Probe)")]),t._v(" , 针对 Java 应用一般是通过 Java Agent 注入. 探针在结构上可视为"),s("strong",[t._v("一个寄生在目标服务身上的小型微服务系统")]),t._v(", 它一般会有自己专用的服务注册, 心跳检测等功能, 有"),s("strong",[t._v("专门的数据收集协议, 把从目标系统中监控到的服务调用信息, 通过另外一次独立的 HTTP 或者 RPC 请求发送给追踪系统")]),t._v(". 因此, 基于服务的追踪会比基于日志的追踪消耗更多的资源, 也有更强的侵入性, 换来的收益是追踪的精确性与稳定性都有所保证, 不必再依靠日志归集来传输追踪数据.")]),t._v(" "),s("p",[t._v('前面把"打印追踪诊断信息"列为'),s("strong",[t._v("反模式")]),t._v(", 如果需要诊断方法参数, 返回值, 上下文信息, 或者方法调用耗时这类数据, 通过追踪系统来实现是比通过日志系统实现更加恰当的解决方案.")]),t._v(" "),s("p",[t._v("当然, 这里也必须说明清楚, 像图中 Pinpoint 这种详细程度的追踪对应用系统的性能压力是相当大的, 一般仅在除错时开启, 而且 Pinpoint 本身就是比较重负载的系统(运行它必须先维护一套 HBase), 这严重制约了它的适用范围, 目前服务追踪的其中一个发展趋势是轻量化, 国产的 SkyWalking 正是这方面的佼佼者.")]),t._v(" "),s("h6",{attrs:{id:"_3-基于边车代理的追踪"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-基于边车代理的追踪"}},[t._v("#")]),t._v(" (3)基于边车代理的追踪")]),t._v(" "),s("p",[s("strong",[t._v("基于边车代理的追踪是服务网格的专属方案")]),t._v(", 也是"),s("strong",[t._v("最理想")]),t._v("的分布式追踪模型, 它对"),s("strong",[t._v("应用完全透明")]),t._v(", 无论是日志还是服务本身都不会有任何变化; 它与程序语言无关, 无论应用采用什么编程语言实现, 只要它还是通过网络(HTTP 或者 gRPC)来访问服务就可以被追踪到; 它有自己"),s("strong",[t._v("独立的数据通道")]),t._v(", 追踪数据通过控制平面上报, 避免了追踪对程序通信或者日志归集的依赖和干扰, 保证了最佳的精确性.")]),t._v(" "),s("p",[t._v("如果要说这种追踪实现方式的缺点, 那就是服务网格现在还"),s("strong",[t._v("不够普及")]),t._v(", 但随着云原生的发展, 相信它在未来会成为追踪系统的主流实现方式之一. 此外, 边车代理本身对应用透明的工作原理决定了它"),s("strong",[t._v("只能实现服务调用层面的追踪")]),t._v(", 不能做到 Pinpoint 那样本地方法调用级别的追踪诊断.")]),t._v(" "),s("p",[t._v("现在市场占有率最高的边车代理 Envoy 就提供了相对完善的追踪功能, 但没有提供自己的界面端和存储端, 所以 Envoy 和 Sleuth 一样都属于狭义的追踪系统, 需要配合专门的 UI 与存储来使用, 现在 SkyWalking, Zipkin, Jaeger, LightStep Tracing 等系统都可以接收来自 Envoy 的追踪数据, 充当它的界面端.")]),t._v(" "),s("h5",{attrs:{id:"_3-追踪规范化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-追踪规范化"}},[t._v("#")]),t._v(" 3.追踪规范化")]),t._v(" "),s("p",[t._v("比起日志与度量, 追踪这个领域的产品竞争要相对"),s("strong",[t._v("激烈")]),t._v('得多. 一方面, 目前还没有像日志, 度量那样出现具有明显统治力的产品, 仍处于群雄混战的状态. 另一方面, 几乎市面上所有的追踪系统都是以 Dapper 的论文为原型发展出来的, 基本上都算是"同门师兄弟", '),s("strong",[t._v("功能上并没有太本质的差距, 却又受制于实现细节, 彼此互斥, 很难搭配工作")]),t._v(". 这种局面只能怪当初 Google 发表的 Dapper 只是论文而不是有约束力的规范标准, 只提供了思路, 并没有规定细节, 譬如该怎样进行埋点, Span 上下文具体该有什么数据结构, 怎样设计追踪系统与探针或者界面端的 API 接口, 等等, 都没有权威的规定.")]),t._v(" "),s("p",[t._v("为了推进追踪领域的产品的标准化, 2016 年 11 月, CNCF 技术委员会接受了 OpenTracing 作为基金会第三个项目. "),s("strong",[t._v("OpenTracing 是一套与平台无关, 与厂商无关, 与语言无关的追踪协议规范, 只要遵循 OpenTracing 规范, 任何公司的追踪探针, 存储, 界面都可以随时切换, 也可以相互搭配使用")]),t._v(".")]),t._v(" "),s("p",[t._v("在操作层面, OpenTracing 只是制定了一个很薄的"),s("strong",[t._v("标准化层, 位于应用程序与追踪系统之间, 使得即使探针与追踪系统不是同一个厂商的产品, 只要它们都支持 OpenTracing 协议就可以互相通信")]),t._v(". 此外, OpenTracing 还规定了微服务之间发生调用时, 应该如何传递 Span 信息(OpenTracing Payload).")]),t._v(" "),s("p",[t._v("OpenTracing 规范公布后, 几乎所有业界有名的追踪系统, 譬如 Zipkin, Jaeger, SkyWalking 等都很快宣布支持 OpenTracing, 但 Google 自己却在此时出来反对, 并提出了与 OpenTracing 目标类似的 "),s("strong",[t._v("OpenCensus 规范")]),t._v(", 随后又得到了巨头 Microsoft 的支持和参与. OpenCensus 不仅涉及追踪, 还把指标度量纳入进来; 内容上不仅涉及规范制定, 还把数据采集的探针和收集器都一起以 SDK(目前支持五种语言)的形式提供出来.")]),t._v(" "),s("p",[s("strong",[t._v("OpenTracing 和 OpenCensus 迅速形成可观测性的两大阵营")]),t._v(", 一边是在这方面深耕多年的众多老牌 APM 系统厂商, 另一边是分布式追踪概念的提出者 Google 以及与 Google 同样庞大的 Microsoft. 对追踪系统的规范化工作, 并没有平息厂商竞争的混乱, 反倒把水搅得更浑了.")]),t._v(" "),s("p",[t._v("2019 年, OpenTracing 和 OpenCensus 又忽然宣布握手言和, "),s("strong",[t._v("共同发布了可观测性的终极解决方案 OpenTelemetry")]),t._v(", 并宣布会各自冻结 OpenTracing 和 OpenCensus 的发展. OpenTelemetry 野心颇大, "),s("strong",[t._v("不仅包括追踪规范, 还包括日志和度量方面的规范, 各种语言的 SDK, 以及采集系统的参考实现, 它距离一个完整的追踪与度量系统, 仅仅是缺了界面端和指标预警这些会与用户直接接触的后端功能")]),t._v(", 将它们留给具体产品去实现, 勉强算是 OpenTelemetry 没有对一众 APM 厂商赶尽杀绝, 留了一条活路.")]),t._v(" "),s("h4",{attrs:{id:"聚合度量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#聚合度量"}},[t._v("#")]),t._v(" 聚合度量")]),t._v(" "),s("p",[s("strong",[t._v("度量的目的是揭示系统的总体运行状态")]),t._v(". 相信大家应该见过这样的场景: 在舰船的驾驶舱或者卫星发射中心的控制室, 在整个房间最显眼的位置, 布满整面墙壁的巨型屏幕里显示着一个个指示器, 仪表板与统计图表, 沉稳端坐中央的指挥官看着屏幕上闪烁变化的指标, 果断决策, 下达命令. 由此可见度量与日志, 追踪的差别, "),s("strong",[t._v("度量是用经过聚合统计后的高维度信息, 以最简单直观的形式来总结复杂的过程, 为监控, 预警提供决策支持")]),t._v(".")]),t._v(" "),s("p",[t._v("Windows 中的任务管理器也是一个非常具有代表性的度量系统.")]),t._v(" "),s("p",[s("strong",[t._v("度量")]),t._v("总体上可分为"),s("strong",[t._v("客户端的指标收集, 服务端的存储查询以及终端的监控预警")]),t._v("三个相对独立的过程, 每个过程在系统中一般也会设置对应的组件来实现.")]),t._v(" "),s("p",[t._v("Prometheus 在度量领域的统治力虽然还暂时不如日志领域中 Elastic Stack 那么稳固, 但在云原生时代, 基本也已经能算是事实标准了, 接下来主要以 Prometheus 为例, 介绍这三个过程的总体思路, 大致内容与理论标准.")]),t._v(" "),s("h5",{attrs:{id:"_1-指标收集"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-指标收集"}},[t._v("#")]),t._v(" 1.指标收集")]),t._v(" "),s("p",[t._v("指标收集部分要解决两个问题:  "),s("strong",[t._v('"如何定义指标" 以及 "如何将这些指标告诉服务端"')]),t._v(" . 如何定义指标这个问题听起来应该是与目标系统密切相关的, 必须根据实际情况才能讨论, 但这并不是绝对的, 无论目标是何种系统, 都具备一些共性特征. 确定目标系统前我们无法决定要收集什么指标, 但"),s("strong",[t._v("指标的数据类型(Metric Type)是可数的, 而所有通用的度量系统都是面向指标的数据类型来设计的")]),t._v(".")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("计数度量器")]),t._v("(Counter): 这是最好理解也是最常用的指标形式. 计数度量器就是对有"),s("strong",[t._v("相同量纲, 可加减数值的合计量")]),t._v(", 譬如"),s("strong",[t._v("业务指标, 销售额, 货物库存量, 职工人数等; 技术指标, 服务调用次数, 网站访问人数等都属于计数器指标")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("瞬态度量器")]),t._v("(Gauge): 瞬态度量器比计数器还简单, 它表示"),s("strong",[t._v("某个指标在某个时点的数值, 连加减统计都不需要")]),t._v(". 譬如当前 Java 虚拟机"),s("strong",[t._v("堆内存的使用量")]),t._v(", 这就是一个瞬态度量器; 又譬如"),s("strong",[t._v("网站访问人数是计数器指标, 而网站在线人数则是瞬态度量指标")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("吞吐率度量器")]),t._v("(Meter): 吞吐率度量器顾名思义是用于"),s("strong",[t._v("统计单位时间的吞吐量")]),t._v(", 即"),s("strong",[t._v("单位时间内某个事件的发生次数")]),t._v('. 譬如交易系统中常以 TPS 衡量事务吞吐率, 即每秒发生了多少笔事务交易; 又譬如港口的货运吞吐率常以"吨/每天"为单位计算.')]),t._v(" "),s("li",[s("strong",[t._v("直方图度量器")]),t._v("(Histogram): 直方图是常见的"),s("strong",[t._v("二维统计图")]),t._v(", 它的两个坐标分别是"),s("strong",[t._v("统计样本和该样本对应的某个属性的度量")]),t._v(", 以长条图的形式表示具体数值. 譬如经济报告中要衡量某个地区历年的 GDP 变化情况, 常会以 GDP 为纵坐标, 时间为横坐标构成直方图来呈现.")]),t._v(" "),s("li",[s("strong",[t._v("采样点分位图度量器")]),t._v("(Quantile Summary): 分位图是统计学中比较各"),s("strong",[t._v("分位数")]),t._v('的分布情况的工具, 用于验证实际值与理论值的差距, 评估理论值与实际值之间的拟合度. 譬如"高考成绩一般符合正态分布", 这句话的意思是: 高考成绩获得高分和低分的人数都较少, 获得中等成绩的较多, 将人数按不同分数段统计, 得出的统计结果一般能够与正态分布的曲线较好地拟合.')])]),t._v(" "),s("p",[t._v("除了以上常见的度量器之外, 还有 Timer, Set, Fast Compass, Cluster Histogram 等其他各种度量器, 不同的度量系统, 其支持度量器类型的范围肯定会有差别, 譬如 "),s("strong",[t._v("Prometheus")]),t._v(" 支持上面提到的五种度量器中的"),s("strong",[t._v("Counter, Gauge, Histogram 和 Summary")]),t._v(" 四种.")]),t._v(" "),s("p",[t._v('对于"'),s("strong",[t._v("如何将这些指标告诉服务端")]),t._v('"这个问题, 通常有两种解决方案: '),s("strong",[t._v("拉取式采集")]),t._v("(Pull-Based Metrics Collection)和"),s("strong",[t._v("推送式采集")]),t._v("(Push-Based Metrics Collection).")]),t._v(" "),s("p",[t._v("所谓"),s("strong",[t._v("拉取是指度量系统主动从目标系统中拉取指标, 相对地, 推送就是由目标系统主动向度量系统推送指标")]),t._v(". 这两种方式并没有绝对的好坏优劣, 以前很多老牌的度量系统, 如 Ganglia, Graphite, StatsD 等是基于推送式采集的, 而以 "),s("strong",[t._v("Prometheus")]),t._v(", Datadog, Collectd 为代表的另一派度量系统则青睐"),s("strong",[t._v("拉取式采集")]),t._v(". 关于采集方式的权衡, 不仅仅在度量中有, 所有涉及客户端和服务端通信的场景, 都会涉及该谁主动的问题, 之前讲的追踪系统也是如此.")]),t._v(" "),s("p",[t._v("一般来说, 度量系统只会支持"),s("strong",[t._v("其中一种指标采集方式, 因为度量系统的网络连接数量, 以及对应的线程或者协程数可能非常庞大, 如何采集指标将直接影响整个度量系统的架构设计")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("Prometheus 在基于拉取式采集架构的同时还能够有限度地兼容推送式采集")]),t._v(", 是因为它有 Push Gateway. 如下图所示, 这是一个位于 Prometheus Server 外部的相对独立的"),s("strong",[t._v("中介模块")]),t._v(", 将"),s("strong",[t._v("外部推送来的指标放到 Push Gateway 中暂存")]),t._v(", 然后再等候 Prometheus Server 从 Push Gateway 中去"),s("strong",[t._v("拉取")]),t._v(". Prometheus 设计 Push Gateway 的本意是"),s("strong",[t._v("解决拉取式采集的一些固有缺陷, 譬如目标系统位于内网, 通过 NAT 访问外网, 外网的 Prometheus 是无法主动连接目标系统的, 这就只能由目标系统主动推送数据; 又譬如某些小型短生命周期服务, 可能还等不及 Prometheus 来拉取, 服务就已经结束运行了, 因此也只能由服务自己推送来保证度量的及时和准确")]),t._v(".")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221231160848760.png",alt:"image-20221231160848760",title:"Prometheus组件流程图"}})]),t._v(" "),s("p",[t._v("在决定该谁主动以后, 另一个问题是"),s("strong",[t._v("指标应该以怎样的网络访问协议, 取数接口, 数据结构来获取")]),t._v('. 与计算机科学中其他这类的问题类似, 问题一贯的解决方向是"定义规范", 即由'),s("strong",[t._v("行业组织和主流厂商一起协商出专门用于度量的协议")]),t._v(", 让目标系统按照协议与度量系统交互. 譬如网络管理中的 SNMP, 以及 Java 的 JMX 都属于这种思路的产物. 但是, 定义标准这个办法在度量领域中不是那么有效, 上述列举的度量协议只在特定的一块小块领域上流行过. 原因一方面是业务系统要使用这些协议并不容易, 可以想象一下, 让订单金额存到 SNMP 中, 让基于 Golang 实现的系统把指标放到 JMX Bean 里, 即便技术上可行, 这也不像是正常程序员会干的事; 另一方面, 度量系统也不会甘心局限于某个领域, 成为某项业务的附属品. "),s("strong",[t._v("度量面向的是广义上的信息系统, 横跨存储(日志, 文件, 数据库), 通信(消息, 网络), 中间件(HTTP 服务, API 服务), 直到系统本身的业务指标, 甚至还会包括度量系统本身")]),t._v("(部署两个独立的 Prometheus 互相监控是很常见的). 所以上面这些度量协议其实"),s("strong",[t._v("都没有成为最正确答案的希望")]),t._v(".")]),t._v(" "),s("p",[t._v("鉴于没有了标准, 有一些度量系统, 譬如老牌的 Zabbix 就选择同时支持 SNMP, JMX, IPMI 等多种不同的度量协议, 还有一些度量系统, "),s("strong",[t._v("以 Prometheus 为代表就相对强硬, 选择不支持任何一种协议, 只允许通过HTTP访问度量端点这一种访问方式")]),t._v(". 如果目标提供了 HTTP 的度量端点(如 Kubernetes, etcd 等本身就带有 Prometheus 的Client Library)就直接访问, 否则就需要一个专门的 Exporter 来充当媒介.")]),t._v(" "),s("p",[s("strong",[t._v("Exporter 是 Prometheus 提出的概念, 它是目标应用的代表, 既可以独立运行, 也可以与应用运行在同一个进程中, 只要集成 Prometheus 的 Client Library 便可. Exporter 以 HTTP 协议返回符合 Prometheus 格式要求的文本数据给 Prometheus 服务器")]),t._v(".")]),t._v(" "),s("p",[t._v("得益于 Prometheus 的良好社区生态, 现在已经有大量各种用途的 Exporter, 使得 Prometheus 的监控范围几乎能涵盖所有用户关心的目标. 绝大多数用户都只需要针对自己系统业务方面的度量指标编写 Exporter 即可.")]),t._v(" "),s("p",[t._v("顺便提一下, 虽然前文提到了一堆没有希望成为最终正确答案的协议, 但是有一种名为 OpenMetrics 的度量规范正在从 Prometheus 的数据格式中逐渐分离出来, 有望成为监控数据格式的国际标准, 最终结果如何, 要取决于 Prometheus 本身的发展情况, 还有 OpenTelemetry 与 OpenMetrics 的关系如何协调.")]),t._v(" "),s("h5",{attrs:{id:"_2-存储查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-存储查询"}},[t._v("#")]),t._v(" 2.存储查询")]),t._v(" "),s("p",[s("strong",[t._v("指标")]),t._v("从目标系统采集过来之后, "),s("strong",[t._v("应存储在度量系统中")]),t._v(", 以便被后续的分析界面, 监控预警所使用. 存储数据对于计算机软件来说是司空见惯的操作, 但如果用传统关系数据库的思路来解决度量系统的存储, 效果可能不会太理想. 举个例子, 假设你建设一个中等规模的, 有 200 个节点的微服务系统, 每个节点要采集的存储, 网络, 中间件和业务等各种指标加一起, 也按 200 个来计算, 监控的频率如果按秒为单位的话, 一天内就会产生超过 "),s("strong",[t._v("34 亿条")]),t._v("记录:")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("200(节点)×200(指标)×86400(秒) = 3456000000(记录)\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("大多数这种 200 节点规模的系统, 本身一天的业务发生数据都远到不了 34 亿条, 如果要建设度量系统, 肯定不能让度量成为业务系统的负担, 可见度量的存储是需要专门研究, 解决的问题. 至于如何解决, 先来观察一段  Prometheus 的真实度量数据, 如下所示:")]),t._v(" "),s("div",{staticClass:"language-JSON line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 时间戳")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"timestamp"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1599117392")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指标名称")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"metric"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"total_website_visitors"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 标签组")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"tags"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"host"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"icyfenix.cn"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"job"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"prometheus"')]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指标值")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"value"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10086")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br")])]),s("p",[t._v("观察这段度量数据的特征: "),s("strong",[t._v("每一个度量指标由时间戳, 名称, 值和一组标签构成, 除了时间外, 指标不与任何其他因素相关")]),t._v(". 指标的数据总量固然不小, 但它"),s("strong",[t._v("没有嵌套, 没有关联, 没有主外键, 不必关心范式和事务")]),t._v(', 这些都是可以针对性优化的地方. 事实上, 业界早已存在专门针对该类型数据的数据库了, 即"'),s("strong",[t._v("时序数据库")]),t._v('"(Time Series Database).')]),t._v(" "),s("p",[s("strong",[t._v("时序数据库用于存储跟随时间而变化的数据, 并且以时间(时间点或者时间区间)来建立索引的数据库.")]),t._v("  时序数据库最早是应用于工业(电力行业, 化工行业)应用的各类型实时监测, 检查与分析设备所采集, 产生的数据, 这些工业数据的典型特点是产生频率快(每一个监测点一秒钟内可产生多条数据), 严重依赖于采集时间(每一条数据均要求对应唯一的时间), 测点多信息量大(常规的实时监测系统均可达到成千上万的监测点, 监测点每秒钟都在产生数据). "),s("strong",[t._v("时间序列数据是历史烙印, 具有不变性, 唯一性, 有序性. 时序数据库同时具有数据结构简单, 数据量大的特点")]),t._v(".")]),t._v(" "),s("p",[t._v("Facebook 有研究表明 85% 的度量指标查询都与"),s("strong",[t._v("最近 26 个小时")]),t._v("的数据写入有关, 95% 以上时序操作是写操作, 时序数据通常只是追加, 很少删改或者根本不允许删改. "),s("strong",[t._v("针对数据热点只集中在近期数据, 多写少读, 几乎不删改, 数据只顺序追加这些特点, 时序数据库被允许做出很激进的存储, 访问和保留策略(Retention Policy")]),t._v("):")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("以日志结构的合并树")]),t._v("(Log Structured Merge Tree, LSM-Tree)代替传统关系型数据库中的 B+ 树作为存储结构, "),s("strong",[t._v("LSM 适合的应用场景就是写多读少, 且几乎不删改的数据")]),t._v(".")]),t._v(" "),s("li",[t._v("设置激进的数据保留策略, 譬如"),s("strong",[t._v("根据过期时间(TTL)自动删除相关数据以节省存储空间")]),t._v(", 同时提高查询性能. 对于普通数据库来说, 数据会存储一段时间后就被自动删除这种事情是不可想象的. 比如数据保留 3 个月后删除.")]),t._v(" "),s("li",[t._v("对数据进行"),s("strong",[t._v("再采样")]),t._v("(Resampling)以节省空间, 譬如最近几天的数据可能需要精确到秒, 而查询一个月前的数据时, 只需要精确到天, 查询一年前的数据时, 只要精确到周就够了, 这样将"),s("strong",[t._v("数据重新采样汇总")]),t._v("就可以极大节省存储空间.")])]),t._v(" "),s("p",[t._v("时序数据库中甚至还有一种不罕见却更加极端的形式, 叫作"),s("strong",[t._v("轮替型数据库")]),t._v("(Round Robin Database, RRD), 以环形缓冲的思路实现, 只能存储"),s("strong",[t._v("固定数量")]),t._v("的最新数据, 超期或超过容量的数据就会被轮替覆盖, 因此虽然它有固定的数据库容量, 却能接收无限量的数据输入.")]),t._v(" "),s("p",[t._v("Prometheus 服务端内置了一个强大的"),s("strong",[t._v("时序数据库")]),t._v('实现, "强大"并非客气, 近几年它在 DB-Engines 的排名中不断提升, 目前已经跃居时序数据库排行榜的前三. 该时序数据库提供了名为 '),s("strong",[t._v("PromQL 的数据查询语言, 能对时序数据进行丰富的查询, 聚合以及逻辑运算")]),t._v(". 某些时序库(如排名第一的 InfluxDB)也会提供类 SQL 风格查询, 但 PromQL 不是, 它是一套完全由 Prometheus 自己"),s("strong",[t._v("定制的数据查询 DSL")]),t._v(', 写起来风格有点像带运算与函数支持的 CSS 选择器. 譬如要查找网站 "icyfenix.cn" 的访问人数, 会是如下写法:')]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 查询命令: ")]),t._v("\ntotal_website_visitors"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("host"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"icyfenix.cn"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回结果: ")]),t._v("\ntotal_website_visitors"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("host"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"icyfenix.cn"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("job"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"prometheus"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10086")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("通过 PromQL 可以轻易实现"),s("strong",[t._v("指标之间的运算, 聚合, 统计")]),t._v("等操作, 在查询界面中往往需要通过 PromQL 计算多种指标的统计结果才能满足监控的需要.")]),t._v(" "),s("p",[t._v("最后补充说明一下, 时序数据库对度量系统来说是很合适的选择, 但并不是说只有时序数据库才能解决度量指标的存储问题, Prometheus 流行之前最老牌的度量系统 Zabbix 就是用传统关系数据库来存储指标.")]),t._v(" "),s("h5",{attrs:{id:"_3-监控预警"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-监控预警"}},[t._v("#")]),t._v(" 3.监控预警")]),t._v(" "),s("p",[s("strong",[t._v("指标度量是手段, 最终目的是做分析和预警")]),t._v(". 界面分析和监控预警是与用户更加贴近的功能模块, 但对度量系统本身而言, 它们都属于相对外围的功能. 与追踪系统的情况类似, 广义上的度量系统由面向目标系统进行指标采集的客户端(Client, 与目标系统进程在一起的 Agent, 或者代表目标系统的 Exporter 等都可归为客户端), 负责调度, 存储和提供查询能力的服务端(Server, Prometheus 的服务端是有存储功能的, 但也有很多度量服务端需要配合独立的存储来使用), 以及面向最终用户的终端(Backend, UI 界面, 监控预警功能等都归为终端)组成. 狭义的度量系统就只包括客户端和服务端, 不包含终端.")]),t._v(" "),s("p",[t._v('按照定义, Prometheus 应算是处于狭义和广义的度量系统之间, 尽管它确实内置了一个界面解决方案 "Console Template", 以模板和 JavaScript 接口的形式提供了一系列预设的组件(菜单, 图表等), 让用户编写一段简单的脚本就可以实现可用的监控功能. 不过这种可用程度, 往往不足以支撑正规的生产部署, 只能说是为把度量功能嵌入系统的某个子系统提供了一定便利. 在'),s("strong",[t._v("生产环境下, 大多是 Prometheus 配合 Grafana 来进行展示的, 这是 Prometheus 官方推荐的组合方案")]),t._v(", 但该组合也并非唯一选择, 如果要搭配 Kibana 甚至 SkyWalking(8.x版之后的 SkyWalking 支持从 Prometheus 获取度量数据)来使用也都是完全可行的.")]),t._v(" "),s("p",[t._v("良好的"),s("strong",[t._v("可视化能力")]),t._v("对于提升度量系统的产品力十分重要, "),s("strong",[t._v("长期趋势分析")]),t._v("(譬如根据对磁盘增长趋势的观察判断什么时候需要扩容), "),s("strong",[t._v("对照分析")]),t._v("(譬如版本升级后对比新旧版本的性能, 资源消耗等方面的差异), "),s("strong",[t._v("故障分析")]),t._v("(不仅可以从日志, 追踪指标自底向上分析故障, 而且可以从高维度的度量指标自顶向下寻找问题的端倪)等分析工作, 既需要度量指标的持续收集, 统计, 往往还需要对数据进行可视化, 才能让人更容易地从数据中挖掘规律, 毕竟数据最终还是要为人类服务的.")]),t._v(" "),s("p",[t._v("除了为分析, 决策, 故障定位等提供支持的用户界面外, 度量信息的另外一种主要的消费途径是预警. 譬如你希望当磁盘消耗超过 90% 时向你发送一封邮件或者一条微信消息, 通知管理员过来处理, 这就是一种预警. "),s("strong",[t._v("Prometheus 提供了专门用于预警的 Alert Manager, 将 Alert Manager 与 Prometheus 关联后, 可以设置某个指标在多长时间内达到何种条件就会触发预警状态, 触发预警后, 根据路由中配置的接收器, 譬如邮件接收器,  Slack 接收器, 微信接收器, 或者更通用的 WebHook 接收器等来自动通知用户")]),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"虚拟化容器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟化容器"}},[t._v("#")]),t._v(" 虚拟化容器")]),t._v(" "),s("p",[t._v("容器是云计算, 微服务等诸多软件行业核心技术的共同基石. "),s("strong",[t._v("容器的首要目标是让软件分发部署过程从传统的发布安装包, 靠人工部署转变为直接发布已经部署好的, 包含整套运行环境的虚拟化镜像")]),t._v(". 在容器技术成熟之前, 主流的软件部署过程是由系统管理员编译或下载好二进制安装包, 根据软件的部署说明文档准备好正确的操作系统, 第三方库, 配置文件, 资源权限等各种前置依赖以后, 才能将程序正确地运行起来.")]),t._v(" "),s("p",[t._v('让软件能够在任何环境, 任何物理机器上达到 "一次编译, 到处运行" 曾是 Java 早年的宣传口号, 这并不是一个简单的目标, 不设前提的"到处运行", 仅靠 Java 语言和 Java 虚拟机是不可能达成的, 因为一个计算机软件要能够正确运行, 需要有以下'),s("strong",[t._v("三方面的兼容性来共同保障")]),t._v('(这里仅讨论软件兼容性, 不涉及"如果没有摄像头就无法运行照相程序"这类问题).')]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("ISA 兼容")]),t._v(": 目标机器指令集的兼容性, 譬如 ARM 架构的计算机无法直接运行面向 x86 架构编译的程序.")]),t._v(" "),s("li",[s("strong",[t._v("ABI 兼容")]),t._v(": 目标系统或者依赖库的二进制兼容性, 譬如 Windows 系统环境中无法直接运行 Linux 的程序.")]),t._v(" "),s("li",[s("strong",[t._v("环境兼容")]),t._v(": 目标环境的兼容性, 譬如没有正确设置的配置文件, 环境变量, 注册中心, 数据库地址, 文件系统的权限等, 任何一个环境因素出现错误, 都会让程序无法正常运行.")])]),t._v(" "),s("p",[s("strong",[t._v("ISA")]),t._v("(Instruction Set Architecture, 指令集架构)是计算机体系结构中与程序设计相关的部分, 包含基本数据类型, 指令集, 寄存器, 寻址模式, 存储体系, 中断, 异常处理以及外部I/O. 指令集架构包含一系列操作码(即通常所说的机器语言)以及由特定处理器执行的基本命令.")]),t._v(" "),s("p",[s("strong",[t._v("ABI")]),t._v("(Application Binary Interface, 应用二进制接口)是应用程序与操作系统之间或其他依赖库之间的低级接口. ABI 涵盖了各种底层细节, 如数据类型的宽度大小, 对象的布局, 接口调用约定等. ABI 不同于 API, API 定义的是源代码和库之间的接口, 因此同样的代码可以在支持这个 API 的任何系统中编译, 而 ABI 允许编译好的目标代码在使用兼容 ABI 的系统中直接运行, 无须任何改动.")]),t._v(" "),s("p",[t._v("这里把使用"),s("strong",[t._v("仿真(Emulation)以及虚拟化")]),t._v("(Virtualization)技术来"),s("strong",[t._v("解决以上三项兼容性问题的方法")]),t._v("都统称为"),s("strong",[t._v("虚拟化技术")]),t._v(". 根据"),s("strong",[t._v("抽象目标与兼容性高低的不同, 虚拟化技术又分为下列五类")]),t._v(".")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("指令集虚拟化")]),t._v("(ISA Level Virtualization). 通过软件来模拟不同 ISA 架构的处理器的工作过程, 将虚拟机发出的指令转换为符合本机 ISA 的指令, 典型代表为 QEMU 和 Bochs. 其实指令集虚拟化就是"),s("strong",[t._v("仿真")]),t._v(", 它能提供几乎完全不受局限的兼容性, 甚至能做到直接在 Web 浏览器上运行完整操作系统这种令人惊讶的效果, 但由于"),s("strong",[t._v("每条指令都要由软件来转换和模拟, 所以也是性能损失最大的虚拟化技术")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("硬件抽象层虚拟化")]),t._v("(Hardware Abstraction Level Virtualization). 以"),s("strong",[t._v("软件或者直接通过硬件来模拟处理器, 芯片组, 内存, 磁盘控制器, 显卡等设备的工作过程")]),t._v(". 既可以使用纯软件的二进制翻译来模拟虚拟设备, 也可以由硬件的 Intel VT-d, AMD-Vi 这类虚拟化技术, 将某个物理设备直通(Passthrough)到虚拟机中使用, 典型代表为 "),s("strong",[t._v("VMware")]),t._v(' ESXi 和 Hyper-V. 如果没有预设语境, 一般人们所说的"'),s("strong",[t._v("虚拟机")]),t._v('"就是指这一类虚拟化技术.')]),t._v(" "),s("li",[s("strong",[t._v("操作系统层虚拟化")]),t._v("(OS Level Virtualization). 无论是指令集虚拟化还是硬件抽象层虚拟化, 都会运行一套"),s("strong",[t._v("完全真实的操作系统")]),t._v("来解决 ABI 兼容性和环境兼容性问题. 虽然 ISA 兼容性是虚拟出来的, 但 ABI 兼容性和环境兼容性却是"),s("strong",[t._v("真实存在")]),t._v("的. "),s("strong",[t._v("操作系统层虚拟化不会提供真实的操作系统, 而是采用隔离手段, 使得不同进程拥有独立的系统资源和资源配额, 看起来仿佛是独享了整个操作系统, 但其实系统的内核仍然是被不同进程所共享的")]),t._v('. 操作系统层虚拟化的另一个名字就是这部分的主角"'),s("strong",[t._v("容器化")]),t._v('"(Containerization), 由此可见, '),s("strong",[t._v("容器化仅仅是虚拟化的一个子集, 只能提供操作系统内核以上的部分 ABI 兼容性与完整的环境兼容性")]),t._v(". 这意味着如果没有其他虚拟化手段的辅助, 在 Windows 系统上是不可能运行 Linux 的 Docker 镜像的(现在可以是因为有其他虚拟机或者 WSL2 的支持), 反之亦然. 同时也决定了如果 Docker 宿主机的内核版本是 Linux Kernel 5.6, 那无论上面运行的镜像是 Ubuntu, RHEL, Fedora, Mint 还是任何发行版的镜像, 看到的内核一定都是"),s("strong",[t._v("相同的")]),t._v(" Linux Kernel 5.6. "),s("strong",[t._v("容器化牺牲了一定的隔离性与兼容性, 换来的是比前两种虚拟化更高的启动速度, 运行性能和更低的执行负担")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("运行库层虚拟化")]),t._v("(Library Level Virtualization). 与操作系统层虚拟化采用隔离手段来模拟系统不同, 运行库层虚拟化选择使用"),s("strong",[t._v("软件翻译的方法来模拟系统")]),t._v(", 它以一个独立进程来可代替操作系统内核, 可提供目标软件运行所需的全部能力. 这种虚拟化方法获得的 ABI 兼容性高低, 取决于软件是否能够准确和全面地完成翻译工作, 典型代表为 WINE(Wine Is Not an Emulator 的缩写, 一款在 Linux 下运行 Windows 程序的软件)和 WSL(特指 Windows Subsystem for Linux Version 1).")]),t._v(" "),s("li",[s("strong",[t._v("语言层虚拟化")]),t._v("(Programming Language Level Virtualization). 由"),s("strong",[t._v("虚拟机将高级语言生成的中间代码转换为目标机器可以直接执行的指令")]),t._v(", 典型代表为 Java 的 JVM 和 .NET 的 CLR. 虽然厂商肯定会提供在不同系统下都有相同接口的标准库, 但本质上这种虚拟化并"),s("strong",[t._v("不直接解决")]),t._v("任何 ABI 兼容性和环境兼容性问题.")])]),t._v(" "),s("h4",{attrs:{id:"容器的崛起"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器的崛起"}},[t._v("#")]),t._v(" 容器的崛起")]),t._v(" "),s("p",[t._v("设计容器的最初目的不是部署软件, 而是"),s("strong",[t._v("隔离计算机中的各类资源, 以便降低软件开发")]),t._v(", 测试阶段可能产生的误操作风险, 或者专门充当蜜罐, 吸引黑客的攻击, 以便监视黑客的行为. 下面将以容器发展历史为线索, 介绍容器技术在不同历史阶段中的主要关注点.")]),t._v(" "),s("h5",{attrs:{id:"_1-隔离文件-chroot"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-隔离文件-chroot"}},[t._v("#")]),t._v(" 1.隔离文件:chroot")]),t._v(" "),s("p",[t._v('容器的起点可以追溯到 1979 年 UNIX 7 系统中提供的 chroot 命令, 这个命令是英文单词 "Change Root" 的缩写, 功能是当某个进程经过 chroot 操作之后, 它的'),s("strong",[t._v("根目录就会被锁定在命令参数所指定的位置, 以后它或者它的子进程将不能再访问和操作该目录之外的其他文件")]),t._v(".")]),t._v(" "),s("p",[t._v('1991 年, 世界上第一个监控黑客行动的蜜罐程序就是使用 chroot 来实现的, 命令参数指定的根目录当时被作者戏称为 "Chroot监狱"(Chroot Jail), 而黑客突破 chroot 限制的方法被称为"越狱"(Jailbreak). 后来, FreeBSD 4.0 系统重新实现了 chroot 命令, 用它作为'),s("strong",[t._v("系统中进程沙箱隔离的基础")]),t._v(', 并将其命名为 FreeBSD Jail. 再后来, 苹果公司又以 FreeBSD 为基础研发出了举世闻名的 iOS 操作系统. 此后, 黑客们就将绕过 iOS 沙箱机制以 root 权限任意安装程序的方法称为"越狱".')]),t._v(" "),s("p",[t._v("2000 年, Linux Kernel 2.3.41 引入了 "),s("strong",[t._v("pivot_root 技术来实现文件隔离, pivot_root 直接切换了根文件系统(rootfs)")]),t._v(" , 有效地避免了 chroot 命令可能出现的安全性漏洞. 本文后续提到的容器技术, 如 "),s("strong",[t._v("LXC, Docker 等也都是优先使用 pivot_root 来实现根文件系统切换的")]),t._v(".")]),t._v(" "),s("p",[t._v("时至今日, chroot 命令依然活跃在 UNIX 系统及几乎所有主流的 Linux 发行版中, 同时以命令行工具(chroot(8))或者系统调用(chroot(2))的形式存在, 但无论是 chroot 命令还是 pivot_root, 都"),s("strong",[t._v("不能提供完美的隔离性")]),t._v(". 原本按照 UNIX 的设计哲学, 一切资源都可以视为文件, 一切处理都可以视为对文件的操作, 理论上, 只要隔离了文件系统, 一切资源都应该被自动隔离才对. 可是哲学归哲学, 现实归现实, 从硬件层面暴露的低层次资源, 如磁盘, 网络, 内存, 处理器, 到经操作系统层面封装的高层次资源, 如 UNIX 分时(UNIX Time-Sharing, UTS), 进程 ID(Process ID, PID), 用户 ID(User ID, UID), 进程间通信(Inter-Process Communication, IPC), "),s("strong",[t._v("都存在大量以非文件形式暴露的操作入口")]),t._v(". 因此, 以 chroot 为代表的文件隔离, 仅仅是容器崛起之路的"),s("strong",[t._v("起点")]),t._v("而已.")]),t._v(" "),s("h5",{attrs:{id:"_2-隔离访问-名称空间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-隔离访问-名称空间"}},[t._v("#")]),t._v(" 2.隔离访问:名称空间")]),t._v(" "),s("p",[t._v("2002 年, Linux Kernel 2.4.19 引入了一种全新的隔离机制: "),s("strong",[t._v("Linux 名称空间")]),t._v("(Linux Namespace). 名称空间的概念在很多现代的高级程序语言中都存在, 用于避免不同开发者提供的 API 相互冲突.")]),t._v(" "),s("p",[s("strong",[t._v("Linux 的名称空间是一种由内核直接提供的全局资源封装, 是内核针对进程设计的访问隔离机制")]),t._v(". 进程在一个独立的 Linux 名称空间中朝系统看去, 会觉得自己仿佛就是这方天地的主人, 拥有这台 Linux 主机上的一切资源, 不仅"),s("strong",[t._v("文件系统是独立的, 还有着独立的 PID 编号(譬如拥有自己的 0 号进程, 即系统初始化的进程), UID/GID 编号(譬如拥有自己独立的 root 用户), 网络(譬如完全独立的 IP 地址, 网络栈, 防火墙等设置)")]),t._v(" , 等等, 此时进程的心情简直不能再好了.")]),t._v(" "),s("p",[t._v("Linux 的名称空间最初依然只是为了隔离文件系统, 而非为了容器化的实现. 后来, 要求"),s("strong",[t._v("系统隔离其他访问操作")]),t._v("的呼声越来越高, 从 2006 年起, Linux 内核陆续添加了 UTS, IPC 等名称空间的隔离, 直到 Linux Kernel 5.6 为止, Linux 名称空间支持以下八种资源的隔离(内核的官网 kernel.org 上仍然只列出了前六种, 从 Linux 的 man 命令能查到全部八种), 如下表所示.")]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("Linux名称空间支持八种资源的隔离")])])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("名称空间")]),t._v(" "),s("th",[t._v("隔离内容")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("Mount")]),t._v(" "),s("td",[t._v("隔离文件系统, 功能上大致可以类别 chroot")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("UTS")]),t._v(" "),s("td",[t._v("隔离主机的 Hostname, Domain name")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("IPC")]),t._v(" "),s("td",[t._v("隔离进程间通信的渠道")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("PID")]),t._v(" "),s("td",[t._v("隔离进程编号, 无法看到其他名称空间中的 PID, 意味着无法对其他进程产生影响")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("Network")]),t._v(" "),s("td",[t._v("隔离网络资源, 如网卡, 网络栈, IP 地址, 端口等")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("User")]),t._v(" "),s("td",[t._v("隔离用户和用户组")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("Cgroup")]),t._v(" "),s("td",[t._v("隔离 cgroups 信息, 进程有自己的 cgroups 的根目录视图(在 /proc/self/cgroup不会看到整个系统的信息)")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("Time")]),t._v(" "),s("td",[t._v("隔离系统时间")])])])]),t._v(" "),s("p",[t._v("如今, 对文件, 进程, 用户, 网络等各类信息的访问, 都被囊括在 Linux 的名称空间中, 即使一些今天仍没有被隔离的访问(譬如 syslog 就还没被隔离, 容器内可以看到容器外其他进程产生的内核 syslog), 日后也可以随内核版本的更新纳入这套框架中. 现在距离完美的隔离性就只差最后一步了: "),s("strong",[t._v("资源的隔离")]),t._v(".")]),t._v(" "),s("h5",{attrs:{id:"_3-隔离资源-cgroups"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-隔离资源-cgroups"}},[t._v("#")]),t._v(" 3.隔离资源: cgroups")]),t._v(" "),s("p",[t._v("如果要让一台物理计算机中的"),s("strong",[t._v("各个进程")]),t._v("看起来像独享整台虚拟计算机, 不仅要隔离各自进程的访问操作, 还必须能"),s("strong",[t._v("独立控制分配给各个进程的资源使用配额")]),t._v(", 不然一个进程发生了内存溢出或者占满了处理器, 其他进程就莫名其妙地被牵连挂起, 这样肯定算不上完美的隔离.")]),t._v(" "),s("p",[t._v("Linux 系统解决以上问题的方案是"),s("strong",[t._v("控制群组(Control Groups, 常简写为 cgroups)")]),t._v(" . 它与名称空间一样都是"),s("strong",[t._v("直接由内核提供功能, 用于隔离或者分配并限制某个进程组能够使用的资源配额, 资源配额包括处理器时间, 内存大小, 磁盘I/O速度等")]),t._v(".")]),t._v(" "),s("p",[t._v('cgroups 项目最早是由 Google 发起, 当时取的名字就叫作"'),s("strong",[t._v("进程容器")]),t._v('"(Process Container), 不过"容器"这个名词的定义在那时候尚不如今天清晰, 在不同场景中常有不同的含义, 为避免混乱, 后来这个项目才被重命名为 cgroups, 并在 2008 年合并到 2.6.24 版内核后正式对外发布, 这一阶段的 cgroups 被称为"第一代 cgroups". 2016 年 3 月发布的 Linux Kernel 4.5 版本中, 搭载了由 Facebook 重新编写的"第二代 cgroups", 其关键改进是支持统一层级管理(Unified Hierarchy), 使得管理员能更加清晰, 精确地控制资源的层级关系. 目前这两个版本的 cgroups 在 Linux 内核代码中是并存的, Docker 暂时仅支持第一代 cgroups.')]),t._v(" "),s("h5",{attrs:{id:"_4-封装系统-lxc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-封装系统-lxc"}},[t._v("#")]),t._v(" 4.封装系统:LXC")]),t._v(" "),s("p",[t._v("当"),s("strong",[t._v("文件系统, 访问, 资源都可以被隔离")]),t._v("后, 容器已经有了降生所需的全部前置条件, 并且 Linux 的开发者们也已经明确地看到了这一点. 为降低普通用户综合使用 namespaces, cgroups 这些低级特性的门槛, 2008 年 Linux Kernel 2.6.24 刚刚开始提供 cgroups 的同一时间, 就又马上发布了名为 Linux 容器(LinuX Container, LXC) 的系统级虚拟化功能.")]),t._v(" "),s("p",[t._v("LXC 眼中的容器与 OpenVZ 和 Linux-VServer 定义的并无差别, 是一种"),s("strong",[t._v("封装系统的轻量级虚拟机")]),t._v(", 而 Docker 眼中的容器则是"),s("strong",[t._v("一种封装应用")]),t._v("的技术手段. 这两种封装理念在技术层面并没有什么本质区别, 但应用效果差异巨大. 举个具体例子, 如果你要建设一个 LAMP(Linux, Apache, MySQL, PHP)应用, 按照 LXC 的思路, 应该先编写或者寻找到 LAMP 的 template(可以暂且不准确地类比为 LXC 版本的 Dockerfile 吧), 以此构造出一个安装了 LAMP 的虚拟系统. 如果从部署虚拟机的角度来看, 这还挺方便的, 作为那个时代(距今也就十年)的系统管理员, 所有软件, 补丁, 配置都是自己搞定的, 部署一台新虚拟机要花费一两天时间很正常, 而有了 LXC 的 template, 一下子都可以装好. 但作为一名现代的系统管理员, 这里的问题就相当大了, 如果想把 LAMP 改为 LNMP(Linux, Nginx, MySQL, PHP), 该怎么办? 如果想把 LAMP 里的 MySQL5 调整为 MySQL8, 该怎么办? 此时只能寻找或者自己编写新的 template 来解决. 但是这台虚拟机的软件, 版本都配置对了, 下一台要构建 LYME 或者 MEAN, 又该怎么办? 以封装系统为出发点, 仍是按照先装系统再装软件的思路, 就永远无法在一两分钟甚至十几秒钟就构造出一个合乎要求的软件运行环境, 也"),s("strong",[t._v("决定了 LXC 不可能形成今天的容器生态")]),t._v(", 所以, 接下来重点到了 Docker 身上.")]),t._v(" "),s("h5",{attrs:{id:"_5-封装应用-docker"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-封装应用-docker"}},[t._v("#")]),t._v(" 5.封装应用:Docker")]),t._v(" "),s("p",[t._v("2013 年宣布开源的 Docker 毫无疑问是容器发展历史上里程碑式的发明, 然而 Docker 的成功似乎没有太多技术驱动的成分. 至少对早期的 Docker 而言, 确实没有什么能构成壁垒的技术, 它的容器化能力"),s("strong",[t._v("直接来源于 LXC")]),t._v(", 它的镜像分层组合的文件系统直接来源于 AUFS.")]),t._v(" "),s("p",[t._v("那为何历史选择了 Docker, 而不是 LXC 或者其他容器技术呢? 对于这个问题, 这里引用 DotCloud 公司创始人 Solomon Hykes 在 Stackoverflow 上的一段问答来回应为什么要用 Docker 而不是 LXC?")]),t._v(" "),s("p",[t._v("Docker 除了包装来自 Linux 内核的特性之外, 它的价值还体现在如下几点上:")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("跨机器的绿色部署")]),t._v(": Docker 定义了一种将应用及其所有的环境依赖都打包到一起的格式, 仿佛它原本就是绿色软件一样. 而 LXC 并没有提供这样的能力, 使用 LXC 部署的新机器的很多细节都需要人的介入, 部署后虚拟机的环境几乎肯定会跟原本部署程序的机器有所差别.")]),t._v(" "),s("li",[s("strong",[t._v("以应用为中心的封装")]),t._v(": Docker "),s("strong",[t._v("封装应用")]),t._v("而非封装机器的理念贯穿了它的设计, API, 界面, 文档等多个方面. 相比之下, LXC 将容器视为对系统的封装, 这限制了容器的发展.")]),t._v(" "),s("li",[s("strong",[t._v("自动构建")]),t._v(": Docker 提供了开发人员在容器中构建产品的全部支持, 使得开发人员无须关注目标机器的具体配置即可使用任意的构建工具链在容器中自动构建出最终产品.")]),t._v(" "),s("li",[s("strong",[t._v("多版本支持")]),t._v(": Docker 支持像 Git 一样管理容器的连续版本, 进行检查版本间差异, 提交或者回滚等操作. 从历史记录中可以看到该容器是如何一步一步构建成的, 并且只增量上传或下载新版本中变更的部分.")]),t._v(" "),s("li",[s("strong",[t._v("组件重用")]),t._v(": Docker 允许将任何现有容器作为基础镜像来使用, 以此构建出更加专业的镜像.")]),t._v(" "),s("li",[s("strong",[t._v("共享")]),t._v(": Docker 拥有公共的镜像仓库, 成千上万的 Docker 用户可以在上面上传自己的镜像, 同时也可以使用他人上传的镜像.")]),t._v(" "),s("li",[s("strong",[t._v("工具生态")]),t._v(": Docker 开放了一套可自动化和自行扩展的接口, 在此之上还有很多工具来扩展其功能, 譬如容器编排, 管理界面, 持续集成等.")])]),t._v(" "),s("p",[t._v("以上这段回答也同时被收录到 Docker 官网的 FAQ 上, 从 Docker 开源至今从未改变. 促使 Docker 一问世就惊艳世间的, "),s("strong",[t._v("不是什么黑科技式的秘密武器, 而是其符合历史潮流的创意与设计理念, 以及充分开放的生态运营")]),t._v(". 可见, 在正确的时候, 正确的人手上有一个优秀的点子, 确实有机会引爆一个时代.")]),t._v(" "),s("p",[t._v("从开源到现在也只过了短短数年时间, Docker 已成为软件开发, 测试, 分发, 部署等各个环节都难以或缺的基础支撑, 自身的架构也发生了相当大的改变, 被分解为由 Docker Client, Docker Daemon, Docker Registry, Docker Container 等子系统, 以及 Graph, Driver, libcontainer 等各司其职的"),s("strong",[t._v("模块")]),t._v("组成, 此时再说Docker 没有太高的技术含量, 就不再合适了.")]),t._v(" "),s("p",[t._v("2014 年, Docker 开源了自己用 Go 语言开发的 libcontainer. 这是一个"),s("strong",[t._v("越过 LXC 直接操作 namespaces 和 cgroups 的核心模块, 它使得 Docker 能直接与系统内核打交道, 而不必依赖 LXC 来提供容器化隔离能力")]),t._v(".")]),t._v(" "),s("p",[t._v('2015 年, 在 Docker 的主导和倡议下, 多家公司联合制定了"'),s("strong",[t._v("开放容器交互标准")]),t._v('"(Open Container Initiative, OCI), 这是一个关于'),s("strong",[t._v("容器格式和运行时的规范文件")]),t._v(", 其中包含运行时标准(runtime-spec), 容器镜像标准(image-spec)和镜像分发标准(distribution-spec, 此标准还未正式发布). 运行时标准定义了应该如何运行一个容器, 如何管理容器的状态和生命周期, 如何使用操作系统的底层特性(namespaces, cgroups, pivot_root 等); "),s("strong",[t._v("容器镜像标准规定了容器镜像的格式, 配置, 元数据的格式, 可以理解为对镜像的静态描述; 镜像分发标准则规定了镜像推送和拉取的网络交互过程")]),t._v(".")]),t._v(" "),s("p",[t._v('为了符合 OCI 标准, Docker 推动自身的架构继续向前演进, 首先将 libcontainer 独立出来, 封装重构成 runC 项目, 并捐献给 Linux 基金会管理. runC 是 OCI 运行时的首个参考实现, 提出了 "让标准容器无所不在" 的口号. 为了能够兼容所有符合标准的 OCI 运行时实现, Docker 进一步重构了 Docker Daemon 子系统, 将其中与运行时交互的部分抽象为 containerd 项目, 这是一个负责管理容器执行, 分发, 监控, 网络, 构建, 日志等功能的核心模块, 内部会为每个容器运行时创建一个 containerd-shim 适配进程, 默认与 runC 搭配工作, 但也可以切换到其他 OCI 运行时实现上(然而实际并没做到, 最后 containerd 仍是紧密绑定于 runC). 2016 年, Docker 把 containerd 项目捐献给 CNCF 管理. runC 与 containerd 两个项目的捐赠托管, 既是 Docker 对开源信念执着的追求, 也是 Docker 在众多云计算大厂夹击下无奈的自救, 这两个项目将成为未来 Docker 消亡和存续的伏笔. Docker, containerd 和 runC 的交互关系如下图所示.')]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230101195814041-2574296.png",alt:"",title:"Docker Containerd和runC的交互关系"}})]),t._v(" "),s("p",[t._v("以上列举的这些 Docker 推动的开源与标准化工作, 既是对 Docker 为开源乃至整个软件业做出贡献的赞赏, 又是为后面介绍容器编排时讲述当前容器引擎的"),s("strong",[t._v("混乱关系")]),t._v("做的铺垫. "),s("strong",[t._v("Docker 目前无疑在容器领域具有统治地位")]),t._v(", 但统治的稳固程度不仅没到高枕无忧, 说是危机四伏都不为过. 目前已经有可见的, 足以威胁 Docker 地位的潜在可能性正在酝酿, 这是源于"),s("strong",[t._v("虽然 Docker 赢得了容器战争, 但 Docker Swarm 却输掉了容器编排战争")]),t._v(". 从结果回望当初,  Docker 赢得容器战争有一些偶然, Docker Swarm 输掉的容器编排战争却是必然的.")]),t._v(" "),s("h5",{attrs:{id:"_6-封装集群-kubernetes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-封装集群-kubernetes"}},[t._v("#")]),t._v(" 6.封装集群:Kubernetes")]),t._v(" "),s("p",[t._v("如果说以 Docker 为代表的容器引擎是将软件的发布流程从分发二进制安装包转变为直接分发虚拟化后的整个运行环境, 令应用得以实现跨机器的绿色部署, 那"),s("strong",[t._v("以 Kubernetes 为代表的容器编排框架就是把大型软件系统运行所依赖的集群环境也进行了虚拟化, 令集群得以实现跨数据中心的绿色部署, 并能够根据实际情况自动扩缩")]),t._v(".")]),t._v(" "),s("p",[t._v("容器的崛起之路讲到 Docker 和 Kubernetes 这个阶段, 已经不再是介绍历史了, 从这里开始发生的变化都是近几年软件行业中的热点事件, 也是本章要讨论的主要话题. 本节首先从宏观层面去理解 Kubernetes 的诞生与演变的驱动力, 这对正确理解未来"),s("strong",[t._v("云原生")]),t._v("的发展方向至关重要.")]),t._v(" "),s("p",[t._v('Kubernetes 可谓出身名门, 前身是 Google 内部已运行多年的集群管理系统 Borg, 于 2014 年 6 月使用 Go 语言完全重写后开源. 自 Kubernetes 诞生之日起, 只要与云计算稍微扯上关系的业界巨头都对 Kubernetes 争相追捧, IBM, Red Hat, Microsoft, VMware 和华为都是它最早期的代码贡献者. 此时, 云计算从实验室到工业化应用已经有十个年头, 然而大量应用使用云计算的方式仍停滞在传统 IDC(Internet Data Center, 网络数据中心)时代, 仅仅是用云端的虚拟机代替了传统的物理机. 尽管早在 2013 年, Pivotal(持有 Spring Framework 和 Cloud Foundry 的公司)就提出了"'),s("strong",[t._v("云原生")]),t._v('"的概念, 但是要实现服务化, 具备韧性(Resilience), 弹性(Elasticity), 可观测性(Observability)的软件系统十分困难, 在当时基本只能依靠架构师和程序员高超的个人能力, 云计算本身帮不上什么忙. 在云的时代不能充分利用云的强大能力, 这让云计算厂商无比遗憾, 也无比焦虑. 直到 Kubernetes 横空出世, 大家才等到了破局的希望, '),s("strong",[t._v("认准了这就是云原生时代的操作系统, 是让复杂软件在云计算下获得韧性, 弹性, 可观测性的最佳路径")]),t._v(", 也是让厂商们推动云计算时代加速到来的关键引擎之一.")]),t._v(" "),s("p",[t._v("2015 年 7 月, Kubernetes 发布了第一个正式版本 1.0 版, 同时 Google 宣布与 Linux 基金会共同筹建云原生基金会(CNCF), 并且将 Kubernetes 托管到 CNCF, 成为其第一个项目. 随后, Kubernetes 以摧枯拉朽之势打败了容器编排领域的其他竞争对手, 哪怕 Docker Swarm 有着 Docker 在容器引擎方面的先天优势, 甚至 DotCloud 后来将 Swarm 直接内置入 Docker 中, 都未能稍稍阻挡 Kubernetes 前进的步伐. Kubernetes 与容器引擎的调用关系如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230101201411759.png",alt:"image-20230101201411759",title:"Kubernetes与容器引擎的调用关系"}})]),t._v(" "),s("p",[t._v('Kubernetes 的成功与 Docker 的成功并不相同. Docker 靠的是优秀的理念, 以一个"好点子"引爆了一个时代. 而 Kubernetes 的成功不仅有 Google 深厚的技术功底作为支撑, 而且有领先时代的设计理念, 更加关键的是 Kubernetes 的出现'),s("strong",[t._v("符合所有云计算大厂的切身利益")]),t._v(", 有着业界巨头不遗余力的广泛支持, 所以它的成功是一种必然.")]),t._v(" "),s("p",[t._v("Kubernetes 与 Docker 的关系十分微妙, 把握住两者关系的变化过程, 是理解 Kubernetes 架构演变与 CRI, OCI 规范的良好线索. 在 Kubernetes 开源的早期, 它是完全依赖且绑定于 Docker 的, 并没有过多考虑日后有使用其他容器引擎的可能性. 直至 Kubernetes 1.5 版本之前, Kubernetes 管理容器的方式都是通过内部的 "),s("strong",[t._v("DockerManager")]),t._v(" 向 Docker Engine 以 HTTP 方式发送指令, 通过 Docker 来完成镜像的增删改查操作, 如上图最右边线路的箭头所示. (图中的 kubelet 是集群节点中的代理程序, 负责与管理集群的 Master 通信, 其他节点的含义将在后文介绍.)将这个阶段 Kubernetes 与容器引擎的调用关系捋直, 并结合上一节提到的 Docker 捐献 containerd 与 runC 项目后重构的调用, 完整的调用链如下所示:")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Kubernetes Master -> kubelet -> DockerManager -> Docker Engine -> containerd -> runC\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("2016 年, Kubernetes 1.5 版本开始引入"),s("strong",[t._v("容器运行时接口")]),t._v("(Container Runtime Interface, CRI), 这是一个定义容器运行时应该如何接入 kubelet 的规范标准, 从此 Kubernetes 内部的 DockerManager 就被更为通用的 "),s("strong",[t._v("KubeGenericRuntimeManager")]),t._v(" 所替代(实际上在 1.6.6 版本之前都仍然可以看到 DockerManager), kubelet 与 KubeGenericRuntimeManager 之间通过 "),s("strong",[t._v("gRPC")]),t._v(" 协议通信. 由于 CRI 是在 Docker 之后才发布的规范, Docker 是肯定不支持 CRI 的, 所以 Kubernetes 又提供了 DockerShim 服务作为 Docker 与 CRI 的适配层, 由它与 Docker Engine 以 HTTP 形式通信, 实现了原来 DockerManager 的全部功能. 此时, Docker 对Kubernetes 来说只是一项"),s("strong",[t._v("默认依赖, 而非之前的无可或缺")]),t._v("了, 它们的调用链为:")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Kubernetes Master -> kubelet -> KubeGenericRuntimeManager -> DockerShim -> Docker Engine -> containerd -> runC\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("2017 年, 由 Google, Red Hat, Intel, SUSE, IBM 联合发起的 "),s("strong",[t._v("CRI-O")]),t._v("(Container Runtime Interface Orchestrator)项目发布了首个正式版本. 从名字就可以看出, 一方面, 它肯定是完全遵循 CRI 规范实现的, 另一方面, 它可以支持所有符合 OCI 运行时标准的容器引擎, 默认仍然是与 runC 搭配工作, 若要换成 Clear Containers, Kata Containers 等其他 OCI 运行时引擎也完全没有问题. 虽然开源版 Kubernetes 是使用 CRI-O, cri-containerd 抑或是 DockerShim 作为 CRI 实现, 完全可以由用户自由选择(根据用户宿主机的环境选择), 但在 Red Hat 自己扩展定制的 Kubernetes 企业版, 即 OpenShift 4 中, 调用链中已经没有了 Docker Engine 的身影:")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Kubernetes Master -> kubelet -> KubeGenericRuntimeManager -> CRI-O -> runC\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("由于此时 Docker 在容器引擎中的市场份额仍然占有绝对优势, 对于普通用户来说, 如果没有明确的收益, 就没有什么动力把 Docker 换成别的引擎, 所以 CRI-O 即使摆出了直接挖掉 Docker 根基的凶悍姿势, 也并没有给 Docker 带来太多即时可见的影响, 不过能够想象此时 Docker 心中肯定充斥了难以言喻的危机感.")]),t._v(" "),s("p",[t._v("2018 年, 由 Docker 捐献给 CNCF 的 containerd 项目, 在 CNCF 的精心孵化下发布了 1.1 版. 1.1 版与 1.0 版的最大区别是此时它"),s("strong",[t._v("完美地支持了 CRI 标准")]),t._v(", 这意味着原本用作 CRI 适配器的 cri-containerd 从此不再需要. 此时, 再观察 Kubernetes 到容器运行时的调用链, 你会发现调用步骤会比通过 DockerShim, Docker Engine 与 containerd 交互的步骤减少两步, 这又意味着"),s("strong",[t._v("用户只要愿意抛弃 Docker, 在容器编排上便可至少省略一次 HTTP 调用, 获得性能上的收益")]),t._v(", 且根据 Kubernetes 官方给出的测试数据, 这些免费的收益还相当可观. Kubernetes 从 1.10 版本宣布开始支持 containerd 1.1, 此时在调用链中已经能够"),s("strong",[t._v("完全抹去 Docker Engine")]),t._v("的存在:")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Kubernetes Master -> kubelet -> KubeGenericRuntimeManager -> containerd -> runC\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("今天, 要使用哪一种容器运行时取决于安装 Kubernetes 时宿主机上的容器"),s("strong",[t._v("运行时环境")]),t._v(", 但对于阿里云 ACK, 腾讯云 TKE 等直接提供 Kubernetes 容器环境的云计算厂商来说, 采用的容器运行时普遍都已是 "),s("strong",[t._v("containerd")]),t._v(", 毕竟运行性能对它们来说就是核心生产力和竞争力.")]),t._v(" "),s("p",[t._v("未来, 随着 Kubernetes 持续发展壮大, Docker Engine 经历从不可或缺, 默认依赖, 可选择, 直到淘汰是大概率事件, 这件事情表面上是 Google, Red Hat 等云计算大厂联手所为, 但实际淘汰它的还是"),s("strong",[t._v("技术发展的潮流趋势")]),t._v(", 就如同 Docker 诞生时依赖 LXC, 到最后用 libcontainer 取代 LXC 一般. 同时也该看到事情的另一面, 现在连 LXC 都还没有被淘汰, 反倒发展出了更加专注于与 OpenVZ 等系统级虚拟化竞争的 LXD, 相信 Docker 本身也很难彻底消亡, 如已经习惯使用的 CLI 界面, 已经形成成熟生态的镜像仓库等都应该会长期存在, 只是在容器编排领域, "),s("strong",[t._v("未来的 Docker 很可能只会以 runC 和 containerd 的形式存续下去, 毕竟它们最初都源于 Docker")]),t._v(".")]),t._v(" "),s("h4",{attrs:{id:"以容器构建系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#以容器构建系统"}},[t._v("#")]),t._v(" 以容器构建系统")]),t._v(" "),s("p",[t._v('自从 Docker 提出的"'),s("strong",[t._v("以封装应用为中心")]),t._v('"的容器发展理念成功取代 LXC 的"'),s("strong",[t._v("以封装系统为中心")]),t._v('"的理念以后, '),s("strong",[t._v("一个容器封装一个单进程应用")]),t._v("已经成为被广泛认可的最佳实践. 然而单体时代过去之后, 分布式系统里应用的概念已不再等同于进程, 此时的"),s("strong",[t._v("应用需要多个进程共同协作, 通过集群的形式对外提供服务, 而以虚拟化方法实现这个目标的过程就被称为容器编排(Container Orchestration)")]),t._v(" .")]),t._v(" "),s("p",[t._v("容器之间"),s("strong",[t._v("顺畅地交互通信")]),t._v("是协作的核心需求, 但容器协作并不仅仅是将容器以高速网络互相连接而已. 如何"),s("strong",[t._v("调度容器, 如何分配资源, 如何扩缩规模, 如何最大限度地接管系统中的非功能特性, 如何让业务系统尽可能免受分布式复杂性的困扰, 都是容器编排框架必须考虑的问题")]),t._v(". 只有恰当解决了这一系列问题, 云原生应用才有可能获得比传统应用更高的生产力.")]),t._v(" "),s("h5",{attrs:{id:"_1-隔离与协作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-隔离与协作"}},[t._v("#")]),t._v(" 1.隔离与协作")]),t._v(" "),s("p",[t._v("笔者并不打算过多介绍 Kubernetes 具体有哪些功能, 例如 Kubernetes 由 Pod, Node, Deployment, ReplicaSet 等各种类型的资源组成的服务, 集群管理平面与节点之间如何工作, 每种资源该如何配置使用等.")]),t._v(" "),s("p",[t._v('这里真正希望说清楚的问题是 "为什么 Kubernetes 会设计成现在这个样子", "为什么以容器构建系统应该这样做", 而寻找这些问题的答案最好是从它们的'),s("strong",[t._v("设计意图")]),t._v("出发. 为此这里虚构了一系列从简单到复杂的场景供你代入其中, 理解并解决这些场景中的问题, 并不要求你对 Kubernetes 有多深入的了解, 但要求你至少使用过 Kubernetes 和 Docker, 基本了解它们的核心功能与命令.")]),t._v(" "),s("p",[t._v("现在来设想一下, 如果让你"),s("strong",[t._v("设计一套容器编排系统, 协调各种容器共同完成一项工作, 会遇到什么问题")]),t._v("? 你会如何着手解决? 让我们从最简单的场景出发.")]),t._v(" "),s("p",[t._v("场景一: 假设你现在有两个应用, 一个是 "),s("strong",[t._v("Nginx")]),t._v(", 另一个是为该 Nginx 收集日志的 "),s("strong",[t._v("Filebeat")]),t._v(", 你希望将它们封装为容器镜像, 以方便日后分发.")]),t._v(" "),s("p",[t._v("最直接的方案就是将 Nginx 和 Filebeat 直接编译成"),s("strong",[t._v("同一个容器镜像")]),t._v(", 这是可以做到的, 而且并不复杂, 然而这样做会埋下很大的隐患: 它"),s("strong",[t._v("违背了 Docker 提倡的单个容器封装单进程应用的最佳实践")]),t._v(". Docker 设计的 Dockerfile 只允许有一个 ENTRYPOINT, 这并非无故添加的人为限制, 而是因为 "),s("strong",[t._v("Docker 只能通过监视 PID 为 1 的进程")]),t._v("(即由 ENTRYPOINT 启动的进程)的运行状态来判断容器的工作状态是否正常, 然后根据状态决定是否执行清理自动重启等操作. 设想一下, 即使使用了 supervisord 之类的进程控制器来解决同时启动 Nginx 和 Filebeat 进程的问题, 如果它们因某种原因不停发生崩溃, 重启, 那 Docker 也无法察觉到, 它只能观察到 supervisord 的运行状态, 因此以上需求会理所当然地演化成场景二.")]),t._v(" "),s("p",[t._v("场景二: 假设你现在有"),s("strong",[t._v("两个 Docker 镜像")]),t._v(", 其中一个封装了 HTTP 服务, 这里称它为 Nginx 容器, 另一个封装了日志收集服务, 这里称它为 Filebeat 容器. 现在要求 "),s("strong",[t._v("Filebeat 容器能收集 Nginx 容器产生的日志信息.")])]),t._v(" "),s("p",[t._v("场景二依然不难解决, 只要在 Nginx 容器和 Filebeat 容器启动时, 分别将它们的"),s("strong",[t._v("日志目录和收集目录挂载为宿主机同一个磁盘位置的 Volume 即可")]),t._v(", 这种操作在 Docker 中是十分常用的容器间的信息交换手段. 不过, 容器间信息交换的不仅仅是文件系统, 假如此时又引入了一个新的工具---confd(Linux 下的一种配置管理工具, 作用是根据配置中心(etcd, ZooKeeper, Consul)的变化自动更新 Nginx 的配置), 这里便又会遇到新的问题. confd 需要向 Nginx 发送 "),s("strong",[t._v("HUP")]),t._v(" 信号, 以便通知 Nginx 配置已经发生了变更, 而发送 HUP 信号自然要求 "),s("strong",[t._v("confd 与 Nginx 能够进行 IPC 通信")]),t._v("才行. 尽管共享 IPC 名称空间不如共享 Volume 常见, 但 Docker 同样支持了该功能. docker run 提供了  "),s("strong",[t._v("--ipc")]),t._v(" 参数, 用于把多个容器挂载到同一个父容器的 IPC 名称空间之下, 以实现容器间共享 IPC 名称空间的需求. 类似地, 如果要共享 UTS 名称空间, 可以使用  "),s("strong",[t._v("--uts")]),t._v(" 参数; 如果要共享网络名称空间, 则可以使用  "),s("strong",[t._v("--net")]),t._v(" 参数.")]),t._v(" "),s("p",[t._v("以上便是 Docker 针对场景二这种"),s("strong",[t._v("不跨机器的多容器协作")]),t._v("所给出的解决方案, 自动地为多个容器设置好共享名称空间其实就是 Docker Compose 提供的核心能力. 这种针对具体应用需求来共享名称空间的方案, 确实可以工作, 却并不够优雅, 也谈不上有什么扩展性. "),s("strong",[t._v("容器的本质是对 cgroups 和 namespaces 所提供的隔离能力的一种封装, 在 Docker 提倡的单进程封装的理念影响下, 容器蕴含的隔离性多了仅针对单个进程的额外限制, 而 Linux 的 cgroups 和 namespaces 原本都是针对进程组而非单个进程来设计的, 同一个进程组中的多个进程天然就可以共享相同的访问权限与资源配额")]),t._v(". 如果现在把容器与进程在概念上对应起来, 那容器编排的第一个扩展点, 就是要找到"),s("strong",[t._v('容器领域中与"进程组"相对应的概念, 这是实现容器从隔离到协作的第一步')]),t._v(", 在 Kubernetes 的设计里, 这个对应物叫作 "),s("strong",[t._v("Pod")]),t._v(".")]),t._v(" "),s("p",[t._v('Pod 的概念在容器正式出现之前的 Borg 系统中就已经存在了. 从 Google 发表的 "Large-Scale Cluster Management at Google with Borg" 可以看出, Kubernetes 时代的 Pod 整合了 Borg 时代的 "Prod"(Production Task的缩写) 与 "Non-Prod" 的职能.')]),t._v(" "),s("p",[t._v('有了"容器组"的概念, 场景二的问题便只需要'),s("strong",[t._v("将多个容器放到同一个 Pod 中")]),t._v("即可解决. 扮演"),s("strong",[t._v("容器组")]),t._v("的角色, 满足容器"),s("strong",[t._v("共享名称空间")]),t._v("的需求, 是 Pod 的两大最基本职责之一, "),s("strong",[t._v("同处于一个 Pod 内的多个容器, 相互之间以超亲密的方式协作")]),t._v('. 请注意, "超亲密"在这里并非某种带强烈感情色彩的形容词, 而是一种有具体定义的协作程度. 对于'),s("strong",[t._v("普通非亲密")]),t._v("的容器, 它们一般以"),s("strong",[t._v("网络")]),t._v("交互方式(其他譬如共享分布式存储来交换信息也算跨网络)协作; 对于"),s("strong",[t._v("亲密协作")]),t._v("的容器, 它们一般被调度到同一个集群节点上, 可以通过"),s("strong",[t._v("共享本地磁盘")]),t._v("等方式协作; 而"),s("strong",[t._v("超亲密的协作")]),t._v("是特指多个容器"),s("strong",[t._v("位于同一个 Pod")]),t._v(" 的特殊关系, 它们将默认共享如下内容.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("UTS 名称空间")]),t._v(": 所有容器都有"),s("strong",[t._v("相同的主机名和域名")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("网络名称空间")]),t._v(": 所有容器都共享"),s("strong",[t._v("一样的网卡, 网络栈, IP 地址")]),t._v("等. 因此, 同一个 Pod 中不同容器占用的"),s("strong",[t._v("端口不能冲")]),t._v("突.")]),t._v(" "),s("li",[s("strong",[t._v("IPC 名称空间")]),t._v(": 所有容器都可以通过"),s("strong",[t._v("信号量或者 POSIX 共享内存等方式通信")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("时间名称空间")]),t._v(": 所有容器都共享相同的系统时间.")])]),t._v(" "),s("p",[s("strong",[t._v("同一个 Pod 的容器, 只有 PID 名称空间和文件名称空间默认是隔离的")]),t._v(". PID 的隔离令每个容器都有独立的进程 ID 编号, 它们封装的应用进程就是 PID 为 1 的进程, 可以通过 Pod 元数据定义中的 spec.shareProcessNamespace 来改变这点. 一旦要求共享 PID 名称空间, 容器封装的应用进程就不再具有 PID 为 1 的特征了, 这有可能导致部分依赖该特征的应用出现异常. 在文件名称空间方面, 容器要求文件名称空间的隔离是很理所当然的需求, 因为容器需要相互独立的文件系统以避免冲突, 但容器间可以共享存储卷, 这是通过 Kubernetes 的 Volume 来实现的.")]),t._v(" "),s("p",[t._v("Kubernetes 中 Pod 名称空间共享的实现细节: Pod 内部多个容器共享 UTS, IPC, 网络等名称空间是通过一个名为 "),s("strong",[t._v("Infra Container")]),t._v(" 的容器来实现的, 这个容器是整个 Pod 中"),s("strong",[t._v("第一个启动")]),t._v("的容器, 只有几十万字节大小(代码只有很短的几十行), Pod 中的其他"),s("strong",[t._v("容器都会以 Infra Container 作为父容器")]),t._v(", UTS, IPC, 网络等名称空间实质上都来自 Infra Container 容器. 如果容器设置为共享 PID 名称空间, 那么 Infra Container 中的进程将作为 PID 1 进程, 而其他容器的进程将以它的"),s("strong",[t._v("子进程")]),t._v('的方式存在, 此时将由 Infra Container 来负责进程管理(譬如清理僵尸进程), 感知状态和传递状态. 由于 Infra Container 的代码除了注册 SIGINT, SIGTERM, SIGCHLD 等信号的处理器外, 就只是一个以 pause() 方法为循环体的无限循环, 永远处于 Pause 状态, 所以也常被称为 "'),s("strong",[t._v("Pause Container")]),t._v('".')]),t._v(" "),s("p",[s("strong",[t._v("Pod 的另外一个基本职责是实现原子性调度")]),t._v(", 如果容器编排不跨越集群节点, 是否具有原子性都无关紧要. 但是在集群环境中, 在容器可能跨机器调度时, 这个特性就变得非常重要. 如果以容器为单位来调度, 不同的容器就有可能被分配到不同的机器上. 两台机器之间本来就是物理隔离, 依靠网络连接的, 这时候谈什么名称空间共享, cgroups 配额共享都将毫无意义, 由此将场景二又演化成以下场景三.")]),t._v(" "),s("p",[t._v("场景三: 假设你现在有 Filebeat, Nginx 两个 Docker 镜像, 在一个具有"),s("strong",[t._v("多个节点的集群环境")]),t._v("下, 要求每次调度都必须让 Filebeat 和 Nginx 容器"),s("strong",[t._v("运行于同一个节点")]),t._v("上.")]),t._v(" "),s("p",[t._v("两个关联的协作任务必须一起调度的需求在容器出现之前就存在已久, 譬如在传统的多线程(或多进程)并发调度中, 如果两个线程(或进程)的工作是强依赖的, 单独给其中一个分配处理时间, 而另一个被挂起会导致程序无法工作, 如此就有了"),s("strong",[t._v("协同调度")]),t._v("(Coscheduling)的概念, 以"),s("strong",[t._v("保证一组紧密联系的任务能够被同时分配资源")]),t._v(". 如果                                                                                  在容器编排中仍然坚持将容器视为调度的最小粒度, 那对容器运行所需资源的需求声明就只能设定在容器上, 这样集群每个节点剩余资源越紧张, 单个节点无法容纳全部协同容器的概率就越大, 协同的容器被分配到不同节点的可能性就越高.")]),t._v(" "),s("p",[t._v('协同调度是十分麻烦的, 实现起来要么很低效, 譬如 Apache Mesos 的 Resource Hoarding 调度策略, 就要等所有需要调度的任务都完备后才会开始分配资源; 要么很复杂, 譬如 Google 就曾针对 Borg 的下一代 Omega 系统发表过论文 "Omega:Flexible,Scalable Schedulers for Large Compute Clusters", 介绍 Omega 是如何通过乐观并发(Optimistic Concurrency), 冲突回滚的方式做到高效率且高复杂度的协同调度的. 但是如果'),s("strong",[t._v("将运行资源的需求声明定义在 Pod 上, 直接以 Pod 为最小的原子单位来实现调度, 由于多个 Pod 之间必定不存在超亲密的协同关系, 只会通过网络非亲密地协作, 就没有协同的说法, 自然也不需要考虑复杂的调度")]),t._v("了. 关于 Kubernetes 的具体调度实现, 后面会展开讲解.")]),t._v(" "),s("p",[s("mark",[s("strong",[t._v("Pod 是隔离与调度的基本单位")])]),t._v(", 也是接触的第一种 Kubernetes 资源. Kubernetes 将一切皆视为"),s("strong",[t._v("资源")]),t._v(", 不同资源之间依靠"),s("strong",[t._v("层级关系相互组合")]),t._v(", 协作的这个思想是贯穿 Kubernetes 整个系统的两大核心设计理念之一, 不仅在容器, Pod, 主机, 集群等计算资源上是这样, 如下图所示, 在工作负载, 持久存储, 网络策略, 身份权限等其他领域中也都有一致的体现.")]),t._v(" "),s("p",[t._v("​"),s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230102232309303.png",alt:"image-20230102232309303",title:"Kubernetes的计算资源"}}),t._v("​")]),t._v(" "),s("p",[t._v("由于 "),s("strong",[t._v("Pod 是 Kubernetes 中最重要的资源, 又是资源模型中一种仅在逻辑上存在, 没有物理对应的概念")]),t._v('(因为对应的"进程组"也只是个逻辑概念), 是其他编排系统没有的概念, 所以笔者专门花费了一些篇幅去介绍它的设计意图, 而不是像帮助手册那样直接给出它的作用和特性. 对于 Kubernetes 中的其他计算资源, 像 Node, Cluster 等都有切实的物理对应物, 相信你很容易就能理解, 所以这里仅将它们的设计意图列举如下.')]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("容器")]),t._v("(Container): 延续了自 Docker 以来"),s("strong",[t._v("一个容器封装一个应用进程")]),t._v("的理念, 是"),s("strong",[t._v("镜像管理的最小单位")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("生产任务")]),t._v('(Pod): 补充了容器化后缺失的与进程组对应的"'),s("strong",[t._v("容器组")]),t._v('"的概念, Pod 中的'),s("strong",[t._v("容器共享 UTS, IPC, 网络等名称空间, 是资源调度的最小单位")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("节点")]),t._v("(Node): 对应于集群中的"),s("strong",[t._v("单台机器")]),t._v(", 这里的机器既可以是生产环境中的"),s("strong",[t._v("物理机")]),t._v(", 也可以是云计算环境中的虚拟节点, "),s("strong",[t._v("节点是处理器和内存等资源的资源池, 是硬件单元的最小单位")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("集群")]),t._v("(Cluster): 对应于整个集群, Kubernetes 提倡面向集群来管理应用. 当要部署应用的时候, 只需要通过声明式 API 将意图写成一份"),s("strong",[t._v("元数据")]),t._v("(Manifest), 将它提交给集群即可, 而无须关心它具体分配到哪个节点(尽管通过标签选择器完全可以控制它分配到哪个节点, 但一般不需要这样做), 如何实现 Pod 间通信, 如何保证韧性与弹性, 等等, 所以"),s("strong",[t._v("集群是处理元数据的最小单位")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("集群联邦")]),t._v("(Federation): 对应于多个集群, 通过集群联邦可以统一管理多个 Kubernetes 集群, 它的一种常见应用是能"),s("strong",[t._v("满足跨可用区域多活, 跨地域容灾的需求")]),t._v(".")])]),t._v(" "),s("h5",{attrs:{id:"_2-韧性与弹性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-韧性与弹性"}},[t._v("#")]),t._v(" 2.韧性与弹性")]),t._v(" "),s("p",[t._v("让容器得以相互连通, 相互协作仅仅是以容器构建系统的"),s("strong",[t._v("第一步")]),t._v(", 因为不仅希望得到一个能够运行起来的系统, 还希望得到一个能够"),s("strong",[t._v("健壮运行, 能够抵御意外与风险")]),t._v("的系统. 在 Kubernetes 的支持下, 确实可以通过"),s("strong",[t._v("直接创建 Pod 将应用")]),t._v("运行起来, 但这样的应用无论是软件缺陷, 意外操作或者硬件故障, 都可能导致在复杂协作过程中的某个容器出现异常, 进而出现系统性崩溃. 为此, 架构师专门设计了"),s("strong",[t._v("服务容错的策略和模式")]),t._v(", Kubernetes 作为云原生时代的基础设施, 也尽力帮助程序员以最小的代价来实现容错, "),s("strong",[t._v("为系统健壮运行提供底层支持")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("控制器模式")]),t._v("是继资源模型之后, 本节介绍的另一个 Kubernetes 核心设计理念, 而"),s("strong",[t._v("如何实现具有韧性与弹性的系统是展示 Kubernetes 控制器设计模式的最好示例")]),t._v(". 下面就从如何解决场景四的问题开始.")]),t._v(" "),s("p",[t._v("场景四: 假设有一个由数十个 Node, 数百个 Pod, 近千个 Container 所组成的分布式系统, 要避免系统因为外部流量压力, 代码缺陷, 软件更新, 硬件升级, 资源分配等原因而出现中断, 作为管理员, 你希望编排系统为你提供哪种支持?")]),t._v(" "),s("p",[t._v("作为用户, 当然最希望"),s("strong",[t._v("容器编排系统能自动把所有意外因素都消灭掉")]),t._v(", 让任何一个服务都永远健康, 永不出错. 但永不出错的服务是不切实际的, 所以只能退而求其次, 让编排系统在这些服务出现问题或者运行状态不正确的时候, 能自动调整成正确的状态. 这种需求听起来也是贪心的, 却已经具备足够的可行性, 相应的解决办法在工业控制系统里已经有非常成熟的应用, 叫作"),s("strong",[t._v("控制回路")]),t._v("(Control Loop).")]),t._v(" "),s("p",[t._v('Kubernetes 官方文档是以房间中空调自动调节温度为例介绍了控制回路的一般工作过程: 当你设置好了温度, 就是告诉空调你对温度的"'),s("strong",[t._v("期望状态")]),t._v('"(Desired State), 而传感器测量出的房间的实际温度是"'),s("strong",[t._v("当前状态")]),t._v('"(Current State). 根据当前状态与期望状态的差距, 由控制器通过控制空调的制冷开关来调节温度, 使当前状态逐渐接近期望状态.')]),t._v(" "),s("p",[t._v("将这种控制回路的思想应用到容器编排上, 自然会为 Kubernetes 中的资源附加上"),s("strong",[t._v("期望状态与实际状态")]),t._v("两项属性. 不论是已经出现在上节的资源模型中, 用于抽象容器运行环境的计算资源, 还是没有登场的另一部分对应于安全, 服务, 令牌, 网络等功能的资源, 用户要想使用这些资源来实现某种需求, 就不提倡像平常编程那样去调用某个或某一组方法来达成目的, 而是要通过"),s("strong",[t._v("描述清楚这些资源的期望状态, 由 Kubernetes 中对应监视这些资源的控制器来驱动资源的实际状态逐渐向期望状态靠拢")]),t._v(". 这种交互风格被称为 "),s("strong",[t._v("Kubernetes 的声明式 API")]),t._v(", 在元数据文件中定义的 "),s("strong",[t._v("spec 字段所描述的便是资源的期望状态")]),t._v(".")]),t._v(" "),s("p",[t._v("Kubernetes 的资源对象与控制器")]),t._v(" "),s("p",[t._v("目前, Kubernetes 已支持相当多的资源对象, 并且可以使用 "),s("strong",[t._v("CRD(Custom Resource Definition, 用户资源自定义)")]),t._v(" 来自定义扩充, 可以使用 kubectl api-resources 来查看它们. 这里根据用途对这些资源对象进行了分类.")]),t._v(" "),s("ul",[s("li",[t._v("用于描述如何创建, 销毁, 更新, 扩缩 Pod, 包括 Autoscaling(HPA), CronJob, DaemonSet, Deployment, Job, Pod, ReplicaSet, StatefulSet.")]),t._v(" "),s("li",[t._v("用于配置信息的设置与更新, 包括 ConfigMap, Secret.")]),t._v(" "),s("li",[t._v("用于持久性地存储文件或者 Pod 之间的文件共享, 包括 Volume, LocalVolume, PersistentVolume, PersistentVolumeClaim, StorageClass.")]),t._v(" "),s("li",[t._v("用于维护网络通信和服务访问的安全, 包括 SecurityContext, ServiceAccount, Endpoint, NetworkPolicy.")]),t._v(" "),s("li",[t._v("用于定义服务与访问, 包括 Ingress, Service, EndpointSlice.")]),t._v(" "),s("li",[t._v("用于划分虚拟集群, 节点和资源配额, 包括 Namespace, Node, ResourceQuota.")])]),t._v(" "),s("p",[t._v("这些"),s("strong",[t._v("资源对象在控制器管理框架中一般都会有相应的控制器")]),t._v("来管理, 下面列举一些常见的控制器, 并按照它们的启动情况分类如下.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("必须启用的控制器")]),t._v(": EndpointController, ReplicationController, PodGCController, ResourceQuotaController, NamespaceController, ServiceAccountController, GarbageCollectorController, DaemonSetController, JobController, Deployment-Controller, ReplicaSetController, HPAController, DisruptionController, StatefulSetController, CronJobController, CSRSigningController, CSRApproving-Controller, TTLController.")]),t._v(" "),s("li",[t._v("默认启用的可选控制器, 可通过选项禁止: TokenController, Node-Controller, ServiceController, RouteController, PVBinderController, AttachDetachController.")]),t._v(" "),s("li",[t._v("默认禁止的可选控制器, 可通过选项启用: BootstrapSignerController, Token-CleanerController.")])]),t._v(" "),s("p",[s("strong",[t._v("与资源相对应, 只要是实际状态有可能发生变化的资源对象, 通常都会由对应的控制器进行追踪, 每个控制器至少会追踪一种类型的资源对象")]),t._v(". 为了管理众多资源控制器, Kubernetes 设计了统一的"),s("strong",[t._v("控制器管理框架")]),t._v("(kube-controller-manager)来维护这些控制器的正常运作, 以及"),s("strong",[t._v("统一的指标监视器")]),t._v("(kube-apiserver)来为控制器提供其工作时追踪资源的度量数据.")]),t._v(" "),s("p",[t._v("由于毕竟不是在写 Kubernetes 的操作手册, 所以只能以两三种资源和控制器为代表来举例说明, 而无法将每个控制器都详细展开讲解. 只要将场景四进一步具体化, 转换成下面的场景五, 便可以得到一个很好的例子, 这里以"),s("strong",[t._v("部署控制器")]),t._v("(Deployment Controller), "),s("strong",[t._v("副本集控制器")]),t._v("(ReplicaSet Controller)和"),s("strong",[t._v("自动扩缩控制器")]),t._v("(HPA Controller)为例来介绍 Kubernetes 控制器模式的工作原理.")]),t._v(" "),s("p",[t._v("场景五: 通过服务编排, 对任何分布式系统自动实现以下三种通用的能力.")]),t._v(" "),s("p",[t._v("(1)Pod "),s("strong",[t._v("出现故障")]),t._v("时, 能够自动恢复, 不中断服务.")]),t._v(" "),s("p",[t._v("(2)Pod "),s("strong",[t._v("更新程序")]),t._v("时, 能够滚动更新, 不中断服务.")]),t._v(" "),s("p",[t._v("(3)Pod "),s("strong",[t._v("遇到压力")]),t._v("时, 能够水平扩展, 不中断服务.")]),t._v(" "),s("p",[t._v("前文曾提到虽然 Pod 本身也是资源, 完全可以直接创建, 但由 Pod 直接构成的系统是十分脆弱的, 在实际生产中并不提倡. 正确的做法是通过"),s("strong",[t._v("副本集(ReplicaSet)来创建 Pod")]),t._v(". ReplicaSet 也是一种资源, 属于工作负荷类, 代表"),s("strong",[t._v("一个或多个 Pod 副本的集合")]),t._v(". 可以在 ReplicaSet 资源的"),s("strong",[t._v("元数据中描述期望的 Pod 副本的数量(即 spec.replicas 的值)")]),t._v(" . 当 ReplicaSet 成功创建之后, 副本集控制器就会持续跟踪该资源, 如果一旦有 Pod 发生崩溃退出, 或者状态异常(默认是靠进程返回值, 还可以在 Pod 中设置探针, 以自定义的方式告诉 Kubernetes 出现何种情况时 Pod 才算状态异常), ReplicaSet 都会"),s("strong",[t._v("自动创建新的 Pod 来替代异常的 Pod")]),t._v("; 如果异常出现了额外数量的 Pod, 也会被 ReplicaSet 自动回收, 总之就是"),s("strong",[t._v("确保在任何时候集群中的这个 Pod 副本的数量都向期望状态靠拢")]),t._v(".")]),t._v(" "),s("p",[t._v("ReplicaSet 本身就能满足场景五中的第一项能力, 即可以保证 Pod "),s("strong",[t._v("出现故障时自动恢复")]),t._v(", 但是在升级程序版本时,  ReplicaSet 不得不主动中断旧的 Pod 的运行, 重新创建新的 Pod, 这会造成服务中断. 对于那些不允许中断的业务, 以前的 Kubernetes 曾经提供了 kubectl rolling-update 命令来辅助实现滚动更新.")]),t._v(" "),s("p",[t._v("所谓"),s("strong",[t._v("滚动更新")]),t._v("(Rolling Update)是指先停止少量旧副本, 维持大量旧副本继续提供服务, 当停止的旧副本更新成功, 新副本可以提供服务以后, 再重复以上操作, 直至所有的副本都更新成功. 将这个过程放到 ReplicaSet 上, 就是先创建新版本的 ReplicaSet, 然后一边让新的 ReplicaSet 逐步创建新版 Pod 的副本, 一边让旧的 ReplicaSet 逐渐减少旧版 Pod 的副本.")]),t._v(" "),s("p",[t._v("之所以 kubectl rolling-update 命令会被"),s("strong",[t._v("淘汰")]),t._v(", 是因为这样的命令式交互完全不符合 Kubernetes 的设计理念(这是台面上的说法, 笔者觉得淘汰的根本原因是它不好用), "),s("strong",[t._v("如果希望改变某个资源的某种状态, 应该将期望状态告诉 Kubernetes, 而不是去教 Kubernetes 具体该如何操作")]),t._v(". 因此, 新的部署资源(Deployment)与部署控制器被设计出来, "),s("strong",[t._v("由 Deployment 来创建 ReplicaSet, 再由 ReplicaSet 来创建 Pod")]),t._v(", 当更新 Deployment 中的信息(譬如更新了镜像的版本)后, 部署控制器就会跟踪到新的期望状态, 自动创建新的 ReplicaSet, 并逐渐缩减旧的 ReplicaSet 的数量, 直至升级完成后彻底删除掉旧的 ReplicaSet.")]),t._v(" "),s("p",[t._v("对于场景五的最后一种能力, 遇到"),s("strong",[t._v("流量压力")]),t._v("时, 管理员完全可以手动修改 Deployment 中的副本数量, 或者通过 kubectl scale 命令指定副本数量, 促使 Kubernetes 部署更多的 Pod 副本来应对压力. 然而这种扩容方式需要人工参与, 且只靠人类经验来判断需要扩容的副本数量, 不容易做到精确与及时, 为此 Kubernetes 又提供了 "),s("strong",[t._v("Autoscaling 资源和自动扩缩控制器")]),t._v(', 从而自动根据度量指标, 如处理器, 内存占用率, 用户自定义的度量值等, 来设置 Deployment(或者 ReplicaSet)的期望状态, 实现当度量指标出现变化时, 系统自动按照 "Autoscaling -> Deployment -> ReplicaSet -> Pod" 这样的顺序层层变更, 最终实现根据度量指标'),s("strong",[t._v("自动扩容/缩容")]),t._v(".")]),t._v(" "),s("p",[t._v("故障恢复, 滚动更新, 自动扩缩这些特性, 在云原生时代里常被概括成服务的"),s("strong",[t._v("韧性(Resilience)与弹性(Elasticity)")]),t._v(' , ReplicaSet, Deployment, Autoscaling 的用法, 也属于所有 Kubernetes 教材资料都会讲到的"基础必修课". 如果你准备学习 Kubernetes 或者其他与云原生相关的技术, 建议最好不要死记硬背地学习每个资源的元数据文件如何编写, 有哪些指令, 有哪些功能, 而是站在'),s("strong",[t._v("解决问题的角度去理解为什么 Kubernetes 要设计这些资源和控制器, 为什么这些资源和控制器会被设计成现在这种样子")]),t._v(".")]),t._v(" "),s("p",[t._v("如果已经理解了前面的几种资源和控制器的例子, 那不妨思考以下几个问题: 假设想限制某个 Pod 持有的最大存储卷数量, 应该如何设计? 假设集群中某个 Node 发生硬件故障, Kubernetes 要让调度任务避开这个 Node, 应该如何设计? 假设一旦这个 Node 重新恢复, Kubernetes 要尽快利用上面的资源, 又该如何设计? 只要你真正接受了资源与控制器是贯穿整个 Kubernetes 的两大设计理念, 即便不去查文档手册, 也应该能想出个大概轮廓, 以此为基础再去看手册或者源码时, 想必就能够事半功倍.")]),t._v(" "),s("h4",{attrs:{id:"以应用为中心的封装"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#以应用为中心的封装"}},[t._v("#")]),t._v(" 以应用为中心的封装")]),t._v(" "),s("p",[t._v('看完容器技术的发展历程, 不知你会不会有种"套娃式"的迷惑感? 容器的崛起缘于 chroot, namespaces, cgroups 等内核提供的隔离能力, 系统级虚拟化技术使得同一台机器上互不干扰地运行多个服务成为可能; 为了降低用户使用内核隔离能力的门槛, 随后出现了 LXC, 它是 namespaces, cgroups 特性的上层封装, 使得"容器"一词真正走出实验室, 走入工业界的实际应用中; 为了实现跨机器的软件绿色部署, 出现了 Docker, 它(最初)是 LXC 的上层封装, 彻底改变了软件打包分发的方式, 并迅速被大量企业广泛采用; 为了满足大型系统对服务集群化的需要, 出现了 Kubernetes, 它(最初)是 Docker 的上层'),s("strong",[t._v("封装")]),t._v(", 让以多个容器共同协作构建出的健壮的分布式系统, 成为今天云原生时代的技术基础设施.")]),t._v(" "),s("p",[t._v("那 Kubernetes 会是容器化崛起之路的终点吗? 它达到了人们对云原生时代技术基础设施的期望了吗? 从能力角度讲, 是可以这样说的, "),s("strong",[t._v("Kubernetes 被誉为云原生时代的操作系统")]),t._v(", 自诞生之日起就因其出色的管理能力, 扩展性与以声明代替命令的交互理念收获了无数喝彩声. 但是从易用角度讲, 坦白说差距还非常大, 云原生基础设施的其中一个重要目标是"),s("strong",[t._v("接管业务系统复杂的非功能特性, 让业务研发与运维工作变得足够简单, 不受分布式的牵绊")]),t._v(", 然而 Kubernetes 被诟病最多的就是复杂, 自诞生之日起就以陡峭的学习曲线而闻名.")]),t._v(" "),s("p",[t._v("举个具体例子, 用 Kubernetes 部署一套 Spring Cloud 版的 Fenix’s Bookstore, 需要分别部署一个到多个配置中心, 注册中心, 服务网关, 安全认证, 用户服务, 商品服务, 交易服务, "),s("strong",[t._v("为每个微服务都配置好相应的 Kubernetes 工作负载与服务访问, 为每一个微服务的 Deployment, ConfigMap, StatefulSet, HPA, Service, ServiceAccount, Ingress 等资源都编写好元数据配置")]),t._v(". 这个过程最难的地方不仅在于烦琐, 还在于要写出合适的元数据描述文件, 既需要懂"),s("strong",[t._v("开发")]),t._v("(网关中服务调用关系, 使用容器的镜像版本, 运行依赖的环境变量这些参数等), 又需要懂"),s("strong",[t._v("运维")]),t._v("(要部署多少个服务, 配置何种扩容缩容策略, 数据库的密钥文件地址等), 有时候还需要懂"),s("strong",[t._v("平台")]),t._v("(需要什么样的调度策略, 如何管理集群资源), 一般企业根本找不到合适的角色来为它管理, 部署和维护应用.")]),t._v(" "),s("p",[t._v("但以上复杂性不能说是 Kubernetes 带来的, 而是分布式架构本身的特点导致. 对于大规模的分布式集群, 无论是最终用户部署应用, 还是软件公司管理应用都存在诸多痛点. "),s("strong",[t._v("这些困难的实质源于 Docker 容器镜像封装了")]),t._v("​"),s("mark",[s("strong",[t._v("单个服务")])]),t._v("​ "),s("strong",[t._v(", Kubernetes 通过资源封装了")]),t._v("​"),s("mark",[s("strong",[t._v("服务集群")])]),t._v("​ "),s("strong",[t._v(", 却没有一个载体真正封装整个应用, 将原本属于应用内部的技术细节圈禁起来, 不暴露给最终用户, 系统管理员和平台维护者, 让使用者去埋单; 应用难以管理的原因在于封装应用的方法没能将开发, 运维, 平台等各种角色的关注点恰当地分离")]),t._v(".")]),t._v(" "),s("p",[t._v("既然微服务时代, 应用的形式已经不再限于单个进程, 那也该到了"),s("strong",[t._v('重新定义 "以应用为中心的封装"')]),t._v("  这句话的时候了. 至于具体怎样的封装才算正确, 今天还未有特别权威结论, 不过经过人们的不断探索, 已经窥见"),s("strong",[t._v("未来容器应用的一些雏形")]),t._v(", 下面将列出近几年来研究的几种主流思路供参考.")]),t._v(" "),s("h5",{attrs:{id:"_1-kustomize"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-kustomize"}},[t._v("#")]),t._v(" 1.Kustomize")]),t._v(" "),s("p",[t._v('最初, 由 Kubernetes 官方给出的 "如何封装应用" 的解决方案是 "用配置文件来配置配置文件", 这不是绕口令, 可以理解为一种针对 YAML 的模板引擎的变体. Kubernetes 官方认为'),s("strong",[t._v("应用就是一组具有相同目标的 Kubernetes 资源的集合")]),t._v(", 如果逐一管理, 部署每项资源元数据过于烦琐的话, 那就提供一种便捷的方式, 把应用中不变的信息与易变的信息分离开以解决管理问题, 把"),s("strong",[t._v("应用所有涉及的资源自动生成一个多合一(All-in-One)的整合包以解决部署问题")]),t._v(".")]),t._v(" "),s("p",[t._v("完成这项工作的工具叫作 "),s("strong",[t._v("Kustomize")]),t._v(", 它原本只是一个独立的小程序, 从 Kubernetes 1.14 版本起, 被纳入 kubectl 命令之中, 成为 Kubernetes 提供的内置功能. "),s("strong",[t._v("Kustomize 使用 Kustomization 文件来组织与应用相关的所有资源, Kustomization 本身也是一个以 YAML 格式编写的配置文件, 里面定义了构成应用的全部资源, 以及资源中需根据情况被覆盖的变量值")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("Kustomize 的主要价值是根据环境来生成不同的部署配置")]),t._v(". 只要建立多个 Kustomization 文件, 开发人员就能以基于基准进行派生(Base and Overlay)的方式, 对不同的模式(譬如生产模式, 调试模式), 不同的项目(同一个产品对不同客户的客制化)定制出不同的资源整合包. 在配置文件里, 无论是开发人员关心的信息, 还是运维人员关心的信息, 只要是在元数据中描述的内容, 最初都是由开发人员来编写, 然后在编译期间由负责 CI/CD 的产品人员针对项目进行定制, 最后在部署期间由运维人员通过 kubectl 的补丁(Patch)机制更改其中需要运维人员关注的属性, 譬如构造一个补丁来增加 Deployment 的副本个数, 构造另外一个补丁来设置 Pod 的内存限制, 等等.")]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[t._v("k8s\n ├── base\n │     ├── deployment.yaml\n │     ├── kustomization.yaml\n │     └── service.yaml\n └── overlays\n       └── prod\n       │     ├── load"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("loadbalancer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("service.yaml\n       │     └── kustomization.yaml\n       └── debug\n             └── kustomization.yaml\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br")])]),s("p",[t._v('Kustomize 使用 Base, Overlay 和 Patch 生成最终配置文件的思路与 Docker 中分层镜像的思路有些相似, 既规避了以"字符替换"对资源元数据文件的入侵, 也不需要用户学习额外的 DSL 语法(譬如 Lua). 从效果来看, 使用由 Kustomize 编译生成的 All-in-One 整合包来部署应用是相当方便的, 只要一行命令就能够把应用涉及的所有服务一次安装好.')]),t._v(" "),s("p",[t._v('但是 Kustomize 毕竟只是一个"'),s("strong",[t._v("小工具")]),t._v('"性质的辅助功能, 对于开发人员, '),s("strong",[t._v("Kustomize 只能简化产品针对不同情况的重复配置, 并没有真正解决应用管理复杂的问题, 要做的事, 要写的配置, 最终都没有减少")]),t._v(", 只是不用反复去写罢了; 对于运维人员, 应用维护不只是安装部署, 应用的整个生命周期, 除了安装外还有更新, 回滚, 卸载, 多版本, 多实例, 依赖项维护等诸多问题. 这些问题需要更强大的管理工具去解决, 譬如下一节的主角 Helm. 不过 Kustomize 能够以极小的成本, 在一定程度上分离开发和运维工作, 无须像 Helm 那样用一套独立的体系来管理应用, 这种轻量便捷, 本身也是一种可贵的价值.")]),t._v(" "),s("h5",{attrs:{id:"_2-helm与chart"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-helm与chart"}},[t._v("#")]),t._v(" 2.Helm与Chart")]),t._v(" "),s("p",[t._v("另一种"),s("strong",[t._v("更具系统性的管理和封装应用的解决方案")]),t._v("参考了各大 Linux 发行版管理应用的思路, 典型代表为 Deis 公司开发的 Helm 和它的应用格式 "),s("strong",[t._v("Chart")]),t._v(". Helm 一开始的目标就很明确: "),s("strong",[t._v("如果说 Kubernetes 是云原生操作系统, 那 Helm 就要成为这个操作系统上的应用商店与包管理工具")]),t._v(".")]),t._v(" "),s("p",[t._v("Linux 系统下也有包管理工具和封装格式, 如 Debian 系的 apt-get 命令与 dpkg 格式, RHEL 系的 yum 命令与 rpm 格式. 有了包管理工具, 只要知道应用的名称, 就可以很方便地从应用仓库中下载, 安装, 升级, 部署, 卸载, 回滚程序, 而且包管理工具自己掌握着应用的依赖信息和版本变更情况, 具备完整的自管理能力, 对于每个应用需要依赖哪些前置的第三方库, 在安装的时候都会一并处理好.")]),t._v(" "),s("p",[t._v("Helm 模拟的就是上面这种做法, 它"),s("strong",[t._v("提出了与 Linux 包管理直接对应的 Chart 格式和 Repository 应用仓库, 针对 Kubernetes 特有的一个应用经常要部署多个版本的特点, 提出了 Release 的专有概念")]),t._v(".")]),t._v(" "),s("p",[t._v("Chart 用于"),s("strong",[t._v("封装 Kubernetes 应用涉及的所有资源")]),t._v(", 通常以"),s("strong",[t._v("目录内的文件集合的形式")]),t._v("存在. 目录名称就是 Chart 的名称(没有版本信息), 譬如官方仓库中 WordPress Chart 的目录结构是这样的:")]),t._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("WordPress\n ├── templates\n │     ├── NOTES.txt\n │     ├── deployment.yaml\n │     ├── externaldb-secrets.yaml\n │     └── 版面原因省略其他资源文件\n │     └── ingress.yaml\n └── Chart.yaml\n └── requirements.yaml\n └── values.yaml\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("p",[t._v("其中有几个固定的配置文件: "),s("strong",[t._v("Chart.yaml")]),t._v(" 给出了应用自身的详细信息(名称, 版本, 许可证, 自述, 说明, 图标, 等等), "),s("strong",[t._v("requirements.yaml")]),t._v(" 给出了应用的依赖关系, 依赖项指向的是另一个应用的坐标(名称, 版本, Repository地址), "),s("strong",[t._v("values.yaml")]),t._v(" 给出了所有可配置项目的预定义值. 可配置项是指需要运维人员在部署期间调整的那些参数, 存储在 templates 目录下的资源文件中. 部署应用时, Helm 会先将管理员设置的值覆盖到 values.yaml 的默认值上, 然后以字符串替换的形式传递给 templates 目录的资源模板, 最后生成要部署到 Kubernetes 的资源文件. 由于 Chart 封装了足够丰富的信息, 所以 Helm 除了支持命令行操作外, 也能很容易地根据这些信息自动生成图形化的应用安装, 参数设置界面.")]),t._v(" "),s("p",[t._v("Repository 仓库用于实现 "),s("strong",[t._v("Chart 的搜索与下载服务")]),t._v(", Helm 社区维护了公开的 Stable 和 Incubator 的中央仓库, 也支持其他人或组织搭建私有仓库和公共仓库, 并能够通过 Hub 服务把不同个人或组织搭建的公共仓库聚合起来, 形成更大型的分布式应用仓库, 以便于 Chart 的查找与共享.")]),t._v(" "),s("p",[s("strong",[t._v("Helm 提供了应用全生命周期, 版本, 依赖项的管理能力, 还支持额外的扩展插件, 能够加入 CI/CD 或者其他方面的辅助功能, 使得它已经从单纯的工具升级到应用管理平台")]),t._v(". 强大的功能让 Helm 获得不少支持, 很多应用主动入驻到其官方仓库中. 从 2018 年起, Helm 项目被托管到 CNFC, 成为其中的一个孵化项目.")]),t._v(" "),s("p",[t._v("Helm 以模仿 Linux 包管理器的思路去管理 Kubernetes 应用, 在一定程度上是可行的, 不过在 Linux 与 Kubernetes 中部署应用时还是存在"),s("strong",[t._v("一些差别, 最重要的一点是在 Linux 中 99% 的应用都只会安装一份, 而 Kubernetes 为了保证可用性, 同一个应用部署多份副本才是常规操作")]),t._v(". Helm 为了支持对同一个 Chart 包进行多次部署, 每次安装应用时都会产生一个版本(Release), 相当于该 Chart 的安装实例. 对于无状态的服务, Helm 依靠不同的版本就已经足够支持多个服务并行工作, 但对于"),s("strong",[t._v("有状态")]),t._v("的服务来说, 这些服务会与特定资源或者服务产生依赖关系, 譬如要部署数据库, 通常要依赖特定的存储来保存持久化数据, 这样事情就变得复杂起来. "),s("strong",[t._v("Helm 无法很好地管理这种有状态的依赖关系, 所以这一类问题就成为 Operator 要解决的痛点")]),t._v(".")]),t._v(" "),s("h5",{attrs:{id:"_3-operator与crd"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-operator与crd"}},[t._v("#")]),t._v(" 3.Operator与CRD")]),t._v(" "),s("p",[t._v("Operator 不应被称作一种工具或者系统, 它应该算"),s("strong",[t._v("是一种封装, 部署和管理 Kubernetes 应用的方法")]),t._v(", 尤其是针对最复杂的有状态应用去封装运维能力的解决方案, 最早由 CoreOS 公司(于 2018 年被 Red Hat 收购)提出.")]),t._v(" "),s("p",[t._v("如果前面介绍 Kubernetes 资源与控制器模式时你没有开小差, 那么 Operator 中最核心的理念你其实已经理解得差不多了. 简单地说, Operator 是通过 Kubernetes 1.7 版本开始支持的"),s("strong",[t._v("自定义资源")]),t._v("(CRD, 此前曾经以 TPR, 即 Third Party Resource 的形式提供过类似的能力), "),s("strong",[t._v("把应用封装为另一种更高层次的资源, 再把 Kubernetes 的控制器模式从面向内置资源扩展到面向所有自定义资源")]),t._v(", 以此来完成对复杂应用的管理. 下面引用了一段 Red Hat 官方对 Operator 设计理念的阐述.")]),t._v(" "),s("hr"),t._v(" "),s("blockquote",[s("p",[t._v("Operator 设计理念")])]),t._v(" "),s("p",[t._v("Operator 是使用自定义资源(CR, Custom Resource, 是 CRD 的实例), "),s("strong",[t._v("管理应用及其组件的自定义 Kubernetes 控制器")]),t._v(". 高级配置和设置由用户在 CR 中提供. Kubernetes Operator 基于嵌入在 Operator 逻辑中的最佳实践将高级指令转换为低级操作. Kubernetes Operator 监视 CR 类型并采取特定于应用的操作, 确保当前状态与该资源的理想状态相符.")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v('以上是直接由 Red Hat 官方撰写和翻译成中文的, 准确, 严谨但比较拗口, 但是什么叫作"高级指令"? 什么叫作"低级操作"? 两者之间具体如何转换? 为了理解这些问题, 需要先弄清楚'),s("strong",[t._v("有状态和无状态应用")]),t._v("的含义及影响, 再来理解 Operator 所做的工作.")]),t._v(" "),s("p",[s("strong",[t._v("有状态应用(Stateful Application)与无状态应用(Stateless Application)是指应用程序是否要自己持有运行所需的数据")]),t._v(", 如果程序每次运行都跟首次运行一样, 不会依赖之前任何操作遗留下来的痕迹, 那它就是无状态的; 反之, 如果程序推倒重来之后, 用户能察觉到该应用已经发生变化, 那它就是有状态的. "),s("strong",[t._v("无状态应用在分布式系统中具有非常大的价值")]),t._v(", 大家都知道分布式中的 CAP 不兼容原理, 如果"),s("strong",[t._v("无状态, 那就不必考虑状态一致性")]),t._v(", 没有了 C, 那 A 和 P 便可以兼得, 换言之, "),s("strong",[t._v("只要资源足够, 无状态应用天生就是高可用")]),t._v("的. 但不幸的是, 现在的分布式系统中多数关键的基础服务都是有状态的, 如缓存, 数据库, 对象存储, 消息队列等, 只有 Web 服务器这类服务属于无状态.")]),t._v(" "),s("p",[s("strong",[t._v("站在 Kubernetes 的角度看, 是否有状态的本质差异在于有状态应用会直接依赖于某些外部资源")]),t._v(", 譬如 Elasticsearch 建立实例时必须依赖特定的存储位置, 重启后仍然指向"),s("strong",[t._v("同一个数据文件")]),t._v("的实例才能被认为是相同的实例. 另外, "),s("strong",[t._v("有状态应用的多个应用实例之间往往有着特定的拓扑关系与顺序关系")]),t._v(", 譬如 etcd 的节点间的选主和投票, 各节点都需要知道彼此的存在. 为了管理好那些与应用实例密切相关的状态信息, Kubernetes 从 1.9 版本开始正式发布了 StatefulSet 及对应的 StatefulSetController. 与普通 ReplicaSet 中的 Pod 相比, 由 "),s("strong",[t._v("StatefulSet")]),t._v(" 管理的 Pod 具备以下几项额外特性.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("Pod 会按顺序创建和销毁")]),t._v(": StatefulSet 中的各个 Pod 会"),s("strong",[t._v("按顺序")]),t._v("地创建出来, 创建后续的 Pod 前, 必须要保证前面的 Pod 已经转入就绪状态. 删除 StatefulSet 中的 Pod 时会按照与创建顺序的逆序来执行.")]),t._v(" "),s("li",[s("strong",[t._v("Pod 具有稳定的网络名称")]),t._v(": Kubernetes 中的 Pod 都具有"),s("strong",[t._v("唯一的名称")]),t._v(", 在普通的 ReplicaSet 中这是靠随机字符产生的, 而在 StatefulSet 中管理的 Pod, 会以带有顺序的编号作为名称, 且能够在重启后依然保持不变.")]),t._v(" "),s("li",[s("strong",[t._v("Pod 具有稳定的持久化存储")]),t._v(": StatefulSet 中的每个 Pod 都可以拥有自己独立的 PersistentVolumeClaim 资源. 即使 Pod 被重新调度到其他节点上, 它所拥有的持久化磁盘也依然会被挂载到该 Pod, 这点会在后面进一步介绍.")])]),t._v(" "),s("p",[t._v('只是罗列出特性, 应该很难快速理解 StatefulSet 的设计意图, 打个比方来帮助你理解: 如果把 ReplicaSet 中的 Pod 比喻为养殖场中的"肉猪", 那 StatefulSet 就是被家庭当宠物圈养的"荷兰猪", 不同的肉猪在食用功能上并没有什么区别, 但每只宠物猪都是独一无二的, 有专属于自己的名字, 习性与记忆. 事实上, 早期的 StatefulSet 就曾经有一段时间用过 PetSet 这个名字.')]),t._v(" "),s("p",[t._v("当 StatefulSet 出现以后, Kubernetes 就能"),s("strong",[t._v("满足 Pod 重新创建后仍然保留上一次运行状态的需求")]),t._v(", 不过有状态应用的维护并不仅限于此, 譬如对于一套 Elasticsearch 集群来说, 通过 StatefulSet 最多只能做到创建集群, 删除集群, 扩容缩容等最基本的操作, 其他的运维操作, "),s("strong",[t._v("譬如备份和恢复数据, 创建和删除索引, 调整平衡策略等也十分常用, 但是 StatefulSet 并不能为此提供任何帮助")]),t._v(".")]),t._v(" "),s("p",[t._v("这里再举个实际例子来说明 Operator 是如何满足那些 StatefulSet 覆盖不到的有状态服务管理需求的: 假设要部署一套 Elasticsearch 集群, 通常要在 StatefulSet 中定义相当多的细节, 譬如服务的端口,  Elasticsearch 的配置, 更新策略, 内存大小, 虚拟机参数, 环境变量, 数据文件位置, 等等, 为了对已经反复提及的 Kubernetes 的"),s("strong",[t._v("复杂性有更加直观的体验")]),t._v(", 这里将贴出满足这个需求的 YAML 全文, 如下所示.")]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" v1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Service\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" elasticsearch"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("cluster\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("clusterIP")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" None\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("selector")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("app")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" es"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("cluster\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("ports")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" transport\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("port")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9300")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("---")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" v1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Service\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" elasticsearch"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("loadbalancer\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("selector")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("app")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" es"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("cluster\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("ports")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" http\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("port")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("80")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("targetPort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9200")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("type")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" LoadBalancer\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("---")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" v1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ConfigMap\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" es"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("config\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("data")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("elasticsearch.yml")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),s("span",{pre:!0,attrs:{class:"token scalar string"}},[t._v('\n    cluster.name: my-elastic-cluster\n    network.host: "0.0.0.0"\n    bootstrap.memory_lock: false\n    discovery.zen.ping.unicast.hosts: elasticsearch-cluster\n    discovery.zen.minimum_master_nodes: 1\n    xpack.security.enabled: false\n    xpack.monitoring.enabled: false')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("ES_JAVA_OPTS")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("Xms512m "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("Xmx512m\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("---")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" apps/v1beta1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" StatefulSet\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" esnode\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("serviceName")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" elasticsearch\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("replicas")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("updateStrategy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("type")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" RollingUpdate\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("template")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("labels")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("app")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" es"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("cluster\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("securityContext")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("fsGroup")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("initContainers")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" init"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("sysctl\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("image")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" busybox\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("imagePullPolicy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" IfNotPresent\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("securityContext")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("privileged")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("command")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"sysctl"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"-w"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"vm.max_map_count=262144"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("containers")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" elasticsearch\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("resources")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("requests")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("memory")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 1Gi\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("securityContext")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("privileged")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("runAsUser")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("capabilities")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" IPC_LOCK\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" SYS_RESOURCE\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("image")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" docker.elastic.co/elasticsearch/elasticsearch"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("7.9.1\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("env")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ES_JAVA_OPTS\n          "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("valueFrom")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n              "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("configMapKeyRef")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n                  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" es"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("config\n                  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("key")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ES_JAVA_OPTS\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("readinessProbe")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("httpGet")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("scheme")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" HTTP\n            "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /_cluster/health"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("?")]),t._v("local=true\n            "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("port")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9200")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("initialDelaySeconds")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("ports")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("containerPort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9200")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" es"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("http\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("containerPort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9300")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" es"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("transport\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("volumeMounts")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" es"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("data\n          "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("mountPath")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /usr/share/elasticsearch/data\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" elasticsearch"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("config\n          "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("mountPath")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /usr/share/elasticsearch/config/elasticsearch.yml\n          "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("subPath")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" elasticsearch.yml\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("volumes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" elasticsearch"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("config\n          "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("configMap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" es"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("config\n            "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("items")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n              "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("key")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" elasticsearch.yml\n                "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" elasticsearch.yml\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("volumeClaimTemplates")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" es"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("data\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("accessModes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ReadWriteOnce"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("resources")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("requests")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("storage")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 5Gi\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br"),s("span",{staticClass:"line-number"},[t._v("25")]),s("br"),s("span",{staticClass:"line-number"},[t._v("26")]),s("br"),s("span",{staticClass:"line-number"},[t._v("27")]),s("br"),s("span",{staticClass:"line-number"},[t._v("28")]),s("br"),s("span",{staticClass:"line-number"},[t._v("29")]),s("br"),s("span",{staticClass:"line-number"},[t._v("30")]),s("br"),s("span",{staticClass:"line-number"},[t._v("31")]),s("br"),s("span",{staticClass:"line-number"},[t._v("32")]),s("br"),s("span",{staticClass:"line-number"},[t._v("33")]),s("br"),s("span",{staticClass:"line-number"},[t._v("34")]),s("br"),s("span",{staticClass:"line-number"},[t._v("35")]),s("br"),s("span",{staticClass:"line-number"},[t._v("36")]),s("br"),s("span",{staticClass:"line-number"},[t._v("37")]),s("br"),s("span",{staticClass:"line-number"},[t._v("38")]),s("br"),s("span",{staticClass:"line-number"},[t._v("39")]),s("br"),s("span",{staticClass:"line-number"},[t._v("40")]),s("br"),s("span",{staticClass:"line-number"},[t._v("41")]),s("br"),s("span",{staticClass:"line-number"},[t._v("42")]),s("br"),s("span",{staticClass:"line-number"},[t._v("43")]),s("br"),s("span",{staticClass:"line-number"},[t._v("44")]),s("br"),s("span",{staticClass:"line-number"},[t._v("45")]),s("br"),s("span",{staticClass:"line-number"},[t._v("46")]),s("br"),s("span",{staticClass:"line-number"},[t._v("47")]),s("br"),s("span",{staticClass:"line-number"},[t._v("48")]),s("br"),s("span",{staticClass:"line-number"},[t._v("49")]),s("br"),s("span",{staticClass:"line-number"},[t._v("50")]),s("br"),s("span",{staticClass:"line-number"},[t._v("51")]),s("br"),s("span",{staticClass:"line-number"},[t._v("52")]),s("br"),s("span",{staticClass:"line-number"},[t._v("53")]),s("br"),s("span",{staticClass:"line-number"},[t._v("54")]),s("br"),s("span",{staticClass:"line-number"},[t._v("55")]),s("br"),s("span",{staticClass:"line-number"},[t._v("56")]),s("br"),s("span",{staticClass:"line-number"},[t._v("57")]),s("br"),s("span",{staticClass:"line-number"},[t._v("58")]),s("br"),s("span",{staticClass:"line-number"},[t._v("59")]),s("br"),s("span",{staticClass:"line-number"},[t._v("60")]),s("br"),s("span",{staticClass:"line-number"},[t._v("61")]),s("br"),s("span",{staticClass:"line-number"},[t._v("62")]),s("br"),s("span",{staticClass:"line-number"},[t._v("63")]),s("br"),s("span",{staticClass:"line-number"},[t._v("64")]),s("br"),s("span",{staticClass:"line-number"},[t._v("65")]),s("br"),s("span",{staticClass:"line-number"},[t._v("66")]),s("br"),s("span",{staticClass:"line-number"},[t._v("67")]),s("br"),s("span",{staticClass:"line-number"},[t._v("68")]),s("br"),s("span",{staticClass:"line-number"},[t._v("69")]),s("br"),s("span",{staticClass:"line-number"},[t._v("70")]),s("br"),s("span",{staticClass:"line-number"},[t._v("71")]),s("br"),s("span",{staticClass:"line-number"},[t._v("72")]),s("br"),s("span",{staticClass:"line-number"},[t._v("73")]),s("br"),s("span",{staticClass:"line-number"},[t._v("74")]),s("br"),s("span",{staticClass:"line-number"},[t._v("75")]),s("br"),s("span",{staticClass:"line-number"},[t._v("76")]),s("br"),s("span",{staticClass:"line-number"},[t._v("77")]),s("br"),s("span",{staticClass:"line-number"},[t._v("78")]),s("br"),s("span",{staticClass:"line-number"},[t._v("79")]),s("br"),s("span",{staticClass:"line-number"},[t._v("80")]),s("br"),s("span",{staticClass:"line-number"},[t._v("81")]),s("br"),s("span",{staticClass:"line-number"},[t._v("82")]),s("br"),s("span",{staticClass:"line-number"},[t._v("83")]),s("br"),s("span",{staticClass:"line-number"},[t._v("84")]),s("br"),s("span",{staticClass:"line-number"},[t._v("85")]),s("br"),s("span",{staticClass:"line-number"},[t._v("86")]),s("br"),s("span",{staticClass:"line-number"},[t._v("87")]),s("br"),s("span",{staticClass:"line-number"},[t._v("88")]),s("br"),s("span",{staticClass:"line-number"},[t._v("89")]),s("br"),s("span",{staticClass:"line-number"},[t._v("90")]),s("br"),s("span",{staticClass:"line-number"},[t._v("91")]),s("br"),s("span",{staticClass:"line-number"},[t._v("92")]),s("br"),s("span",{staticClass:"line-number"},[t._v("93")]),s("br"),s("span",{staticClass:"line-number"},[t._v("94")]),s("br"),s("span",{staticClass:"line-number"},[t._v("95")]),s("br"),s("span",{staticClass:"line-number"},[t._v("96")]),s("br"),s("span",{staticClass:"line-number"},[t._v("97")]),s("br"),s("span",{staticClass:"line-number"},[t._v("98")]),s("br"),s("span",{staticClass:"line-number"},[t._v("99")]),s("br"),s("span",{staticClass:"line-number"},[t._v("100")]),s("br"),s("span",{staticClass:"line-number"},[t._v("101")]),s("br"),s("span",{staticClass:"line-number"},[t._v("102")]),s("br"),s("span",{staticClass:"line-number"},[t._v("103")]),s("br"),s("span",{staticClass:"line-number"},[t._v("104")]),s("br"),s("span",{staticClass:"line-number"},[t._v("105")]),s("br"),s("span",{staticClass:"line-number"},[t._v("106")]),s("br"),s("span",{staticClass:"line-number"},[t._v("107")]),s("br"),s("span",{staticClass:"line-number"},[t._v("108")]),s("br"),s("span",{staticClass:"line-number"},[t._v("109")]),s("br"),s("span",{staticClass:"line-number"},[t._v("110")]),s("br"),s("span",{staticClass:"line-number"},[t._v("111")]),s("br"),s("span",{staticClass:"line-number"},[t._v("112")]),s("br"),s("span",{staticClass:"line-number"},[t._v("113")]),s("br"),s("span",{staticClass:"line-number"},[t._v("114")]),s("br")])]),s("p",[s("strong",[t._v('出现如此大量的细节配置, 其根本原因在于 Kubernetes 完全不知道 Elasticsearch 是什么, 所有 Kubernetes 不知道的信息, 不能启发式推断出来的信息, 都必须由用户在资源的元数据定义中明确列出, 必须一步一步, 手把手地"教会" Kubernetes 如何部署 Elasticsearch, 这种形式就属于 Red Hat 在 Operator 设计理念介绍中所说的"低级操作"')]),t._v(" .")]),t._v(" "),s("p",[t._v("如果使用 Elastic.co 官方提供的 Operator, 那情况就会简单得多. "),s("strong",[t._v("Elasticsearch Operator")]),t._v(' 提供了一种 kind:Elasticsearch 的自定义资源, 在它的帮助下, 仅需十行代码, 将用户的意图是 "部署三个版本为 7.9.1 的 ES 集群节点" 说清楚, 便能实现与前面 StatefulSet 那一大堆配置相同乃至更强大的效果, 如下面代码所示.')]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" elasticsearch.k8s.elastic.co/v1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Elasticsearch\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" elasticsearch"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("cluster\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("version")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 7.9.1\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("nodeSets")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" default\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("count")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("config")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("node.master")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("node.data")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("node.ingest")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("node.store.allow_mmap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("false")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br")])]),s("p",[t._v('有了 Elasticsearch Operator 的自定义资源, 相当于 Kubernetes 已经学会了怎样操作 Elasticsearch, 知道所有与它相关的参数含义与默认值, 而无须用户再手把手地教了, 这种就是所谓的 "高级指令".')]),t._v(" "),s("p",[t._v("Operator 将简洁的高级指令转化为 Kubernetes 中具体操作的方法, 与前面 Helm 或者 Kustomize 的方法并不相同. "),s("strong",[t._v("Helm 和 Kustomize 最终仍然是依靠 Kubernetes 的内置资源来跟 Kubernetes 打交道的, Operator 则要求开发者自己实现一个专门针对该自定义资源的控制器, 在控制器中维护自定义资源的期望状态")]),t._v(". 通过程序编码来扩展 Kubernetes, 比只通过内置资源来扩展要灵活得多, 譬如当需要更新集群中某个 Pod 对象的时候, 由 Operator 的开发者自己编码实现的控制器完全可以在原地对 Pod 进行重启, 而无须像 Deployment 那样必须先删除旧的 Pod, 再创建新的 Pod.")]),t._v(" "),s("p",[t._v("使用 CRD 定义高层次资源, 使用配套的控制器来维护期望状态, 带来的好处不仅仅是操作更加便捷, 而是"),s("strong",[t._v("在遵循 Kubernetes 一贯基于资源与控制器的设计原则的同时, 又不必再受制于 Kubernetes 内置资源的表达能力")]),t._v(". 只要 Operator 的开发者愿意编写代码, "),s("strong",[t._v("前面曾经提到的那些 StatefulSet 不能支持的能力, 如备份恢复数据, 创建/删除索引, 调整平衡策略等操作, 都完全可以实现")]),t._v(".")]),t._v(" "),s("p",[t._v("把运维的操作封装在程序代码中, 表面看最大的受益者是运维人员, 开发人员要为此付出更多劳动. 然而 Operator 并没有受到开发人员的抵制, 反而因代码相对于资源配置的表达能力的提升, 以及开发与运维之间协作成本的降低而备受好评. Operator 变成了近两, 三年容器封装应用的一股新潮流, 现在很多复杂的分布式系统都有了官方或者第三方提供的Operator. Red Hat 公司也持续在 "),s("strong",[t._v("Operator")]),t._v(" 上面大量投入, 推出了简化开发人员编写 Operator 的Operator Framework/SDK.")]),t._v(" "),s("p",[s("strong",[t._v("目前看来, Operator 也许是应对有状态应用的封装运维的最有可行性的方案")]),t._v(", 但这依然不是一项轻松的工作. 以 etcd 的 Operator 为例, etcd 本身不算什么特别复杂的应用, Operator 实现的功能看起来也相当基础, 主要有创建集群, 删除集群, 扩容缩容, 故障转移, 滚动更新, 备份恢复等功能, 但代码已经超过一万行了. 现在开发 Operator 的门槛的确相对较高, 通常由专业的平台开发人员而非业务开发或者运维人员去完成, "),s("strong",[t._v("但是 Operator 符合技术潮流, 顺应软件业界所提倡的 DevOps 一体化理念, 待 Operator 的生态进一步成熟之后, 开发和运维人员都将能从中受益, 未来应该能成长为一种应用封装的主流形式")]),t._v(".")]),t._v(" "),s("h5",{attrs:{id:"_4-开放应用模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-开放应用模型"}},[t._v("#")]),t._v(" 4.开放应用模型")]),t._v(" "),s("p",[t._v("本节介绍的最后一种应用封装的方案, 是阿里云和微软公司在 2019 年 10 月上海 QCon 大会上联合发布的"),s("strong",[t._v("开放应用模型(Open Application Model, OAM)")]),t._v(" , 它不仅是中国云计算企业参与制定乃至主导发起的国际技术规范, 也是业界首个"),s("strong",[t._v("云原生应用标准定义与架构模型")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("开放应用模型思想的核心是如何分离开发人员, 运维人员与平台人员的关注点, 即开发人员关注业务逻辑的实现, 运维人员关注程序平稳运行, 平台人员关注基础设施的能力与稳定性")]),t._v(", 长期让几个角色关注同一个 All-in-One 资源文件, 并不能擦出什么火花, 反而会将配置工作弄得越来越复杂.")]),t._v(" "),s("p",[t._v('开放应用模型把云原生应用定义为 "'),s("strong",[t._v("由一组相互关联但又离散独立的组件构成, 这些组件实例化在合适的运行时上, 由配置来控制行为并共同协作提供统一的功能")]),t._v('". 为了便于跟稍后的概念对应, 笔者首先把这句话拆解, 翻译为另一种形式.')]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("OAM 定义的应用")]),t._v(" "),s("p",[t._v("一个 Application 由一组 "),s("strong",[t._v("Component")]),t._v(" 构成, 每个 Component 的运行状态由 "),s("strong",[t._v("Workload")]),t._v(" 描述, 每个 Component 可以施加 Trait 来获取额外的运维能力, 同时可以使用 Application Scope 将 Components 划分到一个或者多个应用边界中, 便于统一配置, 限制, 管理. "),s("strong",[t._v("把 Component, Trait 和 Scope 组合在一起实例化部署, 形成具体的 Application Configuration, 以实现应用的多实例部署与升级")]),t._v(".")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("然后, 笔者通过"),s("strong",[t._v("解析上述所列的核心概念")]),t._v("来帮助你理解 OAM 对应用的定义. 这句话里面每一个用英文标注出来的技术名词都是 OAM 在 Kubernetes 基础上扩展而来概念, 每一个名词都有专门的自定义资源与之对应, 换而言之, 它们并非纯粹的抽象概念, 而是可以被实际使用的"),s("strong",[t._v("自定义资源")]),t._v(". 这些概念的具体含义如下.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("Component(服务组件)")]),t._v(' : 由 Component 构成应用的思想自 SOA 以来就屡见不鲜了, 然而 OAM 的 Component 不仅仅特指构成应用 "整体" 的一个 "部分", 它还有一个重要职责是抽象那些应该由开发人员关注的元素. 譬如应用的名字, 自述, 容器镜像, 运行所需的参数, 等等.')]),t._v(" "),s("li",[s("strong",[t._v("Workload(工作负荷)")]),t._v(" : Workload 决定了应用的"),s("strong",[t._v("运行模式")]),t._v(', 每个 Component 都要设定自己的 Workload 类型, OAM 按照 "是否可访问, 是否可复制, 是否长期运行" 预定义了六种 Workload 类型. 如有必要还可以通过 CRD 与 Operator 去扩展.')]),t._v(" "),s("li",[s("strong",[t._v("Trait(运维特征)")]),t._v(" : 开发活动有大量"),s("strong",[t._v("复用功能")]),t._v("的技巧, 但运维活动却很贫乏, 平时能写个 Shell 脚本或者简单工具已经算是个高级的运维人员了. OAM 的 Trait 就用于封装模块化后的运维能力, 可以针对运维中的可重复操作预先设定好一些"),s("strong",[t._v("具体的 Trait")]),t._v(", 譬如日志收集 Trait, 负载均衡 Trait, 水平扩缩容 Trait 等. 这些预定义的 Traits 定义里, 会注明它们可以作用于哪种类型的工作负荷, 能填哪些参数, 哪些必填项, 参数的作用描述是什么, 等等.")]),t._v(" "),s("li",[s("strong",[t._v("Application Scope(应用边界)")]),t._v(" : 多个 Component 共同组成一个 "),s("strong",[t._v("Scope")]),t._v(", 可以根据 Component 的特性或者作用域来划分 Scope, 譬如具有"),s("strong",[t._v("相同网络策略的 Component 放在同一个 Scope 中")]),t._v(", 具有相同健康度量策略的 Component 放到另一个 Scope 中. 同时, 一个 Component 也可能属于多个 Scope, 譬如一个 Component 完全可能既需要配置网络策略, 也需要配置健康度量策略.")]),t._v(" "),s("li",[s("strong",[t._v("Application Configuration(应用配置)")]),t._v(" : 将 "),s("strong",[t._v("Component(必需), Trait(必需), Scope(非必需)组合到一起进行实例化")]),t._v(", 就形成了一个完整的应用配置.")])]),t._v(" "),s("p",[s("strong",[t._v("OAM 使用上述介绍的这些自定义资源对原先 All-in-One 的复杂配置做了一定层次的解耦, 开发人员负责管理 Component; 运维人员负责将 Component 组合并与 Trait 绑定变成 Application Configuration; 平台人员或基础设施提供方负责提供 OAM 的解释能力, 将这些自定义资源映射到实际的基础设施中. 不同角色分工协作, 整体简化了单个角色关注的内容, 使得不同角色可以更聚焦, 更专业地做好本角色的工作")]),t._v(", 整个过程如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230103222503530.png",alt:"image-20230103222503530",title:"OAM角色关系图"}})]),t._v(" "),s("p",[t._v("OAM 未来能否成功, 很大程度上取决于"),s("strong",[t._v("云计算厂商的支持力度")]),t._v(", 因为 OAM 的自定义资源一般是由"),s("strong",[t._v("云计算基础设施负责解释和驱动")]),t._v("的, 譬如阿里云的 EDAS 就已内置了对 OAM 的支持. 如果你希望能够应用于私有 Kubernetes 环境, 目前 OAM 的主要参考实现是 Rudr(已声明废弃)和 Crossplane. Crossplane 是一个仅发起一年多的 CNCF 沙箱项目, 主要参与者包括阿里云, 微软, Google, Red Hat 等公司的工程师. Crossplane 提供了 OAM 中全部的自定义资源以及控制器, 安装后便可用 OAM 定义的资源来描述应用.")]),t._v(" "),s("h4",{attrs:{id:"后记"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#后记"}},[t._v("#")]),t._v(" 后记")]),t._v(" "),s("p",[t._v("今天容器圈的发展一日千里, 各种新规范, 新技术层出不穷, 本节根据人气和代表性, 列举了其中最出名的四种, 其他未提到的应用封装技术还有 CNAB, Armada, Pulumi 等. 这些封装技术的功能会有一定的重叠, 但并非都是重复的轮子, 实际应用时往往会联合其中多个工具一起使用. "),s("strong",[t._v("应该如何封装应用才是最佳的实践, 目前尚且没有定论, 但是以应用为中心的理念却已经成为明确的共识")]),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"容器间网络"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器间网络"}},[t._v("#")]),t._v(" 容器间网络")]),t._v(" "),s("p",[t._v("本章将讨论"),s("strong",[t._v("虚拟化网络方面")]),t._v('的话题, 如果不加任何限定, "虚拟化网络" 是一项内容十分丰富, 研究历史十分悠久的计算机技术, 是计算机科学中一门独立的分支, 完全不依附于虚拟化容器而存在. 网络运营商常提及的 "网络功能虚拟化"(Network Function Virtualization, NFV), 网络设备商和网络管理软件提供商常提及的"软件定义网络"(Software Defined Networking, SDN)等都属于虚拟化网络的范畴. 对于普通的软件开发者而言, 要完全理解和掌握虚拟化网络, 需要储备大量开发中不常用到的专业知识, 消耗大量的时间成本, 一般并无必要.')]),t._v(" "),s("p",[t._v("本节讨论的虚拟化网络是"),s("strong",[t._v("狭义")]),t._v('的, 它特指 "'),s("strong",[t._v("如何基于 Linux 系统的网络虚拟化技术来实现容器间网络通信")]),t._v('", 更通俗一点, 就是只关注那些为了'),s("strong",[t._v("使相互隔离的 Linux 网络名称空间可相互通信而设计出来的虚拟化网络设施")]),t._v(', 讨论这个问题所需的网络知识, 基本还是在普通开发者应该具有的合理知识范畴之内. 在这个语境中的 "'),s("strong",[t._v("虚拟化网络")]),t._v('" 就是直接为'),s("strong",[t._v("容器服务")]),t._v('的, 说它是依附于容器而存在亦无不可, 因此为避免混淆, 在后文中会尽量回避 "虚拟化网络" 这个范畴过大的概念, 而是以 "Linux 网络虚拟化" 和 "容器网络与生态" 为题来展开.')]),t._v(" "),s("h4",{attrs:{id:"linux网络虚拟化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linux网络虚拟化"}},[t._v("#")]),t._v(" Linux网络虚拟化")]),t._v(" "),s("p",[t._v("在 Linux 目前提供的八种名称空间里, "),s("strong",[t._v("网络名称空间无疑是隔离内容最多的一种")]),t._v(", 它为名称空间内的"),s("strong",[t._v("所有进程提供了全套的网络设施, 包括独立的设备界面, 路由表, ARP 表, IP 地址表, iptables/ebtables 规则, 协议栈")]),t._v(", 等等. 虚拟化容器是以 "),s("strong",[t._v("Linux 名称空间的隔离性")]),t._v("为基础来实现的, 所以解决隔离的容器之间, 容器与宿主机之间, 乃至跨物理网络的不同容器间通信问题的责任, 很自然也落在了 Linux "),s("strong",[t._v("网络虚拟化")]),t._v("技术的肩上. 本节将暂时放下容器编排, 云原生, 微服务等这些上层概念, 走入 "),s("strong",[t._v("Linux 网络的底层世界")]),t._v(", 去学习一些与设备, 协议, 通信相关的基础网络知识.")]),t._v(" "),s("p",[t._v("本节的阅读对象设定为以实现业务功能为主, 平常并不直接接触网络设备的普通开发人员.")]),t._v(" "),s("h5",{attrs:{id:"_1-网络通信模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-网络通信模型"}},[t._v("#")]),t._v(" 1.网络通信模型")]),t._v(" "),s("p",[t._v("如果抛开虚拟化, 只谈网络的话, 笔者认为首先应该了解的知识是 "),s("strong",[t._v("Linux 系统的网络通信模型")]),t._v(', 即信息是如何从程序中发出, 通过网络传输, 再被另一个程序接收到的. 从整体上看, Linux 系统的通信过程无论按理论上的 OSI 七层模型, 还是以实际上的 TCP/IP 四层模型来解构, 都明显呈现出 "'),s("strong",[t._v("逐层调用, 逐层封装")]),t._v('" 的特点, 这种逐层处理的方式与栈结构, 譬如程序执行时的方法栈很类似, 因此它通常被称为 "'),s("strong",[t._v("Linux 网络协议栈")]),t._v('", 简称"网络栈", 有时也称"协议栈". 下图体现了 Linux 网络通信过程与 OSI 或者 TCP/IP 模型的对应关系, 也展示了网络栈中的数据流动的路径.')]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230105222009904.png",alt:"image-20230105222009904",title:"Linux系统的网络通信模型"}})]),t._v(" "),s("p",[t._v("在上图中传输模型的左侧, 笔者特别标出了网络栈在"),s("strong",[t._v("用户空间与内核空间")]),t._v("的部分, 可见几乎整个网络栈(应用层以下)都位于系统内核空间之中. 之所以采用这种设计, 主要是从"),s("strong",[t._v("数据安全隔离")]),t._v("的角度来考虑的. 由"),s("strong",[t._v("内核去处理网络报文的收发, 无疑会有更高的执行开销, 譬如数据在内核态和用户态之间来回复制的额外成本, 因此会损失一些性能, 但是能够保证应用程序无法窃听或者伪造另一个应用程序的通信内容")]),t._v(". 针对特别关注收发性能的应用场景, 也有直接在用户空间中实现全套协议栈的旁路方案, 譬如开源的 Netmap 以及 Intel 的 DPDK, 都能做到零复制收发网络数据包.")]),t._v(" "),s("p",[t._v("上图中传输模型的箭头展示的是数据流动的方向, 它体现了信息从程序中发出以后, 到被另一个程序接收到之前, 将经历如下几个阶段.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("Socket")]),t._v(": 应用层的程序是通过 "),s("strong",[t._v("Socket 编程接口与内核空间的网络协议栈通信")]),t._v("的. 现在 Socket 已经不局限于某个操作系统的专属功能, "),s("strong",[t._v("成为各大主流操作系统共同支持的通用网络编程接口, 是网络应用程序实际的交互基础")]),t._v(". "),s("strong",[t._v("应用程序通过读写收, 发缓冲区(Receive/Send Buffer)来与 Socket 进行交互")]),t._v(', 在 UNIX 和 Linux 系统中, 出于 "一切皆是文件" 的设计哲学, '),s("strong",[t._v("对 Socket 的操作被实现为对文件系统(socketfs)的读写访问操作, 通过文件描述符(File Descriptor)来进行")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("TCP/UDP")]),t._v(": 传输层协议族里最重要的协议无疑是"),s("strong",[t._v("传输控制协议")]),t._v("(Transmission Control Protocol, TCP)和"),s("strong",[t._v("用户数据报协议")]),t._v("(User Datagram Protocol, UDP)两种, 它们也是 Linux 内核中直接支持的协议. 此外还有流控制传输协议(Stream Control Transmission Protocol, SCTP), 数据报拥塞控制协议(Datagram Congestion Control Protocol, DCCP)等. 不同协议的处理流程大致是一样的, 只是封装的报文以及头, 尾部信息会有所不同. 这里以 TCP 协议为例, 内核发现 Socket 的"),s("strong",[t._v("发送缓冲区中有新的数据被复制进来后")]),t._v(", 会把"),s("strong",[t._v("数据封装为 TCP Segment 报文")]),t._v(", 常见网络协议的报文基本上都是由报文头(Header)和报文体(Body, 也叫 Payload)两部分组成. 系统内核将缓冲区中用户要发送出去的数据作为报文体, 然后把传输层中的必要控制信息, 譬如代表哪个程序发, 由哪个程序收的源, 目标端口号, 用于保证可靠通信(重发与控制顺序)的序列号, 用于校验信息是否在传输中出现损失的校验和(Check Sum)等信息"),s("strong",[t._v("封装入报文头")]),t._v("中.")]),t._v(" "),s("li",[s("strong",[t._v("IP")]),t._v(": 网络层协议最主要就是"),s("strong",[t._v("网际协议")]),t._v("(Internet Protocol, IP), 其他还有因特网组管理协议(Internet Group Management Protocol, "),s("strong",[t._v("IGMP")]),t._v("), 大量的路由协议(EGP, NHRP, OSPF, IGRP)等. 以 IP 协议为例, 它会将来自上一层(本例中的 TCP 报文)的数据包作为"),s("strong",[t._v("报文体")]),t._v(", 再次加入自己的报文头, 譬如指明数据应该发到哪里的路由地址, 数据包的长度, 协议的版本号, 等等, 封装成 IP 数据包后再发往下一层.")]),t._v(" "),s("li",[s("strong",[t._v("Device")]),t._v(": 网络设备是网络访问层中"),s("strong",[t._v("面向系统一侧的接口")]),t._v(", 这里所说的设备与物理硬件设备并不是同一个概念, "),s("strong",[t._v("Device 只是一种向操作系统端开放的接口")]),t._v(", 其背后既可能代表真实的物理硬件, 也可能是某段具有特定功能的程序代码, 譬如即使不存在物理网卡, 也依然可以存在回环设备(Loopback Device). 许多"),s("strong",[t._v("网络抓包工具")]),t._v(", 如 tcpdump, Wirshark 便是"),s("strong",[t._v("在此处工作")]),t._v("的, 前面介绍微服务流量控制时曾提到的"),s("strong",[t._v("网络流量整形")]),t._v(", 通常也是在这里完成的. "),s("strong",[t._v("Device 的主要作用是抽象出统一的界面, 让程序代码去选择或影响收发包出入口, 譬如决定数据应该从哪块网卡设备发送出去; 准备好网卡驱动工作所需的数据, 譬如来自上一层的 IP 数据包, 下一跳(Next Hop)的 MAC 地址(这个地址是通过 ARP Request 得到的)等")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("Driver")]),t._v(": 网卡驱动程序是"),s("strong",[t._v("网络访问层中面向硬件一侧的接口")]),t._v(", 它会通过 DMA 将主存中待发送的数据包复制到驱动内部的缓冲区之中. 数据被复制的同时, 也会将上层提供的 IP 数据包, 下一跳 MAC 地址这些信息, 加上网卡的 MAC 地址, VLAN Tag 等信息一并封装成"),s("strong",[t._v("以太帧")]),t._v("(Ethernet Frame), 并自动计算校验和. 对于需要确认重发的信息, 如果没有收到接收者的确认(ACK)响应, 那重发的处理也是在这里自动完成的.")])]),t._v(" "),s("p",[t._v("上面这些阶段是信息从程序中对外发出时经过协议栈的过程, 接收过程则是从相反方向进行的逆操作. 程序发送数据做的是层层封包, 加入协议头, 传给下一层; 接收数据则是层层解包, 提取协议体, 传给上一层, 可以类比来理解数据包接收过程, 这里就不再专门列举了.")]),t._v(" "),s("h5",{attrs:{id:"_2-干预网络通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-干预网络通信"}},[t._v("#")]),t._v(" 2.干预网络通信")]),t._v(" "),s("p",[t._v("网络协议栈的处理是一套相对固定和封闭的流程, 整套处理过程中, 除了在网络设备层能看到一点点程序以设备的形式介入处理的空间外, 其他过程似乎就没有什么可供程序插手的空间了. 然而事实并非如此, 从 Linux Kernel 2.4 版本开始, 内核开放了一套"),s("strong",[t._v("通用的, 可供代码干预数据在协议栈中流转的过滤器框架")]),t._v(". 这套名为 "),s("strong",[t._v("Netfilter")]),t._v(" 的框架是 Linux 防火墙和网络的主要维护者 Rusty Russell 提出并主导设计的, 它"),s("strong",[t._v("围绕网络层(IP 协议)的周围, 埋下了五个钩子(Hook), 每当有数据包流到网络层, 经过这些钩子时, 就会自动触发由内核模块注册在这里的回调函数, 这样程序代码就能够通过回调函数来干预 Linux 的网络通信")]),t._v(", 如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230105225202585.png",alt:"",title:"应用收, 发数据包所经过的Netfilter钩子"}})]),t._v(" "),s("p",[t._v("这五个钩子的名字与含义如下.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("PREROUTING")]),t._v(": 来自设备的数据包进入协议栈后"),s("strong",[t._v("立即触发此钩子")]),t._v(". PREROUTING 钩子在进入 IP 路由之前触发, 这意味着"),s("strong",[t._v("只要接收到数据包, 无论是否真的发往本机, 都会触发此钩子. 一般用于目标网络地址转换(Destination NAT, DNAT)")]),t._v(" .")]),t._v(" "),s("li",[s("strong",[t._v("INPUT")]),t._v(": 报文经过 IP 路由后, 如果确定是发往本机的, 将会触发此钩子, 一般用于"),s("strong",[t._v("加工发往本地进程的数据包")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("FORWARD")]),t._v(": 报文经过 IP 路由后, 如果确定不是发往本机的, 将会触发此钩子, 一般用于"),s("strong",[t._v("处理转发到其他机器的数据包")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("OUTPUT")]),t._v(": 从本机程序发出的数据包, 在经过 IP 路由前, 将会触发此钩子, 一般用于"),s("strong",[t._v("加工本地进程的输出数据包")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("POSTROUTING")]),t._v(": 从本机网卡发出的数据包, 无论是本机的程序所发出的, 还是由本机转发给其他机器的, 都会触发此钩子, 一般用于"),s("strong",[t._v("源网络地址转换(Source NAT, SNAT)")]),t._v(" .")])]),t._v(" "),s("p",[t._v("Netfilter 允许在"),s("strong",[t._v("同一个钩子处注册多个回调函数, 因此向钩子注册回调函数时必须提供明确的优先级, 以便触发时能按照优先级从高到低进行激活")]),t._v('. 由于回调函数会存在多个, 看起来就像挂在同一个钩子上的一串链条, 因此钩子触发的回调函数集合被称为 "'),s("strong",[t._v("回调链")]),t._v('"(Chained Callback), 这个名字也导致后续基于 Netfilter 设计的 Xtables 系工具, 如稍后介绍的 iptables 均有使用到 "链"(Chain)的概念. 虽然现在看来 Netfilter 只是一些简单的事件回调机制, 然而这样一套简单的设计, 却成为'),s("strong",[t._v("整座 Linux 网络大厦的核心基石")]),t._v(", Linux 系统提供的"),s("strong",[t._v("许多网络能力, 如数据包过滤, 封包处理(设置标志位, 修改TTL等), 地址伪装, 网络地址转换, 透明代理, 访问控制, 基于协议类型的连接跟踪, 带宽限速, 等等, 都是在 Netfilter 基础之上实现的")]),t._v(".")]),t._v(" "),s("p",[t._v("以 Netfilter 为基础的应用有很多, 其中使用最广泛的无疑要数 "),s("strong",[t._v("Xtables")]),t._v(" 系列工具, 譬如 "),s("strong",[t._v("iptables")]),t._v(', ebtables, arptables, ip6tables 等. iptables 常被称为 Linux 系统 "'),s("strong",[t._v("自带的防火墙")]),t._v('", 然而 iptables 实际能做的事情已远远超出防火墙的范畴, 严谨地讲, iptables 比较贴切的定位应是'),s("strong",[t._v("能够代替 Netfilter 多数常规功能的 IP 包过滤工具")]),t._v(". 由于 Netfilter 的钩子回调虽然很强大, 但仍要通过"),s("strong",[t._v("程序编码")]),t._v("才能使用, 并不适合系统管理员用来日常运维, 而"),s("strong",[t._v("设计 iptables 的目的便是以配置去实现原本用 Netfilter 编码才能做到的事情")]),t._v(". iptables 先把用户常用的管理意图总结成具体的行为"),s("strong",[t._v("预先准备好, 然后在满足条件时自动激活行为")]),t._v(". 以下列出了部分 iptables "),s("strong",[t._v("预置的行为")]),t._v(".")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("DROP")]),t._v(": 直接将数据包丢弃.")]),t._v(" "),s("li",[s("strong",[t._v("REJECT")]),t._v(": 向客户端返回 Connection Refused 或 Destination Unreachable 报文.")]),t._v(" "),s("li",[s("strong",[t._v("QUEUE")]),t._v(": 将数据包放入用户空间的队列, 供用户空间的程序处理.")]),t._v(" "),s("li",[s("strong",[t._v("RETURN")]),t._v(": 跳出当前链, 该链里后续的规则不再执行.")]),t._v(" "),s("li",[s("strong",[t._v("ACCEPT")]),t._v(": 同意数据包通过, 继续执行后续的规则.")]),t._v(" "),s("li",[s("strong",[t._v("JUMP")]),t._v(": 跳转到其他用户自定义的链继续执行.")]),t._v(" "),s("li",[s("strong",[t._v("REDIRECT")]),t._v(": 在本机做端口映射.")]),t._v(" "),s("li",[s("strong",[t._v("MASQUERADE")]),t._v(": 地址伪装, 自动用修改源或目标的 IP 地址来做网络地址转换.")]),t._v(" "),s("li",[s("strong",[t._v("LOG")]),t._v(": 在 /var/log/messages 文件中记录日志信息.")])]),t._v(" "),s("p",[t._v("这些行为本来能够被挂载到 Netfilter 钩子的回调链上, 但 iptables 进行了一层"),s("strong",[t._v("额外抽象")]),t._v(", 不是把行为与链直接挂钩, 而是根据这些底层操作的目的, 先总结为"),s("strong",[t._v("更高层次的规则")]),t._v('. 举个例子, 假设挂载规则的目的是实现网络地址转换, 那就应该对符合某种特征的流量(譬如来源于某个网段, 从某张网卡发送出去), 在某个钩子上(譬如通常在 POSTROUTING 做 SNAT, 通常在 PREROUTING 做 DNAT)进行 MASQUERADE 行为, 这样具有相同目的的规则, 就应该放到一起才便于管理, 由此便形成 "'),s("strong",[t._v("规则表")]),t._v('" 的概念. iptables 内置了五张'),s("strong",[t._v("不可扩展的规则表")]),t._v("(其中 security 表并不常用, 很多资料只计算了前四张表), 如下所示.")]),t._v(" "),s("p",[t._v("(1)"),s("strong",[t._v("raw 表")]),t._v(": 用于去除数据包上的连接追踪机制(Connection Tracking).")]),t._v(" "),s("p",[t._v("(2)"),s("strong",[t._v("mangle 表")]),t._v(": 用于修改数据包的报文头信息, 如服务类型(Type of Service, ToS), 生存周期(Time to Live, TTL)以及为数据包设置 Mark 标记, 典型的应用是链路的服务质量管理(Quality of Service, QoS).")]),t._v(" "),s("p",[t._v("(3)"),s("strong",[t._v("nat 表")]),t._v(": 用于修改数据包的源或者目的地址等信息, 典型的应用是"),s("strong",[t._v("网络地址转换")]),t._v(".")]),t._v(" "),s("p",[t._v("(4)"),s("strong",[t._v("filter 表")]),t._v(": 用于对数据包进行过滤, 控制到达某条链上的数据包是继续放行, 直接丢弃或拒绝(ACCEPT, DROP, REJECT), 典型的应用是"),s("strong",[t._v("防火墙")]),t._v(".")]),t._v(" "),s("p",[t._v("(5)"),s("strong",[t._v("security 表")]),t._v(": 用于在数据包上应用 SELinux, 这张表并不常用.")]),t._v(" "),s("p",[t._v("以上五张规则表是具有优先级的: raw -> mangle -> nat -> filter -> security, 也即上面列举它们的顺序. 在 iptables 中"),s("strong",[t._v("新增规则")]),t._v("时, 需要"),s("strong",[t._v("按照规则的意图指定要存入哪张表中, 如果没有指定, 将默认存入 filter 表")]),t._v(". 此外, 每张表能够使用到的链也有所不同, 具体表与链的对应关系如下表所示.")]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("表与链的对应关系")])])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}}),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("PREROUTING")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("POSTROUTING")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("FORWARD")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("INPUT")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("OUTPUT")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("raw")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("mangle")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("nat(Source)")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("nat(Destination)")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("filter")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("Security")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")])])])]),t._v(" "),s("p",[t._v("从名字上就能看出预置的"),s("strong",[t._v("五条链直接源自于 Netfilter 的钩子")]),t._v(", 它们与五张规则表的对应关系是"),s("strong",[t._v("固定的")]),t._v(", 用户不能增加自定义的表, 或者修改已有表与链的关系, 但可以增加自定义的链, 新增的自定义链与 Netfilter 的钩子没有天然的对应关系, 换言之就是不会被自动触发, 只有显式使用 JUMP 行为, 从默认的五条链中跳转过去才能被执行.")]),t._v(" "),s("p",[t._v("iptables 不仅仅是 Linux 系统自带的一个网络工具, 它在"),s("strong",[t._v("容器间通信中也扮演着相当重要的角色")]),t._v(". 譬如 Kubernetes 用来管理 Service 的 Endpoints 的"),s("strong",[t._v("核心组件 kube-proxy, 就依赖 iptables 来完成 ClusterIP 到 Pod 的通信")]),t._v("(也可以采用 IPVS, IPVS 同样是基于 Netfilter 的), 这种通信的本质就是一种 "),s("strong",[t._v("NAT 访问")]),t._v(". 对于 Linux 用户, 以上都是相当基础的网络常识, 但如果平常较少在 Linux 系统下工作, 就可能需要一些用 iptables 充当防火墙过滤数据, 充当路由器转发数据, 充当网关做 NAT 的实际例子来帮助理解.")]),t._v(" "),s("p",[t._v("本章用了两个小节的篇幅去介绍 Linux 下网络通信的协议栈模型, 以及程序如何干涉在协议栈中流动的信息, 它们与虚拟化并没有什么直接关系, 是整个 Linux 网络通信的必要基础. 下一节开始就开始专注与网络虚拟化密切相关的内容了.")]),t._v(" "),s("h5",{attrs:{id:"_3-虚拟化网络设备"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-虚拟化网络设备"}},[t._v("#")]),t._v(" 3.虚拟化网络设备")]),t._v(" "),s("p",[t._v("虚拟化网络并不需要完全遵照物理网络的样子来设计, 不过, 由于已有大量现成的代码原本就是面向物理存在的网络设备来编码实现, 也出于方便理解和知识继承方面的考虑, 虚拟化网络与物理网络中的设备还是有相当高的相似性的. 所以, 笔者准备从"),s("strong",[t._v("网络中那些与网卡, 交换机, 路由器等对应的虚拟设施")]),t._v(", 以及如何使用这些虚拟设施来组成网络入手, 介绍"),s("strong",[t._v("容器间网络的通信基础设施")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_1-网卡-tun-tap-veth"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-网卡-tun-tap-veth"}},[t._v("#")]),t._v(" (1)网卡:tun/tap, veth")]),t._v(" "),s("p",[t._v("目前主流的"),s("strong",[t._v("虚拟网卡")]),t._v("方案有 "),s("strong",[t._v("tun/tap 和 veth")]),t._v(" 两种, 在时间上 tun/tap 出现得更早, 它是一组通用的虚拟驱动程序包, 里面包含两个设备, 分别是用于"),s("strong",[t._v("网络数据包处理的虚拟网卡驱动")]),t._v(", 以及用于内核空间与用户空间交互的字符设备(Character Device, 这里具体指 /dev/net/tun)驱动. 大概在 2000 年左右, Solaris 系统为了实现隧道协议(Tunneling Protocol)开发了这套驱动, 并从 Linux Kernel 2.1 版开始移植到 Linux 内核中, 当时是源码中的可选模块, 2.4 版之后发布的内核都会默认编译 tun/tap 的驱动.")]),t._v(" "),s("p",[t._v("tun 和 tap 是两个相对独立的"),s("strong",[t._v("虚拟网络设备")]),t._v(", 其中 "),s("strong",[t._v("tap 模拟了以太网设备, 操作二层数据包(以太帧), tun 则模拟了网络层设备")]),t._v(", 操作三层数据包(IP 报文). "),s("strong",[t._v("使用 tun/tap 设备的目的是实现把来自协议栈的数据包先交由某个打开了 /dev/net/tun 字符设备的用户进程处理后, 再把数据包重新发回到链路中")]),t._v(". 可以通俗地理解为它"),s("strong",[t._v("一端连接着网络协议栈, 另一端连接着用户态程序")]),t._v(", 而"),s("strong",[t._v("普通的网卡驱动则是一端连接着网络协议栈, 另一端连接着物理网卡")]),t._v(". 只要协议栈中的数据包能被用户态程序截获并加工处理, 程序员就有足够的舞台空间去玩出各种花样, 譬如"),s("strong",[t._v("数据压缩, 流量加密, 透明代理")]),t._v("等功能都能够以此为基础来实现, 以最典型的 VPN 应用程序为例, 程序发送给 "),s("strong",[t._v("tun 设备的数据包")]),t._v(", 会经过下图所示的顺序流进 VPN 程序.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230109215138478.png",alt:"",title:"VPN中数据流动示意图"}})]),t._v(" "),s("p",[t._v("应用程序通过 tun0 设备"),s("strong",[t._v("对外发送")]),t._v("数据包后, tun0 设备如果发现另一端的字符设备已被 "),s("strong",[t._v("VPN 程序打开")]),t._v("(这就是一端连接着网络协议栈, 另一端连接着用户态程序), 便会"),s("strong",[t._v("把数据包通过字符设备发送给 VPN 程序")]),t._v(", VPN 收到数据包, 会修改后再将其"),s("strong",[t._v("封装成新报文")]),t._v(", 譬如"),s("strong",[t._v("数据包原本是发送给 A 地址的, VPN 把整个包进行加密, 然后作为报文体, 封装到另一个发送给 B 地址的新数据包当中")]),t._v('. 这种将一个数据包套进另一个数据包的处理方式被形象地形容为 "'),s("strong",[t._v("隧道")]),t._v('"(Tunneling), 隧道技术是在物理网络中构筑逻辑网络的经典做法. 而其中提到的加密, 也有标准的协议可遵循, 譬如 IPSec 协议.')]),t._v(" "),s("p",[t._v("使用 tun/tap 设备传输数据需要"),s("strong",[t._v("经过两次协议栈")]),t._v(", 不可避免地会有一定的"),s("strong",[t._v("性能损耗")]),t._v(", 如果条件允许, 容器对容器的直接通信并不会把 tun/tap 作为首选方案, 一般是基于稍后介绍的 veth 来实现的. 但是 tun/tap 没有 veth 那样要求设备成对出现, 数据要原样传输的限制, 数据包到用户态程序后, 程序员就有完全掌控的权力, 要进行哪些修改, 要发送到什么地方, 都可以通过编写代码去实现, 因此 tun/tap 方案比起 veth 方案有更广泛的适用范围.")]),t._v(" "),s("p",[s("strong",[t._v("veth 是另外一种主流的虚拟网卡方案")]),t._v(", 在 Linux Kernel 2.6 版本, Linux 在开始支持网络名称空间隔离的同时, 也提供了专门的"),s("strong",[t._v("虚拟以太网")]),t._v("(Virtual Ethernet, 习惯简写做 veth)让两个隔离的网络名称空间之间可以互相通信. 直接把 veth 比喻成虚拟网卡其实并不准确, 如果要和物理设备类比, 它应该相当于由交叉网线连接的一对物理网卡.")]),t._v(" "),s("p",[t._v("veth 实际上不是一个设备, 而是"),s("strong",[t._v("一对设备")]),t._v(", 因而也常被称作 "),s("strong",[t._v("veth pair")]),t._v(". 要使用 veth, 必须"),s("strong",[t._v("在两个独立的网络名称空间中进行才有意义")]),t._v(", 因为 "),s("strong",[t._v("veth pair 是一端连着协议栈, 另一端彼此相连")]),t._v("的, 在 veth 设备的其中一端输入数据, 这些数据就会从设备的另外一端原样不变地流出, 它工作时的数据流动如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230109223304362.png",alt:"",title:"veth pair工作示意图"}})]),t._v(" "),s("p",[t._v("由于两个容器之间采用 veth 通信"),s("strong",[t._v("不需要反复多次经过网络协议栈")]),t._v(", 这让 veth 有比 tap/tun 更好的"),s("strong",[t._v("性能")]),t._v(", 也让 veth pair 的实现变得十分简单, 内核中只用几十行代码实现一个数据复制函数就完成了 veth 的主体功能. veth 以"),s("strong",[t._v("模拟网卡直连")]),t._v("的方式很好地解决了两个容器之间的通信问题, 然而对多个容器间通信, 如果仍然单纯只用 veth pair 的话, 事情就会变得非常麻烦, 让每个容器都为与它通信的其他容器建立一对专用的 veth pair 并不实际, 这时就迫切"),s("strong",[t._v("需要一台虚拟化的交换机来解决多容器之间的通信问题")]),t._v("了.")]),t._v(" "),s("h6",{attrs:{id:"_2-交换机-linux-bridge"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-交换机-linux-bridge"}},[t._v("#")]),t._v(" (2)交换机: Linux Bridge")]),t._v(" "),s("p",[t._v("既然有了虚拟网卡, 很自然就会联想到让"),s("strong",[t._v("网卡接入交换机, 以实现多个容器间的相互连接")]),t._v(". "),s("strong",[t._v("Linux Bridge")]),t._v(" 便是 Linux 系统下的"),s("strong",[t._v("虚拟化交换机")]),t._v(', 虽然它以"网桥"(Bridge)而不是"交换机"(Switch)为名, 但是在使用过程中, 会发现 Linux Bridge 的目的看起来像交换机, 功能像交换机, 程序实现也像交换机, '),s("strong",[t._v("实际就是一台虚拟交换机")]),t._v(".")]),t._v(" "),s("p",[t._v("Linux Bridge 是在 Linux Kernel 2.2 版本开始提供的"),s("strong",[t._v("二层转发工具")]),t._v(", 由 "),s("strong",[t._v("brctl 命令")]),t._v("创建和管理. Linux Bridge 创建以后, 便能够接入任何位于二层的网络设备, 无论是真实的物理设备(譬如 eth0)抑或是虚拟设备(譬如 veth 或者 tap)都能与 Linux Bridge 配合工作. 当有"),s("strong",[t._v("二层数据包(以太帧)从网卡进入时 Linux Bridge 将根据数据包的类型和目标 MAC 地址")]),t._v(", 按如下规则转发处理.")]),t._v(" "),s("ul",[s("li",[t._v("如果数据包是广播帧, 转发给所有接入网桥的设备.")]),t._v(" "),s("li",[t._v("如果数据包是单播帧: (1) 且 MAC 地址在地址转发表中不存在, 则洪泛(Flooding)给所有接入网桥的设备, 并将响应设备的接口与 MAC 地址学习(MAC Learning)到自己的 MAC 地址转发表中. (2) 且 MAC 地址在地址转发表中已存在, 则直接转发到地址表中指定的设备.")]),t._v(" "),s("li",[t._v("如果数据包是此前转发过的, 又重新发回到此 Bridge, 说明冗余链路产生了环路. 由于以太帧不像 IP 报文那样有生存周期来约束, 因此一旦出现环路, 如果没有额外措施来处理的话就会永不停歇地转发下去. 对于这种数据包就需要交换机实现生成树协议(Spanning Tree Protocol, STP)来交换拓扑信息, 生成唯一拓扑链路以切断环路.")])]),t._v(" "),s("p",[t._v("上面提到的这些名词, 譬如二层转发, 泛洪, MAC 学习, 地址转发表, STP, 等等, 都是物理交换机中极为成熟的概念, 它们在 Linux Bridge 中"),s("strong",[t._v("都有对应的实现")]),t._v(", 所以说 Linux Bridge 不仅用起来像交换机, 实现起来也像交换机. 不过它与普通的物理交换机还是有一点差别, 普通交换机只会单纯地做二层转发, "),s("strong",[t._v("Linux Bridge 却还支持把发给它自身的数据包接入主机的三层协议栈中")]),t._v(".")]),t._v(" "),s("p",[t._v("对于通过 brctl 命令显式接入网桥的设备, Linux Bridge 与物理交换机的转发行为是完全一致的, 都"),s("strong",[t._v("不允许给接入的设备设置 IP 地址")]),t._v(", 因为网桥是根据 MAC 地址做二层转发的, 就算设置了三层的 IP 地址也毫无意义. 然而 Linux Bridge 与普通交换机的区别是除了显式接入的设备外, 它自己也无可分割地连接着一台有着完整网络协议栈的 Linux 主机, 因为 Linux Bridge 本身肯定是在某台 Linux 主机上创建的, 可以"),s("strong",[t._v("看作 Linux Bridge 有一个与自己名字相同的隐藏端口, 隐式地连接了创建它的那台 Linux 主机")]),t._v(". 因此, Linux Bridge 允许给自己设置 IP 地址, 比普通交换机多出一种特殊的转发情况: 如果数据包的目的 MAC 地址为网桥本身, 并且网桥设置了 IP 地址的话, 那该数据包即被认为是收到发往创建网桥那台主机的数据包, 此数据包将不会转发到任何设备, 而是直接交给上层(三层)协议栈去处理.")]),t._v(" "),s("p",[t._v("此时, "),s("strong",[t._v("网桥就取代了 eth0 设备来对接协议栈, 进行三层协议")]),t._v("的处理. 设置这条特殊转发规则的好处是: 只要通过简单的 NAT 转换, 就可以实现一个最原始的单 IP 容器网络. 这种组网是最基本的容器间通信形式, 下面举个具体例子来帮助你理解. 假设现有如下设备, 它们的连接情况如下图所示, 具体配置如下.")]),t._v(" "),s("ul",[s("li",[t._v("网桥 br0: 分配 IP 地址 192.168.31.1.")]),t._v(" "),s("li",[t._v("容器: 三个网络名称空间(容器), 分别编号为 1, 2, 3, 均使用 veth pair 接入网桥, 且有如下配置. (1)在容器一端的网卡名为 veth0, 在网桥一端的网卡名为 veth1, veth2, veth3. (2)为三个容器中的 veth0 网卡分配 IP 地址: 192.168.1.10, 192.168.1.11, 192.168.1.12. (3)三个容器中的 veth0 网卡"),s("strong",[t._v("设置网关为网桥")]),t._v(", 即 192.168.31.1. (4)网桥中的 veth1, veth2, veth3 无 IP 地址.")]),t._v(" "),s("li",[t._v("物理网卡 eth0: 分配的 IP 地址为 14.123.254.86.")]),t._v(" "),s("li",[t._v("外部网络: 外部网络中有一台服务器, 地址为 122.246.6.183.")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230109224946073.png",alt:"",title:"Linux Bridge构建单IP容器网络"}})]),t._v(" "),s("p",[t._v("如果名称空间 1 中的应用程序想访问外网地址为 122.246.6.183 的服务器, 由于容器没有自己的公网 IP 地址, 程序发出的数据包必须经过如下步骤处理后, 才能最终到达"),s("strong",[t._v("外网服务器")]),t._v(".")]),t._v(" "),s("p",[t._v("(1)应用程序调用 Socket API 发送数据, 此时生成的原始数据包为:")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("源 MAC: veth0 的 MAC\n目标 MAC: 网关的 MAC(即网桥的 MAC)\n源 IP: veth0 的 IP, 即 192.168.31.1\n目标 IP: 外网的 IP, 即 122.246.6.183\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("(2)从 veth0 发送的数据, 会在 veth1 中原样发出, 网桥将从 veth1 中接收到一个"),s("strong",[t._v("目标 MAC 为自己的数据包")]),t._v(", 并且网桥有配置 IP 地址, 由此触发 Linux Bridge 的特殊转发规则. 这样这个数据包便"),s("strong",[t._v("不会转发给任何设备, 而是转交给主机的协议栈处理")]),t._v(".")]),t._v(" "),s("p",[t._v("注意, 从这步以后就是"),s("strong",[t._v("三层路由")]),t._v("了, 已不在网桥的工作范围之内, 是由 Linux 主机依靠 "),s("strong",[t._v("Netfilter")]),t._v(" 进行 IP 转发(IP Forward)去实现的.")]),t._v(" "),s("p",[t._v("(3)数据包经过主机协议栈, Netfilter 的钩子被激活, 预置好的 "),s("strong",[t._v("iptables NAT")]),t._v(" 规则会"),s("strong",[t._v("修改数据包的源 IP 地址")]),t._v(", 将其改为"),s("strong",[t._v("物理网卡 eth0 的 IP 地址")]),t._v(", 并在映射表中记录"),s("strong",[t._v("设备端口及两个 IP 地址之间的对应关系")]),t._v(", 经过 SNAT 之后的数据包, 最终会从 eth0 出去, 此时报文头中的地址为:")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("源 MAC: eth0 的 MAC\n目标 MAC: 下一跳(Hop)的 MAC\n源 IP: eth0 的 IP, 即 14.123.254.86\n目标 IP: 外网的 IP, 即 122.246.6.183\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("(4)可见, 经过"),s("strong",[t._v("主机协议栈后, 数据包的源和目标 IP 地址均为公网的 IP")]),t._v(", 这个数据包在外部网络中可以根据 IP 正确路由到目标服务器中. 当目标服务器处理完毕, 对该请求发出响应后, 返回数据包的目标地址也是"),s("strong",[t._v("公网 IP")]),t._v(". 当返回的数据包经过链路所有跳点, 由 eth0 达到网桥时, 报文头中的地址为:")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("源 MAC: eth0 的 MAC\n目标 MAC: 网桥的 MAC\n源 IP: 外网的 IP, 即 122.246.6.183\n目标 IP: eth0 的 IP, 即 14.123.254.86\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("(5)这同样是一个"),s("strong",[t._v("以网桥 MAC 地址为目标的数据包")]),t._v(", 同样会触发特殊转发规则, 交由"),s("strong",[t._v("协议栈")]),t._v("处理. 此时 Linux 将根据"),s("strong",[t._v("映射表中的转换关系做 DNAT")]),t._v(", 把"),s("strong",[t._v("目标 IP 地址从 eth0 替换回 veth0 的 IP")]),t._v(", 最终 veth0 收到的响应数据包为:")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("源 MAC: 网桥的 MAC\n目标 MAC: veth0 的 MAC\n源 IP: 外网的 IP, 即 122.246.6.183\n目标 IP: veth0 的 IP, 即 192.168.31.1\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("在以上处理过程中, Linux 主机独立承担了"),s("strong",[t._v("三层路由")]),t._v("的职责, 在一定程度上扮演了"),s("strong",[t._v("路由器")]),t._v("的角色. 由于有 Netfilter 的存在, 对网络层的路由转发, 就无须像 Linux Bridge 一样专门提供 brctl 这样的命令去创建一个虚拟设备, 通过 Netfilter 可以很容易地在 Linux 内核完成根据 IP 地址进行路由的操作. 可以这样理解: "),s("strong",[t._v("Linux Bridge 是一个人工创建的虚拟交换机, 而 Linux 内核则是一个天然的虚拟路由器")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_3-网络-vxlan"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-网络-vxlan"}},[t._v("#")]),t._v(" (3)网络: VXLAN")]),t._v(" "),s("p",[t._v("有了虚拟化网络设备后, 下一步就是要"),s("strong",[t._v("使用这些设备组成网络")]),t._v(". 容器分布在不同的"),s("strong",[t._v("物理主机")]),t._v("上, 每一台物理主机都有"),s("strong",[t._v("物理网络")]),t._v("相互联通, 然而这种网络的物理拓扑结构是"),s("strong",[t._v("相对固定")]),t._v("的, 很难跟上云原生时代分布式系统的逻辑拓扑结构的变动频率, 譬如服务的扩缩, 断路, 限流, 等等, 都可能要求网络随之做出相应的变化. 正因如此, 软件定义网络(Software Defined Network, SDN)的需求在云计算和分布式时代变得前所未有地迫切. "),s("strong",[t._v("SDN 的核心思路是在物理网络上再构造一层虚拟化的网络, 将控制平面和数据平面分离开来, 实现流量的灵活控制, 为核心网络及应用的创新提供良好的平台")]),t._v(". SDN 里位于下层的物理网络被称为 Underlay, 它着重解决网络的连通性与可管理性, 位于上层的逻辑网络被称为 Overlay, 它着重为应用提供与软件需求相符的传输服务和网络拓扑.")]),t._v(" "),s("p",[t._v("软件定义网络已经发展了十余年时间, 远比云原生, 微服务这些概念出现得早. 网络设备商基于硬件设备开发出了EVI(Ethernet Virtualization Interconnect, 以太网虚拟化互联), TRILL(Transparent Interconnection of Lots of Link, 多链接透明互联), SPB(Shortest Path Bridging, 最短路径桥接)等大二层网络技术; 软件厂商也提出了 VXLAN(Virtual eXtensible LAN, 虚拟局域网扩展), NVGRE(Network Virtualization Using Generic Routing Encapsulation, 使用通用路由封装的网络虚拟化), STT(A Stateless Transport Tunneling Protocol for Network Virtualization, 无状态传输隧道协议网络虚拟化)等一系列"),s("strong",[t._v("基于虚拟交换机实现的 Overlay 网络")]),t._v(". 由于"),s("strong",[t._v("跨主机的容器间通信用的大多是 Overlay 网络, 所以在本节以 VXLAN 为例去介绍 Overlay 网络的原理")]),t._v(".")]),t._v(" "),s("p",[t._v('VXLAN 你可能没听说过, 但 VLAN 很多人都会有所了解, VLAN 的全称是 "虚拟局域网"(Virtual Local Area Network). 由于二层网络本身的工作特性决定了它非常'),s("strong",[t._v("依赖于广播")]),t._v(", 无论是广播帧(如 ARP 请求, DHCP, RIP 都会产生广播帧), 还是泛洪路由, 其执行成本都随着接入二层网络的设备数量的增长而等比例增加, 当设备太多, 广播又频繁的时候, 很容易形成"),s("strong",[t._v("广播风暴")]),t._v("(Broadcast Radiation). 因此, "),s("strong",[t._v("VLAN 的首要职责就是划分广播域")]),t._v(", 将连接在同一个物理网络上的设备区分开来, 划分的具体方法是在"),s("strong",[t._v("以太帧的报文头")]),t._v("中加入 VLAN Tag, 让所有广播只针对具有相同 VLAN Tag 的设备生效. 这样既缩小了广播域, 也提高了安全性和可管理性, 因为两个 VLAN 之间不能直接通信. 如果确有通信的需要, 就必须通过三层设备来进行, 譬如单臂路由(Router on a Stick)或者三层交换机.")]),t._v(" "),s("p",[t._v("然而 VLAN 有两个明显的缺陷, 第一个缺陷在于 VLAN Tag 的设计, 定义 VLAN 的 802.1Q 规范是在 1998 年提出的, 当时的网络工程师完全不可能预料到未来云计算会如此普及, 因而只给 VLAN Tag 预留了 "),s("strong",[t._v("32 位")]),t._v("的存储空间, 其中还要分出 16 位存储标签协议识别符(Tag Protocol Identifier), 3 位存储优先权代码点(Priority Code Point), 1 位存储标准格式指示(Canonical Format Indicator), 剩下的 12 位才会用来存储 VLAN ID(Virtualization Network Identifier, VNI), 换言之, "),s("strong",[t._v("VLAN ID 最多只能有 212(4096) 种取值")]),t._v(". 在云计算数据中心出现后, 即使不考虑虚拟化的需求, 单是需要分配 IP 的物理设备都有可能数以万计甚至数以十万计, 这样看来, 4096 个 VLAN 肯定是不够用的. 后来 IEEE 又提出 802.1AQ 规范来弥补这个缺陷, 大致思路是给以太帧连续打上两个 VLAN Tag, 每个 Tag 里仍然只有 12 位的 VLAN ID, 但两个加起来就可以存储 224(16 777 216)个不同的 VLAN ID, 由于两个 VLAN Tag 并排放在报文头上, 802.1AQ 规范还有了一个 QinQ(802.1Q in 802.1Q) 的昵称别名.")]),t._v(" "),s("p",[t._v("QinQ 是 2011 年推出的规范, 但是直到现在都没有特别普及, 除了需要设备支持外, 它还弥补不了 VLAN 的第二个缺陷: 跨数据中心传递. VLAN 本身是为二层网络所设计的, 但是在两个独立数据中心之间, 信息只能通过"),s("strong",[t._v("三层网络传递")]),t._v(", 由于云计算的发展普及, 大型分布式系统已不局限于单个数据中心, 完全有跨数据中心运作的可能性, 此时如何让 VLAN Tag 在两个数据中心间传递又成为不得不考虑的麻烦事.")]),t._v(" "),s("p",[t._v("为了统一解决以上两个问题, IETF 定义了 "),s("strong",[t._v("VXLAN 规范, 这是三层虚拟化网络")]),t._v("(Network Virtualization over Layer 3, NVO3)的标准技术规范之一, 是一种典型的 "),s("strong",[t._v("Overlay 网络")]),t._v(". VXLAN 采用 L2 over L4(MAC in UDP)的报文封装模式, 把原本在"),s("strong",[t._v("二层传输的以太帧放到四层 UDP 协议的报文体")]),t._v("内, 同时加入了自己定义的 VXLAN Header. "),s("strong",[t._v("VXLAN Header 里直接就有 24 位的 VLAN ID")]),t._v(", 同样可以存储 1677 万个不同的取值, 使得"),s("strong",[t._v("二层网络可以在三层范围")]),t._v("内进行扩展, 不再受数据中心间传输的限制.")]),t._v(" "),s("p",[t._v("VXLAN 对网络基础设施的要求很低, 不需要专门的硬件提供的特别支持, 只要三层可达的网络就能部署 VXLAN. VXLAN 的每个边缘入口上都布置了一个 VTEP(VXLAN Tunnel Endpoint)设备, 它既可以是物理设备, 也可以是虚拟化设备, 负责 VXLAN 协议报文的封包和解包. 互联网号码分配局(Internet Assigned Numbers Authority, IANA)专门分配了 4789 作为 VTEP 设备的 UDP 端口(以前 Linux VXLAN 用的默认端口是 8472, 目前这两个端口在许多场景中仍有并存的情况).")]),t._v(" "),s("p",[t._v("到了 3.12 版本, Linux 对 VXLAN 的支持已达到完全完备的程度, 能够处理单播和组播, 能够运行于 IPv4 和 IPv6 之上, 一台 Linux 主机经过简单配置之后, 便可以"),s("strong",[t._v("把 Linux Bridge 作为 VTEP 设备使用")]),t._v(".")]),t._v(" "),s("p",[t._v("VXLAN 带来了很高的灵活性, 扩展性和可管理性, 同一套物理网络中可以任意创建多个 VXLAN, 每个 VXLAN 中接入的设备都仿佛是在一个完全独立的二层局域网中一样, 不会受到外部广播的干扰, 也很难遭受外部的攻击, 这使得 VXLAN 能够良好地匹配分布式系统的弹性需求. 不过, VXLAN 也带来了额外的复杂度和性能开销, 具体表现在如下两个方面.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("传输效率的下降")]),t._v(". 经过 VXLAN 封装后的报文, 新增加的报文头部分就占了整整 50 字节(VXLAN 报文头占 8 字节, UDP 报文头占 8 字节, IP 报文头占 20 字节, 以太帧的 MAC 头占 14 字节), 而原本需要的 14 字节, 被封到了最里面的以太帧中. 以太网的 MTU 默认是 1500 字节, 如果是传输大量数据, 额外损耗 50 字节并不算很高的成本, 但如果传输的数据只有几个字节, 那传输消耗在报文头上的成本就很高昂了.")]),t._v(" "),s("li",[s("strong",[t._v("传输性能的下降")]),t._v(". 每个 VXLAN 报文的封包和解包操作都属于额外的处理过程, 尤其是用软件来实现的 VTEP, 额外的运算资源消耗有时候会成为不可忽略的性能影响因素.")])]),t._v(" "),s("h6",{attrs:{id:"_4-副本网卡-macvlan"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-副本网卡-macvlan"}},[t._v("#")]),t._v(" (4)副本网卡: MACVLAN")]),t._v(" "),s("p",[t._v("理解了 VLAN 和 VXLAN 的原理后, 就有足够的前置知识去了解 "),s("strong",[t._v("MACVLAN")]),t._v(" 这最后一种网络设备虚拟化的方式了.")]),t._v(" "),s("p",[t._v("前文提到, 两个 VLAN 之间是"),s("strong",[t._v("完全二层隔离")]),t._v("的, 不存在重合的广播域, 因此要通信就只能通过"),s("strong",[t._v("三层设备")]),t._v(", 而最简单的三层通信就是通过"),s("strong",[t._v("单臂路由")]),t._v("实现. 笔者以下图所示的网络拓扑结构来举个具体例子, 介绍单臂路由是如何工作的.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230110220159491.png",alt:"image-20230110220159491",title:"VLAN单臂路由原理"}})]),t._v(" "),s("p",[t._v("假设位于 VLAN-A 中的主机 A1 希望将数据包发送给 VLAN-B 中的主机 B2, 由于 A, B 两个 VLAN 之间的"),s("strong",[t._v("二层链路不通")]),t._v(", 因此引入了"),s("strong",[t._v("单臂路由")]),t._v(". 单臂路由不属于任何 VLAN, 它与交换机之间的链路允许"),s("strong",[t._v("任何 VLAN ID 的数据")]),t._v("包通过, 而这个通信的接口也被称为 "),s("strong",[t._v("TRUNK")]),t._v(". 这样, A1 要和 B2 通信, 就要将数据包先发送给路由(只需把路由设置为网关即可), 然后路由会根据数据包上的 IP 地址得知 B2 的位置, 去掉 VLAN-A 的 VLAN Tag, 改用 VLAN-B 的 VLAN Tag 重新封装数据包后再发回给交换机, 交换机收到后就可以顺利转发给 B2 了. 这个过程并不复杂, 但你是否注意到一个问题, 路由器应该设置怎样的 IP 地址呢? 由于 A1, B2 各自处于独立的网段上, 它们又各自要将同一个路由作为网关使用, 这就要求路由器必须同时具备 192.168.1.0/24 和 192.168.2.0/24 的 IP 地址. 如果真的只有 VLAN-A, VLAN-B 两个 VLAN, 那为路由器上的两个接口分别设置不同的 IP 地址, 然后用两条网线分别连接到交换机上也勉强算是一个解决办法, 但 VLAN 最多支持 4096 个 VLAN, 如果要接四千多条网线就太离谱了. 为了解决这个问题, 802.1Q 规范中专门定义了"),s("strong",[t._v("子接口")]),t._v("(Sub-Interface)的概念, 其作用是"),s("strong",[t._v("允许在同一张物理网卡上, 针对不同的 VLAN 绑定不同的 IP 地址")]),t._v(".")]),t._v(" "),s("p",[t._v("MACVLAN 借用了 VLAN 子接口的思路, 并且在这个基础上进一步优化, 不仅允许为同一个网卡设置多个 IP 地址, 还允许在"),s("strong",[t._v("同一张网卡上设置多个 MAC 地址")]),t._v(", 这也是 "),s("strong",[t._v("MACVLAN")]),t._v(' 名字的由来. 原本 MAC 地址是网卡接口的"身份证", 应该是严格的一对一关系, 而 MACVLAN 打破了这层关系, '),s("strong",[t._v("方法是在物理设备之上, 网络栈之下生成多个虚拟的设备, 每个设备都有一个 MAC 地址")]),t._v(", 新增设备的操作本质上相当于在系统内核中注册一个收发特定数据包的回调函数, 每个回调函数都能对一个 MAC 地址的数据包进行响应, 当物理设备收到数据包时, 会先根据 MAC 地址进行一次判断, 确定交给哪个设备来处理, 如下图所示. 从交换机一侧的视角来看, 这个端口后面仿佛是"),s("strong",[t._v("另一台已经连接了多个设备的交换机")]),t._v("一样.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230110220741802.png",alt:"",title:"MACVLAN原理"}})]),t._v(" "),s("p",[t._v("用 MACVLAN 技术虚拟出来的"),s("strong",[t._v("副本网卡")]),t._v(", 在功能上和真实的网卡是"),s("strong",[t._v("完全对等")]),t._v("的, 此时真正的物理网卡实际上承担着类似交换机的职责, 它会在收到数据包后, 根据目标 MAC 地址判断这个包应转发给哪块副本网卡处理. "),s("strong",[t._v("由同一块物理网卡虚拟出来的副本网卡, 天然处于同一个 VLAN 之中, 可以直接二层通信, 不需要将流量转发到外部网络")]),t._v(".")]),t._v(" "),s("p",[t._v("与 Linux Bridge 相比, 这种以网卡模拟交换机的方法在目标上并没有本质的不同, 但 MACVLAN 在内部实现上要比 Linux Bridge 轻量得多. 从数据流来看, 副本网卡的通信只比物理网卡多了一次判断而已, 能获得很高的网络通信性能; 从操作步骤来看, 由于 MAC 地址是静态的, 所以 MACVLAN 不需要像 Linux Bridge 那样考虑 MAC 地址学习, STP 协议等复杂的算法, 这也进一步突出了 MACVLAN 的性能优势.")]),t._v(" "),s("p",[t._v("除了模拟交换机的 Bridge 模式外, MACVLAN 还支持虚拟以太网端口聚合(Virtual Ethernet Port Aggregator, VEPA)模式, Private 模式, Passthru 模式, Source 模式等其他工作模式, 这里就不逐一介绍了.")]),t._v(" "),s("h5",{attrs:{id:"_4-容器间通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-容器间通信"}},[t._v("#")]),t._v(" 4.容器间通信")]),t._v(" "),s("p",[t._v("经过对虚拟化网络基础知识的一番了解后, 最后将尝试使用这些知识去解构"),s("strong",[t._v("容器间的通信原理")]),t._v(", 毕竟运用知识去解决问题才是介绍网络虚拟化的根本目的. 这节先以 Docker 为目标, 谈一谈 Docker 所提供的容器通信方案. 下一节将介绍 CNI 下的 Kubernetes 网络插件生态. 也许看完后会觉得 Docker 的网络通信相对简单, 对于某些分布式系统的需求来说甚至过于简陋了, 然而虽然容器间的网络方案多种多样, "),s("strong",[t._v("但通信主体却是固定的")]),t._v(", 不外乎"),s("strong",[t._v("没有物理设备的虚拟主体")]),t._v("(容器, Pod, Service, Endpoint等), 不需要跨网络的本地主机, 以及通过网络连接的外部主机三种层次, "),s("strong",[t._v("所有的容器网络通信问题, 都可以归结为本地主机内部的多个容器之间, 本地主机与内部容器之间和跨越不同主机的多个容器之间的通信问题")]),t._v(", 其中的许多原理都是相通的, 所以 Docker 网络的简单, 在检验前面网络知识有没有理解到位时倒不失为一种优势.")]),t._v(" "),s("p",[t._v("Docker 的网络方案在操作层面上是指能够直接通过 "),s("strong",[t._v("docker run--network")]),t._v(" 参数指定的网络, 或者先通过 docker network create 命令创建后再被容器使用的网络. 安装 Docker 过程中会自动在宿主机上创建一个名为 "),s("strong",[t._v("docker0 的网桥")]),t._v(", 以及三种不同的 "),s("strong",[t._v("Docker 网络")]),t._v(", 分别是 bridge, host 和 none, 可以通过 docker network ls 命令查看这三种网络, 具体如下所示:")]),t._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("docker")]),t._v(" network "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ls")]),t._v("\nNETWORK ID          NAME                              DRIVER              SCOPE\n2a25170d4064        bridge                            bridge              "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("local")]),t._v("\na6867d58bd14        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("host")]),t._v("                              "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("host")]),t._v("                "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("local")]),t._v("\naeb4f8df39b1        none                              null                "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("local")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[t._v("这三种网络, 对应 Docker 提供的"),s("strong",[t._v("三种开箱即用的网络方案")]),t._v(", 分别如下.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("桥接模式")]),t._v(", 使用 --"),s("strong",[t._v("network=bridge")]),t._v(" 指定, 这也是未指定网络参数时的"),s("strong",[t._v("默认网络")]),t._v(". 桥接模式下, Docker 会为"),s("strong",[t._v("新容器分配独立的网络名称空间, 创建好 veth pair, 一端接入容器, 另一端接入 docker0 网桥")]),t._v(". Docker 会为每个容器自动分配好 IP 地址, 默认配置下地址范围是 172.17.0.0/24, docker0 的地址默认是 172.17.0.1, 并且设置所有容器的"),s("strong",[t._v("网关为 docker0")]),t._v(", 这样所有接入同一个网桥内的容器可以直接依靠二层网络来通信, 而在此范围之外的容器, 主机就必须通过"),s("strong",[t._v("网关")]),t._v("来访问, 具体过程在介绍 Linux Bridge 时已经详细讲解过, 这里不再赘述.")]),t._v(" "),s("li",[s("strong",[t._v("主机模式")]),t._v(", 使用 --"),s("strong",[t._v("network=host")]),t._v(" 指定. 主机模式下, Docker "),s("strong",[t._v("不会为新容器创建独立的网络名称空间")]),t._v(", 这样容器一切的网络设施, 如网卡, 网络栈等都"),s("strong",[t._v("直接使用宿主机上的真实设施")]),t._v(", 容器也就不会拥有自己的独立的 IP 地址. 主机模式下, Docker 与外界通信时"),s("strong",[t._v("无须进行 NAT 转换")]),t._v(", 没有性能损耗, 但缺点也十分明显, 没有隔离就无法避免网络资源的冲突, 譬如端口号就"),s("strong",[t._v("不允许重复")]),t._v(".")]),t._v(" "),s("li",[s("strong",[t._v("空置模式")]),t._v(", 使用 --"),s("strong",[t._v("network=none")]),t._v(" 指定. 空置模式下, Docker 会给新容器创建独立的网络名称空间, 但是不会创建任何虚拟的网络设备, 此时容器能看到的只有一个回环设备(Loopback Device)而已. 提供这种方式是为了方便用户去做自定义的网络配置, 如增加网络设备, 管理 IP 地址, 等等.")])]),t._v(" "),s("p",[t._v("除了三种开箱即用的网络外, Docker 还支持以下由用户"),s("strong",[t._v("自行创建")]),t._v("的网络.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("容器模式")]),t._v(", 创建容器后使用 --network=container:容器名称指定. 容器模式下, 新创建的容器将会加入指定的容器的网络名称空间, 共享一切网络资源, 但其他资源, 如文件, PID 等默认仍然是隔离的. 两个容器间可以直接使用回环地址(localhost)通信, 但端口号等网络资源不能有冲突.")]),t._v(" "),s("li",[s("strong",[t._v("MACVLAN 模式")]),t._v(": 使用 docker network create-d macvlan 创建. 此网络允许"),s("strong",[t._v("为容器指定一个副本网卡")]),t._v(", 容器通过副本网卡的 MAC 地址来使用宿主机上的物理设备, 在追求通信性能的场合, 这种网络是最好的选择.  Docker 的 MACVLAN 只支持 Bridge 通信模式, 因此在功能表现上与桥接模式类似.")]),t._v(" "),s("li",[s("strong",[t._v("Overlay 模式")]),t._v(": 使用 docker network create-d overlay 创建. Docker 说的 Overlay 网络实际上就是特指 VXLAN, 这种网络模式主要用于 Docker Swarm 服务之间的通信. 然而由于 Docker Swarm 败于 Kubernetes, 并未成为主流, 所有这种网络模式实际"),s("strong",[t._v("很少使用")]),t._v(".")])]),t._v(" "),s("h4",{attrs:{id:"容器网络与生态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器网络与生态"}},[t._v("#")]),t._v(" 容器网络与生态")]),t._v(" "),s("p",[t._v("容器网络的第一个业界标准源于 Docker 在 2015 年发布的 libnetwork 项目, 这是 Docker 用 Go 编写的, 专门用来抽象容器间网络通信的一个独立模块, 与 libcontainer 是作为 OCI 的标准实现而设计类似, libnetwork 是作为 Docker 提出的 CNM 规范(Container Network Model, 容器网络模型)的标准实现而设计的. 不过, 与 libcontainer 因孵化出 runC 项目, 时至今日仍然广为人知的结局不同, libnetwork 随着 Docker Swarm 的失败, "),s("strong",[t._v("已经基本失去了实用价值")]),t._v(".")]),t._v(" "),s("h5",{attrs:{id:"_1-cnm与cni"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-cnm与cni"}},[t._v("#")]),t._v(" 1.CNM与CNI")]),t._v(" "),s("p",[t._v("如今 "),s("strong",[t._v("CNM 与容器网络的事实标准 CNI")]),t._v("(Container Networking Interface, "),s("strong",[t._v("容器网络接口")]),t._v(')在目标上几乎是完全重叠的, 由此决定了 CNM 与 CNI 之间只能是"你死我活"的竞争关系, 这与容器运行时中提及的 CRI 和 OCI 的关系明显不同, CRI 与 OCI 的目标并不一样, 两者有足够的空间可以和平共处.')]),t._v(" "),s("p",[t._v("尽管 CNM 规范已是明日黄花, 但它作为容器网络的先行者, 对后续的容器网络标准制定有直接的指导意义. "),s("strong",[t._v("提出容器网络标准的目的就是把网络功能从容器运行时引擎或者容器编排系统中剥离出去")]),t._v(". 网络的专业性和针对性极强, 如果不把它变成外部可扩展的功能, 都由自己来做的话, 不仅费时费力, 还讨不到好.")]),t._v(" "),s("p",[t._v("网络的专业性与针对性也决定了 CNM 和 CNI "),s("strong",[t._v("均采用了插件式的设计")]),t._v(", 需要接入什么样的网络, 就设计一个对应的网络插件即可. 所谓插件, 在形式上也就是一个可执行文件, 再配上相应的 "),s("strong",[t._v("Manifest 描述")]),t._v(". 为了方便插件编写, CNM 将协议栈, 网络接口(对应于 veth, tap/tun 等)和网络(对应于 Bridge, VXLAN, MACVLAN 等)分别抽象为 Sandbox, Endpoint 和 Network, 并在接口的 API 中提供了这些抽象资源的读写操作. 而 CNI 中尽管也有 Sandbox, Network 的概念, 含义也与 CNM 大致相同, 不过在 Kubernetes 资源模型的支持下, 它无须刻意强调某一种网络资源应该如何描述, 如何访问, 因此结构上显得更加轻便.")]),t._v(" "),s("p",[t._v("从程序功能上看, CNM 和 CNI 的网络插件提供的能力都能划分为"),s("strong",[t._v("网络的管理与 IP 地址的管理两类")]),t._v(", 插件可以选择只实现其中的某一功能, 也可以全部实现.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("管理网络创建与删除")]),t._v(". 解决如何创建网络, 如何将容器接入网络, 以及如何退出和删除网络. 这个过程实际上是对容器网络的生命周期管理, 如果更熟悉 Docker 命令, 可以类比理解为 docker network 命令所做的事情. CNM 规范中定义了创建网络, 删除网络, 容器接入网络, 容器退出网络, 查询网络信息, 创建通信 Endpoint, 删除通信 Endpoint 等十个编程接口, 而 CNI 中就更加简单了, 只要实现对网络的增加与删除两项操作即可. 你不需要学过 Go 语言, 只从名称上就能轻松看明白以下接口中每个方法的含义是什么.")])]),t._v(" "),s("div",{staticClass:"language-go line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" CNI "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    AddNetworkList "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("net "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("NetworkConfigList"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" rt "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("RuntimeConf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("types"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    DelNetworkList "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("net "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("NetworkConfigList"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" rt "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("RuntimeConf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),t._v("\n    AddNetwork "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("net "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("NetworkConfig"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" rt "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("RuntimeConf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("types"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    DelNetwork "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("net "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("NetworkConfig"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" rt "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("RuntimeConf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("ul",[s("li",[s("strong",[t._v("管理 IP 地址分配与回收")]),t._v(". 解决如何为三层网络分配唯一的 IP 地址的问题. 二层网络的 MAC 地址天然具有唯一性, 所以无须刻意地考虑如何分配的问题. 但是三层网络的 "),s("strong",[t._v("IP 地址")]),t._v("只有通过精心规划, 才能保证在全局网络中都是唯一的, 否则如果两个容器之间存在相同地址, 那它们最多只能做 NAT, 而不可能做到直接通信.")])]),t._v(" "),s("p",[t._v("相比基于 UUID 或者数字序列实现的全局唯一 ID 产生器, IP 地址的全局分配工作要更困难一些. 首先是要符合 IPv4 的网段规则, 且保证不重复, 这在分布式环境里只能依赖 etcd, ZooKeeper 等协调工具来实现, Docker 自己也提供了类似的 libkv 来完成这项工作. 其次是必须考虑"),s("strong",[t._v("回收")]),t._v("的问题, 否则一旦 Pod 发生持续重启就有可能耗尽某个网段中的所有地址. 最后是必须关注"),s("strong",[t._v("时效性")]),t._v(", 原本获取 IP 地址时采用标准的 DHCP 协议(Dynamic Host Configuration Protocol, 动态主机配置协议)即可, 但 DHCP 有可能产生长达"),s("strong",[t._v("数秒")]),t._v("的延迟, 对于某些生存周期很短的 Pod, 这已经超出了它的忍受限度, 因此在容器网络中, "),s("strong",[t._v("往往 Host-Local 的 IP 分配方式会比 DHCP 更实用")]),t._v(".")]),t._v(" "),s("h5",{attrs:{id:"_2-cnm到cni"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-cnm到cni"}},[t._v("#")]),t._v(" 2.CNM到CNI")]),t._v(" "),s("p",[t._v("容器网络标准能够提供一致的网络操作界面, 无论什么网络插件都使用一致的 API, 提高了网络配置的自动化程度, 提升了在不同网络间迁移的体验, 对最终用户, 容器提供商, 网络提供商来说是三方共赢的事情.")]),t._v(" "),s("p",[t._v("CNM 规范发布以后, 借助 Docker 在容器领域的强大号召力, 很快得到了网络提供商与开源组织的支持, 不说专门为 Docker 设计针对容器互联的网络, 最起码会让现有的网络方案兼容于 CNM 规范, 以便能在容器圈中多分一杯羹. 对 CNM 持不同意见的是那些和 Docker 存在直接竞争关系的产品, 譬如 Docker 的最大竞争对手, 来自 CoreOS 公司的 RKT 容器引擎. 其实并不是其他容器引擎想刻意去抵制 CNM, 而是 Docker 制定 CNM 规范时完"),s("strong",[t._v("全是基于 Docker 本身来设计")]),t._v(", 并没有考虑 CNM 用于其他容器引擎的可能性.")]),t._v(" "),s("p",[t._v('为了平衡 CNM 规范的影响力, 也为了在 Docker 的主导背景下寻找一条出路, RKT 提出了与 CNM 目标类似的 "RKT 网络提案"(RKT Networking Proposal). 一个业界标准成功与否, 很大程度上取决于它的支持者阵营的规模, 对于容器网络这种插件式的规范更是如此. Docker 力推的 CNM 毫无疑问是当时统一容器网络标准的最有力竞争者, 如果没有外力的介入, 有极大可能成为最后的胜利者. 然而, 影响容器网络发展的外力还是出现了, 即使此前笔者没有提过 CNI, 应该很容易猜到, 在容器圈里能够掀翻 Docker 的"外力", 唯有 '),s("strong",[t._v("Kubernetes")]),t._v(" 一家而已.")]),t._v(" "),s("p",[t._v("Kubernetes 在开源的初期(Kubernetes 提出 CRI 规范之前), 在"),s("strong",[t._v("容器引擎上是选择彻底绑定于 Docker")]),t._v(" 的, 但是在容器网络的选择上, Kubernetes 一直坚持独立于 Docker 自己来维护网络. 在 CNM 和 CNI 提出之前, Kubernetes 会使用 Docker 的空置网络模式(--network=none)来创建 Pause 容器, 然后通过内部的 kubenet 来创建网络设施, 再让 Pod 中的其他容器加入 Pause 容器的名称空间中以共享这些网络设施.")]),t._v(" "),s("hr"),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("kubenet")])])]),t._v(" "),s("p",[t._v("kubenet 是 kubelet 内置的一个非常简单的"),s("strong",[t._v("网络")]),t._v(", 它采用"),s("strong",[t._v("网桥来实现 Pod 间通信")]),t._v(". kubenet 会自动创建一个名为 "),s("strong",[t._v("cbr0 的网桥")]),t._v(", 当有新的 Pod 启动时, 会由 kubenet 自动将其接入 cbr0 网桥中, 再将控制权交还给 kubelet, 完成后续的 Pod 创建流程. kubenet 采用 "),s("strong",[t._v("Host-Local 的 IP 地址管理方式")]),t._v(", 具体来说是根据当前服务器对应的节点资源上的 PodCIDR 字段所设的网段来分配 IP 地址. 当有新的 Pod 启动时, 会由本地节点的 IP 段分配一个空闲的 IP 供 Pod 使用.")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("在 CNM 规范还未提出之前, Kubernetes 自己来维护网络是必然的结果, 因为 Docker 自带的网络基本上只聚焦于如何解决本地通信, "),s("strong",[t._v("完全无法满足 Kubernetes 跨集群节点的容器编排的需要")]),t._v(". 在 CNM 规范提出之后, 原本 Kubernetes 应该是除 Docker 外最大的受益者才对, 因为 CNM 的价值就是能很方便地引入其他网络插件来替代 Docker 自带的网络, 但 Kubernetes 却对 Docker 的 CNM 规范表现得颇为犹豫, 经过一番评估考量, Kubernetes 最终决定转而支持当时极不成熟的 RKT 的网络提案, 与 CoreOS 合作以 RKT 网络提案为基础发展出 CNI 规范.")]),t._v(" "),s("p",[t._v('Kubernetes Network SIG 的负责人, Google 的工程师 Tim Hockin 专门撰写过一篇文章---"Why Kubernetes doesn’t use libnetwork" 来解释为何 Kubernetes 要拒绝 CNM 与 libnetwork. 当时"容器编排战争"还处于三国争霸(Kubernetes, Apache Mesos, Docker Swarm)的拉锯阶段, 即使强势如 Kubernetes, 拒绝 CNM 其实也要冒不小的风险, 付出颇大的代价, 因为这个决定不可避免会引发一系列技术和非技术的问题, 譬如网络提供商要为 Kubernetes 专门编写不同的网络插件, 由 docker run 命令启动的独立容器将无法与 Kubernetes 启动的容器直接通信, 等等.')]),t._v(" "),s("p",[t._v("促使 Kubernetes 拒绝 CNM 的理由也同样有"),s("strong",[t._v("来自于技术和非技术方面")]),t._v('的. 技术方面, Docker 的网络模型做出了许多对 Kubernetes 无效的假设: Docker 的网络有本地网络(不带任何跨节点协调能力, 譬如 Bridge 模式就没有全局统一的 IP 分配)和全局网络(跨主机的容器通信, 例如 Overlay 模式)的区别, 本地网络对 Kubernetes 来说毫无意义, 而全局网络又默认依赖 libkv 来实现全局 IP 地址管理等跨机器的协调工作. 这里的 libkv 是 Docker 建立的 lib* 家族中的另一位成员, 用来对标 etcd, ZooKeeper 等分布式 K/V 存储, 这对于已经拥有了 etcd 的 Kubernetes 来说如同鸡肋. 非技术方面, Kubernetes 决定放弃 CNM 的原因很大程度上还是他们与 Docker 在发展理念上的冲突, Kubernetes 当时已经开始推进 Docker 从必备依赖变为可选引擎的重构工作, 而 Docker 则坚持 CNM 只能基于 Docker 来设计. Tim Hockin 在文章中举了一个例子: CNM 的网络驱动没有向外部暴露网络所连接容器的具体名称, 只使用一个内部分配的 ID 来代替, 这让外部(包括网络插件和容器编排系统)很难将网络连接的容器与自己管理的容器关联起来, 当他们向 Docker 开发人员反馈这个问题时, 被以"工作符合预期结果"(Working as Intended)为理由直接关闭掉. Tim Hockin 还专门列出了这些问题的详细清单, 这些问题被 Kubernetes 认为是人为地使用 CNM 给非 Docker 的第三方容器引擎设置障碍. 在整个沟通过程中, Docker 表现得也极为强硬, 明确表示他们对偏离当前路线或委托控制的想法都不太欢迎. 上面这些"非技术"的问题, 即使没有 Docker 的支持, Kubernetes 自己也并非不能从"技术上"去解决, 但 Docker 的理念令 Kubernetes 感到忧虑, 因为 Kubernetes 在 Docker 之上扩展了很多功能, 且不想将这些功能永远绑定在 Docker 之上.')]),t._v(" "),s("p",[t._v("CNM 与 libnetwork 是在 2015 年 5 月 1 日发布, CNI 则是在 2015 年 7 月发布, 两者正式诞生只相差不到两个月时间, 这显然是竞争的需要而非单纯的巧合. 五年之后的今天, 这场容器网络的话语权之争已经尘埃落定,  "),s("strong",[t._v("CNI 获得全面的胜利")]),t._v(", 除了 Kubernetes 和 RKT 外, Amazon ECS, RedHat OpenShift, Apache Mesos, Cloud Foundry 等容器编排圈子中除了 Docker 之外的其他具有影响力的参与者都已宣布支持 CNI 规范, 原本已经加入了 CNM 阵营的 Contiv, Calico, Weave 网络提供商也纷纷推出了自己的 CNI 插件.")]),t._v(" "),s("h5",{attrs:{id:"_3-网络插件生态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-网络插件生态"}},[t._v("#")]),t._v(" 3.网络插件生态")]),t._v(" "),s("p",[t._v("时至今日, 支持 CNI 的网络插件已多达数十种, 不过, "),s("strong",[t._v("跨主机通信的网络实现模式只有下面这三种")]),t._v(". 不妨以"),s("strong",[t._v("网络实现模式")]),t._v("为主线, 针对每种模式介绍一个具有代表性的插件, 以达到对网络插件生态窥斑见豹的效果.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("Overlay 模式")]),t._v(": Overlay 网络是一种虚拟化的上层逻辑网络, 好处在于它不受底层物理网络结构的约束, 有更大的自由度, 更好的易用性; 坏处是由于额外的包头封装导致信息密度降低, 额外的隧道封包, 解包会导致传输性能下降. 在虚拟化环境(例如 OpenStack)中的网络限制往往较多, 譬如不允许机器之间直接进行二层通信, 只能通过三层转发. 在"),s("strong",[t._v("这类被限制网络的环境里, 基本上只能选择 Overlay 网络插件")]),t._v(", 常见的 Overlay 网络插件有 Flannel(VXLAN 模式), Calico(IPIP 模式), Weave 等. 这里以 Flannel-VXLAN 为例, 由 CoreOS 开发的 Flannel 可以说是最早的跨节点容器通信解决方案, 很多其他网络插件的设计中都能找到 Flannel 的影子. 早在 2014 年, VXLAN 还没有进入 Linux 内核的时候,  Flannel 就已经开始流行, 当时的 Flannel 只能采用自定义的 UDP 封包实现自己私有协议的 Overlay 网络, 由于封包, 解包的操作只能在用户态中进行, 而数据包在内核态的协议栈中流转, 导致数据要在用户态, 内核态之间反复复制, 性能堪忧. 从此 Flannel 就给人留下了速度慢的坏印象. VXLAN 进入 Linux 内核后, 这种内核态, 用户态的转换消耗完全消失, Flannel-VXLAN 的效率比起 Flannel-UDP 有了很大提升, 目前已经成为最常用的容器网络插件之一.")]),t._v(" "),s("li",[s("strong",[t._v("路由模式")]),t._v(": 路由模式其实属于 Underlay 模式的一种特例, 这里将它单独作为一种网络实现模式来介绍. 相比 Overlay 网络, 路由模式的主要区别在于它的跨主机通信是直接通过路由转发来实现的, 因而无须在不同主机之间进行隧道封包. 这种模式的好处是"),s("strong",[t._v("性能比 Overlay 网络有明显提升")]),t._v(", 坏处是路由转发要依赖底层网络环境的支持, 并不是你想做就能做到的. "),s("strong",[t._v("路由网络要求要么所有主机都位于同一个子网之内, 都是二层连通的, 要么不同二层子网之间由支持边界网关协议")]),t._v("(Border Gateway Protocol, BGP)的路由相连, 并且网络插件也同样支持 BGP 协议去修改路由表. 前面提到在 Linux 系统中不需要专门的虚拟路由, 因为 Linux 本身就具备路由的功能. 路由模式就是依赖 Linux 内置在系统之中的路由协议, 将路由表分发到子网的每一台物理主机的. 这样, 当跨主机访问容器时, Linux 主机可以根据自己的路由表得知该容器具体位于哪台物理主机之中, 从而直接将数据包转发过去, 避免了 VXLAN 的封包, 解包而导致的性能降低. 常见的路由网络有 Flannel(HostGateway 模式), Calico(BGP 模式)等. 这里以 Flannel-HostGateway 为例, Flannel 通过在各个节点上运行的 Flannel Agent(Flanneld) 将容器网络的路由信息设置到主机的路由表上, 这样一来, 所有的物理主机都将拥有整个容器网络的路由数据, 且容器间的数据包可以被 Linux 主机直接转发, 使得通信效率与裸机直连相差无几. 不过, 由于 Flannel Agent 只能修改运行主机上的路由表, 一旦主机之间隔了其他路由设备, 譬如路由器或者三层交换机, 这个包就会在路由设备上被丢掉, 要解决这种问题就必须依靠 BGP 路由和 Calico-BGP 这类支持标准 BGP 协议修改路由表的网络插件共同协作才行.")]),t._v(" "),s("li",[s("strong",[t._v("Underlay 模式")]),t._v(": 这里的 Underlay 模式特指让容器和宿主机处于同一网络, 两者拥有相同地位的网络方案. Underlay 网络要求容器的网络接口能够直接与底层网络进行通信, 因此该模式是直接依赖于虚拟化设备与底层网络能力的. 常见的 Underlay 网络插件有 MACVLAN, SR-IOV(Single Root I/O Virtualization) 等. 对于真正的大型数据中心, 大型系统, Underlay 模式才是最有发展潜力的网络实现模式. 这种模式能够最大限度地利用硬件的能力, 往往有着最优秀的性能表现. 但也是由于它直接依赖于硬件与底层网络环境, 必须根据软, 硬件情况来进行部署, 难以做到 Overlay 网络那样开箱即用的灵活性. 这里以 SR-IOV 为例, SR-IOV 不是某种专门的网络名字, 而是一种将 PCIe 设备共享给虚拟机使用的硬件虚拟化标准, 目前多用于网络设备中, 理论上也可以支持其他的 PCIe 硬件. 通过 SR-IOV 能够让硬件在虚拟机上实现独立的内存地址, 中断和 DMA 流, 而无须虚拟机管理系统的介入. 对于容器系统来说, SR-IOV 的价值是可以直接在硬件层面虚拟多张网卡, 并且以硬件直通(Passthrough)的形式交付给容器使用. 但是 SR-IOV 直通部署起来通常比较烦琐, 现在容器用的 SR-IOV 方案很多是使用 MACVTAP 来对 SR-IOV 网卡进行转接的, MACVTAP 提升了 SR-IOV 的易用性, 但是这种转接又会带来额外的性能损失, 并不一定会比其他网络方案有更好的表现.")])]),t._v(" "),s("p",[t._v("了解过 CNI 插件大致的实现原理与分类后, 下一个问题就是哪种 CNI 网络最好? 如何选择合适的 CNI 插件? 选择 CNI 网络插件时主要有两方面的考量因素, 首先必须是"),s("strong",[t._v("系统所处的环境是支持 CNI 插件的")]),t._v(", 在环境可以支持的前提下, 另外一个因素"),s("strong",[t._v("就是性能与功能方面是否合乎的要求")]),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"持久化存储"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#持久化存储"}},[t._v("#")]),t._v(" 持久化存储")]),t._v(" "),s("p",[t._v("容器是镜像的运行时实例, 为了保证镜像能够重复地产出"),s("strong",[t._v("具备一致性的运行时实例")]),t._v(", 必须要求"),s("strong",[t._v("镜像本身是持久且稳定")]),t._v("的, 这决定了在"),s("strong",[t._v("容器中发生的一切数据变动操作都不能真正写入镜像")]),t._v("当中, 否则必然会破坏镜像稳定不变的性质. 为此, 容器中的数据修改操作大多是基于"),s("strong",[t._v("写入时复制")]),t._v("(Copy-on-Write)策略来实现的, 容器会利用"),s("strong",[t._v("叠加式文件系统")]),t._v("(OverlayFS)的特性, "),s("strong",[t._v('在用户意图修改镜像时, 自动将变更的内容写入独立区域, 再与原有数据叠加到一起, 使其从外观上看来像是"覆盖"了原有内容')]),t._v(". 这种改动通常都是临时的, 一旦容器终止运行, 这些存储于独立区域中的变动信息也将被一并移除, 不复存在. 由此可见, 如果"),s("strong",[t._v("不进行额外的处理, 容器默认是不具备持久化存储能力")]),t._v("的.")]),t._v(" "),s("p",[t._v("而另一方面, 容器作为信息系统的运行载体, 必定会产出有价值的, "),s("strong",[t._v("应该被持久保存的信息")]),t._v(", 譬如扮演数据库角色的容器, 大概没有什么系统能够接受数据库像缓存服务一样重启之后丢失全部数据; 多个容器之间也经常需要通过共享存储来实现某些交互操作, 譬如以前举过的例子, Nginx 容器产生日志, Filebeat 容器收集日志, 两者需要共享同一块日志存储区域才能协同工作. 正因为"),s("strong",[t._v("镜像的稳定性与生产数据的持久性存在矛盾")]),t._v(", 由此才产生了本章的主题: "),s("strong",[t._v("如何实现容器的持久化存储")]),t._v(".")]),t._v(" "),s("h4",{attrs:{id:"kubernetes存储设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes存储设计"}},[t._v("#")]),t._v(" Kubernetes存储设计")]),t._v(" "),s("p",[t._v("Kubernetes 在规划持久化存储能力的时候, 依然遵循着它的一贯设计哲学, 即"),s("strong",[t._v("用户负责以资源和声明式 API 来描述自己的意图, Kubernetes 负责根据用户意图来完成具体的操作")]),t._v('. 不过, 仅描述清楚用户的存储意图也并不是一件容易的事, 相比 Kubernetes 提供的其他能力的资源, 其内置的存储资源显得格外复杂, 甚至可以说是有些烦琐的. 下列围绕 "Volume" 所衍生出的概念, 它们仅仅是与 Kubernetes 存储相关的概念的一个子集而已, 请你思考一下这些概念是否全都是必需的, 是否还有整合的空间, 以及是否有化繁为简的可能性.')]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("概念: Volume, PersistentVolume, PersistentVolumeClaim, Provisioner, StorageClass, Volume Snapshot, Volume Snapshot Class, Ephemeral Volumes, FlexVolume Driver, Container Storage Interface, CSI Volume Cloning, Volume Limits, Volume Mode, Access Modes, Storage Capacity...")]),t._v(" "),s("p",[t._v("操作: Mount, Bind, Use, Provision, Claim, Reclaim, Reserve, Expand, Clone, Schedule, Reschedule...")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("诚然, Kubernetes 提出了如此多关于存储的概念, 最重要的原因是存储技术本来就门类众多, 为了尽可能多地兼容各种存储技术, Kubernetes 不得不预置了很多 "),s("strong",[t._v("In-Tree")]),t._v(" (意思是在 Kubernetes 的代码树里)插件来对接, 让用户根据自己的"),s("strong",[t._v("业务按需选择")]),t._v(". 同时, 为了兼容那些不在预置范围内的需求场景, 支持用户使用 FlexVolume 或者 CSI 来定制 Out-of-Tree (意思是在 Kubernetes 的代码树之外)插件, 实现更加丰富多样的存储能力.")]),t._v(" "),s("p",[t._v("迫使 Kubernetes 的存储设计如此复杂的另外一个"),s("strong",[t._v("非技术层面")]),t._v("的原因是: Kubernetes 是一个工业级的, 面向"),s("strong",[t._v("生产应用的容器编排系统")]),t._v(", 这意味着即使发现某些已存在的功能有更好的实现方式, 直到旧版本被淘汰前, "),s("strong",[t._v("原本已支持的功能都不允许突然间被移除或者替换掉")]),t._v(", 否则, 如果生产系统更新版本, 已有的功能就出现异常, 那么产品累积的良好信誉就会受损.")]),t._v(" "),s("p",[t._v("为了兼容而导致的烦琐, 在一定程度上可以被谅解, 但这样的设计的确令 Kubernetes 的学习曲线变得更加陡峭. Kubernets 官方文档的主要作用是提供参考, 它并不会告诉你 Kubernetes 中各种概念的演化历程, 版本发布新功能的时间线, 改动的缘由与背景等信息. "),s("strong",[t._v('Kubernetes 的文档系统只会以 "平坦" 的方式来陈述所有目前可用的功能, 这有利于熟练的管理员快速查询到关键信息')]),t._v(', 却不利于初学者去理解 Kubernetes 的设计思想. 由于难以理解那些概念和操作的本意, 初学者往往只能死记硬背, 也很难分辨出它们应该如何被 "更正确" 的使用. 所以, 介绍Kubernetes 设计理念的职责, 只能由 Kubernetes 官方的 Blog 这类定位超越了参考手册的信息渠道或者其他非官方资料去完成. 本节以 '),s("strong",[t._v("Volume 概念从操作系统到 Docker 再到 Kubernetes 的演进历程为主线, 梳理前面提及的那些概念与操作")]),t._v(", 以此帮助大家理解 Kubernetes 的存储设计.")]),t._v(" "),s("h5",{attrs:{id:"_1-mount和volume"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-mount和volume"}},[t._v("#")]),t._v(" 1.Mount和Volume")]),t._v(" "),s("p",[t._v("Mount 和 Volume 都是源自操作系统的常用术语. Mount 是动词, 表示将"),s("strong",[t._v("某个外部存储挂载到系统")]),t._v("中; Volume 是名词, 表示物理存储的逻辑抽象, 目的是为"),s("strong",[t._v("物理存储提供有弹性的分割方式")]),t._v(". 容器源于对操作系统层的虚拟化, 为了满足容器内生成数据的外部存储需求, 很自然地会将 Mount 和 Volume 的概念延拓至容器中. 要了解容器存储的发展, 不妨就以 Docker 的 Mount 操作为起始点.")]),t._v(" "),s("p",[t._v("目前, Docker 内置了"),s("strong",[t._v("三种挂载类型")]),t._v(", 分别是 "),s("strong",[t._v("Bind")]),t._v("(--mount type=bind), "),s("strong",[t._v("Volume")]),t._v("(--mount type=volume)和 "),s("strong",[t._v("tmpfs(--mount type=tmpfs), 如下图所示. 其中 tmpfs 用于在")]),t._v("内存中读写临时数据, 不属于本节主要讨论的对象持久化存储范畴, 所以后面只着重关注 "),s("strong",[t._v("Bind 和 Volume")]),t._v(" 两种挂载类型.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230111235014094.png",alt:"",title:"Docker的三种挂载类型"}})]),t._v(" "),s("p",[t._v("Bind Mount 是 Docker 最早提供的(发布时就支持)挂载类型, 作用是"),s("strong",[t._v("把宿主机的某个目录(或文件)挂载到容器的指定目录(或文件)下")]),t._v(", 譬如以下命令中参数 -v 表达的意思就是将外部的 HTML 文档挂载到 Nginx 容器的默认网站根目录下:")]),t._v(" "),s("div",{staticClass:"language-shell line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("docker")]),t._v(" run "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-v")]),t._v(" /icyfenix/html:/usr/share/nginx/html nginx:latest\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("请注意, 虽然命令中的 -v 参数是 --volume 的缩写, 但  "),s("strong",[t._v("-v 最初只是用来创建 Bind Mount")]),t._v(" 而不是创建 Volume Mount 的, 这种迷惑的行为也并非 Docker 的本意, 只是由于 Docker 刚发布时考虑得不够周全, 随随便便就在参数中"),s("strong",[t._v("占用")]),t._v("了 Volume 这个词, 到后来真的需要扩展 Volume 的概念来"),s("strong",[t._v("支持 Volume Mount")]),t._v(" 时, 前面的 -v 已经被用户广泛使用了, 所以只得如此将就着继续用. 从 Docker 17.06 版本开始, 它在 Docker Swarm 中借用了  "),s("strong",[t._v("--mount 参数")]),t._v(", 该参数默认创建的是 Volume Mount, 可以通过明确的 type 子参数来指定另外两种挂载类型. 上面的命令等价于如下形式:")]),t._v(" "),s("div",{staticClass:"language-shell line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("docker")]),t._v(" run "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--mount")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("type")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("bind,source"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("/icyfenix/html,destination"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("/usr/share/\n    nginx/html nginx:latest\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("从 Bind Mount 到 Volume Mount, 实质是容器发展过程中"),s("strong",[t._v("对存储抽象能力提升")]),t._v('的外在表现. 从 Bind 这个名字以及 Bind Mount 的实际功能可以合理地推测出, Docker 最初认为 Volume 就只是一种 "'),s("strong",[t._v("外部宿主机的磁盘存储到内部容器的映射关系")]),t._v('", 但后来发现事情并没有那么简单: '),s("strong",[t._v("存储的位置并不局限于外部宿主机, 存储的介质并不局限于物理磁盘, 存储的管理也并不局限于映射关系")]),t._v(".")]),t._v(" "),s("p",[t._v("譬如, Bind Mount 只允许容器与本地宿主机之间建立某个目录的映射, 如果想要在"),s("strong",[t._v("不同宿主机")]),t._v("上的容器共享同一份存储, 就必须"),s("strong",[t._v("先把共享存储挂载到每一台宿主机操作系统的某个目录下, 然后才能逐个挂载到容器内使用")]),t._v(", 这种跨宿主机共享存储的场景如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230111235941850.png",alt:"",title:"跨主机的共享存储需求"}})]),t._v(" "),s("p",[s("strong",[t._v("这种存储范围超越了宿主机的共享存储")]),t._v(", 配置过程却要涉及大量与宿主机环境相关的操作, 只能由管理员人工去完成, 不仅烦琐, 而且"),s("strong",[t._v("很难自动化")]),t._v("(每台宿主机环境的差异所致).")]),t._v(" "),s("p",[t._v("又譬如, 即便只考虑单台宿主机的情况, 基于可管理性的需求, Docker 也完全有支持 Volume Mount 的必要. 在 Bind Mount 的设计里, "),s("strong",[t._v("Docker 只有容器的控制权")]),t._v(", 而存放容器生产数据的主机目录是"),s("strong",[t._v("完全独立")]),t._v("的, 与 Docker 没有任何关系, 既不受 Docker 保护, 也不受 Docker 管理. "),s("strong",[t._v("数据很容易被其他进程访问到, 甚至被修改和删除")]),t._v(". 如果用户想对挂载的目录进行备份, 迁移等管理运维操作, 也只能在 Docker 之外靠管理员人工进行, 增加了数据安全与操作意外的风险. 因此, Docker 希望能"),s("strong",[t._v("有一种抽象的资源来代表在宿主机或网络中存储的区域")]),t._v(", 以便让 Docker 能管理这些资源, 由此就很自然地联想到了操作系统里 "),s("strong",[t._v("Volume")]),t._v(" 的概念.")]),t._v(" "),s("p",[t._v("提出 Volume 的最核心的目的是"),s("strong",[t._v("提升 Docker 对不同存储介质的支撑能力")]),t._v(", 这同时也可以减轻 Docker 本身的工作量. "),s("strong",[t._v("存储并不是仅有挂载在宿主机上的物理存储这一种介质, 云计算时代, 网络存储逐渐成为数据中心的主流选择")]),t._v(", 不同的网络存储有各自的协议和交互接口, 而且并非所有存储系统都适合先挂载到操作系统, 再挂载到容器上, 如果 Docker 想要越过操作系统去支持挂载某种存储系统, 首先必须要知道该如何访问它, 然后才能将容器中的读写操作自动转移到该位置. Docker 把解决"),s("strong",[t._v("如何访问存储系统的功能模块称为存储驱动")]),t._v("(Storage Driver). 通过 docker info 命令能查看到当前 Docker 所支持的存储驱动. 虽然 Docker 已经内置了市面上主流的 OverlayFS 驱动, 譬如 Overlay2, AUFS, BTRFS, ZFS 等, 但面对云计算的快速迭代, 仅靠 Docker 自己来支持全部云计算厂商的存储系统是完全不现实的, 为此, Docker 提出了与 Storage Driver 相对应的 Volume Driver(卷驱动)的概念. 用户可以通过 "),s("strong",[t._v("docker plugin install 命令安装外部的卷驱动")]),t._v(", 并在创建 Volume 时指定一个与其存储系统相匹配的卷驱动, 譬如希望数据存储在 AWS Elastic Block Store 上, 就找一个 AWS EBS 的驱动, 如果想存储在 Azure File Storage 上, 就找一个对应的 Azure File Storage 驱动. 如果创建 Volume 时不指定卷驱动, 将默认为 local 类型, 在 Volume 中存放的数据会存储在宿主机的  "),s("strong",[t._v("/var/lib/docker/volumes/")]),t._v("  目录中.")]),t._v(" "),s("h5",{attrs:{id:"_2-静态存储分配"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-静态存储分配"}},[t._v("#")]),t._v(" 2.静态存储分配")]),t._v(" "),s("p",[t._v("现在把讨论主角转回"),s("strong",[t._v("容器编排系统")]),t._v("上. Kubernetes 同样将操作系统和 Docker 的 Volume 概念延续了下来, 并对其进行了"),s("strong",[t._v("细化")]),t._v(". "),s("strong",[t._v("Kubernetes 将 Volume 分为持久化的 PersistentVolume 和非持久化的普通 Volume 两类")]),t._v('. 为了不与前面定义的 Volume 概念混淆, 后面特指 Kubernetes 中非持久化的 Volume 时, 都会带着 "普通" 这个前缀.')]),t._v(" "),s("p",[t._v("普通 Volume 的设计目标"),s("strong",[t._v("不是为了持久地保存数据, 而是为同一个 Pod 中多个容器提供可共享的存储资源")]),t._v(", 因此 Volume 具有十分明确的"),s("strong",[t._v("生命周期---与挂载它的 Pod 相同的生命周期")]),t._v(", 这意味着尽管普通 Volume 不具备持久化的存储能力, 但至少比 Pod 中运行的任何"),s("strong",[t._v("容器的存活期都更长")]),t._v(". "),s("strong",[t._v("Pod 中不同的容器能共享相同的普通 Volume, 当容器重新启动时, 普通 Volume 中的数据也能够保留. 当然, 一旦整个 Pod 被销毁, 普通 Volume 也将不复存在, 数据在逻辑上也会被销毁掉, 至于实质上是否会真正删除数据, 就取决于存储驱动具体是如何实现 Unmount, Detach, Delete 接口的")]),t._v(', 由于本节的主题为 "持久化存储", 所以无持久化能力的普通 Volume 就不再展开介绍了.')]),t._v(" "),s("p",[t._v("从操作系统里传承下来的 Volume 概念, 在 Docker 和 Kubernetes 中继续按照一致的逻辑延伸拓展, 只不过 Kubernetes 为将其与普通 Volume 区别开来, 专门取了 "),s("strong",[t._v("PersistentVolume")]),t._v(" 这个名字, 你可以从下图中直观地看出普通 Volume, PersistentVolume 和 Pod 之间的关系差异.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230114154344788.png",alt:"image-20230114154344788",title:"普通Volume与PersistVolume的区别"}})]),t._v(" "),s("p",[t._v("从 Persistent 这个单词就能看出, PersistentVolume 是指"),s("strong",[t._v("能够持久化存储数据")]),t._v("的一种资源对象, 它可以"),s("strong",[t._v("独立于 Pod 存在, 且生命周期与 Pod 无关")]),t._v(", 因此也决定了 PersistentVolume "),s("strong",[t._v("不应该依附于任何一个宿主机节点")]),t._v(", 否则必然会对 Pod 调度产生干扰限制. 前面表13-1中 Persistent 一列里都是网络存储便是很好的印证.")]),t._v(" "),s("p",[t._v("将 PersistentVolume 与 Pod 分离后, 便需要专门考虑 "),s("strong",[t._v("PersistentVolume 该如何被 Pod 引用")]),t._v('的问题. 原本在 Pod 中引用其他资源是常有的事, 要么通过资源名称直接引用, 要么通过标签选择器(Selector)间接引用. 但是类似的方法在这里却都不太妥当, 至于原因, 请你想一下 "Pod 该使用何种存储" 这件事情应该是由系统管理员(运维人员)说了算, 还是由用户(开发人员)说了算. 最合理的答案是他们一起说了才算, 因为只有开发人员能准确评估 Pod 需要消耗多大的存储空间, 只有运维人员清楚地知道当前系统可以使用的存储设备状况. 为了让他们得以提供各自擅长的信息, Kubernetes 又额外设计出了 '),s("strong",[t._v("PersistentVolumeClaim 资源")]),t._v(". Kubernetes 官方给出的概念定义也特别"),s("strong",[t._v("强调了 PersistentVolume 是由管理员(运维人员)负责维护, 由用户(开发人员)通过 PersistentVolumeClaim 来匹配到合乎需求的 PersistentVolume")]),t._v(".")]),t._v(" "),s("hr"),t._v(" "),s("ul",[s("li",[t._v("PersistentVolume 是由管理员负责提供的集群存储.")]),t._v(" "),s("li",[t._v("PersistentVolumeClaim 是由用户负责提供的存储请求.")])]),t._v(" "),s("p",[t._v("---Kubernetes Documentation/Reference, PersistentVolume")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("PersistentVolume 是 Volume 这个抽象概念的"),s("strong",[t._v("具象化表现")]),t._v(", 通俗地说, 它是"),s("strong",[t._v("已经被管理员分配好的具体的存储")]),t._v(', 这里的"具体"是指'),s("strong",[t._v("有明确的存储系统地址, 有明确的容量, 访问模式, 存储位置等信息")]),t._v("; 而 "),s("strong",[t._v("PersistentVolumeClaim 则是 Pod 对其所需存储能力的声明")]),t._v(", 通俗地说就是满足这个 Pod 正常运行要满足怎样的条件, 譬如要"),s("strong",[t._v("消耗多大的存储空间")]),t._v(", 要支持怎样的访问方式. 因此"),s("strong",[t._v("两者并不是谁引用谁的固定关系, 而是根据实际情况动态匹配的")]),t._v(", 两者配合的具体工作过程如下.")]),t._v(" "),s("p",[t._v("(1)管理员准备好要使用的存储系统, 它应是某种"),s("strong",[t._v("网络文件系统(NFS)或者云储存系统")]),t._v(", 一般来说应该具备"),s("strong",[t._v("跨主机共享")]),t._v("的能力.")]),t._v(" "),s("p",[t._v("(2)管理员根据存储系统的实际情况手工"),s("strong",[t._v("预先分配好若干个 PersistentVolume")]),t._v(", 并定义好每个 PersistentVolume "),s("strong",[t._v("可以提供的具体能力")]),t._v(". 譬如:")]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" v1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" PersistentVolume\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" nginx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("html\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("capacity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("storage")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 5Gi                          "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 最大容量为5GB")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("accessModes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" ReadWriteOnce                       "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 访问模式为RXO")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("persistentVolumeReclaimPolicy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Retain   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 回收策略是Retain")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("nfs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("                                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 存储驱动是NFS")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /html\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("server")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 172.17.0.2\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br")])]),s("p",[t._v("以上 YAML 中定义的存储能力具体为:")]),t._v(" "),s("ul",[s("li",[t._v("存储的最大容量是 5GB.")]),t._v(" "),s("li",[t._v('存储的访问模式是 "'),s("strong",[t._v("只能被一个节点读写挂载")]),t._v('"(ReadWriteOnce, RWO), 另外两种可选的访问模式是 "'),s("strong",[t._v("可以被多个节点以只读方式挂载")]),t._v('"(ReadOnlyMany, ROX)和 "'),s("strong",[t._v("可以被多个节点读写挂载")]),t._v('"(ReadWriteMany, RWX).')]),t._v(" "),s("li",[t._v("存储的回收策略是 Retain, 即在 Pod 被销毁时"),s("strong",[t._v("并不会删除")]),t._v("数据. 另外两种可选的回收策略分别是 Recycle 和 Delete. Recycle 策略下在 "),s("strong",[t._v("Pod 被销毁时, 由 Kubernetes 自动执行 rm -rf /volume/")]),t._v(" "),s("em",[t._v("这样的命令来自动删除资料")]),t._v("*. Delete 策略下, Kubernetes 会自动调用 AWS EBS, GCE PersistentDisk, OpenStack Cinder 这些云存储的删除指令.")]),t._v(" "),s("li",[t._v("存储驱动是 NFS, 其他常见的存储驱动还有 AWS EBS, GCE PD, iSCSI, RBD(Ceph Block Device), GlusterFS, HostPath 等.")])]),t._v(" "),s("p",[t._v("(3)"),s("strong",[t._v("用户根据业务系统的实际情况创建 PersistentVolumeClaim, 声明 Pod 运行所需的存储能力")]),t._v(". 譬如:")]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" PersistentVolumeClaim\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" v1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" nginx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("html"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("claim\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("accessModes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" ReadWriteOnce    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 支持RXO访问模式")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("resources")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("requests")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("storage")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 5Gi     "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 最小容量5GB")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("p",[t._v("以上 YAML 中声明了容量不得小于 5GB, 必须支持 RWO 的访问模式.")]),t._v(" "),s("p",[t._v("(4)"),s("strong",[t._v("Kubernetes 在创建 Pod 的过程中, 会根据系统中 PersistentVolume 与 Persistent-VolumeClaim 的供需关系对两者进行")]),t._v("​"),s("mark",[s("strong",[t._v("撮合")])]),t._v(". 如果系统中存在满足 PersistentVolumeClaim 声明中要求能力的 PersistentVolume, 则撮合成功, 将它们绑定. 如果撮合不成功, Pod 就不会被继续创建, 直至系统中出现新的或让出空闲的 PersistentVolume 资源.")]),t._v(" "),s("p",[t._v("(5)以上几步都顺利完成的话, 意味着 Pod 的存储需求得到了满足, 可"),s("strong",[t._v("继续 Pod 的创建")]),t._v("过程. 整个过程如下图所示.")]),t._v(" "),s("p",[t._v("​"),s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230114155945407.png",alt:"image-20230114155945407",title:"PersistVolumeClaim与PersistVolume的工作过程"}}),t._v("​")]),t._v(" "),s("p",[t._v("Kubernetes 对 PersistentVolumeClaim 与 PersistentVolume 的撮合结果是"),s("strong",[t._v("产生一对一的绑定关系")]),t._v(', "一对一" 的意思是 '),s("strong",[t._v("PersistentVolume 一旦绑定在某个 PersistentVolumeClaim 上, 直到释放以前都会被这个 PersistentVolumeClaim 所独占")]),t._v(", 不能再与其他 Persistent-VolumeClaim 进行绑定. 这意味着即使 PersistentVolumeClaim 申请的存储空间比 Persistent-Volume 能够提供的要少, 依然要求整个存储空间都为该 PersistentVolumeClaim 所用, 这有可能会造成资源的"),s("strong",[t._v("浪费")]),t._v(". 譬如, 某个 PersistentVolumeClaim 要申请 3GB 的存储容量, 而当前 Kubernetes 手上只剩下一个 5GB 的 PersistentVolume, 此时 Kubernetes 只好将这个 PersistentVolume 与申请资源的 PersistentVolumeClaim 进行绑定, 平白浪费了 2GB 空间. 假设后续有另外一个 PersistentVolumeClaim 申请 2GB 的存储空间, 那它也只能"),s("strong",[t._v("等待")]),t._v("管理员分配新的 PersistentVolume, 或者有其他 PersistentVolume 被回收之后才能被成功分配.")]),t._v(" "),s("h5",{attrs:{id:"_3-动态存储分配"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-动态存储分配"}},[t._v("#")]),t._v(" 3.动态存储分配")]),t._v(" "),s("p",[t._v("对于中小规模的 Kubernetes 集群, PersistentVolume 已经能够满足有状态应用的存储需求, 它依靠"),s("strong",[t._v("人工介入来分配空间")]),t._v("的设计, 简单直观, 却算不上先进, 一旦应用规模增大, 其很难被自动化的问题就会突显出来. 这是由于在 Pod 创建过程中去挂载某个 Volume 时, 要求该 Volume 必须是真实存在的, 否则 Pod 启动可能依赖的数据(如一些配置, 数据, 外部资源等)都将无从读取. Kubernetes 有能力随着流量压力和硬件资源状况, "),s("strong",[t._v("自动扩缩 Pod 的数量")]),t._v(", 但是当 Kubernetes 自动扩展出一个新的 Pod 时, "),s("strong",[t._v("并没有办法让 Pod 去自动挂载一个还未被分配资源的 PersistentVolume")]),t._v(". 想解决这个问题, 要么允许多个不同的 Pod 共用相同的 PersistentVolumeClaim, 这种方案确实只靠 PersistentVolume 就能解决, 却"),s("strong",[t._v("损失了隔离性")]),t._v(", 难以通用; 要么就要求每个 Pod 用到的 PersistentVolume 都是已经被"),s("strong",[t._v("预先建立并分配好")]),t._v("的, 这种方案靠管理员提前手工分配好是可以实现的, "),s("strong",[t._v("却损失了自动化能力")]),t._v(".")]),t._v(" "),s("p",[t._v("无论哪种情况, 都难以符合 Kubernetes 工业级编排系统的产品定位, 对于大型集群, 面对成百上千, 甚至成千上万的 Pod, 靠管理员手工分配存储肯定是难以应付的. 在 2017 年 Kubernetes 发布 1.6 版本后, 终于提供了今天被称为"),s("strong",[t._v("动态存储分配")]),t._v("(Dynamic Provisioning)的"),s("strong",[t._v("动态存储解决方案")]),t._v(", 让系统管理员摆脱了人工分配 PersistentVolume 的窘境, 与之相对, 人们把此前的分配方式称为"),s("strong",[t._v("静态存储分配")]),t._v("(Static Provisioning).")]),t._v(" "),s("p",[s("strong",[t._v("所谓动态存储分配方案, 是指在用户声明存储能力的需求时, 不是通过 Kubernetes 撮合来获得一个管理员人工预置的 PersistentVolume, 而是由特定的资源分配器(Provisioner)自动地在存储资源池或者云存储系统中分配符合用户存储需求的 PersistentVolume, 然后挂载到 Pod 中使用")]),t._v(". 完成这项工作的资源被命名为 "),s("strong",[t._v("StorageClass")]),t._v(", 它的具体工作过程如下.")]),t._v(" "),s("p",[t._v("(1)管理员根据存储系统的实际情况, 先准备好对应的"),s("strong",[t._v("资源分配器")]),t._v(". Kubernetes 官方已经提供了一系列预置的 In-Tree 资源分配器, 放置在 kubernetes.io 的 API 组之下. 其中部分资源分配器已经有了官方的 CSI 驱动, 譬如 vSphere 的 Kubernetes 自带驱动为 kubernetes.io/vsphere-volume, VMware 的官方驱动为 csi.vsphere.vmware.com.")]),t._v(" "),s("p",[t._v("(2)管理员"),s("strong",[t._v("不再手工分配 PersistentVolume")]),t._v(", 而是根据存储"),s("strong",[t._v("配置 StorageClass")]),t._v(". Pod 是可以动态扩缩的, 而存储则是相对固定的, 哪怕使用的是具有扩展能力的云存储, 也会将它们视为存储容量, IOPS 等参数可变的固定存储来看待. 譬如可以"),s("strong",[t._v("将来自不同云存储提供商, 不同性能, 支持不同访问模式的存储配置为各种类型的 StorageClass")]),t._v(', 这也是它名字中"Class"(类型)的由来, 如以下例子所示:')]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" storage.k8s.io/v1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" StorageClass\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" standard\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("provisioner")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" kubernetes.io/aws"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("ebs  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#AWS EBS的Provisioner")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("parameters")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("type")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" gp2\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("reclaimPolicy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Retain\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br")])]),s("p",[t._v("(3)用户依然通过 PersistentVolumeClaim 来声明所需的存储, 但是应在声明中明确指出该由哪个 StorageClass 来代替 Kubernetes 处理该 PersistentVolumeClaim 的请求, 譬如以下例子所示:")]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" v1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" PersistentVolumeClaim\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" standard"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("claim\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("accessModes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" ReadWriteOnce\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("storageClassName")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" standard  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#明确指出该由哪个StorageClass来处理该PersistentVolumeClaim的请求")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("resource")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("requests")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("storage")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 5Gi\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br")])]),s("p",[t._v("(4)如果 PersistentVolumeClaim 中要求的 StorageClass 及它用到的资源分配器均可用, 那这个 StorageClass 就会"),s("strong",[t._v("接管")]),t._v("原本由 Kubernetes 撮合 PersistentVolume 与 PersistentVolumeClaim 的操作, "),s("strong",[t._v("按照 PersistentVolumeClaim 中声明的存储需求, 自动生成满足该需求的 PersistentVolume 描述信息, 并发送给资源分配器处理")]),t._v(".")]),t._v(" "),s("p",[t._v("(5)资源分配器接收到 StorageClass 发来的"),s("strong",[t._v("创建 PersistentVolume 的请求")]),t._v("后, 会操作其背后的存储系统去"),s("strong",[t._v("分配空间")]),t._v(", 如果分配成功, 就生成并返回符合要求的 PersistentVolume 供 Pod 使用.")]),t._v(" "),s("p",[t._v("(6)以上几步都顺利完成的话, 意味着 Pod 的存储需求得到了满足, 可继续 Pod 的创建过程, 整个过程如下图所示.")]),t._v(" "),s("p",[t._v("​"),s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230114163327363.png",alt:"image-20230114163327363",title:"StorageClass的工作过程"}}),t._v("​")]),t._v(" "),s("p",[t._v("Dynamic Provisioning 与 Static Provisioning 并不是各有用途的互补设计, 而是"),s("strong",[t._v("对同一个问题先后出现的两种解决方案")]),t._v(". 你完全可以只用 Dynamic Provisioning 来满足所有 Static Provisioning 能够满足的存储需求, 包括那些不需要动态分配的场景, 甚至之前例子里使用 HostPath 在本地静态分配存储的操作, 都可以指定 no-provisioner 作为资源分配器的 StorageClass, 以 Local Persistent Volume 来代替, 譬如以下例子所示:")]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" storage.k8s.io/v1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" StorageClass\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" local"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("storage\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("provisioner")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" kubernetes.io/no"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("provisioner\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("volumeBindingMode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" WaitForFirstConsumer\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("p",[t._v("使用 "),s("strong",[t._v("Dynamic Provisioning 来分配存储无疑是更合理的设计")]),t._v(", 不仅省去了管理员的人工操作的中间层, 而且不再需要将 PersistentVolume 这样的概念暴露给最终用户, 因为 Dynamic Provisioning 里的 PersistentVolume 只是"),s("strong",[t._v("处理过程的中间产物")]),t._v(", 用户不需要接触和理解它, 只需要知道"),s("strong",[t._v("由 PersistentVolumeClaim 去描述存储需求, 由 StorageClass 去满足存储需求即可")]),t._v(". "),s("strong",[t._v("只描述意图而不关心中间具体的处理过程是声明式编程的精髓, 也是流程自动化的必要基础")]),t._v(".")]),t._v(" "),s("p",[t._v("由 Dynamic Provisioning 来分配存储还能获得更高的"),s("strong",[t._v("可管理性")]),t._v(", 譬如前面提到的回收策略, 当希望 PersistentVolume 跟随 Pod 一同被销毁时, 以前经常会将回收策略配置为 Recycle 来回收空间, 即让系统自动执行 rm -rf /volume/* 命令, 这种方式往往过于"),s("strong",[t._v("粗暴")]),t._v(', 遇到更精细的管理需求, 譬如 "删除到回收站" 或者 "敏感信息粉碎式彻底删除" 这样的功能时就很麻烦. 而 Dynamic Provisioning 中由于有'),s("strong",[t._v("资源分配器")]),t._v("的存在, 其创建, 回收都是由资源分配器的代码所管理, 所以更"),s("strong",[t._v("灵活")]),t._v(". 现在 Kubernetes 官方已经"),s("strong",[t._v("明确建议废弃 Recycle 策略")]),t._v(", 如有这类需求, 应由 Dynamic Provisioning 去实现.")]),t._v(" "),s("p",[t._v("Static Provisioning 的主要使用场景已局限于管理员能够手工管理存储的小型集群, 它符合很多小型系统尤其是私有化部署系统的现状, 但并不符合当今运维自动化所提倡的思路. Static Provisioning 的存在, 在某种意义上也可以视为对历史的一种兼容, 在可见的将来, Kubernetes 肯定仍会把 Static Provisioning 作为用户分配存储的一种主要方案供用户选用.")]),t._v(" "),s("h4",{attrs:{id:"容器存储与生态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器存储与生态"}},[t._v("#")]),t._v(" 容器存储与生态")]),t._v(" "),s("p",[t._v("容器存储具有很强的"),s("strong",[t._v("多样性")]),t._v(", "),s("strong",[t._v("如何对接后端实际的存储系统并且完全发挥出它所有的功能")]),t._v(", 并不是 Kubernetes 团队所擅长的工作, 这件事情只有存储提供商自己才能做到最好. 由此可以理解"),s("strong",[t._v("容器编排系统为何会有很强烈的意愿把存储功能独立到外部去实现")]),t._v(", 在前面的讲解中, 笔者已经反复提到 In-Tree, Out-of-Tree 插件, 本节会以存储插件的"),s("strong",[t._v("接口与实现")]),t._v("为中心, 去解析 Kubernetes 的"),s("strong",[t._v("容器存储生态")]),t._v(".")]),t._v(" "),s("h5",{attrs:{id:"_1-kubernetes存储架构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-kubernetes存储架构"}},[t._v("#")]),t._v(" 1.Kubernetes存储架构")]),t._v(" "),s("p",[t._v("正式开始讲解 Kubernetes 的 In-Tree, Out-of-Tree 存储插件前, 有必要了解一点 "),s("strong",[t._v("Kubernetes 存储架构")]),t._v("的知识, 大体上"),s("strong",[t._v("弄清楚一个真实的存储系统是如何接入新创建的 Pod 中, 成为可以读写访问的 Volume 的, 以及当 Pod 被销毁时, Volume 如何被回收, 回归到存储系统中")]),t._v("的. Kubernetes 参考了传统操作系统接入或移除新存储设备的做法, 把"),s("strong",[t._v("接入或移除外部存储")]),t._v("分解为以下三种操作.")]),t._v(" "),s("ul",[s("li",[t._v("首先, 决定应"),s("strong",[t._v("准备(Provision)哪种存储设备")]),t._v(", Provision 可类比为给操作系统扩容而购买了新的存储设备. 这步确定了接入存储设备的"),s("strong",[t._v("来源, 容量, 性能")]),t._v("以及其他技术参数, 它的逆操作是移除(Delete)存储.")]),t._v(" "),s("li",[t._v("然后, "),s("strong",[t._v("将准备好的存储设备附加(Attach)到系统中")]),t._v(", Attach 可类比为"),s("strong",[t._v("将存储设备接入操作系统")]),t._v(", 此时尽管设备还不能使用, 但已经可以用操作系统的 fdisk-l 命令看到设备. 这步确定了存储的"),s("strong",[t._v("设备名称")]),t._v(", 驱动方式等面向系统侧的信息, 它的逆操作是分离(Detach)存储设备.")]),t._v(" "),s("li",[t._v("最后, "),s("strong",[t._v("将附加好的存储挂载(Mount)到系统中")]),t._v(", Mount 可类比为"),s("strong",[t._v("将设备挂载到系统的指定位置")]),t._v(", 也就是起到操作系统中 mount 命令的作用. 这步确定了存储设备的访问目录, 文件系统格式等面向应用侧的信息, 它的逆操作是卸载(Unmount)存储设备.")])]),t._v(" "),s("p",[t._v("以上提到的 "),s("strong",[t._v("Provision, Delete, Attach, Detach, Mount, Unmount")]),t._v(" 六种操作, 并不是直接由 Kubernetes 来实现, 而是在"),s("strong",[t._v("存储插件")]),t._v("中完成的, 它们会分别被 Kubernetes 通过两个控制器及一个管理器来调用, 如下图所示, 这些控制器, 管理器的作用分别如下.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230114164106641.png",alt:"",title:"Kubernetes存储架构"}})]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("PV 控制器")]),t._v("(PersistentVolume Controller): Kubernetes 里所有的控制器都遵循"),s("strong",[t._v("相同的工作模式")]),t._v("--"),s("strong",[t._v("让实际状态尽可能接近期望状态")]),t._v(". "),s("strong",[t._v('PV 控制器的期望状态有两个, 分别是 "所有未绑定的 PersistentVolume 都能处于可用状态" 以及 "所有处于等待状态的 PersistentVolumeClaim 都能匹配到与之绑定的PersistentVolume"')]),t._v(" . PV 控制器内部也有两个相对独立的核心逻辑(ClaimWorker 和 VolumeWorker)来分别跟踪这两种期望状态, 可以简单地理解为 PV 控制器实现了 PersistentVolume 和 PersistentVolumeClaim 的"),s("strong",[t._v("生命周期管理职能")]),t._v(", 在这个过程中, 它会根据需要调用存储驱动插件的 Provision/Delete 操作.")]),t._v(" "),s("li",[s("strong",[t._v("AD 控制器")]),t._v("(Attach/Detach Controller): AD 控制器的"),s("strong",[t._v('期望状态是 "所有被调度到的准备创建新 Pod 的节点都附加了要使用的存储设备; 当 Pod 被销毁后, 原本运行 Pod 的节点都分离了不再使用的存储"')]),t._v(" , 如果实际状态不符合该期望, 会根据需要调用存储驱动插件的 Attach/Detach 操作.")]),t._v(" "),s("li",[s("strong",[t._v("Volume 管理器")]),t._v("(Volume Manager): Volume 管理器实际上是 kubelet 的一部分, 是 kubelet 的众多管理器之一, 主要用来支持本节点中 Volume 执行 Attach/Detach/Mount/Unmount 操作. 你可能注意到了, 这里不仅有 Mount/Unmount 操作, 也有 Attach/Detach 操作, 这是历史原因导致的, 由于最初版本的 Kubernetes 中并没有 AD 控制器, Attach/Detach 操作也在 kubelet 中完成. 现在 kubelet 默认情况下已经不再执行 Attach/Detach 操作了, 但有少量旧程序已经依赖了由 kubelet 来执行 Attach/Detach 操作的内部逻辑, 所以 kubelet 不得不设计一个  "),s("strong",[t._v("--enable-controller-attach-detach")]),t._v(" 参数, 如果将其设置为 false, 就会重新回到旧的兼容模式上, 由 kubelet 代替 AD 控制器来完成 Attach/Detach 操作.")])]),t._v(" "),s("p",[t._v("后端的真实存储依次经过 "),s("strong",[t._v("Provision, Attach, Mount")]),t._v(" 操作之后, 就形成了"),s("strong",[t._v("可以在容器中挂载的 Volume")]),t._v(", 当存储插件的生命周期完结, 依次经过 "),s("strong",[t._v("Unmount, Detach, Delete")]),t._v(" 操作之后, Volume 便能够被存储"),s("strong",[t._v("系统回收")]),t._v(". 对于某些存储插件来说, 其中有一些操作可能是无效的, 譬如 NFS, 实际使用中并不需要 Attach, 此时存储插件只需将 Attach 设置为空操作即可.")]),t._v(" "),s("h5",{attrs:{id:"_2-flexvolume与csi"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-flexvolume与csi"}},[t._v("#")]),t._v(" 2.FlexVolume与CSI")]),t._v(" "),s("p",[t._v("Kubernetes 目前同时支持 "),s("strong",[t._v("FlexVolume")]),t._v(" 与 "),s("strong",[t._v("CSI")]),t._v("(Container Storage Interface, 容器存储接口) 两套独立的"),s("strong",[t._v("存储扩展机制")]),t._v(". FlexVolume 是 Kubernetes 很早期版本(1.2 版本开始提供, 1.8 版本达到 GA 状态)就开始支持的扩展机制, 它是只针对 Kubernetes 的私有的存储扩展, 目前已经处于"),s("strong",[t._v("冻结状态")]),t._v(", 可以正常使用但不再发展新的功能. CSI 则是从 Kubernetes 1.9 版本开始加入的扩展机制, 与之前介绍过的 CRI 和 CNI 相同, CSI 是"),s("strong",[t._v("公开的技术规范")]),t._v(", 任何容器运行时, 容器编排引擎只要愿意支持, 都"),s("strong",[t._v("可以使用 CSI 规范去扩展自己的存储能力")]),t._v(", 这是目前 Kubernetes 重点发展的扩展机制.")]),t._v(" "),s("p",[t._v("由于 "),s("strong",[t._v("FlexVolume")]),t._v(" 是为 Kubernetes 量身订做的, 所以 FlexVolume 的实现逻辑与上一节介绍的 Kubernetes 的存储架构高度一致. "),s("strong",[t._v("FlexVolume 驱动其实就是一个实现了 Attach, Detach, Mount, Unmount 操作的可执行文件(甚至可以仅仅是个 Shell 脚本)而已")]),t._v(", 该可执行文件应该存放在集群每个节点的 /usr/libexec/kubernetes/kubelet-plugins/volume/exec 目录里, 其工作过程就是当 AD 控制器和 Volume 管理器需要进行 Attach, Detach, Mount, Unmount 操作时"),s("strong",[t._v("自动调用它的对应方法接口")]),t._v(", 如下图所示.")]),t._v(" "),s("p",[t._v("​"),s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230114165859541.png",alt:"image-20230114165859541",title:"Flex Volume Driver工作过程"}}),t._v("​")]),t._v(" "),s("p",[t._v("如果仅仅考虑支持最基本的 Static Provisioning, 那实现一个 FlexVolume 驱动确实是非常简单的. 然而也是由于 FlexVolume 过于简单了, 导致应用时会有诸多"),s("strong",[t._v("不便之处")]),t._v(".")]),t._v(" "),s("ul",[s("li",[t._v("FlexVolume 并不是全功能的驱动: 它不包含 Provision 和 Delete 操作, 也就无法直接用于 Dynamic Provisioning, 除非你愿意再单独编写一个 External Provisioner.")]),t._v(" "),s("li",[t._v("FlexVolume 的部署, 维护都"),s("strong",[t._v("相对烦琐")]),t._v(": 它是独立于 Kubernetes 的可执行文件, 当集群节点增加时, 需要由管理员在"),s("strong",[t._v("新节点上部署 FlexVolume")]),t._v(" 驱动, 有经验的系统管理员通常会专门编写一个 DaemonSet 来代替人工完成这项任务.")]),t._v(" "),s("li",[t._v("FlexVolume 实现复杂交互时也相对烦琐: FlexVolume 的每一次操作, 都是对插件可执行文件的一次"),s("strong",[t._v("独立调用")]),t._v(", 这种插件实现方式在各种操作需要相互通信时会很别扭. 譬如你希望在执行 Mount 操作的时候生成一些额外的状态信息, 供后面执行的 Unmount 操作使用, 此时只能把信息记录在某个"),s("strong",[t._v("约定好的临时文件")]),t._v("中, 对于一个面向生产的容器编排系统, 这样的做法实在是过于简陋了.")])]),t._v(" "),s("p",[t._v("相比 FlexVolume 的种种不足, "),s("strong",[t._v("CSI 可以说是一个十分完善的存储扩展规范")]),t._v(', 这里的"十分完善"并不是客套话, 根据 GitHub 的自动代码行统计, FlexVolume 的规范文档仅有 155 行, 而 CSI 则长达 2704 行. 总体上看, CSI 规范可以'),s("strong",[t._v("分为需要容器系统去实现的组件以及需要存储提供商去实现的组件两大部分")]),t._v(". 前者包括存储整体架构, Volume 的生命周期模型, 驱动注册, Volume 创建, 挂载, 扩容, 快照, 度量等内容, 目前, 通过 Kubernetes 提供的插件都已经完整地实现这些内容了, 其中涉及的"),s("strong",[t._v("主要组件")]),t._v("如下.")]),t._v(" "),s("ul",[s("li",[t._v("Driver Register: 负责注册第三方插件, CSI 0.3 版本之后已经处于 Deprecated 状态, 将会被 Node Driver Register 所取代.")]),t._v(" "),s("li",[t._v("External Provisioner: 调用第三方插件的接口来完成"),s("strong",[t._v("数据卷的创建与删除")]),t._v("操作.")]),t._v(" "),s("li",[t._v("External Attacher: 调用第三方插件的接口来完成"),s("strong",[t._v("数据卷的挂载")]),t._v("操作.")]),t._v(" "),s("li",[t._v("External Resizer: 调用第三方插件的接口来完成"),s("strong",[t._v("数据卷的扩容")]),t._v("操作.")]),t._v(" "),s("li",[t._v("External Snapshotter: 调用第三方插件的接口来完成"),s("strong",[t._v("快照的创建和删除")]),t._v("操作.")]),t._v(" "),s("li",[t._v("External Health Monitor: 调用第三方插件的接口来提供"),s("strong",[t._v("度量监控数据")]),t._v("功能.")])]),t._v(" "),s("p",[s("strong",[t._v("需要存储提供商去实现的组件才是 CSI 的主体部分")]),t._v(', 即前文中多次提到的 "第三方插件". 这部分'),s("strong",[t._v("着重定义了外部存储挂载到容器过程中所涉及操作的抽象接口和具体的通信方式")]),t._v(", 主要包括以下三个 gRPC 接口.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("CSI Identity 接口")]),t._v(": 用于描述插件的基本信息, 譬如插件版本号, 插件所支持的 CSI 规范版本, 插件是否支持存储卷创建及删除功能, 是否支持存储卷挂载功能, 等等. 此外 Identity 接口还用于检查插件的健康状态, 开发者可以通过实现 Probe 接口对外提供存储的健康度量信息.")]),t._v(" "),s("li",[s("strong",[t._v("CSI Controller 接口")]),t._v(": 用于从存储系统的角度对存储资源进行管理, 譬如准备和移除存储(Provision, Delete操作), 附加与分离存储(Attach, Detach操作), 对存储进行快照, 等等. 存储插件并不一定要实现这个接口的所有方法, 对于存储本身就不支持的功能, 可以在 CSI Identity 接口中声明为不提供.")]),t._v(" "),s("li",[s("strong",[t._v("CSI Node 接口")]),t._v(": 用于从集群节点的角度对存储资源执行各种操作, 譬如存储卷的分区和格式化, 将存储卷挂载到指定目录上或者将存储卷从指定目录上卸载等.")])]),t._v(" "),s("p",[t._v("与 FlexVolume 以单独的可执行程序的存在形式不同, "),s("strong",[t._v("CSI 插件本身便是由一组标准的 Kubernetes 资源所构成")]),t._v("的, CSI Controller 接口是一个以 StatefulSet 方式部署的 "),s("strong",[t._v("gRPC 服务")]),t._v(", CSI Node 接口则是基于 DaemonSet 方式部署的 gRPC 服务. 这意味着虽然 CSI 实现起来要比 FlexVolume 复杂得多, 但是却"),s("strong",[t._v("很容易安装, 如同安装 CNI 插件及其他应用那样, 直接载入 Manifest 文件即可")]),t._v(", 也不会遇到 FlexVolume 那样需要人工运维, 或者自己编写 DaemonSet 来维护集群节点变更的问题. 此外, 通过 gRPC 协议传递参数比通过命令行参数传递参数更加严谨, 灵活和可靠, 最起码不会出现多个接口之间协作只能写临时文件这样的尴尬状况.")]),t._v(" "),s("h5",{attrs:{id:"_3-从in-tree到out-of-tree"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-从in-tree到out-of-tree"}},[t._v("#")]),t._v(" 3.从In-Tree到Out-of-Tree")]),t._v(" "),s("p",[t._v("Kubernetes 曾内置了相当多的 In-Tree 的存储驱动, 甚至还早于 Docker 宣布支持卷驱动功能, 这种策略使得 Kubernetes "),s("strong",[t._v("能够在云存储提供商发布官方驱动之前就将其纳入支持范围中")]),t._v(", 同时减轻了管理员维护的工作量, 并为它在诞生初期快速占领市场做出了一定的贡献. 但这种策略也让 Kubernetes 丧失了随时添加或修改存储驱动的灵活性, 只能在更新大版本时才能加入或者修改驱动, 导致"),s("strong",[t._v("云存储提供商被迫与 Kubernetes 的发布节奏保持一致")]),t._v(". 此外, 还涉及第三方存储代码混杂在 Kubernetes 二进制文件中可能引起的可靠性及安全性问题. 因此, 当 Kubernetes 成为市场主流以后, 从 1.14 版本开始, Kubernetes 启动了 "),s("strong",[t._v("In-Tree 存储驱动的 CSI 外置迁移工作")]),t._v(". 按照计划, 在 1.21 到 1.22 版本时, Kubernetes 中主要的存储驱动, 如 AWS EBS, GCE PD, vSphere 等"),s("strong",[t._v("都会迁移至符合 CSI 规范的 Out-of-Tree 实现, 不再提供对 In-Tree 的支持")]),t._v(". 这种做法在设计上无疑是正确的, 然而这又带来了此前提过的该"),s("strong",[t._v("如何兼容旧功能")]),t._v("的策略问题, 譬如下面的 YAML 定义了一个 Pod:")]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" v1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Pod\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" nginx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("pod"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("example\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("containers")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" nginx\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("image")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" nginx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("latest\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("volumeMounts")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" html"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("pages"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("volume\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("mountPath")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /usr/share/nginx/html\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" config"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("volume\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("mountPath")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /etc/nginx\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("volumes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" html"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("pages"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("volume\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("hostPath")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("                 "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 来自本地的存储")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /srv/nginx/html\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("type")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Directory\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" config"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("volume\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("awsElasticBlockStore")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 来自AWS ESB的存储")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("volumeID")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" vol"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("0b39e0b08745caef4\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("fsType")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ext4\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br")])]),s("p",[t._v("代码中用到了类型为 hostPath 的 Volume, 这相当于 Docker 中驱动类型为 local 的 Volume, 不需要专门的驱动; 而类型为 awsElasticBlockStore 的 Volume, 从名字上就能看出是指存储驱动为 AWS EBS 的 Volume, 当 CSI 迁移完成, awsElasticBlockStore 从 In-Tree 卷驱动中移除之后, 它就应该"),s("strong",[t._v("按照 CSI 的写法")]),t._v("改写成如下形式:")]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" config"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("volume\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("csi")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("driver")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ebs.csi.aws.com\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("volumeAttributes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \n          "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("volumeID")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" vol"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("0b39e0b08745caef4\n          "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("fsType")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ext4\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("p",[t._v("这样的要求有悖于升级版本不应影响还在大范围使用的已有功能的原则, 所以 Kubernetes 1.17 版本中又提出了称为 "),s("strong",[t._v("CSIMigration")]),t._v(" 的解决方案, 让 Out-of-Tree 的驱动能够"),s("strong",[t._v("自动伪装成 In-Tree 的接口")]),t._v("来提供服务.")]),t._v(" "),s("p",[t._v("笔者专门花这两段来介绍 Volume 的 CSI 迁移, 倒不是由于它有多么重要的特性, 而是这种"),s("mark",[s("strong",[t._v("兼容性")])]),t._v("​"),s("strong",[t._v("设计本身就是 Kubernetes 设计理念的一个缩影")]),t._v(", 在 Kubernetes 的代码与功能中随处可见. "),s("strong",[t._v("好的设计需要权衡多个方面的利益, 很多时候都得顾及现实的影响, 要求设计向现实妥协, 而不能仅仅考虑理论最优的方案")]),t._v(".")]),t._v(" "),s("h5",{attrs:{id:"_4-容器插件生态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-容器插件生态"}},[t._v("#")]),t._v(" 4.容器插件生态")]),t._v(" "),s("p",[t._v("现在几乎所有云计算厂商都支持自家的容器"),s("strong",[t._v("通过 CSI 规范去接入外部存储")]),t._v(", 能够应用于 CSI 与 FlexVolume 的存储插件更是多达上百款, 已经算是形成了初步的生态环境. 这里不打算去谈论各种 CSI 存储插件的细节, 而是采取与 CNI 网络插件类似的讲述方式, 以不同的存储类型为线索, 介绍其中"),s("strong",[t._v("有代表性的实现")]),t._v(".")]),t._v(" "),s("p",[t._v("目前出现过的存储系统和设备均可以划分到"),s("strong",[t._v("块存储, 文件存储和对象存储")]),t._v("这三种存储类型之中, 划分的根本依据其实并非各种存储系统或设备如何存储数据---那完全是存储系统的事情, 更合理的划分依据应该是"),s("strong",[t._v("各种存储系统或设备提供何种形式的接口供外部访问数据, 不同的外部访问接口将反过来影响存储的内部结构, 性能与功能表现")]),t._v(". 虽然块存储, 文件存储和对象存储可以彼此"),s("strong",[t._v("协同工作")]),t._v(", 但它们各自都有明确的擅长领域与优缺点, 理解它们的工作原理, 因地制宜地选择最适合的存储类型, 才能让系统达到最佳的工作状态. 下面按照它们出现的时间顺序分别介绍.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("块存储")]),t._v(": 块存储是数据存储的最古老形式, 数据都存储在"),s("strong",[t._v("固定长度的一个或多个块")]),t._v("(Block)中, 想要读写访问数据, 就必须使用与存储类型相匹配的"),s("strong",[t._v("协议")]),t._v("(SCSI, SATA, SAS, FCP, FCoE, iSCSI等)来进行. 建议读者参考上一章网络通信中网络栈的数据流动过程, 把存储设备中由块构成的信息流与网络设备中由数据包构成的信息流进行对比, 事实上, 像 iSCSI 这种协议确实是建设在 TCP/IP 网络之上的, 上层以 SCSI 作为应用层协议对外提供服务. 硬盘就是最经典的块存储设备, 以机械硬盘为例, 一个块就是一个扇区, 大小通常在 512 字节至 4096 字节. 为了便于管理, 硬盘通常会以多个块(这些块甚至可以来自不同的物理设备, 譬如磁盘阵列的情况)来组成一个逻辑"),s("strong",[t._v("分区")]),t._v("(Partition), 将分区进行高级格式化之后就形成了"),s("strong",[t._v("卷")]),t._v('(Volume), 这便与之前提到的 "Volume 是源于操作系统的概念" 衔接了起来. 块存储由于贴近底层硬件, 没有文件, 目录, 访问权限等的牵绊, 所以'),s("strong",[t._v("性能通常都是最优秀")]),t._v("的, 吞吐量高, 延迟低. 尽管人类作为信息系统的最终用户, 并不会直接面对块来操作数据, 多数应用程序也是基于文件而不是块来读写数据, 但是操作系统"),s("strong",[t._v("内核")]),t._v("中的许多地方都直接通过块设备(Block Device)接口来访问硬盘, 一些追求 I/O 性能的软件, 譬如"),s("strong",[t._v("高性能的数据库, 也会支持直接读写块设备以提升磁盘 I/O")]),t._v(". 块存储的特点是具有"),s("strong",[t._v("排他性")]),t._v(", 一旦块设备被某个客户端挂载, 其他客户端就无法再访问上面的数据了, 因此, Kubernetes 中挂载的块存储的访问模式大都要求必须是 RWO(ReadWriteOnce)的.")]),t._v(" "),s("li",[s("strong",[t._v("文件存储")]),t._v(": "),s("strong",[t._v("文件存储是最贴近人类用户的数据存储形式")]),t._v(", 数据存储在长度不固定的文件之中, 用户可以针对文件进行新增, 写入, 追加, 移动, 复制, 删除, 重命名等各种操作, 通常文件存储还会提供文件查找, 目录管理, 权限控制等额外的高级功能. 文件存储的访问不像块存储那样有五花八门的协议, POSIX 接口已经成为事实标准, 被各种商用的存储系统和操作系统共同支持. 绝大多数传统的文件存储都是"),s("strong",[t._v("基于块存储")]),t._v("来实现的, 可以近似地认为文件是由块所组成的更高级存储单位. 对于固定不会发生变动的文件, 直接让每个文件连续占用若干个块, 在文件头尾加入标志区分即可, 磁带, CD-ROM, DVD-ROM 就采用了由"),s("strong",[t._v("连续块")]),t._v("来构成文件的存储方案; 但对于可能发生变动的场景, 就必须考虑"),s("strong",[t._v("如何跨多个不连续的块来构成文件")]),t._v(". 这种需求从数据结构角度看只需在每个块中记录好下一个块的地址, 形成链表结构即可满足. 但是链表的缺点是只能依次顺序访问, 这样访问文件中任何内容都要从头读取多个块, 显然过于低效了. 真正被广泛运用的解决方案是"),s("strong",[t._v("把形成链表的指针整合起来统一存放, 这便形成了文件分配表(File Allocation Table, FAT)")]),t._v(" . 既然已经有了专门组织块结构来构成文件的分配表, 那在表中再加入其他控制信息, 就能很方便地扩展出更多的高级功能, 譬如除了文件占用的块地址信息外, 加上文件的逻辑位置就形成了"),s("strong",[t._v("目录")]),t._v(", 加上文件的访问标志就形成了"),s("strong",[t._v("权限")]),t._v(", 还可以加上文件的名称, 创建时间, 所有者, 修改者等一系列元数据信息来"),s("strong",[t._v("构成其他应用形式")]),t._v(". 人们把"),s("strong",[t._v("定义文件分配表应该如何实现, 存储哪些信息, 提供什么功能的标准称为文件系统")]),t._v("(File System), FAT32, NTFS, exFAT, ext2/3/4, XFS, BTRFS 等都是很常用的文件系统. 而前面介绍存储插件接口时提到的对分区进行的高级格式化操作, 实际上就是在"),s("strong",[t._v("初始化一套空白的文件系统")]),t._v(", 供后续用户与应用程序访问. 文件存储相对于块存储来说是更高层次的存储类型, 加入目录, 权限等元素后形成的树状结构以及路径访问方式方便了人类理解, 记忆和访问; "),s("strong",[t._v("文件系统能够提供哪个进程打开或正在读写某个文件的信息, 这也有利于文件的共享处理")]),t._v(". 但在另一方面, 计算机需要对路径进行分解, 然后逐级向下查找, 最后才能查到需要的文件. 要从文件分配表中确定具体数据存储的位置, 要判断文件的访问权限, 要记录每次修改文件的用户与时间, 这些额外操作对于性能产生负面影响也是无可避免的, 因此, 如果一个系统选择不采用文件存储, 那磁盘 I/O 性能一般就是最主要的决定因素.")]),t._v(" "),s("li",[s("strong",[t._v("对象存储")]),t._v(": 对象存储是相对较新的数据存储形式, 是一种随着"),s("strong",[t._v("云数据中心")]),t._v("的兴起而发展起来的存储, 是以"),s("strong",[t._v("非结构化数据为目标的存储方案")]),t._v('. 这里的 "对象" 可以理解为一个'),s("strong",[t._v("元数据及与其配对的一个逻辑数据块的组合")]),t._v(", 元数据提供了对象所包含的上下文信息, 譬如数据的类型, 大小, 权限, 创建人, 创建时间等, 数据块则存储了对象的具体内容. 可以简单地理解为"),s("strong",[t._v("数据和元数据这两样东西共同构成了一个对象")]),t._v(". 每个对象都有属于自己的"),s("strong",[t._v("全局唯一标识")]),t._v(", 这个标识会直接开放给最终用户使用, 作为访问该对象的主要凭据, 通常会是 UUID 的形式. 对象存储的访问接口就是根据该唯一标识, 对逻辑数据块进行读/写/删除操作, 通常接口都十分简单, 甚至连修改操作都不会提供. 对象存储"),s("strong",[t._v("基本上只会在分布式存储系统之上去实现")]),t._v(', 由于对象存储天生就有明确的 "元数据" 概念, 不必依靠文件系统来提供数据的描述信息, 因此完全可以'),s("strong",[t._v("将一大批对象的元数据集中存放在某一台(组)服务器上")]),t._v(", 再辅以多台 OSD(Object Storage Device) 服务器来存储对象的数据块部分. 当外部要访问对象时, 多台 OSD 能够同时对外发送数据, 因此对象存储不仅易于共享, 容量庞大, 还能提供非常高的吞吐量. 不过, 由于需要先经过元数据查询确定 OSD 存放对象的确切位置, 该过程可能涉及多次网络传输, "),s("strong",[t._v("延迟方面就会表现得相对较差")]),t._v('. 由于对象的元数据仅描述对象本身的信息, 与其他对象都没有关联, 换言之每个对象都是相互独立的, 自然也就不存在目录的概念, 所以对象存储天然就是扁平化的, 与软件系统中很常见的 K/V 访问类似, 不过许多对象存储会提供 Bucket 的概念, 用户可以在逻辑上把它当作 "单层的目录" 来使用. 由于对象存储天生的分布式特性, 以及极其低廉的扩展成本, 很适合 CDN 一类的应用, 用于存放图片和音视频等媒体内容以及网页和脚本等静态资源.')])]),t._v(" "),s("p",[t._v("关于应该选择哪种存储类型的问题, 这里以世界云计算市场占有率第一的亚马逊为例, 简要对比介绍它选用的不同存储类型产品的差异.")]),t._v(" "),s("ul",[s("li",[t._v("亚马逊的块存储服务是 Amazon Elastic Block Store(AWS EBS), 购买 EBS 之后, 在 EC2(亚马逊的云计算主机)里看见的是一块原始的, 未格式化的"),s("strong",[t._v("块设备")]),t._v(". 这点就决定了 EBS 并不能作为一个独立存储而存在, 它总是和 EC2 同时被创建, EC2 的操作系统也只能安装在 EBS 之上. EBS 的大小理论上取决于建立的分区方案, 即块大小乘以块数量. MBR 分区的块数量是 232, 块大小通常是 512B, 总容量为 2TB. AWS 设置了上限是 16TB, 在此范围内的实际值就只取决于预算额度; EBS 的性能取决于选择的存储介质类型(SSD, HDD)和优化类型(通用性, 预置型, 吞吐量优化, 冷存储优化等), 这也将直接影响存储的费用成本. EBS 适合作为系统引导卷, 适合追求磁盘 I/O 的大型工作负载以及追求低时延的应用, 譬如 Oracle 等可以直接访问块设备的大型数据库更为合适. 但 EBS 只允许被单个节点挂载, 难以共享, 这点在单机时代是天经地义的, 但在云计算和分布式时代就成为很要命的缺陷. 除了少数特殊的工作负载外(如前面说的 Oracle 数据库), 笔者并不建议将它作为容器编排系统的主要外置存储来使用.")]),t._v(" "),s("li",[t._v("亚马逊的文件存储服务是 Amazon Elastic File System(AWS EFS), 购买 EFS 之后, 只要在 EFS 控制台上创建好文件系统, 并且管理好网络信息(如 IP 地址, 子网)就可以直接使用, 无须依附于任何 EC2 云主机. EFS 本质是完全托管在"),s("strong",[t._v("云端的网络文件系统")]),t._v("(Network File System, NFS), 可以在任何兼容 POSIX 的操作系统中直接挂载它, 而不会在 /dev 中看到新设备存在. 按照本节开头 Kubernetes 存储架构中的操作来说就, 是你只需要考虑 Mount, 而无须考虑 Attach. 得益于 NFS 的天然特性, EFS 的扩缩可以是完全自动, 实时的, 创建新文件时无须预置存储, 删除已有文件时也不必手动缩容以节省费用. 在高性能网络的支持下, EFS 的性能已经能够达到相当高的水平, 尽管由于网络访问的限制, 性能最高的 EFS 依然比不过最高水平的 EBS, 但仍然能充分满足绝大多数应用运行的需要. 还有最重要的一点优势是由于脱离了块设备的束缚, EFS 能够轻易地被成百上千个 EC2 实例共享, 考虑到 EFS 的性能, 动态弹性, 可共享等因素, 笔者给出的明确建议是它可以作为大部分容器工作负载的首选存储.")]),t._v(" "),s("li",[t._v('亚马逊的对象存储服务是 Amazon Simple Storage Service(AWS S3), S3 通常是以 REST Endpoint 的形式对外部提供文件访问服务的, 在这种方式下应该直接使用程序代码来访问 S3, 而不是靠操作系统或容器编排系统去挂载它. 如果真的希望这样做, 也可以通过存储网关(如 AWS Storage Gateway)将 S3 的存储能力转换为 NFS, SMB, iSCSI 等访问协议, 经过转换后, 操作系统或者容器就能将其作为 Volume 来挂载了. S3 也许是 AWS 最出名, 使用面最广的存储服务, 这个结果不是由于它的性能优异, 事实上 S3 的性能比起 EBS 和 EFS 来说是相对最差的, 但它的优势在于它名字中 "Simple" 所标榜的简单, 挂载外部存储的目的十有八九是为了给程序提供存储服务, 使用 S3 不必写一行代码就能够直接通过 HTTP Endpoint 进行读写访问, 且完全不需要考虑容量, 维护和数据丢失的风险, 这就是简单的价值. S3 的另一大优势就是它的价格相对于 EBS 和 EFS 来说往往要低一至两个数量级, 因此程序的备份还原, 数据归档, 灾难恢复, 静态页面的托管, 多媒体分发等功能就非常适合使用 S3 来完成.')])]),t._v(" "),s("p",[t._v("从目前的存储技术发展来看, 不会有哪一种存储方案能够包打天下. 不同业务系统的场景需求不同, 对存储的诉求就不同, 选择自然也不同.")]),t._v(" "),s("h3",{attrs:{id:"资源与调度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#资源与调度"}},[t._v("#")]),t._v(" 资源与调度")]),t._v(" "),s("p",[s("strong",[t._v("调度是容器编排系统最核心的功能之一")]),t._v(', "编排"一词本身便包含 "调度" 的含义. '),s("strong",[t._v("调度是指为新创建的 Pod 找到一个最恰当的宿主机节点来运行它, 这个过程成功与否, 结果恰当与否, 关键取决于容器编排系统是如何管理与分配集群节点的资源的")]),t._v(". 可以认为"),s("strong",[t._v("调度是必须以容器编排系统的资源管控为前提")]),t._v(", 那就先从 Kubernetes 的资源模型谈起.")]),t._v(" "),s("h4",{attrs:{id:"资源模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#资源模型"}},[t._v("#")]),t._v(" 资源模型")]),t._v(" "),s("p",[t._v("开篇先来理清一个概念: 资源是什么. 资源在 Kubernetes 中是极为常用的术语, 广义上讲, Kubernetes 系统中所有能够接触的方方面面都被抽象成了资源, 譬如表示"),s("strong",[t._v("工作负荷")]),t._v("的资源(Pod, ReplicaSet, Service 等), 表示"),s("strong",[t._v("存储")]),t._v("的资源(Volume, PersistentVolume, Secret 等), 表示"),s("strong",[t._v("策略")]),t._v("的资源(SecurityContext, ResourceQuota, LimitRange 等), 表示"),s("strong",[t._v("身份")]),t._v('的资源(ServiceAccount, Role, ClusterRole等). "'),s("strong",[t._v("一切皆为资源")]),t._v('" 的设计是 Kubernetes 能够顺利施行声明式 API 的必要前提. '),s("strong",[t._v("Kubernetes 以资源为载体, 建立了一套同时囊括抽象元素(如策略, 依赖, 权限)和物理元素(如软件, 硬件, 网络)的领域特定语言")]),t._v(". 通过不同层级间资源的使用关系来描述上至整个集群甚至集群联邦, 下至某一块内存区域或者一小部分处理器核心的状态, 这些对资源状态的描述的集合, 共同构成了一幅信息系统工作运行的全景图.")]),t._v(" "),s("p",[t._v("之前曾提到 Kubernetes 的"),s("strong",[t._v("资源模型")]),t._v(", 并将它与"),s("strong",[t._v("控制器模式")]),t._v("一并列为 Kubernetes 中最重要的两个设计思想. 本节将再次讨论资源模型, 但这里所说的主要是狭义上的"),s("strong",[t._v("物理资源")]),t._v(", 特指排除了广义上那些逻辑方面的抽象资源, "),s("strong",[t._v("只包括能够与真实物理底层硬件对应的资源")]),t._v(", 譬如处理器资源, 内存资源, 磁盘存储资源, 等等. 由于讨论的话题是调度, 作为"),s("strong",[t._v("调度最基本单位的 Pod")]),t._v(", 只会与这些和物理硬件直接相关的资源产生"),s("strong",[t._v("供需关系")]),t._v(", 所以后文中提到资源, 如无额外说明, 均特指狭义上的"),s("strong",[t._v("物理资源")]),t._v(".")]),t._v(" "),s("p",[t._v("从"),s("strong",[t._v("编排系统的角度来看, Node 是资源的提供者, Pod 是资源的使用者, 调度是对两者进行恰当的撮合")]),t._v(". Node 通常能够提供三方面资源: "),s("strong",[t._v("计算资源")]),t._v("(如处理器, 图形处理器, 内存), "),s("strong",[t._v("存储资源")]),t._v("(如磁盘容量, 不同类型的介质)和"),s("strong",[t._v("网络资源")]),t._v("(如带宽, 网络地址). 其中与调度关系最密切的是处理器和内存, 虽然它们同属于计算资源, 但两者在调度时又有一些微妙的差别. 处理器这样的资源被称作"),s("strong",[t._v("可压缩资源")]),t._v('(Compressible Resource), 特点是当可压缩资源不足时, Pod 只会处于 "饥饿状态", 运行变慢, 但不会被系统杀死, 即容器不会被直接终止, 或被要求限时退出. 而像内存这样的资源, 则被称作'),s("strong",[t._v("不可压缩资源")]),t._v("(Incompressible Resource), 特点是当不可压缩资源不足, 或者超过了容器自己声明的最大限度时, Pod 就会因为"),s("strong",[t._v("内存溢出")]),t._v("(Out-Of-Memory, OOM)而被系统直接杀掉.")]),t._v(" "),s("p",[t._v('Kubernetes 给处理器资源设定的默认计量单位是 "'),s("strong",[t._v("逻辑处理器的个数")]),t._v('". 至于具体 "一个逻辑处理器" 应该如何理解, 就要取决于节点的宿主机是如何解释的, 通常会是 /proc/cpuinfo 中看到的处理器数量. 它有可能是多路处理器系统上的一个处理器, 多核处理器中的一个核心, 云计算主机上的一个虚拟化处理器(Virtual CPU, vCPU), 或者处理器核心里的一条超线程(Hyper-Threading). 总之, '),s("strong",[t._v('Kubernetes 只负责保证 Pod 能够使用到 "一个处理器" 的计算能力, 对不同硬件环境构成的 Kubernetes 集群, 乃至同一个集群中不同硬件的宿主机节点来说, "一个处理器" 所代表的真实算力完全有可能是不一样的')]),t._v(".")]),t._v(" "),s("p",[t._v("在具体设置方面, Kubernetes 沿用了云计算中处理器限额设置的一贯做法. 如果不明确标注单位, 譬如直接写 0.5, 默认单位就是 Core, 即 0.5 个处理器; 也可以明确使用 Millcore 为单位, 譬如写成 500m 同样代表 0.5 个处理器, 因为 Kubernetes 规定了 1 Core = 1000 Millcores. 而对于内存来说, 它早已有广泛使用的计量单位, 即 Byte, 如果设置中不明确标注单位就会默认以 Byte 计数. 为了实际设置的方便, Kubernetes 还支持 Ei, Pi, Ti, Gi, Mi, Ki, 以及 E, P, T, G, M, K 为单位, 它们略微有一点点差别, 以 Mi 和 M 为例, 它们分别是 Mebibyte 与 Megabyte 的缩写, 前者表示 1024×1024 Bytes, 后者表示 1000×1000 Bytes.")]),t._v(" "),s("h4",{attrs:{id:"服务质量与优先级"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务质量与优先级"}},[t._v("#")]),t._v(" 服务质量与优先级")]),t._v(" "),s("p",[t._v("设定"),s("strong",[t._v("资源计量单位")]),t._v("的目的是使管理员能够"),s("strong",[t._v("限制某个 Pod 对资源的过度占用")]),t._v(", 避免影响到其他 Pod 的正常运行. "),s("strong",[t._v("Pod 由一到多个容器组成")]),t._v(", 资源最终交由 Pod 的各个容器去使用, 所以资源的需求是设定在容器上的, 具体的配置是 Pod 的 spec.containers[].resource.limits/requests.cpu/memory 字段. 但是对资源需求的配额不是针对容器的, 而是"),s("strong",[t._v("针对 Pod 整体")]),t._v(", Pod 的资源配额无须手动设置, 它就是其包含的每个容器资源需求的累加值.")]),t._v(" "),s("p",[t._v("为容器设定最大的资源配额的做法从 cgroups 诞生后已经屡见不鲜, 但你是否注意到 Kubernetes 给出的配置中有 requests 和 limits 两个设置项呢? 这两者的区别其实很简单: "),s("strong",[t._v("requests 是供调度器使用")]),t._v("的, Kubernetes 选择哪个节点运行 Pod, 只会根据 requests 的值来进行决策; "),s("strong",[t._v("limits 才是供 cgroups 使用的")]),t._v(", Kubernetes 在向 cgroups 传递资源配额时, 会按照 limits 的值来进行设置.")]),t._v(" "),s("p",[t._v('Kubernetes 采用这样的设计完全是基于 "心理学" 的原因, 因为 Google 根据 Borg 和 Omega 系统长期运行的实践经验总结出了一条经验法则: '),s("strong",[t._v("用户提交工作负载时设置的资源配额, 并不是容器调度必须严格遵守的值, 因为根据实际经验, 大多数的工作负载在运行过程中真正使用到的资源, 其实都远小于它所请求的资源配额")]),t._v(".")]),t._v(" "),s("p",[t._v('"多多益善" 的想法完全符合人类的心理, 大家提交的资源需求通常都是按照可能面临的'),s("strong",[t._v("最大压力")]),t._v("去估计的, 甚至考虑到了未来用户增长所导致的新需求. 为了避免服务因资源不足而中断, 都会往大了去申请, 这点可以理解, 但如果直接按照申请的资源去分配限额, 所导致的结果必然是一方面服务器在大多数时间里都会有"),s("strong",[t._v("大量硬件资源闲置")]),t._v(", 另一方面这些闲置资源又已经分配出去, 有了明确的所有者, 不能再被其他人使用, 难以真正发挥价值.")]),t._v(" "),s("p",[t._v("当然, 仅依靠将一个资源配额的设置拆分成 requests 和 limits 两个设置项是不太可能解决这个矛盾的, Kubernetes 为此还进行了许多额外的处理. 一旦不按照最保守, 最安全的方式去分配资源, 就意味着容器编排系统必须为有可能出现的极端情况买单. 如果允许节点给 Pod 分配的资源总和超过自己最大的可提供资源的话, 假如某个时刻这些 Pod 的总消耗真的超标了, 便会不可避免地导致节点无法继续遵守调度时对 Pod 许下的资源承诺, 此时, Kubernetes 只能杀掉一部分 Pod 腾出资源来保证其余 Pod 的正常运行, 这个操作就是"),s("strong",[t._v("驱逐机制")]),t._v("(Eviction). 要进行驱逐, 首先 Kubernetes 就必须制定"),s("strong",[t._v("资源不足时该先牺牲哪些 Pod, 保留哪些 Pod")]),t._v(" 的明确准则, 由此就形成了 Kubernetes 的"),s("strong",[t._v("服务质量等级")]),t._v("(Quality of Service Level, QoS Level)和"),s("strong",[t._v("优先级")]),t._v('(Priority)的概念. 试想 Kubernetes 若不是为了理性对抗人类 "多多益善" 的心理, 尽可能提高硬件利用效率, 而是直接按申请的最大资源去安排调度, 那原本它是无须理会这些麻烦事的.')]),t._v(" "),s("p",[s("strong",[t._v("质量等级")]),t._v("是 Pod 的一个隐含属性, 也是 Kubernetes 优先保障重要的服务, 放弃一些没那么重要的服务的衡量标准. 不知道你是否想到这样一个细节: 如果不去设置 limits 和 requests 会怎样? 如果不设置处理器和内存的资源, 就意味着"),s("strong",[t._v("没有上限")]),t._v(", 该 Pod 可以使用节点上所有可用的计算资源. 但先别高兴得太早, 虽然这类 Pod 能以最灵活的方式去使用资源, 但也正是这类 Pod 扮演着"),s("strong",[t._v("最不稳定的风险来源")]),t._v("的角色. Google 明确提出了针对这类 Pod 的一种近乎带惩罚性质的处理建议: "),s("strong",[t._v("当节点硬件资源不足时, 优先杀掉这类 Pod, 说得文雅一点, 就是给予这类 Pod 最低的服务质量等级")]),t._v(".")]),t._v(" "),s("p",[t._v("Kubernetes 目前提供的"),s("strong",[t._v("服务质量等级一共分为三级")]),t._v(", 由高到低分别为 "),s("strong",[t._v("Guaranteed, Burstable 和 BestEffort")]),t._v(". 如果 Pod 中所有的容器都设置了 limits 和 requests, 且两者的值相等, 那此 Pod 的服务质量等级便为最高的 Guaranteed; 如果 Pod 中有部分容器的 requests 值小于 limits 值, 或者只设置了 requests 而未设置 limits, 那此 Pod 的服务质量等级为第二级 Burstable; 如果是上文说的那种情况, limits 和 requests 两个都没设置则属于最低的 BestEffort.")]),t._v(" "),s("p",[t._v("通常"),s("strong",[t._v("建议将数据库应用等有状态的应用, 或者一些重要的必须不能中断的业务的服务质量等级定为 Guaranteed")]),t._v(", 这样除非 Pod 使用超过了它们的 limits 所描述的不可压缩资源, 或者节点的内存压力大到 Kubernetes 已经杀光所有等级更低的 Pod 了, 否则它们都不会被系统自动杀死. 相对地, 应将一些"),s("strong",[t._v("临时的, 不那么重要的任务设置为 BestEffort")]),t._v(", 这样有利于调度时在更大的节点范围中寻找宿主机, 也有利于在宿主机中利用更多的资源快速地完成任务, 然后退出, 尽量缩减影响范围; 当然, 遇到系统资源紧张时, 它们也更容易被系统杀掉.")]),t._v(" "),s("p",[t._v("除了服务质量等级以外, Kubernetes 还允许系统管理员"),s("strong",[t._v("自行决定 Pod 的优先级")]),t._v(", 这是通过类型为 PriorityClass 的资源来实现的. 优先级决定了 Pod 之间并不是平等的关系, 且这种不平等不是谁会占用更多资源的问题, 而是"),s("strong",[t._v("会直接影响 Pod 调度与生存的关键")]),t._v(".")]),t._v(" "),s("p",[t._v("优先级会影响调度这很容易理解, 它是指"),s("strong",[t._v("当多个 Pod 同时被调度的话, 高优先级的 Pod 会优先被调度")]),t._v(". Pod 越晚被调度, 就越大概率因节点资源已被占用而不能成功. 但受优先级影响更大的另一方面是指 Kubernetes 的"),s("strong",[t._v("抢占机制")]),t._v("(Preemption), 在正常未设置优先级的情况下, 如果 Pod 调度失败, 就会暂时处于 Pending 状态被搁置起来, 直到集群中有新节点加入或者旧 Pod 退出. 但是, 如果有一个被设置了明确优先级的 Pod 调度失败无法创建的话, "),s("strong",[t._v("Kubernetes 就会在系统中寻找一批牺牲者(Victim), 将它们杀掉以便给更高优先级的 Pod 让出资源")]),t._v(". 寻找的原则是根据在优先级低于待调度的 Pod 的所有已调度的 Pod 里, 按照优先级从低到高排序, 从最低的杀起, 直至腾出的资源足以支持待调度 Pod 成功调度所需的资源为止, 或者已经找不到更低优先级的 Pod 为止.")]),t._v(" "),s("h4",{attrs:{id:"驱逐机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#驱逐机制"}},[t._v("#")]),t._v(" 驱逐机制")]),t._v(" "),s("p",[t._v('前面动不动就说要杀掉某个 Pod, 听起来实在是欠优雅的, 在 Kubernetes 中专业的称呼是 "'),s("strong",[t._v("驱逐")]),t._v('"(Eviction, '),s("strong",[t._v("即资源回收")]),t._v("). Pod 的驱逐机制是通过 "),s("strong",[t._v("kubelet")]),t._v(" 来执行的, "),s("strong",[t._v("kubelet 是部署在每个节点的集群管理程序, 由于本身就运行在节点中, 所以最容易感知到节点的资源实时消耗情况")]),t._v(". kubelet 一旦发现某种不可压缩资源将要耗尽时, 就会"),s("strong",[t._v("主动终止节点上较低服务质量等级的 Pod")]),t._v(", 以保证其他更重要的 Pod 的安全. 被驱逐的 Pod 中的所有容器都会被终止, Pod 的状态也会被更改为 Failed.")]),t._v(" "),s("p",[t._v('内存是一种最重要的不可压缩资源, 默认配置下, 前面所说的 "资源即将耗尽" 的 "即将", 具体阈值是可用内存小于 100Mi. 除了'),s("strong",[t._v("可用内存")]),t._v("(memory.available)外, 其他不可压缩资源还包括宿主机的可用"),s("strong",[t._v("磁盘空间")]),t._v("(nodefs.available), 文件系统"),s("strong",[t._v("可用 inode 数量")]),t._v("(nodefs.inodesFree), 以及可用的容器运行时"),s("strong",[t._v("镜像存储空间")]),t._v("(imagefs.available). 后面三个的阈值都是按照实际容量的百分比来计算的, 具体的默认值如下:")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("memory"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("available "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v("Mi\nnodefs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("available "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("\nnodefs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("inodesFree "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("\nimagefs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("available "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("15")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("管理员可以在 kubelet 启动时, 通过"),s("strong",[t._v("命令行参数")]),t._v("来修改这些默认值, 譬如可用内存只剩余 100 Mi 时才启动驱逐对于多数生产系统来说过于危险了, 笔者建议在生产环境中考虑通过以下命令调整为剩余 10% 内存时开始驱逐:")]),t._v(" "),s("div",{staticClass:"language-sh line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[t._v("$ kubelet --eviction-hard"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("memory.available"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("%\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("要注意的是 Kubernetes 的驱逐不能完全等同于编程语言(如 Java)中的垃圾收集. 垃圾收集是"),s("strong",[t._v("安全的内存回收行为")]),t._v(", 而"),s("strong",[t._v("驱逐 Pod 是一种毁坏性的清理行为, 有可能导致服务中断")]),t._v(", 必须更加谨慎. 譬如, 要同时兼顾硬件资源可能只是短时间内间歇性地超过了阈值的场景, 以及资源正在被快速消耗, 很快就会危及高服务质量的 Pod 甚至整个节点稳定性的场景. 因此, 驱逐机制中就有了"),s("strong",[t._v("软驱逐")]),t._v("(Soft Eviction), "),s("strong",[t._v("硬驱逐")]),t._v("(Hard Eviction)以及"),s("strong",[t._v("优雅退出期")]),t._v("(Grace Period)的概念.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("软驱逐")]),t._v(": 通常配置一个"),s("strong",[t._v("较低的警戒线")]),t._v("(譬如可用内存仅剩 20%), 触及此线时, 系统将进入一段"),s("strong",[t._v("观察期")]),t._v(". 如果只是暂时的资源抖动, 在观察期内能够恢复到正常水平的话, 那就不会真正启动驱逐操作. 否则, 若资源持续超过警戒线一段时间, 就会触发 Pod 的"),s("strong",[t._v("优雅退出")]),t._v("(Grace Shutdown), 系统会通知 Pod 进行必要的清理工作(譬如将缓存的数据落盘), 然后自行结束. 在优雅退出期结束后, 系统会强制杀掉还未曾自行了断的 Pod.")]),t._v(" "),s("li",[s("strong",[t._v("硬驱逐")]),t._v(": 通常配置一个"),s("strong",[t._v("较高的终止线")]),t._v("(譬如可用内存仅剩 10%), 一旦触及此红线, "),s("strong",[t._v("立即强制")]),t._v("杀掉 Pod, 而不会优雅退出.")])]),t._v(" "),s("p",[t._v("软驱逐是为了"),s("strong",[t._v("减少资源抖动")]),t._v("对服务的影响, 硬驱逐是为了"),s("strong",[t._v("保障核心系统的稳定")]),t._v(", 它们并不矛盾, 一般会同时使用, 譬如以下例子所示:")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ kubelet --eviction-hard=memory.available<10% \\\n            --eviction-soft=memory.available<20% \\\n            --eviction-soft-grace-period=memory.available=1m30s \\\n            --eviction-max-pod-grace-period=600\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v('Kubernetes 的驱逐与编程语言中的垃圾收集的另一个不同之处是, 垃圾收集可以 "'),s("strong",[t._v("应收尽收")]),t._v('", 而驱逐显然不行, 不能无缘无故把整个节点中所有可驱逐的 Pod 都清空掉. 但通常也不能只清理到刚刚低于警戒线就停止, 必须考虑驱逐之后的新 Pod 调度与旧 Pod 运行的新增消耗. 譬如 kubelet 驱逐了若干个 Pod, 让资源使用率勉强低于阈值, 那么很可能在极短的时间内, 资源使用率又会因某个 Pod 稍微占用了些许资源而重新超过阈值, 再产生'),s("strong",[t._v("新的驱逐")]),t._v(", 如此往复. 为此, Kubernetes 提供了  "),s("strong",[t._v("--eviction-minimum-reclaim")]),t._v(" 参数设置一旦驱逐发生之后, "),s("strong",[t._v("至少清理出来多少资源")]),t._v("才会终止.")]),t._v(" "),s("p",[t._v("不过, 问题到这里还是没有全部解决, Kubernetes 中很少会单独创建 Pod, 通常都是由 ReplicaSet, Deployment 等更高层资源来管理, 这意味着当 Pod 被驱逐之后, 它不会从此彻底消失, Kubernetes 将自动生成一个新的 Pod 来取代, 并经过调度选择一个节点继续运行. 如果没有额外的处理, 那很大概率这个 Pod 会被系统调度到当前节点上重新创建, 因为上一次调度就选择了这个节点, 而且这个节点刚刚驱逐完一批 Pod 得到了空闲资源, 所以它显然符合此 Pod 的调度需求. 为了避免上述情况, Kubernetes 还提供了另一个参数  "),s("strong",[t._v("--eviction-pressure-transition-period")]),t._v(" 来约束调度器, 设置在驱逐发生之后多长时间内不得往该节点调度 Pod.")]),t._v(" "),s("p",[t._v("关于驱逐机制还应该意识到, 这些措施既然被设计为以参数的形式开启, 就说明了它们一定"),s("strong",[t._v("不是放之四海皆准的通用准则")]),t._v(". 举个例子, 假设当前 Pod 是由 DaemonSet 控制的, 一旦该 Pod 被驱逐, 又强行不允许节点在一段时间内接受调度, 那显然这就有违 DaemonSet 的语义. 目前 Kubernetes 并没有办法区分 Pod 是由 DaemonSet 抑或是别的高层次资源创建, 因此这种假设情况确实有可能发生, 比较合理的方案是让 DaemonSet 创建 Guaranteed 而不是 BestEffort 等级的 Pod. 总而言之, "),s("strong",[t._v('在 Kubernetes 还没有成熟到变为 "傻瓜式" 容器编排系统之前, 因地制宜地配置和运维是非常必要的')]),t._v(".")]),t._v(" "),s("p",[t._v("最后, "),s("strong",[t._v("服务质量, 优先级, 驱逐机制这些概念, 都是在 Pod 层面上限制资源")]),t._v(", 是仅"),s("strong",[t._v("针对单个 Pod 的低层次约束")]),t._v(", 但现实中还常会遇到面向更高层次去控制资源的需求, 譬如想限制由"),s("strong",[t._v("多个 Pod 构成的微服务系统消耗的总资源")]),t._v(", 或者由多名成员组成的团队消耗的总资源. 举个具体例子, 想要在拥有 32GiB 内存和 16 个处理器的集群里, 允许 A 团队使用 20GiB 内存和 10 个处理器的资源, 再允许 B 团队使用 10GiB 内存和 4 个处理器的资源, 再预留 2GiB 内存和 2 个处理器供将来分配. 要满足这种资源限制的需求, Kubernetes 的解决方案是"),s("strong",[t._v("先为它们建立一个专用的名称空间, 然后在名称空间里建立 ResourceQuota 对象来描述如何进行整体的资源约束")]),t._v(".")]),t._v(" "),s("p",[t._v("但是 ResourceQuota 与调度就没有直接关系了, 它针对的对象也不是 Pod, 所以这里所说的资源可以是"),s("strong",[t._v("广义上的资源")]),t._v(", 不仅能够设置处理器, 内存等物理资源的限额, 还可以设置诸如 Pod 最大数量, ReplicaSet 最大数量, Service 最大数量, 全部 PersistentVolumeClaim 的总存储容量等"),s("strong",[t._v("各种抽象资源")]),t._v("的限额. 甚至当 Kubernetes 预置的资源模型不能满足约束需要时, 还能够根据实际情况去拓展, 譬如要控制 GPU 的使用数量, 完全可以通过 Kubernetes 的设备插件(Device Plugin)机制拓展出诸如 nvidia.com/gpu:4 这样的配置来.")]),t._v(" "),s("h4",{attrs:{id:"默认调度器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#默认调度器"}},[t._v("#")]),t._v(" 默认调度器")]),t._v(" "),s("p",[t._v("本章的最后一节回过头来探讨开篇提出的问题: "),s("strong",[t._v("Kubernetes 是如何撮合 Pod 与 Node 的, 这其实也是最难的一个问题")]),t._v(". "),s("strong",[t._v("调度是为新创建出来的 Pod 寻找一个最恰当的宿主机节点去运行它")]),t._v(', 这句话里就包含 "运行" 和 "恰当" 两个调度中关键过程, 具体分析如下.')]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("运行")]),t._v(": 从集群所有节点中找出一批"),s("strong",[t._v("剩余资源")]),t._v("可以满足该 Pod 运行的节点. 为此, Kubernetes 调度器设计了一组名为 "),s("strong",[t._v("Predicate")]),t._v(" 的"),s("strong",[t._v("筛选")]),t._v("算法.")]),t._v(" "),s("li",[s("strong",[t._v("恰当")]),t._v(": 从符合运行要求的节点中找出一个"),s("strong",[t._v("最适合的节点")]),t._v("完成调度. 为此, Kubernetes 调度器设计了一组名为 "),s("strong",[t._v("Priority")]),t._v(" 的"),s("strong",[t._v("评价")]),t._v("算法.")])]),t._v(" "),s("p",[t._v("这里要先说明白一点: 在几个, 十几个节点的集群里进行调度, 调度器怎么实现都不会太困难, 但是对于数千个乃至更多节点的大规模集群, 要实现高效的调度就绝不简单. 请想象一下, 有一个由数千节点组成的集群, 每次创建 Pod 都必须"),s("strong",[t._v("依据各节点的实时资源状态来确定调度的目标节点")]),t._v(", 然而各节点的资源是随着程序运行无时无刻不在变动的, 资源状况只有节点本身最清楚, 如果每次调度都要发生数千次的远程访问来获取这些信息的话, 那压力与耗时都很难降下来, 结果不仅会令调度器成为集群管理的性能瓶颈, 还会出现因耗时过长, 某些节点上资源状况已发生变化, 调度器的资源信息过时而导致调度结果不准确等问题.")]),t._v(" "),s("p",[s("strong",[t._v("由于调度器的工作负载与集群规模大致成正比")]),t._v(', 随着集群和它们的工作负载不断增长, 调度器很有可能成为扩展性瓶颈所在. 针对以上问题, Google 在论文 "Omega:Flexible,Scalable Schedulers for Large Compute Clusters" 里总结了自身的经验, 并参考了当时 Apache Mesos 和 Hadoop on Demand(HOD) 的实现, 提出了一种'),s("strong",[t._v("共享状态(Shared State)的双循环调度机制")]),t._v(". 这种调度机制后来不仅应用在 Google 的 Omega 系统(Borg 的下一代集群管理系统)中, 也同样被 Kubernetes 继承了下来, 它的整体工作流程如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230114205641895.png",alt:"",title:"状态共享的双循环调度机制"}})]),t._v(" "),s("p",[t._v('"状态共享的双循环" 中的第一个控制循环可被称为 "'),s("strong",[t._v("Informer Loop")]),t._v('", 它是一系列 Informer 的集合, 这些 Informer 持续监视 etcd 中与调度相关资源(主要是 Pod 和 Node)的'),s("strong",[t._v("变化情况")]),t._v(", 一旦 Pod, Node 等资源出现变动, 就会"),s("strong",[t._v("触发对应 Informer 的 Handler")]),t._v(". Informer Loop 的职责是根据 etcd 中的资源变化去"),s("strong",[t._v("更新调度队列")]),t._v("(Priority Queue)和"),s("strong",[t._v("调度缓存")]),t._v("(Scheduler Cache)中的信息, 譬如当有新 Pod 生成时, 就将其入队(Enqueue)到调度队列中, 如有必要, 还会根据优先级触发上一节提到的插队和抢占操作. 又譬如有新的节点加入集群, 或者已有节点资源信息发生变动时, Informer 也会将这些信息更新同步到调度缓存之中.")]),t._v(" "),s("p",[t._v('另一个控制循环可被称为 "'),s("strong",[t._v("Scheduler Loop")]),t._v('", 它的核心逻辑是'),s("strong",[t._v("不停地将调度队列中的 Pod 出队(Pop), 然后使用 Predicate 算法进行节点选择")]),t._v(". Predicate 本质上是一组"),s("strong",[t._v("节点过滤器")]),t._v("(Filter), 它根据预设的过滤策略来筛选节点. Kubernetes 中默认有三种过滤策略, 分别如下所示.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("通用过滤策略")]),t._v(": 最基础的调度过滤策略, 用来"),s("strong",[t._v("检查节点能否满足 Pod 声明中需要的资源需求")]),t._v(". 譬如处理器, 内存资源是否满足, 主机端口与声明的 NodePort 是否存在冲突, Pod 的选择器或者 nodeAffinity 指定的节点是否与目标相匹配, 等等.")]),t._v(" "),s("li",[s("strong",[t._v("卷过滤策略")]),t._v(": 与"),s("strong",[t._v("存储相关")]),t._v("的过滤策略, 用来检查"),s("strong",[t._v("节点挂载的 Volume 是否存在冲突")]),t._v("(譬如将一个块设备挂载到两个节点上), 或者 Volume 的可用区域是否与目标节点冲突, 等等. 之前提到的 Local PersistentVolume 的调度检查, 便是在这里处理的.")]),t._v(" "),s("li",[s("strong",[t._v("节点过滤策略")]),t._v(": 与"),s("strong",[t._v("宿主机相关")]),t._v("的过滤策略, 最典型的是 Kubernetes 的"),s("strong",[t._v("污点与容忍度")]),t._v("(Taint and Toleration)机制, 譬如默认情况下 Kubernetes 会设置 Master 节点不允许被调度, 这就是通过在 Master 中施加污点来避免的. 之前提到的控制节点处于驱逐状态, 或者在驱逐后一段时间不允许调度, 也是在这个策略里实现的.")])]),t._v(" "),s("p",[s("strong",[t._v("Predicate 算法所使用的一切数据均来自于调度缓存, 而绝对不会去远程访问节点本身")]),t._v(". 只有 Informer Loop 与 etcd 的监视操作才会涉及远程调用, Scheduler Loop 中除了最后的异步绑定要发起一次远程的 etcd 写入外, 其余都是"),s("strong",[t._v("进程内访问")]),t._v(", "),s("strong",[t._v("这一点是调度器执行效率的重要保证")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("调度缓存就是两个控制循环的共享状态(Shared State), 这样的设计避免了每次调度时主动去轮询所有集群节点, 保证了调度器的执行效率")]),t._v(", 但是并不能完全避免因节点信息同步不及时而导致调度过程中实际资源发生变化的情况, 譬如节点的某个端口在获取调度信息后, 发生实际调度前被意外占用了. 为此, 当调度结果出来之后, kubelet 真正创建 Pod 之前, 还必须执行一次 Admit 操作, 在该节点上"),s("strong",[t._v("重新调用 Predicate 算法来进行二次确认")]),t._v(".")]),t._v(" "),s("p",[t._v("经过 Predicate 算法"),s("strong",[t._v("筛选出符合要求的节点集")]),t._v(", 交给 "),s("strong",[t._v('Priorities 算法来打分(0 ～ 10分)并排序, 以便挑选出 "最恰当" 的一个')]),t._v('. "恰当" 是带有主观色彩的词语, Kubernetes 也提供了不同的打分规则来满足不同的主观需求, 譬如最常用的 '),s("strong",[t._v("LeastRequestedPriority")]),t._v(" 规则, 它的计算公式是:")]),t._v(" "),s("div",{staticClass:"language-sh line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[t._v("score "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cpu"),s("span",{pre:!0,attrs:{class:"token variable"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("((")]),t._v("capacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" sum"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("requested"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("))")])]),t._v(" × "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v(" / capacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" + memory"),s("span",{pre:!0,attrs:{class:"token variable"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("((")]),t._v("capacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" \n    sum"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("requested"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("))")])]),t._v(" × "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v(" / capacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("))")]),t._v(" / "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("从公式上很容易看出这就是在"),s("strong",[t._v("选择处理器和内存空闲资源最多的节点")]),t._v(", 因为这些资源剩余越多, 得分就越高. 经常与它配合使用的是 "),s("strong",[t._v("BalancedResourceAllocation")]),t._v(" 规则, 它的公式是:")]),t._v(" "),s("div",{staticClass:"language-sh line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[t._v("score "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v(" - variance"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cpuFraction, memoryFraction, volumeFraction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" × "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("此公式中 cpuFraction, memoryFraction, volumeFraction 的含义分别是 Pod 请求的处理器, 内存和存储资源占该节点上对应可用资源的比例, variance 函数的作用是计算资源之间的差距, 差距越大, 函数值越大. 由此可知 BalancedResourceAllocation 规则的意图是"),s("strong",[t._v("希望调度完成后, 所有节点里各种资源的分配尽量均衡")]),t._v(", 避免节点上出现诸如处理器资源被大量分配而内存大量剩余的尴尬状况. Kubernetes 内置的评分规则还有 ImageLocalityPriority, NodeAffinityPriority, TaintTolerationPriority 等, 就不再逐一解释了.")]),t._v(" "),s("p",[s("strong",[t._v("经过 Predicate 的筛选, Priorities 的评分之后, 调度器已经选出了调度的最终目标节点, 最后一步是通知目标节点的 kubelet 去创建 Pod")]),t._v(". 调度器并不会直接与 kubelet 通信来创建 Pod, 它只需要把待调度的 Pod 的 nodeName 字段更新为目标节点的名字即可, "),s("strong",[t._v("kubelet 本身会监视该值的变化来接手后续工作")]),t._v(". 不过, 从调度器在 etcd 中更新 nodeName, kubelet 从 etcd 中检测到变化, 执行 Admit 操作二次确认调度可行性, 最后到 Pod 开始实际创建的这个过程可能会持续一段不短的时间, 如果一直等待这些工作都完成了才宣告调度最终完成, 那势必也会显著影响调度器的效率. 实际上 Kubernetes 调度器采用了"),s("strong",[t._v("乐观绑定")]),t._v("(Optimistic Binding)的策略来解决此问题, 它会同步更新调度缓存中 Pod 的 nodeName 字段, 并异步更新 etcd 中 Pod 的 nodeName 字段, 这个操作被称为"),s("strong",[t._v("绑定")]),t._v("(Binding). 如果最终调度成功了, "),s("strong",[t._v("那 etcd 与调度缓存中的信息最终必定会保持一致")]),t._v(", 否则, 如果调度失败了, 那将会由 Informer 来根据 Pod 的变动, 清空调度成功却没有创建成功的 Pod 的 nodeName 字段, 重新同步回调度缓存中, 以便促使另外一次调度的开始.")]),t._v(" "),s("p",[t._v('最后, 请注意在介绍这一节时用的标题是 "'),s("strong",[t._v("默认调度器")]),t._v('", 这是强调以上行为仅是 '),s("strong",[t._v("Kubernetes 默认的行为")]),t._v(". 对调度过程的大部分行为, 都可以"),s("strong",[t._v("通过 Scheduler Framework 暴露的接口来进行扩展和自定义")]),t._v(", Scheduler Framework 暴露了许多扩展点. 由于 Scheduler Framework 属于 Kubernetes 内部的扩展机制(通过 Golang 的 Plugin 机制来实现, 需静态编译), 通用性与本章提到的其他扩展机制(CRI, CNI, CSI等)无法相提并论, 属于较为高级的 Kubernetes 管理技能, 所以这里仅简单地提一下, 就不多做介绍了.")]),t._v(" "),s("h3",{attrs:{id:"服务网格"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务网格"}},[t._v("#")]),t._v(" 服务网格")]),t._v(" "),s("p",[s("strong",[t._v("容器编排系统管理的最细粒度只能到达容器层次")]),t._v(', 在此粒度之下的技术细节, 仍然只能依赖程序员自己来管理, 编排系统很难提供有效的支持. 2016 年, William Morgan 发表的文章 "What’s A Service Mesh?And Why Do I Need One?" 中首次正式地定义了 "'),s("strong",[t._v("服务网格")]),t._v('" (Service Mesh)一词. 服务网格之所以能够获得企业与社区的重视, 是因为它很好地'),s("strong",[t._v("弥补了容器编排系统对分布式应用细粒度管控能力不足的缺憾")]),t._v(".")]),t._v(" "),s("p",[t._v("服务网格是"),s("strong",[t._v("一种用于管控服务间通信的基础设施")]),t._v(", 职责是"),s("strong",[t._v("支持现代云原生应用网络请求在复杂拓扑环境中的可靠传递")]),t._v(". 在实践中, "),s("strong",[t._v("服务网格通常会以轻量化网络代理的形式来体现")]),t._v(", 这些代理与应用程序代码会部署在一起, 对应用程序来说, 它"),s("strong",[t._v("完全不会感知到代理")]),t._v("的存在.")]),t._v(" "),s("p",[t._v("服务网格并不是什么神秘, 难以理解的黑科技, "),s("strong",[t._v("它只是一种处理程序间通信的基础设施")]),t._v(", 典型的存在形式是"),s("strong",[t._v("部署在应用旁边, 一对一为应用提供服务的边车代理以及管理这些边车代理的控制程序")]),t._v(".  "),s("strong",[t._v('"边车" 本来就是一种常见的容器设计模式, 用来形容外挂在容器上的辅助程序')]),t._v(". 早在容器盛行以前, 边车代理就已有了成功的应用案例, 譬如 2014 年开始的 Netflix Prana 项目, 由于 Netfilix OSS 套件是用 Java 语言开发的, 为了让非 JVM 语言的微服务, 譬如以 Python, Node.js 编写的程序同样能接入 Netfilix OSS 生态, 享受到 Eureka, Ribbon, Hystrix 等框架的支持, Netflix 建立了 Prana 项目, 它的作用是为每个服务提供一个专门的 HTTP Endpoint, 使得非 JVM 语言的程序能通过访问该 Endpoint 来获取系统中所有服务的实例, 相关路由节点, 系统配置参数等在 Netfilix 组件中管理的信息.")]),t._v(" "),s("p",[t._v("Netflix Prana 的代理需要"),s("strong",[t._v("由应用程序主动去访问")]),t._v("才能发挥作用, 但在容器的刻意支持下, "),s("strong",[t._v("服务网格无须应用程序的任何配合")]),t._v(", 就能强制性地对应用通信进行管理. 它使用了类似网络攻击里中间人"),s("strong",[t._v("流量劫持的手段")]),t._v(", "),s("strong",[t._v("完全透明")]),t._v("(既无须程序主动访问, 也不会被程序感知到)地接管容器与外界的通信, "),s("strong",[t._v("将管理的粒度从容器级别细化到每个单独的远程服务级别")]),t._v(", 使得基础设施干涉应用程序, 介入程序行为的能力大为增强. 如此一来, 云原生希望"),s("strong",[t._v("用基础设施接管应用程序非功能性需求")]),t._v("的目标就能更进一步, "),s("strong",[t._v("从容器粒度延伸到远程访问, 分布式系统继容器和容器编排")]),t._v("之后, 又发掘到另一块更广袤的舞台空间.")]),t._v(" "),s("h4",{attrs:{id:"透明通信的涅槃"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#透明通信的涅槃"}},[t._v("#")]),t._v(" 透明通信的涅槃")]),t._v(" "),s("p",[t._v("Kubernetes 为它管理的工作负载提供了工业级的韧性与弹性, 也为每个处于运行状态的 Pod 维护了"),s("strong",[t._v("相互连通的虚拟化网络")]),t._v(". 不过, 程序之间的通信不同于简单地在网络上拷贝数据, 具备可连通的网络环境仅仅是程序间能够可靠通信的必要但非充分的条件, 作为一名经历过 SOA, 微服务, 云原生洗礼的分布式程序员, 必定已深谙"),s("strong",[t._v("路由, 容错, 限流, 加密, 认证, 授权, 跟踪, 度量等问题在分布式系统中都是无可回避")]),t._v("的.")]),t._v(" "),s("p",[t._v("服务网格的诞生在某种意义上可以说是透明通信的重生, "),s("strong",[t._v("服务网格试图以容器, 虚拟化网络, 边车代理等技术所构筑的新一代通信基础设施为武器, 重新对已盖棺定论三十多年的程序间远程通信不是透明的原则发起冲击")]),t._v(". 今天, 这场关于通信的变革仍然在酝酿发展当中, 最后到底会是成功的逆袭, 抑或是另一场失败, 笔者不敢妄言定论, 但是作为程序通信发展历史的一名见证者, 笔者丝毫不吝对"),s("strong",[t._v("服务网格")]),t._v("投去最高的期许与最深的祝愿.")]),t._v(" "),s("h5",{attrs:{id:"_1-通信成本"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-通信成本"}},[t._v("#")]),t._v(" 1.通信成本")]),t._v(" "),s("p",[t._v("在本节会从更微观, 更聚焦的角度, 分析不同时期"),s("strong",[t._v("应用程序")]),t._v("是如何看待与实现通信方面的非功能性需求, 以及如何做到可靠通信的. 下面通过以下五个阶段的变化, 理解分布式服务的通信是如何逐步演化成服务网格的.")]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("第一阶段: 将通信的非功能性需求视作业务需求的一部分, 通信的可靠性由")]),t._v("​"),s("mark",[s("strong",[t._v("开发人员")])]),t._v("​"),s("strong",[t._v("来保障.")])])]),t._v(" "),s("p",[t._v("本阶段是软件企业刚刚开始尝试分布式时选择的早期技术策略. 这类系统原本所具有的通信能力一般并不是作为系统功能的一部分被设计出来, 而是遇到问题后修补累积所形成的. 开始时, 系统往往只具备最基本的网络 API, 譬如集成了 OKHTTP, gRPC 这样的库来访问远程服务, 如果远程访问接收到异常, 就编写对应的重试或降级逻辑去处理. 在系统进入生产环境以后, 遇到并解决的一个个通信问题, 逐渐在"),s("strong",[t._v("业务系统中留下了越来越多关于通信的代码逻辑")]),t._v(". 这些"),s("strong",[t._v("通信的逻辑由业务系统的开发人员直接编写, 与业务逻辑直接共处在一个进程空间")]),t._v("之中, 如下图所示.")]),t._v(" "),s("p",[t._v("​"),s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230114220439557.png",alt:"image-20230114220439557",title:"控制逻辑与业务逻辑耦合"}}),t._v("​")]),t._v(" "),s("p",[t._v("这一阶段的主要矛盾是绝大多数擅长业务逻辑的开发人员并"),s("strong",[t._v("不擅长处理的通信方面的问题")]),t._v(', 要写出正确, 高效, 健壮的分布式通信代码, 是一项专业性极强的工作. 由此决定了大多数普通软件企业都很难在这个阶段支撑起一个靠谱的分布式系统来. 另一方面, 把专业的通信功能强加于普通开发人员, 无疑为带来了更多工作量, 尤其是这些 "额外的工作" 与原有的业务逻辑耦合在一起, 让系统越来越复杂, 也越来越容易出错.')]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("第二阶段: 将代码中的通信功能抽离重构成公共组件库, 通信的可靠性由专业的平台开发人员来保障.")])])]),t._v(" "),s("p",[t._v("开发人员解耦依赖的一贯有效办法是"),s("strong",[t._v("抽取分离代码与封装重构组件")]),t._v(". 微服务的普及离不开一系列封装了分布式通信能力的"),s("strong",[t._v("公共组件库")]),t._v(", 代表产品有 Twitter 的 Finagle, Spring Cloud 中的许多组件等. 这些公共的通信组件由熟悉分布式的专业的平台开发人员编写和维护, 不仅效率更高, 质量更好, 一般还都提供了经过良好设计的 API 接口, "),s("strong",[t._v("让业务代码既可以使用它们的能力, 又无须把处理通信的逻辑散布于业务代码当中")]),t._v(", 如下图所示.")]),t._v(" "),s("p",[t._v("​"),s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230114221527485.png",alt:"image-20230114221527485",title:"抽取公共的分布式通信组件"}}),t._v("​")]),t._v(" "),s("p",[t._v("分布式通信组件让普通开发人员开发出靠谱的微服务系统成为可能, 这是无可抹杀的成绩, 但普通开发人员使用它们的成本依然很高, 不仅要学习分布式的知识, 还要学习这些公共组件的使用方法. 最麻烦的是, "),s("strong",[t._v("对于同一种问题往往需要用到多种不同的组件才能解决")]),t._v(". 这是因为通信组件首先是一段特定编程语言开发出来的程序, 是与语言绑定的, 一个由 Python 编写的组件再优秀, 对 Java 系统来说也没有太多的实用价值. "),s("strong",[t._v("目前基于公共组件库开发微服务仍然是应用最为广泛的解决方案")]),t._v(", 却不是一种完美的解决方案, "),s("strong",[t._v("这是微服务基础设施完全成熟之前必然会出现的应用形态")]),t._v(", 同时也一定是微服务进化过程中必然会被替代的过渡形态.")]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("第三阶段: 将负责通信的公共组件库分离到进程之外, 程序间通过网络代理来交互, 通信的可靠性由专门的网络代理提供商来保障.")])])]),t._v(" "),s("p",[t._v("为了能够把分布式通信组件与具体的编程语言脱钩, 也为了避免开发人员还要专门学习这些组件的编程模型与 API 接口, 这一阶段进化出了"),s("strong",[t._v("能专门负责可靠通信的网络代理")]),t._v(". 这些网络代理不再与业务逻辑部署于同一个进程空间, 但仍然与业务系统处于"),s("strong",[t._v("同一个容器或者虚拟机")]),t._v("中, 可以通过回环设备甚至 UDS(UNIX Domain Socket)进行交互, 具备相当高的"),s("strong",[t._v("网络性能")]),t._v(". 只要让网络代理"),s("strong",[t._v("接管程序七层或四层流量")]),t._v(", 就能够"),s("strong",[t._v("在代理上完成断路, 容错")]),t._v("等几乎所有的分布式通信功能, 前面提到过的 Netflix Prana 就属于这类产品的典型代表, 如下图所示.")]),t._v(" "),s("p",[t._v("​"),s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230114221902978.png",alt:"image-20230114221902978",title:"通过网络代理获得可靠的通信能力"}}),t._v("​")]),t._v(" "),s("p",[t._v("通过"),s("strong",[t._v("网络代理")]),t._v("来提升通信质量的思路提出以后, 它本身的使用范围其实并不算特别广泛, 但它的"),s("strong",[t._v("方向是正确")]),t._v("的. 这种思路后来演化出了两种改进形态. 一方面, 如果"),s("strong",[t._v("将网络代理从进程身边拉远")]),t._v(", 让它与进程分别处于不同的机器上, 这样就可以同时给"),s("strong",[t._v("多个进程")]),t._v("提供可靠通信的代理服务, 这条路线逐渐演变成了今天常见的"),s("mark",[s("strong",[t._v("微服务网关")])]),t._v(", 在网关上同样可以实现流控, 容错等功能. 另一方面, 如果将网络代理"),s("strong",[t._v("往进程方向靠近")]),t._v(", 不仅"),s("strong",[t._v("让它与进程处于一个共享了网络名称空间的容器组之中, 还要让它透明并强制地接管通信")]),t._v(", 这便演变成了下一阶段所说的"),s("strong",[t._v("边车代理")]),t._v(".")]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("第四阶段: 将网络代理以边车的形式注入应用容器, 自动劫持应用的网络流量, 通信的可靠性由专门的通信基础设施来保障.")])])]),t._v(" "),s("p",[t._v("与前一阶段的独立代理相比, 如下图所示, 以"),s("strong",[t._v("边车模式运作的网络代理")]),t._v("拥有两个无可比拟的优势. 第一个优势是它"),s("strong",[t._v("对流量的劫持是强制性")]),t._v("的, 通常是"),s("strong",[t._v("靠直接写容器的 iptables 转发表来实现")]),t._v(". 此前, 独立的网络代理只有当程序首先去访问它时, 它才能被动地为程序提供可靠通信服务, 只要程序有选择不访问它的可能性, 代理就永远只能充当服务者而不能成为管理者, 上阶段中"),s("strong",[t._v("保留")]),t._v("了两个容器网络设备直接连接的箭头就代表这种可能性, 而这一阶段中, "),s("strong",[t._v("服务与网络名称空间的虚线箭头代表被劫持后应用程序以为存在")]),t._v(", 但实际并不存在的流量.")]),t._v(" "),s("p",[s("strong",[t._v("第二个优势是边车代理对应用是透明的")]),t._v(", 无须对已部署的应用程序代码进行任何改动, 不需要引入任何的库(这点并不是绝对的, 有部分边车代理也会要求有轻量级的 SDK), "),s("strong",[t._v("也不需要程序专门去访问某个特定的网络位置")]),t._v(". 这意味着它对所有现存程序都具备开箱即用的适应性, 无须修改旧程序就能直接享受到边车代理的服务, 这样它的适用范围就变得十分广泛. 目前边车代理的代表产品有 Linkerd, Envoy, MOSN 等.")]),t._v(" "),s("p",[t._v("​"),s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230114222703887.png",alt:"image-20230114222703887",title:"边车代理模式"}}),t._v("​")]),t._v(" "),s("p",[t._v("如果说边车代理还有什么不足之处的话, 那大概就是来自于"),s("strong",[t._v("运维人员")]),t._v("的不满了. "),s("strong",[t._v("边车代理能够透明且具有强制力地解决可靠通信的问题, 但它本身也需要有足够的信息才能完成这项工作")]),t._v(", 譬如获取可用服务的列表, 譬如得到每个服务名称对应的 IP 地址等等. 这些信息不会自动到边车里去, 需要由"),s("strong",[t._v("管理员主动去告知代理")]),t._v(", 或者代理主动从约定的好的位置获取. 可见管理代理本身也会产生额外的通信需求. 如果没有额外的支持, "),s("strong",[t._v("这些管理方面的通信都得由运维人员去埋单")]),t._v(", 由此而生的不满便可以理解. 为了管理与协调边车代理, 程序间通信进化到了最后一个阶段: "),s("strong",[t._v("服务网格")]),t._v(".")]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("第五阶段:")]),t._v(" "),s("mark",[s("strong",[t._v("将边车代理统一管控起来实现安全, 可控, 可观测的通信, 将数据平面与控制平面分离开来, 实现通用, 透明的通信, 这项工作由专门的服务网格框架来保障")])]),t._v("​ "),s("strong",[t._v(".")])])]),t._v(" "),s("p",[t._v("从总体架构看, 服务网格包括两大块内容, 分别是由"),s("strong",[t._v("一系列与微服务共同部署的边车代理, 以及用于控制这些代理的管理器")]),t._v("所构成. 代理与代理之间需要通信, 用以转发程序间通信的数据包; 代理与管理器之间也需要通信, 用以传递路由管理, 服务发现, 数据遥测等控制信息. "),s("strong",[t._v("服务网格使用数据平面(Data Plane)通信和控制平面(Control Plane)通信来形容这两类流量")]),t._v(", 下图中"),s("strong",[t._v("实线就表示数据平面通信, 虚线表示控制平面通信")]),t._v(".")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/mesh3.png",alt:"",title:"服务网格的控制平面通信与数据平面通信"}})]),t._v(" "),s("p",[t._v("数据平面与控制平面并不是什么新鲜概念, 它们最初就是用在计算机网络中的术语, 通常是指"),s("strong",[t._v("网络层次的划分")]),t._v(", 软件定义网络中将"),s("strong",[t._v("解耦数据平面与控制平面作为其最主要特征之一")]),t._v(". 服务网格把计算机网络的经典概念引入程序通信之中, 既可以说是对程序通信的一种变革创新, 也可以说是对网络通信的一种发展传承.")]),t._v(" "),s("p",[s("strong",[t._v('分离数据平面与控制平面的实质是将 "程序" 与 "网络" 进行解耦')]),t._v(", 将网络可能出现的问题(譬如中断后重试, 降级), 与可能需要的功能(譬如实现追踪度量)的处理过程"),s("strong",[t._v("从程序中拿出, 放到由控制平面指导的数据平面通信中去处理")]),t._v(', 制造出一种 "这些问题在程序间通信中根本不存在" 的假象, 仿佛网络和远程服务都是完美可靠的. 这种完美的假象, 让应用之间可以非常简单地交互而不必考虑过多异常情况, 也能够在不同的程序框架, 不同的云服务提供商环境之间平稳地迁移; 同时, 还能让管理者不依赖程序支持就得到遥测所需的全部信息, 根据角色, 权限进行统一的访问控制.')]),t._v(" "),s("h5",{attrs:{id:"_2-数据平面"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-数据平面"}},[t._v("#")]),t._v(" 2.数据平面")]),t._v(" "),s("p",[t._v("接下来的两个小节会延续"),s("strong",[t._v('服务网格将 "程序" 与 "网络" 解耦')]),t._v("的思路, 介绍数据平面通信与控制平面通信中的几个核心问题的解决方案. 在工业界, 数据平面已有 Linkerd, "),s("strong",[t._v("Nginx")]),t._v(", Envoy 等产品, "),s("strong",[t._v("控制平面也有 Istio, Open Service Mesh, Consul 等产品")]),t._v(", 后文笔者主要是以目前市场占有率最高的 "),s("strong",[t._v("Istio 与 Envoy")]),t._v(" 为例进行讲述, 但讲述的目的是"),s("strong",[t._v("介绍两种平面通信的技术原理")]),t._v(", 而不是介绍 Istio 和 Envoy 的功能与用法, 这里涉及的"),s("strong",[t._v("原理在各种服务网格产品中一般都是通用的")]),t._v(", 并不局限于某一种具体实现.")]),t._v(" "),s("p",[s("strong",[t._v("数据平面由一系列边车代理构成, 核心职责是转发应用的入站(Inbound)和出站(Outbound)数据包, 因此数据平面也被称为转发平面(Forwarding Plane)")]),t._v(" . 同时为了在不可靠的物理网络中"),s("strong",[t._v("保证程序间通信最大的可靠性")]),t._v(", 数据平面必须根据控制平面下发策略的指导, 在"),s("strong",[t._v("应用无感知的情况下自动完成服务路由, 健康检查, 负载均衡, 认证鉴权, 产生监控数据")]),t._v("等一系列工作. 为了达成上述工作目标, 至少需要妥善解决以下"),s("strong",[t._v("三个关键问题")]),t._v(".")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("代理注入")]),t._v(": 边车代理是如何注入应用程序中的?")]),t._v(" "),s("li",[s("strong",[t._v("流量劫持")]),t._v(": 边车代理是如何劫持应用程序的通信流量的?")]),t._v(" "),s("li",[s("strong",[t._v("可靠通信")]),t._v(": 边车代理是如何保证应用程序的通信可靠性的?")])]),t._v(" "),s("h6",{attrs:{id:"_1-代理注入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-代理注入"}},[t._v("#")]),t._v(" (1)代理注入")]),t._v(" "),s("p",[t._v("从职责上说, "),s("strong",[t._v("注入边车代理是控制平面的工作")]),t._v(", 但从本章的叙述逻辑上看, 将其放在数据平面中介绍更合适. "),s("strong",[t._v("把边车代理注入应用的过程并不一定全都是透明的")]),t._v(", 现在的服务网格产品使用以下三种方式将边车代理接入应用程序中.")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("基座模式")]),t._v("(Chassis): 这种方式接入的边车代理"),s("strong",[t._v("对程序就是不透明")]),t._v("的, 它至少会包括一个轻量级的 SDK, 通信"),s("strong",[t._v("由 SDK 中的接口去处理")]),t._v(". 基座模式的好处是在程序代码的帮助下, 有可能达到更好的性能, 功能也相对更容易实现, 但坏处是"),s("strong",[t._v("对代码有侵入性")]),t._v(", 对编程语言有依赖性. 这种模式的典型产品是由华为开源后捐献给 Apache 基金会的 ServiceComb Mesher. 基座模式目前"),s("strong",[t._v("并不属于主流方式")]),t._v(", 所以就不展开介绍了.")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("注入模式")]),t._v("(Injector): 根据注入方式不同, 又可以分为以下两种.")]),t._v(" "),s("p",[t._v("(1)"),s("strong",[t._v("手动注入模式")]),t._v(": 这种注入方式"),s("strong",[t._v("对使用者来说不透明, 但对程序来说是透明")]),t._v("的. 由于边车代理的定义就是"),s("strong",[t._v("一个与应用共享网络名称空间的辅助容器")]),t._v(", 这天然就契合了 Pod 的设定, 因此在 Kubernetes 中要进行手动注入是十分简单的---只是"),s("strong",[t._v("为 Pod 增加一个额外容器")]),t._v("而已, 即使没有工具帮助, 自己修改 Pod 的 Manifest 也能轻易办到.")]),t._v(" "),s("p",[t._v("(2)"),s("strong",[t._v("自动注入模式")]),t._v(": 这种注入方式"),s("strong",[t._v("对使用者和程序都是透明")]),t._v("的, 也是 "),s("strong",[t._v("Istio 推荐的代理注入方式")]),t._v('. 在 Kubernetes 中, 服务网格一般是依靠 "'),s("strong",[t._v("动态准入控制")]),t._v('"(Dynamic Admission Control)中的 Mutating Webhook 控制器来实现自动注入的.')])])]),t._v(" "),s("p",[t._v("这里以 "),s("strong",[t._v("Istio 自动注入边车代理")]),t._v("(istio-proxy 容器)的过程为例, 介绍一下自动注入的具体流程. 只要对 Istio 有基本了解就会知道, 对任何设置了 "),s("strong",[t._v("istio-injection=enabled")]),t._v(" 标签的名称空间, Istio 都会自动为其"),s("strong",[t._v("新创建的 Pod 注入一个名为 istio-proxy 的容器")]),t._v(". 之所以能做到自动这一点, 是因为 Istio 预先在 Kubernetes 中注册了一个类型为 "),s("strong",[t._v("MutatingWebhookConfiguration")]),t._v(" 的资源, 它的主要内容如下所示:")]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" admissionregistration.k8s.io/v1beta1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" MutatingWebhookConfiguration\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" istio"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("sidecar"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("injector\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("..\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("webhooks")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("clientConfig")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("service")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" istio"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("sidecar"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("injector\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("namespace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" istio"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("system\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /inject\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" sidecar"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("injector.istio.io\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("namespaceSelector")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("matchLabels")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("istio-injection")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" enabled\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("rules")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiGroups")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('""')]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersions")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" v1\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("operations")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" CREATE\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("resources")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" pods\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br")])]),s("p",[t._v("以上配置会告诉 Kubernetes, 对于"),s("strong",[t._v("符合标签 istio-injection:enabled 的名称空间, 在 Pod 资源进行 CREATE 操作时, 应该先自动触发一次 Webhook 调用, 调用的位置是 istio-system 名称空间中的服务 istio-sidecar-injector, 调用的 URL 路径是 /inject. 在这次调用中, Kubernetes 会把新建的 Pod 的元数据定义作为参数发送给 HTTP Endpoint, 然后从服务返回结果中得到注入边车代理的新 Pod 定义, 以此自动完成注入")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_2-流量劫持"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-流量劫持"}},[t._v("#")]),t._v(" (2)流量劫持")]),t._v(" "),s("p",[s("strong",[t._v("边车代理做流量劫持最典型的方式是基于 iptables 进行的数据转发")]),t._v(", 前面也介绍过 Netfilter 与 iptables 的工作原理. 这里仍然以 Istio 为例, 它在注入边车代理后, 除了生成封装 Envoy 的 istio-proxy 容器外, 还会生成一个 "),s("strong",[t._v("initContainer")]),t._v(", 作用是"),s("strong",[t._v("自动修改容器的 iptables")]),t._v(", 具体内容如下所示:")]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("initContainers")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("image")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" docker.io/istio/proxyv2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("1.5.1\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" istio"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("init\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("command")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" istio"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("iptables "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v('p "15001" '),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v('z "15006"'),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v('u "1337" '),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("m REDIRECT "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("i '"),s("span",{pre:!0,attrs:{class:"token important"}},[t._v("*'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v('x "" \n    '),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("b '"),s("span",{pre:!0,attrs:{class:"token important"}},[t._v("*'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("d 15090"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("15020")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("p",[t._v("以上命令行中的 istio-iptables 是 Istio 提供的用于"),s("strong",[t._v("配置 iptables 的 Shell 脚本")]),t._v(", 这行命令的意思是"),s("strong",[t._v("让边车代理拦截所有进出 Pod 的流量")]),t._v(", 包括的动作为拦截除 15090, 15020 端口(这两个分别是 Mixer 和 "),s("strong",[t._v("Ingress Gateway")]),t._v(" 的端口, 关于 Istio 占用的固定端口可参考官方文档所列)外的"),s("strong",[t._v("所有入站流量, 全部转发至 15006 端口(Envoy 入站端口), 经 Envoy 处理后, 再从 15001 端口(Envoy 出站端口)发送出去")]),t._v(". 该命令会在 iptables 中的 PREROUTING 和 OUTPUT 链中挂载相应的转发规则, 使用 iptables -t nat -L -v 命令可以看到如下所示配置信息:")]),t._v(" "),s("div",{staticClass:"language-sh line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[t._v("Chain PREROUTING\n pkts bytes target         prot opt "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v("      out        "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("source")]),t._v("     destination\n "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2701")]),t._v("  162K ISTIO_INBOUND  tcp  --  any     any        anywhere   anywhere\n\nChain OUTPUT\n pkts bytes target         prot opt "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v("      out        "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("source")]),t._v("     destination\n   "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("15")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("900")]),t._v(" ISTIO_OUTPUT   tcp  --  any     any        anywhere   anywhere\n\nChain ISTIO_INBOUND "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" references"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n pkts bytes target         prot opt "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v("      out        "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("source")]),t._v("     destination\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" RETURN      tcp  --  any  any   anywhere   anywhere   tcp dpt:ssh\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("120")]),t._v(" RETURN      tcp  --  any  any   anywhere   anywhere   tcp dpt:15090\n "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2699")]),t._v("  162K RETURN      tcp  --  any  any   anywhere   anywhere   tcp dpt:15020\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" ISTIO_IN_REDIRECT  tcp  --  any any        anywhere   anywhere\n\nChain ISTIO_IN_REDIRECT "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(" references"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n pkts bytes target      prot opt "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v("     out  "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("source")]),t._v("    destination\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" REDIRECT   tcp  --  any   any  anywhere  anywhere redir ports "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("15006")]),t._v("\n\nChain ISTIO_OUTPUT "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" references"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n pkts bytes target  prot opt "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v("     out     "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("source")]),t._v("               destination\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" RETURN  all  --  any    lo      "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("127.0")]),t._v(".0.6            anywhere\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" ISTIO_IN_REDIRECT all  --  any  lo  anywhere   \n        "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("localhost  owner "),s("span",{pre:!0,attrs:{class:"token environment constant"}},[t._v("UID")]),t._v(" match "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1337")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" RETURN  all  --  any  lo  anywhere  anywhere  \n        "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v(" owner "),s("span",{pre:!0,attrs:{class:"token environment constant"}},[t._v("UID")]),t._v(" match "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1337")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("15")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("900")]),t._v(" RETURN  all  --  any  any  anywhere anywhere owner "),s("span",{pre:!0,attrs:{class:"token environment constant"}},[t._v("UID")]),t._v(" match "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1337")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" ISTIO_IN_REDIRECT  all  --  any  lo anywhere   \n        "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("localhost   owner GID match "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1337")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" RETURN  all  --  any  lo  anywhere  anywhere "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v(" owner GID match "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1337")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" RETURN  all  --  any  any anywhere  anywhere owner GID match "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1337")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" RETURN  all  --  any  any anywhere  localhost\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" ISTIO_REDIRECT  all  --  any  any   anywhere     anywhere\n\nChain ISTIO_REDIRECT "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" references"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n pkts bytes target     prot opt "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v("   out  "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("source")]),t._v("              destination\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" REDIRECT   tcp  --  any  any  anywhere  anywhere  redir ports "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("15001")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br"),s("span",{staticClass:"line-number"},[t._v("25")]),s("br"),s("span",{staticClass:"line-number"},[t._v("26")]),s("br"),s("span",{staticClass:"line-number"},[t._v("27")]),s("br"),s("span",{staticClass:"line-number"},[t._v("28")]),s("br"),s("span",{staticClass:"line-number"},[t._v("29")]),s("br"),s("span",{staticClass:"line-number"},[t._v("30")]),s("br"),s("span",{staticClass:"line-number"},[t._v("31")]),s("br"),s("span",{staticClass:"line-number"},[t._v("32")]),s("br"),s("span",{staticClass:"line-number"},[t._v("33")]),s("br"),s("span",{staticClass:"line-number"},[t._v("34")]),s("br"),s("span",{staticClass:"line-number"},[t._v("35")]),s("br"),s("span",{staticClass:"line-number"},[t._v("36")]),s("br"),s("span",{staticClass:"line-number"},[t._v("37")]),s("br")])]),s("p",[t._v("用 iptables 进行流量劫持是最经典, 最通用的手段, 不过, iptables 重定向流量必须通过回环设备交换数据, 即流量不得不"),s("strong",[t._v("多穿越一次协议栈")]),t._v(", 如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/iptables.55330e25.png",alt:"img",title:"经iptables转发的通信"}})]),t._v(" "),s("p",[t._v("这种方案在网络 I/O 不构成主要瓶颈的系统中并没有什么不妥, 但在"),s("strong",[t._v("网络敏感的大并发场景下会损失一定的性能")]),t._v(". 目前, 如何实现更优化的数据平面流量劫持, 是服务网格发展的前沿研究课题之一. 其中一种"),s("strong",[t._v("可行的优化方案是使用 eBPF")]),t._v("(Extended Berkeley Packet Filter)技术, "),s("strong",[t._v("在 Socket 层面直接完成数据转发")]),t._v(", 而不需要再往下经过更底层的 TCP/IP 协议栈的处理, 从而减少数据在通信链路的路径长度, 如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/ebpf.9c4bdb6a-20230115180255853.png",alt:"img",title:"经eBPF直接转发的通信"}})]),t._v(" "),s("p",[t._v("另一种可以考虑的方案是"),s("strong",[t._v("让服务网格与 CNI 插件配合来实现流量劫持")]),t._v(", 譬如 Istio 就有提供自己实现的 CNI 插件. 只要安装了这个 CNI 插件, 整个"),s("strong",[t._v("虚拟化网络都由 Istio 自己来控制")]),t._v(", 那自然就无须依赖 iptables, 也不必存在 initContainers 配置和 istio-init 容器了. 这种方案有很高的上限与自由度, 不过, 要实现一个功能全面, 管理灵活, 性能优秀, 表现稳定的 CNI 网络插件绝非易事, 连 Kubernetes 自己都迫不及待想从网络插件中脱坑, 其麻烦程度可见一斑, 因此目前这种方案使用得也并不广泛.")]),t._v(" "),s("p",[t._v("流量劫持技术的发展与服务网格的落地效果密切相关, 有一些服务网格通过基座模式中的 SDK 也能达到很好的转发性能, 但考虑到应用程序通用性和环境迁移等问题, 无侵入式的低时延, "),s("strong",[t._v("低管理成本的流量劫持方案仍然是研究的主流方向")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_3-可靠通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-可靠通信"}},[t._v("#")]),t._v(" (3)可靠通信")]),t._v(" "),s("p",[t._v("注入边车代理, 劫持应用流量, "),s("strong",[t._v("最终的目的都是代理能够接管应用程序的通信")]),t._v(", 然而, 代理接管了应用的通信之后, 它会做什么呢? 这个问题的答案是: "),s("strong",[t._v("不确定")]),t._v(". 代理的行为需要根据控制平面提供的策略来决定, 传统的代理程序, 譬如 HAProxy, Nginx 是使用"),s("strong",[t._v("静态配置文件来描述转发策略")]),t._v("的, 这种"),s("strong",[t._v("静态配置很难跟得上应用需求的变化与服务扩缩时网络拓扑结构的变动")]),t._v(". Envoy 在这方面进行了创新, 它"),s("strong",[t._v("将代理转发的行为规则抽象成 Listener, Router, Cluster 三种资源")]),t._v(', 以此为基础, 又定义了应该如何发现和访问这些资源的一系列 API, 现在这些资源和 API 被统称为 "xDS协议族". 自此以后, '),s("strong",[t._v("数据平面就有了如何描述各种配置和策略的事实标准")]),t._v(", 控制平面也有了与控制平面交互的标准接口. 目前 xDS v3.0 协议族已经包含许多协议:")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("简称")]),t._v(" "),s("th",{staticStyle:{"text-align":"left"}},[t._v("全称")]),t._v(" "),s("th",{staticStyle:{"text-align":"left"}},[t._v("服务描述")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("LDS")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("Listener Discovery Service")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("监听器发现服务")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("RDS")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("Route Discovery Service")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("路由发现服务")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("CDS")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("Cluster Discovery Service")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("集群发现服务")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("EDS")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("Endpoint Discovery Service")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("集群成员发现服务")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("ADS")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("Aggregated Discovery Service")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("聚合发现服务")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("HDS")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("Health Discovery Service")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("健康度发现服务")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("SDS")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("Secret Discovery Service")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("密钥发现服务")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("MS")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("Metric Service")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("度量指标服务")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("RLS")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("Rate Limit Service")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("速率限制服务")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("ALS")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("gRPC Access Log Service")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("gRPC 访问日志服务")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("LRS")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("Load Reporting service")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("负载报告服务")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("RTDS")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("Runtime Discovery Service")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("运行时发现服务")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("CSDS")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("Client Status Discovery Service")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("客户端状态发现服务")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("ECDS")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("Extension Config Discovery Service")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("扩展配置发现服务")])])])]),t._v(" "),s("p",[t._v("这里不会逐一介绍这些协议, 但可以说清楚它们一致的运作原理, 其中的关键是解释清楚这些协议的"),s("strong",[t._v("共同基础")]),t._v(", 即 "),s("strong",[t._v("Listener, Cluster, Router")]),t._v(" 三种资源的具体含义.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("Listener")]),t._v(": Listener 可以简单理解为 Envoy 的一个"),s("strong",[t._v("监听端口")]),t._v(", 用于"),s("strong",[t._v("接收来自下游应用程序(Downstream)的数据")]),t._v(". Envoy 能够同时支持多个 Listener, 不同的 Listener 之间的"),s("strong",[t._v("策略配置是相互隔离")]),t._v("的. 自动发现 Listener 的服务被称为 "),s("strong",[t._v("LDS")]),t._v("(Listener Discovery Service, 监听器发现服务), 它是所有其他 xDS 协议的基础, 如果没有 LDS(也没有在 Envoy 启动时静态配置 Listener 的话), 其他所有 xDS 服务也就失去了意义, 因为没有监听端口的 Envoy 不能为任何应用提供服务.")]),t._v(" "),s("li",[s("strong",[t._v("Cluster")]),t._v(": Cluster 是 Envoy 能够连接到的一组逻辑上提供相同服务的"),s("strong",[t._v("上游(Upstream)主机")]),t._v(". Cluster 包含该服务的连接池, 超时时间, Endpoint 地址, 端口, 类型等信息. 具体到 Kubernetes 环境, 可以认为 Cluster 与 Service 是对等的概念, Cluster 实际上承担了"),s("strong",[t._v("服务发现")]),t._v("的职责. 自动发现 Cluster的 服务被称为 CDS(Cluster Discovery Service, 集群发现服务), 通常情况下, 控制平面会将它从外部环境中获取的所有可访问服务全量推送给 Envoy. 与 CDS 紧密相关的另一种服务是 "),s("strong",[t._v("EDS")]),t._v("(Endpoint Discovery Service, 集合成员发现服务). 当 Cluster 被标识为需要 EDS 时, 则说明该 Cluster 的所有 Endpoint 的地址应该由 xDS 服务下发, 而不是依靠 DNS 服务去解析.")]),t._v(" "),s("li",[s("strong",[t._v("Router")]),t._v(": Listener 负责"),s("strong",[t._v("接收来自下游的数据")]),t._v(", Cluster 负责将数据转发送给上游的服务, 而 Router 则决定 Listener 在接收到下游的数据之后, 具体应该将数据交给哪一个 Cluster 处理, 由此定义可知, Router 实际上是承担了服务网关的职责. 自动发现 Router 的服务被称为 RDS(Router Discovery Service, 路由发现服务), Router 中最核心的信息是目标 Cluster 及其匹配规则, 即"),s("strong",[t._v("实现网关的路由职能")]),t._v(". 此外, 视 Envoy 中的插件配置情况, 也可能包含重试, 分流, 限流等动作, 实现网关的过滤器职能.")])]),t._v(" "),s("p",[t._v("Envoy 的另外一个设计重点是 "),s("strong",[t._v("Filter 机制")]),t._v(". Filter 通俗地讲就是 Envoy 的插件, 通过 Filter 机制, Envoy 提供了强大的可扩展能力, 插件不是无关重要的外围功能, 很多 Envoy 的核心功能都使用 Filter 来实现的. 譬如对 "),s("strong",[t._v("HTTP 流量的治理, Tracing 机制, 多协议支持")]),t._v(", 等等. 利用 Filter 机制, "),s("strong",[t._v("Envoy 理论上可以实现任意协议的支持以及协议之间的转换, 可以对请求流量进行全方位的修改和定制, 还可以保持较高的可维护性")]),t._v(".")]),t._v(" "),s("h5",{attrs:{id:"_3-控制平面"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-控制平面"}},[t._v("#")]),t._v(" 3.控制平面")]),t._v(" "),s("p",[t._v("如果说"),s("strong",[t._v("数据平面是行驶中的车辆, 那控制平面就是车辆上的导航系统")]),t._v("; 如果说数据平面是城市的交通道路, 那控制平面就是路口的指示牌与交通信号灯. "),s("strong",[t._v("控制平面的特点是不直接参与程序间通信, 只会与数据平面中的代理通信, 在程序不可见的背后, 默默地完成下发配置和策略, 指导数据平面工作")]),t._v(". 由于服务网格(暂时)没有大规模引入计算机网络中管理平面(Management Plane)等其他概念, 所以控制平面通常也会附带地实现诸如网络行为的可视化, 配置传输等一系列管理职能(其实还是有专门的管理平面的工具的, 譬如 Meshery, ServiceMeshHub). 这里仍然以 Istio 为例介绍控制平面的主要功能.")]),t._v(" "),s("p",[t._v("Istio 在 1.5 版本之前, 也是采用微服务架构开发的. 它将控制平面的职责分解为 Mixer, Pilot, Galley, Citadel 四个模块去实现, 其中 Mixer 负责鉴权策略与遥测; Pilot 负责对接 Envoy 的数据平面, 遵循 xDS 协议进行策略分发; Galley 负责配置管理, 为服务网格提供外部配置感知能力; Citadel 负责安全加密, 提供服务和用户层面的认证和鉴权, 管理凭据和 RBAC 等安全相关能力. 不过, 经过实践应用, 很多用户都反馈 Istio 的微服务架构有"),s("strong",[t._v("过度设计")]),t._v("的嫌疑. Istio 在定义项目目标时, 曾非常理想化地提出控制平面的各个组件都"),s("strong",[t._v("应能独立部署")]),t._v(", 然而在实际应用场景里却并非如此, 独立的组件反而带来了部署复杂, 职责划分不清晰等问题.")]),t._v(" "),s("p",[t._v("从 1.5 版本起, Istio 重新"),s("strong",[t._v("回归单体架构")]),t._v(", 将 Pilot, Galley, Citadel 的功能全部集成到新的 istiod 之中, 如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/istio-arch.9a97cf23.png",alt:"",title:"Istio 1.5版本之后的架构"}})]),t._v(" "),s("p",[t._v("当然这也并不是说完全推翻之前的设计, 只是将原有的"),s("strong",[t._v("多进程形态优化成单进程的形态")]),t._v(", 之前各个独立组件变成了 istiod 的内部逻辑上的子模块而已. 单体化之后出现的新进程 istiod 就承担了所有的控制平面职责, 具体包括如下内容.")]),t._v(" "),s("p",[t._v("(1)"),s("strong",[t._v("数据平面交互")]),t._v(": 这是满足服务网格正常工作所需的必要工作, 具体包括以下几个方面.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("边车注入")]),t._v(": 在 Kubernetes 中注册 Mutating Webhook 控制器, 实现代理容器的自动注入, 并生成 Envoy 的启动配置信息.")]),t._v(" "),s("li",[s("strong",[t._v("策略分发")]),t._v(": 接手了原来 Pilot 的核心工作, 为所有的 Envoy 代理提供符合 xDS 协议的策略分发的服务.")]),t._v(" "),s("li",[s("strong",[t._v("配置分发")]),t._v(": 接手了原来 Galley 的核心工作, 负责监听来自多种支持配置源的数据, 譬如 kube-apiserver, 本地配置文件, 或者定义为网格配置协议(Mesh Configuration Protocol, MCP)的配置信息. 原来 Galley 需要处理的 API 校验和配置转发功能也包含在内.")])]),t._v(" "),s("p",[t._v("(2)"),s("strong",[t._v("流量控制")]),t._v(": 这通常是用户使用服务网格的"),s("strong",[t._v("最主要目的")]),t._v(", 具体包括以下几个方面.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("请求路由")]),t._v(": 通过 VirtualService, DestinationRule 等 Kubernetes 自定义资源实现了灵活的服务版本切分与规则路由. 譬如以服务的迭代版本号(如 v1.0 版, v2.0 版), 部署环境(如 Development 版, Production 版)作为路由规则来控制流量, 实现诸如金丝雀发布这类应用需求.")]),t._v(" "),s("li",[s("strong",[t._v("流量治理")]),t._v(": 包括熔断, 超时, 重试等功能, 譬如通过修改 Envoy 的最大连接数, 实现对请求的流量控制; 通过修改负载均衡策略, 在轮询, 随机, 最少访问等方式间进行切换; 通过设置异常探测策略, 将满足异常条件的实例从负载均衡池中摘除, 以保证服务的稳定性, 等等.")]),t._v(" "),s("li",[s("strong",[t._v("调试能力")]),t._v(": 包括故障注入和流量镜像等功能, 譬如在系统中人为设置一些故障, 来测试系统的容错稳定性和系统恢复的能力. 又譬如通过复制一份请求流量, 把它发送到镜像服务, 从而满足A/B验证的需要.")])]),t._v(" "),s("p",[t._v("(3)"),s("strong",[t._v("通信安全")]),t._v(": 包括通信中的加密, 凭证, 认证, 授权等功能, 具体包括以下几个方面.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("生成 CA 证书")]),t._v(": 接手了原来 Galley 的核心工作, 负责生成通信加密所需私钥和 CA 证书.")]),t._v(" "),s("li",[s("strong",[t._v("SDS 服务代理")]),t._v(": 最初 Istio 是通过 Kubernetes 的 Secret 卷的方式将证书分发到 Pod 中的, 从 Istio 1.1 版本之后改为通过 SDS 服务代理来解决, 这种方式保证了私钥证书不会在网络中传输, 仅存在于 SDS 代理和 Envoy 的内存中, 证书刷新轮换也不需要重启 Envoy.")]),t._v(" "),s("li",[s("strong",[t._v("认证")]),t._v(": 提供基于节点的服务认证和基于请求的用户认证, 这项功能曾在之前详细介绍过.")]),t._v(" "),s("li",[s("strong",[t._v("授权")]),t._v(": 提供不同级别的访问控制.")])]),t._v(" "),s("p",[t._v("(4)"),s("strong",[t._v("可观测性")]),t._v(": 包括日志, 追踪, 度量三大能力, 具体包括以下几个方面.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("日志收集")]),t._v(": 程序日志的收集并不属于服务网格的处理范畴, 通常会使用 ELK Stack 去完成, 这里是指远程服务的访问日志的收集, 对等的类比目标应该是以前 Nginx, Tomcat 的访问日志.")]),t._v(" "),s("li",[s("strong",[t._v("链路追踪")]),t._v(": 为请求途经的所有服务生成分布式追踪数据并自动上报, 运维人员可以通过 Zipkin 等追踪系统从数据中重建服务调用链, 开发人员可以借此了解网格内服务的依赖和调用流程.")]),t._v(" "),s("li",[s("strong",[t._v("指标度量")]),t._v(": 基于四类不同的监控标识(响应延迟, 流量大小, 错误数量, 饱和度)生成一系列观测不同服务的监控指标, 用于记录和展示网格中的服务状态.")])]),t._v(" "),s("h4",{attrs:{id:"服务网格与生态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务网格与生态"}},[t._v("#")]),t._v(" 服务网格与生态")]),t._v(" "),s("p",[t._v("服务网格目前仍然处于技术浪潮的"),s("strong",[t._v("早期")]),t._v(", 但其价值已被业界所普遍认可, 几乎所有希望能够影响云原生发展方向的企业都已参与进来. 从最早 2016 年的 Linkerd 和 Envoy, 到 2017 年 Google, IBM 和 Lyft 共同发布的 "),s("strong",[t._v("Istio")]),t._v(", 再到后来 CNCF 将 Buoyant 的 Conduit 改名为 Linkerd2 再度参与 Istio 竞争. 2018 年后, 服务网格的话语权争夺战已全面升级至由云计算巨头直接主导. Google 将 Istio 搬上 Google Cloud Platform, 推出了 Istio 的公有云托管版本 Google Cloud Service Mesh; 亚马逊推出了用于 AWS 的 App Mesh; 微软推出了 Azure 完全托管版本的 Service Fabric Mesh, 发布了自家的控制平面 Open Service Mesh; 阿里巴巴也推出了基于 Istio 的修改版 SOFAMesh, 并开源了自己研发的 MOSN 代理. 可以说, "),s("strong",[t._v('云计算的所有 "玩家" 都正在布局服务网格生态')]),t._v(".")]),t._v(" "),s("p",[t._v("市场繁荣的同时也带来了"),s("strong",[t._v("碎片化")]),t._v('的问题, 一个技术领域能够形成被业界普遍承认的规范标准, 是这个领域从分头研究, 各自开拓的萌芽状态, 走向工业化生产应用的成熟状态的重要标志. 标准的诞生可以说是每一项技术普及之路中都必须经历的"成人礼". 前面曾接触过'),s("strong",[t._v("容器运行时领域的 CRI 规范, 容器网络领域的 CNI 规范, 容器存储领域的 CSI 规范")]),t._v(", 尽管服务网格诞生至今仅有数年时间, 但作为微服务, 云原生的前沿热点, 它也正在酝酿自己的标准规范, 即本节的主角: "),s("strong",[t._v("服务网格接口")]),t._v("(Service Mesh Interface, "),s("strong",[t._v("SMI")]),t._v(") 与"),s("strong",[t._v("通用数据平面 API")]),t._v("(Universal Data Plane API, UDPA), 它们的关系如下图所示.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230115115734857.png",alt:"",title:"SMI规范与UDPA规范"}})]),t._v(" "),s("p",[s("strong",[t._v("服务网格的实质是数据平面产品与控制平面产品的集合")]),t._v(", 所以在规范制订方面, 很自然地分成了两类. "),s("strong",[t._v("SMI 规范提供了外部环境(实际上就是 Kubernetes)与控制平面交互的标准, 使得 Kubernetes 及在其之上的应用能够无缝切换各种服务网格产品. UDPA 规范则提供了控制平面与数据平面交互的标准, 使得服务网格产品能够灵活搭配不同的边车代理, 针对不同场景的需求, 发挥各类边车代理的功能或者性能优势")]),t._v(". 这两个规范并没有重叠, 它们的关系与在容器运行时中介绍的 CRI 和 OCI 规范的关系颇有些相似.")]),t._v(" "),s("h5",{attrs:{id:"_1-服务网格接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-服务网格接口"}},[t._v("#")]),t._v(" 1.服务网格接口")]),t._v(" "),s("p",[t._v("2019年, 微软联合 Linkerd, HashiCorp, Solo, Kinvolk 和 Weaveworks 等一批云原生服务商共同宣布了 "),s("strong",[t._v("Service Mesh Interface")]),t._v(" 规范, 希望能在各家的服务网格产品之上建立一个抽象的 API 层, 然后通过这个抽象层来解耦和屏蔽底层服务网格实现, 让上层的应用, 工具, 生态系统可以建立在同一个业界标准之上, "),s("strong",[t._v("从而实现应用程序在不同服务网格产品之间的无缝移植与互通")]),t._v(".")]),t._v(" "),s("p",[t._v("如果你更熟悉 Istio 的话, 不妨把 SMI 的作用理解为"),s("strong",[t._v("提供一套与 Istio 中 VirtualService, DestinationRule, Gateway 等私有概念对等的行业标准版本")]),t._v(", 只要使用 SMI 中定义的标准资源, 应用程序就可以在不同的控制平面上灵活迁移, 唯一的要求是这些控制平面都支持了 SMI 规范.")]),t._v(" "),s("p",[t._v("SMI 与 Kubernetes 是"),s("strong",[t._v("彻底绑定")]),t._v('的, 规范的落地执行完全依靠在 Kubernetes 中部署 SMI 定义的 CRD 来实现, 这一点在 SMI 的目标中被形容为 "Kubernetes Native", 说明微软等云服务厂商已经认定容器编排领域不会有 Kubernetes 之外的候选项, 这也是微软选择在 KubeCon 大会上公布 SMI 规范的原因. 但是在另外一端, SMI 并不与包括行业第一的 Istio 或者微软自家 Open Service Mesh 在内的任何控制平面所绑定, 这点在 SMI 的目标中被形容为 "Provider Agnostic", 说明微软看到了服务网格领域处于群雄混战的现状. Provider Agnostic 对消费者有利, 但对目前处于行业领先地位的 Istio 肯定是不利的, 所以 SMI 为何没有得到 Istio 及其背后的 Google, IBM 与 Lyft 的支持也就完全可以理解了.')]),t._v(" "),s("p",[t._v("在过去的两年里, Istio 无论是在发展策略还是在设计上(过度设计)的风评并不算好, 业界一直在期待 Google 和 Istio 能做出改进, "),s("strong",[t._v("在持续两年的失望之后, 已经有很多用户在考虑 Istio 以外的选择了. SMI 一发布就吸引了除 Istio 之外几乎所有的服务网格玩家参与进来")]),t._v(". 这恐怕并不仅仅是因为微软号召力大的缘故. 为了对抗 Istio 的抵制, SMI 还提供了一个 Istio 的适配器, 以便使用 Istio 的程序能平滑地迁移的 SMI 上, 所以遗留代码并不能为 Istio 构建出特别坚固的壁垒.")]),t._v(" "),s("p",[t._v("2020 年 4 月, SMI 被托管到 CNCF, 成为其中的一个 Sandbox 项目(Sandbox 是最低级别的项目, CNCF 只提供有限度的背书), 如果能够经过孵化, 毕业阶段的话, SMI 将有望成为公认的行业标准, 这也是开源技术社区里民主管理的一点好处.")]),t._v(" "),s("p",[t._v("讲述了 SMI 的背景与价值, 笔者再简要介绍一下 SMI 的主要内容. 目前(v0.5 版本)的 SMI 规范包括四方面的 API构成, 分别如下.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("流量规范")]),t._v("(Traffic Specs): "),s("strong",[t._v("目标是定义流量的表示方式")]),t._v(", 譬如 TCP 流量, HTTP/1 流量, HTTP/2 流量, gRPC 流量, WebSocket 流量等该如何"),s("strong",[t._v("在配置中抽象及使用")]),t._v(". 目前 SMI 只提供了 TCP 和 HTTP 流量的直接支持, 而且都比较简陋, 譬如 HTTP 流量的路由中甚至不支持以 Header 作为判断条件. 这暂时只能自我安慰地解释为 SMI 在流量协议的扩展方面是完全开放的, 没有功能也能自己扩充, 哪怕不支持或私有协议的流量也有可能使用 SMI 来管理. "),s("strong",[t._v("流量表示是路由和访问控制的必要基础, 因为必须要以流量中的特征为条件才能进行转发和控制")]),t._v(", 流量规范中已经自带了路由能力, 访问控制则被放到独立的规范中去实现.")]),t._v(" "),s("li",[s("strong",[t._v("流量拆分")]),t._v("(Traffic Split): "),s("strong",[t._v("目标是定义不同版本服务之间的流量比例")]),t._v(", 提供流量治理的能力, 譬如限流, 降级, 容错等, 以满足灰度发布, A/B 测试等场景. SMI 的流量拆分是直接基于 Kubernetes 的 Service 资源来设置的, 这样做的好处是使用者不需要学习理解新的概念, 坏处是要拆分流量就必须定义出具有层次结构的 Service, 即 Service 后面不是 Pod, 而是其他 Service. 而 Istio 中则是设计了 VirtualService 这样的新概念来解决相同的问题, 通过 Subset 来拆分流量. 至于两者孰优孰劣, 这就见仁见智了.")]),t._v(" "),s("li",[s("strong",[t._v("流量度量")]),t._v("(Traffic Metric): "),s("strong",[t._v("目标是为资源提供通用集成点")]),t._v(", 度量工具可以通过访问这些集成点来抓取指标. 这部分完全遵循了 Kubernetes 的 Metrics API 进行扩充.")]),t._v(" "),s("li",[s("strong",[t._v("流量访问控制")]),t._v("(Traffic Access Control): "),s("strong",[t._v("目标是根据客户端的身份配置")]),t._v(', 对特定的流量访问特定的服务提供简单的访问控制. SMI 绑定了 Kubernetes 的 ServiceAccount 来做服务身份访问控制, 这里说的"简单"不是指它的使用简单, 而是说它只支持 ServiceAccount 一种身份机制, 在正式使用中这恐怕是不足以应付所有场景的, 日后应该还需要继续扩充.')])]),t._v(" "),s("p",[t._v("这四种 API 目前暂时均是 Alpha 版本, "),s("strong",[t._v("意味着它们还未成熟")]),t._v(", 随时可能发生变动. 从目前版本来看, 至少与 Istio 的私有 API 相比, SMI 没有明显优势, 不过考虑 SMI 还处于项目早期阶段, 不够强大也情有可原, 希望未来 SMI 可以成长为一个足够坚实可用的技术规范, 这有助于避免数据平面出现一家独大的情况, 有利于竞争与发展.")]),t._v(" "),s("h5",{attrs:{id:"_2-通用数据平面api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-通用数据平面api"}},[t._v("#")]),t._v(" 2.通用数据平面API")]),t._v(" "),s("p",[t._v('2019 年 5 月, CNCF 创立了一个名为 "'),s("strong",[t._v("通用数据平面 API 工作组")]),t._v('"(Universal Data Plane API Working Group, UDPA-WG)的组织, 目标是制定类似于软件定义网络中 OpenFlow 协议的数据平面交互标准. 工作组的名字被敲定的那一刻, 就已经决定了所产出的标准名字必定叫 "'),s("strong",[t._v("通用数据平面 API")]),t._v('"(Universal Data Plane API, '),s("strong",[t._v("UDPA")]),t._v(").")]),t._v(" "),s("p",[t._v("如果不纠结于是否足够标准, 是否由足够权威组织来制定的话, 之前介绍数据平面时提到的 "),s("strong",[t._v("Envoy xDS 协议族其实就已经完全满足了控制平面与数据平面交互的需要")]),t._v(". 事实上, Envoy 正是 UDPA-WG 工作组的主要成员, 在 2019 年 11 月 Envoy 的核心开发者详细而清晰地说明了 xDS 与 UDAP 之间的关系: "),s("strong",[t._v("UDAP 的研发就是基于 xDS 的经验, 在未来 xDS 将逐渐向 UDPA 靠拢, 最终将基于 UDPA 来实现")]),t._v(".")]),t._v(" "),s("p",[t._v("在规范内容方面, 由于 UDPA 连 Alpha 状态都未能达到, 目前公开的资料还很少. 从 GitHub 和 Google 文档上能找到的部分设计原型文件来看, UDAP 的主要内容会分为传输协议(UDPA-TP, TransPort)和数据模型(UDPA-DM, Data Model)两部分, 且这两部分是独立设计的, 以后完全有出现不同的数据模型共用同一套传输协议的可能.")]),t._v(" "),s("h5",{attrs:{id:"_3-服务网格生态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-服务网格生态"}},[t._v("#")]),t._v(" 3.服务网格生态")]),t._v(" "),s("p",[t._v('2016 年 "Service Mesh" 一词诞生至今不过几年, 服务网格已经从研究理论变成在工业界中广泛采用的技术, 用户的态度也从观望走向落地生产. 下面按'),s("strong",[t._v("数据平面和控制平面")]),t._v(", 分别介绍一下目前服务网格产品的"),s("strong",[t._v("主要竞争者")]),t._v(".")]),t._v(" "),s("p",[t._v("在"),s("strong",[t._v("数据平面")]),t._v("的产品主要有以下几个.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("Linkerd")]),t._v(": 2016 年 1 月发布的 Linkerd 是服务网格的鼻祖, 使用 Scala 语言开发的 Linkerd-proxy 也就成为业界第一款正式的边车代理. 由于 Linkerd-proxy 运行需要 Java 虚拟机的支持, 在启动时间, 预热, 内存消耗等方面相比晚它半年发布的挑战者 Envoy 均处于全面劣势, 因而 Linkerd 很快就被 Istio 与 Envoy 的组合所击败, 结束了它短暂的统治期.")]),t._v(" "),s("li",[s("strong",[t._v("Envoy")]),t._v(": 2016 年 9 月开源的 "),s("strong",[t._v("Envoy 是目前边车代理产品中市场占有率最高")]),t._v("的一款产品, 已经在很多个企业的生产环境里经受过大量检验. Envoy 最初由 Lyft 公司开发, 后来由于 Lyft 与Google, IBM 达成合作协议, 所以 "),s("strong",[t._v("Envoy 就成了 Istio 的默认数据平面")]),t._v(". Envoy 使用 C++ 语言实现, 比起 Linkerd 在资源消耗方面有了明显的改善. 此外, 由于采用了公开的 xDS 协议进行控制, Envoy 并不只为 Istio 所私有, 这个特性让 Envoy 被很多其他的管理平面选用, 为它夺得市场占有率桂冠做出了重要贡献.")]),t._v(" "),s("li",[s("strong",[t._v("Conduit/Linkerd")]),t._v(" : 这是 Linkerd-proxy 被 Envoy 击败后, Buoyant 公司使用 Rust 语言重新开发的第二代的服务网格产品, 最初是以 Conduit 命名, 在 Conduit 加入 CNCF 后不久, 与原有的 Linkerd 项目合并, 被重新命名为 Linkerd2(这样就只算一个项目了). 使用 Rust 重写后, Linkerd2-proxy 的性能与资源消耗方面都已不输 Envoy, 但它的定位通常是作为 Linkerd2 的专有数据平面, 成功与否很大程度上取决于 Linkerd2 的发展.")]),t._v(" "),s("li",[s("strong",[t._v("MOSN")]),t._v(": 2018 年 6 月, 来自蚂蚁金服的 MOSN 宣布开源, MOSN 是 SOFAStack 中的一部分, 使用 Golang 语言实现, 在阿里巴巴及蚂蚁金服中经受住了大规模的应用考验. 由于 MOSN 是阿里技术生态的一部分, 对于使用了 Dubbo 框架, 或者 SOFABolt 这样的 RPC 协议的微服务应用, MOSN 往往能够提供额外的便捷性.")])]),t._v(" "),s("p",[t._v("以上介绍的是知名度和使用率最高的一部分"),s("strong",[t._v("数据平面")]),t._v(", 笔者在选择时也考虑了不同程序语言实现的代表性, 其他未提及的数据平面还有 HAProxy Connect, Traefik, ServiceComb Mesher 等, 这里不再逐一介绍.")]),t._v(" "),s("p",[t._v("除了数据平面, 服务网格中另外一条争夺激烈的战线是"),s("strong",[t._v("控制平面产品")]),t._v(", 主要包括以下产品.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("Linkerd2")]),t._v(': Buoyant 公司的服务网格产品, 无论是数据平面抑或是控制平面均使用了 "Linkerd" 和 "Linkerd2" 的名字. 功能上 Linkerd2 仍不足以与 Istio 媲美, 在 mTLS, 多集群支持, 支持流量拆分条件的丰富程度等方面 Istio 都比 Linkerd2 更有优势, 毕竟两者背后的研发资源并不对等, 一方是创业公司 Buoyant, 另一方是 Google, IBM 等巨头.')]),t._v(" "),s("li",[s("strong",[t._v("Istio")]),t._v(": Google, IBM 和 Lyft 公司联手打造的产品, "),s("strong",[t._v("以自己的 Envoy 为默认数据平面. Istio 是目前功能最强大的服务网格")]),t._v(", 如果你苦恼于这方面产品的选型, 直接挑选 Istio 不一定是最合适的, 但起码能保证这是不会有明显缺陷的选择; 同时 Istio 也是市场占有率第一的控制平面, 不少公司发布的服务网格产品都是在它的"),s("strong",[t._v("基础上派生增强")]),t._v("而来, 譬如蚂蚁金服的 SOFAMesh, Google Cloud Service Mesh 等. 不过, 服务网格毕竟比容器运行时, 容器编排要年轻, Istio 在服务网格领域尽管占有不小的优势, 但统治力还远远不能与容器运行时领域的 Docker 和容器编排领域的 Kubernetes 相媲美.")]),t._v(" "),s("li",[s("strong",[t._v("Consul Connect")]),t._v(': Consul Connect 是来自 HashiCorp 公司的服务网格, 目标是将现有由 Consul 管理的集群平滑升级为服务网格的解决方案. 如同 Connect 这个名字所预示的"连接"含义, Consul Connect 十分强调其整合集成的角色定位, 不与具体的网络和运行平台绑定, 可以切换多种数据平面(默认为 Envoy), 支持多种运行平台, 譬如 Kubernetest, Nomad 或者标准的虚拟机环境.')]),t._v(" "),s("li",[s("strong",[t._v("OSM")]),t._v(": OSM(Open Service Mesh)是微软开源的服务网格, 同样"),s("strong",[t._v("以 Envoy 为数据平面")]),t._v(". OSM 项目的其中一个主要目标是"),s("strong",[t._v("作为 SMI 规范的参考实现")]),t._v('. 同时, 为了与强大却复杂的 Istio 进行差异化竞争, OSM 明确以"'),s("strong",[t._v("轻量简单")]),t._v('"为卖点, 通过减少边缘功能和对外暴露的 API 数量, 降低服务网格的学习, 使用成本. 现在服务网格正处于群雄争霸的时期, 在世界三大云计算厂商中, 亚马逊的 AWS App Mesh 走的是专有闭源的发展路线, 剩下就只有微软与 Google 具有相似体量, 能够对等地竞争. 但它们又选择了截然不同的竞争策略: OSM 开源后, 微软马上将其捐献给 CNCF, 成为开源社区的一部分; 与此相对, 尽管 CNCF 与 Istio 都有着 Google 的背景关系, 但 Google 却不惜违反与 IBM, Lyft 之间的协议, '),s("strong",[t._v("拒绝将 Istio 托管至 CNCF")]),t._v(", 而是自建新组织转移了 Istio 的商标所有权. 这种做法不出意外地遭到开源界的抗议, 让观众产生了一种微软与 Google 身份错位的感觉. 在云计算的激烈竞争中, "),s("strong",[t._v("似乎已经再也分不清楚谁是恶龙, 谁是屠龙少年了")]),t._v(".")])]),t._v(" "),s("p",[t._v("上面未提到的控制平面还有许多, 譬如 Traefik Mesh, Kuma 等, 这里不再展开介绍.")]),t._v(" "),s("p",[t._v("服务网格也许是未来的发展方向, 但想要真正发展成熟并大规模落地还有很长的一段路要走. 一方面, 相当多的程序员已经"),s("strong",[t._v("习惯了通过代码与组件库去进行微服务治理")]),t._v(", 并且已经积累了很多的经验, 能把产品做得足够成熟稳定, 因此对服务网格的需求并不迫切; 另一方面, 目前服务网格产品的成熟度还有待提高, 冒险迁移过于激进, 也容易面临兼容性的问题. 也许服务网格开始远离市场宣传的喧嚣后, 才会真正落地.")]),t._v(" "),s("h3",{attrs:{id:"向微服务迈进"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#向微服务迈进"}},[t._v("#")]),t._v(" 向微服务迈进")]),t._v(" "),s("p",[t._v("本书的主体内容是务实的, 多谈具体技术, 少谈方向理论, 只在本章集中讨论几点与分布式, 微服务, 架构等相关的相对务虚的话题.")]),t._v(" "),s("p",[t._v('《人月神话: 软件项目管理之道》里反复强调一个观点: "'),s("strong",[t._v("软件研发中任何一项技术, 方法, 架构都不可能是银弹")]),t._v('." 这个结论已经被软件工程里无数事实所验证, 现在对于微服务也依然成立. 本节将会谈到哪些场景适合使用微服务, 以及一些已经被验证过, 被总结为经验的最佳的实践方式; 而更主要的是'),s("strong",[t._v("想讨论哪些场景不适合微服务, 微服务存在哪些理解误区, 应用前提")]),t._v(", 等等.")]),t._v(" "),s("h4",{attrs:{id:"目的-微服务的驱动力"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#目的-微服务的驱动力"}},[t._v("#")]),t._v(" 目的: 微服务的驱动力")]),t._v(" "),s("p",[t._v("在讨论什么时候开始以及如何向微服务迁移之前, "),s("strong",[t._v("先来理清为什么需要微服务")]),t._v(". 凡事总该先有目的, 有预期收益再谈行动才显得合理. 有人会说迈向微服务的目的是追求更先进的"),s("strong",[t._v("架构形式")]),t._v('. 这话对, 但没有什么信息量可言, 任何一次架构演进的目的都是为了更加先进, 应该没谁是为 "追求落后" 而重构系统的. 有人会说微服务是信息系统发展的必然阶段, 为了应对日益庞大的压力, 获得更好的性能, 自然会演进至能够扩缩自如的微服务架构. 这个观点看似合理, 具体, 正确, 实则争议颇大. 笔者个人的态度是旗帜鲜明地'),s("strong",[t._v('反对以 "获得更好的性能" 为主要目的')]),t._v(', 将系统重构为微服务架构, 性能有可能会作为辅助性的理由, 但仅仅为了性能而选择分布式的话, 那应该是 40 年前 "原始分布式时代" 所追求的目标. 现代的单体系统同样会采用可扩缩的设计, 同样能够集群部署, 更重要的是云计算数据中心的处理能力几乎可以认为是无限的, 那能够通过扩展硬件的手段解决问题就尽量别使用复杂的软件方法, 其中原因在前面引用"银弹"时已经解释过: '),s("strong",[t._v("硬件的成本能够持续稳定地下降, 而软件开发的成本则不可能")]),t._v(". 而且, 性能也不会因为采用了微服务架构而凭空产生. 把系统拆成多个微服务, 一旦在某个关键地方依然卡住了业务流程, 其整体的结果往往还不如单体, 没有清晰的职责划分, 导致扩展性失效, 多加机器往往还不如单机. 将前面这句话开头的性能替换为代码质量, 生产力等词语往往也同样适用, 具体不再赘述.")]),t._v(" "),s("p",[t._v("软件系统选择微服务架构, 通常比较常见的, "),s("strong",[t._v("合理的驱动力来自组织外部, 内部两方面")]),t._v(".")]),t._v(" "),s("p",[t._v("先列举一些"),s("strong",[t._v("外部因素")]),t._v(".")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("当意识到没有什么技术能够包打天下")]),t._v(". 举个具体例子, 某个系统选用了 Java 语言来开发, 也会遇到很多想做但 Java 却不擅长的事情. 譬如想做人工智能, 进行深度学习训练, 发现大量的库和开源代码都离不开 Python; 想要引入分布式协调工具时, 发现近几年 ZooKeeper 已经有被后起之秀 Go 的 etcd 蚕食替代的趋势; 想做集中式缓存, 发现无可争议的首选是 Redis, 等等. 很多时候为"),s("strong",[t._v("异构能力进行的分布式部署")]),t._v(", 并不是你想或者不想的问题, 而是没有选择, 不可避免的.")]),t._v(" "),s("li",[s("strong",[t._v("当个人能力因素成为系统发展的明显制约")]),t._v('. 在单体架构下, 没有什么有效阻断错误传播的手段, 系统中"整体"与"部分"的关系没有物理的划分, 系统质量只能靠研发与项目管理措施来尽可能地保障, 少量的技术专家很难阻止大量螺丝钉式的程序员或者不熟悉原有技术架构的外包人员在某个不起眼的地方犯错并产生全局性的影响, 不容易做出整体可靠的大型系统. 这时微服务可以作为专家掌控架构约束力的技术手段, 由高水平的开发, 运维人员去保证关键的技术和业务服务质量, 其他大量外围的功能即使不靠谱, 甚至默认它们必定不靠谱, 也能保证系统整体的稳定和局部的容错, 自愈与快速迭代.')]),t._v(" "),s("li",[s("strong",[t._v("当遇到来自外部商业层面对内部技术层面提出的要求")]),t._v('. 对于那些以"自产自销"为主的互联网公司来说这一点体验不明显, 但对于很多为企业提供信息服务的软件公司来说, '),s("strong",[t._v("甲方的要求往往才是具决定性的推动力")]),t._v(". 技术, 需求上的困难也许能变通克服, 但当微服务架构变成大型系统先进性的背书时, 甲方的招投标文件技术规范明文要求系统必须支持微服务架构, 分布式部署, 那就没有多少讨价还价的余地了.")])]),t._v(" "),s("p",[t._v("在系统和研发"),s("strong",[t._v("团队内部")]),t._v(", 也会有一些因素促使其向微服务靠拢.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("变化发展特别快的创新业务系统往往会自主地向微服务架构靠近")]),t._v('. 对于那种 "一个功能上线平均活不过三天" 的系统, 如果团队本身能力能够支撑在合理的代价下让功能有快速迭代的可能, 让代码能避免在类库层面的直接依赖而导致纠缠不清, 让系统有更好的可观测性和回弹性(自愈能力), 需求, 开发, 运维人员肯定都是很乐意接受微服务的, 毕竟此时大家的利益一致, 微服务的实施也会水到渠成.')]),t._v(" "),s("li",[s("strong",[t._v("大规模的, 业务复杂的, 历史包袱沉重的系统也可能主动向微服务架构靠近")]),t._v(".")])]),t._v(" "),s("p",[t._v("以上列举的这些内外部原因只是举例, 肯定不是全部, 选择微服务的具体理由可能多种多样, 相信你做出向微服务迈进的决策时, 一定经过恰当的权衡, 认为收益大于成本. "),s("strong",[t._v("微服务最主要的目的是对系统进行有效拆分, 实现物理层面的隔离, 微服务的核心价值就是拆分之后的系统能够让局部的单个服务有可能实现敏捷地卸载, 部署, 开发, 升级, 而局部的持续更迭, 是系统整体具备 Phoenix 特性的必要条件")]),t._v(".")]),t._v(" "),s("h4",{attrs:{id:"前提-微服务需要的条件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前提-微服务需要的条件"}},[t._v("#")]),t._v(" 前提: 微服务需要的条件")]),t._v(" "),s("p",[t._v("下一件要弄明白的事情就是, "),s("strong",[t._v("什么情况下可以开始微服务化")]),t._v(", 或者说, "),s("strong",[t._v("开始微服务时需要哪些前提条件")]),t._v("? 笔者认为微服务的前提条件首要还是解决"),s("strong",[t._v("非技术方面")]),t._v("的问题, 准确地说是人的问题. 分布式不是一项纯粹的技术性工作, 如果"),s("strong",[t._v("不能满足以下条件, 就应该尽量避免采用微服务")]),t._v(".")]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("微服务化的第一个前提条件是决策者与执行者都能意识到康威定律在软件设计中的关键作用")]),t._v(".")])]),t._v(" "),s("p",[t._v("系统的架构趋同于组织的沟通结构. ---康威定律")]),t._v(" "),s("p",[t._v('康威定律尝试使用社会学的方法去解释软件研发中的问题, 其核心观点是"'),s("strong",[t._v("沟通决定设计")]),t._v('"(Communication Dictate Design), 如果技术层面紧密联系在一起的特性, 在组织层面上强行分离开来, 那结果会是'),s("strong",[t._v("沟通成本")]),t._v("的上升, 因为会产生大量跨组织的沟通; 如果技术层面本身没什么联系的特性, 在组织层面上强行安放在一块, 那结果会是"),s("strong",[t._v("管理成本")]),t._v("的上升, 因为成员越多越不利于一致决策的形成. 这些社会学, 管理学的规律决定了假如产品和组织能够经受住市场竞争, 长期发展的话, 最终都会自发地调整成组织与产品互相匹配的状态. 哪些特性在团队内部沟通, 哪些特性需要跨团队的协作, 将最终都会在产品中分别映射成与组织结构一致的应用内, 外部的调用与依赖关系.")]),t._v(" "),s("p",[t._v('尽管稍微有些工作经验的员工和管理者思考一下都能理解康威定律所描述的现象, 但是为了推进软件架构的微服务化而配合调整组织架构, 通常不是一件容易的事情. 西方有一句谚语叫作 "'),s("strong",[t._v("所有技术上的决策实际都是政治上的决策")]),t._v('"(All Technical Decisions Are Political Decisions), 这里的 "政治" 是泛指如何与其他人协作将事情搞定, "技术" 也是泛指所有战术层面行为, 并不局限于信息技术. 架构不仅仅是个技术问题, 更是一种社交活动, 甚至还可能会涉及利益的重新分配. 譬如, 产品在技术上的拆装重构相对容易, 但为了做到组织与产品对齐, 将某个组织的一部分权利, 职能和人员拆分出来, 该组织的领导是否愿意; 将两个团队合并成一个新的团队, 原有的团队负责人要如何安置等. 这些问题不仅需要执行者有良好的社交能力, 还需要更上层的决策者充分理解架构演变同步调整组织结构的必要性, 为微服务化打破局部的利益藩篱.')]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("微服务化的第二个前提条件是组织中具备一些对微服务有充分理解, 有一定实践经验的技术专家")]),t._v(".")])]),t._v(" "),s("p",[t._v("微服务对架构者是满满的恶意, 对架构能力要求已提升到史无前例的程度. 即使对微服务最乐观的支持者也无法否认它在架构方面带来了额外的复杂性. 对于开发业务逻辑的普通程序员来说, 即使代码出现缺陷也可以被快速修复升级, 甚至有可能在 Kubernetes 的帮助下自动回弹, 哪怕不能自愈, 最起码错误也会被系统自动隔离, 而不至于影响全局, 弄崩整个系统. 开发业务的普通程序员可以不去深究跟踪治理, 负载均衡, 故障隔离, 认证授权, 伸缩扩展这些系统性的问题, 它们被隐藏于软件架构的最底层, 被掩埋在"),s("strong",[t._v("基础设施")]),t._v("之下. 与此相对的另外一面, "),s("strong",[t._v("靠谱的软件架构应该要由深刻理解微服务的技术专家来设计建造, 健壮的基础设施也离不开有经验的运维专家的持续运维")]),t._v(", Kubernetes, Istio, Spring Cloud, Dubbo 等现成的开源工具能在此过程发挥很大的作用, 但它们本身也有一定的复杂性. 如果整个团队中缺乏能够在微服务架构中撑起系统主干的技术和运维专家, 强行进行微服务化并不会有任何好处, 至少收益不足以抵消复杂性增加而导致的成本. 这些技术专家不需要很多(能多当然更好), 但是必须有.")]),t._v(" "),s("p",[t._v('微服务对普通程序员友善的背后, 预示着未来的信息技术行业很可能也会出现 "阶级分层" 的现象, 由于更先进的软件架构已经允许更平庸的开发者也同样能写出可运行, 可用于生产的软件产品, 同时又对精英开发者提出更多, 更复杂的技术要求, 长此以往, 在开发者群体中会出现比现在还要明显的马太效应. 如果把整个软件业界看作一个巨大的组织, 它也应符合康威定律, 软件架构的趋势将导致开发者的分层, 从如今所有开发者都普遍被认为是 "高智商人群" 的状态, 转变为大部分工业化软件生产工人加上小部分软件设计专家的金字塔结构.')]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("微服务化的第三个前提条件是系统应具有以自治为目标的自动化与监控度量能力")]),t._v(".")])]),t._v(" "),s("p",[t._v('微服务是由大量松耦合服务互相协作构成的系统, 将自动化与监控度量作为它的建设前提是顺理成章的. Martin Fowler 在 "Microservice Prerequisites" 中提出了微服务系统的三个技术前提都跟自动化与监控度量有关, 具体如下所示.')]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("环境预置")]),t._v("(Rapid Provisioning): 即使不依赖云计算数据中心的支持, 也有能力在短时间(原文是几个小时, 如今 Kubernetes 重启一个 Pod 只需要数秒到数十秒)内迅速启动一台新的服务器.")]),t._v(" "),s("li",[s("strong",[t._v("基础监控")]),t._v("(Basic Monitoring): 监控体系有能力迅速捕捉到系统中出现的技术问题(如异常, 服务可用性变化)和业务问题(如订单交易量下降).")]),t._v(" "),s("li",[s("strong",[t._v("快速部署")]),t._v("(Rapid Deployment): 有能力通过全自动化的部署管道, 将服务的变更迅速部署到测试或生产环境中.")])]),t._v(" "),s("p",[t._v('请注意 Martin Fowler 撰写这篇文章的时间是 2014 年, 当时 Kubernetes 都还没有从闭源的 Borg 中诞生, 虚拟化, 自动化技术还是比较初级的水平. 近年来, 许多公司都构建起了 DevOps 文化, 虚拟化与开发运维自动化有了长足发展, 2014 年要专门强调的"前提条件"对今天的系统来说算不上什么困难. 在这里笔者更希望强调的重点是"'),s("strong",[t._v("以自治为目标")]),t._v('", 因为如果不是朝这个方向去努力的话, 自动化最终会导向一个套娃式的悖论: 即使所有运维都实现了自动化, 同时有一个监控系统来随时恢复出现故障的服务, 但是这个监控系统本身也需要被监控. 如果启用另一个监控系统, 同样这个监控系统也需要被监控. 最终, 不论自动化实现了多少层, 顶层仍然必须是人, 只有人能确保整体运维的连续性, 所以永远也无法达到完全的自动化. 而且, 这些自动化与监控措施本身也会消耗资源, 也会带来更高的复杂性.')]),t._v(" "),s("p",[s("strong",[t._v("微服务自动化的最终目的是构筑可持续的生态系统")]),t._v(". 笔者用一个具体的场景加以说明: 如果将微服务比作水族馆里养的鱼, 为了维持鱼的生存, 管理员需要不断向水族馆内添加各种自动化设施, 如人工照明, 氧化剂, 水过滤器, 加热器等. 这些设施最终仍然需要人花费精力去维护, 本身就耗费了大量成本. 如果我们换一种思路, 通过种植海洋植物提供氧气, 通过藻类过滤水质, 通过放养螺类清理鱼缸等, 这样的水族馆就不再是依靠人工维护才能存在的水族馆了, 它变成了一个小型的湖泊或海洋, 理想状态下, 这里的鱼类可以不需要人的干预就能长期存活.")]),t._v(" "),s("p",[s("strong",[t._v("以生态自治为目标的自动化")]),t._v(", 并不是指要达到如此高的自动化程度之后才能开始微服务, 只要满足与系统规模及目标相匹配的自动化能力, "),s("strong",[t._v("建设微服务的不同时期, 由不同程度的人力去参与运维完全是合情合理的")]),t._v('. 退一步说, 即使在信息化水平最高的大型互联网企业中, 完全的生态自治在当前技术水平下仍然是一个过于理想化, 难以全面落地的目标, 不过, 只有朝着这个目标去发展自动化与监控度量, 才能避免 "屠龙少年" 最终变成 "恶龙", '),s("strong",[t._v("避免自动化与度量监控反过来成为人与系统的负担")]),t._v(".")]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("微服务化的第四个前提条件是复杂性已经成为制约生产力的主要矛盾")]),t._v(".")])]),t._v(" "),s("p",[t._v('前面已经阐述了一个观点: "对于小型系统, 单体架构就是最好的架构". 系统进行任何改造的根本动力都是 "'),s("strong",[t._v("这样做收益大于成本")]),t._v('". 一般情况下, 引入新技术在解决问题之前就带来复杂度的提升, 反而会导致生产力下降. 只有在业务已经发展到一定程度, 单体架构与微服务架构的生产力曲线已经到达交叉点, 此时开始进行微服务化才是有收益的.')]),t._v(" "),s("h4",{attrs:{id:"边界-微服务的粒度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#边界-微服务的粒度"}},[t._v("#")]),t._v(" 边界: 微服务的粒度")]),t._v(" "),s("p",[t._v('当今软件业界, 对本节的话题 "'),s("strong",[t._v("识别微服务的边界")]),t._v('" 其实已取得了较为一致的观点, 也找到了指导具体实践的方法论, 即'),s("strong",[t._v("领域驱动设计")]),t._v("(Domain-Driven Design, DDD). 囿于主题, 在本书中甚少涉及该如何抽象业务, 分析流程, 识别边界, 建立模型, 映射到服务和代码等偏重理论的务虚话题, 即使在这一章中, 笔者也尽量规避了 DDD 中需要专门学习才能理解的概念, 如界限上下文(Bounded Context), 语境映射(Context Map), 通用语言(Ubiquitous Language), 领域和子域(Domain, Sub Domain), 聚合(Aggregate), 领域事件(Domain Event)等. 并非笔者认为业务流程与设计方法论不重要, 而是如果要严谨, 深刻地讨论这些话题, 其篇幅足以独立地写出一本书. 事实上, 市场上已经有不少这样的书了, DDD 的发明人 Eric Evans 撰写的同名图书---《"),s("strong",[t._v("领域驱动设计: 软件核心复杂性应对之道")]),t._v("》便是其中翘楚. 笔者个人是更推荐 Chris Richardson 撰写的颇具口碑的入门书---《"),s("strong",[t._v("微服务架构设计模式")]),t._v("》, 其叙述的主线就是在 DDD 指导下, 如何"),s("strong",[t._v("将一个单体服务逐步拆分为微服务结构")]),t._v(". 在本节, 笔者会从业务之外的其他角度, 从"),s("strong",[t._v("非功能性, 研发效率")]),t._v("等方面来探讨微服务的粒度与拆分.")]),t._v(" "),s("p",[t._v("系统设计是一种创作, 而不是应试, 不可能每一位架构师设计的服务粒度全都相同, 微服务的大小, 边界不应该只有唯一正确的答案或绝对的标准, 但是应该有个"),s("strong",[t._v("合理的范围")]),t._v(", 笔者称其为"),s("strong",[t._v("微服务粒度的上下界")]),t._v(". 可以通过分析如果微服务的粒度太小或者太大会出现哪些问题, 从而得出服务上下界应该定在哪里.")]),t._v(" "),s("p",[t._v('可能是受微服务名字中"微"的"蛊惑", 笔者听过不少人提倡微服务越小越好, 最好做到一个 REST Endpoint 对应一个微服务, 这种极端的理解肯定是错误的, '),s("strong",[t._v("如果将微服务粒度设计得过细")]),t._v(", 会受到以下几个方面的反噬.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("从性能角度看")]),t._v(', 一次进程内的方法调用(仅计算调用, 与方法具体内容无关), 耗时在零(按方法完全内联的场景来计算)到数百个时钟周期(按最慢的虚方法调用无内联缓存要查虚表的场景来计算)之间; 一次跨服务的方法调用里, 网络传输, 参数序列化和结果反序列化都是不可避免的, 耗时要达到毫秒级别, 可以算一下这两者有多少个数量级的差距. 远程服务调用里已经解释了 "透明的分布式通信" 是不存在的, 因此, '),s("strong",[t._v("服务粒度大小必须考虑到消耗在网络上的时间与方法本身执行时间的比例, 避免设计得过于琐碎, 客户端不得不多次调用服务才能完成一项业务操作")]),t._v(", 譬如, 将字符串处理这样的功能设计为一个微服务便是不合适的. 这点要求从功能设计上看微服务应该是完备的.")]),t._v(" "),s("li",[s("strong",[t._v("从数据一致性角度看")]),t._v(", 每个微服务都有自己独立的数据源, 如果多个微服务要协同工作, 可以采用很多办法来保证它们处理数据的最终一致性, 但"),s("strong",[t._v("如果某些数据必须要求保证强一致性的话, 那它们本身就应当聚合在同一个微服务中")]),t._v(", 而不是强行启用 XA 事务来实现, 因为参与协作的微服务越多, XA 事务的可用性就越差. 这点要求从数据一致性上看微服务应该是"),s("strong",[t._v("内聚")]),t._v("(Cohesion)的.")]),t._v(" "),s("li",[s("strong",[t._v("从服务可用性角度看")]),t._v(", 服务之间是"),s("strong",[t._v("松散耦合的依赖关系")]),t._v(", 微服务架构中无法也不应该假设被调用的服务具有绝对的可用性, 服务可能因为网络分区, 软件重启升级, 硬件故障等任何原因发生中断. "),s("strong",[t._v('如果两个微服务都必须依赖对方可用才能正常工作, 那就应当将其合并到同一个微服务中(注意这里说的是"彼此依赖对方才能工作", 单向的依赖是必定存在的)')]),t._v(" . 这点要求从依赖关系上看微服务应该是独立的.")])]),t._v(" "),s("p",[t._v("综上可以得出第一个结论: "),s("strong",[t._v("微服务粒度的下界是它至少应满足独立——能够独立发布, 独立部署, 独立运行与独立测试, 内聚---强相关的功能与数据在同一个服务中处理, 完备---一个服务包含至少一项业务实体与对应的完整操作")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("如果微服务的粒度太大")]),t._v(', 会出现什么问题? 从技术角度讲, 并不会有什么问题, 每个能正常工作的单体系统都能满足独立, 内聚, 完备的要求. 微服务的上界并非受限于技术, 而是受限于人, 更准确地说, 受限于人与人之间的社交协作. 《人月神话》中最反直觉的一个结论是: "为进度给项目增加人力, 如同用水去为油锅灭火"(Adding Manpower to A Late Software Project Makes It Later). 为什么? Fred Brooks 给出了简洁而有力的答案:')]),t._v(" "),s("blockquote",[s("p",[t._v("软件项目中的沟通成本 = n × (n – 1) / 2, n 为参与项目的人数")])]),t._v(" "),s("p",[t._v('有了以上铺垫, 你应该更能理解前面许多文章中笔者为何采用 "2 Pizza Team" 作为微服务团队规模的 "量词" 了, 这符合软件开发中团队管理的理想规模.')]),t._v(" "),s("p",[s("strong",[t._v("康威定律约束了软件的架构与组织的架构要保持一致")]),t._v(", 所以微服务的上界应该与 2 Pizza Team 能够开发的最大程序规模保持一致. 那么, 2 Pizza Team 能开发多大规模的程序呢? 在人员数量固定的前提下, 这个答案不仅与开发者的"),s("strong",[t._v("能力水平相关, 更是与研发模式和周期")]),t._v("相关. 如果软件产品采用瀑布开发模式, 可能需要一个月, 两个月迭代一次; 如果采用 "),s("strong",[t._v("Scrum")]),t._v(" 模式, 可能会一周, 两周完成一次冲刺; 如果追求日构建, 精益, 甚至可能一天, 两天就会集成构建出一个小版本, 以上不同的研发方法, 都会产生相应规模的上界.")]),t._v(" "),s("p",[t._v("综上得出了第二个结论: "),s("strong",[t._v("微服务粒度的上界是一个 2 Pizza Team 能够在一个研发周期内完成的全部需求范围")]),t._v(".")]),t._v(" "),s("p",[t._v("在上下界范围内, 架构师会根据业务和团队的实际情况来灵活划定微服务的具体粒度. 譬如"),s("strong",[t._v("下界的完备性要求微服务至少包含一项完整的业务")]),t._v(", 在不超过上界的前提下, 要判断这个微服务包含两项, 三项业务操作是否合理, 需要根据这些操作本身是否有合理的逻辑关系来具体讨论. 又譬如上界要求单个研发周期内处理掉一个微服务的全部需求, 在不超过下界的前提下, 一个周期就能完成属于两个, 三个微服务的全部需求时, 是缩短研发周期更合理, 还是允许这个周期内同时开发几个微服务更合理, 也可以根据实际情况具体讨论.")]),t._v(" "),s("h4",{attrs:{id:"治理-理解系统复杂性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#治理-理解系统复杂性"}},[t._v("#")]),t._v(" 治理: 理解系统复杂性")]),t._v(" "),s("p",[t._v("本章的字里行间都有意无意地流露出微服务架构是复杂的, 反复提醒读者三思而后行, 慎重决策, 却还没有解释"),s("strong",[t._v("复杂性具体是指什么, 微服务到底有多么复杂, 能不能量化, 有没有解决的办法")]),t._v(". 对于最后这个问题, 笔者其实并不能给出具体的解决复杂性的方法, 在软件研发中估计永远无法找到. 这节笔者将重点分析前三个问题, 正确理解软件的复杂性, 日后实际解决问题时方能有的放矢.")]),t._v(" "),s("p",[t._v("治理就是让产品能够符合预期地稳定运行, 并能够持续保持在一定的质量水平上.")]),t._v(" "),s("p",[t._v('软件业的确经常会使用到 "治理" 这个词, 听着高级, 用着也贴切, 譬如系统治理, 业务治理, 流程治理, 服务治理, 等等. 这个词的'),s("strong",[t._v("确切含义是让产品(系统, 业务, 流程, 服务)能够符合预期地稳定运行, 并能够持续保持在一定的质量水平上")]),t._v('. 该定义把治理具体分解为 "'),s("strong",[t._v("正确执行")]),t._v('"(让软件符合预期地运行)和 "'),s("strong",[t._v("持续保持")]),t._v('"(让软件持续保持一定质量水平地运行)两个层次的要求, 笔者也会分别从静态与发展两种角度解释'),s("strong",[t._v("治理与复杂性的关系")]),t._v(".")]),t._v(" "),s("h5",{attrs:{id:"_1-静态的治理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-静态的治理"}},[t._v("#")]),t._v(" 1.静态的治理")]),t._v(" "),s("p",[t._v('要求一个信息系统能够符合预期地运行, 这听起来无论如何不算什么 "高标准". 不过, 当复杂性高到一定程度的时候, 能达到正常运行确实就已经离不开治理了. 复杂是相对于人而言的, 是一个主观标准, 每个人都可以有不同的裁量. 基于大型软件都是由开发人员互相协作完成的这个基本出发点, 笔者用以下两个心理学概念来解释复杂性的来源.')]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("复杂性来自认知负荷")]),t._v("(Cognitive Load): 在软件研发中表现为人接受业务, 概念, 模型, 设计, 接口, 代码等信息所带来的负担大小. 系统中个体的认知负担越大, 系统就越复杂.")]),t._v(" "),s("li",[s("strong",[t._v("复杂性来自协作成本")]),t._v("(Collaboration Cost): 在软件研发中表现为团队共同研发时付出的沟通, 管理成本. 系统个体间协作的成本越高, 系统就越复杂.")])]),t._v(" "),s("p",[t._v("根据这两个概念, 可以进一步量化地推导出前文已经使用过的一个结论: "),s("strong",[t._v("软件规模小时微服务的复杂度高于单体系统, 规模大时则相反. 这里的原因就是微服务的认知负荷较高, 但是协作成本较低")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("软件研发的协作成本, 本质上来自协作的沟通复杂度")]),t._v(". 前一节讨论微服务粒度时已经使用过 Fred Brooks 的沟通成本的公式, 沟通成本 = n × (n – 1) / 2, 可见随着规模增长, 沟通复杂度呈"),s("strong",[t._v("平方级增长")]),t._v(", 借用算法复杂度的表示方法那就是 O(N2). 在微服务架构下, 组织的拆分与产品的拆分对齐(康威定律), 微服务系统的交互分为服务内部的进程内调用和服务之间的网络调用, 组织的沟通也被拆分为团队内部的沟通与团队之间的协作, 这种"),s("strong",[t._v("分治措施")]),t._v("有利于控制沟通成本的增长速度, 此时沟通成本的复杂度, 就能缩减至经典分治算法的时间复杂度, 即 O(NlogN).")]),t._v(" "),s("p",[s("strong",[t._v("软件研发的认知负荷, 本质上来自技术的认知复杂度")]),t._v(". 每次技术进步都伴随着新知识, 新概念的诞生, 说技术进步会伴随复杂度升级也无不可. 只是微服务或者分布式系统所提倡的许多理念, 都选择偏向于机器而不是人, 有意无意地加剧了该现象. 微服务加剧认知负荷还体现在很多其他方面, 如"),s("strong",[t._v("异步通信")]),t._v("(异步比同步更难理解), "),s("strong",[t._v("粗粒度服务接口")]),t._v("(粗粒度 API 比细粒度 API 更难使用, 关于这点在 Martin Fowler 的原文中也有详细的解释), "),s("strong",[t._v("容错处理")]),t._v("(服务容错比异常更为复杂), "),s("strong",[t._v("去中心化")]),t._v('(尽管中心化设计会降低可用性, 但确实比非中心化有更高的可管理性)等. 该结果并不让人感到意外, 分布式系统早已放弃了 UNIX 所追求的"简单性是系统第一属性"的设计哲学.')]),t._v(" "),s("p",[t._v('由于认知负荷是与概念, 模型, 业务, 代码的规模呈正比关系, 这些工作都是由人来做的, 最终都能被某种比例系数放大之后反映到人员规模上, 可以认为认知负荷的复杂度是 O(k×N)(为便于讲解, 这里将复杂度刻意写成未除消系数的形式), 单体与微服务的差别是复杂度比例系数 k 的大小差别, 微服务架构的 k 要比单体架构的 k 更大. 软件研发的整体复杂度是认知负荷与协作成本两者之和, 对于单体架构是 O(k×N)+O(N2), 对于微服务架构, 整体复杂度就是 O(k×N)+O(NlogN), 由于高次项的差异, N 的规模增加时单体架构的复杂度增长更快, 这就定量地论证了 "规模小时微服务的复杂度高于单体系统, 规模大时则相反" 的观点.')]),t._v(" "),s("p",[t._v('笔者用了千余字的篇幅, 目的不是证明这个观点的正确, 很多架构师仅凭经验也能直观感受出它是正确的. 笔者的目的是想解释清楚软件研发的复杂性的来源与差距程度, 并说明微服务中分治思想对控制软件研发复杂性的价值. 假如只能用一个词来形容微服务解决问题的核心思想, 笔者给的答案就是"分治", 这既是微服务的基本特征, 也是微服务应对复杂性的手段.')]),t._v(" "),s("h5",{attrs:{id:"_2-发展的治理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-发展的治理"}},[t._v("#")]),t._v(" 2.发展的治理")]),t._v(" "),s("p",[t._v("再来看"),s("strong",[t._v("治理对动态发展方面的要求")]),t._v(', "持续保持" 是指采取某些措施, 让软件系统能够持续保持一定的质量. "持续保持" 听起来只是守成, 应该至少不比建设困难. 可是一个令人感到意外的结论是此目标其实不可能实现, 如果软件系统长期接受新的需求输入, 它的质量必然无法长期保持. 软件研发中有一个概念 "'),s("strong",[t._v("架构腐化")]),t._v('"(Architectural Decay)专门形容此现象: '),s("strong",[t._v("架构腐化只能延缓, 无法避免")]),t._v(".")]),t._v(" "),s("p",[t._v("架构腐化与生物的衰老过程很像, 原因都来自于随时间发生的微妙变化, 如果你曾经参与过多个项目或产品的研发, 应该能对以下场景有所共鸣: 在项目开始的时候, 团队会花很多时间去决策该选择什么技术体系, 哪种架构, 怎样的平台框架, 甚至具体到开发, 测试和持续集成工具. 团队选择的解决方案通常能够解决技术选型时就能预料到的那部分困难. 但真正困难的地方在于, 随着时间的流逝, "),s("strong",[t._v("团队对该项目质量的持续保持能力会逐渐下降")]),t._v(", 一方面是高级技术专家不可能持续参与软件稳定之后的迭代过程, 反过来, 如果持续绑定在同一个达到稳定之后的项目上, 也很难培养出技术专家. 老人的退出, 新人的加入使得团队总是需要理解旧代码同时完成新功能的成员, 技术专家偶尔来评审一下或救一救火, 充其量只能算临时抱佛脚; 另一方面是代码会逐渐失控, 时间长了一定会有某些并不适合放进最初设计中的需求出现, 工期紧, 任务重, 业务复杂, 代码不熟悉等都会成为欠下一笔技术债的妥协理由, 原则底线每一次被细微地突破, 都可能被破窗效应撕裂放大成触目惊心的血痕, 最终累积到每个新人到来就马上能嗅出老朽腐臭味道的程度.")]),t._v(" "),s("p",[s("strong",[t._v("架构腐化是软件动态发展中出现的问题, 任何静态的治理方案都只能延缓, 不能根治, 必须在发展中才能找到彻底解决的办法")]),t._v(". 治理架构腐化唯一有效的办法是"),s("strong",[t._v("演进式的设计")]),t._v(", 这点与生物族群的延续也很像, 流水不腐, 户枢不蠹.")]),t._v(" "),s("p",[t._v("演进式设计在之前已经提到过多次, 它是微服务中提倡的主要特征之一, 也是作为技术决策者的架构师应该具备的发展式思维. 架构师(Architect)一词是软件行业从建筑行业引进的舶来词, Arch 本身就是拱形建筑的含义. 有很多资料都把软件架构师解释为给建筑设计骨架, 绘制图纸的建筑架构师, 这其实潜藏着极大的误导. 一个复杂的软件与一栋复杂的建筑看似有可比性, 两者的演进过程却截然不同. 万丈高楼也是根据预先设计好的完整详尽的图纸准确施工而建成的, 但是任何一个大型的软件系统都绝不可能这样建造出来. 演进式设计与建筑设计的关键区别是, "),s("strong",[t._v('它不像是 "造房子", 更像是 "换房子"')]),t._v(" . 举个具体的例子你就能明白:")]),t._v(" "),s("ul",[s("li",[t._v("在校求学的你住着六人间宿舍;")]),t._v(" "),s("li",[t._v("初入职场的你搬进了单间出租屋;")]),t._v(" "),s("li",[t._v("新婚燕尔的你买下属于自己的两室一厅;")]),t._v(" "),s("li",[t._v("孩子上学时, 你换上了大户型的学区房;")]),t._v(" "),s("li",[t._v("孩子离家读书时, 你也终于走上人生巅峰, 换了一套梦想中的大别墅.")])]),t._v(" "),s("p",[t._v('对于你住进大别墅的这个过程, 后一套房子并不是前一套房子的"升级版本", 两套房子之间只有逻辑意义上的继承关系, 没有实质血源上的继承关系, 你最后的大别墅绝对不是在最初的六人间宿舍基础上添砖加瓦扩建而来的. 同理, '),s("strong",[t._v("大型软件的建设是一个不断推倒重来的演进过程")]),t._v(', 前一个版本对后一个版本的价值在于它满足了这个阶段用户的需要, 让团队成功适应了这个阶段的复杂度, 可以向下一个台阶迈进. 对于最终用户来说, 一个能在演进过程中逐步为用户提供价值的系统, 体验也要远好于一个"憋大招"的系统——哪怕这大招最终能成功憋出来, 这个道理就如下图这幅关于理想交通工具的漫画所示.')]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/evolution.1e925d7f.png",alt:"",title:"理想交通工具"}})]),t._v(" "),s("p",[t._v("笔者强调的演进式设计, 不应被过度解读成系统最终都是会腐化, 项目最终被推倒重建, 针对特定阶段的努力就没有什么作用. 静态的治理措施当然有它的价值, 我们"),s("strong",[t._v('无法避免架构腐化, 却完全有必要依靠良好的设计和治理, 为项目的质量维持一段合理的 "保质期", 让它在合理的生命周期中发挥价值')]),t._v(".")]),t._v(" "),s("p",[t._v("复杂性本身不是洪水猛兽, 无法处理的复杂性才是. 刀耕火种的封建时代无法想象机器大生产中的复杂协作, 蒸汽革命时代同样难以想象数字化社会中信息的复杂流动. 先进的生产力都伴随着更高的复杂性, 需要有与生产力符合的生产关系来匹配, 敏锐地捕捉到生产力的变化, 随时调整生产关系, 这才是架构师治理复杂性的终极方法.")]),t._v(" "),s("h3",{attrs:{id:"加餐-graalvm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#加餐-graalvm"}},[t._v("#")]),t._v(" 加餐-GraalVM")]),t._v(" "),s("h4",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),s("p",[t._v('Graal VM 被官方称为 "Universal VM" 和 "Polyglot VM", 这是一个在 HotSpot 虚拟机基础上增强而成的'),s("strong",[t._v("跨语言全栈虚拟机")]),t._v(', 可以作为 "任何语言" 的运行平台使用, 这里 "任何语言" 包括了 Java, Scala, Groovy, Kotlin 等基于 Java 虚拟机之上的语言, 还包括了 C, C++, Rust 等基于 LLVM 的语言, 同时支持其他像 JavaScript, Ruby, Python 和 R 语言等等. Graal VM 可以无额外开销地混合使用这些编程语言, 支持不同语言中混用对方的接口和对象, 也能够支持这些语言使用已经编写好的本地库文件.')]),t._v(" "),s("p",[t._v("Graal VM 的基本工作原理是"),s("strong",[t._v("将这些语言的源代码(例如 JavaScript)或源代码编译后的中间格式(例如 LLVM 字节码)通过解释器转换为能被 Graal VM 接受的中间表示")]),t._v('(Intermediate Representation, IR), 譬如设计一个解释器专门对 LLVM 输出的字节码进行转换来支持 C 和 C++ 语言, 这个过程称为 "'),s("strong",[t._v("程序特化")]),t._v('"(Specialized, 也常称为 Partial Evaluation). Graal VM 提供了 Truffle 工具集来快速构建面向一种新语言的解释器, 并用它构建了一个称为 Sulong 的高性能 LLVM 字节码解释器.')]),t._v(" "),s("p",[t._v("以更严格的角度来看, Graal VM 才是"),s("strong",[t._v("真正意义上与物理计算机相对应的高级语言虚拟机, 理由是它与物理硬件的指令集一样, 做到了只与机器特性相关而不与某种高级语言特性相关")]),t._v('. Oracle Labs 的研究总监 Thomas Wuerthinger 表示: "随着 Graal VM 1.0 的发布, 已经证明了拥有高性能的多语言虚拟机是可能的, 并且实现这个目标的最佳方式不是通过类似 Java 虚拟机和微软 CLR 那样带有语言特性的字节码". 对于一些本来就不以速度见长的语言运行环境, 由于 Graal VM 本身能够对输入的中间表示进行自动优化, 在运行时还能进行即时编译优化, 往往使用 Graal VM 实现能够获得比原生编译器更优秀的执行效率, 譬如 Graal.js 要优于 Node.js, Graal.Python 要优于 CPtyhon, TruffleRuby 要优于 Ruby MRI, FastR 要优于 R 语言等等.')]),t._v(" "),s("p",[t._v("针对 Java 而言, "),s("strong",[t._v("Graal VM 本来就是在 HotSpot 基础上诞生的, 天生就可作为一套完整的符合 Java SE 8 标准的 Java 虚拟机来使用")]),t._v(". 它和标准的 HotSpot 差异主要在即时编译器上, 其执行效率, 编译质量目前与标准版的 HotSpot 相比也是互有胜负.")]),t._v(" "),s("p",[t._v("但现在 Oracle Labs 和美国大学里面的研究院所做的最新即时编译技术的研究全部都迁移至基于 Graal VM 之上进行了, 其发展潜力令人期待. 如果 Java 语言或 HotSpot 虚拟机真的有被取代的一天, 那从现在看来 Graal VM 是希望最大的一个候选项, 这场革命很可能会在 Java 使用者没有明显感觉的情况下悄然而来, Java 世界所有的软件生态都没有发生丝毫变化, 但天下第一的位置已经悄然更迭.")]),t._v(" "),s("h4",{attrs:{id:"新一代即时编译器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#新一代即时编译器"}},[t._v("#")]),t._v(" 新一代即时编译器")]),t._v(" "),s("p",[s("strong",[t._v("对需要长时间运行的应用来说, 由于经过充分预热, 热点代码会被 HotSpot 的探测机制准确定位捕获, 并将其编译为物理硬件可直接执行的机器码, 在这类应用中 Java 的运行效率很大程度上是取决于即时编译器所输出的代码质量")]),t._v(".")]),t._v(" "),s("p",[t._v("HotSpot 虚拟机中包含有"),s("strong",[t._v("两个即时编译器")]),t._v(", 分别是编译时间较短但输出代码优化程度较低的"),s("strong",[t._v("客户端编译器(简称为 C1)")]),t._v(" 以及编译耗时长但输出代码优化质量也更高的"),s("strong",[t._v("服务端编译器(简称为 C2)")]),t._v(" , 通常它们会在"),s("strong",[t._v("分层编译机制下与解释器互相配合来共同构成 HotSpot 虚拟机的执行子系统")]),t._v("的.")]),t._v(" "),s("p",[t._v("自 JDK 10 起, HotSpot 中又加入了一个全新的即时编译器: "),s("strong",[t._v("Graal 编译器")]),t._v(", 看名字就可以联想到它是来自于前一节提到的 Graal VM. "),s("strong",[t._v("Graal 编译器是作为 C2 编译器替代者的角色登场")]),t._v('的. Graal 的编译效果短短几年间迅速追平了 C2, 甚至某些测试项中开始逐渐反超 C2 编译器. Graal 能够做比 C2 更加复杂的优化, 如 "部分逃逸分析"(Partial Escape Analysis), 也拥有比 C2 更容易使用 "激进预测性优化"(Aggressive Speculative Optimization)的策略, 支持自定义的预测性假设等等.')]),t._v(" "),s("p",[t._v('今天的 Graal 编译器尚且年幼, 还未经过足够多的实践验证, 所以仍然带着 "'),s("strong",[t._v("实验状态")]),t._v('" 的标签, 需要用开关参数去激活. Graal 编译器未来的前途可期, 作为 Java 虚拟机执行代码的最新引擎, 它的持续改进, 会同时为 HotSpot 与 Graal VM 注入更快更强的驱动力.')]),t._v(" "),s("h4",{attrs:{id:"向原生迈进"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#向原生迈进"}},[t._v("#")]),t._v(" 向原生迈进")]),t._v(" "),s("p",[t._v("对不需要长时间运行的, 或者小型化的应用而言, Java(而不是指 Java ME)天生就带有一些劣势, 这里并不光是指跑个 HelloWorld 也需要百多兆的 JRE 之类的问题, 而更重要的是指近几年从大型单体应用架构向小型微服务应用架构发展的技术潮流下, Java 表现出来的不适应.")]),t._v(" "),s("p",[t._v("在微服务架构的视角下, 应用拆分后, 单个微服务很可能就不再需要再面对数十, 数百 GB 乃至 TB 的内存, 有了高可用的服务集群, 也无须追求单个服务要 7×24 小时不可间断地运行, 它们随时可以中断和更新; 但相应地, Java 的启动时间相对较长, 需要预热才能达到最高性能等特点就显得相悖于这样的应用场景. 在无服务架构中, 矛盾则可能会更加突出, 比起服务, 一个函数的规模通常会更小, 执行时间会更短, 当前最热门的无服务运行环境 AWS Lambda 所允许的最长运行时间仅有 15 分钟.")]),t._v(" "),s("p",[t._v("一直把软件服务作为重点领域的 Java 自然不可能对此视而不见, 在最新的几个 JDK 版本的功能清单中, 已经陆续推出了跨进程的, 可以面向用户程序的类型信息共享(Application Class Data Sharing, AppCDS, 允许把加载解析后的类型信息缓存起来, 从而提升下次启动速度, 原本 CDS 只支持 Java 标准库, 在 JDK 10 时的 AppCDS 开始支持用户的程序代码), 无操作的垃圾收集器(Epsilon, 只做内存分配而不做回收的收集器, 对于运行完就退出的应用十分合适)等改善措施. 而酝酿中的一个更彻底的解决方案, 是逐步开始对提前编译(Ahead of Time Compilation, AOT)提供支持.")]),t._v(" "),s("p",[s("strong",[t._v("提前编译是相对于即时编译的概念, 提前编译能带来的最大好处是 Java 虚拟机加载这些已经预编译成二进制的库之后就能够直接调用, 而无须再等待即时编译器在运行时将其编译成二进制机器码")]),t._v('. 理论上提前编译可以减少即时编译带来的预热时间, 减少 Java 应用长期给人带来的 "第一次运行慢" 不良体验, 可以放心地进行很多全程序的分析行为, 可以使用时间压力更大的优化措施.')]),t._v(" "),s("p",[t._v('但是提前编译的坏处也很明显, 它破坏了 Java "一次编写, 到处运行" 的承诺, 必须为每个不同的硬件, 操作系统去编译对应的发行包. 也显著降低了 Java 链接过程的动态性, 必须要求加载的代码在编译期就是全部已知的, 而不能再是运行期才确定, 否则就只能舍弃掉已经提前编译好的版本, 退回到原来的即时编译执行状态.')]),t._v(" "),s("p",[t._v("早在 JDK 9 时期, Java 就提供了实验性的 Jaotc 命令来进行提前编译, 不过多数人试用过后都颇感失望, 大家原本期望的是类似于 Excelsior JET 那样的编译过后能生成本地代码完全脱离 Java 虚拟机运行的解决方案, 但 Jaotc 其实仅仅是代替掉即时编译的一部分作用而已, 仍需要运行于 HotSpot 之上.")]),t._v(" "),s("p",[t._v("直到 "),s("strong",[t._v("Substrate VM")]),t._v(" 出现, 才算是满足了人们心中对 Java 提前编译的全部期待. Substrate VM 是在 Graal VM 0.20 版本里新出现的一个极小型的运行时环境, 包括了独立的异常处理, 同步调度, 线程管理, 内存管理(垃圾收集)和 JNI 访问等组件, 目标是代替 HotSpot 用来支持提前编译后的程序执行. 它还包含了一个本地镜像的构造器(Native Image Generator)用于为用户程序建立基于 Substrate VM 的本地运行时镜像. 这个构造器采用指针分析(Points-To Analysis)技术, 从用户提供的程序入口出发, 搜索所有可达的代码. 在搜索的同时, 它还将执行初始化代码, 并在最终生成可执行文件时, 将已初始化的堆保存至一个堆快照之中. 这样一来, Substrate VM 就可以直接从目标程序开始运行, 而无须重复进行 Java 虚拟机的初始化过程. 但相应地, 原理上也决定了 Substrate VM 必须要求目标程序是完全封闭的, 即不能动态加载其他编译期不可知的代码和类库. 基于这个假设, Substrate VM 才能探索整个编译空间, 并通过静态分析推算出所有虚方法调用的目标方法.")]),t._v(" "),s("p",[t._v("Substrate VM 带来的好处是能显著降低内存占用及启动时间, 由于 HotSpot 本身就会有一定的内存消耗(通常约几十 MB), 这对最低也从几 GB 内存起步的大型单体应用来说并不算什么, 但在微服务下就是一笔不可忽视的成本. 根据 Oracle 官方给出的测试数据, 运行在 Substrate VM 上的小规模应用, 其内存占用和启动时间与运行在 HotSpot 相比有了 5 倍到 50 倍的下降, 具体结果如下图所示.")]),t._v(" "),s("p",[t._v("内存占用对比:")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://icyfenix.cn/assets/img/substrate1.f8e5fe7f.png",alt:""}}),t._v("启动时间对比")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://icyfenix.cn/assets/img/substrate2.e515ae74.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v('Substrate VM 补全了 Graal VM "Run Programs Faster Anywhere" 愿景蓝图里最后的一块拼图, 让 Graal VM 支持其他语言时不会有重量级的运行负担')]),t._v(". 譬如运行 JavaScript 代码, Node.js 的 V8 引擎执行效率非常高, 但即使是最简单的 HelloWorld, 它也要使用约 20MB 的内存, 而运行在 Substrate VM 上的 Graal.js, 跑一个 HelloWorld 则只需要 4.2MB 内存而已, 且运行速度与 V8 持平. Substrate VM 的轻量特性, 使得它十分适合于嵌入至其他系统之中, 譬如 Oracle 自家的数据库就已经开始使用这种方式支持用不同的语言代替 PL/SQL 来编写存储过程.")]),t._v(" "),s("h4",{attrs:{id:"没有虚拟机的java"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#没有虚拟机的java"}},[t._v("#")]),t._v(" 没有虚拟机的Java")]),t._v(" "),s("p",[t._v('尽管 Java 已经看清楚了在微服务时代的前进目标, 但是 Java 语言和生态在微服务, 微应用环境中的天生的劣势并不会一蹴而就地被解决, 通往这个目标的道路注定会充满荆棘; 尽管已经有了放弃 "一次编写, 到处运行", 放弃语言动态性的思想准备, 但是这些特性并不单纯是宣传口号, 它们在 Java 语言诞生之初就被植入到基因之中, 当 Graal VM 试图打破这些规则的同时, 也受到了 Java 语言和在其之上的生态的强烈反噬, 这里将其中最主要的一些困难列举如下:')]),t._v(" "),s("ul",[s("li",[s("p",[t._v("某些 Java 语言的特性, 使得 Graal VM 编译本地镜像的过程变得极为艰难. 譬如常见的反射, 除非使用安全管理器去专门进行认证许可, 否则反射机制具有在运行期动态调用几乎所有 API 接口的能力, 且具体会调用哪些接口, 在程序不会真正运行起来的编译期是无法获知的. 反射显然是 Java 不能放弃不能妥协的重要特性, 为此, 只能由程序的开发者明确地告知 Graal VM 有哪些代码可能被反射调用(通过 JSON 配置文件的形式), Graal VM 才能在编译本地程序时将它们囊括进来.")]),t._v(" "),s("div",{staticClass:"language-json line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        name"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"com.github.fenixsoft.SomeClass"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        allDeclaredConstructors"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        allPublicMethods"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        name"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"com.github.fenixsoft.AnotherClass"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        fileds"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"foo"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bar"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        methods"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            name"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"<init>"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            parameterTypes"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"char[]"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// something else ……")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br")])]),s("p",[t._v("这是一种可操作性极其低下却又无可奈何的解决方案, 即使开发者接受不厌其烦地列举出自己代码中所用到的反射 API, 但他们又如何能保证程序所引用的其他类库的反射行为都已全部被获知, 其中没有任何遗漏? 与此类似的还有另外一些语言特性, 如动态代理等. 另外, 一切非代码性质的资源, 如最典型的配置文件等, 也都必须明确加入配置中才能被 Graal VM 编译打包. 这导致了如果没有专门的工具去协助, 使用 Graal VM 编译 Java 的遗留系统即使理论可行, 实际操作也将是极度的繁琐.")])]),t._v(" "),s("li",[s("p",[t._v("大多数运行期对字节码的生成和修改操作, 在 Graal VM 看来都是无法接受的, 因为 Substrate VM 里面不再包含即时编译器和字节码执行引擎, 所以一切可能被运行的字节码, 都必须经过 AOT 编译成为原生代码. 请不要觉得运行期直接生成字节码会很罕见, 误以为导致的影响应该不算很大. 事实上, 多数实际用于生产的 Java 系统都或直接或间接, 或多或少引用了 ASM, CGLIB, Javassist 这类字节码库. 举个例子, CGLIB 是通过运行时产生字节码(生成代理类的子类)来做动态代理的, 长期以来这都是 Java 世界里进行类增强的主流形式, 因为面向接口的增强可以使用 JDK 自带的动态代理, 但对类的增强则并没有多少选择的余地. CGLIB 也是 Spring 用来做类增强的选择, 但 Graal VM 明确表示是不可能支持 CGLIB 的, 因此, 这点就必须由用户(面向接口编程), 框架(Spring 这些 DI 框架放弃 CGLIB 增强)和 Graal VM(起码得支持 JDK 的动态代理, 留条活路可走)来共同解决. 自 Spring Framework 5.2 起, @Configuration 注解中加入了一个新的 proxyBeanMethods 参数, 设置为 false 则可避免 Spring 对于非接口类型的 Bean 进行代理. 同样地, 对应在 Spring Boot 2.2 中, @SpringBootApplication 注解也增加了 proxyBeanMethods 参数, 通常采用 Graal VM 去构建的 Spring Boot 本地应用都需要设置该参数.")])]),t._v(" "),s("li",[s("p",[t._v("一切 HotSpot 虚拟机本身的内部接口, 譬如 JVMTI, JVMCI 等, 都将不复存在了——在本地镜像中, 连 HotSpot 本身都被消灭了, 这些接口自然成了无根之木. 这对使用者一侧的最大影响是再也无法进行 Java 语言层次的远程调试了, 最多只能进行汇编层次的调试. 在生产系统中一般也没有人这样做, 开发环境就没必要采用 Graal VM 编译, 这点的实际影响并不算大.")])]),t._v(" "),s("li",[s("p",[t._v("Graal VM 放弃了一部分可以妥协的语言和平台层面的特性, 譬如 Finalizer, 安全管理器, InvokeDynamic 指令和 MethodHandles, 等等, 在 Graal VM 中都被声明为不支持的, 这些妥协的内容大多倒并非全然无法解决, 主要是基于工作量性价比的原因. 能够被放弃的语言特性, 说明确实是影响范围非常小的, 所以这个对使用者来说一般是可以接受的.")])]),t._v(" "),s("li",[s("p",[t._v("...")])])]),t._v(" "),s("p",[t._v("以上, 是 Graal VM 在 Java 语言中面临的部分困难, 在整个 Java 的生态系统中, 数量庞大的第三方库才是真正最棘手的难题. 可以预料, 这些第三方库一旦脱离了 Java 虚拟机, 在原生环境中肯定会暴露出无数千奇百怪的异常行为. Graal VM 团队对此的态度非常务实, 并没有直接硬啃. 要建设可持续, 可维护的 Graal VM, 就不能为了兼容现有 JVM 生态, 做出过多的会影响性能, 优化空间和未来拓展的妥协牺牲, 为此应该也只能反过来由 Java 生态去适应 Graal VM, 这是 Graal VM 团队明确传递出对第三方库的态度.")]),t._v(" "),s("p",[t._v("为了推进 Java 生态向 Graal VM 兼容, "),s("strong",[t._v("Graal VM 主动拉拢了 Java 生态中最庞大的一个派系: Spring")]),t._v(". 从 2018 年起, 来自 Oracle 的 Graal VM 团队与来自 Pivotal 的 Spring 团队已经紧密合作了很长的一段时间, 共同创建了 Spring Graal Native 项目来解决 Spring 全家桶在 Graal VM 上的运行适配问题, 下一个大的 Spring 版本(Spring Framework 5.3, Spring Boot 2.3)的其中一项主要改进就是能够开箱即用地支持 Graal VM, 这样用于微服务环境的 Spring Cloud 便会获得不受 Java 虚拟机束缚的更广阔的舞台空间.")]),t._v(" "),s("p",[t._v("‍")]),t._v(" "),s("h3",{attrs:{id:"参考资料"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://icyfenix.cn/summary/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://icyfenix.cn/summary/"),s("OutboundLink")],1)])]),t._v(" "),s("p",[t._v("‍")])])}),[],!1,null,null,null);s.default=e.exports}}]);