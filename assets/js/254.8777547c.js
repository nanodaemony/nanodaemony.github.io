(window.webpackJsonp=window.webpackJsonp||[]).push([[254],{582:function(_,v,t){"use strict";t.r(v);var s=t(4),n=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"_4-2-3树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-3树"}},[_._v("#")]),_._v(" 4.2-3树")]),_._v(" "),v("h5",{attrs:{id:"_1-概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[_._v("#")]),_._v(" 1.概述")]),_._v(" "),v("p",[v("strong",[_._v("2-3")]),_._v(" 查找树引入了 "),v("strong",[_._v("2 节点和 3 节点")]),_._v(", 目的是为了让"),v("strong",[_._v("树平衡")]),_._v(". 一颗完美平衡的 2-3 查找树的"),v("strong",[_._v("所有空链接到根节点")]),_._v("的距离应该是"),v("strong",[_._v("相同")]),_._v("的.")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563523596755.png",alt:""}})]),_._v(" "),v("p",[_._v("2-3 树是"),v("strong",[_._v("最简单的 B 树")]),_._v("结构, 具有如下特点:")]),_._v(" "),v("ul",[v("li",[_._v("2-3 树的所有"),v("strong",[_._v("叶子节点")]),_._v("都在"),v("strong",[_._v("同一层")]),_._v(". (只要是 B 树都满足这个条件)")]),_._v(" "),v("li",[_._v("2-3 树是由"),v("strong",[_._v("二节点和三节点")]),_._v("构成的树.")]),_._v(" "),v("li",[_._v("有"),v("strong",[_._v("两个子节点")]),_._v("的节点叫"),v("strong",[_._v("二节点")]),_._v(", 二节点要么"),v("strong",[_._v("没有")]),_._v("子节点, 要么有"),v("strong",[_._v("两个")]),_._v("子节点.")]),_._v(" "),v("li",[_._v("有"),v("strong",[_._v("三个子节点")]),_._v("的节点叫"),v("strong",[_._v("三节点")]),_._v(", 三节点要么"),v("strong",[_._v("没有")]),_._v("子节点, 要么有"),v("strong",[_._v("三个")]),_._v("子节点.")]),_._v(" "),v("li",[_._v("2-3 树中结点的顺序"),v("strong",[_._v("也要满足排序树")]),_._v("的特点, 即左边的结点的值"),v("strong",[_._v("大于")]),_._v("根结点的值, 根结点的值"),v("strong",[_._v("小于")]),_._v("右结点的值.")])]),_._v(" "),v("h5",{attrs:{id:"_2-构造过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-构造过程"}},[_._v("#")]),_._v(" 2.构造过程")]),_._v(" "),v("p",[_._v("插入操作和 BST 的插入操作有很大区别, BST 的插入操作是先进行一次未命中的查找, 然后再将节点插入到对应的空链接上. 但是 2-3 查找树如果也这么做的话, 那么就会破坏了平衡性. "),v("strong",[_._v("它是将新节点插入到叶子节点上")]),_._v(".")]),_._v(" "),v("p",[_._v("根据"),v("strong",[_._v("叶子节点的类型")]),_._v("不同, 有不同的处理方式:")]),_._v(" "),v("ul",[v("li",[_._v("如果插入到 "),v("strong",[_._v("2- 节点")]),_._v("上, 那么直接将新节点和原来的节点"),v("strong",[_._v("组成 3- 节点")]),_._v("即可.")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563523611923.png",alt:""}})]),_._v(" "),v("ul",[v("li",[_._v("如果是插入到 "),v("strong",[_._v("3- 节点")]),_._v("上, 就会产生一个"),v("strong",[_._v("临时 4- 节点")]),_._v("时, 需要将 4- 节点"),v("strong",[_._v("分裂成 3- 个 2- 节点")]),_._v(", 并将"),v("strong",[_._v("中间的")]),_._v(" 2- 节点"),v("strong",[_._v("移到上层节点")]),_._v("中. 如果上移操作继续产生临时 4- 节点则一直进行"),v("strong",[_._v("分裂上移")]),_._v(", 直到不存在临时 4- 节点.")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563523626358.png",alt:""}})]),_._v(" "),v("p",[_._v("所以整个"),v("strong",[_._v("插入过程")]),_._v("中树是"),v("strong",[_._v("由下往上")]),_._v("生长的.")]),_._v(" "),v("p",[_._v("2-3 树的插入操作, 首先一定是在"),v("strong",[_._v("叶子节点")]),_._v(", 另外如果 2-3 树中已存在当前插入的 key, 则更新值,  下面就在这两点的前提下, 进行 2-3 树插入流程的分析:")]),_._v(" "),v("ul",[v("li",[_._v("如果待插入的节点只有 1 个 key, 则直接插入即可;")]),_._v(" "),v("li",[_._v("如果待插入的节点有 2 个 key, 则对节点进行分裂, 即 2 个 key 加上待插入的 key, 这 3 个 key 分裂成 1 个key 跟两个子节点, 然后将分裂之后的 3 个 key 中的父节点看作向上层插入的 key, 然后重复(1), (2)步骤, 直到满足 2-3 树的定义性质.")])]),_._v(" "),v("p",[_._v("如下图所示, 插入“7”, 而此时节点 “5” 只有一个key, 则直接插入即可, 形成节点 “"),v("strong",[_._v("5 7")]),_._v("”."),v("br"),_._v("\n​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20191225165048088.png",alt:"image-20191225165048088"}}),_._v("​")]),_._v(" "),v("p",[_._v("此时如果再插入“6”, 而节点 “5 7” 已经有 2 个 key 了, 所以需要先进行"),v("strong",[_._v("分裂")]),_._v(".")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20191225165400980.png",alt:""}})]),_._v(" "),v("p",[_._v("“5 7” 节点与新插入的 “6” 分裂之后, 如下图所示.")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20191225165509187.png",alt:""}})]),_._v(" "),v("p",[_._v("此时需要将 “6” "),v("strong",[_._v("向父节点插入")]),_._v(", 而父节点 “13 30” 又包含 2 个 key, 则需要"),v("strong",[_._v("再次分裂")]),_._v(", 即如下图所示, “13 30” 与 “6” 分裂成父节点为 “13”, 子节点为 “6” 跟 “30”.")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20191225165619226.png",alt:""}})]),_._v(" "),v("p",[_._v("再将节点 “13” 看作"),v("strong",[_._v("向父节点插入")]),_._v(", 而此时父节点 “50” 只有一个key, 则将 “13” 与 “50” 直接"),v("strong",[_._v("合并")]),_._v("即可, 如下图所示, 完成节点的插入调整.")]),_._v(" "),v("p",[_._v("​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20191225170706510.png",alt:"image-20191225170706510"}}),_._v("​")]),_._v(" "),v("h5",{attrs:{id:"_3-性质"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-性质"}},[_._v("#")]),_._v(" 3.性质")]),_._v(" "),v("p",[_._v("2-3 查找树插入操作的变换都是"),v("strong",[_._v("局部")]),_._v("的, 除了相关的节点和链接之外"),v("strong",[_._v("不必修改")]),_._v("或者检查树的其它部分, 而这些"),v("strong",[_._v("局部变换不会影响树的全局有序性和平衡性")]),_._v(".")]),_._v(" "),v("p",[_._v("2-3 查找树的查找和插入操作复杂度和插入顺序无关, 在最坏的情况下"),v("strong",[_._v("查找和插入操作")]),_._v("访问的节点必然不超过 "),v("strong",[_._v("logN")]),_._v(" 个, 含有 10 亿个节点的 2-3 查找树最多只需要访问 "),v("strong",[_._v("30 个节点")]),_._v("就能进行任意的查找和插入操作.")]),_._v(" "),v("p",[_._v("2-3 树是一棵自平衡的"),v("strong",[_._v("多路查找树")]),_._v(", 它并不是一棵二叉树, 具有如下性质:")]),_._v(" "),v("ul",[v("li",[_._v("每个节点有 "),v("strong",[_._v("1 个或 2 个 key")]),_._v(", 对应的子节点为 2 个子节点(称为 "),v("strong",[_._v("2- 结点")]),_._v(")或 3 个子节点(称为 "),v("strong",[_._v("3- 结点")]),_._v(");")]),_._v(" "),v("li",[_._v("所有"),v("strong",[_._v("叶子节点到根节点的长度一致")]),_._v(";")]),_._v(" "),v("li",[_._v("每个节点的 key 从左到右保持了"),v("strong",[_._v("从小到大的顺序")]),_._v(", 两个 key 之间的子树中所有的 key 一定大于它的父节点的左 key, 小于父节点的右 key.")])]),_._v(" "),v("p",[_._v("如下图所示.")]),_._v(" "),v("p",[_._v("​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20191225164229220.png",alt:"image-20191225164229220"}}),_._v("​")]),_._v(" "),v("p",[_._v("因为 2-3 树是一棵自平衡的多路查找树, 所以构建跟维系一棵 2-3 树, 就比二叉平衡树要"),v("strong",[_._v("复杂的多")]),_._v("了.")]),_._v(" "),v("h4",{attrs:{id:"_2-3-4树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-4树"}},[_._v("#")]),_._v(" 2-3-4树")]),_._v(" "),v("p",[_._v("2-3-4 树只是在 2-3 树的基础上进行了扩展. 2-3-4 树也是一棵自平衡的"),v("strong",[_._v("多路查找树")]),_._v(", 具有如下性质:")]),_._v(" "),v("ul",[v("li",[_._v("任一节点只能是 1 个或 2 个或 3 个 key, 对应的子节点为 2 个子节点或 3 个子节点或 4 个子节点;")]),_._v(" "),v("li",[_._v("所有"),v("strong",[_._v("叶子")]),_._v("节点到"),v("strong",[_._v("根节点的长度一致")]),_._v(";")]),_._v(" "),v("li",[_._v("每个节点的 key 从左到右保持了"),v("strong",[_._v("从小到大")]),_._v("的顺序, 两个 key 之间的子树中所有的 key 一定大于它的父节点的左 key, 小于父节点的右 key, 对于 3 个 key 的节点, 两两 key 之间也是如此.")])]),_._v(" "),v("p",[_._v("如下图所示.")]),_._v(" "),v("p",[_._v("​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20191225171218999.png",alt:"image-20191225171218999"}}),_._v("​")]),_._v(" "),v("p",[_._v("2-3-4 树插入节点跟删除节点的处理, 实际上跟 2-3 树"),v("strong",[_._v("很像")]),_._v(", 特别是插入节点, 基本上跟 2-3 树是一模一样, 只是"),v("strong",[_._v("分裂的条件由 2 个 key 变成了 3 个 key而已")]),_._v(", 即,")]),_._v(" "),v("ul",[v("li",[_._v("如果待插入的节点不是 3 个 key, 则直接插入即可;")]),_._v(" "),v("li",[_._v("如果待插入的节点有 3 个 key, 则对节点进行"),v("strong",[_._v("分裂")]),_._v(", 即 3 个 key 加上待插入的 key, 这 4 个 key 分裂成 1 个key 跟 2 个子节点, 然后将分裂之后的 4 个 key 中的父节点看作"),v("strong",[_._v("向上层插入")]),_._v("的 key, 然后重复 (1) (2) 步骤, 直到满足 2-3-4 树的定义性质.")])]),_._v(" "),v("p",[_._v("‍")])])}),[],!1,null,null,null);v.default=n.exports}}]);