(window.webpackJsonp=window.webpackJsonp||[]).push([[246],{573:function(s,_,t){"use strict";t.r(_);var v=t(4),n=Object(v.a)({},(function(){var s=this,_=s._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[_("h1",{attrs:{id:"_5-跳表skiplist"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-跳表skiplist"}},[s._v("#")]),s._v(" 5.跳表SkipList")]),s._v(" "),_("h5",{attrs:{id:"_1-基本原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本原理"}},[s._v("#")]),s._v(" 1.基本原理")]),s._v(" "),_("p",[_("strong",[s._v("跳表")]),s._v("是一种"),_("strong",[s._v("升维优化")]),s._v("的思想, 采用了"),_("strong",[s._v("空间换时间")]),s._v("的做法来提升速度, 具体是通过添加"),_("strong",[s._v("多级索引")]),s._v("实现.")]),s._v(" "),_("p",[s._v("先来看一个普通的链表结构:")]),s._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/7896890-11b7eebde1779904.png",alt:""}})]),s._v(" "),_("p",[s._v("如果需要这个链表按照 score 值进行排序, 当需要添加新的元素时需要"),_("strong",[s._v("遍历定位到插入点")]),s._v(", 这样才能保证链表有序, 而"),_("strong",[s._v("不能用高效的二分法")]),s._v(".")]),s._v(" "),_("p",[s._v("如果每相邻两个节点之间就增加一个指针, 让指针指向下一个节点, 如下图:")]),s._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/7896890-8cae2c261c950b32.png",alt:""}})]),s._v(" "),_("p",[s._v("这样所有新增的指针连成了一个"),_("strong",[s._v("新的链表")]),s._v(", 但它包含的数据却只有原来的"),_("strong",[s._v("一半")]),s._v(" (图中的为 3, 11).")]),s._v(" "),_("p",[s._v("现在查找数据时可以根据这条新的链表查找, 如果碰到比待查找数据大的节点时, 再"),_("strong",[s._v("回到原来的链表")]),s._v("中查找. 比如查找 7, 查找的路径则是沿着下图中标注出的红色指针所指向的方向进行的.")]),s._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/7896890-9c0262c7a85c120e.png",alt:""}})]),s._v(" "),_("p",[s._v("通过新增加的指针查找, 不再需要与链表上的每一个节点逐一进行比较, 这样改进之后需要比较的节点数大概只有原来的一半. 利用同样的方式可以在新产生的链表上, 继续为每两个相邻的节点增加一个指针, 从而产生"),_("strong",[s._v("第三层链表")]),s._v(":")]),s._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/7896890-22036e274bedaa5a.png",alt:""}})]),s._v(" "),_("p",[s._v("在这个新的三层链表结构中"),_("strong",[s._v("查找 13")]),s._v(", 那么沿着最上层链表首先比较的是 11, 发现 11 比 13 小, 于是就知道只需要到 11 后面继续查找, "),_("strong",[s._v("从而一下跳过了 11 前面的所有节点")]),s._v(".")]),s._v(" "),_("p",[s._v("当"),_("strong",[s._v("链表足够长")]),s._v(", 这样的多层链表结构可以"),_("strong",[s._v("跳过很多下层节点")]),s._v(", 从而加快查找的效率.")]),s._v(" "),_("p",[_("strong",[s._v("跳跃表 skiplist")]),s._v(" 就是受到这种多层链表结构的启发而设计出来的. 按照上面生成链表的方式, 上面每一层链表的节点个数, 是下面一层的节点个数的"),_("strong",[s._v("一半")]),s._v(", 这样查找过程就非常类似于一个"),_("strong",[s._v("二分查找")]),s._v(", 使得查找的时间复杂度可以降低到 "),_("strong",[s._v("O(logn)")]),s._v(".")]),s._v(" "),_("p",[s._v("但是这种方法在"),_("strong",[s._v("插入数据")]),s._v("的时候有很大的问题. 新插入一个节点之后, 就会"),_("strong",[s._v("打乱上下相邻两层链表")]),s._v("上节点个数严格的 2:1 的对应关系. 如果要"),_("strong",[s._v("维持这种对应关系")]),s._v(", 就必须把新插入的节点后面的"),_("strong",[s._v("所有节点 (也包括新插入的节点) 重新进行调整")]),s._v(", 这会让时间复杂度重新退化成 O(N). "),_("strong",[s._v("删除数据")]),s._v("也有同样的问题.")]),s._v(" "),_("p",[_("strong",[s._v("skiplist")]),s._v(" 为了避免这一问题, 它"),_("strong",[s._v("不要求")]),s._v("上下相邻两层链表之间的节点"),_("strong",[s._v("个数有严格的对应关系")]),s._v(", 而是"),_("strong",[s._v("为每个节点随机出一个层数(level)")]),s._v(". 比如一个节点随机出的层数是 3, 那么就把它链入到第 1 层到第 3 层这三层链表中. 为了表达清楚, 下图展示了如何通过一步步的插入操作从而形成一个 skiplist 的过程:")]),s._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200527144430530.png",alt:""}})]),s._v(" "),_("p",[s._v("从上面的创建和插入的过程中可以看出, "),_("strong",[s._v("每一个节点的层数(level)是随机出来的")]),s._v(", 而且新插入一个节点并"),_("strong",[s._v("不会")]),s._v("影响到其他节点的层数, 因此"),_("strong",[s._v("插入操作只需要修改节点前后的指针, 而不需要对多个节点都进行调整")]),s._v(", 这就降低了插入操作的复杂度.")]),s._v(" "),_("p",[s._v("现在假设从刚才创建的这个结构中查找 23 这个不存在的数, 那么查找路径会如下图.")]),s._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200527144457960.png",alt:""}})]),s._v(" "),_("h5",{attrs:{id:"_2-应用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-应用场景"}},[s._v("#")]),s._v(" 2.应用场景")]),s._v(" "),_("p",[_("strong",[s._v("Redis")]),s._v(" 中的 "),_("strong",[s._v("Zset 数据结构")]),s._v("的底层实现. ZSet 结构同时包含一个"),_("strong",[s._v("字典")]),s._v("和一个"),_("strong",[s._v("跳跃表")]),s._v(", 跳跃表按 score 从小到大保存所有集合元素. 字典保存着从 member 到 score 的映射. 这两种结构通过"),_("strong",[s._v("指针共享相同元素")]),s._v("的 member 和 score, 不会浪费额外内存.")])])}),[],!1,null,null,null);_.default=n.exports}}]);