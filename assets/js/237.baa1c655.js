(window.webpackJsonp=window.webpackJsonp||[]).push([[237],{565:function(r,_,t){"use strict";t.r(_);var v=t(4),e=Object(v.a)({},(function(){var r=this,_=r._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[_("h1",{attrs:{id:"_4-rocketmq"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-rocketmq"}},[r._v("#")]),r._v(" 4.RocketMQ")]),r._v(" "),_("p",[_("strong",[r._v("RocketMQ")]),r._v(" 是一个 "),_("strong",[r._v("队列模型")]),r._v(" 的消息中间件, 具有"),_("strong",[r._v("高性能, 高可靠, 高实时, 分布式")]),r._v(" 等特点. 是一个基于 Java 开发的分布式消息系统.")]),r._v(" "),_("h4",{attrs:{id:"rocketmq架构🌟"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq架构🌟"}},[r._v("#")]),r._v(" RocketMQ架构🌟")]),r._v(" "),_("h5",{attrs:{id:"_1-基本架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本架构"}},[r._v("#")]),r._v(" 1.基本架构")]),r._v(" "),_("p",[r._v("RocketMQ 架构中有四大角色 "),_("strong",[r._v("NameServer, Broker, Producer, Consumer")]),r._v(".")]),r._v(" "),_("ul",[_("li",[_("strong",[r._v("Broker")]),r._v(": 主要负责消息的"),_("strong",[r._v("存储, 投递和查询以及服务高可用保证")]),r._v(". 其实就是消息队列服务器, 生产者生产消息到 Broker, 消费者从 Broker 拉取消息并消费.")]),r._v(" "),_("li",[_("strong",[r._v("NameServer")]),r._v(": 其实也是一个 "),_("strong",[r._v("注册中心")]),r._v(", 主要提供两个功能: "),_("strong",[r._v("Broker 管理和路由信息管理")]),r._v(". Broker 会"),_("strong",[r._v("将自己的信息注册到 NameServer")]),r._v(", 此时 NameServer 就存放了很多 Broker 的信息(Broker 的路由表), "),_("strong",[r._v("消费者和生产者就从 NameServer 中获取路由表然后照着路由表的信息于对应的 Broker 进行通信")]),r._v("(生产者和消费者定期会向 NameServer 去查询相关的 Broker 的信息).")]),r._v(" "),_("li",[_("strong",[r._v("Producer")]),r._v(": "),_("strong",[r._v("消息发布")]),r._v("的角色, 就是"),_("strong",[r._v("生产者")]),r._v(", 支持分布式集群方式部署.")]),r._v(" "),_("li",[_("strong",[r._v("Consumer")]),r._v(": "),_("strong",[r._v("消息消费")]),r._v("的角色, 就是"),_("strong",[r._v("消费者")]),r._v(", 支持分布式集群方式部署. 支持以 "),_("strong",[r._v("push 推, pull 拉两种模式")]),r._v("对消息进行消费. 同时也支持集群方式和广播方式的消费, 它提供实时消息订阅机制.")])]),r._v(" "),_("p",[r._v("四个组件关系如下图所示.")]),r._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230211215719467.png",alt:""}})]),r._v(" "),_("h5",{attrs:{id:"_2-集群架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-集群架构"}},[r._v("#")]),r._v(" 2.集群架构")]),r._v(" "),_("p",[r._v("RocketMQ 生产环境下的架构比上面复杂, 因为上面的四个角色都是需要做"),_("strong",[r._v("集群")]),r._v("的.")]),r._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200728144455669.png",alt:"image-20200728144455669"}})]),r._v(" "),_("p",[r._v("集群架构与之前的架构图也没什么区别, 主要是一些细节上的差别.")]),r._v(" "),_("p",[r._v("第一, Broker 做了集群并且还进行了"),_("strong",[r._v("主从部署")]),r._v(", 由于"),_("strong",[r._v("消息分布在各个 Broker 上")]),r._v(". 一旦某个 Broker 宕机, 则该 Broker 上的消息读写都会受到影响. 所以 RocketMQ 提供了 "),_("strong",[r._v("master/slave")]),r._v(" 的结构, salve 定时从 master 同步数据(同步刷盘或者异步刷盘), 如果 master 宕机, 则 slave 提供消费服务, 但是不能写入消息.")]),r._v(" "),_("p",[r._v("第二, 为了保证 "),_("strong",[r._v("HA")]),r._v(", NameServer 也做了"),_("strong",[r._v("集群部署")]),r._v(", 但是注意它是 "),_("strong",[r._v("去中心化")]),r._v(" 的. 也就意味着"),_("strong",[r._v("它没有主节点")]),r._v(", NameServer 的所有节点是没有进行"),_("strong",[r._v("信息同步")]),r._v("的, 在 RocketMQ 中是通过单个 Broker 和"),_("strong",[r._v("所有 NameServer 保持长连接")]),r._v(", 并且在每隔 30 秒 Broker 会向所有 Nameserver "),_("strong",[r._v("发送心跳")]),r._v(", 心跳包含了自身的 Topic 配置信息, 这个步骤就对应这上面的 Routing Info.")]),r._v(" "),_("p",[r._v("第三, "),_("strong",[r._v("生产者")]),r._v("需要向 Broker "),_("strong",[r._v("发送消息")]),r._v("的时候, 需要先"),_("strong",[r._v("从 NameServer 获取关于 Broker 的路由信息")]),r._v(", 然后通过"),_("strong",[r._v("轮询")]),r._v("的方法去向每个队列中生产数据以达到"),_("strong",[r._v("负载均衡")]),r._v("的效果.")]),r._v(" "),_("p",[r._v("第四, "),_("strong",[r._v("消费者")]),r._v("通过 NameServer 获取所有 Broker 的路由信息后, 向 "),_("strong",[r._v("Broker 发送 Pull 请求")]),r._v("来获取消息数据. Consumer 可以以两种模式启动: "),_("strong",[r._v("广播")]),r._v("(Broadcast)"),_("strong",[r._v("和集群")]),r._v("(Cluster). 广播模式下, 一条消息会发送给同一个消费组中的所有消费者, 集群模式下消息只会发送给一个消费者.")]),r._v(" "),_("h4",{attrs:{id:"broker模型🌟"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#broker模型🌟"}},[r._v("#")]),r._v(" Broker模型🌟")]),r._v(" "),_("p",[r._v("Broker 就是消息服务器. 一个 Topic 中存在多个队列, 一个 Topic 分布在多个 Broker 上, 一个 Broker 可以配置多个 Topic , 它们是多对多的关系. 如果某个 Topic 消息量很大, 应该给它多配置多个"),_("strong",[r._v("队列")]),r._v("(提高并发能力), 并且尽量多分布在不同 Broker 上, 以减轻某个 Broker 的压力. Topic 消息量都比较均匀的情况下, 如果某个 broker 上的队列越多, 则该 broker 压力越大. 所以一般需要配置多个 Broker.")]),r._v(" "),_("p",[r._v("Broker 与 Topic 的关系如下所示:")]),r._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230211214523542.png",alt:""}})]),r._v(" "),_("h4",{attrs:{id:"nameserver🌟"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nameserver🌟"}},[r._v("#")]),r._v(" NameServer🌟")]),r._v(" "),_("p",[_("strong",[r._v("NameServer 干啥用的, 这不多余吗? 直接 Producer, Consumer 和 Broker 直接进行生产消息, 消费消息不就好了么?")])]),r._v(" "),_("p",[r._v("Broker 是需要保证高可用的, 如果整个系统仅仅靠着一个 Broker 来维持的话, 那么这个 Broker 的压力会很大, 所以需要使用多个 Broker 来保证 "),_("strong",[r._v("负载均衡")]),r._v(".")]),r._v(" "),_("p",[r._v("如果消费者和生产者"),_("strong",[r._v("直接")]),r._v("和多个 Broker 相连, 那么当 Broker 修改的时候必定会"),_("strong",[r._v("牵连着每个生产者和消费者")]),r._v(", 这样就会产生"),_("strong",[r._v("耦合问题")]),r._v(", 而 "),_("strong",[r._v("NameServer 注册中心")]),r._v("就是用来解决这个问题的.")]),r._v(" "),_("p",[_("strong",[r._v("RocketMQ 不使用 ZooKeeper 作为注册中心的原因, 以及自制的 NameServer 优缺点?")])]),r._v(" "),_("p",[r._v("ZooKeeper 作为支持顺序一致性的中间件, 在某些情况下, 它"),_("strong",[r._v("为了满足一致性, 会丢失一定时间内的可用性")]),r._v(", RocketMQ 需要"),_("strong",[r._v("注册中心只是为了发现组件地址")]),r._v(", 在某些情况下, RocketMQ 的注册中心"),_("strong",[r._v("可以出现数据不一致性")]),r._v(", 这同时也是 NameServer 的缺点, 因为 NameServer 集群间"),_("strong",[r._v("互不通信")]),r._v(", 它们之间的注册信息可能会不一致. 另外, 当有新的服务器加入时, NameServer 并"),_("strong",[r._v("不会立马通知")]),r._v("到 Produer, 而是由 Produer 定时去请求 NameServer 获取最新的 Broker/Consumer 信息.")]),r._v(" "),_("h4",{attrs:{id:"rocketmq消息模型🌟"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq消息模型🌟"}},[r._v("#")]),r._v(" RocketMQ消息模型🌟")]),r._v(" "),_("h5",{attrs:{id:"_1-模型概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-模型概述"}},[r._v("#")]),r._v(" 1.模型概述")]),r._v(" "),_("p",[r._v("对于"),_("strong",[r._v("主题模型")]),r._v("的实现来说"),_("strong",[r._v("每个消息中间件的底层设计都是不一样的")]),r._v(", 比如 Kafka 中的 "),_("strong",[r._v("分区")]),r._v(", RocketMQ 中的 "),_("strong",[r._v("队列")]),r._v(", RabbitMQ 中的 "),_("strong",[r._v("Exchange")]),r._v(". 可以理解为 "),_("strong",[r._v("主题模型/发布订阅模型 就是一个标准")]),r._v(", 那些中间件只不过照着这个标准去实现而已.")]),r._v(" "),_("p",[r._v("RocketQM 消息模型如下图所示.")]),r._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230211210421889.png",alt:"image-20230211210421889"}})]),r._v(" "),_("p",[r._v("下图源自 RocketMQ 官方文档.")]),r._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/mainarchi-9b036e7ff5133d050950f25838367a17.png",alt:"领域模型"}})]),r._v(" "),_("p",[r._v("整个图中有 "),_("strong",[r._v("Producer Group, Topic, Consumer Group")]),r._v(" 三个角色.")]),r._v(" "),_("ul",[_("li",[_("strong",[r._v("Producer Group 生产者组")]),r._v(": 代表某一类的生产者, 比如有多个秒杀系统作为生产者, 这多个合在一起就是一个 Producer Group 生产者组, 它们一般生产相同的消息.")]),r._v(" "),_("li",[_("strong",[r._v("Consumer Group 消费者组")]),r._v(": 代表某一类的消费者, 比如有多个短信系统作为消费者, 这多个合在一起就是一个 Consumer Group 消费者组, 它们一般消费相同的消息.")]),r._v(" "),_("li",[_("strong",[r._v("Topic 主题")]),r._v(": 代表一类"),_("strong",[r._v("消息")]),r._v(", 比如订单消息, 物流消息等.")])]),r._v(" "),_("p",[r._v("图中生产者组中的生产者会向 Topic 发送消息, 而 "),_("strong",[r._v("Topic 中存在多个队列")]),r._v(", 生产者每次生产消息之后是指定 Topic 中的某个队列发送消息的.")]),r._v(" "),_("p",[r._v("每个 Topic 中都有"),_("strong",[r._v("多个队列")]),r._v("(这里还不涉及到 Broker), 集群消费模式下, 一个消费者集群多台机器共同消费一个 Topic 的多个队列, "),_("strong",[r._v("一个队列只会被一个消费者消费")]),r._v(". 如果某个消费者挂掉, 分组内其它消费者会接替挂掉的消费者继续消费. 就像上图中 Consumer1 和 Consumer2 分别对应着两个队列, 而 Consuer3 是没有队列对应的, "),_("strong",[r._v("所以一般来讲要控制消费者组中的消费者个数和主题中队列个数相同")]),r._v(".")]),r._v(" "),_("h5",{attrs:{id:"_2-消费位置"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-消费位置"}},[r._v("#")]),r._v(" 2.消费位置")]),r._v(" "),_("p",[_("strong",[r._v("每个消费组在每个队列上维护一个消费位置 offset")]),r._v(", 因为在发布订阅模式中一般会涉及到"),_("strong",[r._v("多个消费者组")]),r._v(", 而每个"),_("strong",[r._v("消费者组在每个队列中的消费位置都是不同的")]),r._v(". 如果此时有多个消费者组, 那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要), 它仅仅是为每个消费者组维护一个"),_("strong",[r._v("消费位移(offset)")]),r._v(" , 每次消费者组消费完会返回一个成功的响应, 然后队列再把维护的消费位移加一, 这样就不会出现刚刚消费过的消息再一次被消费了.")]),r._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230211210455087.png",alt:"image-20230211210455087"}})]),r._v(" "),_("p",[r._v("所以总结来说, RocketMQ 通过使用在一个 "),_("strong",[r._v("Topic 中配置多个队列并且每个队列维护每个消费者组的消费位置")]),r._v(" 实现了主题模式/发布订阅模式.")]),r._v(" "),_("h4",{attrs:{id:"消息消费机制🌟"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消息消费机制🌟"}},[r._v("#")]),r._v(" 消息消费机制🌟")]),r._v(" "),_("h5",{attrs:{id:"_1-顺序消费"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-顺序消费"}},[r._v("#")]),r._v(" 1.顺序消费")]),r._v(" "),_("h6",{attrs:{id:"_1-普通顺序与严格顺序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-普通顺序与严格顺序"}},[r._v("#")]),r._v(" (1)普通顺序与严格顺序")]),r._v(" "),_("p",[r._v("从上面的架构中可知 RocketMQ 在 "),_("strong",[r._v("Topic 上是无序")]),r._v("的, 它只有在"),_("strong",[r._v("队列层面才是保证有序")]),r._v("的.")]),r._v(" "),_("p",[r._v("这又扯到两个概念: "),_("strong",[r._v("普通顺序")]),r._v(" 和 "),_("strong",[r._v("严格顺序")]),r._v(".")]),r._v(" "),_("ul",[_("li",[_("strong",[r._v("普通顺序")]),r._v(": 指消费者通过"),_("strong",[r._v("同一个消费队列收到的消息是有顺序的")]),r._v(", 不同消息队列收到的消息则"),_("strong",[r._v("可能是无顺序")]),r._v("的. 普通顺序消息在 Broker "),_("strong",[r._v("重启情况下不会保证消息顺序性")]),r._v(" (短暂时间).")]),r._v(" "),_("li",[_("strong",[r._v("严格顺序")]),r._v(": 指消费者收到的"),_("strong",[r._v("所有消息")]),r._v("均是有"),_("strong",[r._v("顺序")]),r._v("的. 严格顺序消息"),_("strong",[r._v("即使在异常情况下也会保证消息的顺序性")]),r._v(".")])]),r._v(" "),_("p",[r._v("但是, 严格顺序看起来虽好, 实现它可会付出巨大的代价. 如果使用严格顺序模式, Broker 集群中只要有一台机器不可用, 则整个集群都不可用. 严格顺序主要场景"),_("strong",[r._v("也就在 binlog 同步")]),r._v(".")]),r._v(" "),_("p",[r._v("一般而言 MQ 都是"),_("strong",[r._v("能容忍短暂的乱序")]),r._v(", 所以推荐使用"),_("strong",[r._v("普通顺序模式")]),r._v(".")]),r._v(" "),_("h6",{attrs:{id:"_2-保证顺序消费"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-保证顺序消费"}},[r._v("#")]),r._v(" (2)保证顺序消费")]),r._v(" "),_("p",[r._v("如果使用普通顺序模式, Producer 生产消息的时候会进行"),_("strong",[r._v("轮询")]),r._v("(取决于"),_("strong",[r._v("负载均衡策略")]),r._v(")来向同一主题的不同消息队列发送消息. 那么如果此时有几个消息分别是同一个订单的创建, 支付, 发货, 在轮询的策略下这三个消息会"),_("strong",[r._v("被发送到不同队列")]),r._v(", 因为在"),_("strong",[r._v("不同的队列此时就无法使用 RocketMQ 带来的队列有序特性来保证消息有序性")]),r._v("了.")]),r._v(" "),_("p",[r._v("要解决此问题, 只需要"),_("strong",[r._v("将同一语义下的消息放入同一个队列")]),r._v("(比如这里是同一个订单), 那就可以使用 "),_("strong",[r._v("Hash 取模法")]),r._v(" 来"),_("strong",[r._v("保证同一个订单在同一个队列")]),r._v("中就行了.")]),r._v(" "),_("h5",{attrs:{id:"_2-重复消费"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-重复消费"}},[r._v("#")]),r._v(" 2.重复消费")]),r._v(" "),_("p",[_("strong",[r._v("幂等")]),r._v(": 在编程中一个幂等操作的特点是其"),_("strong",[r._v("任意多次执行所产生的影响均与一次执行的影响相同")]),r._v(". 需要给消费者实现"),_("strong",[r._v("幂等")]),r._v(", 也就是对同一个消息的处理结果, 执行多少次都不变.")]),r._v(" "),_("p",[r._v("不过最主要的还是需要"),_("strong",[r._v("根据特定场景使用特定的解决方案")]),r._v(", 要明确消息重复消费是否是"),_("strong",[r._v("完全不能忍受还是可以忍受")]),r._v(", 然后再选择"),_("strong",[r._v("强校验和弱校验")]),r._v("的方式.")]),r._v(" "),_("p",[r._v("如何给业务实现幂等? 需要"),_("strong",[r._v("结合具体的业务")]),r._v(". 可以使用"),_("strong",[r._v("数据库插入法")]),r._v(", 基于数据库的"),_("strong",[r._v("唯一键")]),r._v("来保证"),_("strong",[r._v("重复数据")]),r._v("不会被插入多条. 也可以使用写入 "),_("strong",[r._v("Redis")]),r._v(" 来保证, 因为 Redis 的 key 和 value 就是"),_("strong",[r._v("天然支持幂等")]),r._v("的")]),r._v(" "),_("h5",{attrs:{id:"_3-消息堆积问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-消息堆积问题"}},[r._v("#")]),r._v(" 3.消息堆积问题")]),r._v(" "),_("p",[r._v("消息队列一个很重要的功能是"),_("strong",[r._v("削峰")]),r._v(", 但峰值太大可能造成导致消息堆积在队列中. 产生消息堆积的根源其实就只有两个: "),_("strong",[r._v("生产者生产太快或消费者消费太慢")]),r._v(".")]),r._v(" "),_("p",[r._v("可以从多个角度去思考解决这个问题, 当流量到峰值的时候是因为生产者生产太快, 可以使用一些"),_("strong",[r._v("限流降级")]),r._v("的方法, 当然也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增. 如果消费者"),_("strong",[r._v("消费过慢")]),r._v("的话, 可以先检查"),_("strong",[r._v("是否是消费者出现了大量的消费错误")]),r._v(", 或者判断是否出现线程卡死或者锁资源不释放等问题.")]),r._v(" "),_("p",[r._v("通常解决消息堆积问题的方法还是"),_("strong",[r._v("增加消费者实例")]),r._v(", 不过"),_("strong",[r._v("同时还需要增加每个主题的队列数量")]),r._v(", 因为 RocketMQ 中一个队列只会被一个消费者消费.")]),r._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230211210421889.png",alt:"image-20230211210421889"}})]),r._v(" "),_("h5",{attrs:{id:"_4-回溯消费"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-回溯消费"}},[r._v("#")]),r._v(" 4.回溯消费")]),r._v(" "),_("p",[r._v("回溯消费是指 Consumer "),_("strong",[r._v("已经消费成功")]),r._v("的消息, 由于业务上需求需要"),_("strong",[r._v("重新消费")]),r._v(". 在 RocketMQ 中,  Broker 在向 Consumer 投递成功消息后, "),_("strong",[r._v("消息仍然需要保留")]),r._v(". 并且重新消费一般是按照"),_("strong",[r._v("时间维度")]),r._v(", 例如由于 Consumer 系统故障, 恢复后需要重新消费 "),_("strong",[r._v("1 小时前")]),r._v("的数据, 那么 Broker 要提供一种机制, 可以按照时间维度来回退消费进度. "),_("strong",[r._v("RocketMQ 支持按照时间回溯消费, 时间维度精确到毫秒.")])]),r._v(" "),_("p",[r._v("‍")]),r._v(" "),_("h4",{attrs:{id:"参考资料"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[r._v("#")]),r._v(" 参考资料")]),r._v(" "),_("ul",[_("li",[r._v("RocketMQ 官方文档: "),_("a",{attrs:{href:"https://rocketmq.apache.org/zh/docs/",target:"_blank",rel:"noopener noreferrer"}},[r._v("https://rocketmq.apache.org/zh/docs/"),_("OutboundLink")],1)]),r._v(" "),_("li",[r._v("《RocketMQ技术内幕》: "),_("a",{attrs:{href:"https://blog.csdn.net/prestigeding/article/details/85233529",target:"_blank",rel:"noopener noreferrer"}},[r._v("https://blog.csdn.net/prestigeding/article/details/85233529"),_("OutboundLink")],1)]),r._v(" "),_("li",[r._v("关于 RocketMQ 对 MappedByteBuffer 的一点优化: "),_("a",{attrs:{href:"https://lishoubo.github.io/2017/09/27/MappedByteBuffer%E7%9A%84%E4%B8%80%E7%82%B9%E4%BC%98%E5%8C%96/",target:"_blank",rel:"noopener noreferrer"}},[r._v("https://lishoubo.github.io/2017/09/27/MappedByteBuffer%E7%9A%84%E4%B8%80%E7%82%B9%E4%BC%98%E5%8C%96/"),_("OutboundLink")],1)]),r._v(" "),_("li",[r._v("阿里中间件团队博客-十分钟入门RocketMQ: "),_("a",{attrs:{href:"http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/",target:"_blank",rel:"noopener noreferrer"}},[r._v("http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/"),_("OutboundLink")],1)]),r._v(" "),_("li",[r._v("分布式事务的种类以及 RocketMQ 支持的分布式消息: "),_("a",{attrs:{href:"https://www.infoq.cn/article/2018/08/rocketmq-4.3-release",target:"_blank",rel:"noopener noreferrer"}},[r._v("https://www.infoq.cn/article/2018/08/rocketmq-4.3-release"),_("OutboundLink")],1)]),r._v(" "),_("li",[r._v("滴滴出行基于RocketMQ构建企业级消息队列服务的实践: "),_("a",{attrs:{href:"https://yq.aliyun.com/articles/664608",target:"_blank",rel:"noopener noreferrer"}},[r._v("https://yq.aliyun.com/articles/664608"),_("OutboundLink")],1)]),r._v(" "),_("li",[r._v("基于《RocketMQ技术内幕》源码注释: "),_("a",{attrs:{href:"https://github.com/LiWenGu/awesome-rocketmq",target:"_blank",rel:"noopener noreferrer"}},[r._v("https://github.com/LiWenGu/awesome-rocketmq"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=e.exports}}]);