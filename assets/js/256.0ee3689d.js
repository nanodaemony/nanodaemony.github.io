(window.webpackJsonp=window.webpackJsonp||[]).push([[256],{584:function(_,v,s){"use strict";s.r(v);var r=s(4),t=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"_6-多路查找树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-多路查找树"}},[_._v("#")]),_._v(" 6.多路查找树")]),_._v(" "),v("h4",{attrs:{id:"多路查找树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多路查找树"}},[_._v("#")]),_._v(" 多路查找树")]),_._v(" "),v("p",[_._v("在二叉树中, 每个节点有数据项, 最多有两个子节点. 如果允许每个节点可以有更多的数据项和更多的子节点, 就是"),v("strong",[_._v("多叉树")]),_._v("(multiway tree). 2 - 3 树, 2 - 3 - 4 树就是"),v("strong",[_._v("多叉树")]),_._v(", 多叉树通过重新组织节点"),v("strong",[_._v("减少树的高度")]),_._v(", 能对二叉树进行优化.")]),_._v(" "),v("h4",{attrs:{id:"b-tree"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b-tree"}},[_._v("#")]),_._v(" B-Tree")]),_._v(" "),v("h5",{attrs:{id:"_1-概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[_._v("#")]),_._v(" 1.概述")]),_._v(" "),v("p",[_._v("B-Tree 就是常说的 "),v("strong",[_._v("B 树")]),_._v(", 一定不要读成 B 减树. B-Tree 是为"),v("strong",[_._v("磁盘")]),_._v("等外存储设备设计的一种"),v("strong",[_._v("平衡查找树")]),_._v(".")]),_._v(" "),v("p",[_._v("B 树这种数据结构常常用于实现"),v("strong",[_._v("数据库索引")]),_._v(", 因为它的"),v("strong",[_._v("查找效率")]),_._v("比较高. "),v("strong",[_._v("B 树")]),_._v("通过重新组织节点, "),v("strong",[_._v("降低树的高度")]),_._v(", 并且减少 IO 读写次数来提升效率.")]),_._v(" "),v("p",[v("strong",[_._v("文件系统")]),_._v("及数据库系统利用了"),v("strong",[_._v("磁盘预读原理")]),_._v(", 将一个节点的大小设为"),v("strong",[_._v("等于一个页")]),_._v("(页得大小通常为 4k), 这样每个节点只需要一次 I/O 就可以"),v("strong",[_._v("完全载入")]),_._v(". 将树的度 M 设置为 1024, 在 600 亿个元素中最多只需要 "),v("strong",[_._v("4 次 I/O")]),_._v(" 操作就可以读取到想要的元素, B 树广泛应用于"),v("strong",[_._v("文件存储系统以及数据库系统")]),_._v("中. 系统从磁盘读取数据到"),v("strong",[_._v("内存")]),_._v("时是以磁盘"),v("strong",[_._v("块")]),_._v("(block)为基本单位的, 位于同一个磁盘块中的数据会被一次性读取出来, 而不是需要什么取什么.")]),_._v(" "),v("p",[_._v("B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块. 为了描述 B-Tree, 首先定义一条记录为一个二元组 [key, data] , key 为记录的键值, 对应表中的"),v("strong",[_._v("主键值")]),_._v(", data 为一行记录中除主键外的"),v("strong",[_._v("数据")]),_._v(". 对于不同的记录, key 值互不相同.")]),_._v(" "),v("h5",{attrs:{id:"_2-b树特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-b树特性"}},[_._v("#")]),_._v(" 2.B树特性")]),_._v(" "),v("p",[_._v("一棵 "),v("strong",[_._v("M 阶")]),_._v("的 B-Tree 有如下特性:")]),_._v(" "),v("ol",[v("li",[_._v("每个节点"),v("strong",[_._v("最多有 M")]),_._v(" 个孩子.")]),_._v(" "),v("li",[_._v("除了根节点和叶子节点外, 其它每个节点"),v("strong",[_._v("至少")]),_._v("有 Ceil(M/2) 个孩子.")]),_._v(" "),v("li",[_._v("若根节点不是叶子节点, 则"),v("strong",[_._v("至少有 2 个")]),_._v("孩子 .")]),_._v(" "),v("li",[_._v("所有"),v("strong",[_._v("叶子节点")]),_._v("都在"),v("strong",[_._v("同一层")]),_._v(", 且不包含其它关键字信息 .")]),_._v(" "),v("li",[_._v("每个非终端节点包含 N 个关键字信息(P0, P1, … Pn,  k1, … kn) .")]),_._v(" "),v("li",[_._v("关键字的个数 N 满足: ceil(M/2)-1 <= N <= M - 1 .")]),_._v(" "),v("li",[_._v("ki(i = 1, … N)为关键字, 且关键字升序排序.")]),_._v(" "),v("li",[_._v("Pi(i = 1, … N)为指向子树根节点的指针. P(i - 1)指向的子树的所有节点关键字均小于 ki, 但都大于 k( i - 1).")])]),_._v(" "),v("p",[_._v("说明:")]),_._v(" "),v("ul",[v("li",[_._v("B 树的阶: 节点的"),v("strong",[_._v("最多子节点")]),_._v("个数. 比如 2-3 树的阶是 3, 2-3-4 树的阶是 4.")]),_._v(" "),v("li",[_._v("B- 树的搜索, 从根结点开始, 对结点内的关键字(有序)序列进行"),v("strong",[_._v("二分查找")]),_._v(", 如果命中则结束, 否则进入查询关键字所属范围的"),v("strong",[_._v("儿子结点")]),_._v("; 重复, 直到所对应的儿子指针为空, 或已经是叶子结点.")]),_._v(" "),v("li",[_._v("关键字集合分布在"),v("strong",[_._v("整颗树")]),_._v("中, 即叶子节点和非叶子节点"),v("strong",[_._v("都存放数据")]),_._v(".")]),_._v(" "),v("li",[_._v("搜索有可能在非叶子结点结束.")]),_._v(" "),v("li",[_._v("其搜索性能等价于在关键字"),v("strong",[_._v("全集内")]),_._v("做"),v("strong",[_._v("一次二分查找")]),_._v(".")])]),_._v(" "),v("h5",{attrs:{id:"_2-b-tree图示"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-b-tree图示"}},[_._v("#")]),_._v(" 2.B-Tree图示")]),_._v(" "),v("p",[_._v("B-Tree 中的每个节点根据实际情况可以包含大量的"),v("strong",[_._v("关键字信息和分支")]),_._v(", 如下图所示为一个 3 阶的 B-Tree(注: 图中的 “磁盘块” 应修改为 “"),v("strong",[_._v("页")]),_._v("”, 因为 InnoDB 存储引擎中默认每个页的大小为 "),v("strong",[_._v("16KB")]),_._v(", 而"),v("strong",[_._v("磁盘块默认为 4KB")]),_._v(", 而 B-/B+ 树"),v("strong",[_._v("一个节点应该是一个页")]),_._v("):")]),_._v(" "),v("p",[_._v("​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20191227120934661.png",alt:"image-20191227120934661"}}),_._v("​")]),_._v(" "),v("p",[_._v("每个"),v("strong",[_._v("节点")]),_._v("占用一个"),v("strong",[_._v("盘")]),_._v("块的磁盘空间, 一个节点上有两个升序排序的关键字和三个指向子树根节点的指针, 指针存储的是"),v("strong",[_._v("子节点")]),_._v("所在磁盘块的地址. 两个关键词划分成的"),v("strong",[_._v("三个范围域")]),_._v("对应三个指针指向的子树的数据的"),v("strong",[_._v("范围域")]),_._v(". 以根节点为例, 关键字为 17 和 35, P1 指针指向的子树的数据范围为小于 17, P2 指针指向的子树的数据范围为17~35, P3 指针指向的子树的数据范围为大于 35.")]),_._v(" "),v("p",[v("strong",[_._v("模拟查找关键字 29 的过程: ​")])]),_._v(" "),v("ul",[v("li",[_._v("根据根节点找到"),v("strong",[_._v("磁盘块 1")]),_._v(", 读入内存. 【磁盘 I/O 操作第 1 次】"),v("br"),_._v("\n比较关键字 29 在区间(17,35), 找到磁盘块 1 的指针 P2.")]),_._v(" "),v("li",[_._v("根据 P2 指针找到"),v("strong",[_._v("磁盘块 3")]),_._v(", 读入内存. 【磁盘 I/O 操作第 2 次】"),v("br"),_._v("\n比较关键字 29 在区间(26,30), 找到磁盘块 3 的指针 P2.")]),_._v(" "),v("li",[_._v("根据 P2 指针找到"),v("strong",[_._v("磁盘块 8")]),_._v(", 读入内存. 【磁盘 I/O 操作第 3 次】"),v("br"),_._v("\n在磁盘块 8 中的关键字列表中找到关键字 29.")])]),_._v(" "),v("p",[_._v("分析上面过程, 发现需要 3 次磁盘 I/O 操作, 和 3 次内存查找操作. 由于内存中的关键字是一个有序表结构, 可以利用"),v("strong",[_._v("二分法")]),_._v("查找提高效率. 而 "),v("strong",[_._v("3 次磁盘 I/O")]),_._v(" 操作是影响整个 B-Tree 查找效率的"),v("strong",[_._v("决定因素")]),_._v(". B-Tree 相对于 AVLTree 缩减了节点个数, 使每次磁盘 I/O 取到内存的数据都发挥了作用, 从而"),v("strong",[_._v("提高了查询效率")]),_._v(".")]),_._v(" "),v("p",[_._v("下图是另一个 B-Tree 图示.")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1569758570040.png",alt:""}})]),_._v(" "),v("p",[v("strong",[_._v("操作图示")])]),_._v(" "),v("p",[_._v("B 树的"),v("strong",[_._v("插入及平衡化")]),_._v("操作和 2-3 树很相似, 下面是往 B 树中依次插入下列数据的过程.")]),_._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token number"}},[_._v("6")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("10")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("4")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("14")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("5")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("11")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("15")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("3")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("2")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("12")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("1")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("7")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("8")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("8")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("6")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("3")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("6")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("21")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("5")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("15")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("15")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("6")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("32")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("23")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("45")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("65")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("7")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("8")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("6")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("5")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("4")]),_._v("\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])]),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/btreebuild.gif",alt:"1569758570040"}})]),_._v(" "),v("p",[v("strong",[_._v("插入或者删除元素")]),_._v("都会导致节点发生"),v("strong",[_._v("裂变反应")]),_._v(", 有时候会非常麻烦, 但正因为如此才让 B 树能够始终保持多路平衡, 这也是 B 树自身的一个优势: "),v("strong",[_._v("自平衡")]),_._v("; B 树主要应用于"),v("strong",[_._v("文件系统")]),_._v("以及部分数据库索引, 如 MongoDB; 大部分关系型数据库"),v("strong",[_._v("索引")]),_._v("其实是使用 "),v("strong",[_._v("B+ 树")]),_._v("实现.")]),_._v(" "),v("h4",{attrs:{id:"b-tree-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b-tree-2"}},[_._v("#")]),_._v(" B+Tree")]),_._v(" "),v("h5",{attrs:{id:"_1-概述-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述-2"}},[_._v("#")]),_._v(" 1.概述")]),_._v(" "),v("p",[_._v("B+ Tree 是在 B-Tree 基础上的一种"),v("strong",[_._v("优化")]),_._v(", 使其更适合实现"),v("strong",[_._v("外存储索引")]),_._v("结构, "),v("strong",[_._v("InnoDB 存储引擎就是用 B+Tree 实现其索引结构. ​")])]),_._v(" "),v("p",[_._v("从上一节中的 "),v("strong",[_._v("B-Tree")]),_._v(" 结构图中可以看到"),v("strong",[_._v("每个节点中不仅包含数据的 key 值, 还有 data 值")]),_._v(". 而每一个页的存储空间是有限的, 如果 data 数据较大时将会导致每个节点(即一个页)能存储的 key 的数量很小, 当存储的"),v("strong",[_._v("数据量很大")]),_._v("时同样会导致 B-Tree 的深度较大, 增大查询时的磁盘I/O次数, 进而影响查询效率.")]),_._v(" "),v("p",[_._v("在 "),v("strong",[_._v("B+Tree")]),_._v(" 中, 所有"),v("strong",[_._v("数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上, 而非叶子节点上只存储 key 值信息")]),_._v(", 这样可以大大"),v("strong",[_._v("加大每个节点存储的 key 值数量")]),_._v(", 降低 B+Tree 的"),v("strong",[_._v("高度")]),_._v(".")]),_._v(" "),v("p",[_._v("B+Tree 相对于 B-Tree 有几点不同:")]),_._v(" "),v("ul",[v("li",[_._v("B+Tree "),v("strong",[_._v("非叶子节点只存储键值")]),_._v("信息.")]),_._v(" "),v("li",[_._v("B+Tree 所有叶子节点之间都有一个"),v("strong",[_._v("链指针")]),_._v(".")]),_._v(" "),v("li",[_._v("B+Tree "),v("strong",[_._v("数据记录都存放在叶子节点")]),_._v("中.")])]),_._v(" "),v("p",[v("strong",[_._v("特性: ​")])]),_._v(" "),v("ol",[v("li",[_._v("有 n 棵子树的非叶子结点中含有 n 个关键字( B 树是 n - 1 个), 这些关键字"),v("strong",[_._v("不保存数据")]),_._v(", 只用来"),v("strong",[_._v("索引")]),_._v(", 所有"),v("strong",[_._v("数据都保存在叶子节点")]),_._v("(B 树是"),v("strong",[_._v("每个关键字都保存数据")]),_._v(").")]),_._v(" "),v("li",[_._v("所有的叶子结点中包含了全部关键字的信息, 及指向含这些"),v("strong",[_._v("关键字记录的指针")]),_._v(", 且叶子结点本身依关键字的大小自小而大顺序链接.")]),_._v(" "),v("li",[_._v("所有的"),v("strong",[_._v("非叶子结点")]),_._v("可以看成是"),v("strong",[_._v("索引部分")]),_._v(", 结点中仅含其子树中的最大(或最小)关键字.")]),_._v(" "),v("li",[_._v("通常在 B+ 树上有"),v("strong",[_._v("两个头指针")]),_._v(", 一个指向"),v("strong",[_._v("根结点")]),_._v(", 一个指向"),v("strong",[_._v("关键字最小的叶子结点")]),_._v(".")]),_._v(" "),v("li",[_._v("同一个数字会在不同节点中重复出现, "),v("strong",[_._v("根节点")]),_._v("的最大元素就是 B+ 树的"),v("strong",[_._v("最大元素")]),_._v(".")])]),_._v(" "),v("p",[_._v("将上一节中的 B-Tree 优化, 由于 B+Tree 的非叶子节点只存储键值信息, 假设每个磁盘块能"),v("strong",[_._v("存储 4 个键值")]),_._v("及指针信息, 则变成 B+Tree 后其结构如下图所示:")]),_._v(" "),v("p",[_._v("​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20191227121050334.png",alt:"image-20191227121050334"}}),_._v("​")]),_._v(" "),v("p",[_._v("通常在 B+Tree 上有"),v("strong",[_._v("两个头指针")]),_._v(", 一个指向"),v("strong",[_._v("根节点")]),_._v(", 另一个指向"),v("strong",[_._v("关键字最小的叶子节点")]),_._v(", 而且"),v("strong",[_._v("所有叶子节点")]),_._v("(即数据节点)之间是一种"),v("strong",[_._v("链式环结构")]),_._v(". 因此可以对 B+Tree 进行"),v("strong",[_._v("两种查找运算")]),_._v(": 一种是对于"),v("strong",[_._v("主键的范围查找和分页查找")]),_._v(", 另一种是从"),v("strong",[_._v("根节点开始进行随机查找")]),_._v(".")]),_._v(" "),v("p",[_._v("下图是 B+Tree 的另一个图示.")]),_._v(" "),v("p",[_._v("​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1569758212200.png",alt:"1569758212200"}}),_._v("​")]),_._v(" "),v("p",[_._v("说明:")]),_._v(" "),v("ul",[v("li",[_._v("B+ 树元素"),v("strong",[_._v("自底向上")]),_._v("插入.")]),_._v(" "),v("li",[_._v("B+ 树的搜索与 B 树也基本相同, "),v("strong",[_._v("区别是 B+ 树只有达到叶子结点才命中")]),_._v("(B 树可以在非叶子结点命中), 其性能也等价于在关键字全集做一次"),v("strong",[_._v("二分")]),_._v("查找.")]),_._v(" "),v("li",[_._v("所有"),v("strong",[_._v("关键字")]),_._v("都出现在"),v("strong",[_._v("叶子结点")]),_._v("的链表中(即"),v("strong",[_._v("数据只能在叶子节点")]),_._v("【也叫稠密索引】), 且链表中的关键字(数据)恰好是"),v("strong",[_._v("有序")]),_._v("的.")]),_._v(" "),v("li",[_._v("B+ 树的特点是能够"),v("strong",[_._v("保持数据稳定有序")]),_._v(", 其插入与修改拥有较稳定的对数时间复杂度.")]),_._v(" "),v("li",[v("strong",[_._v("不可能")]),_._v("在非叶子结点命中.")]),_._v(" "),v("li",[_._v("非叶子结点相当于是叶子结点的索引(稀疏索引), 叶子结点相当于是存储(关键字)数据的数据层.")]),_._v(" "),v("li",[_._v("B 树和 B+ 树各有自己的应用场景, 不能说 B+ 树完全比 B 树好, 反之亦然.")])]),_._v(" "),v("h5",{attrs:{id:"_2-b-tree与数据库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-b-tree与数据库"}},[_._v("#")]),_._v(" 2.B+Tree与数据库")]),_._v(" "),v("p",[v("strong",[_._v("B+树有一个最大的好处就是方便扫库, B树必须用中序遍历的方法按序扫库")]),_._v(", 而 B+ 树直接从"),v("strong",[_._v("叶子结点")]),_._v("挨个扫一遍即可.  "),v("strong",[_._v("B+树支持 range-query (区间查询)非常方便, 而 B 树不支持")]),_._v(". 这是数据库选用 B+ 树的最主要原因.")]),_._v(" "),v("p",[_._v("可能上面例子中只有 22 条数据记录, 看不出 B+Tree 的优点, 下面做一个推算:")]),_._v(" "),v("p",[_._v("InnoDB 存储引擎中"),v("strong",[_._v("页的大小为 16KB")]),_._v(", 一般表的"),v("strong",[_._v("主键类型")]),_._v("为 INT(占用 4 个字节)或 BIGINT(占用 8 个字节), 指针类型也一般为 4 或 8个字节, 也就是说一个"),v("strong",[_._v("页")]),_._v("(B+Tree中的一个节点)中大概存储 16KB/(8B+8B) = 1K 个"),v("strong",[_._v("键值")]),_._v("(因为是估值, 为方便计算, 这里的 K 取值为10^3^). 也就是说一个深度为 3 的 B+Tree 索引可以维护 10^3 * 10^3 * 10^3 = 10 亿条记录.")]),_._v(" "),v("p",[_._v("InnoDB 存储引擎中有**页(Page)**的概念, "),v("strong",[_._v("页是其磁盘管理的最小单位")]),_._v(". InnoDB 存储引擎中默认每个页的大小为 16KB, 可通过参数 "),v("strong",[_._v("innodb_page_size")]),_._v(" 将页的大小设置为 4K, 8K, 16K, 在 MySQL 中可通过如下命令查看页的大小:")]),_._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("mysql> show variables like 'innodb_page_size';\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])]),v("p",[_._v("而系统一个磁盘块的存储空间往往没有这么大, 因此 InnoDB 每次申请磁盘空间时都会是"),v("strong",[_._v("若干地址连续磁盘块来达到页的大小 16KB")]),_._v(". InnoDB 在把磁盘数据读入到磁盘时会以"),v("strong",[_._v("页")]),_._v("为基本单位, 在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置, 这将会"),v("strong",[_._v("减少磁盘 I/O 次数")]),_._v(", 提高查询效率.")]),_._v(" "),v("p",[_._v("实际情况中每个节点可能不能填充满, 因此在数据库中, B+Tree 的高度一般都在 "),v("strong",[_._v("2 ~ 4 层")]),_._v(". MySQL 的 InnoDB 存储引擎在设计时是将"),v("strong",[_._v("根节点常驻内存")]),_._v("的, 也就是说查找"),v("strong",[_._v("某一键值的行记录时最多只需要 1~3 次磁盘 I/O")]),_._v(" 操作.")]),_._v(" "),v("p",[_._v("数据库中的 B+Tree 索引可以分为"),v("strong",[_._v("聚集索引")]),_._v("(clustered index)和"),v("strong",[_._v("辅助索引")]),_._v("(secondary index). 上面的 B+Tree 示例图在数据库中的实现即为"),v("strong",[_._v("聚集索引")]),_._v(", 聚集索引的 B+Tree 中的"),v("strong",[_._v("叶子节点")]),_._v("存放的是"),v("strong",[_._v("整张表的行记录数据")]),_._v(". 辅助索引与聚集索引的区别在于"),v("strong",[_._v("辅助索引的叶子节点并不包含行记录的全部数据")]),_._v(", 而是"),v("strong",[_._v("存储相应行数据的聚集索引键")]),_._v(", 即主键. 当通过"),v("strong",[_._v("辅助索引")]),_._v("来查询数据时, InnoDB 存储引擎会"),v("strong",[_._v("遍历辅助索引找到主键")]),_._v(", 然后再"),v("strong",[_._v("通过主键在聚集索引")]),_._v("中找到完整的行记录数据.")]),_._v(" "),v("h4",{attrs:{id:"b-树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b-树"}},[_._v("#")]),_._v(" B*树")]),_._v(" "),v("p",[_._v("B* 树是 "),v("strong",[_._v("B+ 树")]),_._v("的变体, 在 B* 树的"),v("strong",[_._v("非根和非叶子结点")]),_._v("再增加"),v("strong",[_._v("指向兄弟")]),_._v("的指针.")]),_._v(" "),v("ul",[v("li",[_._v("B* 树定义了非叶子结点关键字个数至少为 (2/3) * M, 即块的最低使用率为 2 / 3, 而 B+ 树的块的最低使用率为B+ 树的1/2.")]),_._v(" "),v("li",[_._v("B* 树分配新结点的概率比 B+ 树要低, "),v("strong",[_._v("空间使用率更高")]),_._v(".")])]),_._v(" "),v("p",[_._v("​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1569758816037.png",alt:"1569758816037"}}),_._v("​")]),_._v(" "),v("p",[_._v("‍")])])}),[],!1,null,null,null);v.default=t.exports}}]);