(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{392:function(a,s,t){"use strict";t.r(s);var e=t(7),r=Object(e.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"_10-走进jvm🌼"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-走进jvm🌼"}},[a._v("#")]),a._v(" 10.走进JVM🌼")]),a._v(" "),s("p",[a._v("本节是《深入理解 Java 虚拟机》的第一章")]),a._v(" "),s("p",[a._v('Java 能获得如此广泛的认可, 除了它拥有一门结构严谨, 面向对象的编程语言之外, 还有许多不可忽视的优点: 它摆脱了硬件平台的束缚, 实现了 "'),s("strong",[a._v("一次编写, 到处运行")]),a._v('" 的理想; 它提供了一种相对安全的内存管理和访问机制, '),s("strong",[a._v("避免了绝大部分内存泄漏和指针越界问题")]),a._v("; 它实现了热点代码检测和运行时编译及优化, 这使得 Java 应用能随着运行时间的增长而获得更高的性能; 它有一套完善的应用程序接口, 还有无数来自商业机构和开源社区的第三方类库来帮助用户实现各种各样的功能...")]),a._v(" "),s("p",[a._v('Java 带来的这些好处, 让软件的开发效率得到了极大的提升. 作为一名 Java 程序员, 在编写程序时除了尽情发挥 Java 的各种优势外, 还会情不自禁地想去了解和思考一下 Java 技术体系中这些优秀的技术特性是如何出现及怎样实现的. 认识这些技术运行的本质, 是自己思考 "程序这样写好不好" 的必要基础与前提. 当在使用一门技术时, 不再依赖书本和他人就能得到这些问题的答案, 那才算升华到了 "不惑" 的境界.')]),a._v(" "),s("p",[a._v("本章将重点讲述 Java 技术体系所囊括的内容, 以及 Java 的历史, 现状和未来的发展趋势.")]),a._v(" "),s("h4",{attrs:{id:"java技术体系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java技术体系"}},[a._v("#")]),a._v(" Java技术体系")]),a._v(" "),s("p",[a._v("从广义上讲, Kotlin, Clojure, JRuby, Groovy 等运行于 Java 虚拟机上的编程语言及其相关的程序都属于 Java 技术体系中的一员.")]),a._v(" "),s("blockquote",[s("p",[a._v("JDK与JRE的定义")])]),a._v(" "),s("p",[a._v("可以把 "),s("strong",[a._v("Java 程序设计语言, Java 虚拟机, Java 类库这三部分统称为 JDK")]),a._v("(Java Development Kit), JDK 是用于支持 Java 程序开发的最小环境, 本书中为行文方便, "),s("strong",[a._v("在不产生歧义的地方常以 JDK 来代指整个 Java 技术体系 和 Java 虚拟机这两部分统称为 JRE")]),a._v("(Java Runtime Environment), JRE 是支持 Java 程序运行的标准环境. 图 1-2 展示了 Java 技术体系所包括的内容, 以及 JDK 和 JRE 所涵盖的范围.")]),a._v(" "),s("p",[a._v("以上是根据 Java 各个组成部分的功能来进行划分, 如果按照技术所服务的领域来划分, 或者按照技术关注的重点业务来划分的话, 那 Java 技术体系可以分为四条主要的产品线.")]),a._v(" "),s("p",[s("img",{attrs:{src:"/img/Image00002-20240302133505-f56aj0n.jpg",alt:"",title:"图1-2 Java 技术体系所包括的内容"}})]),a._v(" "),s("h4",{attrs:{id:"展望java技术的未来"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#展望java技术的未来"}},[a._v("#")]),a._v(" 展望Java技术的未来")]),a._v(" "),s("p",[a._v("今天的 Java 正处于机遇与挑战并存的时期, Java 未来能否继续壮大发展, 某种程度上取决于如何应对当下已出现的挑战, 本文将按照这个脉络来组织, 介绍现在仍处于 Oracle Labs 中的 "),s("strong",[a._v("Graal VM, Valhalla, Amber, Loom, Panama")]),a._v(" 等面向未来的研究项目.")]),a._v(" "),s("h5",{attrs:{id:"_1-无语言倾向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-无语言倾向"}},[a._v("#")]),a._v(" 1.无语言倾向")]),a._v(" "),s("p",[a._v('Java "天下第一" 的底气不在于语法多么先进好用, 而是来自它庞大的用户群和极其成熟的软件生态, 这在朝夕之间难以撼动. 大家都清楚不太可能有哪门语言能在每一个领域都尽占优势, Java 已是距离这个目标最接近的选项, 但若 "天下第一" 还要百尺竿头更进一步的话, 似乎就只能忘掉 Java 语言本身, 踏入无招胜有招的境界.')]),a._v(" "),s("p",[a._v("2018 年 4 月, Oracle Labs 新公开了一项黑科技: "),s("strong",[a._v("Graal VM")]),a._v(', 如图 1-4 所示, 从它的口号 "'),s("strong",[a._v("Run Programs Faster Anywhere")]),a._v('" 就能感觉到一颗蓬勃的野心.')]),a._v(" "),s("p",[a._v('Graal VM 被官方称为 "Universal VM" 和 "Polyglot VM", 这是一个'),s("strong",[a._v('在 HotSpot 虚拟机基础上增强而成的跨语言全栈虚拟机, 可以作为 "任何语言" 的运行平台使用')]),a._v(', 这里 "任何语言" 包括了 Java, Scala, Groovy, Kotlin 等基于 Java 虚拟机之上的语言, 还包括了 C, C++, Rust 等基于 LLVM 的语言, 同时支持其他像 JavaScript, Ruby, Python 和 R 语言等. '),s("strong",[a._v("Graal VM 可以无额外开销地混合使用这些编程语言, 支持不同语言中混用对方的接口和对象, 也能够支持这些语言使用已经编写好的本地库文件")]),a._v(".")]),a._v(" "),s("p",[s("img",{attrs:{src:"/img/Image00004-20240302133505-cwggntm.jpg",alt:"",title:"图1-4　Graal VM"}})]),a._v(" "),s("p",[s("mark",[s("strong",[a._v("Graal VM 的基本工作原理是将这些语言的源代码(例如 JavaScript)或源代码编译后的中间格式(例如 LLVM 字节码)通过解释器转换为能被 Graal VM 接受的中间表示(Intermediate Representation, IR)")])]),a._v(" , 譬如设计一个解释器专门对 LLVM 输出的字节码进行转换来支持 C 和 C++ 语言, 这个过程称为"),s("strong",[a._v("程序特化")]),a._v("(Specialized, 也常被称为 Partial Evaluation).")]),a._v(" "),s("p",[a._v("从更严格的角度来看, Graal VM 才是真正意义上"),s("strong",[a._v("与物理计算机相对应的高级语言虚拟机")]),a._v(", 理由是它与物理硬件的指令集一样, 做到了"),s("strong",[a._v("只与机器特性相关")]),a._v('而不与某种高级语言特性相关. Oracle Labs 的研究总监 Thomas Wuerthinger 在接受 InfoQ 采访时谈到: "随着 GraalVM 1.0 的发布, 我们已经证明了拥有高性能的多语言虚拟机是可能的, 并且实现这个目标的最佳方式不是通过类似 Java 虚拟机和微软 CLR 那样带有语言特性的字节码, TruffleRuby 要优于 Ruby MRI, FastR 要优于 R 语言等.')]),a._v(" "),s("p",[a._v("对 Java 而言, Graal VM 本来就是"),s("strong",[a._v("在 HotSpot 基础上诞生的")]),a._v(", 天生就可作为一套完整的符合 Java SE8 标准的 Java 虚拟机来使用. 它和标准的 HotSpot 的差异主要在"),s("strong",[a._v("即时编译器")]),a._v("上, 其执行效率, 编译质量目前与标准版的 HotSpot 相比也是互有胜负. 但现在 Oracle Labs 和美国大学里面的研究院所做的最新即时编译技术的研究全部都迁移至基于 Graal VM 之上进行了, 其发展潜力令人期待. 如果 Java 语言或者 HotSpot 虚拟机真的有被取代的一天, 那从现在看来 Graal VM 是希望最大的一个候选项, 这场革命很可能会在 Java 使用者没有明显感觉的情况下悄然而来, Java 世界所有的软件生态都没有发生丝毫变化, 但天下第一的位置已经悄然更迭.")]),a._v(" "),s("h5",{attrs:{id:"_2-新一代即时编译器graal"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-新一代即时编译器graal"}},[a._v("#")]),a._v(" 2.新一代即时编译器Graal")]),a._v(" "),s("p",[s("strong",[a._v("对需要长时间运行的应用来说, 由于经过充分预热, 热点代码会被 HotSpot 的探测机制准确定位捕获, 并将其编译为物理硬件可直接执行的机器码, 在这类应用中 Java 的运行效率很大程度上取决于即时编译器所输出的代码质量")]),a._v(".")]),a._v(" "),s("p",[a._v("HotSpot 虚拟机中含有"),s("strong",[a._v("两个即时编译器")]),a._v(", 分别是编译耗时短但输出代码优化程度较低的"),s("mark",[s("strong",[a._v("客户端编译器")])]),a._v("(简称为 C1)以及编译耗时长但输出代码优化质量也更高的"),s("mark",[s("strong",[a._v("服务端编译器")])]),a._v("(简称为 C2), 通常它们会在"),s("strong",[a._v("分层编译机制")]),a._v("下与解释器互相配合来共同构成 HotSpot 虚拟机的执行子系统(参考: 即时编译器).")]),a._v(" "),s("p",[a._v("自 JDK10 起, HotSpot 中又加入了一个全新的即时编译器: "),s("mark",[s("strong",[a._v("Graal 编译器")])]),a._v(", 看名字就可以联想到它是来自于前一节提到的 Graal VM. Graal 编译器是以 "),s("strong",[a._v("C2 编译器替代者")]),a._v('的身份登场的. C2 的历史已经非常长了, 可以追溯到 Cliff Click 大神读博士期间的作品, 这个由 C++ 写成的编译器尽管目前依然效果拔群, 但已经复杂到连 Cliff Click 本人都不愿意继续维护的程度. 而 Graal 编译器本身就是由 Java 语言写成, 实现时又刻意与 C2 采用了同一种名为 "Sea-of-Nodes" 的高级中间表示(High IR)形式, 使其能够更容易借鉴 C2 的优点. Graal 编译器比 C2 编译器晚了足足二十年面世, 有着极其充沛的后发优势, 在保持输出相近质量的编译代码的同时, 开发效率和扩展性上都要显著优于 C2 编译器, 这决定了 C2 编译器中优秀的代码优化技术可以轻易地移植到 Graal 编译器上, 但是反过来 Graal 编译器中行之有效的优化在 C2 编译器里实现起来则异常艰难. 这种情况下, Graal 的编译效果短短几年间迅速追平了 C2, 甚至某些测试项中开始逐渐反超 C2 编译器. '),s("strong",[a._v("Graal 能够做比 C2 更加复杂的优化")]),a._v(', 如 "部分逃逸分析"(Partial Escape Analysis), 也拥有比 C2更容易使用激进预测性优化(Aggressive Speculative Optimization)的策略, 支持自定义的预测性假设等.')]),a._v(" "),s("p",[a._v('今天的 Graal 编译器尚且年幼, 还未经过足够多的实践验证, 所以仍然带着 "实验状态" 的标签, 需要用开关参数去激活.')]),a._v(" "),s("p",[s("strong",[a._v("Graal 编译器未来的前途可期, 作为 Java 虚拟机执行代码的最新引擎, 它的持续改进, 会同时为 HotSpot 与 Graal VM 注入更快更强的驱动力")]),a._v(".")]),a._v(" "),s("h5",{attrs:{id:"_3-向native迈进"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-向native迈进"}},[a._v("#")]),a._v(" 3.向Native迈进")]),a._v(" "),s("p",[a._v("对不需要长时间运行的, 或者小型化的应用而言, Java(而不是指 Java ME)天生就带有一些劣势, 这里并不只是指跑个 HelloWorld 也需要百多兆的 JRE 之类的问题, 更重要的是指近几年在从大型单体应用架构向小型微服务应用架构发展的技术潮流下, Java 表现出来的不适应.")]),a._v(" "),s("p",[a._v("在微服务架构的视角下, 应用拆分后, 单个微服务很可能就不再需要面对数十, 数百 GB 乃至 TB 的内存, 有了高可用的服务集群, 也无须追求单个服务要 7×24 小时不间断地运行, 它们随时可以中断和更新; 但相应地, "),s("strong",[a._v("Java 的启动时间相对较长, 需要预热才能达到最高性能等特点就显得相悖于这样的应用场景")]),a._v(". 在无服务架构中, 矛盾则可能会更加突出, 比起服务, 一个函数的规模通常会更小, 执行时间会更短, 当前最热门的无服务运行环境 AWS Lambda 所允许的最长运行时间仅有 15 分钟.")]),a._v(" "),s("p",[a._v("一直把软件服务作为重点领域的 Java 自然不可能对此视而不见, 酝酿中的一个解决方案, 是逐步开始对"),s("strong",[a._v("提前编译")]),a._v("(Ahead of Time Compilation, AOT)提供支持. 提前编译是相对于即时编译的概念, 提前编译能带来的最大好处是 Java 虚拟机加载这些已经预编译成二进制库之后就能够直接调用, 而无须再等待即时编译器在运行时将其编译成二进制机器码. 理论上, "),s("strong",[a._v('提前编译可以减少即时编译带来的预热时间, 减少 Java 应用长期给人带来的 "第一次运行慢" 的不良体验, 可以放心地进行很多全程序的分析行为, 可以使用时间压力更大的优化措施')]),a._v(".")]),a._v(" "),s("p",[a._v('但是提前编译的坏处也很明显, 它破坏了 Java "一次编写, 到处运行" 的承诺, 必须为每个不同的硬件, 操作系统去编译对应的发行包; 也显著降低了 Java 链接过程的动态性, 必须要求加载的代码在编译期就是全部已知的, 而不能在运行期才确定, 否则就只能舍弃掉已经提前编译好的版本, 退回到原来的即时编译执行状态.')]),a._v(" "),s("p",[s("strong",[a._v("直到 Substrate VM 出现, 才算是满足了人们心中对 Java 提前编译的全部期待")]),a._v(". Substrate VM 是在 Graal VM 0.20 版本里新出现的一个极小型的运行时环境, 包括了独立的异常处理, 同步调度, 线程管理, 内存管理(垃圾收集)和 JNI 访问等组件, 目标是代替 HotSpot 用来支持提前编译后的程序执行. 它还包含了一个本地镜像的构造器(Native Image Generator), 用于为用户程序建立基于 Substrate VM 的本地运行时镜像. 这个构造器采用指针分析(Points-To Analysis)技术, 从用户提供的程序入口出发, 搜索所有可达的代码. 在搜索的同时, 它还将执行初始化代码, 并在最终生成可执行文件时, 将已初始化的堆保存至一个堆快照之中. 这样一来, Substrate VM 就可以直接从目标程序开始运行, 而无须重复进行 Java 虚拟机的初始化过程. 但相应地, 原理上也决定了 Substrate VM 必须要求目标程序是完全封闭的, 即不能动态加载其他编译器不可知的代码和类库. 基于这个假设, Substrate VM 才能探索整个编译空间, 并通过静态分析推算出所有虚方法调用的目标方法.")]),a._v(" "),s("p",[s("strong",[a._v("Substrate VM 带来的好处是能显著降低内存占用及启动时间")]),a._v(", 由于 HotSpot 本身就会有一定的内存消耗(通常约几十 MB), 这对最低也从几 GB 内存起步的大型单体应用来说并不算什么, 但在微服务下就是一笔不可忽视的成本. 根据 Oracle 官方给出的测试数据, 运行在 Substrate VM 上的小规模应用, 其内存占用和启动时间与运行在 HotSpot 上相比有 5 倍到 50 倍的下降, 具体结果如图 1-5 和图 1-6 所示.")]),a._v(" "),s("p",[s("img",{attrs:{src:"/img/Image00005-20240302133505-bikvqlm.jpg",alt:"",title:"图1-5　内存占用对比"}})]),a._v(" "),s("p",[a._v('Substrate VM 补全了 Graal VM "Run Programs Faster Anywhere" 愿景蓝图里的最后一块拼图, 让 '),s("strong",[a._v("Graal VM 支持其他语言时不会有重量级的运行负担")]),a._v(". 譬如运行 JavaScript 代码, Node.js 的 V8 引擎执行效率非常高, 但即使是最简单的 HelloWorld, 它也要使用约 20MB 的内存, 而运行在 Substrate VM 上的 Graal.js, 跑一个 HelloWorld 则只需要 4.2MB 内存, 且运行速度与 V8 持平. Substrate VM 的轻量特性, 使得它十分适合嵌入其他系统, 譬如 Oracle 自家的数据库就已经开始使用这种方式支持用不同的语言代替 PL/SQL 来编写存储过程.")]),a._v(" "),s("p",[s("img",{attrs:{src:"/img/Image00006-20240302133505-d0bawsr.jpg",alt:"",title:"图1-6　启动时间对比"}})]),a._v(" "),s("h5",{attrs:{id:"_4-灵活的胖子"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-灵活的胖子"}},[a._v("#")]),a._v(" 4.灵活的胖子")]),a._v(" "),s("p",[a._v("即使 HotSpot 最初设计时考虑得再长远, 大概也不会想到这个虚拟机将在未来的二十年内一直保持长盛不衰. 这二十年间有无数改进和功能被不断地添加到 HotSpot 的源代码上, 致使它成长为今天这样的庞然大物.")]),a._v(" "),s("p",[a._v("现在, HotSpot 虚拟机能够在编译时指定一系列特性开关, 让"),s("strong",[a._v("编译输出的 HotSpot 虚拟机可以裁剪成不同的功能")]),a._v(", 譬如支持哪些编译器, 支持哪些收集器, 是否支持 JFR, AOT, CDS, NMT 等都可以选择. 能够实现这些功能特性的组合拆分, 反映到源代码不仅仅是条件编译, 更关键的是接口与实现的分离.")]),a._v(" "),s("p",[a._v("在 JDK 9 时期, HotSpot 虚拟机开放了 Java 语言级别的编译器接口(Java Virtual Machine Compiler Interface, "),s("strong",[a._v("JVMCI")]),a._v("), 使得"),s("strong",[a._v("在 Java 虚拟机外部增加, 替换即时编译器成为可能")]),a._v(", 这个改进实现起来并不费劲, 但比起之前 JVMPI, JVMDI 和 JVMTI 却是更深层次的开放, 它为不侵入 HotSpot 代码而增加或修改 HotSpot 虚拟机的固有功能逻辑提供了可行性. Graal 编译器就是通过这个接口植入到 HotSpot 之中.")]),a._v(" "),s("p",[a._v("到了 JDK 10, HotSpot 又重构了 Java 虚拟机的垃圾收集器接口(Java Virtual Machine Compiler Interface), 统一了其内部各款垃圾收集器的公共行为. 有了这个接口, 才可能存在日后(今天尚未)某个版本中的 CMS 收集器退役, 和 JDK 12 中 Shenandoah 这样由 Oracle 以外其他厂商领导开发的垃圾收集器进入 HotSpot 中的事情. 如果未来这个接口完全开放的话, 甚至有可能会出现其他独立于 HotSpot 的垃圾收集器实现.")]),a._v(" "),s("p",[a._v("经过一系列的重构与开放, HotSpot 虚拟机逐渐从时间的侵蚀中挣脱出来, 虽然代码复杂度还在增长, 体积仍在变大, 但其架构并未老朽, 而是拥有了越来越多的"),s("strong",[a._v("开放性和扩展性")]),a._v(', 使得 HotSpot 成为一个能够联动外部功能, 能够应对各种场景, 能够学会十八般武艺的身手灵活敏捷的 "胖子".')]),a._v(" "),s("h5",{attrs:{id:"_5-语言语法的持续增强"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-语言语法的持续增强"}},[a._v("#")]),a._v(" 5.语言语法的持续增强")]),a._v(" "),s("p",[a._v("一门语言的功能, 语法是影响语言生产力和效率的重要因素, 很多语言特性和语法糖不论有没有, 程序也照样能写, 但即使只是可有可无的"),s("strong",[a._v("语法糖")]),a._v(", 也是直接影响语言使用者的幸福感程度的关键指标.")]),a._v(" "),s("p",[a._v("除语法糖以外, 语言的功能也在持续改进之中, 以下几个项目是目前比较明确的, 也是受到较多关注的功能改进计划:")]),a._v(" "),s("ul",[s("li",[a._v("Project Loom: "),s("strong",[a._v("现在的 Java 做并发处理的最小调度单位是线程, Java 线程的调度是直接由操作系统内核提供的")]),a._v("(这方面的内容可见本书第 12 章), 会有"),s("strong",[a._v("核心态, 用户态的切换开销")]),a._v(". 而很多其他语言都提供了更加轻量级的, 由软件自身进行调度的用户线程, 譬如 Golang 的 Groutine, D 语言的 Fiber 等. Loom 项目就准备提供一套与目前 Thread 类 API 非常接近的 Fiber 实现.")]),a._v(" "),s("li",[a._v("Project Valhalla: 提供"),s("strong",[a._v("值类型和基本类型的泛型支持")]),a._v(", 并提供明确的不可变类型和非引用类型的声明. 不可变类型在并发编程中能带来很多好处, 没有数据竞争风险带来了更好的性能. 一些语言(如 Scala)就有明确的不可变类型声明, 而 Java 中只能在定义类时将全部字段声明为 final 来间接实现. 基本类型的范型支持是指在泛型中引用基本数据类型不需要自动装箱和拆箱, 避免性能损耗.")]),a._v(" "),s("li",[a._v("Project Panama: 目的是"),s("strong",[a._v("消弭 Java 虚拟机与本地代码之间的界线")]),a._v(". 现在 Java 代码可以通过 JNI 来调用本地代码, 这点在与硬件交互频繁的场合尤其常用(譬如 Android). 但是 JNI 的调用方式充其量只能说是达到能用的标准而已, 使用起来仍相当烦琐, 频繁执行的性能开销也非常高昂, Panama 项目的目标就是提供更好的方式让 Java 代码与本地代码进行调用和传输数据.")])]),a._v(" "),s("p",[a._v("随着 Java 每半年更新一次的节奏, 新版本的 Java 中会出现越来越多其他语言里已有的优秀特性, 相信博采众长的 Java, 还能继续保持现在的勃勃生机相当长时间.")]),a._v(" "),s("h4",{attrs:{id:"实战-自己编译jdk"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实战-自己编译jdk"}},[a._v("#")]),a._v(" 实战:自己编译JDK")]),a._v(" "),s("p",[a._v("想要窥探 Java 虚拟机内部的实现原理, 最直接的一条路径就是"),s("strong",[a._v("编译一套自己的 JDK")]),a._v(", 阅读和跟踪调试 JDK 源码来了解 Java 技术体系的运作. Java 类库里的很多底层方法都是 Native 的, 在了解这些方法的运作过程, 或对 JDK 进行 Hack(根据需要进行定制微调)的时候, 都需要有能自行编译, 调试虚拟机代码的能力.")]),a._v(" "),s("p",[a._v("现在网络上有不少开源的 JDK 实现可以选择, 但毫无疑问 OpenJDK 是使用得最广泛的 JDK, 这里也将选择 OpenJDK 来进行这次编译实战.")]),a._v(" "),s("blockquote",[s("p",[a._v("1.获取源码")])]),a._v(" "),s("p",[a._v("编译源码之前, 要先明确 "),s("strong",[a._v("OpenJDK 和 OracleJDK 之间, OpenJDK 的各个不同版本之间存在什么联系")]),a._v(", 这有助于确定接下来编译要使用的 JDK 版本和源码分支, 也有助于理解编译出来的 JDK 与 Oracle 官方提供的 JDK 有什么差异.")]),a._v(" "),s("p",[a._v("如果拿 OpenJDK 中的源码跟对应版本的 JRL 许可证形式开放的 Sun/OracleJDK 源码互相比较的话, 会发现除了文件头的版权注释之外, 其余代码几乎都是相同的. 所以"),s("strong",[a._v("编译的 OpenJDK, 基本上可以认为性能, 功能和执行逻辑上都和官方的 OracleJDK 是一致的")]),a._v(".")]),a._v(" "),s("p",[a._v("OpenJDK 的第一个版本就是来自于当时 Sun 公司正在开发的 JDK 7. 通过图 1-8 可以比较清楚地理解不同版本分支之间的关系. 到了 JDK 10 及以后的版本, 在组织上出现了一些新变化, 此时全部开发工作统一归属到 JDK 和 JDK Updates 两条主分支上, 主分支不再带版本号, 在内部再用子分支来区分具体的 JDK 版本. OpenJDK 不同版本的源码都可以在它们的主页("),s("a",{attrs:{href:"http://openjdk.java.net/",target:"_blank",rel:"noopener noreferrer"}},[a._v("http://openjdk.java.net/"),s("OutboundLink")],1),a._v(")上找到, 在本次编译实践中选用的版本是 "),s("strong",[a._v("OpenJDK 12")]),a._v(".")]),a._v(" "),s("p",[s("img",{attrs:{src:"/img/Image00008-20240302133505-uaohoq9.jpg",alt:"",title:"图1-8　OpenJDK 版本之间的关系"}})]),a._v(" "),s("p",[a._v("建议直接在仓库中打包出源码压缩包, 再进行下载. 可以直接访问准备下载的 JDK 版本的仓库页面(譬如本例中 OpenJDK 12 的页面为 "),s("a",{attrs:{href:"https://hg.openjdk.java.net/jdk/jdk12/",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://hg.openjdk.java.net/jdk/jdk12/"),s("OutboundLink")],1),a._v('), 然后点击左边菜单中的 "Browse", 将显示如图 1-9 的源码根目录页面. 此时点击左边的 "zip" 链接即可下载当前版本打包好的源码, 到本地直接解压即可. 笔者下载的 OpenJDK 12 源码包大小为 171MB, 解压之后约为 579MB.')]),a._v(" "),s("p",[s("img",{attrs:{src:"/img/Image00009-20240302133505-68h6ch6.jpg",alt:"",title:"图1-9　JDK 12的根目录"}})]),a._v(" "),s("p",[a._v("尽量在 Linux 或者 MacOS 上构建 OpenJDK, 本篇实践中笔者将以 Ubuntu 18.04 LTS 为平台进行构建. 无论在什么平台下进行编译, 都建议读者认真阅读一遍源码中的 "),s("strong",[a._v("doc/building.html")]),a._v(" 文档, 编译过程中需要注意的细节较多. 在官方文档上要求编译 OpenJDK 至少需要 2～4GB 的内存空间(CPU 核心数越多, 需要的内存越大), 而且至少要 6～8GB 的空闲磁盘空间, 不要看 OpenJDK 源码的大小只有不到 600MB, 要完成编译, 过程中会产生大量的"),s("strong",[a._v("中间文件")]),a._v(", 会占用大量磁盘空间.")]),a._v(" "),s("blockquote",[s("p",[a._v("2.构建编译环境")])]),a._v(" "),s("p",[a._v("对于 Linux 系统, Ubuntu 里用户可以自行选择安装 "),s("strong",[a._v("GCC")]),a._v(" 或 CLang 来进行编译, 但必须确保最低的版本为 GCC 4.8 或者 CLang 3.2以上, 官方推荐使用 GCC 7.8 或者 CLang 9.1 来完成编译. 在 Ubuntu 系统上安装 GCC 的命令为:")]),a._v(" "),s("div",{staticClass:"language-ziti1 line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("sudo apt-get install build-essential\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("在编译过程中需要依赖 FreeType, CUPS 等若干第三方库, OpenJDK 全部的依赖库已在表 1-1 中列出, 可执行相应的安装命令完成安装.")]),a._v(" "),s("p",[s("strong",[a._v("表1-1　OpenJDK 编译依赖库")])]),a._v(" "),s("p",[s("img",{attrs:{src:"/img/Image00010-20240302133505-6oo8fvc.jpg",alt:""}})]),a._v(" "),s("p",[a._v("最后, 假设要编译大版本号为 N 的 JDK, 还要另外准备一个大版本号至少为 N-1 的, "),s("strong",[a._v("已经编译好的 JDK")]),a._v(", 这是因为 OpenJDK 由多个部分(HotSpot, JDK 类库, JAXWS, JAXP...)构成, 其中一部分(HotSpot)代码使用 C, C++ 编写, 而更多的代码则是使用 Java 语言来实现, 因此"),s("strong",[a._v("编译这些 Java 代码就需要用到另一个编译期可用的 JDK")]),a._v(', 官方称这个 JDK 为 "Bootstrap JDK". 编译 OpenJDK 12 时, Bootstrap JDK 必须使用 JDK 11 及之后的版本. 在 Ubuntu 中使用以下命令安装 OpenJDK 11:')]),a._v(" "),s("div",{staticClass:"language-ziti1 line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("sudo apt-get install openjdk-11-jdk\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("blockquote",[s("p",[a._v("3.进行编译")])]),a._v(" "),s("p",[a._v('需要下载的编译环境和依赖项目都齐备后, 就可以按照默认配置来开始编译了, 但通常编译 OpenJDK 的目的都不仅仅是为了得到在自己机器中诞生的编译成品, 而是带着调试, 定制化等需求, 这样就必须了解 OpenJDK 提供的编译参数才行, 这些参数可以使用 "bash configure--help" 命令查询到, 下面对它们中最有用的部分简要说明如下:')]),a._v(" "),s("ul",[s("li",[a._v("​"),s("code",[a._v("--with-debug-level=<level>")]),a._v("​: 设置编译的级别, 可选值为 release, fastdebug, slowde-bug, 越往后进行的优化措施就越少, 带的调试信息就越多. 还有一些虚拟机调试参数必须在特定模式下才可以使用. 默认值为 release.")]),a._v(" "),s("li",[a._v("​"),s("code",[a._v("--enable-debug")]),a._v("​: 等效于 --with-debug-level=fastdebug.")]),a._v(" "),s("li",[a._v("​"),s("code",[a._v("--with-native-debug-symbols=<method>")]),a._v("​: 确定调试符号信息的编译方式, 可选值为 none, internal, external, zipped.")]),a._v(" "),s("li",[a._v("​"),s("code",[a._v("--with-version-string=<string>")]),a._v("​: 设置编译 JDK 的版本号, 譬如 java-version 的输出就会显示该信息. 这个参数还有 "),s("code",[a._v("--with-version-<part>=<value>")]),a._v("​ 的形式, 其中 part 可以是 pre, opt, build, major, minor, security, patch 之一, 用于设置版本号的某一个部分.")]),a._v(" "),s("li",[a._v("​"),s("code",[a._v("--with-jvm-variants=<variant>[, <variant>...]")]),a._v("​: 编译特定模式(Variants)的 HotSpot 虚拟机, 可以多个模式并存, 可选值为 server, client, minimal, core, zero, custom.")]),a._v(" "),s("li",[a._v("​"),s("code",[a._v("--with-jvm-features=<feature>[, <feature>...]")]),a._v("​: 针对 --with-jvm-variants=custom 时的自定义虚拟机特性列表(Features), 可以多个特性并存, 由于可选值较多, 请参见 help 命令输出.")]),a._v(" "),s("li",[a._v("​"),s("code",[a._v("--with-<lib>=<path>")]),a._v("​: 用于指明依赖包的具体路径, 通常使用在安装了多个不同版本的 Bootstrap JDK 和依赖包的情况. 其中 lib 的可选值包括 boot-jd, freetype, cups, x, alsa, libffi, jtreg, libjpeg, giflib, libpng, lcms, zlib.")]),a._v(" "),s("li",[a._v("​"),s("code",[a._v("--with-extra-<flagtype>=<flags>")]),a._v("​: 用于设定 C, C++ 和 Java 代码编译时的额外编译器参数, 其中 flagtype 可选值为 cflags, cxxflags, ldflags, 分别代表 C, C++ 和 Java 代码的参数.")]),a._v(" "),s("li",[a._v("​"),s("code",[a._v("--with-conf-name=<name>")]),a._v('​: 指定编译配置名称, OpenJDK 支持使用不同的配置进行编译, 默认会根据编译的操作系统, 指令集架构, 调试级别自动生成一个配置名称, 譬如 "linux-x86_64-server-release", 如果在这些信息都相同的情况下保存不同的编译参数配置, 就需要使用这个参数来自定义配置名称.')])]),a._v(" "),s("p",[a._v("以上是 "),s("strong",[a._v("configure 命令的部分参数")]),a._v(", 所有参数均通过以下形式使用:")]),a._v(" "),s("div",{staticClass:"language-ziti1 line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("bash configure [options]\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("譬如, 编译 FastDebug 版, 仅含 Server 模式的 HotSpot 虚拟机, 命令应为:")]),a._v(" "),s("div",{staticClass:"language-ziti1 line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("bash configure --enable-debug --with-jvm-variants=server\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v('configure 命令承担了依赖项检查, 参数配置和构建输出目录结构等多项职责, 如果编译过程中需要的工具链或者依赖项有缺失, 命令执行后将会得到明确的提示, 并且给出该依赖的安装命令, 这比编译旧版 OpenJDK 时的 "make sanity" 检查要友好得多, 譬如以下例子所示:')]),a._v(" "),s("div",{staticClass:"language-ziti1 line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("configure: error: Could not find fontconfig! You might be able to fix this by running 'sudo apt-get install libfontconfig1-dev'.\nconfigure exiting with result code 1\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("p",[a._v("如果一切顺利的话, 就会收到"),s("strong",[a._v("配置成功")]),a._v("的提示, 并且输出调试级别, Java 虚拟机的模式, 特性, 使用的编译器版本等配置摘要信息, 如下所示:")]),a._v(" "),s("div",{staticClass:"language-Java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("A")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" configuration has been successfully created in\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("home"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("icyfenix"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("develop"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("java"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("jdk12"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("build"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("linux"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("x86_64"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("server"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("release\nusing "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("default")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("settings"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")])]),a._v("\n\nConfiguration")]),a._v(" summary"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Debug")]),a._v(" level"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("    release\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("HS")]),a._v(" debug level"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" product\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("JVM")]),a._v(" variants"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("   server\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("JVM")]),a._v(" features"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("   server"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" 'aot cds cmsgc compiler1 compiler2 epsilongc g1gc graal jfr jni"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("check jvmci jvmti management nmt parallelgc serialgc services shenandoahgc vm"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("structs zgc'\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("OpenJDK")]),a._v(" target"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("OS")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" linux"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("CPU")]),a._v(" architecture"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" x86"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" address length"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("64")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Version")]),a._v(" string"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("12")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("internal"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("adhoc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("icyfenix"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("jdk12 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("12")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("internal"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Tools")]),a._v(" summary"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Boot")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("JDK")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("       openjdk version "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"11.0.3"')]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2019")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("04")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("16")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("OpenJDK")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Runtime")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Environment")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("build "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("11.0")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v(".3")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("7")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Ubuntu")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v("ubuntu218"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("04.1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("OpenJDK")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("64")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Bit")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Server")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("VM")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("build "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("11.0")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v(".3")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("7")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Ubuntu")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v("ubuntu218"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("04.1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" mixed mode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" sharing"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("at "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("usr"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("lib"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("jvm"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("java"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("11")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("openjdk"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("amd64"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Toolchain")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("      gcc "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GNU")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Compiler")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Collection")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("C")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Compiler")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("     "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Version")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("7.4")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v(".0")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("at "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("usr"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("bin"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("gcc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("C")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Compiler")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Version")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("7.4")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v(".0")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("at "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("usr"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("bin"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("g"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Build")]),a._v(" performance summary"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Cores")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("to")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("use")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Memory")]),a._v(" limit"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("7976")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("MB")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br")])]),s("p",[a._v('在 configure 命令以及后面的 make 命令的执行过程中, 会在 "build/配置名称" 目录下产生如下目录结构. 不常使用 C/C++ 的读者要特别注意, 如果多次编译, 或者目录结构成功产生后又再次修改了配置, 必须先使用 "'),s("strong",[a._v("make clean")]),a._v('" 和 "'),s("strong",[a._v("make dist-clean")]),a._v('" 命令清理目录, 才能确保新的配置生效. 编译产生的目录结构以及用途如下所示:')]),a._v(" "),s("div",{staticClass:"language-sh line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[a._v("buildtools/: 用于生成, 存放编译过程中用到的工具\nhotspot/: HotSpot 虚拟机编译的中间文件\nimages/: 使用 "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("make")]),a._v(" *-image 产生的镜像存放在这里\njdk/: 编译后产生的 JDK 就放在这里\nsupport/: 存放编译时产生的中间文件\ntest-results/: 存放编译后的自动化测试结果\nconfigure-support/: 这三个目录是存放执行 configure, "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("make")]),a._v(" 和 "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("test")]),a._v(" 的临时文件\nmake-support/\ntest-support/\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br")])]),s("p",[a._v('依赖检查通过后便可以输入 "'),s("strong",[a._v("make images")]),a._v('" 执行整个 OpenJDK 编译了, 这里 "images" 是 "product-images" 编译目标(Target)的简写别名, 这个目标的作用是编译出整个 JDK 镜像, 除了 "product-images" 以外, 其他编译目标还有:')]),a._v(" "),s("div",{staticClass:"language-ziti1 line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("hotspot: 只编译 HotSpot 虚拟机\nhotspot-<variant>: 只编译特定模式的 HotSpot 虚拟机\ndocs-image: 产生 JDK 的文档镜像\ntest-image: 产生 JDK 的测试镜像\nall-images: 相当于连续调用 product, docs, test 三个编译目标\nbootcycle-images: 编译两次 JDK, 其中第二次使用第一次的编译结果作为 Bootstrap JDK\nclean: 清理 make 命令产生的临时文件\ndist-clean: 清理 make 和 configure 命令产生的临时文件\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br")])]),s("p",[a._v('编译完成之后, 进入 OpenJDK 源码的 "'),s("strong",[a._v("build/配置名称/jdk")]),a._v('" 目录下就可以看到 OpenJDK 的完整编译结果了, '),s("strong",[a._v("把它复制到 JAVA_HOME 目录, 就可以作为一个完整的 JDK 来使用")]),a._v(", 如果没有人为设置过 JDK 开发版本的话, 这个 JDK 的开发版本号里默认会带上编译的机器名, 如下所示:")]),a._v(" "),s("div",{staticClass:"language-ziti1 line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('> ./java -version\nopenjdk version "12-internal" 2019-03-19\nOpenJDK Runtime Environment (build 12-internal+0-adhoc.icyfenix.jdk12)\nOpenJDK 64-Bit Server VM (build 12-internal+0-adhoc.icyfenix.jdk12, mixed mode)\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("blockquote",[s("p",[a._v("4.在IDE工具中进行源码调试")])]),a._v(" "),s("p",[a._v("在本次实战里, 笔者采用的 IDE 是 JetBrains 的 "),s("strong",[a._v("CLion")]),a._v(' 2019.1. CLion 安装后, 新建一个项目, 选择 "New CMake Project from Sources", 在源码文件夹中填入 OpenJDK 源码根目录, 此时, CLion 已经自动选择好了需要导入的源码, 如图 1-10 所示. 点击 OK 按钮就会导入源码并自动创建好 CMakeLists.txt 文件.')]),a._v(" "),s("p",[s("img",{attrs:{src:"/img/Image00011-20240302133505-nx37sk4.jpg",alt:"",title:"图1-10　在 CLion 中创建 HotSpot 项目(1)"}})]),a._v(" "),s("p",[a._v("这份自动生成的 CMakeLists.txt 并不能直接使用, OpenJDK 本身也没有为任何 IDE 提供支持, 但如果只是为了能够在 CLion 中跟踪, 阅读源码, 而不需要修改重新编译的话, 那直接在 Run/Debug Configurations 中增加一个 CMake Application, 然后 Executable 选择刚才编译出来的 FastDebug 或者 SlowDebug 版的 java 命令, 运行参数加上 -version 或者某个 Class 文件的路径, 再把 Before launch 里面的 Build 去掉, 就可以开始运行调试了, 如图 1-11 所示.")]),a._v(" "),s("p",[s("img",{attrs:{src:"/img/Image00012-20240302133505-poyapd9.jpg",alt:"",title:"图1-11　在 NetBeans 中创建 HotSpot 项目(2)"}})]),a._v(" "),s("p",[a._v("不过如果读者需要在 CLion 中修改源码, 并重新编译产生新的 JDK, 又或者不想阅读时看见一堆头文件缺失提示的话, 那还是需要把 CMakeLists.txt 修好, 在 GitHub 上已经有现成的参考, 读者可以直接下载, 内容较多, 就不在本文中列出了.")]),a._v(" "),s("p",[a._v("读者在调试 Java 代码执行时, 如果要跟踪具体 Java 代码在虚拟机中是如何执行的, 一开始可能会觉得有些无处入手, 因为目前 HotSpot 在主流的操作系统上, 都采用模板解释器来执行字节码, 它与即时编译器一样, 最终执行的汇编代码都是运行期间产生的, 无法直接设置断点, 所以 HotSpot 增加了以下参数来方便开发人员调试解释器:")]),a._v(" "),s("div",{staticClass:"language-ziti1 line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("-XX:+TraceBytecodes -XX:StopInterpreterAt=<n>\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("这组参数的作用是当遇到序号为 "),s("code",[a._v("<n>")]),a._v("​ 的字节码指令时, 便会中断程序执行, 进入断点调试. 调试解释器部分代码时, 把这两个参数加到 java 命令的参数后面即可.")]),a._v(" "),s("p",[a._v("完成以上配置之后, 一个可修改, 编译, 调试的 HotSpot 工程就完全建立起来了, Hot-Spot 虚拟机启动器的执行入口是 java.c 的 JavaMain() 方法, 读者可以设置断点单步跟踪, 如图 1-12 所示.")]),a._v(" "),s("p",[s("img",{attrs:{src:"/img/Image00013-20240302133505-a812hzj.jpg",alt:"",title:"图1-12　在 CLion 中创建 HotSpot 项目(3)"}})]),a._v(" "),s("h4",{attrs:{id:"本章小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#本章小结"}},[a._v("#")]),a._v(" 本章小结")]),a._v(" "),s("p",[a._v('本章介绍了 Java 技术体系的过去, 现在和未来的发展趋势, 并在实践中介绍了如何自己编译一个 OpenJDK 12. 作为全书的引言部分, 本章建立了后文研究所必需的环境. 在了解 Java 技术的来龙去脉后, 后面章节将分为四部分去介绍 Java 在 "自动内存管理", "Class 文件结构与执行引擎", "编译器优化" 及 "多线程并发" 方面的实现原理.')]),a._v(" "),s("p",[a._v("‍")]),a._v(" "),s("p",[a._v("‍")]),a._v(" "),s("p",[a._v("‍")]),a._v(" "),s("p",[a._v("‍")])])}),[],!1,null,null,null);s.default=r.exports}}]);