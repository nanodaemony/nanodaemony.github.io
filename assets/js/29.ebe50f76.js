(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{341:function(_,v,t){"use strict";t.r(v);var r=t(7),s=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"_3-内存管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-内存管理"}},[_._v("#")]),_._v(" 3.内存管理")]),_._v(" "),v("p",[_._v("操作系统的"),v("strong",[_._v("内存管理")]),_._v("主要负责"),v("strong",[_._v("内存的分配与回收, 地址转换(将逻辑地址转换成相应的物理地址)")]),_._v(" 等.")]),_._v(" "),v("h4",{attrs:{id:"虚拟地址空间🌟"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟地址空间🌟"}},[_._v("#")]),_._v(" 虚拟地址空间🌟")]),_._v(" "),v("h5",{attrs:{id:"_1-基本概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本概念"}},[_._v("#")]),_._v(" 1.基本概念")]),_._v(" "),v("p",[_._v("几个概念.")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("虚拟地址/逻辑地址")]),_._v(": 指由程序产生的"),v("strong",[_._v("由段选择符和段内偏移地址")]),_._v("两个部分组成的地址. 这两部分组成的地址"),v("strong",[_._v("并没有直接访问物理内存")]),_._v(", 而是要通过"),v("strong",[_._v("分段地址")]),_._v("的变换机构处理或"),v("strong",[_._v("映射后")]),_._v("才会对应到相应的物理内存地址. 许多人直接把逻辑地址当成虚拟地址.")]),_._v(" "),v("li",[v("strong",[_._v("线性地址")]),_._v(": 指的是"),v("strong",[_._v("虚拟地址到物理地址变换之间的中间层")]),_._v(", 是处理器可寻指的内存空间(称为线性地址空间)中的地址. 程序代码会产生逻辑地址, 或者说是段中的偏移地址, 加上相应段的基地址就生成了一个线性地址. 如果启用了分页机制, 那么线性地址可以再经过变换产生物理地址. 若是没有采用分页机制, 那么线性地址就是物理地址.")]),_._v(" "),v("li",[v("strong",[_._v("物理地址")]),_._v(": "),v("strong",[_._v("物理地址")]),_._v("指的是"),v("strong",[_._v("真实物理内存中地址")]),_._v(", 是内存单元"),v("strong",[_._v("真正")]),_._v("的地址, 具体一点就是"),v("strong",[_._v("内存地址寄存器中的地址")]),_._v(", 是地址变换的"),v("strong",[_._v("最终结果")]),_._v(".")])]),_._v(" "),v("p",[v("strong",[_._v("编程")]),_._v("一般只有可能和"),v("strong",[_._v("逻辑地址")]),_._v("打交道, 比如 C 语言中指针里存储的数值就可以理解成为内存里的一个"),v("strong",[_._v("地址")]),_._v(", 这个地址就是"),v("strong",[_._v("逻辑地址")]),_._v(", "),v("mark",[v("strong",[_._v("逻辑地址由操作系统决定")])]),_._v(".")]),_._v(" "),v("h5",{attrs:{id:"_2-寻址方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-寻址方式"}},[_._v("#")]),_._v(" 2.寻址方式")]),_._v(" "),v("blockquote",[v("p",[_._v("CPU寻址是什么?为什么需要虚拟地址空间?")])]),_._v(" "),v("p",[_._v("现代处理器使用的是一种称为"),v("strong",[_._v("虚拟寻址(Virtual Addressing)")]),_._v(" 的寻址方式. "),v("strong",[_._v("使用虚拟寻址时, CPU 需要将虚拟地址翻译成物理地址, 这样才能访问到真实的物理内存")]),_._v(". 实现虚拟地址到物理地址转换的硬件是 CPU 中称为 "),v("strong",[_._v("内存管理单元(Memory Management Unit, MMU)")]),_._v("  的硬件. 如下图所示:")]),_._v(" "),v("p",[_._v("​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200718170748101.png",alt:"",title:"内存管理单元MMU"}}),_._v("​")]),_._v(" "),v("p",[_._v("如果没有虚拟地址空间, 程序可以直接访问与操作物理内存. 这时用户程序可以访问"),v("strong",[_._v("任意内存地址")]),_._v(", 这很有可能破坏操作系统, 造成"),v("strong",[_._v("操作系统崩溃")]),_._v(". 因此不能直接把物理地址暴露出来.")]),_._v(" "),v("p",[_._v("通过"),v("strong",[_._v("虚拟地址访问内存")]),_._v("有以下优势:")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("不同进程")]),_._v("使用的虚拟地址"),v("strong",[_._v("彼此隔离")]),_._v(". 一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存. 这也提升了操作系统安全性.")]),_._v(" "),v("li",[_._v("程序可以使用一系列"),v("strong",[_._v("虚拟地址")]),_._v("来访问"),v("strong",[_._v("大于可用物理内存的内存缓冲区")]),_._v(". 当物理内存的供应量变小时, 内存管理器会将物理内存页(通常大小为 4 KB)保存到"),v("strong",[_._v("磁盘文件")]),_._v(".")])]),_._v(" "),v("h4",{attrs:{id:"虚拟内存🌟"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存🌟"}},[_._v("#")]),_._v(" 虚拟内存🌟")]),_._v(" "),v("h5",{attrs:{id:"_1-虚拟内存概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-虚拟内存概念"}},[_._v("#")]),_._v(" 1.虚拟内存概念")]),_._v(" "),v("p",[_._v("几个概念:")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("物理内存 RAM(Random Access Memory)")]),_._v(" : 是计算机的"),v("strong",[_._v("实际内存大小")]),_._v(", 它直接与 CPU 交换数据, 也被称为主存.")]),_._v(" "),v("li",[v("strong",[_._v("虚拟内存(Virtual Memory)")]),_._v(' : 虚拟内存是操作系统为了更高效率使用物理内存的一种概念, 它是对物理内存的抽象. Windows 的 "'),v("strong",[_._v("虚拟内存")]),_._v('" 和 Linux 的  '),v("strong",[_._v('"交换空间(swap)"')]),_._v("  都是虚拟内存技术的一种"),v("strong",[_._v("实现")]),_._v(".")])]),_._v(" "),v("p",[v("strong",[_._v("虚拟内存")]),_._v("是计算机系统"),v("strong",[_._v("内存管理")]),_._v("的一种技术. "),v("strong",[_._v("虚拟内存")]),_._v("使应用程序认为它"),v("strong",[_._v("拥有连续可用的内存")]),_._v("(一个连续完整的地址空间), 而实际上它通常是被"),v("strong",[_._v("分隔成多个物理内存碎片")]),_._v(", 甚至可能还有部分"),v("strong",[_._v("暂时存储在外部磁盘存储器上")]),_._v(", 在需要时进行"),v("strong",[_._v("数据交换")]),_._v(". 它可以让程序可以"),v("strong",[_._v("拥有超过系统物理内存大小的可用内存空间")]),_._v(", 其目的是为了让物理内存扩充成更大的"),v("strong",[_._v("逻辑内存")]),_._v(", 从而让程序获得更多的"),v("strong",[_._v("可用内存")]),_._v(". "),v("strong",[_._v("虚拟内存为每个进程提供了一个一致的, 私有的地址空间")]),_._v(".")]),_._v(" "),v("p",[_._v("为更好的管理内存, 操作系统将"),v("strong",[_._v("内存")]),_._v("抽象成"),v("strong",[_._v("地址空间")]),_._v(". 每个程序拥有自己的"),v("strong",[_._v("地址空间")]),_._v(", 这个地址空间被分割成多个块, "),v("strong",[_._v("每一块称为一页")]),_._v(". 这些"),v("strong",[_._v("页被映射到物理内存")]),_._v(", 但"),v("strong",[_._v("不需要映射到连续的物理内存, 也不需要所有页都必须在物理内存中")]),_._v(". 当程序引用到不在物理内存中的页时, 由"),v("strong",[_._v("硬件执行必要的映射")]),_._v(", 将缺失的部分装入"),v("strong",[_._v("物理内存")]),_._v("并重新执行失败的指令. "),v("strong",[_._v("虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存")]),_._v(", 也就是说一个程序不需要全部调入内存就可以运行, 这使得有限的内存运行大程序成为可能. 例如有一台计算机可以产生 16 位地址, 那么一个程序的地址空间范围是 0~64K. 该计算机只有 32KB 的物理内存, 虚拟内存技术允许该计算机运行一个 64K 大小的程序. "),v("strong",[_._v("虚拟内存是被虚拟")]),_._v("出来的, 可以使用硬盘("),v("strong",[_._v("不仅仅是硬盘")]),_._v(")来作为虚拟内存. 这就是为什么可以"),v("strong",[_._v("正常运行一个所需内存比计算机内存还大的程序")]),_._v(", 并感受不到内存的限制的原因.")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563375683605.png",alt:"1563375683605"}})]),_._v(" "),v("h5",{attrs:{id:"_2-局部性原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-局部性原理"}},[_._v("#")]),_._v(" 2.局部性原理")]),_._v(" "),v("p",[v("strong",[_._v("局部性原理是虚拟内存技术的基础")]),_._v(". 正是因为程序运行具有局部性原理, 才可以"),v("strong",[_._v("只装入部分程序到内存")]),_._v("就可以开始运行.")]),_._v(" "),v("p",[_._v("程序在执行的时候往往"),v("strong",[_._v("呈现局部性规律")]),_._v(", 也就是说在某个较短的时间段内, 程序"),v("strong",[_._v("执行局限于某一小部分")]),_._v(", 程序访问的存储空间也局限于某个区域. 局部性原理"),v("strong",[_._v("表现")]),_._v("在以下两个方面:")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("时间局部性")]),_._v(": 如果程序中的某条"),v("strong",[_._v("指令一旦执行")]),_._v(", 不久以后该指令可能"),v("strong",[_._v("再次执行")]),_._v("; 如果某数据被访问过, 不久以后该数据可能再次被访问. 产生时间局部性的典型原因是由于在程序中存在着大量的"),v("strong",[_._v("循环操作")]),_._v(". "),v("strong",[_._v("时间局部性")]),_._v("是通过将近来使用的"),v("strong",[_._v("指令和数据保存到高速缓存存储器")]),_._v("中, 并使用高速缓存的层次结构实现.")]),_._v(" "),v("li",[v("strong",[_._v("空间局部性")]),_._v(": 一旦程序访问了某个存储单元, 在不久之后, 其附近的存储单元可能也将被访问, 即程序在一段时间内所访问的地址, 可能集中在一定的范围之内, 这是因为指令通常是顺序存放, 顺序执行的, 数据也一般是簇聚存储的. "),v("strong",[_._v("空间局部性")]),_._v("通常是使用"),v("strong",[_._v("较大的高速缓存")]),_._v(", 并将预取机制集成到高速缓存控制逻辑中实现.")])]),_._v(" "),v("p",[_._v('虚拟内存技术实际上就是建立了 "'),v("strong",[_._v("内存-外存")]),_._v('" 的'),v("strong",[_._v("两级存储器")]),_._v("的结构, 利用"),v("strong",[_._v("局部性原理实现髙速缓存")]),_._v(".")]),_._v(" "),v("h5",{attrs:{id:"_3-虚拟存储器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-虚拟存储器"}},[_._v("#")]),_._v(" 3.虚拟存储器")]),_._v(" "),v("p",[v("strong",[_._v("基于局部性原理, 在程序装入时, 可以将程序的一部分装入内存, 而将其他部分留在外存, 就可以启动程序执行. 在程序执行过程中, 当所访问的信息不在内存时, 由操作系统将所需要的部分调入内存, 然后继续执行程序. 另一方面, 操作系统也可以将内存中暂时不使用的内容交换到外存上, 从而腾出空间存放将要调入内存的信息")]),_._v(". 这样计算机好像为用户提供了一个比实际内存大得多的存储器: "),v("strong",[_._v("虚拟存储器")]),_._v(".")]),_._v(" "),v("p",[_._v("所以虚拟内存是一种"),v("strong",[_._v("时间换空间")]),_._v("的策略, 用 CPU 的计算时间与页的调入调出花费的时间, 换来了一个虚拟的更大的空间来支持程序的运行.")]),_._v(" "),v("h5",{attrs:{id:"_4-虚拟内存技术实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-虚拟内存技术实现"}},[_._v("#")]),_._v(" 4.虚拟内存技术实现")]),_._v(" "),v("p",[v("strong",[_._v("虚拟内存的实现需要建立在离散分配的内存管理方式基础上")]),_._v(".")]),_._v(" "),v("p",[v("strong",[v("strong",[_._v("虚拟内存的")])]),_._v("​"),v("strong",[_._v("实现")]),_._v("有以下三种方式:")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("请求分页存储管理")]),_._v(": 建立在"),v("strong",[_._v("分页管理")]),_._v("之上, 为了支持虚拟存储器功能而增加了"),v("strong",[_._v("请求调页功能, 页面置换功能")]),_._v(". 请求分页是目前最常用的一种实现虚拟存储器的方法. 请求分页存储管理系统中, 在作业开始运行之前, 仅装入当前要执行的"),v("strong",[_._v("部分页")]),_._v("即可运行. 假如在作业运行的过程中发现要访问的"),v("strong",[_._v("页面不在内存")]),_._v(", 则由处理器通知操作系统按照对应的"),v("strong",[_._v("页面置换算法")]),_._v("将相应的页面调入到主存, 同时操作系统也可以将暂时不用的"),v("strong",[_._v("页面置换到外存")]),_._v("中.")]),_._v(" "),v("li",[v("strong",[_._v("请求分段存储管理")]),_._v(": 建立在"),v("strong",[_._v("分段存储管理")]),_._v("之上, 增加了"),v("strong",[_._v("请求调段功能, 分段置换功能")]),_._v(". 具体过程与分页形式类似, 不过这里操作的是段.")]),_._v(" "),v("li",[v("strong",[_._v("请求段页式存储管理")]),_._v(".")])]),_._v(" "),v("p",[_._v("不管哪种实现方式, 一般都需要:")]),_._v(" "),v("ol",[v("li",[_._v("一定容量的"),v("strong",[_._v("内存和外存")]),_._v(": 只需将程序的一部分装入内存, 而将其他部分留在外存, 程序即可执行;")]),_._v(" "),v("li",[v("strong",[_._v("缺页中断")]),_._v(": 如果"),v("strong",[_._v("需执行的指令或访问的数据尚未在内存")]),_._v("(称为缺页或缺段), 则由"),v("strong",[_._v("处理器")]),_._v("通知"),v("strong",[_._v("操作系统")]),_._v("将相应的页或段"),v("strong",[_._v("调入到内存")]),_._v(", 然后继续执行程序;")]),_._v(" "),v("li",[v("strong",[_._v("虚拟地址空间")]),_._v(": "),v("strong",[_._v("逻辑地址到物理地址的变换")]),_._v(".")])]),_._v(" "),v("h5",{attrs:{id:"_5-页面置换算法🌟"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-页面置换算法🌟"}},[_._v("#")]),_._v(" 5.页面置换算法🌟")]),_._v(" "),v("p",[v("strong",[_._v("虚拟内存管理")]),_._v("很重要的一个概念就是"),v("strong",[_._v("页面置换算法")]),_._v(".")]),_._v(" "),v("blockquote",[v("p",[_._v("为何需要进行页面置换?")])]),_._v(" "),v("p",[_._v("在程序运行过程中, "),v("strong",[_._v("如果要访问的页(或段)不在内存中, 就发生缺页中断, 从而需要将该页调入内存之后再进行访问")]),_._v(". 被内存映射的文件实际上成了一个分页交换文件. 此时如果内存"),v("strong",[_._v("已无空闲空间")]),_._v(", 系统必须从"),v("strong",[_._v("内存中")]),_._v("调出一个"),v("strong",[_._v("页到磁盘对换区")]),_._v("中, 以便为即将调入的页让出空间.")]),_._v(" "),v("p",[_._v("用来"),v("strong",[_._v("选择被淘汰页")]),_._v("的规则即"),v("strong",[_._v("页面置换算法")]),_._v(". "),v("strong",[_._v("页面置换算法")]),_._v("和缓存淘汰策略类似, 缓存系统中缓存大小有限, 当有新的缓存到达时, 需要淘汰一部分已经存在的缓存, 这样才有空间存放新的缓存数据. "),v("mark",[v("strong",[_._v("页面置换算法的主要目标是使页面置换频率最低, 也可以说缺页率最低")])]),_._v(".")]),_._v(" "),v("p",[_._v("常见的页面置换算法.")]),_._v(" "),v("h6",{attrs:{id:"_1-最佳算法opt"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-最佳算法opt"}},[_._v("#")]),_._v(" (1)最佳算法OPT")]),_._v(" "),v("p",[_._v("OPT 算法所选择的被换出的页面将是最长时间内不再被访问, 通常可以保证获得最低的缺页率. 是一种"),v("strong",[_._v("理论上的算法")]),_._v(", 因为无法知道一个页面多长时间不再被访问.")]),_._v(" "),v("p",[_._v("举例: 一个系统为某进程分配了三个物理块, 并有如下页面引用序列:")]),_._v(" "),v("div",{staticClass:"language-html line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-html"}},[v("code",[_._v("7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])]),v("p",[_._v("开始运行时, 先将 7, 0, 1 三个页面装入内存. 当进程要访问页面 2 时, 产生缺页中断, 会将页面 7 换出, 因为页面 7 再次被访问的时间最长.")]),_._v(" "),v("h6",{attrs:{id:"_2-最近最久未使用算法lru"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-最近最久未使用算法lru"}},[_._v("#")]),_._v(" (2)最近最久未使用算法LRU")]),_._v(" "),v("p",[_._v("LRU(Least Recently Used) 算法. 虽然无法知道将来要使用的页面情况, 但可以知道"),v("strong",[_._v("过去使用页面")]),_._v("的情况. LRU 将"),v("strong",[_._v("最近最久未使用")]),_._v("的页面换出. 为实现 LRU, 需要在内存中维护一个所有页面的"),v("strong",[_._v("双向链表")]),_._v(". 当一个页面被访问时, 将这个页面移到链表表头. 这样就能保证"),v("strong",[_._v("链表表尾的页面")]),_._v("是最近最久未访问的. 因为"),v("strong",[_._v("每次访问")]),_._v("都需要"),v("strong",[_._v("更新链表")]),_._v(", 因此这种方式实现的 LRU 代价较高.")]),_._v(" "),v("p",[_._v("下面是页面使用顺序及其在链表中的图示.")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("4, 7, 0, 7, 1, 0, 1, 2, 1, 2, 6\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])]),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563375725614.png",alt:"1563375725614"}})]),_._v(" "),v("h6",{attrs:{id:"_3-最近未使用算法nru"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-最近未使用算法nru"}},[_._v("#")]),_._v(" (3)最近未使用算法NRU")]),_._v(" "),v("p",[_._v("NRU算法(Not Recently Used). 每个页面都有"),v("strong",[_._v("两个状态位")]),_._v(": "),v("strong",[_._v("R 与 M")]),_._v(", 当页面被"),v("strong",[_._v("访问")]),_._v("时设置页面的 "),v("strong",[_._v("R = 1")]),_._v(", 当页面被"),v("strong",[_._v("修改")]),_._v("时设置 "),v("strong",[_._v("M = 1")]),_._v(". 其中 R 位会"),v("strong",[_._v("定时被清零")]),_._v(". 可以将页面分成以下"),v("strong",[_._v("四类")]),_._v(":")]),_._v(" "),v("ul",[v("li",[_._v("R=0, M=0")]),_._v(" "),v("li",[_._v("R=0, M=1")]),_._v(" "),v("li",[_._v("R=1, M=0")]),_._v(" "),v("li",[_._v("R=1, M=1")])]),_._v(" "),v("p",[_._v("当发生缺页中断时, NRU 算法随机地从"),v("strong",[_._v("类编号最小")]),_._v("的"),v("strong",[_._v("非空类")]),_._v("中挑选一个页面将它换出. NRU "),v("strong",[_._v("优先换出已经被修改的脏页面")]),_._v("(R=0, M=1), 而"),v("strong",[_._v("不是被频繁使用的干净页面")]),_._v("(R=1, M=0).")]),_._v(" "),v("h6",{attrs:{id:"_4-先进先出算法fifo"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-先进先出算法fifo"}},[_._v("#")]),_._v(" (4)先进先出算法FIFO")]),_._v(" "),v("p",[_._v("FIFO 算法(First In First Out). 选择换出的页面是"),v("strong",[_._v("最先进入")]),_._v("的页面. 该算法会将那些"),v("strong",[_._v("经常被访问")]),_._v("的页面也可能被换出, 从而使缺页率升高.")]),_._v(" "),v("h6",{attrs:{id:"_5-第二次机会算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-第二次机会算法"}},[_._v("#")]),_._v(" (5)第二次机会算法")]),_._v(" "),v("p",[v("strong",[_._v("FIFO 算法")]),_._v("可能会把经常使用的页面置换出去, 为避免这一问题, 对该算法做一个简单的"),v("strong",[_._v("修改")]),_._v(": 当页面被访问 (读或写) 时设置该页面的 "),v("strong",[_._v("R 位为 1")]),_._v(". 需要替换的时候, 检查"),v("strong",[_._v("最老页面的 R 位")]),_._v(". 如果 R 位是 0, 那么这个页面既老又没有被使用, 可以立刻置换掉; 如果"),v("strong",[_._v("是 1, 就将 R 位清 0")]),_._v(", 并把该页面放到链表的"),v("strong",[_._v("尾端")]),_._v(", 修改它的装入时间使它就像刚装入的一样, 然后继续从链表的头部开始搜索.")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563375750307.png",alt:"",title:"第二次机会算法"}})]),_._v(" "),v("h6",{attrs:{id:"_6-时钟算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-时钟算法"}},[_._v("#")]),_._v(" (6)时钟算法")]),_._v(" "),v("p",[_._v("Clock 算法, "),v("strong",[_._v("第二次机会算法")]),_._v("需要在"),v("strong",[_._v("链表")]),_._v("中移动页面, 降低了效率. 时钟算法使用"),v("strong",[_._v("环形链表")]),_._v("将页面连接起来, 再使用一个"),v("strong",[_._v("指针")]),_._v("指向最老的页面.")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563375761281.png",alt:"",title:"时钟算法"}})]),_._v(" "),v("p",[_._v("‍")]),_._v(" "),v("h4",{attrs:{id:"参考资料"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[_._v("#")]),_._v(" 参考资料")]),_._v(" "),v("ul",[v("li",[_._v("《计算机操作系统—汤小丹》第四版")]),_._v(" "),v("li",[v("a",{attrs:{href:"https://book.douban.com/subject/1230413/",target:"_blank",rel:"noopener noreferrer"}},[_._v("《深入理解计算机系统》"),v("OutboundLink")],1)]),_._v(" "),v("li",[v("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://zh.wikipedia.org/wiki/输入输出内存管理单元"),v("OutboundLink")],1)]),_._v(" "),v("li",[v("a",{attrs:{href:"https://baike.baidu.com/item/%E5%BF%AB%E8%A1%A8/19781679",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://baike.baidu.com/item/快表/19781679"),v("OutboundLink")],1)]),_._v(" "),v("li",[v("a",{attrs:{href:"https://www.jianshu.com/p/1d47ed0b46d5",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://www.jianshu.com/p/1d47ed0b46d5"),v("OutboundLink")],1)]),_._v(" "),v("li",[v("a",{attrs:{href:"https://www.studytonight.com/operating-system",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://www.studytonight.com/operating-system"),v("OutboundLink")],1)]),_._v(" "),v("li",[v("a",{attrs:{href:"https://www.geeksforgeeks.org/interprocess-communication-methods/",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://www.geeksforgeeks.org/interprocess-communication-methods/"),v("OutboundLink")],1)]),_._v(" "),v("li",[v("a",{attrs:{href:"https://juejin.im/post/59f8691b51882534af254317",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://juejin.im/post/59f8691b51882534af254317"),v("OutboundLink")],1)]),_._v(" "),v("li",[v("a",{attrs:{href:"https://juejin.im/post/59f8691b51882534af254317",target:"_blank",rel:"noopener noreferrer"}},[_._v("《虚拟内存的那点事儿》"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=s.exports}}]);