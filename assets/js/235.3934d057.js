(window.webpackJsonp=window.webpackJsonp||[]).push([[235],{563:function(t,_,v){"use strict";v.r(_);var r=v(4),s=Object(r.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"_2-rabbitmq"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-rabbitmq"}},[t._v("#")]),t._v(" 2.RabbitMQ")]),t._v(" "),_("h4",{attrs:{id:"基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),_("p",[t._v("RabbitMQ 是用 Erlang 语言实现 "),_("strong",[t._v("AMQP")]),t._v(" 协议的消息中间件. RabbitMQ 的特点:")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("可靠性: ​")]),t._v("RabbitMQ 使用持久化, 传输确认及发布确认等机制来保证消息的可靠性.")]),t._v(" "),_("li",[_("strong",[t._v("灵活路由: ​")]),t._v("在消息进入队列之前, 通过交换器来路由消息. 对于典型的路由功能, RabbitMQ 己经提供了一些内置的交换器来实现. 针对更复杂的路由功能, 可以将多个交换器绑定在一起, 也可以通过插件机制来实现自己的交换器.")]),t._v(" "),_("li",[_("strong",[t._v("扩展性: ​")]),t._v("RabbitMQ 可以部署为集群, 可以根据实际业务情况动态收缩集群节点.")]),t._v(" "),_("li",[_("strong",[t._v("高可用性: ​")]),t._v("可以在集群中设置镜像, 使得部分节点在出现问题的情况下依然可用.")]),t._v(" "),_("li",[_("strong",[t._v("支持多种协议: ​")]),t._v("除了原生支持 AMQP 协议, 还支持 STOMP, MQTT 等多种协议.")]),t._v(" "),_("li",[_("strong",[t._v("多语言客户端: ​")]),t._v("几乎支持所有常用语言, 比如 Java, Python, JavaScript等.")]),t._v(" "),_("li",[_("strong",[t._v("插件机制: ​")]),t._v("RabbitMQ 提供了许多插件, 以实现从多方面进行扩展. 也可以自己开发插件.")])]),t._v(" "),_("h4",{attrs:{id:"rabbitmq架构🌸"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq架构🌸"}},[t._v("#")]),t._v(" RabbitMQ架构🌸")]),t._v(" "),_("p",[t._v("整体模型架构如下所示.")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200728153059822.png",alt:"image-20200728153059822"}})]),t._v(" "),_("h5",{attrs:{id:"_1-producer与consumer"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-producer与consumer"}},[t._v("#")]),t._v(" 1.Producer与Consumer")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("Producer(生产者)")])]),t._v(" "),_("li",[_("strong",[t._v("Consumer(消费者)")])])]),t._v(" "),_("p",[t._v("消息一般由 2 部分组成: "),_("strong",[t._v("消息头")]),t._v("(Label)和 "),_("strong",[t._v("消息体")]),t._v("(PayLoad).")]),t._v(" "),_("p",[t._v("消息体是不透明的, 而消息头则由一系列的"),_("strong",[t._v("可选属性组成")]),t._v(", 如 "),_("strong",[t._v("routing-key")]),t._v("(路由键), "),_("strong",[t._v("priority")]),t._v("(相对于其他消息的优先权), "),_("strong",[t._v("delivery-mode")]),t._v("(指出该消息可能需要持久性存储)等.")]),t._v(" "),_("h5",{attrs:{id:"_2-exchange"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-exchange"}},[t._v("#")]),t._v(" 2.Exchange")]),t._v(" "),_("p",[t._v("即交换器, 在 RabbitMQ 中, 消息并不是直接被投递到 "),_("strong",[t._v("Queue(消息队列)")]),t._v(" 中, 中间还必须经过 "),_("strong",[t._v("Exchange(交换器)")]),t._v(" 这一层, "),_("strong",[t._v("交换器")]),t._v("会把的消息分配到对应的"),_("strong",[t._v("消息队列")]),t._v("中. "),_("strong",[t._v("交换器")]),t._v("用来接收生产者发送的消息并将这些消息路由给服务器中的队列.")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220616203851494.png",alt:""}})]),t._v(" "),_("p",[t._v("Exchange 有 4 种"),_("strong",[t._v("类型")]),t._v(", 分别对应着不同的"),_("strong",[t._v("路由策略")]),t._v(": "),_("strong",[t._v("direct(默认)")]),t._v(", "),_("strong",[t._v("fanout")]),t._v(", "),_("strong",[t._v("topic")]),t._v(" 和 "),_("strong",[t._v("headers")]),t._v(". 不同类型的 Exchange 转发消息的"),_("strong",[t._v("策略")]),t._v("有所区别.")]),t._v(" "),_("p",[t._v("生产者将消息发给"),_("strong",[t._v("交换器")]),t._v("的时候, 一般会指定一个 "),_("strong",[t._v("RoutingKey(路由键)")]),t._v(", 用于指定该消息的路由规则, 这个 RoutingKey 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效.")]),t._v(" "),_("p",[t._v("RabbitMQ 会将 "),_("strong",[t._v("Exchange(交换器)")]),t._v(" 与 "),_("strong",[t._v("Queue(消息队列)")]),t._v(" 进行绑定关联, 在绑定的时候一般会指定一个 "),_("strong",[t._v("BindingKey(绑定建)")]),t._v(", 这样 RabbitMQ 就知道如何正确将消息路由到队列了, 如下图所示. 一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则, 所以可以将"),_("strong",[t._v("交换器理解成一个由绑定构成的路由表")]),t._v(". Exchange 和 Queue 的绑定可以是"),_("strong",[t._v("多对多")]),t._v("的关系.")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220616203922506.png",alt:""}})]),t._v(" "),_("p",[t._v("生产者将消息发送给交换器时, 需要一个 "),_("strong",[t._v("RoutingKey")]),t._v(", 当 BindingKey 和 RoutingKey 相匹配时, 消息会被路由到对应的队列中.")]),t._v(" "),_("h5",{attrs:{id:"_3-queue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-queue"}},[t._v("#")]),t._v(" 3.Queue")]),t._v(" "),_("p",[_("strong",[t._v("Queue(消息队列)")]),t._v(" 用来保存消息直到发送给消费者. 它是消息的容器. 一个消息可投入到一个或多个队列. 生产者生产消息并最终投递到队列中, 消费者可以从队列中获取消息并消费.")]),t._v(" "),_("p",[_("strong",[t._v("RabbitMQ")]),t._v(" 中消息只能存储在 "),_("strong",[t._v("队列")]),t._v(" 中, 而 Kafka 将消息存储在 "),_("strong",[t._v("topic(主题)")]),t._v(" 这个逻辑层面, 而相对应的队列逻辑只是 topic 实际存储文件中的位移标识.")]),t._v(" "),_("p",[_("strong",[t._v("多个消费者可以订阅同一个队列")]),t._v(", 这时队列中的消息会被平均分摊(Round-Robin, 即轮询)给多个消费者进行处理, 而不是每个消费者都收到所有的消息并处理, 这可以避免消息的重复消费.")]),t._v(" "),_("p",[_("strong",[t._v("RabbitMQ")]),t._v(" 不支持队列层面的广播消费, 如果有广播消费的需求, 需要在其上进行二次开发.")]),t._v(" "),_("h5",{attrs:{id:"_4-broker"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-broker"}},[t._v("#")]),t._v(" 4.Broker")]),t._v(" "),_("p",[t._v("一个 Broker 可以看作一个 RabbitMQ 服务节点或实例.")]),t._v(" "),_("p",[t._v("‍")])])}),[],!1,null,null,null);_.default=s.exports}}]);