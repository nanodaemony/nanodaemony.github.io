(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{346:function(t,s,_){"use strict";_.r(s);var v=_(7),r=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_5-io模型🌼"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-io模型🌼"}},[t._v("#")]),t._v(" 5.IO模型🌼")]),t._v(" "),s("p",[t._v("这里介绍下操作系统中的 IO 模型, "),s("strong",[t._v("IO 模型简单来说就是用什么样的通道进行数据的发送和接收")]),t._v(". Java 中也对这些模型进行了封装, 具体可以参考 Java网络IO模型.")]),t._v(" "),s("h4",{attrs:{id:"基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),s("h5",{attrs:{id:"_1-同步与异步"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-同步与异步"}},[t._v("#")]),t._v(" 1.同步与异步")]),t._v(" "),s("p",[s("strong",[t._v("同步和异步")]),t._v("是针对"),s("mark",[s("strong",[t._v("应用程序和操作系统内核")])]),t._v("的交互而言的, 同步和异步关注的是"),s("strong",[t._v("消息通信机制")]),t._v(".")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("同步")]),t._v(": 两个同步任务"),s("strong",[t._v("相互依赖")]),t._v(", 且一个任务必须依赖于另一任务的某种方式执行. 比如在 A->B 事件模型中, 需要先完成 A 才能执行 B. 再换句话说, "),s("strong",[t._v("同步 IO")]),t._v(" "),s("strong",[s("strong",[t._v("调用一旦开始, 调用者必须")])]),t._v("​"),s("strong",[t._v("等到方法调用返回后, 才能继续后续的行为")]),t._v(". 例如: 按下电饭锅的煮饭按钮, 然后等待饭煮好, 把饭盛出来, 然后再去炒菜.")]),t._v(" "),s("li",[s("strong",[t._v("异步")]),t._v(": "),s("strong",[t._v("异步 IO")]),t._v(" 调用更像一个"),s("strong",[t._v("消息传递")]),t._v(", 一旦开始, 方法调用就会立即返回, 调用者可以继续后续的操作. 两个异步的"),s("strong",[t._v("任务完全独立")]),t._v("的, 一方的执行不需要等待另外一方的执行. 例如: 按下电钮锅的煮饭按钮, 直接去炒菜或者做别的事情, 当电饭锅响的时候, 再回去把饭盛出来.")])]),t._v(" "),s("h5",{attrs:{id:"_2-阻塞与非阻塞"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-阻塞与非阻塞"}},[t._v("#")]),t._v(" 2.阻塞与非阻塞")]),t._v(" "),s("p",[s("strong",[t._v("阻塞和非阻塞")]),t._v("是针对"),s("mark",[s("strong",[t._v("进程在访问数据")])]),t._v("的时候, 根据 IO 操作的"),s("strong",[t._v("就绪状态")]),t._v("来采取的不同方式, 是一种读取或写入操作函数的实现方式. 阻塞方式下读取或写入函数将一直等待, 而非阻塞方式下, 读取或者写入函数会立即返回一个状态值. 阻塞和非阻塞关注的是"),s("strong",[t._v("程序在等待调用结果(消息, 返回值)时的状态")]),t._v(".")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("阻塞")]),t._v(": 当发起一个请求时, "),s("strong",[t._v("调用者一直等待请求结果返回")]),t._v(", 也就是当前线程会被"),s("strong",[t._v("挂起")]),t._v(", 无法进行其他任务, 只有当条件就绪才能继续当然线程. 例如: 你打电话问书店老板有没有《金瓶梅》, 如果是阻塞式调用, 则不会挂电话, 直到得到老板回复有没有这本书的结果.")]),t._v(" "),s("li",[s("strong",[t._v("非阻塞")]),t._v(": 当发起一个请求时, "),s("strong",[t._v("调用者不用一直等着结果返回")]),t._v(", 可以先去干其他事情, 在不能立刻得到结果之前, 该调用不会阻塞当前线程. 例子: 打电话问书店老板有没有《金瓶梅》, 不管老板有没有告诉你结果, 可以自己先一边去玩, 当然也要偶尔过几分钟 check 一下老板有没有告知结果.")])]),t._v(" "),s("p",[s("strong",[t._v("同步和异步是目的, 阻塞和非阻塞是实现方式. 同步/异步是从行为角度描述事物的, 而阻塞和非阻塞描述的当前事物的状态(等待调用结果时的状态)")]),t._v(" .")]),t._v(" "),s("blockquote",[s("p",[t._v("综合示例")])]),t._v(" "),s("p",[t._v("如果想吃一份宫保鸡丁盖饭:")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("同步阻塞")]),t._v(": 到饭馆点餐, 然后在那等着, 还要一边喊: 好了没! (阻塞式IO)")]),t._v(" "),s("li",[s("strong",[t._v("同步非阻塞")]),t._v(": 在饭馆点完餐, 就去遛狗了. 不过每过十分钟就打电话问饭店: 好了没! (非阻塞式IO)")]),t._v(" "),s("li",[s("strong",[t._v("异步阻塞")]),t._v(": 遛狗的时候, 接到饭馆电话, 说饭做好了, 让您亲自去拿. (多路复用式IO)")]),t._v(" "),s("li",[s("strong",[t._v("异步非阻塞")]),t._v(": 饭馆打电话说, 我们知道您的位置, 一会给你送过来, 安心遛狗就可以了.")])]),t._v(" "),s("h5",{attrs:{id:"_3-io交互流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-io交互流程"}},[t._v("#")]),t._v(" 3.IO交互流程")]),t._v(" "),s("p",[t._v("通常用户进程中的一次"),s("strong",[t._v("完整 IO 交互")]),t._v("流程分为"),s("strong",[t._v("两个阶段")]),t._v(". 首先是经过"),s("strong",[t._v("内核空间")]),t._v(", 由"),s("strong",[t._v("操作系统")]),t._v("处理; 然后到"),s("strong",[t._v("用户空间")]),t._v(", 由"),s("strong",[t._v("应用进程")]),t._v("处理. 应用进程必须通过"),s("strong",[t._v("系统调用")]),t._v("请求内核协助"),s("strong",[t._v("完成 IO 操作")]),t._v(".")]),t._v(" "),s("p",[t._v("对于一个"),s("strong",[t._v("套接字")]),t._v("上的网络输入操作主要分为两个阶段:")]),t._v(" "),s("ul",[s("li",[s("mark",[s("strong",[t._v("等待数据")])]),t._v(": 等待网络数据到达"),s("strong",[t._v("网卡")]),t._v(", 然后将"),s("strong",[t._v("数据读取到内核缓冲区")]),t._v(".")]),t._v(" "),s("li",[s("mark",[s("strong",[t._v("复制数据")])]),t._v(": 从内核缓冲区"),s("strong",[t._v("复制数据")]),t._v(", 拷贝到"),s("strong",[t._v("用户空间的应用进程")]),t._v("中.")])]),t._v(" "),s("p",[t._v("IO 模型则是对这个交互流程的实现, 不同的 IO 模型在一次网络操作过程中其等待数据和复制数据的步骤有不同的表现.")]),t._v(" "),s("h4",{attrs:{id:"io模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#io模型"}},[t._v("#")]),t._v(" IO模型")]),t._v(" "),s("p",[t._v("Unix 有"),s("strong",[t._v("五种")]),t._v(" IO 模型:")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("阻塞式 IO")])]),t._v(" "),s("li",[s("strong",[t._v("非阻塞式 IO")])]),t._v(" "),s("li",[s("strong",[t._v("IO 复用(select 和 poll)")])]),t._v(" "),s("li",[s("strong",[t._v("信号驱动式 IO(SIGIO)")])]),t._v(" "),s("li",[s("strong",[t._v("异步 IO(AIO)")])])]),t._v(" "),s("h5",{attrs:{id:"_1-阻塞式io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-阻塞式io"}},[t._v("#")]),t._v(" 1.阻塞式IO")]),t._v(" "),s("p",[s("strong",[t._v("应用进程")]),t._v("被"),s("strong",[t._v("阻塞")]),t._v(", 直到数据"),s("strong",[t._v("从内核缓冲区复制")]),t._v("到应用"),s("strong",[t._v("进程缓冲区中")]),t._v("才返回.")]),t._v(" "),s("p",[t._v("在阻塞过程中, 其它应用进程依然可以执行, 因此阻塞不意味着整个操作系统都被阻塞. 因为其它应用进程还可以执行, 所以不消耗 CPU 时间, 这种模型的 CPU "),s("strong",[t._v("利用效率")]),t._v("会比较高. 例如 "),s("strong",[t._v("Java BIO")]),t._v("(BIO).")]),t._v(" "),s("p",[t._v("下图中, "),s("strong",[t._v("recvfrom()")]),t._v("  函数用于"),s("strong",[t._v("接收 Socket")]),t._v(" 传来的数据, 并复制到"),s("strong",[t._v("应用进程的缓冲区 buf")]),t._v(" 中. 这里可把 recvfrom() 当成"),s("strong",[t._v("系统调用")]),t._v(". 除了异步 IO 之外的其他几个模型都需要"),s("strong",[t._v("调用 recvfrom() 来从操作系统内核复制数据到进程中")]),t._v(", 调用它的时候就是"),s("strong",[t._v("阻塞")]),t._v("的.")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ssize_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("recvfrom")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" sockfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("buf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" len"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" flags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("sockaddr")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("src_addr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("socklen_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("addrlen"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220528180004061.png",alt:"",title:"阻塞式IO"}})]),t._v(" "),s("h5",{attrs:{id:"_2-非阻塞式io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-非阻塞式io"}},[t._v("#")]),t._v(" 2.非阻塞式IO")]),t._v(" "),s("p",[s("strong",[t._v("应用进程")]),t._v("执行系统调用 "),s("strong",[t._v("recvfrom()")]),t._v("  之后, 内核返回一个"),s("strong",[t._v("错误码")]),t._v(". 应用进程"),s("strong",[t._v("可以继续执行")]),t._v(", 但是需要"),s("strong",[t._v("不断执行系统调用")]),t._v("来获知 IO 是否完成, 这种方式称为"),s("strong",[t._v("轮询")]),t._v("(polling). 由于 CPU 要处理更多的"),s("strong",[t._v("系统调用")]),t._v(", 因此这种 IO 模型的 CPU 利用率比较"),s("strong",[t._v("低")]),t._v(".")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220528180218113.png",alt:"",title:"非阻塞式IO"}})]),t._v(" "),s("h5",{attrs:{id:"_3-多路复用io🌟"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-多路复用io🌟"}},[t._v("#")]),t._v(" 3.多路复用IO🌟")]),t._v(" "),s("p",[t._v("使用 "),s("strong",[t._v("select() 或者 poll()")]),t._v(" "),s("strong",[t._v("等待")]),t._v("数据, 并且可以"),s("strong",[t._v("等待多个套接字")]),t._v("中的任何一个变为"),s("strong",[t._v("可读")]),t._v(", 这一过程会被"),s("strong",[t._v("阻塞")]),t._v(". 当某一个套接字"),s("strong",[t._v("可读时")]),t._v("返回, 之后再使用 "),s("strong",[t._v("recvfrom()")]),t._v("  把数据从内核"),s("strong",[t._v("复制")]),t._v("到进程中, 所以这个过程使用了"),s("strong",[t._v("两个")]),t._v("系统调用.")]),t._v(" "),s("p",[s("strong",[t._v("多个进程的 IO")]),t._v(" 可以注册到一个 "),s("strong",[t._v("Selector")]),t._v(" 上, Selector 会对所有 IO 事件进行监听. 它可以让"),s("strong",[t._v("单个进程")]),t._v("具有处理"),s("strong",[t._v("多个 IO 事件")]),t._v("的能力. 因此又被称为"),s("strong",[t._v("事件驱动 IO")]),t._v("(Event Driven IO).")]),t._v(" "),s("p",[t._v("如果一个 Web 服务器没有 IO 复用, 那么"),s("strong",[t._v("每一个 Socket 连接")]),t._v("都需要创建一个"),s("strong",[t._v("线程")]),t._v("去处理. 如果同时有"),s("strong",[t._v("几万个")]),t._v("连接, 那么就需要创建相同数量的线程. 相比多进程和多线程技术, "),s("strong",[t._v("IO 复用不需要进程线程创建和切换的开销")]),t._v(", 系统开销更小.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220528180300053.png",alt:"",title:"多路复用IO"}})]),t._v(" "),s("p",[t._v("IO 复用的"),s("strong",[t._v("优势在于能够处理更多的连接")]),t._v(", 但是对单个连接的处理不一定比阻塞 IO 快. 对于"),s("strong",[t._v("每一个 Socket")]),t._v(", 一般都是设置为"),s("strong",[t._v("非阻塞")]),t._v(", 但是"),s("strong",[t._v("整个用户进程其实是一直被阻塞")]),t._v("的, 只不过进程是"),s("strong",[t._v("被 select 调用")]),t._v("阻塞, 而不是被 Socket IO 阻塞.")]),t._v(" "),s("p",[t._v("典型应用有 "),s("strong",[t._v("Java NIO, Nginx, Netty")]),t._v(". 参考: NIO.")]),t._v(" "),s("h5",{attrs:{id:"_4-信号驱动io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-信号驱动io"}},[t._v("#")]),t._v(" 4.信号驱动IO")]),t._v(" "),s("p",[t._v("应用进程使用 "),s("strong",[t._v("sigaction()")]),t._v("  系统调用, 内核"),s("strong",[t._v("立即")]),t._v("返回, 应用进程"),s("strong",[t._v("可以继续执行")]),t._v(", 所以"),s("strong",[t._v("等待数据")]),t._v("阶段应用进程是"),s("strong",[t._v("非阻塞")]),t._v("的. 内核在数据"),s("strong",[t._v("到达时")]),t._v("向应用进程发送 "),s("strong",[t._v("SIGIO")]),t._v(" 信号, 应用进程收到之后在信号处理程序中调用 "),s("strong",[t._v("recvfrom()")]),t._v("  调用将数据从内核"),s("strong",[t._v("复制")]),t._v("到应用进程中.")]),t._v(" "),s("p",[t._v("相比于非阻塞式 IO 的轮询方式, 信号驱动 IO 的 CPU 利用率更高. 等待数据的时候不是阻塞的, 但是"),s("strong",[t._v("拷贝")]),t._v("数据到应用进程的时候"),s("strong",[t._v("依然是阻塞")]),t._v("的.")]),t._v(" "),s("p",[t._v("这个模型其实"),s("strong",[t._v("用的不太多")]),t._v(".")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220528180344073.png",alt:"",title:"信号驱动IO"}})]),t._v(" "),s("h5",{attrs:{id:"_5-异步io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-异步io"}},[t._v("#")]),t._v(" 5.异步IO")]),t._v(" "),s("p",[s("strong",[t._v("应用进程执行 aio_read() 系统调用会立即返回, 应用进程可以继续执行, 不会被阻塞, 内核自己会等待数据到来并把数据复制到应用进程缓冲区之后会向应用进程发送数据复制完成的信号")]),t._v(".")]),t._v(" "),s("p",[t._v("异步 IO 与信号驱动 IO 的区别在于, "),s("strong",[t._v("异步 IO")]),t._v(" 的信号是通知应用进程 "),s("strong",[t._v("IO 操作已经完成, 数据已经复制到了应用进程缓冲区")]),t._v(", 而"),s("strong",[t._v("信号驱动")]),t._v(" IO 的信号是通知应用进程"),s("strong",[t._v("可以开始 IO")]),t._v(", 也就是通知应用进程"),s("strong",[t._v("可以开始阻塞并拷贝数据")]),t._v("了, 数据得自己拷贝.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220528180421373.png",alt:"",title:"异步IO"}})]),t._v(" "),s("p",[t._v("异步 IO 模型真正实现了异步, 是五种 IO 模型中"),s("strong",[t._v("唯一的异步模型")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("典型应用")]),t._v(": "),s("strong",[t._v("Java7 AIO")]),t._v(", 高性能服务器应用. 参考: AIO.")]),t._v(" "),s("h5",{attrs:{id:"_6-io模型比较🌟"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-io模型比较🌟"}},[t._v("#")]),t._v(" 6.IO模型比较🌟")]),t._v(" "),s("p",[s("strong",[t._v("阻塞式 IO, 非阻塞式 IO, 多路复用 IO 和信号驱动 IO 都是同步 IO")]),t._v(", 它们的主要区别在"),s("strong",[t._v("第一个阶段")]),t._v(", 因为"),s("strong",[t._v("第二阶段")]),t._v("都是"),s("mark",[s("strong",[t._v("阻塞调用 recvfrom()")])]),t._v("​ ** 将数据从内核复制到用户进程**.")]),t._v(" "),s("p",[t._v("非阻塞式 IO, 信号驱动 IO 和异步 IO 在第一阶段不会阻塞.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220528181647796.png",alt:"image-20220528181647796",title:"IO模型对比总结"}})]),t._v(" "),s("h4",{attrs:{id:"多路复用io实现🌟"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多路复用io实现🌟"}},[t._v("#")]),t._v(" 多路复用IO实现🌟")]),t._v(" "),s("p",[s("strong",[t._v("select/poll/epoll 都是多路复用 IO 模型的具体实现")]),t._v(", select 出现的最早, 之后是 poll, 再是 epoll.")]),t._v(" "),s("h5",{attrs:{id:"_1-select"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-select"}},[t._v("#")]),t._v(" 1.select")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("select")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" fd_set "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("readfds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" fd_set "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("writefds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" fd_set "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("exceptfds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("timeval")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("timeout"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("有"),s("strong",[t._v("三种类型")]),t._v("的描述符类型: "),s("strong",[t._v("readset, writeset, exceptset")]),t._v(", 分别对应读, 写, 异常条件的描述符集合. fd_set 使用"),s("strong",[t._v("数组")]),t._v("实现, 数组大小使用 FD_SETSIZE 定义. "),s("strong",[t._v("timeout")]),t._v(" 为超时参数, "),s("strong",[t._v("调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout")]),t._v(". 成功调用返回结果大于 0, 出错返回结果为 -1, 超时返回结果为 0.")]),t._v(" "),s("h5",{attrs:{id:"_2-poll"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-poll"}},[t._v("#")]),t._v(" 2.poll")]),t._v(" "),s("h6",{attrs:{id:"_1-基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础"}},[t._v("#")]),t._v(" (1)基础")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("poll")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("pollfd")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("fds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" nfds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" timeout"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("结构体 pollfd 使用"),s("strong",[t._v("链表实现")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_2-select与poll比较"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-select与poll比较"}},[t._v("#")]),t._v(" (2)select与poll比较")]),t._v(" "),s("blockquote",[s("p",[t._v("功能")])]),t._v(" "),s("p",[t._v("select 和 poll 的功能"),s("strong",[t._v("基本相同")]),t._v(", 不过在一些实现细节上有所不同.")]),t._v(" "),s("ul",[s("li",[t._v("select 会"),s("strong",[t._v("修改描述符")]),t._v(", 而 poll 不会;")]),t._v(" "),s("li",[s("strong",[t._v("select")]),t._v(" 的"),s("strong",[t._v("描述符类型")]),t._v("使用"),s("strong",[t._v("数组实现")]),t._v(", FD_SETSIZE 大小默认为 "),s("strong",[t._v("1024")]),t._v(", 因此默认"),s("strong",[t._v("只能监听 1024 个描述符")]),t._v(". 如果要监听更多描述符的话, 需要修改 FD_SETSIZE 之后"),s("strong",[t._v("重新编译")]),t._v("; 而 "),s("strong",[t._v("poll")]),t._v(" 的"),s("strong",[t._v("描述符类型")]),t._v("使用"),s("strong",[t._v("链表实现")]),t._v(", 没有描述符数量的限制;")]),t._v(" "),s("li",[t._v("poll 提供了更多的"),s("strong",[t._v("事件类型")]),t._v(", 并且对描述符的"),s("strong",[t._v("重复利用")]),t._v("上比 select 高.")]),t._v(" "),s("li",[t._v("如果一个线程对某个描述符调用了 select 或者 poll, 另一个线程关闭了该描述符, 会导致调用结果不确定.")])]),t._v(" "),s("blockquote",[s("p",[t._v("速度")])]),t._v(" "),s("p",[t._v("select 和 poll 速度"),s("strong",[t._v("都比较慢")]),t._v(".")]),t._v(" "),s("ul",[s("li",[t._v("select 和 poll "),s("strong",[t._v("每次调用")]),t._v("都需要将"),s("strong",[t._v("全部描述符")]),t._v("从应用进程缓冲区复制到"),s("strong",[t._v("内核")]),t._v("缓冲区.")]),t._v(" "),s("li",[t._v("select 和 poll 的返回结果中没有声明哪些描述符已经准备好, 所以如果返回值大于 0 时, 应用进程都需要使用"),s("strong",[t._v("轮询")]),t._v("的方式来找到 IO 完成的描述符.")])]),t._v(" "),s("blockquote",[s("p",[t._v("可移植性")])]),t._v(" "),s("p",[t._v("几乎"),s("strong",[t._v("所有的")]),t._v("系统都"),s("strong",[t._v("支持 select")]),t._v(", 但是只有"),s("strong",[t._v("比较新的")]),t._v("系统支持 "),s("strong",[t._v("poll")]),t._v(".")]),t._v(" "),s("h5",{attrs:{id:"_3-epoll"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-epoll"}},[t._v("#")]),t._v(" 3.epoll")]),t._v(" "),s("h6",{attrs:{id:"_1-基础-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础-2"}},[t._v("#")]),t._v(" (1)基础")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("epoll_create")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("epoll_ctl")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" epfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" op"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" fd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("epoll_event")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("event"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("epoll_wait")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" epfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("epoll_event")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" events"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" maxevents"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" timeout"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[s("strong",[t._v("epoll_ctl()")]),t._v("  用于向内核注册"),s("strong",[t._v("新的")]),t._v("描述符或者是改变某个文件描述符的"),s("strong",[t._v("状态")]),t._v(". 已注册的"),s("strong",[t._v("描述符")]),t._v("在内核中会被维护在一棵"),s("strong",[t._v("红黑树")]),t._v("上, 通过"),s("strong",[t._v("回调函数")]),t._v("内核会将 IO 准备好的"),s("strong",[t._v("描述符")]),t._v("加入到一个"),s("strong",[t._v("链表")]),t._v("中管理, 进程调用 epoll_wait() 便可以得到"),s("strong",[t._v("事件完成")]),t._v("的描述符. "),s("strong",[t._v("通过")]),t._v("​"),s("mark",[s("strong",[t._v("红黑树和双向链")])]),t._v("​"),s("strong",[t._v("表数据结构, 并结合回调机制, 造就了 epoll 的高效")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("epoll 只需要将描述符从进程缓冲区向内核缓冲区")]),t._v("​"),s("mark",[s("strong",[t._v("拷贝一次")])]),t._v(", 并且进程"),s("strong",[t._v("不需要通过轮询")]),t._v("来获得事件"),s("strong",[t._v("完成的描述符")]),t._v(".")]),t._v(" "),s("p",[s("strong",[t._v("epoll 仅适用于 Linux")]),t._v(". "),s("strong",[t._v("epoll 比 select 和 poll 更加灵活")]),t._v("而且"),s("strong",[t._v("没有描述符数量限制")]),t._v(". epoll 对"),s("strong",[t._v("多线程编程更有友好")]),t._v(", 一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也"),s("strong",[t._v("不会")]),t._v("产生像 select 和 poll 的不确定情况.")]),t._v(" "),s("h6",{attrs:{id:"_2-epoll工作模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-epoll工作模式"}},[t._v("#")]),t._v(" (2)epoll工作模式")]),t._v(" "),s("p",[s("strong",[t._v("epoll")]),t._v(" 的描述符事件有"),s("strong",[t._v("两种触发模式")]),t._v(": "),s("strong",[t._v("LT")]),t._v("(level trigger) 和 "),s("strong",[t._v("ET")]),t._v("(edge trigger).")]),t._v(" "),s("blockquote",[s("p",[t._v("水平触发模式")])]),t._v(" "),s("p",[t._v("epoll_wait() 函数为 epoll 系列主要系统调用函数, 它在"),s("strong",[t._v("一段超时时间内等待一组文件描述符上的事件")]),t._v(". 此函数成功返回时返回"),s("strong",[t._v("就绪网络事件的个数")]),t._v('. 可以设置 "timout" 参数, 其单位是毫秒, 在这个时间内 epoll_wait() 系统调用将被阻塞.')]),t._v(" "),s("p",[t._v("当 epoll_wait() 检测到"),s("strong",[t._v("描述符事件到达")]),t._v("时, 将此"),s("mark",[s("strong",[t._v("事件通知进程, 进程可以不立即处理该事件")])]),t._v(", 下次调用 epoll_wait() 会"),s("strong",[t._v("再次通知进程")]),t._v(". 是"),s("strong",[t._v("默认")]),t._v("的一种模式, 并且同时支持 "),s("strong",[t._v("Blocking")]),t._v(" 和 "),s("strong",[t._v("No-Blocking")]),t._v(".")]),t._v(" "),s("blockquote",[s("p",[t._v("边沿触发模式")])]),t._v(" "),s("p",[t._v("和水平触发模式不同的是, "),s("mark",[s("strong",[t._v("通知之后进程必须立即处理事件")])]),t._v(", 下次再调用 epoll_wait() 时"),s("strong",[t._v("不会")]),t._v("再得到事件到达的通知. 这种模式很大程度上"),s("strong",[t._v("减少了 epoll 事件被重复触发的次数")]),t._v(", 因此效率要比 LT 模式高. "),s("strong",[t._v("只支持 No-Blocking")]),t._v("(可以理解为马上就需要处理所以是非阻塞), 以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死.")]),t._v(" "),s("h5",{attrs:{id:"_4-应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-应用场景"}},[t._v("#")]),t._v(" 4.应用场景")]),t._v(" "),s("p",[t._v("不要认为 select 和 poll 都已经过时只用 epoll 就可以, 它们都有各自的使用场景.")]),t._v(" "),s("h6",{attrs:{id:"_1-select应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-select应用场景"}},[t._v("#")]),t._v(" (1)select应用场景")]),t._v(" "),s("p",[t._v("select 的 timeout 参数"),s("strong",[t._v("精度为 1ns")]),t._v(", 而 poll 和 epoll 为 "),s("strong",[t._v("1ms")]),t._v(", 因此 "),s("strong",[t._v("select 更加适用于实时性要求比较高")]),t._v("的场景, 比如核反应堆的控制.")]),t._v(" "),s("p",[s("strong",[t._v("select 可移植性更好")]),t._v(", 几乎被"),s("strong",[t._v("所有主流平台")]),t._v("所支持.")]),t._v(" "),s("h6",{attrs:{id:"_2-poll应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-poll应用场景"}},[t._v("#")]),t._v(" (2)poll应用场景")]),t._v(" "),s("p",[t._v("poll "),s("strong",[t._v("没有最大描述符数量的限制")]),t._v(", 如果"),s("strong",[t._v("平台支持")]),t._v("并且对"),s("strong",[t._v("实时性要求不高")]),t._v(", 应该使用 "),s("strong",[t._v("poll")]),t._v(" 而非 select.")]),t._v(" "),s("h6",{attrs:{id:"_3-epoll应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-epoll应用场景"}},[t._v("#")]),t._v(" (3)epoll应用场景")]),t._v(" "),s("p",[t._v("只需要运行在 "),s("strong",[t._v("Linux")]),t._v(" 上, 有"),s("strong",[t._v("大量的描述符")]),t._v("需要同时轮询, 并且这些连接最好是"),s("strong",[t._v("长连接")]),t._v(".")]),t._v(" "),s("p",[t._v("如果需要同时监控"),s("strong",[t._v("小于 1000")]),t._v(" 个描述符, 就"),s("strong",[t._v("没有必要")]),t._v("使用 epoll, 因为这个应用场景下并不能体现 epoll 的优势. 需要监控的描述符状态"),s("strong",[t._v("变化多")]),t._v(", 而且都是非常短暂的, 也"),s("strong",[t._v("没有必要")]),t._v("使用 epoll. 因为 epoll 中的所有描述符都存储在内核中, 造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用, 频繁系统调用降低效率. 并且 epoll 的描述符存储在内核, 不容易调试.")]),t._v(" "),s("p",[t._v("‍")]),t._v(" "),s("p",[t._v("‍")]),t._v(" "),s("h4",{attrs:{id:"参考资料"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),s("ul",[s("li",[t._v("Stevens W R, Fenner B, Rudoff A M. UNIX network programming[M]. Addison-Wesley Professional, 2004.")]),t._v(" "),s("li",[s("a",{attrs:{href:"https://www.ibm.com/developerworks/linux/library/l-async/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Boost application performance using asynchronous I/O"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://msdn.microsoft.com/en-us/library/windows/desktop/aa365683(v=vs.85).aspx",target:"_blank",rel:"noopener noreferrer"}},[t._v("Synchronous and Asynchronous I/O"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://segmentfault.com/a/1190000003063859",target:"_blank",rel:"noopener noreferrer"}},[t._v("Linux IO 模式及 select, poll, epoll 详解"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://daniel.haxx.se/docs/poll-vs-select.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("poll vs select vs event-based"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"http://www.ulduzsoft.com/2014/01/select-poll-epoll-practical-difference-for-system-architects/",target:"_blank",rel:"noopener noreferrer"}},[t._v("select / poll / epoll: practical difference for system architects"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Browse the source code of userspace/glibc/sysdeps/unix/sysv/linux/ online"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=r.exports}}]);