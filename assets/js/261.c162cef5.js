(window.webpackJsonp=window.webpackJsonp||[]).push([[261],{591:function(_,v,t){"use strict";t.r(v);var s=t(4),r=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"_4-最小生成树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-最小生成树"}},[_._v("#")]),_._v(" 4.最小生成树")]),_._v(" "),v("h5",{attrs:{id:"_1-概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[_._v("#")]),_._v(" 1.概述")]),_._v(" "),v("p",[_._v("给无向图的每一条边加上"),v("strong",[_._v("权重")]),_._v(", 就得到了加权无向图.")]),_._v(" "),v("p",[v("strong",[_._v("最小生成树: 图的生成树是它的一棵含有所有顶点的无环连通子图. 加权图的最小生成树(MST)是它的一棵权值之和最小的生成树")]),_._v(".")]),_._v(" "),v("p",[_._v("最小生成树算法有"),v("strong",[_._v("很多应用")]),_._v(", 比如顶点是城市, 边是城市之间的航线, 那么最小生成树可以看作覆盖这些城市做需要的"),v("strong",[_._v("最短总航线")]),_._v(".")]),_._v(" "),v("p",[_._v("下面先来看基本的实现原理.")]),_._v(" "),v("h5",{attrs:{id:"_2-切分定理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-切分定理"}},[_._v("#")]),_._v(" 2.切分定理")]),_._v(" "),v("ul",[v("li",[_._v("切分: 将图的"),v("strong",[_._v("顶点集")]),_._v("分为两个非空并且没有交集的集合. 下图即切分为"),v("strong",[_._v("白色和灰色")]),_._v("两部分的顶点.")]),_._v(" "),v("li",[v("strong",[_._v("横切边")]),_._v(": 链接两个属于不同集合的顶点的边. (下图的红色边)")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1577432773034.png",alt:""}})]),_._v(" "),v("p",[v("strong",[_._v("切分定理")]),_._v(": 在一副加权图中, 给定"),v("strong",[_._v("任意的切分")]),_._v(", "),v("strong",[_._v("它的横切边中的")]),_._v("​**==权重最小者=="),v("strong",[_._v("​")]),_._v("必然属于图中的最小生成树**.")]),_._v(" "),v("p",[_._v("=="),v("strong",[_._v("权重最小的横切边必然属于最小生成树. ​")]),_._v("==")]),_._v(" "),v("h5",{attrs:{id:"_3-最小生成树的贪心算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-最小生成树的贪心算法"}},[_._v("#")]),_._v(" 3.最小生成树的贪心算法")]),_._v(" "),v("p",[_._v("贪心思想: "),v("strong",[_._v("==使用切分定理找到最小生成树的一条边, 不断重复直到找到最小生成树的所有边=="),v("strong",[_._v("​")]),_._v(". ​")])]),_._v(" "),v("p",[_._v("贪心算法是所有最小生成树算法的基础, 基本原理就是从"),v("strong",[_._v("一个点")]),_._v("开始, 以已经找到的最小生成树的顶点, 和其他顶点作为一个切分, "),v("strong",[_._v("找出权重最小的横切边")]),_._v(", 加入最小生成树, 不断进行下去, 直到包含了所有顶点.")]),_._v(" "),v("p",[_._v("过程如下:")]),_._v(" "),v("p",[_._v("将含有 V 个顶点的任意加权连通图中"),v("strong",[_._v("属于")]),_._v("最小生成树的"),v("strong",[_._v("边标记为黑色")]),_._v(".")]),_._v(" "),v("ol",[v("li",[_._v("初始状态下所有"),v("strong",[_._v("边均为灰色")]),_._v(", 找到一种切分, 它产生的横切边"),v("strong",[_._v("均不为黑色")]),_._v(".")]),_._v(" "),v("li",[_._v("将它"),v("strong",[_._v("权重最小")]),_._v("的横切边标记为"),v("strong",[_._v("黑色")]),_._v(".")]),_._v(" "),v("li",[_._v("反复, 直到标记了 "),v("strong",[_._v("V-1 条黑色")]),_._v("边为止.")])])])}),[],!1,null,null,null);v.default=r.exports}}]);