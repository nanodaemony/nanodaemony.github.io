(window.webpackJsonp=window.webpackJsonp||[]).push([[176],{505:function(_,t,v){"use strict";v.r(t);var r=v(4),s=Object(r.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"_1001-数据库面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1001-数据库面试题"}},[_._v("#")]),_._v(" 1001.数据库面试题")]),_._v(" "),t("h4",{attrs:{id:"一条sql语句执行得很慢的原因有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一条sql语句执行得很慢的原因有哪些"}},[_._v("#")]),_._v(" 一条SQL语句执行得很慢的原因有哪些?")]),_._v(" "),t("p",[_._v("分以下两种情况来讨论. "),t("strong",[_._v("1. 大多数情况是正常的, 只是偶尔会出现很慢的情况. 2. 在数据量不变的情况下, 这条 SQL 语句一直都执行的很慢.")])]),_._v(" "),t("h5",{attrs:{id:"_1-偶尔很慢的情况"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-偶尔很慢的情况"}},[_._v("#")]),_._v(" 1.偶尔很慢的情况")]),_._v(" "),t("p",[_._v("一条 SQL 大多数情况正常, 偶尔才能出现很慢的情况, 针对这种情况, 这条 SQL 语句本身应该是没什么问题的, 可能是其他原因导致慢查询的.")]),_._v(" "),t("h6",{attrs:{id:"_1-等待数据库刷新脏页"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-等待数据库刷新脏页"}},[_._v("#")]),_._v(" (1)等待数据库刷新脏页")]),_._v(" "),t("p",[_._v("当需要往数据库插入或更新一条数据的时候, 数据库会在"),t("strong",[_._v("内存")]),_._v("中把对应字段的数据更新了. 但更新之后, 这些更新的字段并不会马上同步持久化到"),t("strong",[_._v("磁盘")]),_._v("中去, 而是把这些"),t("strong",[_._v("更新的记录写入到 redo log 日志")]),_._v("中去, 等到"),t("strong",[_._v("空闲")]),_._v("的时候, 再通过 redo log 里的日志把最新的数据同步到"),t("strong",[_._v("磁盘")]),_._v("中去.")]),_._v(" "),t("p",[_._v("当"),t("strong",[_._v("内存数据页")]),_._v("跟"),t("strong",[_._v("磁盘数据页")]),_._v('内容不一致的时候, 可以称这个内存页为 "'),t("strong",[_._v("脏页")]),_._v('". 内存数据写入到磁盘后, 内存和磁盘上的数据页的内容就一致了, 称为 "'),t("strong",[_._v("干净页")]),_._v('". 偶尔执行很慢可能是数据库在'),t("strong",[_._v("刷脏页")]),_._v(". 刷脏页有下面 4 种场景(后两种一般不会导致查询变慢):")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("redo log 写满: ​")]),_._v("​"),t("strong",[t("strong",[_._v("redo log 里的容量是有限的, 如果数据库一直很忙, 更新又很频繁, 这个时候 redo log 很快就会被写满, 这个时候只能暂停其他操作来把")])]),_._v("​"),t("strong",[_._v("数据同步到磁盘中")]),_._v("去的, 而这个时候, "),t("strong",[_._v("就可能导致平时正常的 SQL 语句突然执行的很慢")]),_._v(".")]),_._v(" "),t("li",[t("strong",[_._v("内存不够用了: ​")]),_._v("​"),t("strong",[t("strong",[_._v("如果一次查询较多的数据, 恰好碰到所查")])]),_._v("​"),t("strong",[_._v("数据页不在内存中")]),_._v("时, 需要申请内存, 而此时恰好内存不足的时候就需要"),t("strong",[_._v("淘汰一部分内存数据页")]),_._v(", 如果是干净页, 就直接释放, 如果恰好是脏页就需要刷脏页.")]),_._v(" "),t("li",[_._v("此外还有 "),t("strong",[_._v('MySQL 认为系统 "空闲" 的时候: ​')]),_._v("这时系统没什么压力. 以及 "),t("strong",[_._v("MySQL 正常关闭的时候: ​")]),_._v("这时候, MySQL 会把内存的脏页都 flush 到磁盘上, 这样下次 MySQL 启动的时候, 就可以直接从磁盘上读数据, 启动速度会很快.")])]),_._v(" "),t("h6",{attrs:{id:"_2-等待锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-等待锁"}},[_._v("#")]),_._v(" (2)等待锁")]),_._v(" "),t("p",[_._v("如果要执行的语句所涉及到的"),t("strong",[_._v("表")]),_._v("别人在用, 并且"),t("strong",[_._v("加锁")]),_._v("了, 拿不到锁的时候就只能慢慢等待锁的释放. 如果要判断是否真的在等待锁, 可以用 "),t("strong",[_._v("show processlist")]),_._v(" 这个命令来查看当前的状态.")]),_._v(" "),t("h5",{attrs:{id:"_2-一直都很慢的情况"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-一直都很慢的情况"}},[_._v("#")]),_._v(" 2.一直都很慢的情况")]),_._v(" "),t("h6",{attrs:{id:"_1-索引失效"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-索引失效"}},[_._v("#")]),_._v(" (1)索引失效")]),_._v(" "),t("p",[_._v("SQL 操作的字段"),t("strong",[_._v("没有建立索引")]),_._v(", 只能走全表扫描. 也可能建立了索引但是因为一些原因导致"),t("strong",[_._v("索引失效")]),_._v(".")]),_._v(" "),t("h4",{attrs:{id:"如何解决秒杀的性能问题和超卖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何解决秒杀的性能问题和超卖"}},[_._v("#")]),_._v(" 如何解决秒杀的性能问题和超卖?")]),_._v(" "),t("p",[_._v("抢订单环节一般会带来高并发与超卖的问题.")]),_._v(" "),t("h5",{attrs:{id:"_1-使用redis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-使用redis"}},[_._v("#")]),_._v(" 1.使用Redis")]),_._v(" "),t("p",[_._v("将存库 MySQL 前移到 Redis 中, 所有的"),t("strong",[_._v("写操作放到内存")]),_._v("中, 由于 Redis 中"),t("strong",[_._v("不存在锁")]),_._v("故不会出现互相等待, 并且由于 Redis 的写性能和读性能都远高于 MySQL, 这就解决了"),t("strong",[_._v("高并发")]),_._v("下的性能问题. 然后通过"),t("strong",[_._v("队列等异步手段")]),_._v(", 将"),t("strong",[_._v("变化的数据异步写入到 DB 中.")])]),_._v(" "),t("p",[_._v("优点: 解决性能问题. 缺点: 没有解决超卖问题, 同时由于异步写入 DB, 存在某一时刻 DB 和 Redis 中"),t("strong",[_._v("数据不一致")]),_._v("的风险.")]),_._v(" "),t("h5",{attrs:{id:"_2-使用消息队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用消息队列"}},[_._v("#")]),_._v(" 2.使用消息队列")]),_._v(" "),t("p",[t("strong",[_._v("引入消息队列, 然后将所有写 DB 操作在消息队列中排队, 完全串行处理. 当达到库存阀值的时候就不在消费队列, 并关闭购买功能. 这就解决了超卖问题.")])]),_._v(" "),t("p",[_._v("优点: 解决超卖问题, 略微提升性能. 缺点: 性能受限于队列处理机处理性能和 DB 的写入性能中最短的那个, 另外多商品同时抢购的时候需要准备"),t("strong",[_._v("多条队列")]),_._v(".")]),_._v(" "),t("h5",{attrs:{id:"_3-两段式提交"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-两段式提交"}},[_._v("#")]),_._v(" 3.两段式提交")]),_._v(" "),t("p",[_._v("将"),t("strong",[_._v("提交操作变成两段式")]),_._v(", "),t("strong",[_._v("先申请后确认")]),_._v(". 然后利用 Redis 的"),t("strong",[_._v("原子自增操作")]),_._v("(相比较 MySQL 的自增来说没有空洞), 同时利用 Redis 的事务特性来发号, "),t("strong",[_._v("保证拿到小于等于库存阀值的号的人都可以成功提交订单")]),_._v(". 然后数据"),t("strong",[_._v("异步")]),_._v("更新到 DB 中.")]),_._v(" "),t("p",[_._v("优点: 解决超卖问题, 库存读写都在内存中, 故同时解决性能问题. 缺点: 由于异步写入 DB, 可能存在数据不一致. 另可能存在少买, 也就是如果拿到号的人不真正下订单, 可能库存减为 0, 但是订单数并没有达到库存阀值.")]),_._v(" "),t("h4",{attrs:{id:"为什么不建议亿级大表使用innodb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么不建议亿级大表使用innodb"}},[_._v("#")]),_._v(" 为什么不建议亿级大表使用InnoDB?")]),_._v(" "),t("p",[_._v("百万数据和亿级数据可能 B+tree 都需要三层 tree, 但因为百万千万数据的"),t("strong",[_._v("索引空间少")]),_._v(", 可以更多的放到"),t("strong",[_._v("内存中")]),_._v(", 速度也就相应快. 亿级表只能放很小的一部分, 万一不中缓存, 那么就要走更多的磁盘 IO. 说白了主要就是 "),t("strong",[_._v("innodb_buffer_pool 缓存")]),_._v("不够.")]),_._v(" "),t("p",[_._v("参考: "),t("a",{attrs:{href:"http://xiaorui.cc/2016/12/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AEinnodb%E4%BD%BF%E7%94%A8%E4%BA%BF%E7%BA%A7%E5%A4%A7%E8%A1%A8/",target:"_blank",rel:"noopener noreferrer"}},[_._v("为什么不建议innodb使用亿级大表 | 峰云就她了"),t("OutboundLink")],1)]),_._v(" "),t("p",[_._v("‍")]),_._v(" "),t("h4",{attrs:{id:"参考资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[_._v("#")]),_._v(" 参考资料")]),_._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/waGRvyhab2z8b-BIw9bJeA",target:"_blank",rel:"noopener noreferrer"}},[_._v("库存扣多了, 到底怎么整 | 架构师之路"),t("OutboundLink")],1)]),_._v(" "),t("li",[t("a",{attrs:{href:"https://blog.csdn.net/zhoudaxia/article/details/38067003",target:"_blank",rel:"noopener noreferrer"}},[_._v("如何解决秒杀的性能问题和超卖的讨论 - CSDN博客"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=s.exports}}]);