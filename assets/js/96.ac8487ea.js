(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{409:function(_,v,t){"use strict";t.r(v);var r=t(7),s=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"_1001-数据库综合问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1001-数据库综合问题"}},[_._v("#")]),_._v(" 1001.数据库综合问题")]),_._v(" "),v("h4",{attrs:{id:"一条sql语句执行得很慢的原因有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一条sql语句执行得很慢的原因有哪些"}},[_._v("#")]),_._v(" 一条SQL语句执行得很慢的原因有哪些?")]),_._v(" "),v("p",[_._v("分以下两种情况来讨论.")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("大多数情况是正常的, 只是偶尔会出现很慢的情况.")])]),_._v(" "),v("li",[v("strong",[_._v("在数据量不变的情况下, 这条 SQL 语句一直都执行的很慢")]),_._v(".")])]),_._v(" "),v("h5",{attrs:{id:"_1-偶尔很慢的情况"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-偶尔很慢的情况"}},[_._v("#")]),_._v(" 1.偶尔很慢的情况")]),_._v(" "),v("p",[_._v("一条 SQL 大多数情况正常, 偶尔才能出现很慢的情况, 针对这种情况, 这条 SQL 语句本身应该是没什么问题的, 可能是其他原因导致慢查询的.")]),_._v(" "),v("blockquote",[v("p",[_._v("等待数据库刷新脏页")])]),_._v(" "),v("p",[_._v("当需要往数据库插入或更新一条数据的时候, 数据库会在"),v("strong",[_._v("内存")]),_._v("中把对应字段的数据更新了. 但更新之后, 这些更新的字段并不会马上同步持久化到"),v("strong",[_._v("磁盘")]),_._v("中去, 而是把这些"),v("strong",[_._v("更新的记录写入到 redo log 日志")]),_._v("中去, 等到"),v("strong",[_._v("空闲")]),_._v("的时候, 再通过 redo log 里的日志把最新的数据同步到"),v("strong",[_._v("磁盘")]),_._v("中去.")]),_._v(" "),v("p",[_._v("当"),v("strong",[_._v("内存数据页")]),_._v("跟"),v("strong",[_._v("磁盘数据页")]),_._v('内容不一致的时候, 可以称这个内存页为 "'),v("strong",[_._v("脏页")]),_._v('". 内存数据写入到磁盘后, 内存和磁盘上的数据页的内容就一致了, 称为 "'),v("strong",[_._v("干净页")]),_._v('".')]),_._v(" "),v("p",[_._v("因此, 偶尔执行很慢可能是数据库在"),v("strong",[_._v("刷脏页")]),_._v(". 刷脏页有下面几种场景(最后两种一般不会导致查询变慢):")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("redo log 写满:")]),_._v(" "),v("strong",[v("strong",[_._v("redo log 里的容量是有限的, 如果数据库一直很忙, 更新又很频繁, 这个时候 redo log 很快就会被写满, 这个时候只能暂停其他操作来把")])]),_._v("​"),v("strong",[_._v("数据同步到磁盘中")]),_._v("去的, 而这个时候, "),v("strong",[_._v("就可能导致平时正常的 SQL 语句突然执行的很慢")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("内存不够用了:")]),_._v(" "),v("strong",[v("strong",[_._v("如果一次查询较多的数据, 恰好碰到所查")])]),_._v("​"),v("strong",[_._v("数据页不在内存中")]),_._v("时, 需要申请内存, 而此时恰好内存不足的时候就需要"),v("strong",[_._v("淘汰一部分内存数据页")]),_._v(", 如果是干净页, 就直接释放, 如果恰好是脏页就需要刷脏页.")]),_._v(" "),v("li",[_._v("MySQL 认为系统空闲的时候.")]),_._v(" "),v("li",[_._v("MySQL 正常关闭的时候.")])]),_._v(" "),v("blockquote",[v("p",[_._v("等待锁")])]),_._v(" "),v("p",[_._v("如果要执行的语句所涉及到的"),v("strong",[_._v("表")]),_._v("别人在用, 并且"),v("strong",[_._v("加锁")]),_._v("了, 拿不到锁的时候就只能慢慢等待锁的释放. 如果要判断是否真的在等待锁, 可以用 "),v("strong",[_._v("show processlist")]),_._v(" 这个命令来查看当前的状态.")]),_._v(" "),v("h5",{attrs:{id:"_2-一直都很慢的情况"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-一直都很慢的情况"}},[_._v("#")]),_._v(" 2.一直都很慢的情况")]),_._v(" "),v("p",[_._v("SQL 操作的字段可能"),v("strong",[_._v("没有建立索引")]),_._v(", 只能走全表扫描. 也可能建立了索引但是因为一些原因导致"),v("strong",[_._v("索引失效")]),_._v(". 也有可能是数据量过大导致.")]),_._v(" "),v("h4",{attrs:{id:"如何解决秒杀的性能问题和超卖"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何解决秒杀的性能问题和超卖"}},[_._v("#")]),_._v(" 如何解决秒杀的性能问题和超卖?")]),_._v(" "),v("p",[_._v("抢订单环节一般会带来高并发与超卖的问题, 这会对数据库造成很大的压力.")]),_._v(" "),v("blockquote",[v("p",[_._v("使用Redis")])]),_._v(" "),v("p",[_._v("将存库 MySQL 前移到 Redis 中, 所有的"),v("strong",[_._v("写操作放到内存")]),_._v("中, 由于 Redis 中"),v("strong",[_._v("不存在锁")]),_._v("故不会出现互相等待, 并且由于 Redis 的写性能和读性能都远高于 MySQL, 这就解决了"),v("strong",[_._v("高并发")]),_._v("下的性能问题. 然后通过"),v("strong",[_._v("队列等异步手段")]),_._v(", 将"),v("strong",[_._v("变化的数据异步写入到 DB 中.")])]),_._v(" "),v("p",[_._v("优点: 解决性能问题. 缺点: 没有解决超卖问题, 同时由于异步写入 DB, 存在某一时刻 DB 和 Redis 中"),v("strong",[_._v("数据不一致")]),_._v("的风险.")]),_._v(" "),v("blockquote",[v("p",[_._v("使用消息队列")])]),_._v(" "),v("p",[v("strong",[_._v("引入消息队列, 然后将所有写 DB 操作在消息队列中排队, 完全串行处理. 当达到库存阀值的时候就不在消费队列, 并关闭购买功能. 这就解决了超卖问题.")])]),_._v(" "),v("p",[_._v("优点: 解决超卖问题, 略微提升性能. 缺点: 性能受限于队列处理机处理性能和 DB 的写入性能中最短的那个, 另外多商品同时抢购的时候需要准备"),v("strong",[_._v("多条队列")]),_._v(".")]),_._v(" "),v("blockquote",[v("p",[_._v("两段式提交")])]),_._v(" "),v("p",[_._v("将"),v("strong",[_._v("提交操作变成两段式")]),_._v(", "),v("strong",[_._v("先申请后确认")]),_._v(". 然后利用 Redis 的"),v("strong",[_._v("原子自增操作")]),_._v("(相比较 MySQL 的自增来说没有空洞), 同时利用 Redis 的事务特性来发号, "),v("strong",[_._v("保证拿到小于等于库存阀值的号的人都可以成功提交订单")]),_._v(". 然后数据"),v("strong",[_._v("异步")]),_._v("更新到 DB 中.")]),_._v(" "),v("p",[_._v("优点: 解决超卖问题, 库存读写都在内存中, 故同时解决性能问题. 缺点: 由于异步写入 DB, 可能存在数据不一致. 另可能存在少买, 也就是如果拿到号的人不真正下订单, 可能库存减为 0, 但是订单数并没有达到库存阀值.")]),_._v(" "),v("h4",{attrs:{id:"为什么不建议亿级大表使用innodb"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么不建议亿级大表使用innodb"}},[_._v("#")]),_._v(" 为什么不建议亿级大表使用InnoDB?")]),_._v(" "),v("p",[_._v("百万数据和亿级数据可能 B+tree 都需要三层 tree, 但因为千万级数据的"),v("strong",[_._v("索引空间相对少")]),_._v(", 可以在内存中加载更多的索引, 查询的速度也就相应快. 而亿级表的索引数据量可能很大，万一无法命中内存中的索引缓存, 那就要走更多的磁盘 IO. 说白了主要就是 "),v("strong",[_._v("innodb_buffer_pool 缓存")]),_._v("不够.")]),_._v(" "),v("p",[_._v("参考: "),v("a",{attrs:{href:"http://xiaorui.cc/2016/12/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AEinnodb%E4%BD%BF%E7%94%A8%E4%BA%BF%E7%BA%A7%E5%A4%A7%E8%A1%A8/",target:"_blank",rel:"noopener noreferrer"}},[_._v("为什么不建议innodb使用亿级大表"),v("OutboundLink")],1)]),_._v(" "),v("p",[_._v("‍")]),_._v(" "),v("p",[_._v("‍")]),_._v(" "),v("p",[_._v("‍")]),_._v(" "),v("h4",{attrs:{id:"参考资料"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[_._v("#")]),_._v(" 参考资料")]),_._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://mp.weixin.qq.com/s/waGRvyhab2z8b-BIw9bJeA",target:"_blank",rel:"noopener noreferrer"}},[_._v("库存扣多了,到底怎么整"),v("OutboundLink")],1)]),_._v(" "),v("li",[v("a",{attrs:{href:"https://blog.csdn.net/zhoudaxia/article/details/38067003",target:"_blank",rel:"noopener noreferrer"}},[_._v("如何解决秒杀的性能问题和超卖的讨论"),v("OutboundLink")],1)])]),_._v(" "),v("p",[_._v("‍")])])}),[],!1,null,null,null);v.default=s.exports}}]);