(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{423:function(_,v,t){"use strict";t.r(v);var s=t(7),r=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"_320-mysql架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_320-mysql架构"}},[_._v("#")]),_._v(" 320.MySQL架构")]),_._v(" "),v("h4",{attrs:{id:"分库分表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分库分表"}},[_._v("#")]),_._v(" 分库分表")]),_._v(" "),v("p",[_._v("当 MySQL "),v("strong",[_._v("单表记录数过大")]),_._v("时, 数据库的性能会明显下降, 可以进行"),v("strong",[_._v("分库分表")]),_._v("操作.")]),_._v(" "),v("h5",{attrs:{id:"_1-切分方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-切分方式"}},[_._v("#")]),_._v(" 1.切分方式")]),_._v(" "),v("p",[_._v("分库分表可以进行水平切分与垂直切分.")]),_._v(" "),v("h6",{attrs:{id:"垂直切分"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垂直切分"}},[_._v("#")]),_._v(" 垂直切分")]),_._v(" "),v("p",[v("strong",[_._v("按照表中数据列的维度，通过相关性、重要性等依据进行拆分")]),_._v(". 简单来说垂直拆分是指数据表列的拆分, 把一张列比较多的表拆分为多张表. 通常是按照列的"),v("strong",[_._v("关系密集程度")]),_._v("进行切分, 也可以利用垂直切分将"),v("strong",[_._v("经常被使用的列和不经常被使用的列")]),_._v("切分到不同的表中.")]),_._v(" "),v("p",[_._v("例如, 用户表中既有用户登录信息又有用户基本信息, 可以将用户不同信息拆分成两个单独的表, 甚至放到单独的库做分库.")]),_._v(" "),v("p",[_._v("​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20240824170630-o94c9cq.png",alt:"image"}}),_._v("​")]),_._v(" "),v("p",[_._v("如果一个表中某个字段的"),v("strong",[_._v("内容长度过长")]),_._v(", 通常需要单独切分出去, 比如 TEXT 类型的字段, 可以考虑单独切分.")]),_._v(" "),v("blockquote",[v("p",[_._v("优缺点分析")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("垂直拆分的优点")]),_._v(": 可以使得列数据变小, 在查询时减少读取的 Block 数, 减少 I/O 次数. 垂直分区可以简化表的结构, 易于维护.")]),_._v(" "),v("li",[v("strong",[_._v("垂直拆分的缺点")]),_._v(": "),v("strong",[_._v("主键会出现冗余")]),_._v(", 需要管理冗余列, 可能引起 "),v("strong",[_._v("JOIN 操作")]),_._v(", 可以通过在"),v("strong",[_._v("应用层进行 JOIN")]),_._v(" 来解决. 垂直切分会让事务变得更加复杂.")])]),_._v(" "),v("h6",{attrs:{id:"水平切分-sharding"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#水平切分-sharding"}},[_._v("#")]),_._v(" 水平切分(Sharding)")]),_._v(" "),v("p",[v("strong",[_._v("水平切分(Sharding)指保持数据表结构不变, 通过某种策略存储数据分片")]),_._v(". 可以用于解决单表数据量过大的问题。"),v("mark",[v("strong",[_._v("水平切分的过程通常也叫 Sharding")])]),_._v(".")]),_._v(" "),v("p",[_._v("水平切分后每一片数据分散到不同的"),v("strong",[_._v("数据表或库")]),_._v("中, 达到分布式的目的. 水平拆分后所有库表的数据加起来就是全部数据. 水平拆分将数据均匀放更多的库里, 用多个库来扛更高的并发, 还有就是用多个库的存储容量来进行扩容.")]),_._v(" "),v("p",[_._v("比如一个数据表有 1000W 条数据，可以按照 userId 的维度将表分成 8 张，每张表 125W 数据。")]),_._v(" "),v("p",[_._v("​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20240824170735-85ub34w.png",alt:"image"}}),_._v("​")]),_._v(" "),v("h6",{attrs:{id:"小结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[_._v("#")]),_._v(" 小结")]),_._v(" "),v("p",[_._v("水平切分和垂直切分是可以同时进行的，分库和分表也是可以同时进行的，本质都是降低单表、单库的压力。当一个表的数据不断增多时, Sharding 是必然的选择, 它可以将数据分布到集群的不同节点上, 从而缓解"),v("strong",[_._v("单个数据库")]),_._v("的压力. 需要注意分表仅仅是"),v("strong",[_._v("解决了单一表数据过大")]),_._v("的问题, 但由于表的数据还是在"),v("strong",[_._v("同一台机器")]),_._v("上, 这对于提升 MySQL 并发能力没有什么意义, 所以"),v("strong",[_._v("水平拆分通常也要分库")]),_._v(".")]),_._v(" "),v("p",[_._v("数据量小的时候不用拆分, 因为拆分会带来"),v("mark",[v("strong",[_._v("逻辑, 部署, 运维的各种复杂度")])]),_._v(", 一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的.")]),_._v(" "),v("h5",{attrs:{id:"_3-sharding策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-sharding策略"}},[_._v("#")]),_._v(" 3.Sharding策略")]),_._v(" "),v("p",[_._v("水平切分可以有不同的策略.")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("哈希取模")]),_._v(": "),v("strong",[_._v("hash(key) % N")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("范围")]),_._v(": 可以是 "),v("strong",[_._v("ID 范围")]),_._v("也可以是"),v("strong",[_._v("时间范围")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("映射表")]),_._v(": 使用"),v("strong",[_._v("单独")]),_._v("的一个数据库来存储映射关系.")]),_._v(" "),v("li",[v("strong",[_._v("根据字段特点分")]),_._v(": 比如主键是"),v("strong",[_._v("身份证号")]),_._v(", 就可以根据身份证号的特点来依据地域或者出生年月分. 但需要考虑数据的分布情况.")])]),_._v(" "),v("p",[_._v("需要注意的是有些策略很容易产生"),v("strong",[_._v("热点问题")]),_._v(", 导致大量的流量全部打到一个表上.")]),_._v(" "),v("h5",{attrs:{id:"_4-分库分表中间件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-分库分表中间件"}},[_._v("#")]),_._v(" 4.分库分表中间件")]),_._v(" "),v("p",[_._v("常见的分库分表中间件有: Sharding-JDBC, Mycat, Cobar, Atlas 等. 这些中间件可以在分库分表之后, "),v("strong",[_._v("根据指定的某个字段值")]),_._v("如 userId, "),v("strong",[_._v("自动路由到对应的库与表上去")]),_._v(".")]),_._v(" "),v("blockquote",[v("p",[_._v("数据库分片方案")])]),_._v(" "),v("p",[_._v("以下是数据库分片的两种常见实现方案:")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("客户端代理")]),_._v(": 数据"),v("strong",[_._v("分片逻辑在应用端")]),_._v(", 封装在 jar 包中, 通过修改或者封装 JDBC 层来实现. 如 "),v("strong",[_._v("ShardingJDBC")]),_._v(", 阿里的 TDDL 是两种比较常用的实现.")]),_._v(" "),v("li",[v("strong",[_._v("中间件代理")]),_._v(": 在应用和数据中间加了一个"),v("strong",[_._v("代理层")]),_._v(", 分片逻辑统一维护在"),v("strong",[_._v("中间件服务")]),_._v("中. 如 Mycat 就是这种方案的实现.")])]),_._v(" "),v("h6",{attrs:{id:"_1-shardingjdbc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-shardingjdbc"}},[_._v("#")]),_._v(" (1)ShardingJDBC")]),_._v(" "),v("p",[_._v("属于 "),v("strong",[_._v("client 层")]),_._v("方案, 是 "),v("strong",[_._v("ShardingSphere 的 client 层方案")]),_._v(", 这种方案的"),v("strong",[_._v("优点在于不用部署, 运维成本低, 不需要代理层的二次转发请求, 性能很高")]),_._v(". 但如果遇到升级时需要各个系统都重新升级版本再发布, 各个系统都需要"),v("strong",[_._v("耦合")]),_._v(" ShardingJDBC 的依赖.")]),_._v(" "),v("h6",{attrs:{id:"_2-mycat"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-mycat"}},[_._v("#")]),_._v(" (2)Mycat")]),_._v(" "),v("p",[_._v("属于 "),v("strong",[_._v("Proxy 层")]),_._v("方案, 功能非常完善. 这种 Proxy 层方案的难点在于"),v("strong",[_._v("需要部署")]),_._v(", 自己运维一套中间件, 运维成本高. "),v("strong",[_._v("好处在于对于各个项目是透明的")]),_._v(", 如果遇到升级之类的都是中间件的事.")]),_._v(" "),v("h6",{attrs:{id:"_3-选型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-选型"}},[_._v("#")]),_._v(" (3)选型")]),_._v(" "),v("p",[_._v("建议"),v("strong",[_._v("中小型公司选用 ShardingJDBC")]),_._v(", client 层方案轻便, 而且维护成本低, 而且中小型公司系统复杂度会低一些, 项目也没那么多.")]),_._v(" "),v("p",[v("strong",[_._v("中大型公司可以选用 Mycat 这类 Proxy 层")]),_._v("方案, 大公司可以有专门团队研究和维护 Mycat, 大量项目直接透明使用即可.")]),_._v(" "),v("h4",{attrs:{id:"读写分离"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#读写分离"}},[_._v("#")]),_._v(" 读写分离")]),_._v(" "),v("p",[_._v("MySQL 的读写分离架构就是: "),v("strong",[_._v("主服务器处理写操作以及实时性要求比较高的读操作, 而从服务器处理读操作")]),_._v(".")]),_._v(" "),v("p",[_._v("读写分离能提高性能的原因:")]),_._v(" "),v("ul",[v("li",[_._v("主从服务器负责各自的读和写, 极大程度缓解了锁的争用.")]),_._v(" "),v("li",[_._v("从服务器可以提升查询性能以及节约系统开销, 降低了整体的负载.")]),_._v(" "),v("li",[_._v("增加冗余, 提高可用性.")])]),_._v(" "),v("p",[_._v("读写分离常用代理方式来实现, "),v("strong",[_._v("代理服务器")]),_._v("接收应用层传来的"),v("strong",[_._v("读写请求")]),_._v(", 然后决定转发到哪个服务器, 如下图所示.")]),_._v(" "),v("p",[_._v("​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563519716630.png",alt:"1563519716630"}}),_._v("​")]),_._v(" "),v("p",[_._v("实现读写分离的关键就在于"),v("strong",[_._v("保证从服务器的数据和主服务器是一致")]),_._v("的, 这需要依赖"),v("strong",[_._v("主从复制")]),_._v("来实现.")]),_._v(" "),v("h4",{attrs:{id:"主从复制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主从复制"}},[_._v("#")]),_._v(" 主从复制")]),_._v(" "),v("h5",{attrs:{id:"基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[_._v("#")]),_._v(" 基础")]),_._v(" "),v("p",[v("strong",[_._v("主从复制解决的是让一台服务器的数据与其他服务器保持一致的问题")]),_._v(". 一台主库的数据可以同步到多台备库上, 备库本身也可以被配置成另外一台服务器的主库. 主库和备库之间可以有多种不同的组合方式.")]),_._v(" "),v("p",[v("strong",[_._v("复制通常不会增加主库的开销, 主要是启用二进制日志带来的开销, 但出于备份或及时从崩溃中恢复的目的, 这点开销也是必要的")]),_._v(". 除此之外, 每个备库也会对主库增加一些负载(例如网络 I/O 开销), 尤其当备库请求从主库读取旧的二进制日志文件时, 可能会造成更高的 I/O 开销. 另外锁竞争也可能阻碍事务的提交. 最后, 如果是从一个高吞吐量(例如 5000 或更高的 TPS)的主库上复制到多个备库, 唤醒多个复制线程发送事件的开销将会累加.")]),_._v(" "),v("blockquote",[v("p",[_._v("主从复制拓扑")])]),_._v(" "),v("p",[_._v("可以在任意个主库和备库之间建立复制, 只有一个限制: "),v("strong",[_._v("每一个从库只能有一个主库")]),_._v(".")]),_._v(" "),v("p",[_._v("基本原则:")]),_._v(" "),v("ul",[v("li",[_._v("一个从库实例只能有一个主库.")]),_._v(" "),v("li",[_._v("每个从库必须有一个唯一的服务器 ID.")]),_._v(" "),v("li",[_._v("一个主库可以有多个从库.")]),_._v(" "),v("li",[_._v("如果打开了 log_slave_updates 选项, 一个从库可以把其主库上的数据变化传播到其他从库.")])]),_._v(" "),v("h5",{attrs:{id:"主从复制参数配置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主从复制参数配置"}},[_._v("#")]),_._v(" 主从复制参数配置")]),_._v(" "),v("p",[_._v("有许多参数来控制复制, 其中一些会对数据安全和性能产生影响.")]),_._v(" "),v("p",[_._v("在主库上二进制日志最重要的选项是 "),v("strong",[_._v("sync_binlog")]),_._v(":")]),_._v(" "),v("div",{staticClass:"language-sql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[_._v("sync_binlog"),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("1")]),_._v("\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])]),v("p",[_._v("如果开启该选项, "),v("mark",[v("strong",[_._v("MySQL 每次在提交事务前会将二进制日志同步到磁盘上, 保证在服务器崩溃时不会丢失事务")])]),_._v(". 如果禁止该选项, 服务器会少做一些工作, 但二进制日志文件可能在服务器崩溃时损坏或丢失信息. 在一个不需要作为主库的备库上, 该选项带来了不必要的开销. 它只适用于二进制日志, 而非中继日志.")]),_._v(" "),v("h5",{attrs:{id:"复制流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#复制流程"}},[_._v("#")]),_._v(" 复制流程")]),_._v(" "),v("p",[_._v("主从复制的主体流程如下:")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("在主库上把数据更改记录到二进制归档日志(binlog)中")]),_._v("(这些记录被称为二进制日志事件), binlog 参考: 二进制归档日志(binlog).")]),_._v(" "),v("li",[v("strong",[_._v("从库将主库上的日志复制到自己的中继日志(Relay Log)中")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("从库读取中继日志中的事件, 将其重放到从库数据之上")]),_._v(".")])]),_._v(" "),v("p",[_._v("下面的图是主节点复制数据给从节点.")]),_._v(" "),v("p",[_._v("​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563519695873.png",alt:""}}),_._v("​")]),_._v(" "),v("p",[_._v("具体来说：")]),_._v(" "),v("ul",[v("li",[_._v("第一步, "),v("strong",[_._v("在主库上记录二进制日志(binlog)")]),_._v(" . 在每次准备提交事务完成数据更新前, 主库将数据更新的事件记录到二进制日志中. MySQL 会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志. "),v("strong",[_._v("在记录二进制日志后, 主库会告诉存储引擎可以提交事务了")]),_._v(".")]),_._v(" "),v("li",[_._v("第二步, "),v("strong",[_._v("备库将主库的 binlog 复制到其本地的中继日志中")]),_._v(". 首先, 备库会启动一个工作线程, 称为 I/O 线程, I/O 线程跟主库建立一个普通的客户端连接, 然后在主库上启动一个特殊的"),v("strong",[_._v("二进制转储(binlog dump)线程")]),_._v("(该线程没有对应的 SQL 命令), 这个二进制转储线程会读取主库上二进制日志中的事件. 它不会对事件进行轮询. 如果该线程追赶上了主库, 它将进入睡眠状态, 直到主库发送信号量通知其有新的事件产生时才会被唤醒, "),v("strong",[_._v("备库 I/O 线程会将接收到的事件记录到中继日志中")]),_._v(".")]),_._v(" "),v("li",[_._v("第三步, "),v("strong",[_._v("备库的 SQL 线程从中继日志中读取事件并在备库执行, 从而实现备库数据的重放更新")]),_._v(". 当 SQL 线程追赶上 I/O 线程时, 中继日志通常已经在系统缓存中, 所以中继日志的开销很低.")])]),_._v(" "),v("p",[_._v("这种复制架构实现了"),v("strong",[_._v("获取事件和重放事件")]),_._v("的解耦, 允许这两个过程异步进行. 也就是说 I/O 线程能够独立于 SQL 线程之外工作. 但这种架构也限制了复制的过程, 其中"),v("strong",[_._v("最重要的一点是在")]),_._v("​"),v("mark",[v("strong",[_._v("主库上并发运行的操作在备库只能串行化执行")])]),_._v(", 因为"),v("strong",[_._v("只有一个 SQL 线程来重放中继日志中的事件")]),_._v(", 这是很多工作负载的性能瓶颈所在.")]),_._v(" "),v("blockquote",[v("p",[_._v("相关线程总结")])]),_._v(" "),v("p",[_._v("主从复制主要涉及三个线程: "),v("strong",[_._v("binlog 线程, I/O 线程和 SQL 线程")]),_._v(".")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("binlog 线程(主库的线程)")]),_._v(" : 负责将"),v("strong",[_._v("主库上的数据")]),_._v("更改写入主库的"),v("strong",[_._v("二进制日志")]),_._v("(binlog)中.")]),_._v(" "),v("li",[v("strong",[_._v("I/O 线程(从库的线程)")]),_._v(" : 负责"),v("strong",[_._v("从主库上读取二进制日志")]),_._v(", 并写入从库的"),v("strong",[_._v("中继日志")]),_._v("(Relay log).")]),_._v(" "),v("li",[v("strong",[_._v("SQL 线程(从库的线程)")]),_._v(" : 负责"),v("strong",[_._v("读取中继日志")]),_._v(", 解析出主库已经执行的数据更改并在"),v("strong",[_._v("从库中执行")]),_._v(".")])]),_._v(" "),v("h5",{attrs:{id:"复制方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#复制方式"}},[_._v("#")]),_._v(" 复制方式")]),_._v(" "),v("p",[_._v("MySQL 支持两种复制方式: "),v("strong",[_._v("基于行的复制和基于语句的复制")]),_._v(". 这两种方式都是通过"),v("mark",[v("strong",[_._v("在主库上记录二进制日志, 在备库重放日志的方式来实现异步的数据复制")])]),_._v(".")]),_._v(" "),v("p",[_._v("主库记录 binlog 的日志格式也决定了主从复制的方式(参考: binlog的日志格式).")]),_._v(" "),v("p",[_._v("相应的, 复制方式有下面几种:")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("基于语句的复制")]),_._v(": 主库会"),v("strong",[_._v("记录那些造成数据更改的查询 SQL 语句")]),_._v(", 当备库读取并重放这些事件时, 实际上只是"),v("strong",[_._v("把主库上执行过的 SQL 再执行一遍")]),_._v(". 但是对于执行获取时间戳这种函数时, 可能出现主从数据不一致.")]),_._v(" "),v("li",[v("strong",[_._v("基于行的复制")]),_._v(": 基于行的复制方式会将"),v("strong",[_._v("实际数据记录在二进制日志")]),_._v("中. 如果修改较大(比如全表更新), 会造成记录的数据很大.")]),_._v(" "),v("li",[v("strong",[_._v("混合复制方式")]),_._v(": 由于没有哪种模式对所有情况都是完美的, "),v("strong",[_._v("MySQL 能够在这两种复制模式间动态切换")]),_._v(". 默认情况下使用的是基于语句的复制方式, 但如果发现语句无法被正确地复制, 就切换到基于行的复制模式.")])]),_._v(" "),v("blockquote",[v("p",[_._v("复制方式的选择")])]),_._v(" "),v("p",[_._v("不同的复制方式记录的日志格式, 日志数量也会不同. 理论上基于"),v("strong",[_._v("行的复制模式整体上更优")]),_._v(", 并且在实际应用中也适用于大多数场景.")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("基于语句的方式执行复制的过程基本上就是执行 SQL 语句")]),_._v(". 这意味着所有在服务器上发生的变更都以一种容易理解的方式运行. 这样当出现问题时可以很好地去定位. 但如果正在使用触发器或者存储过程, 就不要使用基于语句的复制模式, 除非能够清楚地确定不会碰到复制问题.")]),_._v(" "),v("li",[v("strong",[_._v("基于行的复制模式能处理几乎所有的场景")]),_._v(". 基于行的复制模式会记录数据变更, 因此在二进制日志中记录的都是实际上在主库上发生了变化的数据.")])]),_._v(" "),v("h5",{attrs:{id:"主从延迟问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主从延迟问题"}},[_._v("#")]),_._v(" 主从延迟问题")]),_._v(" "),v("p",[_._v("主从复制的过程决定了在同一时间点备库上的数据可能与主库存在不一致, 并且无法保证主备之间的延迟. 一些大的语句可能导致备库产生几秒, 几分钟甚至几个小时的延迟. 这就带来了主从延迟问题。")]),_._v(" "),v("p",[v("strong",[_._v("主从延迟问题")]),_._v(": 从库同步主库数据的过程是串行化的, 也就是说主库上并行的操作, 在从库上会串行执行. 所以由于从库从主库拷贝日志以及串行执行 SQL 的特点, 在高并发场景下, 从库的数据一定会比主库慢一些, 是"),v("strong",[_._v("有延时")]),_._v("的. 所以经常出现刚写入主库的数据可能是读不到的, 要过几十毫秒甚至几百毫秒才能读取到的问题，这就是主从延迟问题.")]),_._v(" "),v("p",[_._v("主从延迟就可能导致主从数据不一致, 可能导致"),v("strong",[_._v("写后读的场景")]),_._v("下读不到数据或者读到错误的数据.")]),_._v(" "),v("blockquote",[v("p",[_._v("主从延迟解决方法")])]),_._v(" "),v("p",[_._v("一般来说, 如果主从延迟较为严重, 有以下解决方案:")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("进行分库")]),_._v(". 将一个主库拆分为多个主库, 每个主库的写并发就减少了几倍, 可以降低主从延迟时间.")]),_._v(" "),v("li",[v("strong",[_._v("打开并行复制, 多个库并行复制")]),_._v(". 如果某个库的写入并发就是特别高, 单库写并发达到了 2000/s, 并行复制还是没意义.")]),_._v(" "),v("li",[_._v("某些"),v("strong",[_._v("写后读")]),_._v("的场景可以考虑"),v("strong",[_._v("强制读主库")]),_._v(".")])]),_._v(" "),v("h4",{attrs:{id:"mysql高可用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql高可用"}},[_._v("#")]),_._v(" MySQL高可用")]),_._v(" "),v("p",[v("strong",[_._v("高可用性实际上是在宕机造成的损失与降低宕机时间所花费的成本之间取一个平衡")]),_._v(". 换句话说, 如果需要花大量金钱去获得更好的可用时间, 但所带来的收益却很低, 可能就不值得去做.")]),_._v(" "),v("blockquote",[v("p",[_._v("如何实现高可用")])]),_._v(" "),v("p",[_._v("可以通过同时进行以下两步来获得高可用性.")]),_._v(" "),v("p",[_._v("首先, "),v("strong",[_._v("可以尝试避免导致宕机的原因来减少宕机时间")]),_._v(". 许多问题其实很容易避免, 例如通过适当的配置, 监控, 以及规范或安全保障措施来避免人为错误.")]),_._v(" "),v("p",[_._v("第二, "),v("strong",[_._v("尽量保证在发生宕机时能够快速恢复")]),_._v(". 最常见的策略是在系统中制造"),v("strong",[_._v("冗余")]),_._v(", 并且具备"),v("strong",[_._v("故障转移")]),_._v("能力.")]),_._v(" "),v("p",[_._v("这两个维度的高可用性可以通过两个相关的度量来确定: 平均失效时间(MTBF)和平均恢复时间(MTTR).")]),_._v(" "),v("p",[_._v("‍")]),_._v(" "),v("p",[_._v("‍")]),_._v(" "),v("h3",{attrs:{id:"参考资料"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[_._v("#")]),_._v(" 参考资料")]),_._v(" "),v("ul",[v("li",[_._v("《高性能 MySQL 第三版》")])]),_._v(" "),v("p",[_._v("‍")]),_._v(" "),v("p",[_._v("‍")])])}),[],!1,null,null,null);v.default=r.exports}}]);