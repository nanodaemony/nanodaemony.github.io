(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{416:function(t,_,s){"use strict";s.r(_);var a=s(7),e=Object(a.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"_230-mysql事务🌟"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_230-mysql事务🌟"}},[t._v("#")]),t._v(" 230.MySQL事务🌟")]),t._v(" "),_("h4",{attrs:{id:"事务基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务基础"}},[t._v("#")]),t._v(" 事务基础")]),t._v(" "),_("h5",{attrs:{id:"_1-基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础"}},[t._v("#")]),t._v(" 1.基础")]),t._v(" "),_("p",[_("strong",[t._v("事务是指满足 ACID 的一组操作, 保证一组 SQL 语句要么全部执行, 要么全部不执行, 用以维护数据库的完整性和数据最终的一致性")]),t._v(". 可以通过 COMMIT "),_("strong",[t._v("提交")]),t._v("一个事务, 也可以通过 ROLLBACK 进行"),_("strong",[t._v("回滚")]),t._v(".")]),t._v(" "),_("p",[t._v("InnoDB 存储引擎提供的是"),_("strong",[t._v("本地事务")]),t._v(", 分布式事务实现则更加复杂.")]),t._v(" "),_("p",[t._v("​"),_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20240824182403-0qdjlqd.png",alt:"image"}}),t._v("​")]),t._v(" "),_("p",[t._v("基本术语:")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("事务")]),t._v("(TRANSACTION): 指一组满足 ACID 条件的 SQL 语句.")]),t._v(" "),_("li",[_("strong",[t._v("回滚")]),t._v("(ROLLBACK): 指撤销指定 SQL 语句的过程.")]),t._v(" "),_("li",[_("strong",[t._v("提交")]),t._v("(COMMIT): 指将未存储的 SQL 语句结果写入数据库表.")]),t._v(" "),_("li",[_("strong",[t._v("保留点")]),t._v("(SAVEPOINT): 指事务处理中设置的"),_("strong",[t._v("临时占位符")]),t._v(", 可以对它发布回退.")])]),t._v(" "),_("h5",{attrs:{id:"_2-事务四大特征"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-事务四大特征"}},[t._v("#")]),t._v(" 2.事务四大特征")]),t._v(" "),_("p",[t._v("事务具有以下 4 个基本属性, 通常简称为事务的 ACID 属性, 即"),_("strong",[t._v("原子性(Atomicity), 一致性(Consistency), 隔离性(Isolation), 持久性(Durability)")]),t._v(" .")]),t._v(" "),_("h6",{attrs:{id:"_1-原子性atomicity"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-原子性atomicity"}},[t._v("#")]),t._v(" (1)原子性Atomicity")]),t._v(" "),_("p",[_("strong",[t._v("原子性指一个事务中的所有操作必须被视为一个不可分割的最小执行单元, 要么全部完成, 要么全部不完成, 不会结束在中间某个环节")]),t._v(". 事务在执行过程中发生错误, 会被"),_("strong",[t._v("回滚")]),t._v("到事务开始前的状态, 就像这个事务从来没有执行过一样.")]),t._v(" "),_("p",[t._v("比如: A 在银行取钱, 密码输入完成还没确定取钱, A 可以决定不取了, 此时回滚到没取的状态.")]),t._v(" "),_("p",[_("strong",[t._v("原子性由回滚日志(undo log)实现")]),t._v(". 参考: 回滚日志.")]),t._v(" "),_("h6",{attrs:{id:"_2-一致性consistency"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-一致性consistency"}},[t._v("#")]),t._v(" (2)一致性Consistency")]),t._v(" "),_("p",[_("strong",[t._v("一致性指数据总是从一个一致性的状态转换到另外一个一致性的状态")]),t._v(". 在一致性状态下, 所有"),_("strong",[t._v("事务对一份数据的读取结果都是相同")]),t._v("的. 在事务开始之前和事务结束以后, 数据库的完整性没有被破坏.")]),t._v(" "),_("p",[_("strong",[t._v("一致性是使用事务的最终目的, 由其它 3 个特性以及业务代码正确逻辑来实现")]),t._v(".")]),t._v(" "),_("p",[t._v("比如: A 向 B 转账, 不可能 A 扣了钱, B 却没有收到.")]),t._v(" "),_("h6",{attrs:{id:"_3-隔离性isolation"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-隔离性isolation"}},[t._v("#")]),t._v(" (3)隔离性Isolation")]),t._v(" "),_("p",[_("strong",[t._v("隔离性指一个事务所做的修改在最终提交以前, 对其它事务是不可见的")]),t._v(". 事务在执行的时候可以隔离其他事务的干扰, 也就是不同事务之间不会相互影响.")]),t._v(" "),_("p",[_("strong",[t._v("数据库允许多个并发事务同时对其数据进行读写和修改, 隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致. 事务隔离分为不同隔离级别, 包括读未提交, 读已提交, 可重复读和串行化")]),t._v(".")]),t._v(" "),_("p",[t._v("比如: A 正在从一张银行卡里面取钱, A 取钱过程中 B 不能向这张银行卡打钱.")]),t._v(" "),_("p",[t._v("隔离性由 MySQL 的各种锁以及 MVCC 机制来实现.")]),t._v(" "),_("h6",{attrs:{id:"_4-持久性durability"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-持久性durability"}},[t._v("#")]),t._v(" (4)持久性Durability")]),t._v(" "),_("p",[_("strong",[t._v("持久性指一旦事务成功提交之后, 它对于数据的修改是永久性的")]),t._v(", 即使出现系统故障也不会丢失.")]),t._v(" "),_("p",[t._v("比如: A 在银行存了钱, 某天断电银行系统宕机, 恢复后钱依然这么多.")]),t._v(" "),_("p",[_("strong",[t._v("持久性由事务日志(redo log)来实现")]),t._v(". 参考: 重做日志(redo log).")]),t._v(" "),_("h6",{attrs:{id:"_5-总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-总结"}},[t._v("#")]),t._v(" (5)总结")]),t._v(" "),_("p",[t._v("​"),_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20250219092109-pi9udth.png",alt:"image"}}),t._v("​")]),t._v(" "),_("p",[t._v("事务的 ACID 特性概念简单, 但不是很好理解, 主要是因为这几个特性"),_("strong",[t._v("不是一种平级关系")]),t._v(":")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("只有满足一致性, 事务的执行结果才是正确的")]),t._v(".")]),t._v(" "),_("li",[t._v("在无并发的情况下, 事务串行执行, 隔离性一定能够满足. 此时只要能满足原子性, 就一定能满足一致性.")]),t._v(" "),_("li",[t._v("在并发的情况下, 多个事务并行执行, 事务不仅要满足原子性, 还需要满足隔离性, 才能满足一致性.")]),t._v(" "),_("li",[t._v("事务满足持久性是为了能应对数据库崩溃的情况.")])]),t._v(" "),_("h5",{attrs:{id:"_3-事务基本使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-事务基本使用"}},[t._v("#")]),t._v(" 3.事务基本使用")]),t._v(" "),_("h6",{attrs:{id:"_1-隐式事务autocommit"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-隐式事务autocommit"}},[t._v("#")]),t._v(" (1)隐式事务AUTOCOMMIT")]),t._v(" "),_("p",[t._v("隐式事务也就是没有明显的开启和结束事务的标志, MySQL "),_("strong",[t._v("默认采用自动提交模式")]),t._v(". 如果不显式使用 "),_("strong",[t._v("START TRANSACTION")]),t._v(" 语句来开始一个事务, 那么"),_("strong",[t._v("每个查询都会被当做一个事务自动提交")]),t._v(".")]),t._v(" "),_("p",[t._v("当显式使用 START TRANSACTION 语句时, 会关闭隐式提交; 当执行 COMMIT 或 ROLLBACK 语句后, 事务会"),_("strong",[t._v("自动关闭")]),t._v(", 重新恢复隐式提交. 设置 AUTOCOMMIT 为 0 可以"),_("strong",[t._v("取消自动提交")]),t._v("; AUTOCOMMIT 标记是在每个连接内生效的.")]),t._v(" "),_("p",[t._v("如果没有设置保留点, ROLLBACK 会回退到 START TRANSACTION 语句处; 如果设置了保留点, 并且在 ROLLBACK 中指定该保留点, 则会回退到该保留点.")]),t._v(" "),_("h6",{attrs:{id:"_2-事务相关操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-事务相关操作"}},[t._v("#")]),t._v(" (2)事务相关操作")]),t._v(" "),_("p",[t._v("下面是事务相关的操作语句.")]),t._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" AUTOCOMMIT "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 关闭隐式事务")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("START")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TRANSACTION")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\t"),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 开启显示事务")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("COMMIT")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\t\t\t\t"),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 提交事务")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ROLLBACK")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\t\t\t"),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 回滚事务")]),t._v("\n\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SAVEPOINT")]),t._v(" 断点\t   "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# SAVEPOINT")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("COMMIT")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TO")]),t._v(" 断点\t   "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 提交到SAVEPOINT")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ROLLBACK")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TO")]),t._v(" 断点 \t   "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 回滚到SAVEPOINT")]),t._v("\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br"),_("span",{staticClass:"line-number"},[t._v("6")]),_("br"),_("span",{staticClass:"line-number"},[t._v("7")]),_("br"),_("span",{staticClass:"line-number"},[t._v("8")]),_("br")])]),_("p",[t._v("使用显式事务:")]),t._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 关闭自动提交")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" AUTOCOMMIT "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("START")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TRANSACTION")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\t"),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 开启事务")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 编写一组事务的语句(多条语句)")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),t._v(" account "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" balance "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" username "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Tom'")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),t._v(" account "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" balance "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("3000")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" username "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Jack'")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 回滚")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# ROLLBACK;")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 提交事务")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("COMMIT")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" account"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br"),_("span",{staticClass:"line-number"},[t._v("6")]),_("br"),_("span",{staticClass:"line-number"},[t._v("7")]),_("br"),_("span",{staticClass:"line-number"},[t._v("8")]),_("br"),_("span",{staticClass:"line-number"},[t._v("9")]),_("br"),_("span",{staticClass:"line-number"},[t._v("10")]),_("br"),_("span",{staticClass:"line-number"},[t._v("11")]),_("br"),_("span",{staticClass:"line-number"},[t._v("12")]),_("br"),_("span",{staticClass:"line-number"},[t._v("13")]),_("br")])]),_("p",[t._v("不能回滚 SELECT 语句, 回退 SELECT 语句也没意义; 也不能回滚 CREATE 和 DROP 语句.")]),t._v(" "),_("h4",{attrs:{id:"事务并发一致性问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务并发一致性问题"}},[t._v("#")]),t._v(" 事务并发一致性问题")]),t._v(" "),_("p",[t._v("在无并发情况下, 事务串行执行, 事务的一致性容易保证. 但在并发环境下, 事务之间交替执行, 可能出现多个事务操作同一个数据来完成各自的业务, 事务的隔离性很难保证, 因此会出现很多并发一致性问题. 它主要强调在并发操作状态下可能出现的一致性问题.")]),t._v(" "),_("h5",{attrs:{id:"_1-丢失修改"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-丢失修改"}},[t._v("#")]),t._v(" 1.丢失修改")]),t._v(" "),_("p",[_("strong",[t._v("丢失修改指一个事务的修改覆盖了另一个事务的修改")]),t._v(".")]),t._v(" "),_("p",[t._v("T1 和 T2 两个事务都对一个数据进行修改, T1 先修改, T2 随后修改, T2 的修改覆盖了 T1 的修改, 这样第一个事务的修改就丢失了.")]),t._v(" "),_("p",[t._v("​"),_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20240824183719-nhxvp0a.png",alt:"image"}}),t._v("​")]),t._v(" "),_("h5",{attrs:{id:"_2-脏读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-脏读"}},[t._v("#")]),t._v(" 2.脏读")]),t._v(" "),_("p",[t._v("事务 A 读取到了事务 B "),_("strong",[t._v("已经修改但尚未提交")]),t._v("的数据. 这里强调的是一个事务还没提交的修改就已经能被其他事务读取到了。")]),t._v(" "),_("p",[t._v("T1 修改一个数据, T2 随后读取这个数据. 如果 T1 之后撤销了这次修改 (T1 事务读取了 T2 事务尚未提交的数据), 那么 T2 读取的数据是脏数据.")]),t._v(" "),_("p",[t._v("​"),_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20240824183753-nxcse2h.png",alt:"image"}}),t._v("​")]),t._v(" "),_("p",[t._v("实例: 如下面的"),_("strong",[t._v("取款转账")]),t._v("操作, 按照正确逻辑, 最后的账户余额应该为 "),_("strong",[t._v("4000")]),t._v(" 元, 但是"),_("strong",[t._v("脏读")]),t._v("之后只有 3000 元了.")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"center"}},[t._v("时间线")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("转账事务")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("取款事务")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}}),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("开始事务")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("2")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("开始事务")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("3")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}}),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("查询账户"),_("strong",[t._v("余额为 2000 元")])])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("4")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}}),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[_("strong",[t._v("取款 1000 元")]),t._v(", 余额被更改为 1000 元")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("5")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("查询账户余额为 "),_("strong",[t._v("1000")]),t._v(" 元(产生"),_("strong",[t._v("脏读")]),t._v(")")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("6")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}}),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("取款操作发生未知错误, 事务"),_("strong",[t._v("回滚")]),t._v(", 余额变更为 "),_("strong",[t._v("2000")]),t._v(" 元")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("7")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("存入 2000 元, 余额被更改为 "),_("strong",[t._v("3000")]),t._v(" 元(脏读的1000 + 2000)")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("8")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[_("strong",[t._v("提交事务(脏数据)")])]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}})])])]),t._v(" "),_("h5",{attrs:{id:"_3-不可重复读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-不可重复读"}},[t._v("#")]),t._v(" 3.不可重复读")]),t._v(" "),_("p",[_("strong",[t._v("事务 A 内部的同一条查询语句在不同时刻读出的结果不一致, 即前后多次读取数据的内容不一致")]),t._v(". 这里强调的是一个事务"),_("strong",[t._v("已经提交")]),t._v("，但是会引起另一个事务读取的数据值不一致。")]),t._v(" "),_("p",[t._v("T2 读取一个数据, T1 对该数据做了修改. 如果 T2 "),_("strong",[t._v("在事务提交之前再次读取这个数据")]),t._v(", 此时读取的结果和第一次读取的结果不同.")]),t._v(" "),_("p",[t._v("​"),_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20240824183809-caop622.png",alt:"image"}}),t._v("​")]),t._v(" "),_("p",[t._v("实例: 假设事务 A 在执行"),_("strong",[t._v("读取")]),t._v("操作, 由整个事务 "),_("strong",[t._v("A 操作较多")]),t._v(", 且需要"),_("strong",[t._v("前后")]),t._v("读取同一条数据, 假设两次读取需要经历很长的时间. 如果这时候 B 事务对这个数据进行修改, 就造成了两次读到数据不一致. 按照正确逻辑, 事务 A 前后两次读取到的数据应该一致.")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"center"}},[t._v("时间线")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("事务A(操作多, 持续时间长)")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("事务B")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[_("strong",[t._v("开始事务")])]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("2")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("第一次查询, 小明的年龄为 "),_("strong",[t._v("20")]),t._v(" 岁")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("3")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}}),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[_("strong",[t._v("开始事务")])])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("4")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("其他耗时操作")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("5")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}}),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("更改小明的年龄为 30 岁")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("6")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}}),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[_("strong",[t._v("提交事务")])])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("7")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("第二次查询, 小明的年龄为 30 岁("),_("strong",[t._v("不可重复读")]),t._v(")")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}})])])]),t._v(" "),_("h5",{attrs:{id:"_4-幻读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-幻读"}},[t._v("#")]),t._v(" 4.幻读")]),t._v(" "),_("p",[t._v("事务 A 读取到了事务 B 提交的新增数据.")]),t._v(" "),_("p",[t._v("T1 读取"),_("strong",[t._v("某个范围")]),t._v("的数据, T2 在这个"),_("strong",[t._v("范围内插入新的数")]),t._v("据, T1 再次"),_("strong",[t._v("读取这个范围")]),t._v("(比如年龄小于 50 的范围)的数据, 此时读取的结果和第一次读取的"),_("strong",[t._v("结果不同")]),t._v(".")]),t._v(" "),_("p",[t._v("​"),_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20240824183837-r6aoc3o.png",alt:"image"}}),t._v("​")]),t._v(" "),_("p",[t._v("实例: 事务 A 在执行读取操作, 且需要在前后间隔较长时间内进行两次统计数据的"),_("strong",[t._v("总量")]),t._v(", 前一次查询数据总量后, 此时事务 B 执行了"),_("strong",[t._v("新增")]),t._v("(或删除)数据的操作并提交后, 这个时候"),_("strong",[t._v("事务 A 读取的数据总量和之前统计的不一样")]),t._v(", 就像产生了幻觉一样, 平白无故的"),_("strong",[t._v("多了几条数据")]),t._v(", 发生幻读.")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"center"}},[t._v("时间线")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("事务A")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("事务B")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[_("strong",[t._v("开始事务")])]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("2")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("第一次查询, 数据"),_("strong",[t._v("总量为 100 条")])]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("3")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}}),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[_("strong",[t._v("开始事务")])])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("4")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("其他操作")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("5")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}}),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("新增(删除) "),_("strong",[t._v("50")]),t._v(" 条数据")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("6")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}}),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[_("strong",[t._v("提交事务")])])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("7")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("第二次查询, 数据"),_("strong",[t._v("总量")]),t._v("为 150 条("),_("strong",[t._v("幻读")]),t._v(")")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}})])])]),t._v(" "),_("blockquote",[_("p",[t._v("不可重复读和幻读的区别")])]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("不可重复读的重点是修改同一条数据")]),t._v(", 比如多次读取一条记录发现其中的数据值被修改.")]),t._v(" "),_("li",[_("strong",[t._v("幻读的重点是新增或者删除范围内的数据")]),t._v(", 比如多次读取某个范围的记录发现"),_("strong",[t._v("范围内")]),t._v("的记录数量改变了.")])]),t._v(" "),_("h5",{attrs:{id:"_5-总结-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-总结-2"}},[t._v("#")]),t._v(" 5.总结")]),t._v(" "),_("h4",{attrs:{id:"事务隔离级别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离级别"}},[t._v("#")]),t._v(" 事务隔离级别")]),t._v(" "),_("h5",{attrs:{id:"_1-基础-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础-2"}},[t._v("#")]),t._v(" 1.基础")]),t._v(" "),_("p",[t._v("事务在并发下会产生诸多的一致性问题，其主要原因是"),_("strong",[t._v("破坏了事务的隔离性")]),t._v(". 做好并发控制可以解决这些问题。")]),t._v(" "),_("p",[_("mark",[_("strong",[t._v("并发控制可以通过加锁来实现, 但是加锁机制操作需要用户自己控制, 相当复杂. 因此数据库提供了事务的隔离级别, 让用户以一种更轻松的方式处理并发一致性问题")])]),t._v(".")]),t._v(" "),_("p",[t._v("事务隔离级别就是为了解决上面"),_("strong",[t._v("并发一致性")]),t._v("的几种问题(丢失修改, 脏读, 不可重复读, 幻读等)而诞生的. "),_("strong",[t._v("数据库的隔离级别是一组规则, 用来控制并发访问数据库时如何分配, 保护和共享资源")]),t._v(". 不同的隔离级别在不同的并发控制策略之间进行调整, 从而提供了不同的读写隔离级别和安全性. 用人话来说, 就是"),_("strong",[t._v("隔离级别代表了一个事务是否了解别的事务以及了解程度怎么样")]),t._v(".")]),t._v(" "),_("p",[t._v("事务隔离级别越高, 在并发下会产生的问题就越少, 但同时付出的性能消耗也将越大, 因此很多时候必须在"),_("mark",[_("strong",[t._v("并发性和性能之间做一个权衡")])]),t._v(". 所以存在"),_("strong",[t._v("几种事物隔离级别")]),t._v(", 以便让"),_("strong",[t._v("不同的项目可以根据自己项目的并发情况")]),t._v("选择合适的事务隔离级别, 对于在事务隔离级别之外会产生的并发问题, 在代码中做补偿.")]),t._v(" "),_("blockquote",[_("p",[t._v("基本操作")])]),t._v(" "),_("p",[t._v("设置隔离级别:")]),t._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SESSION")]),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GLOBAL")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TRANSACTION")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ISOLATION")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LEVEL")]),t._v(" 隔离级别名"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br")])]),_("p",[t._v("查看隔离级别:")]),t._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" @"),_("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@tx_isolation")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br")])]),_("p",[t._v("每个"),_("strong",[t._v("会话都有自己的事务隔离级别")]),t._v(", 不同的"),_("strong",[t._v("连接")]),t._v("可以设置不同的隔离级别.")]),t._v(" "),_("h5",{attrs:{id:"_2-分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-分类"}},[t._v("#")]),t._v(" 2.分类")]),t._v(" "),_("h6",{attrs:{id:"_1-读未提交-read-uncommitted"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-读未提交-read-uncommitted"}},[t._v("#")]),t._v(" (1)读未提交(READ UNCOMMITTED)")]),t._v(" "),_("p",[t._v("一个事务中对数据的修改, 即使"),_("strong",[t._v("还没有提交, 对其它事务也是可见")]),t._v("的. 问题很多.")]),t._v(" "),_("h6",{attrs:{id:"_2-读已提交-read-committed"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-读已提交-read-committed"}},[t._v("#")]),t._v(" (2)读已提交(READ COMMITTED)")]),t._v(" "),_("p",[_("strong",[t._v("一个事务只能读取其他已经提交的事务所做的修改，也就是一个事务所做的修改在提交之前对其它事务是不可见的")]),t._v(". 解决了"),_("strong",[t._v("脏读")]),t._v("的问题.")]),t._v(" "),_("h6",{attrs:{id:"_3-可重复读-repeatable-read"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-可重复读-repeatable-read"}},[t._v("#")]),t._v(" (3)可重复读(REPEATABLE READ)")]),t._v(" "),_("p",[_("strong",[t._v("保证在同一个事务中多次读取同样数据的结果是一样的, 是默认的隔离级别")]),t._v(".")]),t._v(" "),_("p",[t._v("可重复读解决了脏读与不可重复读问题, 但是"),_("strong",[t._v("理论")]),t._v("上依然不能解决幻读问题. 但是与 SQL 标准不同的是 "),_("mark",[_("strong",[t._v("InnoDB 存储引擎在可重复读事务隔离级别下使用的是 MVCC 实现, 并配合 Next-Key Lock 锁算法, 因此可以解决幻读的问题")])]),t._v(". 所以说 InnoDB 存储引擎的默认支持的可重复读隔离级别已经"),_("strong",[t._v("可以完全保证事务的隔离性要求")]),t._v(", 即达到了 SQL 标准的串行化隔离级别.")]),t._v(" "),_("p",[t._v("可重复读隔离级别在"),_("strong",[t._v("事务开启")]),t._v("的时候, 第一次查询是查的数据库里"),_("strong",[t._v("已提交")]),t._v("的最新数据, 这时候全数据库会有一个"),_("strong",[t._v("快照")]),t._v("(当然并不是真正的生成了一个快照, 这就是 MVCC 机制), 在这个事务之后执行的查询操作都是查快照里的数据, 别的事务不管怎么修改数据对当前这个事务的查询都没有影响, 但是当前事务如果修改了某条数据, "),_("strong",[t._v("那当前事务之后查这条修改的数据就是被修改之后的值, 但是查其它数据依然是从快照里查")]),t._v(", 不受影响.")]),t._v(" "),_("p",[t._v("因为隔离级别越低, 事务请求的锁越少, 所以许多数据库系统的隔离级别都是 "),_("strong",[t._v("READ-COMMITTED(读已提交)")]),t._v(" , 但是 InnoDB 默认使用可重复读并不会有任何性能损失.")]),t._v(" "),_("h6",{attrs:{id:"_4-可串行化-serializable"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-可串行化-serializable"}},[t._v("#")]),t._v(" (4)可串行化(SERIALIZABLE)")]),t._v(" "),_("p",[t._v("强制事务串行执行, 解决一切问题, 但是性能低下. 需要加锁实现. 这种隔离级别并发性极低, 开发中很少会用.")]),t._v(" "),_("h5",{attrs:{id:"_3-总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-总结"}},[t._v("#")]),t._v(" 3.总结")]),t._v(" "),_("p",[_("strong",[t._v("数据库的事务隔离越严格, 并发副作用越小, 但付出的代价也就越大")]),t._v(', 因为事务不同隔离级别其实就是使事务在一定程度上 "串行化" 进行, 这显然与 "并发" 是矛盾的.')]),t._v(" "),_("p",[t._v("同时, "),_("strong",[t._v("不同的应用对读一致性和事务隔离程度的要求也是不同的")]),t._v(', 比如许多应用对 "不可重复读" 和 "幻读" 并不敏感, 可能更关心数据并发访问的能力, 这就需要'),_("strong",[t._v("根据实际的需求选择隔离级别")]),t._v(".")]),t._v(" "),_("p",[t._v("各个隔离级别可以解决的并发一致性问题表如下, 可以根据项目的需求进行选择.")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"center"}},[t._v("隔离级别")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("脏读")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("不可重复读")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("幻读")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("Read uncommitted(读未提交)")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("😱")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("😱")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("😱")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("Read committed("),_("strong",[t._v("读已提交")]),t._v(")")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("😄")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("😱")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("😱")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("Repeatable read("),_("strong",[t._v("可重复读")]),t._v(")")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("😄")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("😄")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("😱")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("Serializable("),_("strong",[t._v("串行化")]),t._v(")")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("😄")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("😄")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("😄")])])])]),t._v(" "),_("p",[t._v("这里尤其要注意一点, 就是"),_("strong",[t._v("理论上来说可重复读是没有解决幻读的. 但是 MySQL 因为使用了临键锁, 因此它的可重复读隔离级别已经解决了幻读问题")]),t._v(".")]),t._v(" "),_("h4",{attrs:{id:"多版本并发控制mvcc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多版本并发控制mvcc"}},[t._v("#")]),t._v(" 多版本并发控制MVCC")]),t._v(" "),_("h5",{attrs:{id:"_0-为什么需要mvcc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_0-为什么需要mvcc"}},[t._v("#")]),t._v(" 0.为什么需要MVCC")]),t._v(" "),_("p",[t._v("前面已经学过了锁, 知道锁本身就是用于并发控制的, 那为什么 InnoDB 还需要引入 MVCC, 读写都加锁不就可以控制住并发吗?")]),t._v(" "),_("p",[_("strong",[t._v("锁确实可以, 但是性能太差")]),t._v(". 数据库和一般的应用有一个很大的区别, 就是"),_("mark",[_("strong",[t._v("数据库即便是读, 也不能被写阻塞住")])]),t._v(". 试想一下, 如果一个线程准备执行 UPDATE 一行数据, 如果这时候阻塞住了所有的 SELECT 语句, 这个性能你能接受吗? 显然接受不了, 所以"),_("mark",[_("strong",[t._v("数据库要有一种机制, 避免读写阻塞")])]),t._v(". 因此这就引入了 MVCC 机制.")]),t._v(" "),_("p",[t._v("此外，前面分析了不同的隔离级别, 这些"),_("strong",[t._v("隔离级别其实也是为了应对不同的并发问题而引入的,  一些隔离级别的实现也是依赖于 MVCC 机制的")]),t._v(".")]),t._v(" "),_("h5",{attrs:{id:"_1-基础-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础-3"}},[t._v("#")]),t._v(" 1.基础")]),t._v(" "),_("p",[_("strong",[t._v("多版本并发控制(Multi-Version Concurrency Control, MVCC) 是 InnoDB 引擎用于控制数据并发访问的协议,")]),t._v(" "),_("strong",[t._v("是 InnoDB 实现隔离级别的一种具体方式, 用于实现提交读和可重复读这两种隔离级别")]),t._v(".")]),t._v(" "),_("p",[_("mark",[_("strong",[t._v("MVCC 主要是借助于版本链来实现的")])]),t._v("​ "),_("strong",[t._v(". 在 InnoDB 引擎里面, 每一行都有两个额外的列, 一个是 trx_id, 代表的是修改这一行数据的事务 ID. 另外一个是 roll_ptr, 代表的是回滚指针. InnoDB 引擎通过回滚指针, 将数据的不同版本串联在一起, 也就是")]),t._v("​"),_("mark",[_("strong",[t._v("版本链")])]),t._v("​ "),_("strong",[t._v(". 这些串联起来的历史版本, 被放到了")]),t._v("​"),_("mark",[_("strong",[t._v("回滚日志")])]),t._v("​ "),_("strong",[t._v("(undolog)里面. 当某一个事务发起查询的时候,")]),t._v(" "),_("mark",[_("strong",[t._v("MVCC 会根据事务的隔离级别来生成不同的 Read View, 从而控制事务查询最终得到的结果")])]),t._v(".")]),t._v(" "),_("p",[t._v("在 MVCC 下, 每个读操作会看到一个一致性的快照(SNAPSHOT), 并且可以实现非阻塞的读. MVCC 允许数据具有多个版本, 这个版本可以是时间戳或者是全局递增的事务 ID. MVCC 是通过保存数据在某个时间点的快照来实现的. 这意味着一个事务无论运行多长时间, 在同一个事务里能够看到数据一致的视图. 不同事务开始的时间不同, 意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的.")]),t._v(" "),_("p",[_("mark",[_("strong",[t._v("MVCC 中的快照点只是解决了并发读的问题, 对于增删改都会使用到数据库中最新的数据. 并发读的是快照")])]),t._v(".")]),t._v(" "),_("p",[t._v("MVCC 只在"),_("strong",[t._v("可重复读和读已提交")]),t._v('两个隔离级别下工作. 其他两个隔离级别都和 MVCC 不兼容, 因为 "读未提交" 隔离级别总是读取最新的数据行, 而不是符合当前事务版本的数据行, '),_("strong",[t._v("无需")]),t._v('使用 MVCC. 而 "串行化" 隔离级别则会对所有读取的行都加锁, 单纯使用 MVCC '),_("strong",[t._v("无法实现")]),t._v(".")]),t._v(" "),_("h5",{attrs:{id:"_2-版本号"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-版本号"}},[t._v("#")]),t._v(" 2.版本号")]),t._v(" "),_("p",[t._v("MVCC 里面有两个事务版本号的概念:")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("系统版本号")]),t._v(": 一个递增的数字, "),_("strong",[t._v("每开始一个新的事务, 系统版本号就会自动递增")]),t._v(".")]),t._v(" "),_("li",[_("strong",[t._v("事务版本号")]),t._v(": 事务开始时对应的"),_("strong",[t._v("系统版本号")]),t._v(".")])]),t._v(" "),_("p",[t._v("​"),_("code",[t._v("BEGIN/START TRANSACTION")]),t._v("​ 语句"),_("strong",[t._v("并不是一个事务")]),t._v("的起点, 在执行到它们之后的第一个操作 InnoDB 表的语句时事务才真正启动, 才会向 MySQL 申请事务 id, MySQL 内部是"),_("strong",[t._v("严格按照事务的启动顺序来分配事务 id 的")]),t._v(".")]),t._v(" "),_("p",[t._v("保存这两个额外系统版本号, 使大多数读操作都可以不用加锁. 这样设计使得读数据操作很简单, 性能很好, 并且也能保证只会读取到符合标准的行.")]),t._v(" "),_("blockquote",[_("p",[t._v("创建与删除版本号")])]),t._v(" "),_("p",[t._v("MVCC 在"),_("strong",[t._v("每行记录后面都保存着两个隐藏的列")]),t._v(", 用来保存"),_("strong",[t._v("两个版本号")]),t._v(":")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("创建版本号")]),t._v(": 表示"),_("strong",[t._v("创建一个数据行的快照时的系统版本号")]),t._v(".")]),t._v(" "),_("li",[_("strong",[t._v("删除版本号")]),t._v(": 表示"),_("strong",[t._v("数据行的过期(删除)系统版本号")]),t._v(".")])]),t._v(" "),_("p",[t._v("其实这两个版本号可以理解成一个"),_("strong",[t._v("事务")]),t._v("的版本号.")]),t._v(" "),_("h5",{attrs:{id:"_3-mvcc实现原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-mvcc实现原理"}},[t._v("#")]),t._v(" 3.MVCC实现原理")]),t._v(" "),_("h6",{attrs:{id:"mvcc与回滚日志"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mvcc与回滚日志"}},[t._v("#")]),t._v(" MVCC与回滚日志")]),t._v(" "),_("p",[_("mark",[_("strong",[t._v("MVCC 使用到的快照存储在 undo log(回滚日志)中, 该日志通过回滚指针把一个数据行(Record) 的所有快照连接起来, 这样数据就可以有多个版本")])]),t._v(". 在每个事务修改完后, MySQL 会保留"),_("strong",[t._v("修改前的数据 undo 回滚日志")]),t._v(", 并且用两个隐藏字段 trx_id 和 roll_pointer 把这些 undo 日志串联起来"),_("strong",[t._v("形成一个历史记录版本链")]),t._v(".")]),t._v(" "),_("h6",{attrs:{id:"read-view"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#read-view"}},[t._v("#")]),t._v(" Read View")]),t._v(" "),_("p",[_("strong",[t._v("Read View 可以理解成是一种可见性规则")]),t._v(". 回滚日志(undo log)里面存放着历史版本的数据, 当事务内部要读取数据的时候, "),_("strong",[t._v("Read View 就被用来控制这个事务应该读取哪个版本的数据")]),t._v(".")]),t._v(" "),_("p",[_("strong",[t._v("Read View 最关键的字段叫做 m_ids, 它代表的是当前已经开始, 但是还没有结束的事务的 ID, 也叫做活跃事务 ID")]),t._v(".")]),t._v(" "),_("p",[t._v("Read View "),_("strong",[t._v("只用于已提交读和可重复读")]),t._v("两个隔离级别, 它用于这两个隔离级别的不同点就在于"),_("strong",[t._v("什么时候生成 Read View")]),t._v(".")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("已提交读")]),t._v(": 事务"),_("strong",[t._v("每次发起查询的时候, 都会重新创建一个新的 Read View")]),t._v(".")]),t._v(" "),_("li",[_("strong",[t._v("可重复读")]),t._v(": 事务"),_("strong",[t._v("开始的时候, 创建出 Read View")]),t._v(".")])]),t._v(" "),_("p",[t._v("已提交读就像你的渣男朋友, 你每次见到他, 他都会换一个新对象; 而可重复读就是一个痴情男, 你每次见到他, 看到的都是他高中时候谈的对象.")]),t._v(" "),_("blockquote",[_("p",[t._v("Read View与已提交读")])]),t._v(" "),_("p",[t._v("在已提交读的隔离级别下, "),_("strong",[t._v("每一次")]),t._v("​"),_("mark",[_("strong",[t._v("查询语句")])]),t._v("​"),_("strong",[t._v("都会重新生成一个 Read View")]),t._v(". 这意味着在事务执行过程中, Read View 是在不断变动的. 现在来看一个例子, 假如现在已经有三个事务了, 状态分别是已提交, 未提交, 未提交.")]),t._v(" "),_("p",[t._v("​"),_("img",{attrs:{src:"/img/28d8fa3fca19cd6aa074060a166949d2-20231223175001-ibvuhun.png",alt:"图片"}}),t._v("​")]),t._v(" "),_("p",[t._v("假如说现在新开了一个事务 A, 分配给它的 ID 是 4. 如果这个时候 A 开始查询 x 的值, 那么 MySQL 会创建一个新的 Read View, 其中 "),_("code",[t._v("m_ids = 2,3")]),t._v("​. 事务 A 发现最后一个已经提交的是事务 "),_("code",[t._v("trx_id = 1")]),t._v("​, 对应的 x 的值是 1. 于是事务 A 读到 x = 1.")]),t._v(" "),_("p",[t._v("​"),_("img",{attrs:{src:"/img/c226080b4a200eeecd01a623365dd2d5-20231223175001-7cjsl5g.png",alt:""}}),t._v("​")]),t._v(" "),_("p",[t._v("如果这个时候事务 2 提交了, 事务 A 再次读取 x, 这个时候 MySQL "),_("strong",[t._v("又会生成一个新的 Read View")]),t._v(" "),_("code",[t._v("m_ids=3")]),t._v("​. 因此事务 A 会读取到 x = 4.")]),t._v(" "),_("p",[t._v("​"),_("img",{attrs:{src:"/img/e2f5cf70f686e1cd9e67b8f90d5e9e4e-20231223175001-zar75y9.png",alt:""}}),t._v("​")]),t._v(" "),_("blockquote",[_("p",[t._v("Read View与可重复读")])]),t._v(" "),_("p",[t._v("在可重复读的隔离级别下, 数据库会"),_("mark",[_("strong",[t._v("在事务开始的时候")])]),t._v("​"),_("strong",[t._v("生成一个 Read View")]),t._v(". 这意味着"),_("strong",[t._v("整个 Read View 在事务执行过程中都是稳定不变的")]),t._v(". 用前面的例子来说明, 就是在事务 A 开始的时候就会创建出来一个 Read View "),_("code",[t._v("m_ids=2,3")]),t._v("​.")]),t._v(" "),_("p",[t._v("​"),_("img",{attrs:{src:"/img/7a7e1a1b069dbab48dbb52939ecffe6c-20231223175001-fj866fo.png",alt:"图片"}}),t._v("​")]),t._v(" "),_("p",[t._v("如果这时候事务 A 去读 x 的数据, 毫无疑问, 读出来的是 x=1.")]),t._v(" "),_("p",[t._v("​"),_("img",{attrs:{src:"/img/c226080b4a200eeecd01a623365dd2d5-20231223175001-7cjsl5g.png",alt:"图片"}}),t._v("​")]),t._v(" "),_("p",[t._v("如果这时候事务 2 提交了, 然后事务 A 想要再去读 x 的值, Read View 不会发生变化, 还是 "),_("code",[t._v("m_ids = 2,3")]),t._v("​. 所以可以看到, 虽然事务 2 提交了, 但是事务 A "),_("strong",[t._v("完全不知道这回事")]),t._v(", 因此它还是读到 x=1.")]),t._v(" "),_("p",[t._v("​"),_("img",{attrs:{src:"/img/9d5c4983202b2077b53579c8eddfc733-20231223175001-p4f0s4e.png",alt:"图片"}}),t._v("​")]),t._v(" "),_("p",[t._v("万一这时候有一个新事务 ID = 5 开始了, 并且也提交了. "),_("strong",[t._v("那么事务 A 并不会读取这个新事务的数据, 因为新事务 ID 已经大于事务 A 的 ID 了(5 > 4)")]),t._v(" , 事务 A 知道这是一个比它还要晚的事务, 所以会忽略新的事务的修改.")]),t._v(" "),_("blockquote",[_("p",[t._v("Read View小结")])]),t._v(" "),_("p",[t._v("下面把前面的内容整合在一起画成了图, 可以参考.")]),t._v(" "),_("p",[t._v("​"),_("img",{attrs:{src:"/img/0370dd5c3b73da1a06e62e175ae2410a-20231223175001-p7klkye.png",alt:"图片"}}),t._v("​")]),t._v(" "),_("p",[t._v("​"),_("img",{attrs:{src:"/img/619e22884e6719182afaf90ba92a4c7a-20231223175001-3rgzq4m.png",alt:"图片"}}),t._v("​")]),t._v(" "),_("p",[t._v("这里只提到了 m_ids, 实际上和 Read View 相关的概念还有三个.")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("m_up_limit_id 是指 m_ids 中的最小值")]),t._v(".")]),t._v(" "),_("li",[_("strong",[t._v("m_low_limit_id 是指下一个分配的事务 ID")]),t._v(".")]),t._v(" "),_("li",[_("strong",[t._v("m_creator_trx_id 当前事务 ID")]),t._v(".")])]),t._v(" "),_("p",[t._v("那么可见性如下图所示:")]),t._v(" "),_("p",[t._v("​"),_("img",{attrs:{src:"/img/cd9e5fc6dccb166f3894ce0a7fb27f19-20231223175001-ykq9vit.png",alt:"图片"}}),t._v("​")]),t._v(" "),_("p",[t._v("m_up_limit_id 在左边, 而 m_low_limit_id 在右边, 不要记错了. 实际上, m_up_limit_id 和 m_low_limit_id 记不住也没关系, 它不影响对 MVCC 和 ReadView 核心逻辑的理解.")]),t._v(" "),_("h5",{attrs:{id:"_4-可重复读的实现过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-可重复读的实现过程"}},[t._v("#")]),t._v(" 4.可重复读的实现过程")]),t._v(" "),_("p",[t._v("下面介绍在"),_("strong",[t._v("可重复读")]),t._v("的隔离级别下, MVCC 的工作流程.")]),t._v(" "),_("p",[t._v("当开始一个事务时, "),_("strong",[t._v("该事务的版本号肯定大于当前所有数据行快照的创建版本号")]),t._v(", 理解这一点很关键. 数据行快照的创建版本号是创建数据行快照时的系统版本号, 系统版本号随着创建事务而递增, 因此新创建一个事务时, 当前这个事务的系统版本号肯定比所有数据行快照的创建版本号都大.")]),t._v(" "),_("h6",{attrs:{id:"_1-insert"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-insert"}},[t._v("#")]),t._v(" (1)INSERT")]),t._v(" "),_("p",[t._v("将当前"),_("strong",[t._v("系统版本号")]),t._v("作为数据行快照的"),_("strong",[t._v("创建版本号")]),t._v(".")]),t._v(" "),_("h6",{attrs:{id:"_2-select"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-select"}},[t._v("#")]),t._v(" (2)SELECT")]),t._v(" "),_("p",[_("strong",[t._v("多个事务必须读取到同一个数据行的快照, 并且这个快照是距离现在最近的一个有效快照")]),t._v(". 但是也有例外, 如果有一个事务"),_("strong",[t._v("正在修改")]),t._v("该数据行, 那么它可以读取事务本身所做的修改, 而"),_("strong",[t._v("不用")]),t._v("和其它事务的读取结果一致.")]),t._v(" "),_("p",[t._v("把"),_("strong",[t._v("没有对一个数据行做修改的事务称为 T, T 所要读取的数据行快照的创建版本号必须小于 T 的版本号")]),t._v(", 因为如果大于或者等于 T 的版本号, 那么表示该数据行快照是其它事务的"),_("strong",[t._v("最新修改")]),t._v(", 因此"),_("strong",[t._v("不能")]),t._v("去读取它. 除此之外, "),_("strong",[t._v("T 所要读取的数据行快照的删除版本号必须大于 T 的版本号")]),t._v(", 因为如果小于等于 T 的版本号, 那么表示该数据行快照是"),_("strong",[t._v("已经被删除")]),t._v("的, 不应该去读取它.")]),t._v(" "),_("ul",[_("li",[t._v("InnoDB 只查找创建版本号早于更当前事务创建版本号的数据行(也就是"),_("strong",[t._v("数据的系统版本号小于或等于事务的系统版本号")]),t._v("), 这样可以确保事务读取的行, 要么是在事务开始前已经存在的, 要么是事务自身插入或者修改过的.")]),t._v(" "),_("li",[_("strong",[t._v("读取行的删除版本要么未定义, 要么大于当前事务版本号")]),t._v(". 这可以确保事务读取到的行, 在事务开始之前未被删除.")])]),t._v(" "),_("h6",{attrs:{id:"_3-delete"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-delete"}},[t._v("#")]),t._v(" (3)DELETE")]),t._v(" "),_("p",[_("strong",[t._v("将当前系统版本号作为数据行快照的删除版本号")]),t._v(".")]),t._v(" "),_("p",[t._v("对于"),_("strong",[t._v("删除")]),t._v("操作, MySQL 底层会记录被删除的数据行的"),_("strong",[t._v("删除事务 id")]),t._v(", 对于"),_("strong",[t._v("更新")]),t._v("操作 MySQL 底层会"),_("strong",[t._v("新增一行相同数据(使用 undoLog 实现)"),_("strong",[t._v("​"),_("strong",[_("strong",[t._v("并记录好对应的")])]),t._v("​")]),t._v("创建事务 id")]),t._v(".")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("创建事务 id <= max (当前事务 id(12), 快照点已提交最大事务 id)")])]),t._v(" "),_("li",[_("strong",[t._v("删除事务 id > max (当前事务 id(12), 快照点已提交最大事务 id)")])])]),t._v(" "),_("h6",{attrs:{id:"_4-update"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-update"}},[t._v("#")]),t._v(" (4)UPDATE")]),t._v(" "),_("p",[t._v("将当前"),_("strong",[t._v("系统版本号")]),t._v("作为更新前的数据行快照的"),_("strong",[t._v("删除版本号")]),t._v(", 并将当前"),_("strong",[t._v("系统版本号")]),t._v("作为更新后的数据行快照的"),_("strong",[t._v("创建版本号")]),t._v(". 可以理解为"),_("strong",[t._v("先执行 DELETE 后执行 INSERT")]),t._v(".")]),t._v(" "),_("h5",{attrs:{id:"_6-快照读与当前读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-快照读与当前读"}},[t._v("#")]),t._v(" 6.快照读与当前读")]),t._v(" "),_("p",[_("mark",[_("strong",[t._v("快照读就是在事务开始的时候创建了一个数据的快照, 在整个事务过程中都读这个快照; 而当前读, 则是每次都去读最新数据")])]),t._v(". MySQL 在可重复读这个隔离级别下, 查询的执行效果和快照读非常接近.")]),t._v(" "),_("h6",{attrs:{id:"_1-快照读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-快照读"}},[t._v("#")]),t._v(" (1)快照读")]),t._v(" "),_("p",[t._v("就是"),_("strong",[t._v("普通的 SELECT 语句, 这时使用 MVCC 读取的是快照中的数据")]),t._v(", 这样可以"),_("strong",[t._v("减少加锁")]),t._v("所带来的开销.")]),t._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLE")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br")])]),_("h6",{attrs:{id:"_2-当前读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-当前读"}},[t._v("#")]),t._v(" (2)当前读")]),t._v(" "),_("p",[_("strong",[t._v("读取的是最新的数据, 需要加锁")]),t._v(". 以下第一个语句需要加 S 锁, 其它都需要加 X 锁(参考: 共享锁与排他锁(读写锁)).")]),t._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 加读锁")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLE")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" ? "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LOCK")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("IN")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SHARE")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("MODE")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n"),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 下面都是加写锁")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLE")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" ? "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FOR")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("        \n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INSERT")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DELETE")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br"),_("span",{staticClass:"line-number"},[t._v("6")]),_("br"),_("span",{staticClass:"line-number"},[t._v("7")]),_("br")])]),_("h4",{attrs:{id:"事务优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务优化"}},[t._v("#")]),t._v(" 事务优化")]),t._v(" "),_("h5",{attrs:{id:"_1-大事务的影响"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-大事务的影响"}},[t._v("#")]),t._v(" 1.大事务的影响")]),t._v(" "),_("ul",[_("li",[t._v("并发情况下, 数据库连接池容易被撑爆")]),t._v(" "),_("li",[t._v("锁定太多的数据, 造成大量的阻塞和锁超时")]),t._v(" "),_("li",[t._v("执行时间长, 容易造成主从延迟")]),t._v(" "),_("li",[t._v("回滚所需要的时间比较长")]),t._v(" "),_("li",[t._v("undo log 膨胀")]),t._v(" "),_("li",[t._v("容易导致死锁")])]),t._v(" "),_("h5",{attrs:{id:"_2-事务优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-事务优化"}},[t._v("#")]),t._v(" 2.事务优化")]),t._v(" "),_("ul",[_("li",[t._v("将"),_("strong",[t._v("查询等数据准备操作放到事务外")])]),t._v(" "),_("li",[t._v("事务中避免远程调用, 远程调用要设置超时, "),_("strong",[t._v("防止事务等待时间太久")])]),t._v(" "),_("li",[t._v("事务中避免一次性处理太多数据, 可以拆分成多个事务分次处理")]),t._v(" "),_("li",[_("strong",[t._v("更新等涉及加锁的操作尽可能放在事务靠后的位置")])]),t._v(" "),_("li",[t._v("能异步处理的尽量异步处理")]),t._v(" "),_("li",[_("strong",[t._v("应用侧(业务代码)保证数据一致性")]),t._v(", 非事务执行")])]),t._v(" "),_("p",[t._v("‍")]),t._v(" "),_("p",[t._v("‍")]),t._v(" "),_("h4",{attrs:{id:"参考资料"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("The InnoDB Storage Engine"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://www.slideshare.net/ErnestoHernandezRodriguez/transaction-isolation-levels",target:"_blank",rel:"noopener noreferrer"}},[t._v("Transaction isolation levels"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"http://scanftree.com/dbms/2-phase-locking-protocol",target:"_blank",rel:"noopener noreferrer"}},[t._v("Concurrency Control"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://www.slideshare.net/brshristov/the-nightmare-of-locking-blocking-and-isolation-levels-46391666",target:"_blank",rel:"noopener noreferrer"}},[t._v("The Nightmare of Locking, Blocking and Isolation Levels!"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://aksakalli.github.io/2012/03/12/database-normalization-and-normal-forms-with-an-example.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Database Normalization and Normal Forms with an Example"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://blog.jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/",target:"_blank",rel:"noopener noreferrer"}},[t._v("The basics of the InnoDB undo logging and history system"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://www.brightbox.com/blog/2013/10/31/on-mysql-locks/",target:"_blank",rel:"noopener noreferrer"}},[t._v("MySQL locking for the busy web developer"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://draveness.me/mysql-innodb",target:"_blank",rel:"noopener noreferrer"}},[t._v("浅入浅出 MySQL 和 InnoDB"),_("OutboundLink")],1)])]),t._v(" "),_("p",[t._v("‍")])])}),[],!1,null,null,null);_.default=e.exports}}]);