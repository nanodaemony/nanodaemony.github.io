(window.webpackJsonp=window.webpackJsonp||[]).push([[213],{544:function(e,r,v){"use strict";v.r(r);var _=v(4),a=Object(_.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"_2-zookeeper核心原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-zookeeper核心原理"}},[e._v("#")]),e._v(" 2.Zookeeper核心原理")]),e._v(" "),r("h4",{attrs:{id:"系统模型🌟"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#系统模型🌟"}},[e._v("#")]),e._v(" 系统模型🌟")]),e._v(" "),r("h5",{attrs:{id:"_1-数据模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据模型"}},[e._v("#")]),e._v(" 1.数据模型")]),e._v(" "),r("p",[e._v('ZooKeeper 的视图结构和 Unix 文件系统类似, 但没有引入文件系统中目录和文件等相关概念, 而是使用了其特有的 "'),r("strong",[e._v("数据结点")]),e._v('" 概念, 称之为 '),r("strong",[e._v("ZNode")]),e._v(".")]),e._v(" "),r("p",[r("strong",[e._v("ZNode")]),e._v(" 是 ZooKeeper 中数据的最小单元, 也称为结点. 每个 ZNode 上都可以保存数据, 同时还可以挂载"),r("strong",[e._v("子结点")]),e._v(", 因此构成了一个层次化的命名空间, 形成"),r("strong",[e._v("一颗树")]),e._v(". 不过 ZNode 没有目录的概念, 不能执行类似 cd 之类的命令.")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20211221223925381.png",alt:""}})]),e._v(" "),r("h6",{attrs:{id:"事务id"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#事务id"}},[e._v("#")]),e._v(" 事务ID")]),e._v(" "),r("p",[e._v("在 ZooKeeper 中, 事务是指能够改变 ZooKeeper 服务器状态的操作, 一般包括数据结点"),r("strong",[e._v("创建与删除, 数据结点内容更新")]),e._v("和"),r("strong",[e._v("客户端会话创建与失效")]),e._v("等操作. 对于每一个事务请求, ZooKeeper 都会为其分配一个"),r("strong",[e._v("全局唯一的事务 ID")]),e._v(", 用 "),r("strong",[e._v("ZXID")]),e._v(" 来表示, 通常是一个 64 位的数字. 每一个 ZXID 对应一次"),r("strong",[e._v("更新")]),e._v("操作, 从这些 ZXID 中可以间接地识别出 ZooKeeper 处理这些更新操作请求的全局顺序.")]),e._v(" "),r("h5",{attrs:{id:"_2-结点znode"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-结点znode"}},[e._v("#")]),e._v(" 2.结点ZNode")]),e._v(" "),r("h6",{attrs:{id:"_1-结点类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-结点类型"}},[e._v("#")]),e._v(" (1)结点类型")]),e._v(" "),r("p",[e._v("每个数据结点都有其生命周期, 这取决于结点类型. 数据结点可以按照 "),r("strong",[e._v("==持久与否, 顺序与否==")]),e._v(" 分为四大类.")]),e._v(" "),r("p",[r("strong",[e._v("==持久结点==")]),e._v("(PERSISTENT)")]),e._v(" "),r("p",[r("strong",[e._v("默认")]),e._v("结点类型. 持久结点指该数据结点被创建后, 就会"),r("strong",[e._v("一直")]),e._v("存在于 ZooKeeper 服务器上, 直到有删除操作来主动清除这个结点.")]),e._v(" "),r("div",{staticClass:"language-bash line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-bash"}},[r("code",[r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 默认创建持久结点")]),e._v("\ncreate /test "),r("span",{pre:!0,attrs:{class:"token string"}},[e._v('"test"')]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br")])]),r("p",[r("strong",[e._v("==持久顺序结点==")]),e._v("(PERSISTENT_SEQUENTIAL)")]),e._v(" "),r("p",[e._v("持久顺序结点的基本特性和持久结点是一致的, 额外的特性表现在顺序性上. 在 Zookeeper 中, 每个父结点都会为它的"),r("strong",[e._v("第一级子结点")]),e._v("维护一份顺序, 用于记录下"),r("strong",[e._v("每个子结点创建的先后顺序")]),e._v(". 在创建结点过程中, ZooKeeper 会自动为给定结点名(路径)加上一个"),r("strong",[e._v("数字后缀")]),e._v(", 作为一个新的, 完整的结点名. 适合用于"),r("strong",[e._v("分布式锁, 分布式选举")]),e._v("等场景.")]),e._v(" "),r("p",[e._v("创建时添加 "),r("strong",[e._v("-s")]),e._v(" 参数即可.")]),e._v(" "),r("div",{staticClass:"language-bash line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-bash"}},[r("code",[r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 创建序号结点")]),e._v("\ncreate "),r("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("-s")]),e._v(" /test\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 返回创建的加了序号的实际路径")]),e._v("\nCreated /test0000000001\n\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 再次创建一个")]),e._v("\ncreate "),r("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("-s")]),e._v(" /test\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 返回创建的实际路径2, 序号已递增")]),e._v("\nCreated /test0000000002\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br")])]),r("p",[r("strong",[e._v("==临时结点==")]),e._v("(EPHEMERAL)")]),e._v(" "),r("p",[e._v("临时结点的生命周期和"),r("strong",[e._v("客户端会话")]),e._v("绑定, 如果客户端会话失效断开连接, 那么这个结点就会被自动删除并清理掉. 注意, 这里指的是客户端会话失效, 而非 TCP 连接断开. 它可以用于判断客户端是否还在连接, 如果已经断开连接, 那么结点就不在了. "),r("strong",[e._v("==临时结点下面不能包含子结点==")]),e._v(", 所以临时结点"),r("strong",[e._v("只能做叶子结点")]),e._v(". 适用于"),r("strong",[e._v("心跳, 服务发现等场景")]),e._v(".")]),e._v(" "),r("p",[e._v("创建时添加参数 "),r("strong",[e._v("-e")]),e._v(" 即可.")]),e._v(" "),r("div",{staticClass:"language-bash line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-bash"}},[r("code",[r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 创建临时结点, 会话端口自动删除")]),e._v("\ncreate "),r("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("-e")]),e._v(" /temp "),r("span",{pre:!0,attrs:{class:"token string"}},[e._v('"test"')]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br")])]),r("p",[r("strong",[e._v("==临时顺序结点==")]),e._v("(EPHEMERAL_SEQUENTIAL)")]),e._v(" "),r("p",[e._v("基本特性和临时结点也是一致的, 同样是在临时结点的基础上增加了顺序的特性.")]),e._v(" "),r("div",{staticClass:"language-bash line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-bash"}},[r("code",[e._v("create "),r("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("-e")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("-s")]),e._v(" /temp/seq\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br")])]),r("h6",{attrs:{id:"_2-结点数据与状态信息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-结点数据与状态信息"}},[e._v("#")]),e._v(" (2)结点数据与状态信息")]),e._v(" "),r("p",[e._v("znode 结点包含如下信息:")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("path")]),e._v(": 唯一路径. 增删改查都是基于 PATH.")]),e._v(" "),r("li",[r("strong",[e._v("childNode")]),e._v(": 子结点列表.")]),e._v(" "),r("li",[r("strong",[e._v("type")]),e._v(": 结点类型.")]),e._v(" "),r("li",[r("strong",[e._v("data")]),e._v(": 数据内容.")]),e._v(" "),r("li",[r("strong",[e._v("stat")]),e._v(": 状态属性.")])]),e._v(" "),r("p",[e._v("每个数据结点除了存储数据内容, 还存储结点本身的一些"),r("strong",[e._v("状态信息")]),e._v(". "),r("strong",[e._v("get 命令")]),e._v("可以获取结点信息, 得到结果的第一行是当前数据结点的"),r("strong",[e._v("数据内容")]),e._v(", 第二行开始就是结点的"),r("strong",[e._v("状态信息")]),e._v(". 典型的有:")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("czxid")]),e._v(". 即 Created ZXID, 表示数据结点被"),r("strong",[e._v("创建时的事务 ID")]),e._v(".")]),e._v(" "),r("li",[r("strong",[e._v("mzxid")]),e._v(". 即 Modified ZXID, 表示数据结点最后一次被更新时的事务 ID.")]),e._v(" "),r("li",[e._v("ctime. 结点创建时间.")]),e._v(" "),r("li",[e._v("mtime. 结点最后一次被更新时间.")]),e._v(" "),r("li",[r("strong",[e._v("version")]),e._v(". 数据结点的版本号.")]),e._v(" "),r("li",[r("strong",[e._v("cversion")]),e._v(". 子结点的版本号.")]),e._v(" "),r("li",[r("strong",[e._v("aversion")]),e._v(". 结点的 ACL 版本号(权限版本变更次数).")]),e._v(" "),r("li",[e._v("ephemeralOwner. 创建该临时结点的会话的 sessionID, 如果为持久结点则此属性为 0.")]),e._v(" "),r("li",[e._v("numChildren. 子结点个数.")]),e._v(" "),r("li",[r("strong",[e._v("pzxid")]),e._v(". 表示该结点子结点列表最后一次被修改时的事务 ID. 只有子结点列表变更会修改 pzxid, 子结点内容变化不会影响 pzxid.")])]),e._v(" "),r("p",[e._v("例子:")]),e._v(" "),r("div",{staticClass:"language-bash line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-bash"}},[r("code",[e._v("cZxid "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" 0x385\nctime "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Tue Sep "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("24")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("17")]),e._v(":26:28 CST "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("2019")]),e._v("\nmZxid "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" 0x385 \nmtime "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Tue Sep "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("24")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("17")]),e._v(":26:28 CST "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("2019")]),e._v("\npZxid "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" 0x385\ncversion "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\ndataVersion "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),e._v("\naclVersion "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\nephemeralOwner "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" 0x0\ndataLength "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("17")]),e._v("\nnumChildren "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br"),r("span",{staticClass:"line-number"},[e._v("10")]),r("br"),r("span",{staticClass:"line-number"},[e._v("11")]),r("br")])]),r("h5",{attrs:{id:"_3-结点版本-保证分布式数据原子性操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-结点版本-保证分布式数据原子性操作"}},[e._v("#")]),e._v(" 3.结点版本(保证分布式数据原子性操作)")]),e._v(" "),r("p",[e._v("每个数据结点都有三种类型的版本信息.")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("version")]),e._v(". 数据结点数据内容的版本号.")]),e._v(" "),r("li",[r("strong",[e._v("cversion")]),e._v(". 子结点的版本号.")]),e._v(" "),r("li",[r("strong",[e._v("aversion")]),e._v(". 当前结点的 ACL 版本号.")])]),e._v(" "),r("p",[e._v('这里 "'),r("strong",[e._v("版本号")]),e._v('" 分别表示对结点'),r("strong",[e._v("数据内容, 子结点列表, 结点 ACL 信息")]),e._v("的"),r("strong",[e._v("更新次数")]),e._v('. 比如一个数据结点创建后, 其 version 值为 0, 表示的含义是 "当前结点自创建后, 被更新过 0 次". 如果对数据内容进行了更新, version 值就会增加(只要是更新操作, 即使内容不变也会增加, 因为这里强调的是变更次数).')]),e._v(" "),r("p",[e._v('版本在实现 "乐观锁" 场景下十分有用. 乐观锁一般分为: 数据读取, '),r("strong",[e._v("写入校验")]),e._v('和数据写入等步骤. 比如 JDK 的 CAS, 对于值 V, 每次更新前都会对比其值是否是预期值 A, 只有符合预期, 才会将 V 原子化等更新到新值 B. ZooKeeper 中的 version 属性正是用于实现乐观锁机制中的 "写入校验" 的.')]),e._v(" "),r("h5",{attrs:{id:"_4-watcher监听-数据变更通知"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-watcher监听-数据变更通知"}},[e._v("#")]),e._v(" 4.Watcher监听(数据变更通知)")]),e._v(" "),r("h6",{attrs:{id:"_1-概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[e._v("#")]),e._v(" (1)概述")]),e._v(" "),r("p",[e._v("ZK 通过 Watcher 机制来实现"),r("strong",[e._v("分布式通知功能")]),e._v(". ZK 允许客户端向服务端"),r("strong",[e._v("注册一个 Watcher 监听")]),e._v(", 当服务端的特定事件触发了这个 Watcher, 就会向"),r("strong",[e._v("指定客户端发送一个事件通知")]),e._v("来实现分布式通知功能. 整个 Watcher 注册与通知过程如下图.")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20211225163152279.png",alt:""}})]),e._v(" "),r("p",[e._v("客户端在向 ZK 注册 Watcher 的同时也会将 Watcher 对象存储在客户端的 "),r("strong",[e._v("WatcherManager")]),e._v(" 中, 当 ZooKeeper 服务器触发 Watcher 事件后, 会向客户端发出通知, 客户端线程从 WatcherManager 取出对应的 Watcher 对象"),r("strong",[e._v("执行回调逻辑")]),e._v("(执行 process() 方法).")]),e._v(" "),r("p",[r("strong",[e._v("客户端")]),e._v("会记录 "),r("strong",[e._v("Watcher 与数据结点路径的映射关系")]),e._v(". Watcher 注册完成后, 会被保存到 ZKWatcherManager 对象的 dataWatches 属性中, 其数据结构为 Map<String, Set"),r("Watcher",[e._v(">, 用于将数据结点的路径和 Watcher 进行映射后管理起来.")])],1),e._v(" "),r("h6",{attrs:{id:"_2-watcher特性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-watcher特性"}},[e._v("#")]),e._v(" (2)Watcher特性")]),e._v(" "),r("p",[r("strong",[e._v("1.一次性")])]),e._v(" "),r("p",[e._v("无论是客户端还是服务端, "),r("strong",[e._v("==一旦一个 Watcher 被触发, Zookeeper 都会将其从相应的存储中移除==")]),e._v(". 因此使用 Watcher 时需要进行"),r("strong",[e._v("反复注册")]),e._v(". 使用后立即失效可以减小服务端压力, 不然需要通知的结点可能很多.")]),e._v(" "),r("p",[r("strong",[e._v("2.客户端串行执行")])]),e._v(" "),r("p",[e._v("客户端 Watcher 回调是一个串行同步的过程. 这保证了顺序.")]),e._v(" "),r("p",[r("strong",[e._v("3.轻量")])]),e._v(" "),r("p",[e._v("当服务端发生了事件后, 会通过 Watcher 机制以 "),r("strong",[e._v("WatchedEvent 消息")]),e._v("的方式告知客户端发送了事件. WatchedEvent 仅包含了"),r("strong",[e._v("通知状态, 事件类型和结点路径")]),e._v("等三部分内容, "),r("strong",[e._v("==不包含事件的具体内容==")]),e._v(". 例如某个结点的子结点列表发生了变更, ZooKeeper 会通过 Watcher 告知客户端此事, 但客户端无法从事件中得到数据结点的原始数据和变更后的子结点数据, "),r("strong",[e._v("客户端需要主动重新去获取数据")]),e._v(".")]),e._v(" "),r("h5",{attrs:{id:"_5-acl-权限控制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-acl-权限控制"}},[e._v("#")]),e._v(" 5.ACL(权限控制)")]),e._v(" "),r("p",[e._v("ZK 通过 "),r("strong",[e._v("ACL(Access Control List) 权限控制机制")]),e._v("来"),r("strong",[e._v("保证数据安全")]),e._v(". ACL 即"),r("strong",[e._v("访问控制列表")]),e._v(", 可以针对任意用户和组进行细粒度的权限控制.")]),e._v(" "),r("p",[e._v('ACL 包含三部分内容, 分别是权限模式(Scheme), 授权对象(ID)与权限(Permission), 通常采用 "'),r("strong",[e._v("scheme : id : permission")]),e._v('" 来标识一个 ACL 信息.')]),e._v(" "),r("p",[e._v("权限仅对当前结点有效, 不会被子结点继承.")]),e._v(" "),r("h6",{attrs:{id:"_1-权限模式-scheme"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-权限模式-scheme"}},[e._v("#")]),e._v(" (1)权限模式(Scheme)")]),e._v(" "),r("p",[e._v("权限模式用于确定权限验证时的检验策略. 如:")]),e._v(" "),r("ul",[r("li",[e._v("IP: 通过 IP 地址进行权限控制.")]),e._v(" "),r("li",[e._v('Digest: 类似于 "username:password" 的方式进行权限配置. '),r("strong",[e._v("用户密码")]),e._v("认证模式, 只有在会话中添加了认证才可以防问.")]),e._v(" "),r("li",[e._v("World: 所有用户都能操作数据.")]),e._v(" "),r("li",[e._v("Super: 超级用户.")])]),e._v(" "),r("h6",{attrs:{id:"_2-授权对象-id"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-授权对象-id"}},[e._v("#")]),e._v(" (2)授权对象(ID)")]),e._v(" "),r("p",[e._v("授权对象指权限赋予的用户或一个指定的实体, 例如是 IP 地址或机器.")]),e._v(" "),r("h6",{attrs:{id:"_3-权限-permission"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-权限-permission"}},[e._v("#")]),e._v(" (3)权限(Permission)")]),e._v(" "),r("p",[e._v("权限指通过权限检查后可以执行的操作.")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("CREATE")]),e._v(". "),r("strong",[e._v("子结点")]),e._v("创建权限. 允许授权对象在该结点下创建子结点.")]),e._v(" "),r("li",[r("strong",[e._v("DELETE")]),e._v(". "),r("strong",[e._v("子结点")]),e._v("删除权限. 允许授权对象删除该数据结点的子结点.")]),e._v(" "),r("li",[r("strong",[e._v("READ")]),e._v(". 数据结点的读取权限. 允许授权对象访问该数据结点并读取其数据内容或子结点列表.")]),e._v(" "),r("li",[r("strong",[e._v("WRITE")]),e._v(". 数据结点的更新权限. 允许授权对象对该数据结点进行更新操作.")]),e._v(" "),r("li",[r("strong",[e._v("ADMIN")]),e._v(". 数据结点的管理权限. 允许授权对象对该数据结点进行 ACL 相关的设置.")])]),e._v(" "),r("h4",{attrs:{id:"客户端"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#客户端"}},[e._v("#")]),e._v(" 客户端")]),e._v(" "),r("h5",{attrs:{id:"_1-客户端命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-客户端命令"}},[e._v("#")]),e._v(" 1.客户端命令")]),e._v(" "),r("p",[r("strong",[e._v("基本命令列表")]),e._v(":")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("connect host:port")]),e._v(": 重新连接指定 ZooKeeper 服务.")]),e._v(" "),r("li",[r("strong",[e._v("create [-s] [-e] [-c] [-t ttl] path [data] [acl]")]),e._v(": 创建结点.")]),e._v(" "),r("li",[r("strong",[e._v("delete [-v version] path")]),e._v(": 删除结点(不能存在子结点).")]),e._v(" "),r("li",[r("strong",[e._v("deleteall path")]),e._v(": 删除路径及所有子结点.")]),e._v(" "),r("li",[r("strong",[e._v("setquota -n|-b val path")]),e._v(": 设置结点限额. -n 子结点数, -b 字节数.")]),e._v(" "),r("li",[r("strong",[e._v("listquota path")]),e._v(": 查看结点限额.")]),e._v(" "),r("li",[r("strong",[e._v("delquota [-n|-b] path")]),e._v(": 删除结点限额.")]),e._v(" "),r("li",[r("strong",[e._v("get [-s] [-w] path")]),e._v(": 查看结点数据. -s 包含结点状态, -w 添加监听.")]),e._v(" "),r("li",[r("strong",[e._v("ls [-s] [-w] [-R] path")]),e._v(": 列出子结点. -s 状态, -R 递归查看所有子结点, -w 添加监听.")]),e._v(" "),r("li",[r("strong",[e._v("setAcl [-s] [-v version] [-R] path acl")]),e._v(": 为结点设置 ACL 权限.")]),e._v(" "),r("li",[r("strong",[e._v("stat [-w] path")]),e._v(": 查看结点状态. -w 添加监听.")])]),e._v(" "),r("p",[r("strong",[e._v("node 数据的增删改查")]),e._v(":")]),e._v(" "),r("div",{staticClass:"language-bash line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-bash"}},[r("code",[r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 列出子结点 ")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" /\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 创建结点")]),e._v("\ncreate /student "),r("span",{pre:!0,attrs:{class:"token string"}},[e._v('"nano"')]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 查看结点")]),e._v("\nget /student\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 创建子结点 ")]),e._v("\ncreate /student/height "),r("span",{pre:!0,attrs:{class:"token string"}},[e._v('"32"')]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 删除结点")]),e._v("\ndelete /student/height\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 删除所有结点包括子结点")]),e._v("\ndeleteall /student\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 修改结点")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("set")]),e._v(" /student "),r("span",{pre:!0,attrs:{class:"token string"}},[e._v('"woman"')]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br"),r("span",{staticClass:"line-number"},[e._v("10")]),r("br"),r("span",{staticClass:"line-number"},[e._v("11")]),r("br"),r("span",{staticClass:"line-number"},[e._v("12")]),r("br"),r("span",{staticClass:"line-number"},[e._v("13")]),r("br"),r("span",{staticClass:"line-number"},[e._v("14")]),r("br")])]),r("h5",{attrs:{id:"_2-开源客户端"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-开源客户端"}},[e._v("#")]),e._v(" 2.开源客户端")]),e._v(" "),r("p",[e._v("可以使用 Java 客户端进行 ZK 访问与操作. 比如 ZkClient 和 Curator 等.")]),e._v(" "),r("h5",{attrs:{id:"_3-java客户端"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-java客户端"}},[e._v("#")]),e._v(" 3.Java客户端")]),e._v(" "),r("p",[e._v("ZooKeeper 提供的客户端. 依赖:")]),e._v(" "),r("div",{staticClass:"language-xml line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-xml"}},[r("code",[r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("dependency")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n    "),r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("groupId")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("org.apache.zookeeper"),r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("</")]),e._v("groupId")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n    "),r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("artifactId")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("zookeeper"),r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("</")]),e._v("artifactId")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n    "),r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("version")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("3.5.5"),r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("</")]),e._v("version")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("</")]),e._v("dependency")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br")])]),r("p",[r("strong",[e._v("初始连接:")])]),e._v(" "),r("p",[e._v("常规的客户端类是 org.apache.zookeeper."),r("strong",[e._v("ZooKeeper")]),e._v(", 实例化该类之后将会"),r("strong",[e._v("自动与集群建立连接")]),e._v(".")]),e._v(" "),r("p",[r("strong",[e._v("监听结点")]),e._v(":")]),e._v(" "),r("p",[e._v("在 "),r("strong",[e._v("getData")]),e._v("() 与 "),r("strong",[e._v("getChildren")]),e._v("() 两个方法中可分别设置"),r("strong",[e._v("监听数据变化和子结点变化")]),e._v(". 通过"),r("strong",[e._v("设置 watch 为 true")]),e._v(", 当前事件触发时会调用 zookeeper() 构建函数中 "),r("strong",[e._v("Watcher.process()")]),e._v(" 方法. 也可以添加 watcher 参数来实现"),r("strong",[e._v("自定义监听")]),e._v(". 一般采用后者.")]),e._v(" "),r("p",[e._v("注意: 所有的监听都是"),r("strong",[e._v("一次性的, 如果要持续监听需要触发后在添加一次监听")]),e._v(".")]),e._v(" "),r("h5",{attrs:{id:"_4-会话session"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-会话session"}},[e._v("#")]),e._v(" 4.会话Session")]),e._v(" "),r("p",[e._v("Session 指 ZK "),r("strong",[e._v("服务器与客户端")]),e._v("会话. 一个客户端连接指客户端和服务器之间的一个 "),r("strong",[e._v("TCP 长连接")]),e._v(". 客户端启动时, 首先会与服务器建立一个 TCP 连接, 从第一次连接建立开始, 客户端会话的生命周期也开始了. 通过这个连接, 客户端能够通过"),r("strong",[e._v("心跳检测")]),e._v("与服务器保持有效的会话, 也能够向服务器发送请求并接受响应, 同时还能够通过该"),r("strong",[e._v("连接接收来自服务器的 Watch 事件通知")]),e._v(".")]),e._v(" "),r("p",[e._v("Session 的 sessionTimeout 参数用来设置一个客户端会话的"),r("strong",[e._v("超时时间")]),e._v(". 即使因为网络故障或是客户端主动断开连接等各种原因导致客户端连接断开, 只要在 sessionTimeout 时间内能够重新连接上集群中任意一台服务器, 那么之前创建的会话仍然有效.")]),e._v(" "),r("p",[e._v("在为客户端创建会话之前, 服务端首先会为每个客户端都分配一个 "),r("strong",[e._v("sessionID")]),e._v(". 由于 sessionID 是 Zookeeper 会话的一个重要标识, 许多与会话相关的运行机制都是基于这个 sessionID 的, 因此无论是哪台服务器为客户端分配的 sessionID, 都务必保证"),r("strong",[e._v("全局唯一")]),e._v(".")]),e._v(" "),r("p",[e._v("会话还有对应的"),r("strong",[e._v("事件")]),e._v(", 如 CONNECTION_LOSS(连接丢失事件), SESSION_MOVED(会话转移事件), SESSION_EXPIRED(会话超时失效事件).")]),e._v(" "),r("h5",{attrs:{id:"_5-客户端组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-客户端组件"}},[e._v("#")]),e._v(" 5.客户端组件")]),e._v(" "),r("p",[e._v("Zookeeper 客户端核心组件如下.")]),e._v(" "),r("ul",[r("li",[e._v("Zookeeper 实例. 客户端的入口.")]),e._v(" "),r("li",[e._v("ClientWatchManage. 客户端的 Watcher 管理器.")]),e._v(" "),r("li",[e._v("HostProvider. 客户端地址列表管理器.")]),e._v(" "),r("li",[r("strong",[e._v("ClientCnxn")]),e._v(". 客户端核心线程, 其内部包含 SendThread 和 EventThread 两个线程. SendThread 是一个 IO 线程, 负责 Zookeeper 客户端与服务器之间的网络 IO 通信. EventThread 是一个事件线程, 负责对服务端的事件进行处理.")])]),e._v(" "),r("h5",{attrs:{id:"_6-客户端会话创建过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-客户端会话创建过程"}},[e._v("#")]),e._v(" 6.客户端会话创建过程")]),e._v(" "),r("p",[r("strong",[e._v("(1) 初始化阶段")])]),e._v(" "),r("ul",[r("li",[e._v("初始化 Zookeeper 对象.")]),e._v(" "),r("li",[e._v("设置会话默认 Watcher.")]),e._v(" "),r("li",[e._v("构造 Zookeeper 服务器地址列表管理器 HostProvider.")]),e._v(" "),r("li",[e._v("创建并初始化客户端网络连接器 ClientCnxn. 创建 ClientCnxn 的同时, 还会创建客户端的两个核心队列: outgoingQueue(客户端请求发送队列)和 pendingQueue(服务端响应等待队列).")]),e._v(" "),r("li",[e._v("初始化 SendThread 和 EventThread.")])]),e._v(" "),r("p",[r("strong",[e._v("(2) 会话创建阶段")])]),e._v(" "),r("ul",[r("li",[e._v("启动 SendThread 和 EventThread.")]),e._v(" "),r("li",[e._v("获取一个服务器地址.")]),e._v(" "),r("li",[e._v("创建 TCP 连接. ClientCnxnSocket 负责与服务器创建一个 TCP 长连接.")]),e._v(" "),r("li",[e._v("构造 ConnectRequest 请求.")]),e._v(" "),r("li",[e._v("发送请求.")])]),e._v(" "),r("p",[r("strong",[e._v("(3) 响应处理阶段")])]),e._v(" "),r("ul",[r("li",[e._v("接收服务端响应.")]),e._v(" "),r("li",[e._v("处理 response.")]),e._v(" "),r("li",[e._v("查询 Watcher.")]),e._v(" "),r("li",[e._v("处理事件. EventThread 不断从 waitingEvents 队列中取出待处理的 Watcher 对象, 然后直接调用该对象的 process 方法进行事件回调.")])]),e._v(" "),r("h4",{attrs:{id:"序列化与协议"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#序列化与协议"}},[e._v("#")]),e._v(" 序列化与协议")]),e._v(" "),r("p",[e._v("Zookeeper 客户端与服务端会进行一些列网络数据传输, ZooKeeper 使用 "),r("strong",[e._v("Jute")]),e._v(" 序列化组件实现通信数据的序列化与反序列化操作.")]),e._v(" "),r("p",[e._v("Zookeeper 设计了基于 TCP/IP 协议的独有的应用层"),r("strong",[e._v("通信协议")]),e._v(", 实现数据的高效传输.")]),e._v(" "),r("h4",{attrs:{id:"服务器启动流程分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务器启动流程分析"}},[e._v("#")]),e._v(" 服务器启动流程分析")]),e._v(" "),r("p",[e._v("Zookeeper 服务端整体架构如下:")]),e._v(" "),r("p",[e._v("​"),r("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220106231854447.png",alt:""}}),e._v("i")]),e._v(" "),r("p",[e._v("Zookeeper 服务器的启动大致可以分为以下五个步骤:")]),e._v(" "),r("ol",[r("li",[e._v("配置文件解析.")]),e._v(" "),r("li",[e._v("初始化数据管理器.")]),e._v(" "),r("li",[e._v("初始化网络 IO 管理器.")]),e._v(" "),r("li",[e._v("数据恢复.")]),e._v(" "),r("li",[e._v("对外服务.")])]),e._v(" "),r("h5",{attrs:{id:"_1-单机版服务器启动"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-单机版服务器启动"}},[e._v("#")]),e._v(" 1.单机版服务器启动")]),e._v(" "),r("p",[e._v("单机版服务器的启动其流程图如下.")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220106232948829.png",alt:"image-20220106232948829"}})]),e._v(" "),r("p",[e._v("上图的过程可以分为"),r("strong",[e._v("预启动")]),e._v("和"),r("strong",[e._v("初始化")]),e._v("过程.")]),e._v(" "),r("h6",{attrs:{id:"_1-预启动"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-预启动"}},[e._v("#")]),e._v(" (1)预启动")]),e._v(" "),r("ol",[r("li",[e._v("统一由 QuorumPeerMain 作为启动类. 无论单机或集群, 在 zkServer.cmd 和 zkServer.sh 中都配置了 QuorumPeerMain 作为启动入口类.")]),e._v(" "),r("li",[e._v("解析配置文件 zoo.cfg. zoo.cfg 配置运行时基本参数, 如 tickTime, dataDir, clientPort 等.")]),e._v(" "),r("li",[e._v("创建并启动历史文件清理器 DatadirCleanupManager. 对事务日志和快照数据文件进行定时清理.")]),e._v(" "),r("li",[e._v("判断当前是集群还是单机模式启动. 若是单机模式, 则委托给 ZooKeeperServerMain 进行启动.")]),e._v(" "),r("li",[e._v("再次解析配置文件 zoo.cfg.")]),e._v(" "),r("li",[e._v("创建服务器实例 ZooKeeperServer. ZooKeeper 服务器首先会进行服务器实例的创建, 然后对该服务器实例进行初始化, 包括连接器, 内存数据库, 请求处理器等组件的初始化.")])]),e._v(" "),r("h6",{attrs:{id:"_2-初始化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-初始化"}},[e._v("#")]),e._v(" (2)初始化")]),e._v(" "),r("ol",[r("li",[e._v("创建服务器统计器 ServerStats. ServerStats 是 Zookeeper 服务器运行时的统计器.")]),e._v(" "),r("li",[e._v("创建 Zookeeper 数据管理器 FileTxnSnapLog. FileTxnSnapLog 是 Zookeeper 上层服务器和底层数据存储之间的对接层, 提供了一系列操作数据文件的接口, 如事务日志文件和快照数据文件. Zookeeper 根据 zoo.cfg 文件中解析出的快照数据目录 dataDir 和事务日志目录 dataLogDir 来创建 FileTxnSnapLog.")]),e._v(" "),r("li",[e._v("设置服务器 tickTime 和会话超时时间限制.")]),e._v(" "),r("li",[e._v("创建 ServerCnxnFactory. 通过配置系统属性 zookeper.serverCnxnFactory 来指定使用 Zookeeper 自己实现的 NIO 还是使用 Netty 框架作为 Zookeeper 服务端网络连接工厂.")]),e._v(" "),r("li",[e._v("初始化 ServerCnxnFactory. Zookeeper 会初始化 Thread 作为 ServerCnxnFactory 的主线程, 然后再初始化 NIO 服务器.")]),e._v(" "),r("li",[e._v("启动 ServerCnxnFactory 主线程. 进入 Thread 的 run 方法, 此时服务端还不能处理客户端请求.")]),e._v(" "),r("li",[e._v("恢复本地数据. 启动时, 需要从本地快照数据文件和事务日志文件进行数据恢复.")]),e._v(" "),r("li",[e._v("创建并启动会话管理器. Zookeeper 会创建会话管理器 SessionTracker 进行会话管理.")]),e._v(" "),r("li",[e._v("初始化 Zookeeper 的请求处理链. Zookeeper 请求处理方式为"),r("strong",[e._v("责任链模式")]),e._v("的实现. 会有多个请求处理器依次处理一个客户端请求, 在服务器启动时, 会将这些请求处理器串联成一个请求处理链.")]),e._v(" "),r("li",[e._v("注册 JMX 服务. Zookeeper 会将服务器运行时的一些信息以 JMX 的方式暴露给外部.")]),e._v(" "),r("li",[e._v("注册 Zookeeper 服务器实例. 将 Zookeeper 服务器实例注册给 ServerCnxnFactory, 之后 Zookeeper 就可以对外提供服务.")])]),e._v(" "),r("p",[e._v("至此, 单机版的 Zookeeper 服务器启动完毕.")]),e._v(" "),r("h5",{attrs:{id:"_2-集群版服务器启动"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-集群版服务器启动"}},[e._v("#")]),e._v(" 2.集群版服务器启动")]),e._v(" "),r("p",[e._v("单机和集群服务器的启动在很多地方是一致的, 其流程图如下.")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220106233835547.png",alt:"image-20220106233835547"}})]),e._v(" "),r("p",[e._v("上图的过程可以分为"),r("strong",[e._v("预启动, 初始化, Leader选举, Leader 与 Follower 启动期交互过程, Leader 与 Follower 启动")]),e._v("等过程.")]),e._v(" "),r("h6",{attrs:{id:"_1-预启动-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-预启动-2"}},[e._v("#")]),e._v(" (1)预启动")]),e._v(" "),r("ol",[r("li",[e._v("统一由 QuorumPeerMain 作为启动类.")]),e._v(" "),r("li",[e._v("解析配置文件 zoo.cfg.")]),e._v(" "),r("li",[e._v("创建并启动历史文件清理器 DatadirCleanupFactory.")]),e._v(" "),r("li",[e._v("判断当前是集群还是单机模式的启动. 在集群模式中, 在 zoo.cfg 文件中配置了多个服务器地址, 可以选择集群启动.")])]),e._v(" "),r("h6",{attrs:{id:"_2-初始化-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-初始化-2"}},[e._v("#")]),e._v(" (2)初始化")]),e._v(" "),r("ol",[r("li",[e._v("创建 ServerCnxnFactory.")]),e._v(" "),r("li",[e._v("初始化 ServerCnxnFactory.")]),e._v(" "),r("li",[e._v("创建 Zookeeper 数据管理器 FileTxnSnapLog.")]),e._v(" "),r("li",[e._v("创建 QuorumPeer 实例. Quorum 是集群模式下特有的对象, 是 Zookeeper 服务器实例(ZooKeeperServer)的托管者, QuorumPeer 代表了集群中的一台机器, 在运行期间, QuorumPeer 会不断检测当前服务器实例的运行状态, 同时根据情况发起 Leader 选举.")]),e._v(" "),r("li",[e._v("创建"),r("strong",[e._v("内存数据库")]),e._v(" ZKDatabase. ZKDatabase 负责管理 ZooKeeper 的所有会话记录以及 DataTree 和事务日志的存储.")]),e._v(" "),r("li",[e._v("初始化 QuorumPeer. 将核心组件如 FileTxnSnapLog, ServerCnxnFactory, ZKDatabase 注册到 QuorumPeer 中, 同时配置 QuorumPeer 的参数, 如服务器列表地址, Leader 选举算法和会话超时时间限制等.")]),e._v(" "),r("li",[e._v("恢复本地数据.")]),e._v(" "),r("li",[e._v("启动 ServerCnxnFactory 主线程.")])]),e._v(" "),r("h6",{attrs:{id:"_3-leader选举"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-leader选举"}},[e._v("#")]),e._v(" (3)Leader选举")]),e._v(" "),r("ol",[r("li",[e._v("初始化 Leader 选举. 集群模式特有, Zookeeper 首先会根据自身的服务器 ID(SID), 最新的 ZXID(lastLoggedZxid) 和当前的服务器 epoch(currentEpoch) 来生成一个"),r("strong",[e._v("初始化投票")]),e._v(", 在初始化过程中, 每个服务器都会给自己投票. 然后根据 zoo.cfg 配置创建相应 Leader 选举算法实现, Zookeeper 提供三种默认算法(LeaderElection, AuthFastLeaderElection, FastLeaderElection), 可通过 zoo.cfg 中的 electionAlg 属性来指定. 在初始化阶段, Zookeeper 会创建 Leader 选举所需的网络 I/O 层 QuorumCnxManager, 同时启动对 Leader 选举端口的监听, 等待集群中其他服务器创建连接.")]),e._v(" "),r("li",[e._v("注册 JMX 服务.")]),e._v(" "),r("li",[e._v("检测当前服务器状态. 运行期间, QuorumPeer 会不断检测当前服务器状态. 正常情况下, Zookeeper 服务器的状态在 LOOKING, LEADING, FOLLOWING/OBSERVING 之间进行切换. 在启动阶段, QuorumPeer 的初始状态是 LOOKING, 因此开始进行 Leader 选举.")]),e._v(" "),r("li",[e._v("Leader 选举. 通过投票确定 Leader, 其余机器称为 Follower 和 Observer. 具体算法在后面会给出.")])]),e._v(" "),r("h6",{attrs:{id:"_4-leader和follower启动期交互过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-leader和follower启动期交互过程"}},[e._v("#")]),e._v(" (4)Leader和Follower启动期交互过程")]),e._v(" "),r("ol",[r("li",[e._v("创建 Leader 服务器和 Follower 服务器. 完成 Leader 选举后, 每个服务器会根据自己服务器的角色创建相应的服务器实例, 并进入各自角色的主流程.")]),e._v(" "),r("li",[e._v("Leader 服务器启动 Follower 接收器 LearnerCnxAcceptor. 运行期间, Leader 服务器需要和所有其余的服务器(统称为 Learner)保持连接以确集群的机器存活情况, LearnerCnxAcceptor 负责接收所有非 Leader 服务器的连接请求.")]),e._v(" "),r("li",[e._v("Leader 服务器开始和 Leader 建立连接. 所有 Learner 会找到 Leader 服务器, 并与其建立连接.")]),e._v(" "),r("li",[e._v("Leader 服务器创建 LearnerHandler. Leader 接收到来自其他机器连接创建请求后, 会创建一个 LearnerHandler 实例, 每个 LearnerHandler 实例都对应一个 Leader 与 Learner 服务器之间的连接, 其负责 Leader 和 Learner 服务器之间几乎所有的消息通信和数据同步.")]),e._v(" "),r("li",[e._v("向 Leader 注册. Learner 完成和 Leader 的连接后, 会向 Leader 进行注册, 即将 Learner 服务器的基本信息(LearnerInfo), 包括 SID 和 ZXID, 发送给 Leader 服务器.")]),e._v(" "),r("li",[e._v("Leader 解析 Learner 信息, 计算新的 epoch. Leader 接收到 Learner 服务器基本信息后, 会解析出该 Learner 的 SID 和 ZXID, 然后根据 ZXID 解析出对应的 epoch_of_learner, 并和当前 Leader 服务器的 epoch_of_leader 进行比较, 如果该 Learner 的 epoch_of_learner 更大, 则更新 Leader 的 epoch_of_leader = epoch_of_learner + 1. 然后 LearnHandler 进行等待, 直到过半 Learner 已经向 Leader 进行了注册, 同时更新了 epoch_of_leader 后, Leader 就可以确定当前集群的 epoch 了.")]),e._v(" "),r("li",[e._v("发送 Leader 状态. 计算出新的 epoch 后, Leader 会将该信息以一个 LEADERINFO 消息的形式发送给 Learner, 并等待 Learner 的响应.")]),e._v(" "),r("li",[e._v("Learner 发送 ACK 消息. Learner 接收到 LEADERINFO 后, 会解析出 epoch 和 ZXID, 然后向 Leader 反馈一个 ACKEPOCH 响应.")]),e._v(" "),r("li",[e._v("数据同步. Leader 收到 Learner 的 ACKEPOCH 后, 即可进行数据同步.")]),e._v(" "),r("li",[e._v("启动 Leader 和 Learner 服务器. 当有过半 Learner 已经完成了数据同步, 那么 Leader 和 Learner 服务器实例就可以启动了.")])]),e._v(" "),r("h6",{attrs:{id:"_5-leader和follower启动"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-leader和follower启动"}},[e._v("#")]),e._v(" (5)Leader和Follower启动")]),e._v(" "),r("ol",[r("li",[e._v("创建启动会话管理器.")]),e._v(" "),r("li",[e._v("初始化 Zookeeper 请求处理链, 集群模式的每个处理器也会在启动阶段串联请求处理链.")]),e._v(" "),r("li",[e._v("注册 JMX 服务.")])]),e._v(" "),r("p",[e._v("至此, 集群版的 Zookeeper 服务器启动完毕.")]),e._v(" "),r("h4",{attrs:{id:"leader选举与zab协议🌟"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#leader选举与zab协议🌟"}},[e._v("#")]),e._v(" Leader选举与ZAB协议🌟")]),e._v(" "),r("h5",{attrs:{id:"_1-集群与服务器角色"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-集群与服务器角色"}},[e._v("#")]),e._v(" 1.集群与服务器角色")]),e._v(" "),r("p",[e._v("ZooKeeper 服务器集群中有 "),r("strong",[e._v("Leader, Follower 和 Observer")]),e._v(" 三种类型角色.")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220106234805740.png",alt:"image-20220106234805740"}})]),e._v(" "),r("p",[e._v("ZooKeeper 集群中的所有机器通过一个 "),r("strong",[e._v("Leader 选举过程")]),e._v('来选定一台 "Leader" 机器, Leader 既可以为客户端提供写服务又能提供读服务. 除 Leader 外, Follower 和 Observer 都只能提供'),r("strong",[e._v("读服务")]),e._v('. Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程, 也不参与写操作的 "'),r("strong",[e._v("过半写成功")]),e._v('" 策略, 因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能.')]),e._v(" "),r("h6",{attrs:{id:"_1-leader"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-leader"}},[e._v("#")]),e._v(" (1)Leader")]),e._v(" "),r("p",[e._v("Leader 服务器是 ZK 集群工作的核心, 是集群中唯一的"),r("strong",[e._v("写请求")]),e._v("处理者, 其主要工作如下:")]),e._v(" "),r("ul",[r("li",[e._v("事务请求的唯一调度和处理者, 保证集群事务处理的顺序性.")]),e._v(" "),r("li",[e._v("集群内部各服务器的调度者.")])]),e._v(" "),r("p",[r("strong",[e._v("请求处理链")])]),e._v(" "),r("p",[e._v("Zookeeper 使用"),r("strong",[e._v("责任链")]),e._v("来处理每个客户端的请求, Leader 服务器的请求"),r("strong",[e._v("处理链")]),e._v("如下:")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220107201550224.png",alt:"image-20220107201550224"}})]),e._v(" "),r("p",[e._v("典型的处理器有:")]),e._v(" "),r("ul",[r("li",[e._v("PrepRequestProcessor. 请求预处理器.")]),e._v(" "),r("li",[e._v("ProposalRequestProcessor. 事务投票处理器.")]),e._v(" "),r("li",[e._v("SyncRequestProcessor. 事务日志记录处理器.")])]),e._v(" "),r("p",[r("strong",[e._v("LearnerHandler")])]),e._v(" "),r("p",[e._v("为了保证整个集群内部的实时通信, 同时为了确保可以控制所有的 Follower/Observer 服务器, Leader 服务器会与每个 Follower/Observer 服务器建立一个 "),r("strong",[e._v("TCP 长连接")]),e._v(". 同时也会为每个 Follower/Observer 服务器创建一个名为 LearnerHandler 的实体. LearnerHandler 是 Learner 服务器的管理者, 主要负责 Follower/Observer 服务器和 Leader 服务器之间的一系列网络通信, 包括数据同步, 请求转发和 Proposal 提议的投票等. Leader 服务器中保存了所有 Follower/Observer 对应的LearnerHandler.")]),e._v(" "),r("h6",{attrs:{id:"_2-follower"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-follower"}},[e._v("#")]),e._v(" (2)Follower")]),e._v(" "),r("p",[e._v("Follower 是 ZooKeeper 集群中的"),r("strong",[e._v("跟随者")]),e._v(", 其主要工作如下:")]),e._v(" "),r("ul",[r("li",[e._v("处理客户端非事务性请求(读取数据), 转发事务请求给 Leader 服务器.")]),e._v(" "),r("li",[e._v("参与事务请求 Proposal 的投票.")]),e._v(" "),r("li",[e._v("参与 Leader 选举投票.")])]),e._v(" "),r("p",[e._v("Follower 也采用了"),r("strong",[e._v("责任链模式")]),e._v("组装的请求处理链来处理每一个客户端请求, 由于不需要对事务请求的投票处理, 因此 Follower 的请求处理链相对简单.")]),e._v(" "),r("h6",{attrs:{id:"_3-observer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-observer"}},[e._v("#")]),e._v(" (3)Observer")]),e._v(" "),r("p",[e._v("Observer 充当"),r("strong",[e._v("观察者")]),e._v("角色, 观察 Zookeeper 集群的最新状态变化并将这些状态同步过来, 其对于非事务请求可以进行独立处理, 对于事务请求, 则会转发给 Leader 服务器进行处理. Observer 不会参与任何形式的投票, 包括事务请求 Proposal 的投票和 Leader 选举投票.")]),e._v(" "),r("h5",{attrs:{id:"_2-zab协议与leader选举概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-zab协议与leader选举概述"}},[e._v("#")]),e._v(" 2.ZAB协议与Leader选举概述")]),e._v(" "),r("p",[e._v("为达成集群数据一致性, ZooKeeper 并"),r("strong",[e._v("没有完全采用 Paxos算法")]),e._v(", 而是"),r("strong",[e._v("使用 ZAB(ZooKeeper Atomic Broadcast 原子广播)协议")]),e._v("作为其"),r("strong",[e._v("保证分布式数据一致性的核心算法")]),e._v(". ZAB 协议并不像 Paxos 算法那样是一种通用的分布式一致性算法, 它是一种"),r("strong",[e._v("特别为 Zookeeper 设计的崩溃可恢复的原子消息广播算法")]),e._v(". 基于该协议, ZooKeeper 实现了一种"),r("strong",[e._v("主备模式")]),e._v("的系统架构来保持集群中各个副本之间的数据一致性.")]),e._v(" "),r("p",[e._v("Leader 选举是保证分布式数据一致性的关键所在. 当 Zookeeper 集群中的一台服务器出现以下两种情况之一时, 需要进入 Leader 选举.")]),e._v(" "),r("ul",[r("li",[e._v("服务器"),r("strong",[e._v("初始化")]),e._v("启动.")]),e._v(" "),r("li",[e._v("服务器"),r("strong",[e._v("运行期间无法和 Leader 保持连接")]),e._v(".")])]),e._v(" "),r("p",[e._v("下面就两种情况进行分析讲解.")]),e._v(" "),r("h6",{attrs:{id:"_1-服务器启动时期的leader选举"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-服务器启动时期的leader选举"}},[e._v("#")]),e._v(" (1)服务器启动时期的Leader选举")]),e._v(" "),r("p",[e._v("进行选举至少需要 2 台服务器, 这里以 3 台机器的集群为例说明. 在集群初始化阶段, 当服务器 Server1 启动时, 其单独无法进行和完成 Leader 选举; 当服务器 Server2 启动时, 此时两台机器可以相互通信, 每台机器都试图找到 Leader, 于是进入 Leader 选举过程.")]),e._v(" "),r("p",[e._v("选举过程如下:")]),e._v(" "),r("p",[r("strong",[e._v("1. 每个 Server 发出一个投票")]),e._v(". 由于是初始情况, Server1 和 Server2 都会将"),r("strong",[e._v("自己")]),e._v("作为 Leader 服务器来进行投票, 每次投票会包含所推举的服务器的 myid 和 ZXID, 使用 "),r("strong",[e._v("(myid, ZXID)")]),e._v(" 来表示, 此时 Server1 的投票为 (1, 0), Server2 的投票为 (2, 0), 然后各自将这个投票发给集群中其他机器.")]),e._v(" "),r("p",[r("strong",[e._v("2. 接受来自各个服务器的投票")]),e._v(". 集群的每个服务器收到投票后, 首先判断该投票的有效性, 如检查是否是本轮投票, 是否来自 LOOKING 状态的服务器.")]),e._v(" "),r("p",[r("strong",[e._v("3. 处理投票")]),e._v(". 针对每一个投票, 服务器都需要将别人的投票和自己的投票进行 PK, PK 规则如下:")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("优先检查 ZXID")]),e._v(". ZXID 比较大的服务器优先作为 Leader.")]),e._v(" "),r("li",[r("strong",[e._v("如果 ZXID 相同, 那么就比较 myid")]),e._v(". myid 较大的服务器作为 Leader 服务器.")])]),e._v(" "),r("p",[e._v("对于 Server1 而言, 它的投票是 (1, 0), 接收 Server2 的投票为(2, 0), 首先会比较两者的 ZXID, 均为 0, 再比较 myid, 此时 Server2 的 myid 最大, 于是更新自己的投票为 (2, 0), 然后重新投票. 对于 Server2 而言, 其无须更新自己的投票, 只是再次向集群中所有机器发出上一次投票信息即可.")]),e._v(" "),r("p",[r("strong",[e._v("4. 统计投票")]),e._v(". 每次投票后, 服务器都会统计投票信息, 判断是否已经有过半机器接受到相同的投票信息, 对于 Server1, Server2 而言, 都统计出集群中已经有两台机器接受了 (2, 0) 的投票信息, 此时便认为已经选出了 Leader.")]),e._v(" "),r("p",[r("strong",[e._v("5. 改变服务器状态")]),e._v(". 一旦确定了 Leader, 每个服务器就会更新自己的状态, 如果是 Follower, 那么就变更为 FOLLOWING, 如果是 Leader, 就变更为 LEADING.")]),e._v(" "),r("h6",{attrs:{id:"_2-服务器运行时期的leader选举"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-服务器运行时期的leader选举"}},[e._v("#")]),e._v(" (2)服务器运行时期的Leader选举")]),e._v(" "),r("p",[e._v("在 ZK 运行期间, 有非 Leader 服务器宕机或新加入也不会影响 Leader, 但一旦 Leader 服务器挂了, 那么整个集群将"),r("strong",[e._v("暂停")]),e._v("对外服务, 进入新一轮 Leader 选举, 其过程和启动时期的选举过程基本一致.")]),e._v(" "),r("p",[e._v("假设正在运行的有 Server1, Server2, Server3 三台服务器, 当前 Leader 是 Server2, 若某一时刻 Leader 挂了, 此时便开始 Leader 选举.")]),e._v(" "),r("p",[e._v("选举过程如下:")]),e._v(" "),r("p",[r("strong",[e._v("1. 变更状态")]),e._v(". Leader 挂后, 余下的非 Observer 服务器都会将自己的状态变更为 LOOKING, 然后开始进入 Leader 选举过程.")]),e._v(" "),r("p",[r("strong",[e._v("2. 每个 Server 发出一个投票")]),e._v(". 在运行期间, 每个服务器上的 ZXID 可能"),r("strong",[e._v("不同")]),e._v(", 此时假定 Server1 的 ZXID 为 123, Server3 的 ZXID 为 122; 在第一轮投票中, Server1 和 Server3 都会投"),r("strong",[e._v("自己")]),e._v(", 产生投票 (1, 123), (3, 122), 然后各自将投票发送给集群中所有机器.")]),e._v(" "),r("p",[r("strong",[e._v("3. 接收来自各个服务器的投票")]),e._v(". 与启动时过程相同.")]),e._v(" "),r("p",[r("strong",[e._v("4. 处理投票")]),e._v(". 与启动时过程相同, 此时 Server1 将会成为 Leader.")]),e._v(" "),r("p",[r("strong",[e._v("5. 统计投票")]),e._v(". 与启动时过程相同.")]),e._v(" "),r("p",[r("strong",[e._v("6. 改变服务器的状态")]),e._v(". 与启动时过程相同.")]),e._v(" "),r("h5",{attrs:{id:"_3-leader选举算法分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-leader选举算法分析"}},[e._v("#")]),e._v(" 3.Leader选举算法分析")]),e._v(" "),r("p",[e._v("在 3.4.0 后的 ZK 版本只保留了 TCP 版本的 "),r("strong",[e._v("FastLeaderElection")]),e._v(" 选举算法.")]),e._v(" "),r("h6",{attrs:{id:"_1-术语解释"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-术语解释"}},[e._v("#")]),e._v(" (1)术语解释")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("SID(服务器ID)")]),e._v(": 一个数字, 标识 ZK 集群中的一台机器, 每台机器不能重复. SID 与 "),r("strong",[e._v("myid")]),e._v(" 的值一致.")]),e._v(" "),r("li",[r("strong",[e._v("ZXID(事务ID)")]),e._v(": ZXID 是一个事务 ID, 用来唯一标识因此服务器状态的变更. 在某一个时刻, 集群中每台机器的 ZXID 值"),r("strong",[e._v("不一定完全都一致")]),e._v(".")]),e._v(" "),r("li",[r("strong",[e._v("Vote(投票)")]),e._v(": Leader 选举需通过投票实现, 当集群中的机器发现自己无法检测到 Leader 机器的时候, 就会开始尝试进行投票.")]),e._v(" "),r("li",[r("strong",[e._v("Quorum(过半数机器")]),e._v("): 一个量词, 通常指过半数的机器.")])]),e._v(" "),r("h6",{attrs:{id:"_2-算法分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-算法分析"}},[e._v("#")]),e._v(" (2)算法分析")]),e._v(" "),r("p",[e._v("当一台机器进入 Leader 选举时, 当前集群可能会处于以下两种状态:")]),e._v(" "),r("ul",[r("li",[e._v("集群中已经存在 Leader.")]),e._v(" "),r("li",[e._v("集群中不存在 Leader.")])]),e._v(" "),r("p",[e._v("对于"),r("strong",[e._v("集群中已经存在 Leader")]),e._v(" 而言, 比如集群加入新机器. 这种情况下新机器试图去选举 Leader 时, 会被告知当前服务器的 Leader 信息, 对于新机器而言, 仅仅需要和 Leader 机器建立连接并进行状态同步即可.")]),e._v(" "),r("p",[e._v("而在"),r("strong",[e._v("集群中不存在 Leader")]),e._v(" 情况下则会相对复杂, 其步骤如下:")]),e._v(" "),r("p",[r("strong",[e._v("1. 第一次投票")])]),e._v(" "),r("p",[e._v("无论哪种情况导致进行 Leader 选举, 集群的所有机器都处于试图选举出一个 Leader 的状态, 即 "),r("strong",[e._v("LOOKING")]),e._v(" 状态, LOOKING 机器会向所有其他机器发送消息, 该消息称为"),r("strong",[e._v("投票")]),e._v(". 投票中包含了 SID(服务器的唯一标识) 和 ZXID(事务ID), "),r("strong",[e._v("(SID, ZXID) 形式来标识一次投票信息")]),e._v(".")]),e._v(" "),r("p",[e._v("假设集群由 5 台机器组成, SID 分别为 1, 2, 3, 4, 5, ZXID 分别为 9, 9, 9, 8, 8, 并且此时 SID 为 2 的机器是 Leader 机器, 某一时刻, 1, 2 所在机器出现故障, 因此集群开始进行 Leader 选举. 在第一次投票时, 每台机器都会将"),r("strong",[e._v("自己")]),e._v("作为投票对象, 于是 SID 为 3, 4, 5 的机器投票情况分别为 (3, 9), (4, 8), (5, 8).")]),e._v(" "),r("p",[r("strong",[e._v("2. 变更投票")])]),e._v(" "),r("p",[e._v("每台机器发出投票后, 也会"),r("strong",[e._v("收到")]),e._v("其他机器的投票, 每台机器会根据一定规则来处理收到的其他机器的投票, 并以此来决定是否需要变更自己的投票, 这个规则也是整个 Leader 选举算法的核心所在, 其描述如下:")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("vote_sid")]),e._v(": 接收到的投票中所推举 Leader 服务器的 SID.")]),e._v(" "),r("li",[r("strong",[e._v("vote_zxid")]),e._v(": 接收到的投票中所推举 Leader 服务器的 ZXID.")]),e._v(" "),r("li",[r("strong",[e._v("self_sid")]),e._v(": 当前服务器自己的 SID.")]),e._v(" "),r("li",[r("strong",[e._v("self_zxid")]),e._v(": 当前服务器自己的 ZXID.")])]),e._v(" "),r("p",[e._v("每次对收到的投票的处理, 都是对 "),r("strong",[e._v("(vote_sid, vote_zxid)")]),e._v(" 和 "),r("strong",[e._v("(self_sid, self_zxid)")]),e._v(" 进行对比的过程.")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("规则一")]),e._v(": 如果 vote_zxid 大于 self_zxid, 就认可当前收到的投票, 并再次将该投票发送出去.")]),e._v(" "),r("li",[r("strong",[e._v("规则二")]),e._v(": 如果 vote_zxid 小于 self_zxid, 那么坚持自己的投票, 不做任何变更.")]),e._v(" "),r("li",[r("strong",[e._v("规则三")]),e._v(": 如果 vote_zxid 等于 self_zxid, 那么就对比两者的 SID, 如果 vote_sid 大于 self_sid, 那么就认可当前收到的投票, 并再次将该投票发送出去.")]),e._v(" "),r("li",[r("strong",[e._v("规则四")]),e._v(": 如果 vote_zxid 等于 self_zxid, 并且 vote_sid 小于 self_sid, 那么坚持自己的投票, 不做任何变更.")])]),e._v(" "),r("p",[e._v("简而言之就是: "),r("strong",[e._v("==ZXID 大的优先, ZXID 相同时 SID 大的优先==")]),e._v(".")]),e._v(" "),r("p",[e._v("结合上面规则, 给出下面的集群变更过程.")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220107210442583.png",alt:"image-20220107210442583"}})]),e._v(" "),r("p",[r("strong",[e._v("3. 确定Leader")])]),e._v(" "),r("p",[e._v("经过第二轮投票后, 集群中的每台机器都会再次接收到其他机器的投票, 然后开始统计投票, 如果一台机器收到了"),r("strong",[e._v("超过半数")]),e._v("的相同投票, 那么这个投票对应的 SID 机器即为 Leader. 此时 Server3 将成为 Leader.")]),e._v(" "),r("p",[e._v("由上面规则可知, "),r("strong",[e._v("==通常哪台服务器上的数据越新(ZXID 会越大), 其成为 Leader 的可能性越大, 也就越能够保证数据的恢复. 如果 ZXID 相同, 则 SID 越大机会越大==")]),e._v(".")]),e._v(" "),r("h5",{attrs:{id:"_4-leader选举实现细节"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-leader选举实现细节"}},[e._v("#")]),e._v(" 4.Leader选举实现细节")]),e._v(" "),r("h6",{attrs:{id:"_1-服务器状态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-服务器状态"}},[e._v("#")]),e._v(" (1)服务器状态")]),e._v(" "),r("p",[e._v("服务器具有"),r("strong",[e._v("四种状态")]),e._v(", 分别是 LOOKING, FOLLOWING, LEADING, OBSERVING.")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("LOOKING")]),e._v(": 寻找 Leader 状态. 当服务器处于该状态时, 它会认为当前集群中没有 Leader, 因此需要进入 Leader 选举状态.")]),e._v(" "),r("li",[r("strong",[e._v("FOLLOWING")]),e._v(": 跟随者状态. 表明当前服务器角色是 Follower.")]),e._v(" "),r("li",[r("strong",[e._v("LEADING")]),e._v(": 领导者状态. 表明当前服务器角色是 Leader.")]),e._v(" "),r("li",[r("strong",[e._v("OBSERVING")]),e._v(": 观察者状态. 表明当前服务器角色是 Observer.")])]),e._v(" "),r("h6",{attrs:{id:"_2-投票数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-投票数据结构"}},[e._v("#")]),e._v(" (2)投票数据结构")]),e._v(" "),r("p",[e._v("每个投票中包含了两个最基本的信息, 所推举服务器的 "),r("strong",[e._v("SID 和 ZXID")]),e._v(", 投票(Vote) 在 ZK 中包含字段如下:")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("id")]),e._v(": 被推举的 Leader 的 SID.")]),e._v(" "),r("li",[r("strong",[e._v("zxid")]),e._v(": 被推举的 Leader 事务 ID.")]),e._v(" "),r("li",[r("strong",[e._v("electionEpoch")]),e._v(": 逻辑时钟, 用来判断多个投票是否在"),r("strong",[e._v("同一轮选举周期")]),e._v("中, 该值在服务端是一个自增序列, 每次进入新一轮的投票后, 都会对该值进行加 1 操作.")]),e._v(" "),r("li",[r("strong",[e._v("peerEpoch")]),e._v(": 被推举的 Leader 的 epoch.")]),e._v(" "),r("li",[r("strong",[e._v("state")]),e._v(": 当前服务器的状态.")])]),e._v(" "),r("h6",{attrs:{id:"_3-quorumcnxmanager-网络i-o"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-quorumcnxmanager-网络i-o"}},[e._v("#")]),e._v(" (3)QuorumCnxManager(网络I/O)")]),e._v(" "),r("p",[e._v("每台服务器在启动过程中, 会启动一个 QuorumPeerManager, 负责各台服务器之间的底层 Leader 选举过程中的网络通信.")]),e._v(" "),r("p",[r("strong",[e._v("1. 消息队列")])]),e._v(" "),r("p",[e._v("QuorumCnxManager 内部维护了一系列的队列, 用来保存接收到的, 待发送的消息以及消息的发送器, 除接收队列以外, 其他队列都按照 SID 分组形成队列集合, 如一个集群中除了自身还有 3 台机器, 那么就会为这 3 台机器分别创建一个发送队列, 互不干扰.")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("recvQueue")]),e._v(": 消息接收队列, 用于存放那些从其他服务器接收到的消息.")]),e._v(" "),r("li",[r("strong",[e._v("queueSendMap")]),e._v(": 消息发送队列, 用于保存那些待发送的消息, 按照 SID 进行分组.")]),e._v(" "),r("li",[r("strong",[e._v("senderWorkerMap")]),e._v(": 发送器集合, 每个 SenderWorker 消息发送器, 都对应一台远程 ZK 服务器, 负责消息的发送, 也按照 SID 进行分组.")]),e._v(" "),r("li",[r("strong",[e._v("lastMessageSent")]),e._v(": 最近发送过的消息, 为每个 SID 保留最近发送过的一个消息.")])]),e._v(" "),r("p",[r("strong",[e._v("2. 建立连接")])]),e._v(" "),r("p",[e._v("为了能够相互投票, ZK 集群中的所有机器都需要两两建立网络连接. QuorumCnxManager 在启动时会创建一个 ServerSocket 来监听 Leader 选举的通信端口(默认为 3888). 开启监听后, ZK 能够不断地接收到来自其他服务器的创建连接请求, 在接收到其他服务器的 TCP 连接请求时, 会进行处理. 一旦连接建立, 就会根据远程服务器的 SID 来创建相应的消息发送器 SendWorker 和消息接收器 RecvWorker, 并启动.")]),e._v(" "),r("p",[r("strong",[e._v("3. 消息接收与发送")])]),e._v(" "),r("p",[r("strong",[e._v("消息接收")]),e._v(": 由消息接收器 RecvWorker 负责, 由于 Zookeeper 为每个远程服务器都分配一个单独的 RecvWorker, 因此每个 RecvWorker 只需要不断地从这个 TCP 连接中读取消息, 并将其保存到 recvQueue 队列中.")]),e._v(" "),r("p",[r("strong",[e._v("消息发送")]),e._v(": 由于 ZK 为每个远程服务器都分配一个单独的 SendWorker, 因此每个 SendWorker 只需要不断地从对应的消息发送队列中获取出一个消息发送即可, 同时将这个消息放入 lastMessageSent 中. 在 SendWorker 中, 一旦 Zookeeper 发现针对当前服务器的消息发送队列为空, 那么此时需要从 lastMessageSent 中取出一个最近发送过的消息来进行再次发送, 这是为了解决接收方在消息接收前或者接收到消息后服务器挂了, 导致消息尚未被正确处理.")]),e._v(" "),r("h6",{attrs:{id:"_4-fastleaderelection-选举算法核心"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-fastleaderelection-选举算法核心"}},[e._v("#")]),e._v(" (4)FastLeaderElection(选举算法核心)")]),e._v(" "),r("p",[e._v("几个核心概念:")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("外部投票")]),e._v(": 特指其他服务器发来的投票.")]),e._v(" "),r("li",[r("strong",[e._v("内部投票")]),e._v(": 服务器自身当前的投票.")]),e._v(" "),r("li",[r("strong",[e._v("选举轮次")]),e._v(": Leader 选举的轮次, 即 logicalclock.")]),e._v(" "),r("li",[r("strong",[e._v("PK")]),e._v(": 对内部投票和外部投票进行对比来确定是否需要变更内部投票.")])]),e._v(" "),r("p",[r("strong",[e._v("1. 选票管理")])]),e._v(" "),r("p",[e._v("下图是选票管理过程中相关组件之间的协作关系.")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220107210956395.png",alt:""}})]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("sendqueue")]),e._v(": 选票发送队列, 用于保存待发送的选票.")]),e._v(" "),r("li",[r("strong",[e._v("recvqueue")]),e._v(": 选票接收队列, 用于保存接收到的外部投票.")]),e._v(" "),r("li",[r("strong",[e._v("WorkerReceiver")]),e._v(": 选票接收器. 其会不断地从 QuorumCnxManager 中获取其他服务器发来的选举消息, 并将其转换成一个选票, 然后保存到 recvqueue 中, 在选票接收过程中, 如果发现该外部选票的选举轮次小于当前服务器的, 那么忽略该外部投票, 同时立即发送自己的内部投票.")]),e._v(" "),r("li",[r("strong",[e._v("WorkerSender")]),e._v(": 选票发送器, 不断地从 sendqueue 中获取待发送的选票, 并将其传递到底层 QuorumCnxManager 中.")])]),e._v(" "),r("p",[r("strong",[e._v("2. 算法核心")])]),e._v(" "),r("p",[e._v("上图展示了 FastLeaderElection 模块是如何与底层网络 I/O 进行交互的. Leader 选举的基本流程如下:")]),e._v(" "),r("p",[r("strong",[e._v("① 自增选举轮次")]),e._v(". Zookeeper 规定所有有效的投票都必须在同一轮次中, 在开始新一轮投票时, 会首先对 logicalclock 进行自增操作.")]),e._v(" "),r("p",[r("strong",[e._v("② 初始化选票")]),e._v(". 在开始进行新一轮投票之前, 每个服务器都会初始化自身的选票, 每台服务器在初始化阶段都会将自己推举为 Leader.")]),e._v(" "),r("p",[r("strong",[e._v("③ 发送初始化选票")]),e._v(". 完成选票的初始化后, 服务器就会发起第一次投票. ZK 会将刚刚初始化好的选票放入 sendqueue 中, 由发送器 WorkerSender 发送出去.")]),e._v(" "),r("p",[r("strong",[e._v("④ 接收外部投票")]),e._v(". 每台服务器会不断从 recvqueue 队列中获取外部选票.")]),e._v(" "),r("p",[r("strong",[e._v("⑤ 判断选举轮次")]),e._v(". 在发送完初始化选票之后, 接着开始处理外部投票. 在处理外部投票时, 会根据"),r("strong",[e._v("选举轮次")]),e._v("来进行不同的处理.")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("外部投票的选举轮次大于内部投票")]),e._v(". 若服务器自身的选举轮次落后于该外部投票对应服务器的选举轮次, 那么就会立即"),r("strong",[e._v("更新自己的选举轮次")]),e._v("(logicalclock), 并清空所有已经收到的投票, 然后使用初始化的投票来进行 PK 以确定是否变更内部投票. 最终再将内部投票发送出去.")]),e._v(" "),r("li",[r("strong",[e._v("外部投票的选举轮次小于内部投票")]),e._v(". 若服务器接收的外选票的选举轮次落后于自身的选举轮次, 那么 ZK 就会直接"),r("strong",[e._v("忽略该外部投票")]),e._v(", 不做任何处理, 并返回步骤 4.")]),e._v(" "),r("li",[r("strong",[e._v("外部投票的选举轮次等于内部投票")]),e._v(". 此时可以开始进行选票 PK.")])]),e._v(" "),r("p",[r("strong",[e._v("⑥ 选票PK")]),e._v(". 在进行选票 PK 时, 符合任意一个条件就需要变更投票.")]),e._v(" "),r("ul",[r("li",[e._v("若外部投票中推举的 Leader 服务器的"),r("strong",[e._v("选举轮次")]),e._v("大于内部投票, 那么需要变更投票.")]),e._v(" "),r("li",[e._v("若选举轮次一致, 那么就对比两者的 ZXID, 若外部投票的 ZXID 大, 那么需要变更投票.")]),e._v(" "),r("li",[e._v("若两者的 ZXID 一致, 那么就对比两者的 SID, 若外部投票的 SID 大, 那么就需要变更投票.")])]),e._v(" "),r("p",[r("strong",[e._v("⑦ 变更投票")]),e._v(". 经过 PK 后, 若确定了外部投票优于内部投票, 那么就变更投票, 即使用外部投票的选票信息来覆盖内部投票, 变更完成后, 再次将这个变更后的内部投票发送出去.")]),e._v(" "),r("p",[r("strong",[e._v("⑧ 选票归档")]),e._v(". 无论是否变更了投票, 都会将刚刚收到的那份外部投票放入选票集合 recvset 中进行归档. recvset 用于记录当前服务器在本轮次的 Leader 选举中收到的所有外部投票 (按照服务队的 SID 区别, 如 {(1, vote1), (2, vote2)...}).")]),e._v(" "),r("p",[r("strong",[e._v("⑨ 统计投票")]),e._v(". 完成选票归档后, 就可以开始统计投票, 统计投票是为了统计集群中是否已经有过半的服务器认可了当前的内部投票, 如果确定已经有过半服务器认可了该投票, 则终止投票. 否则返回步骤 4.")]),e._v(" "),r("p",[r("strong",[e._v("⑩ 更新服务器状态")]),e._v(". 若已经确定可以终止投票, 那么就开始更新服务器状态, 服务器首选判断当前被过半服务器认可的投票所对应的 Leader 服务器是否是自己, 若是自己, 则将自己的服务器状态更新为 LEADING, 若不是, 则根据具体情况来确定自己是 FOLLOWING 或是 OBSERVING.")]),e._v(" "),r("p",[e._v("以上 10 个步骤就是 FastLeaderElection 的核心, 其中步骤 4-9 会经过几轮循环, 直到有 Leader 选举产生.")]),e._v(" "),r("h5",{attrs:{id:"_5-数据同步机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-数据同步机制"}},[e._v("#")]),e._v(" 5.数据同步机制")]),e._v(" "),r("p",[e._v("ZK 的数据同步是为了保证各结点中的"),r("strong",[e._v("数据一致性")]),e._v(", 同步时涉及两个流程, 一个是正常的"),r("strong",[e._v("客户端数据提交")]),e._v(", 另一个是集群某个结点宕机在恢复后的"),r("strong",[e._v("数据同步")]),e._v(".")]),e._v(" "),r("p",[r("strong",[e._v("客户端写入请求: ​")]),e._v("​"),r("strong",[r("strong",[e._v("写入请求的大至流程是, Leader 接收客户端")])]),e._v("​"),r("strong",[e._v("写请求")]),e._v(", 并"),r("strong",[e._v("同步给各个子结点")]),e._v(". 如下图:")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220107211151215.png",alt:""}})]),e._v(" "),r("p",[e._v("但实际情况要复杂的多, 比如 client 并不知道哪个结点是 Leader, 有可能写的请求会发给 Follower, 由 Follower 再"),r("strong",[e._v("转发")]),e._v("给 Leader 进行"),r("strong",[e._v("同步")]),e._v("处理.")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220107212056670.png",alt:""}})]),e._v(" "),r("p",[e._v("客户端"),r("strong",[e._v("写入流程")]),e._v("说明:")]),e._v(" "),r("ol",[r("li",[e._v("client 向 ZK 中的 server 发送写请求, 如果该 server 不是 Leader, 则会将该写请求转发给 Leader, Leader 将请求事务以 "),r("strong",[e._v("proposal")]),e._v(" 形式分发给 Follower;")]),e._v(" "),r("li",[e._v("当 Follower 收到 Leader 的 proposal 时, 根据接收的"),r("strong",[e._v("先后顺序")]),e._v("处理 proposal;")]),e._v(" "),r("li",[e._v("当 Leader 收到 Follower 针对某个 proposal "),r("strong",[e._v("过半的 ack 后")]),e._v(", 则发起"),r("strong",[e._v("事务提交")]),e._v(", 重新发起一个 "),r("strong",[e._v("commit")]),e._v(" 的 proposal;")]),e._v(" "),r("li",[e._v("Follower 收到 commit 的 proposal 后, "),r("strong",[e._v("记录事务提交")]),e._v(", 并把数据更新到"),r("strong",[e._v("内存数据库")]),e._v(";")]),e._v(" "),r("li",[e._v("当写成功后, 反馈给 client.")])]),e._v(" "),r("p",[r("strong",[e._v("服务结点初始化同步:")])]),e._v(" "),r("p",[e._v("在集群运行过程当中如果有一个 Follower 结点宕机, 由于宕机结点没过半, 集群仍然能正常服务. 当 Leader 收到新的客户端请求, 此时无法同步给宕机的结点. 造成数据不一致. 为解决这个问题, 当"),r("strong",[e._v("结点启动")]),e._v("时, 第一件事情就是找当前的 Leader, 比对数据是否一致. 如果不一致则开始"),r("strong",[e._v("同步")]),e._v(", 同步完成之后在进行对外提供服务.")]),e._v(" "),r("p",[e._v("如何比对 Leader 的数据"),r("strong",[e._v("版本")]),e._v("呢, 这里通过 "),r("strong",[e._v("ZXID 事务 ID")]),e._v(" 来确认. 比 Leader 低就需要同步.")]),e._v(" "),r("p",[r("strong",[e._v("ZXID: ​")]),e._v("​"),r("strong",[r("strong",[e._v("ZXID 是一个长度 64 位的数字, 其中低 32 位是按照数字递增, ​")])]),e._v("​"),r("strong",[r("strong",[r("strong",[e._v("任何数据的变更"),r("strong",[r("strong",[r("strong",[e._v("​")])]),e._v("都会导致低 32 位的数字简单加 1. 高 32 位是 leader 周期编号, 每当选举出一个新的 Leader 时, 新的 Leader 就从本地事务日志中取出 ZXID, 然后解析出高 32 位的周期编号, 进行")])]),e._v("​")]),e._v("加 1")]),e._v(", 再将"),r("strong",[e._v("低 32 位的全部设置为 0")]),e._v(". 这样就保证每次"),r("strong",[e._v("新选举 Leader 后")]),e._v(" ZXID 的"),r("strong",[e._v("唯一且递增")]),e._v(".")]),e._v(" "),r("h4",{attrs:{id:"数据与存储"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据与存储"}},[e._v("#")]),e._v(" 数据与存储")]),e._v(" "),r("p",[e._v("ZK 的数据模型是树结构, 在"),r("strong",[e._v("内存数据库")]),e._v("存储了整棵树的内容, 包括所有结点路径, 结点数据, ACL 信息. ZK 会定时将这个数据存储到磁盘上. 在 ZK 服务器启动期间, 首先会进行数据初始化工作, 将存储在磁盘上的数据文件加载到服务器内存中.")]),e._v(" "),r("h5",{attrs:{id:"_1-内存数据"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-内存数据"}},[e._v("#")]),e._v(" 1.内存数据")]),e._v(" "),r("p",[r("strong",[e._v("DataTree")]),e._v(" 是内存数据存储的核心, 是一个树结构, "),r("strong",[e._v("代表了内存中一份完整的数据")]),e._v(". DataTree 不包含任何与网络, 客户端连接及请求处理相关的业务逻辑, 是一个独立的组件.")]),e._v(" "),r("p",[r("strong",[e._v("DataNode 是数据存储的最小单元")]),e._v(", 其内部除了保存了结点的数据内容, ACL 列表, 结点状态之外, 还记录了父结点的引用和子结点列表两个属性, 其也提供了对子结点列表进行操作的接口.")]),e._v(" "),r("p",[r("strong",[e._v("ZKDatabase")]),e._v(" 是 ZK 的内存数据库, 管理 ZK 的所有会话, DataTree 存储和事务日志. ZKDatabase 会定时向磁盘 dump 快照数据, 同时在 ZK 启动时, 会通过磁盘的事务日志和快照文件"),r("strong",[e._v("恢复")]),e._v("成一个完整的内存数据库.")]),e._v(" "),r("h5",{attrs:{id:"_2-事务日志"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-事务日志"}},[e._v("#")]),e._v(" 2.事务日志")]),e._v(" "),r("p",[e._v("在配置 ZK 集群时需要配置 dataDir 目录, 其用来存储事务日志文件.")]),e._v(" "),r("h5",{attrs:{id:"_3-数据快照-snapshot"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-数据快照-snapshot"}},[e._v("#")]),e._v(" 3.数据快照(snapshot)")]),e._v(" "),r("p",[e._v("数据快照是 ZK 数据存储中非常核心的运行机制, 数据快照用来记录 ZK 服务器上某一时刻的"),r("strong",[e._v("全量")]),e._v("内存数据内容, 并将其写入指定的"),r("strong",[e._v("磁盘")]),e._v("文件中.")]),e._v(" "),r("p",[e._v("‍")]),e._v(" "),r("p",[e._v("‍")])])}),[],!1,null,null,null);r.default=a.exports}}]);