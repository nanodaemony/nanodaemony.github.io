(window.webpackJsonp=window.webpackJsonp||[]).push([[222],{525:function(s,t,a){"use strict";a.r(t);var n=a(7),v=Object(n.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"_10-基础理论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-基础理论"}},[s._v("#")]),s._v(" 10.基础理论")]),s._v(" "),t("h4",{attrs:{id:"时间复杂度分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度分析"}},[s._v("#")]),s._v(" 时间复杂度分析")]),s._v(" "),t("h5",{attrs:{id:"_1-大o表示法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-大o表示法"}},[s._v("#")]),s._v(" 1.大O表示法")]),s._v(" "),t("p",[s._v("一般来说, 计算机算法是问题规模 n 的函数 "),t("strong",[s._v("f(n)")]),s._v(" , 算法的时间复杂度也因此记做:")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("T(n) = O(f(n))\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("算法执行时间的增长率与 f(n) 的增长率正相关, 称作渐近时间复杂度(Asymptotic Time Complexity), 简称"),t("strong",[s._v("时间复杂度")]),s._v(".")]),s._v(" "),t("p",[s._v("常见的"),t("strong",[s._v("大 O")]),s._v(" 运行时间:")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("O(1)")]),s._v("  也叫"),t("strong",[s._v("常数时间")])]),s._v(" "),t("li",[t("strong",[s._v("O(log n)")]),s._v("  也叫"),t("strong",[s._v("对数时间")])]),s._v(" "),t("li",[t("strong",[s._v("O(n)")]),s._v("  也叫"),t("strong",[s._v("线性时间")])]),s._v(" "),t("li",[t("strong",[s._v("O(n*log n)")])]),s._v(" "),t("li",[t("strong",[s._v("O(n2)")])]),s._v(" "),t("li",[t("strong",[s._v("O(n!)")])])]),s._v(" "),t("p",[s._v("其他表示法:")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("大O")]),s._v(" 表示法分析得到算法"),t("strong",[s._v("最大")]),s._v("的时间需求, 用的最多.")]),s._v(" "),t("li",[t("strong",[s._v("大Ω")]),s._v(" 表示法分析得到算法"),t("strong",[s._v("最小")]),s._v("的时间需求.")]),s._v(" "),t("li",[t("strong",[s._v("大Θ")]),s._v(" 表示法分析得到的是位于上下界之间的复杂度.")])]),s._v(" "),t("h5",{attrs:{id:"_2-算法分析注意事项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-算法分析注意事项"}},[s._v("#")]),s._v(" 2.算法分析注意事项")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("大常数")]),s._v(": 在求近似时, 如果低级项的常数系数很大, 那么近似的结果是错误的.")]),s._v(" "),t("li",[t("strong",[s._v("缓存")]),s._v(": 计算机系统会使用缓存技术来组织内存, 访问数组相邻的元素会比访问不相邻的元素快很多.")]),s._v(" "),t("li",[t("strong",[s._v("对最坏情况下的性能的保证")]),s._v(": 在核反应堆, 心脏起搏器或者刹车控制器中的软件, 最坏情况下的性能是十分重要的.")]),s._v(" "),t("li",[t("strong",[s._v("随机化算法")]),s._v(": 通过打乱输入, 去除算法对输入的依赖.")]),s._v(" "),t("li",[t("strong",[s._v("均摊分析")]),s._v(": 将所有操作的总成本除于操作总数来将成本均摊. 例如对一个空栈进行 N 次连续的 push() 调用需要访问数组的次数为 N + 4 + 8 + 16 +...+ 2N = 5N - 4(N 是向数组写入元素的次数, 其余都是调整数组大小时进行复制需要的访问数组次数), 均摊后访问数组的平均次数为常数.")])]),s._v(" "),t("blockquote",[t("p",[s._v("分析例子")])]),s._v(" "),t("p",[s._v("以下两层循环, 内循环常数时间执行 O(1) 复杂度, 外循环 O(n) 复杂度, "),t("strong",[s._v("整体 O(n) 复杂度")]),s._v(".")]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("i "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("to")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token namespace"}},[s._v("n")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("i "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("to")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        sum "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" sum "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("h4",{attrs:{id:"递归"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#递归"}},[s._v("#")]),s._v(" 递归")]),s._v(" "),t("p",[s._v("自己调用"),t("strong",[s._v("自己")]),s._v("的方法称为递归方法, 递归是将一个问题分成"),t("strong",[s._v("同样的但更小的子问题")]),s._v("的求解过程. 递归一般更消耗内存, 需要设置"),t("strong",[s._v("递归终止条件")]),s._v(", 否则无限递归会导致栈溢出.")]),s._v(" "),t("p",[s._v("递归的两个法则:")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("基准情形")]),s._v(": 必须总要有某些基准的情形, 即 Base Case, 它们不用递归就能求解.")]),s._v(" "),t("li",[t("strong",[s._v("不断推进")]),s._v(": 对于那些要递归求解的情形, 递归调用必须总能够朝着一个"),t("strong",[s._v("基准情形")]),s._v("推进.")])]),s._v(" "),t("h4",{attrs:{id:"动态规划"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[s._v("#")]),s._v(" 动态规划")]),s._v(" "),t("h5",{attrs:{id:"_1-概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[s._v("#")]),s._v(" 1.概述")]),s._v(" "),t("p",[s._v("动态规划(Dynamic Programming)算法的核心思想是: 将大问题划分为小问题进行解决, 从而一步步获取最优解的处理算法.")]),s._v(" "),t("p",[s._v("动态规划算法与分治算法类似, 其基本思想也是"),t("strong",[s._v("将待求解问题分解成若干个子问题, 先求解子问题, 然后从这些子问题的解得到原问题的解")]),s._v(".")]),s._v(" "),t("p",[s._v("与分治法不同的是, 适合于用"),t("strong",[s._v("动态规划")]),s._v("求解的问题, 经分解得到子问题往往不是互相独立的, "),t("strong",[s._v("即下一个子阶段的求解是建立在上一个子阶段的解的基础上, 进行进一步的求解")]),s._v(".")]),s._v(" "),t("p",[s._v("动态规划可以通过"),t("strong",[s._v("填表")]),s._v("的方式来逐步推进, 得到"),t("strong",[s._v("最优解")]),s._v(".")]),s._v(" "),t("p",[s._v("递归和动态规划都是将原问题拆成多个子问题然后求解, 可以保存子问题的解, 避免重复计算.")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/dynamic_programming.png",alt:""}})]),s._v(" "),t("h5",{attrs:{id:"_2-动态规划问题的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-动态规划问题的特点"}},[s._v("#")]),s._v(" 2.动态规划问题的特点")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("最优子结构")]),s._v(": 可以通过"),t("strong",[s._v("子问题的最优解")]),s._v(", 推导出当前问题的最优解.")]),s._v(" "),t("li",[t("strong",[s._v("无后效性")]),s._v(": 现在的最优解和以后要发生的事"),t("strong",[s._v("没有关系")]),s._v(".")]),s._v(" "),t("li",[t("strong",[s._v("重复子问题")]),s._v(": 每个问题的最优解反反复复都是同样的解法, 就是找当前的最优子结构.")])]),s._v(" "),t("h4",{attrs:{id:"分治算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分治算法"}},[s._v("#")]),s._v(" 分治算法")]),s._v(" "),t("p",[s._v('字面上的解释是 "'),t("strong",[s._v("分而治之")]),s._v('", 就是把一个复杂的问题'),t("strong",[s._v("分成两个或更多的相同或相似的子问题")]),s._v(", 再把子问题分成更小的子问题, 直到最后子问题可以简单的直接求解, 原问题的解即子问题的解的"),t("strong",[s._v("合并")]),s._v(".")]),s._v(" "),t("blockquote",[t("p",[s._v("应用场景")])]),s._v(" "),t("p",[s._v("分治算法可以求解的一些经典问题:")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("二分搜索")])]),s._v(" "),t("li",[s._v("大整数乘法")]),s._v(" "),t("li",[s._v("棋盘覆盖")]),s._v(" "),t("li",[t("strong",[s._v("归并排序")])]),s._v(" "),t("li",[t("strong",[s._v("快速排序")])]),s._v(" "),t("li",[s._v("线性时间选")]),s._v(" "),t("li",[s._v("最接近点对问题")]),s._v(" "),t("li",[s._v("循环赛日程表")]),s._v(" "),t("li",[s._v("汉诺塔")])]),s._v(" "),t("p",[s._v("分治法在每一层递归上都有三个步骤:")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("分解")]),s._v(": 将原问题分解为若干个规模较小, 相互独立, 与原问题形式相同的子问题.")]),s._v(" "),t("li",[t("strong",[s._v("解决")]),s._v(": 若子问题规模较小而容易被解决则"),t("strong",[s._v("直接解")]),s._v(", 否则"),t("strong",[s._v("递归地解")]),s._v("各个子问题.")]),s._v(" "),t("li",[t("strong",[s._v("合并")]),s._v(": 将各个子问题的解合并为原问题的解.")])]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("P")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" ≤ n0\n   then "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("ADHOC")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("P")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 将P分解为较小的子问题 P1 ,P2 ,…,Pk")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" i ← "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("to")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token namespace"}},[s._v("k")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("do")]),s._v(" yi ← "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Divide")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("and"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Conquer")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Pi")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("   "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 递归解决Pi")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("T")]),s._v(" ← "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("MERGE")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("y1"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" y2"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" …"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" yk"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("   "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 合并子问题")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("T")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br")])]),t("p",[s._v("其中 |P| 表示问题 P 的规模; n0 为一阈值, 表示当问题 P 的规模不超过 n0 时, 问题已容易直接解出, 不必再继续分解. ADHOC(P) 是该分治法中的基本子算法, 用于直接解小规模的问题 P. 因此, 当 P 的规模不超过 n0 时直接用算法 ADHOC(P) 求解. 算法 "),t("code",[s._v("MERGE(y1, y2, …, yk)")]),s._v("​ 是该分治法中的"),t("strong",[s._v("合并")]),s._v("子算法, 用于将 P 的子问题 P1, P2, …, Pk 的相应的解 y1, y2, …, yk 合并为 P 的解.")]),s._v(" "),t("h4",{attrs:{id:"贪心算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法"}},[s._v("#")]),s._v(" 贪心算法")]),s._v(" "),t("p",[s._v("贪心算法指在对问题进行求解时, 在每一步选择中都采取最好或者最优(即最有利)的选择, 从而希望能够导致结果是最好或者最优的算法.")]),s._v(" "),t("p",[s._v("贪心算法所得到的结果"),t("strong",[s._v("不一定是最优")]),s._v("的结果(有时候会是最优解), 但是都是相对近似(接近)最优解的结果.")]),s._v(" "),t("p",[s._v("贪心只是一种"),t("strong",[s._v("思想")]),s._v(", 这种思想很多都源于生活.")]),s._v(" "),t("p",[s._v("‍")]),s._v(" "),t("p",[s._v("‍")]),s._v(" "),t("h4",{attrs:{id:"参考资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[s._v("#")]),s._v(" 参考资料")]),s._v(" "),t("ul",[t("li",[s._v("《算法 第四版》")])])])}),[],!1,null,null,null);t.default=v.exports}}]);