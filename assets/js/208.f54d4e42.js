(window.webpackJsonp=window.webpackJsonp||[]).push([[208],{535:function(t,_,v){"use strict";v.r(_);var r=v(4),a=Object(r.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"_110-系统设计基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_110-系统设计基础"}},[t._v("#")]),t._v(" 110.系统设计基础")]),t._v(" "),_("h4",{attrs:{id:"系统架构发展"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#系统架构发展"}},[t._v("#")]),t._v(" 系统架构发展")]),t._v(" "),_("p",[t._v("架构不是一来就完全定好的, 而是不断发展演变而来的. 看看架构的发展史.")]),t._v(" "),_("h5",{attrs:{id:"_1-单体系统时代"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-单体系统时代"}},[t._v("#")]),t._v(" 1.单体系统时代")]),t._v(" "),_("p",[t._v("单台机器就足以支撑其良好运行的系统, 不仅易于开发, 测试, 部署, 且由于系统中各个功能, 模块, 方法的调用过程都是进程内调用, 不会发生进程间通信, 因此连运行效率也高.")]),t._v(" "),_("p",[t._v("然而单体应用缺乏隔离能力, 难以阻断错误传播, 不便于动态更新程序.")]),t._v(" "),_("h5",{attrs:{id:"_2-soa时代"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-soa时代"}},[t._v("#")]),t._v(" 2.SOA时代")]),t._v(" "),_("p",[t._v("SOA 对大型的单体系统进行拆分, 让每一个子系统都能独立地部署, 运行, 更新.")]),t._v(" "),_("p",[t._v("SOA 包含的许多概念, 思想都已经能在今天的微服务中找到对应的身影了, 譬如服务之间的松散耦合, 注册, 发现, 治理, 隔离, 编排等.")]),t._v(" "),_("h5",{attrs:{id:"_3-微服务时代🌟"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-微服务时代🌟"}},[t._v("#")]),t._v(" 3.微服务时代🌟")]),t._v(" "),_("p",[t._v("微服务是一种软件开发技术, 是 SOA 的一种变体. ---维基百科")]),t._v(" "),_("p",[t._v("一种更现代的定义: 微服务是一种通过多个小型服务组合来构建单个应用的架构风格, 这些服务围绕业务能力而非特定的技术标准来构建. 各个服务可以采用不同的编程语言, 不同的数据存储技术, 运行在不同的进程之中. 服务采取轻量级的通信机制和自动化的部署机制实现通信与运维.")]),t._v(" "),_("p",[_("strong",[t._v("微服务的九个核心的业务与技术特征")])]),t._v(" "),_("blockquote",[_("p",[t._v("摘自:《Microservices: A Definition of This New Architectural Term》")])]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("围绕业务能力构建")]),t._v(". 有怎样结构, 规模, 能力的团队, 就会产生对应结构, 规模, 能力的产品.")]),t._v(" "),_("li",[_("strong",[t._v("分散治理")]),t._v(". 指服务对应的开发团队有直接对服务运行质量负责的责任, 也有不受外界干预地掌控服务各个方面的权力, 譬如选择与其他服务异构的技术来实现自己的服务.")]),t._v(" "),_("li",[_("strong",[t._v("通过服务来实现独立自治的组件")]),t._v(". 服务是进程外组件, 通过远程调用来提供功能, 尽管远程服务调用有更高的成本, 但这是为组件带来自治与隔离能力的必要代价.")]),t._v(" "),_("li",[_("strong",[t._v("产品化思维")]),t._v(". 避免把软件研发视作要去完成某种功能, 而是视作一种持续改进, 提升的过程.")]),t._v(" "),_("li",[_("strong",[t._v("数据去中心化")]),t._v(". 微服务明确提倡数据应该按领域分散管理, 更新, 维护, 存储. 在单体服务中, 一个系统的各个功能模块通常会使用同一个数据库.")]),t._v(" "),_("li",[_("strong",[t._v("弱终端弱管道")]),t._v(". 微服务提倡使用类似于经典 UNIX 过滤器那样简单直接的通信方式, 所以 RESTful 风格的通信在微服务中会是更合适的选择.")]),t._v(" "),_("li",[_("strong",[t._v("容错性设计")]),t._v(". 不再虚幻地追求服务永远稳定, 而是接受服务总会出错的现实, 要求在微服务的设计中, 能够有自动的机制对其依赖的服务进行快速故障检测, 在持续出错的时候进行隔离, 在服务恢复的时候重新联通. 可靠系统完全可能由会出错的服务组成, 这是微服务最大的价值所在.")]),t._v(" "),_("li",[_("strong",[t._v("演进式设计")]),t._v(". 容错性设计承认服务会出错, 演进式设计则承认服务会被报废淘汰. 一个设计良好的服务, 应该是能够报废的, 而不是期望得到长存永生. 假如系统中出现不可更改, 无可替代的服务, 这并不能说明这个服务多么优秀, 多么重要, 反而是一种系统设计上脆弱的表现, 微服务所追求的自治, 隔离, 也是反对这种脆弱性的表现.")]),t._v(" "),_("li",[_("strong",[t._v("基础设施自动化")]),t._v(". 基础设施自动化, 如 CI/CD 的长足发展, 显著减少了构建, 发布, 运维工作的复杂性.")])]),t._v(" "),_("p",[t._v('从以上微服务的定义和特征中, 可以明显地感觉到微服务追求的是更加自由的架构风格, 摒弃了几乎所有 SOA 里可以抛弃的约束和规定, 提倡以"实践标准"代替"规范标准". 对于服务的注册发现, 跟踪治理, 负载均衡, 故障隔离, 认证授权, 伸缩扩展, 传输通信, 事务处理等问题, 微服务中将不再有统一的解决方案. 比如仅一个服务间远程调用问题, 可选的就有 Thrift, Dubbo, gRPC 等多种解决方案.')]),t._v(" "),_("p",[t._v("微服务带来的自由是把双刃剑. 可以自由选择架构需要的技术标准, 系统架构复杂性以及对整体架构能力的要求也更进一步.")]),t._v(" "),_("h5",{attrs:{id:"_4-云原生时代🌟"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-云原生时代🌟"}},[t._v("#")]),t._v(" 4.云原生时代🌟")]),t._v(" "),_("p",[t._v("分布式架构中出现的问题, 如注册发现, 跟踪治理, 负载均衡, 传输通信等, 其实在 SOA 时代就已经存在了, 只要是分布式架构的系统, 就无法完全避免. 但不妨换个思路来想一下, 这些问题一定要由软件系统自己来解决吗?")]),t._v(" "),_("p",[t._v("如果不局限于采用软件的方式, 这些问题几乎都有对应的"),_("strong",[t._v("硬件解决方案")]),t._v(". 譬如, 某个系统需要伸缩扩容, 通常会购买新的服务器, 部署若干副本实例来分担压力; 如果某个系统需要解决负载均衡问题, 通常会布置负载均衡器, 选择恰当的均衡算法来分流; 如果需要解决传输安全问题, 通常会布置 TLS 传输链路, 配置好 CA 证书以保证通信不被窃听篡改; 如果需要解决服务发现问题, 通常会设置 DNS 服务器, 让服务访问依赖稳定的记录名而不是易变的 IP 地址, 等等.")]),t._v(" "),_("p",[t._v("其实这些问题大多有了专职化的"),_("strong",[t._v("基础设施")]),t._v("去解决, 在微服务时代, 人们之所以选择在"),_("strong",[t._v("软件的代码层面")]),t._v("而不是硬件的基础设施层面去解决这些分布式问题, 很大程度上是因为由硬件构成的基础设施跟不上由软件构成的应用服务的灵活性的无奈之举.")]),t._v(" "),_("p",[t._v("被业界广泛认可, 普遍采用的通过"),_("strong",[t._v("虚拟化基础设施")]),t._v("去解决分布式架构问题的开始于 Kubernetes. Kubernetes 提供的=="),_("strong",[t._v("基础设施层面")]),t._v("==的解决方案与传统 Spring Cloud 中提供的**==应用层面==**的解决方案的对比, 尽管因为各自出发点不同, 解决问题的方法和效果都有所差异, 但这无疑是提供了一条全新的, 前途更加广阔的解题思路.")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"center"}}),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("Kubernetes")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("Spring Cloud")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("弹性伸缩")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("Autoscaling")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("---")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("服务发现")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("KubeDNS/CoreNDS")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("Spring Cloud Eureka")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("配置中心")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("ConfigMap/Secret")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("Spring Cloud Config")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("服务网关")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("Ingress Controller")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("Spring Cloud Zuul")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("负载均衡")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("Load Balancer")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("Spring Cloud Ribbon")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("服务安全")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("RBAC API")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("Spring Cloud Security")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("跟踪监控")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("Metrics API/Dashboard")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("Spring Cloud Turbine")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("降级熔断")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("---")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("Spring Cloud Hystrix")])])])]),t._v(" "),_("p",[_("strong",[t._v("当虚拟化的基础设施从单个服务的容器扩展至由多个容器构成的服务集群, 通信网络和存储设施时, 软件与硬件的界限便已模糊. 一旦虚拟化的硬件能够跟上软件的灵活性, 那些与业务无关的技术性问题便有可能从软件层面剥离, 悄无声息地在硬件基础设施之内解决, 让软件得以只专注业务, 真正围绕业务能力构建团队与产品")]),t._v(".")]),t._v(" "),_("p",[_("strong",[t._v('从软件层面独立应对分布式架构所带来的各种问题, 发展到应用代码与基础设施软, 硬一体, 合力应对架构问题, 这就是"云原生时代".')])]),t._v(" "),_("p",[t._v("云原生时代追求的目标与此前微服务时代追求的目标并没有本质改变.")]),t._v(" "),_("p",[t._v("Kubernetes 虽然成为容器战争胜利者, 但 Kubernetes 仍然没能完美解决全部的分布式问题. 仅从功能上看, 单纯的 Kubernetes 反而不如之前的 Spring Cloud 方案. 比如微服务 A 调用了微服务 B 的两个服务, 称为 B1 和 B2, 假设 B1 表现正常但 B2 出现了持续的 500 异常, 那在达到一定阈值之后就应该对 B2 进行熔断, 以避免产生雪崩效应. 如果仅在基础设施层面来处理, 这会遇到一个两难问题, 切断 A 到 B 的网络通路会影响 B1 的正常调用, 不切断则会持续受 B2 的错误影响.")]),t._v(" "),_("p",[t._v("以上问题在通过 Spring Cloud 这类通过应用代码实现的微服务中并不难处理, 既然是使用程序代码来解决问题, 只要合乎逻辑, 想要实现什么功能, 只受限于开发人员的想象力与技术能力. 但基础设施是针对整个容器来管理的, 粒度相对粗犷, 只能到容器层面, 对单个远程服务则很难有效管控. 类似的, 在服务的监控, 认证, 授权, 安全, 负载均衡等方面都有可能面临细化管理的需求, 譬如服务调用时的负载均衡, 往往需要根据流量特征, 调整负载均衡的层次, 算法等, 而 DNS 虽然能实现一定程度的负载均衡, 但通常并不能满足这些额外的需求.")]),t._v(" "),_("p",[t._v('为了解决这一类问题, 虚拟化的基础设施很快完成了第二次进化, 引入了今天被称为"'),_("strong",[t._v("服务网格")]),t._v('"(Service Mesh)的"'),_("strong",[t._v("边车代理模式")]),t._v('"(Sidecar Proxy). 在虚拟化场景中的边车指的是由系统自动在服务容器(通常是指 Kubernetes 的 Pod)中注入一个通信代理服务器, 以类似网络安全里中间人攻击的方式进行流量劫持, 在应用毫无感知的情况下, 悄然接管应用所有对外通信. 这个代理除了实现正常的服务间通信外(称为数据平面通信), 还接收来自控制器的指令(称为控制平面通信), 根据控制平面中的配置, 对数据平面通信的内容进行分析处理, 以实现熔断, 认证, 度量, 监控, 负载均衡等各种附加功能. 通过边车代理模式, 便实现了既不需要在应用层面加入额外的处理代码, 也提供了几乎不亚于程序代码的精细管理能力.')]),t._v(" "),_("p",[t._v('服务网格可能会成为微服务之间通信交互的主流模式, 把"选择什么通信协议""怎样调度流量""如何认证授权"之类的技术问题隔离于程序代码之外, 取代今天 Spring Cloud 全家桶中大部分组件的功能. 微服务只需要考虑业务本身的逻辑, 这才是最理想的智能终端解决方案. 业务与技术完全分离, 远程与本地完全透明, 也许这就是最好的时代了吧.')]),t._v(" "),_("h5",{attrs:{id:"_5-无服务时代🌟"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-无服务时代🌟"}},[t._v("#")]),t._v(" 5.无服务时代🌟")]),t._v(" "),_("p",[t._v('无服务其实含义是"无限服务", 也就是'),_("strong",[t._v("无限的性能")]),t._v(".")]),t._v(" "),_("p",[t._v("无服务的愿景是让开发者只需要纯粹地关注业务: 不需要考虑技术组件, 后端的技术组件是现成的, 可以直接取用, 没有采购, 版权和选型的烦恼; 不需要考虑如何部署, 部署过程完全托管到云端, 由云端自动完成; 不需要考虑算力, 有整个数据中心支撑, 算力可以认为是无限的; 不需要操心运维, 维护系统持续平稳运行是云计算服务商的责任而不再是开发者的责任.")]),t._v(" "),_("p",[t._v('无服务现在还没有一个特别权威的"官方"定义, 但它的概念并没有前面提到的各种架构那么复杂, 本来无服务也是以"简单"为主要卖点的, 它只涉及两块内容: 后端设施(Backend)和函数(Function).')]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("后端设施")]),t._v("是指数据库, 消息队列, 日志, 存储等这类用于支撑业务逻辑运行, 但本身无业务含义的"),_("strong",[t._v("技术组件")]),t._v(', 这些后端设施都运行在云中, 在无服务中将它们称为"后端即服务"(Backend as a Service, BaaS).')]),t._v(" "),_("li",[_("strong",[t._v("函数")]),t._v("是指"),_("strong",[t._v("业务逻辑代码")]),t._v(', 这里函数的概念与粒度都已经很接近于程序编码角度的函数了, 其区别是无服务中的函数运行在云端, 不必考虑算力问题, 也不必考虑容量规划(从技术角度可以不考虑, 从计费的角度还是要掂量一下的), 在无服务中将其称为"函数即服务"(Function as a Service, FaaS).')])]),t._v(" "),_("p",[t._v("无服务架构确实能够降低一些应用的开发和运维环节的成本, 譬如不需要交互的离线大规模计算, 又譬如多数Web资讯类网站, 小程序, 公共 API 服务, 移动应用服务端等都契合于无服务架构所擅长的短链接, 无状态, 适合事件驱动的交互形式. 但另一方面, 对于那些信息管理系统, 网络游戏等对于具有业务"),_("strong",[t._v("逻辑复杂, 依赖服务端状态, 响应速度要求较高")]),t._v(', 需要长链接等特征的应用, 至少目前是相对不那么适合的. 这是因为无服务天生"无限算力"的假设决定了它必须要按使用量(函数运算的时间和占用的内存)计费以控制消耗的算力的规模, 因而函数不会一直以活动状态常驻服务器, 请求到了才会开始运行, 这就导致了函数不便依赖服务端状态, 也导致了函数会有冷启动时间, 响应的性能可能不太好. 目前无服务的冷启动过程大概是在数十到百毫秒级别, 对于 Java 这类启动性能差的应用, 甚至是接近秒的级别.')]),t._v(" "),_("h4",{attrs:{id:"系统特性🌟"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#系统特性🌟"}},[t._v("#")]),t._v(" 系统特性🌟")]),t._v(" "),_("h5",{attrs:{id:"_1-伸缩性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-伸缩性"}},[t._v("#")]),t._v(" 1.伸缩性")]),t._v(" "),_("p",[t._v("指不断向集群中"),_("strong",[t._v("添加服务器")]),t._v("来缓解不断上升的用户"),_("strong",[t._v("并发访问压力和不断增长的数据存储需求")]),t._v(".")]),t._v(" "),_("h6",{attrs:{id:"_1-伸缩性与性能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-伸缩性与性能"}},[t._v("#")]),t._v(" (1)伸缩性与性能")]),t._v(" "),_("p",[t._v("如果系统存在"),_("strong",[t._v("性能问题")]),t._v(", 那么单个用户的请求总是很慢的; 如果系统存在"),_("strong",[t._v("伸缩性问题")]),t._v(", 那么"),_("strong",[t._v("单个")]),t._v("用户的"),_("strong",[t._v("请求可能会很快")]),t._v(", 但是在"),_("strong",[t._v("并发数很高")]),t._v("的情况下系统会很慢.")]),t._v(" "),_("h6",{attrs:{id:"_2-实现伸缩性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-实现伸缩性"}},[t._v("#")]),t._v(" (2)实现伸缩性")]),t._v(" "),_("p",[_("strong",[t._v("应用服务器")]),t._v("只要提供**==无状态服务==**, 那就可以很容易地通过负载均衡器向集群中添加新的服务器.")]),t._v(" "),_("p",[_("strong",[t._v("关系型数据库")]),t._v("的伸缩性通过 "),_("strong",[t._v("Sharding")]),t._v(" 来实现, 将"),_("strong",[t._v("数据按一定的规则分布到不同的节点")]),t._v("上, 从而解决单台存储服务器的存储空间限制. 对于"),_("strong",[t._v("非关系型数据库")]),t._v(", 它们天生就是为海量数据而诞生, 对伸缩性的支持较好.")]),t._v(" "),_("h5",{attrs:{id:"_2-扩展性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-扩展性"}},[t._v("#")]),t._v(" 2.扩展性")]),t._v(" "),_("p",[t._v("拓展性指添加"),_("strong",[t._v("新功能")]),t._v("时对现有系统的其它应用无影响, 这要求不同应用具备"),_("strong",[t._v("低耦合")]),t._v("的特点.")]),t._v(" "),_("p",[t._v("实现可扩展主要有两种方式:")]),t._v(" "),_("ul",[_("li",[t._v("使用"),_("strong",[t._v("消息队列")]),t._v("进行解耦, 应用之间通过"),_("strong",[t._v("消息传递")]),t._v("进行通信;")]),t._v(" "),_("li",[t._v("使用"),_("strong",[t._v("分布式服务")]),t._v("将业务和"),_("strong",[t._v("可复用的服务")]),t._v("分离开, 业务使用分布式服务框架调用可复用的服务. 新增的产品可以通过调用可复用的服务来实现业务逻辑, 对其它产品没有影响.")])]),t._v(" "),_("h5",{attrs:{id:"_3-可用性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-可用性"}},[t._v("#")]),t._v(" 3.可用性")]),t._v(" "),_("h6",{attrs:{id:"_1-冗余"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-冗余"}},[t._v("#")]),t._v(" (1)冗余")]),t._v(" "),_("p",[t._v("保证"),_("strong",[t._v("高可用")]),t._v("的主要手段是使用"),_("strong",[t._v("冗余")]),t._v(", 当某个服务器故障时就请求其它服务器.")]),t._v(" "),_("p",[_("strong",[t._v("应用服务器")]),t._v("的冗余比较容易实现, 只要"),_("strong",[t._v("保证应用服务器不具有状态")]),t._v(", 那么某个应用服务器故障时, 负载均衡器将该应用服务器原先的用户请求转发到另一个应用服务器上, 不会对用户有任何影响.")]),t._v(" "),_("p",[_("strong",[t._v("存储服务器")]),t._v("的冗余需要使用"),_("strong",[t._v("主从复制")]),t._v("来实现, 当主服务器故障时, 需要切换从服务器为主服务器.")]),t._v(" "),_("h6",{attrs:{id:"_2-系统监控"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-系统监控"}},[t._v("#")]),t._v(" (2)系统监控")]),t._v(" "),_("p",[t._v("对 "),_("strong",[t._v("CPU, 内存, 磁盘, 网络")]),t._v("等系统负载信息进行监控, 当某个信息达到一定阈值时通知运维人员, 从而在系统发生故障之前及时发现问题.")]),t._v(" "),_("h6",{attrs:{id:"_3-服务降级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-服务降级"}},[t._v("#")]),t._v(" (3)服务降级")]),t._v(" "),_("p",[_("strong",[t._v("服务降级")]),t._v("是系统为了应对大量的请求, "),_("strong",[t._v("主动关闭部分功能")]),t._v(", 从而"),_("strong",[t._v("保证核心功能")]),t._v("可用.")]),t._v(" "),_("h5",{attrs:{id:"_4-安全性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-安全性"}},[t._v("#")]),t._v(" 4.安全性")]),t._v(" "),_("p",[t._v("要求系统在应对各种"),_("strong",[t._v("攻击手段")]),t._v("时能够有可靠的应对措施.")]),t._v(" "),_("h4",{attrs:{id:"系统性能评价🌟"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#系统性能评价🌟"}},[t._v("#")]),t._v(" 系统性能评价🌟")]),t._v(" "),_("h5",{attrs:{id:"_1-性能指标"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-性能指标"}},[t._v("#")]),t._v(" 1.性能指标")]),t._v(" "),_("h6",{attrs:{id:"_1-响应时间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-响应时间"}},[t._v("#")]),t._v(" (1)响应时间")]),t._v(" "),_("p",[t._v("指某个请求从"),_("strong",[t._v("发出到接收到响应")]),t._v("消耗的时间. 在对响应时间进行测试时, 通常采用重复请求的方式, 然后计算平均响应时间.")]),t._v(" "),_("p",[_("strong",[t._v("P90/P95/P99")]),t._v(": 单个请求响应耗时"),_("strong",[t._v("从小到大")]),t._v("排列, 顺序处于 90%/95%/99% 位置的值即为 P90/P95/P99 值.")]),t._v(" "),_("h6",{attrs:{id:"_2-吞吐量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-吞吐量"}},[t._v("#")]),t._v(" (2)吞吐量")]),t._v(" "),_("p",[t._v("指系统在"),_("strong",[t._v("单位时间")]),t._v("内可以处理的"),_("strong",[t._v("请求数量")]),t._v(", 通常使用"),_("strong",[t._v("每秒请求数")]),t._v("来衡量.")]),t._v(" "),_("h6",{attrs:{id:"_3-并发用户数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-并发用户数"}},[t._v("#")]),t._v(" (3)并发用户数")]),t._v(" "),_("p",[t._v("指系统能"),_("strong",[t._v("同时处理的并发用户请求")]),t._v("数量. 在没有并发存在的系统中, 请求被"),_("strong",[t._v("顺序执行")]),t._v(", 此时"),_("strong",[t._v("响应时间为吞吐量的倒数")]),t._v(". 例如系统支持的吞吐量为 100 req/s, 那么平均响应时间应该为 0.01s.")]),t._v(" "),_("p",[t._v("目前的大型系统都支持"),_("strong",[t._v("多线程")]),t._v("来处理并发请求, 多线程能够提高吞吐量以及缩短响应时间, 主要有两个原因:")]),t._v(" "),_("ul",[_("li",[t._v("多 CPU")]),t._v(" "),_("li",[t._v("IO 等待时间")])]),t._v(" "),_("p",[t._v("使用 "),_("strong",[t._v("IO 多路复用")]),t._v("等方式, 系统在等待一个 IO 操作完成的这段时间内不需要被阻塞, 可以去处理其它请求. 通过将这个等待时间利用起来, 使得 "),_("strong",[t._v("CPU 利用率")]),t._v("大大提高. 并发用户数不是越高越好, 因为如果并发用户数太高, 系统来不及处理这么多的请求, 会使得过多的请求需要等待, 那么响应时间就会大大提高.")]),t._v(" "),_("h5",{attrs:{id:"_2-系统性能优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-系统性能优化"}},[t._v("#")]),t._v(" 2.系统性能优化")]),t._v(" "),_("h6",{attrs:{id:"_1-集群"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-集群"}},[t._v("#")]),t._v(" (1)集群")]),t._v(" "),_("p",[t._v("将多台服务器组成"),_("strong",[t._v("集群")]),t._v(", 使用"),_("strong",[t._v("负载均衡")]),t._v("将请求转发到集群中, 避免单一服务器的负载压力过大导致性能降低.")]),t._v(" "),_("h6",{attrs:{id:"_2-缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-缓存"}},[t._v("#")]),t._v(" (2)缓存")]),t._v(" "),_("p",[_("strong",[t._v("缓存")]),t._v("能够提高性能的原因如下:")]),t._v(" "),_("ul",[_("li",[t._v("缓存数据通常位于"),_("strong",[t._v("内存等介质")]),t._v("中, 数据"),_("strong",[t._v("读取")]),t._v("特别快;")]),t._v(" "),_("li",[t._v("缓存数据可以位于"),_("strong",[t._v("靠近用户的地理位置")]),t._v("上;")]),t._v(" "),_("li",[t._v("可以将计算结果进行缓存, 从而"),_("strong",[t._v("避免重复计算")]),t._v(".")])]),t._v(" "),_("h6",{attrs:{id:"_3-异步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-异步"}},[t._v("#")]),t._v(" (3)异步")]),t._v(" "),_("p",[t._v("某些流程可以将操作转换为异步消息, 将消息发送到"),_("strong",[t._v("消息队列")]),t._v("之后立即返回, 之后这个操作会被"),_("strong",[t._v("异步处理")]),t._v(". 比如某些"),_("strong",[t._v("与主线业务关联不大的统计, 更新流程")]),t._v("等.")]),t._v(" "),_("h4",{attrs:{id:"好系统标准"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#好系统标准"}},[t._v("#")]),t._v(" 好系统标准")]),t._v(" "),_("ul",[_("li",[t._v("不同模块间完全没有影响")]),t._v(" "),_("li",[t._v("只共享Immutable Data")]),t._v(" "),_("li",[t._v("共享 Mutable Data, 但是 interface 少, 而且"),_("strong",[t._v("几乎不变")])]),t._v(" "),_("li",[t._v("interface 变化次数/ implementation 变化次数比例小")])]),t._v(" "),_("p",[t._v("==先考虑业务架构, 再考虑技术架构.==")]),t._v(" "),_("p",[t._v("‍")]),t._v(" "),_("p",[t._v("‍")]),t._v(" "),_("h4",{attrs:{id:"参考资料"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),_("ul",[_("li",[t._v("周志明-《凤凰架构》")]),t._v(" "),_("li",[_("a",{attrs:{href:"http://www.jscape.com/blog/load-balancing-algorithms",target:"_blank",rel:"noopener noreferrer"}},[t._v("Comparing Load Balancing Algorithms"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"http://slideplayer.com/slide/6599069/#",target:"_blank",rel:"noopener noreferrer"}},[t._v("Redirection and Load Balancing"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=a.exports}}]);