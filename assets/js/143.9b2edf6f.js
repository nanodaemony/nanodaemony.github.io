(window.webpackJsonp=window.webpackJsonp||[]).push([[143],{456:function(_,v,r){"use strict";r.r(v);var t=r(7),s=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"_300-分布式共识算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_300-分布式共识算法"}},[_._v("#")]),_._v(" 300.分布式共识算法")]),_._v(" "),v("p",[_._v("在对一个分布式系统进行架构设计的过程中, 往往会在系统的"),v("strong",[_._v("可用性和数据一致性")]),_._v("之间进行反复权衡, 于是就产生了一系列"),v("mark",[v("strong",[_._v("一致性协议")])]),_._v(".")]),_._v(" "),v("p",[v("strong",[_._v("二阶段提交(2PC)")]),_._v("  协议解决了"),v("strong",[_._v("分布式事务的原子性")]),_._v("问题.")]),_._v(" "),v("p",[v("strong",[_._v("三阶段提交(3PC)")]),_._v("  协议解决了 2PC 中的"),v("strong",[_._v("无限期等待")]),_._v("问题, 但存在"),v("strong",[_._v("数据不一致")]),_._v("问题.")]),_._v(" "),v("p",[v("strong",[_._v("Paxos 算法")]),_._v("引入少数服从多数原则, 支持角色之间的轮换, 避免了单点故障, 无限期等待, 网络分区问题, 是最优秀的分布式一致性协议之一. 但是这 Paxos 算法难以理解且算法实现比较困难.")]),_._v(" "),v("p",[v("strong",[_._v("Raft 算法")]),_._v("算是对 Paxos 算法的优化, 更容易实现与落地.")]),_._v(" "),v("h4",{attrs:{id:"两阶段提交-2pc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#两阶段提交-2pc"}},[_._v("#")]),_._v(" 两阶段提交(2PC)")]),_._v(" "),v("h5",{attrs:{id:"_1-概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[_._v("#")]),_._v(" 1.概述")]),_._v(" "),v("p",[_._v("二阶段提交(2PC, Two-Phase Commit)是一种在网络或数据库领域内, 为了使基于分布式系统架构下的所有节点在进行事务提交时保持原子性和一致性而设计的一种算法(协议). PC 即"),v("strong",[_._v("阶段提交")]),_._v(".")]),_._v(" "),v("p",[_._v("二阶段提交是一种保证"),v("strong",[_._v("分布式系统数据一致性")]),_._v("的协议, 许多"),v("strong",[_._v("关系型数据库都是采用两阶段提交协议")]),_._v("来完成"),v("strong",[_._v("分布式事务")]),_._v("的处理.")]),_._v(" "),v("p",[_._v("二阶段提交协议是将"),v("strong",[_._v("事务的提交过程")]),_._v("分成两个阶段来进行处理. 主要涉及到两个角色, 分别是"),v("strong",[_._v("协调者和参与者")]),_._v(".")]),_._v(" "),v("ul",[v("li",[_._v("**协调者: ** 用来统一调度所有分布式节点的执行逻辑.")]),_._v(" "),v("li",[_._v("**参与者: ** 被调度的分布式节点.")])]),_._v(" "),v("h5",{attrs:{id:"_2-算法流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-算法流程"}},[_._v("#")]),_._v(" 2.算法流程")]),_._v(" "),v("h6",{attrs:{id:"_1-提交事务请求-投票阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-提交事务请求-投票阶段"}},[_._v("#")]),_._v(" (1)提交事务请求(投票阶段)")]),_._v(" "),v("p",[v("strong",[_._v("阶段一即投票阶段")]),_._v(".")]),_._v(" "),v("ol",[v("li",[_._v("事务询问. 协调者节点向所有参与者节点询问"),v("strong",[_._v("是否可以执行提交操作")]),_._v("(vote), 并开始等待各参与者节点的响应.")]),_._v(" "),v("li",[_._v("执行事务. 各参与者节点执行询问发起为止的所有事务操作, 并"),v("strong",[_._v("将 Undo 信息和 Redo 信息写入日志")]),_._v(".")]),_._v(" "),v("li",[_._v('各参与者节点响应协调者节点发起的询问. 如果参与者节点的事务操作实际执行成功, 则它返回一个 "YES" 消息; 如果参与者节点的事务操作实际执行失败, 则它返回一个 "NO" 消息.')])]),_._v(" "),v("h6",{attrs:{id:"_2-执行事务请求-执行阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-执行事务请求-执行阶段"}},[_._v("#")]),_._v(" (2)执行事务请求(执行阶段)")]),_._v(" "),v("p",[v("strong",[_._v("阶段二即执行阶段")]),_._v(".")]),_._v(" "),v("p",[_._v("分为以下两种情况:")]),_._v(" "),v("p",[v("mark",[v("strong",[_._v("情况1: 执行事务提交")])]),_._v(".")]),_._v(" "),v("p",[_._v('当协调者节点从所有参与者节点获得的相应消息都为 "YES" 时, '),v("strong",[_._v("执行事务提交")]),_._v(".")]),_._v(" "),v("ol",[v("li",[_._v('发送提交请求. 协调者节点向所有参与者节点发出 "'),v("strong",[_._v("正式提交")]),_._v('(Commit)" 请求.')]),_._v(" "),v("li",[_._v("事务提交. 参与者节点接受到 COMMIT 请求后正式完成操作, 并释放在整个事务期间内占用的资源.")]),_._v(" "),v("li",[_._v('反馈事务提交结果. 参与者节点完成事务提交之后, 向协调者节点发送 "ACK” 消息.')]),_._v(" "),v("li",[_._v('完成事务. 协调者节点收到所有参与者节点反馈的 "ACK” 消息后, 完成事务.')])]),_._v(" "),v("p",[v("mark",[v("strong",[_._v("情况2: 中断事务")])]),_._v(".")]),_._v(" "),v("p",[_._v('如果任一参与者节点在第一阶段返回的响应消息为 "NO", 或者协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时, 那么就会'),v("strong",[_._v("中断事务")]),_._v(".")]),_._v(" "),v("ol",[v("li",[_._v('发送回滚请求. 协调者节点向所有参与者节点发出 "'),v("strong",[_._v("回滚操作")]),_._v('(Rollback)" 的请求.')]),_._v(" "),v("li",[_._v("事务回滚. 参与者节点收到回滚请求后, 利用之前写入的 Undo 信息执行回滚, 并释放在整个事务期间内占用的资源.")]),_._v(" "),v("li",[_._v('反馈事务回滚结果. 参与者节点向协调者节点发送 "ACK" 消息.')]),_._v(" "),v("li",[_._v('中断事务. 协调者节点受到所有参与者节点反馈的 "ACK" 消息后, 完成事务中断.')])]),_._v(" "),v("p",[_._v("简单来说, 二阶段提交将一个事务的处理过程分成了 "),v("strong",[_._v("投票与执行")]),_._v(" 两个阶段, 其核心是对每个事务都采用"),v("strong",[_._v("先尝试后提交")]),_._v("的处理方式, 因此也可以将二阶段提交看做一个"),v("mark",[v("strong",[_._v("强一致性算法")])]),_._v(".")]),_._v(" "),v("h5",{attrs:{id:"_3-存在问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-存在问题"}},[_._v("#")]),_._v(" 3.存在问题")]),_._v(" "),v("p",[_._v("事实上 2PC 只解决了各个事务的"),v("strong",[_._v("原子性问题")]),_._v(", 也存在诸多问题.")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("单点故障问题")]),_._v(": 由于协调者的重要性, 一旦协调者发生故障. 参与者会一直阻塞下去. 尤其在第二阶段, 如果协调者发生故障, 那么所有的参与者还都处于锁定事务资源的状态中, 而无法继续完成事务操作.")]),_._v(" "),v("li",[v("strong",[_._v("同步阻塞问题")]),_._v(": 执行过程中, 所有参与节点都是事务"),v("strong",[_._v("阻塞型")]),_._v("的. 当参与者占有公共资源时, 其他第三方节点访问公共资源不得不处于阻塞状态.")]),_._v(" "),v("li",[v("strong",[_._v("数据不一致问题")]),_._v(": 比如当第二阶段, 协调者只发送了一部分的 Commit 请求就挂了, 那么也就意味着收到消息的参与者会进行事务的提交, 而后面没收到的则不会进行事务提交, 这就会产生"),v("strong",[_._v("数据不一致性")]),_._v("问题.")]),_._v(" "),v("li",[_._v("**太过保守: ** 二阶段提交缺乏较为完善的容错机制, 任意一个节点的失败导致整个事务的失败.")])]),_._v(" "),v("h4",{attrs:{id:"三阶段提交-3pc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三阶段提交-3pc"}},[_._v("#")]),_._v(" 三阶段提交(3PC)")]),_._v(" "),v("p",[_._v('三阶段提交(3PC) 是对二阶段提交的改进. 将 2PC 中的 "'),v("strong",[_._v("提交事务请求")]),_._v('" 的过程一分为二, 形成了三个阶段.')]),_._v(" "),v("h5",{attrs:{id:"_1-算法流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-算法流程"}},[_._v("#")]),_._v(" 1.算法流程")]),_._v(" "),v("h6",{attrs:{id:"_1-cancommit阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-cancommit阶段"}},[_._v("#")]),_._v(" (1)CanCommit阶段")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("事务询问")]),_._v(". 协调者向参与者发送 CanCommit 请求. "),v("strong",[_._v("询问是否可以执行事务提交操作")]),_._v(". 然后开始等待参与者响应.")]),_._v(" "),v("li",[v("strong",[_._v("参与者响应事务询问")]),_._v('. 参与者接到 CanCommit 请求之后, 正常情况下, 如果其自身认为可以顺利执行事务, 则返回 "Yes" 响应, 并进入预备状态. 否则反馈 "No".')])]),_._v(" "),v("h6",{attrs:{id:"_2-precommit阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-precommit阶段"}},[_._v("#")]),_._v(" (2)PreCommit阶段")]),_._v(" "),v("p",[_._v("根据阶段一的响应可能有以下两种请况:")]),_._v(" "),v("p",[v("mark",[v("strong",[_._v("情况1: 执行事务预提交")])])]),_._v(" "),v("p",[_._v("假如协调者从所有的参与者获得的反馈都是  "),v("strong",[_._v('"Yes" 响应')]),_._v(", 那么就会执行事务的"),v("strong",[_._v("预提交")]),_._v(".")]),_._v(" "),v("ol",[v("li",[_._v("发送预提交请求. "),v("strong",[_._v("协调者")]),_._v("向所有参与者发送 "),v("strong",[_._v("PreCommit")]),_._v(" 请求, 并进入 Prepared 阶段.")]),_._v(" "),v("li",[_._v("事务预提交. 参与者接收到 PreCommit 请求后, 会执行事务操作, 并将 Undo 和 Redo 信息记录到事务日志中.")]),_._v(" "),v("li",[v("strong",[_._v("各参与者向协调者反馈事务执行的响应")]),_._v('. 如果参与者成功执行了事务操作, 则返回 "ACK" 响应, 同时开始等待最终指令: '),v("strong",[_._v("提交(Commit) 或者中止(Abort)")]),_._v(" .")])]),_._v(" "),v("p",[v("mark",[v("strong",[_._v("情况2: 事务中断")])])]),_._v(" "),v("p",[_._v("假如有任何一个参与者向协调者发送了  "),v("strong",[_._v('"No" 响应')]),_._v(", 或者等待超时之后, 协调者都没有接到参与者的响应, 那么就执行"),v("strong",[_._v("事务中断")]),_._v(".")]),_._v(" "),v("ol",[v("li",[_._v("发送中断请求. 协调者向所有参与者发送 "),v("strong",[_._v("abort")]),_._v(" 请求.")]),_._v(" "),v("li",[_._v("中断事务. 参与者收到来自协调者的 abort 请求之后(或超时之后, 仍未收到协调者的请求), 执行事务的中断.")])]),_._v(" "),v("h6",{attrs:{id:"_3-docommit阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-docommit阶段"}},[_._v("#")]),_._v(" (3)DoCommit阶段")]),_._v(" "),v("p",[_._v("该阶段将进行"),v("strong",[_._v("真正的事务提交")]),_._v(", 可能会存在以下两种情况.")]),_._v(" "),v("p",[v("mark",[v("strong",[_._v("情况1: 执行提交")])])]),_._v(" "),v("ol",[v("li",[_._v('发送提交请求. 协调接收到所有参与者发送的 "ACK" 响应, 那么他将从 "'),v("strong",[_._v("预提交")]),_._v('" 状态进入到 "'),v("strong",[_._v("提交")]),_._v('" 状态. 并向所有参与者发送 '),v("strong",[_._v("doCommit")]),_._v(" 请求.")]),_._v(" "),v("li",[_._v("事务提交. 参与者接收到 doCommit 请求之后, 执行正式的事务提交, 并在完成事务提交之后释放所有事务资源.")]),_._v(" "),v("li",[_._v('反馈事务提交结果. 参与者完成事务提交之后, 向协调者发送 "ACK" 响应.')]),_._v(" "),v("li",[_._v('完成事务. 协调者接收到所有参与者的 "ACK" 响应之后, 完成事务.')])]),_._v(" "),v("p",[v("mark",[v("strong",[_._v("情况2: 中断事务")])])]),_._v(" "),v("p",[_._v('如果协调者收到任意一个参与的 "No" 响应; 或者协调者等待超时之后而无法接收到全部参与的反馈响应, 就会中断事务.')]),_._v(" "),v("ol",[v("li",[_._v("发送中断请求. 协调者向所有参与者发送 "),v("strong",[_._v("abort")]),_._v(" 请求.")]),_._v(" "),v("li",[_._v("事务回滚. 参与者接收到 abort 请求之后, 利用其在阶段二记录的 Undo 信息来执行事务的回滚操作, 并在完成回滚之后释放所有的事务资源.")]),_._v(" "),v("li",[_._v('反馈事务回滚结果. 参与者完成事务回滚之后, 向协调者发送 "ACK" 消息.')]),_._v(" "),v("li",[_._v('中断事务. 协调者接收到所有参与者反馈的 "ACK" 消息之后, 执行事务的中断.')])]),_._v(" "),v("p",[_._v("一旦进入阶段三, 可能会出现以下"),v("strong",[_._v("故障")]),_._v(":")]),_._v(" "),v("ul",[v("li",[_._v("协调者出现问题.")]),_._v(" "),v("li",[_._v("协调者和参与者之间的网络出现故障.")])]),_._v(" "),v("p",[_._v("无论哪种异常都会导致参与者无法及时接收到来自协调者的 doCommit 或者 abort 请求. 针对这样的情况, 参与者都会在"),v("strong",[_._v("等待超时")]),_._v("之后, "),v("strong",[_._v("继续进行事务的提交")]),_._v(".")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220103134558023.png",alt:""}})]),_._v(" "),v("p",[_._v("上图是 3PC 成功执行的流程图, 可以看到很多地方进行了"),v("mark",[v("strong",[_._v("超时中断处理")])]),_._v(", 比如协调者在指定时间内为收到全部的确认消息则进行事务中断的处理, 这样能"),v("strong",[_._v("减少同步阻塞")]),_._v("的时间.")]),_._v(" "),v("p",[_._v("需要注意 3PC 在 "),v("strong",[_._v("DoCommit")]),_._v(" 阶段, 即使参与者如未收到协调者发送的提交事务的请求, "),v("strong",[_._v("它也会在一定时间内默认进行事务的提交")]),_._v(". 为何这么做? 因为执行到 "),v("strong",[_._v("DoCommit")]),_._v(" 阶段时肯定保证了在第一阶段所有协调者都返回了"),v("strong",[_._v("可以执行事务")]),_._v("的响应, 这个时候"),v("strong",[_._v("有理由相信其他系统都能进行事务的执行和提交")]),_._v(", 所以不管协调者有没有发消息给参与者, 进入第三阶段参与者都会进行事务的提交操作. 因此, 相对于 2PC, 3PC 协议最大的优点在于降低了参与者的阻塞范围, 并且能够在出现单点故障后继续达成一致. "),v("mark",[v("strong",[_._v("3PC 主要解决了单点故障问题, 并减少阻塞范围")])]),_._v(", 因为即使参与者无法及时收到来自协调者的信息, 它也会"),v("strong",[_._v("默认执行 commit")]),_._v(", 而不会一直持有事务资源并处于阻塞状态.")]),_._v(" "),v("p",[_._v("3PC 通过一系列的"),v("strong",[_._v("超时机制很好的缓解了阻塞问题")]),_._v(", 但"),v("mark",[v("strong",[_._v("并没有解决一致性问题")])]),_._v(". 比如在 PreCommit 阶段, 当一个参与者收到了请求之后其他参与者和协调者挂了或者出现了"),v("strong",[_._v("网络分区")]),_._v(", 这个时候收到消息的参与者都会进行事务提交, 这就会出现"),v("strong",[_._v("数据不一致")]),_._v("性问题.")]),_._v(" "),v("p",[_._v("所以, 要解决一致性问题还需要靠 "),v("strong",[_._v("Paxos 算法")]),_._v(".")]),_._v(" "),v("h4",{attrs:{id:"paxos算法🌟"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#paxos算法🌟"}},[_._v("#")]),_._v(" Paxos算法🌟")]),_._v(" "),v("h5",{attrs:{id:"_1-概述-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述-2"}},[_._v("#")]),_._v(" 1.概述")]),_._v(" "),v("p",[_._v("Paxos 算法是一种"),v("strong",[_._v("基于消息传递且具有高度容错特性的分布式一致性算法")]),_._v(", 是目前公认的解决分布式一致性问题最有效的算法之一, "),v("strong",[_._v("其解决的问题就是在分布式系统中如何就某个值(决议)达成一致")]),_._v(". 它用于达成共识性问题, 即对多个节点产生的值, 该算法能"),v("strong",[_._v("保证只选出唯一一个值")]),_._v(". 但 Paxos 算法"),v("strong",[_._v("不仅难以理解, 更难以实现")]),_._v(".")]),_._v(" "),v("p",[_._v("一个或多个"),v("strong",[_._v("提议进程(Proposer)")]),_._v("  可以发起"),v("strong",[_._v("提案(Proposal)")]),_._v(" , Paxos 算法使所有提案中的某一个提案在"),v("strong",[_._v("所有进程中达成一致")]),_._v(". 系统中的"),v("strong",[_._v("多数派")]),_._v("同时认可该提案, 即达成了一致. 算法最多只针对一个确定的提案达成一致.")]),_._v(" "),v("p",[_._v("Paxos 算法运行在"),v("strong",[_._v("允许宕机故障的异步系统中, 不要求可靠的消息传递, 可容忍消息丢失, 延迟, 乱序以及重复")]),_._v(". 它利用大多数(Majority) 机制保证了 "),v("strong",[_._v("2F+1")]),_._v(" 的容错能力, "),v("strong",[_._v("即 2F+1 个节点的系统最多允许 F 个节点同时出现故障")]),_._v(".")]),_._v(" "),v("p",[_._v("系统中主要有三类节点:")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("提议者")]),_._v("(Proposer): "),v("strong",[_._v("提出提案")]),_._v(", 提案信息包括提案编号和提议的 value.")]),_._v(" "),v("li",[v("strong",[_._v("接受者")]),_._v("(Acceptor): 对每个提议进行"),v("strong",[_._v("投票")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("最终决策学习者")]),_._v("(Learner): 被"),v("strong",[_._v("告知投票的结果")]),_._v(", 不参与投票过程.")])]),_._v(" "),v("p",[_._v("在多副本状态机中, 每个副本可以"),v("strong",[_._v("同时")]),_._v("作为 Proposer, Acceptor, Learner 三种角色.")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220103141916509.png",alt:""}})]),_._v(" "),v("h5",{attrs:{id:"_2-算法流程-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-算法流程-2"}},[_._v("#")]),_._v(" 2.算法流程")]),_._v(" "),v("p",[_._v("Paxos 算法通过一个决议分为"),v("strong",[_._v("两个阶段")]),_._v("(因为 Learn 阶段之前决议已经"),v("strong",[_._v("形成")]),_._v("). 规定一个"),v("strong",[_._v("提议")]),_._v("包含两个字段:  "),v("strong",[_._v("[n, v]")]),_._v(" , 其中 n 为序号(具有唯一性), v 为提议值.")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("第一阶段")]),_._v(": "),v("strong",[_._v("Prepare 阶段")]),_._v(". Proposer 向 Acceptors 发出 Prepare 请求, Acceptors 针对收到的 "),v("strong",[_._v("Prepare 请求")]),_._v("进行 "),v("strong",[_._v("Promise 承诺")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("第二阶段")]),_._v(": "),v("strong",[_._v("Accept 阶段")]),_._v(". Proposer 收到多数 Acceptors 承诺的 Promise 后, 向 Acceptors 发出 "),v("strong",[_._v("Propose 请求")]),_._v(", Acceptors 针对收到的 Propose 请求进行 "),v("strong",[_._v("Accept 处理")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("第三阶段")]),_._v(": "),v("strong",[_._v("Learn 阶段")]),_._v(". Proposer 在收到"),v("strong",[_._v("多数")]),_._v(" Acceptors 的 Accept 之后, 标志着"),v("strong",[_._v("本次 Accept 成功")]),_._v(", 决议形成, 将形成的决议发送"),v("strong",[_._v("给所有 Learners")]),_._v(".")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200726161233705.png",alt:"image-20200726161233705"}})]),_._v(" "),v("p",[_._v("Paxos 算法流程中的每条"),v("strong",[_._v("消息")]),_._v("描述如下:")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("Prepare")]),_._v(": Proposer 生成"),v("strong",[_._v("全局唯一且递增的 Proposal ID")]),_._v("(可使用时间戳加 Server ID), 向所有 Acceptors 发送 Prepare 请求, 这里无需携带提案内容, 只携带 Proposal ID 即可.")]),_._v(" "),v("li",[v("strong",[_._v("Promise")]),_._v(': Acceptors 收到 Prepare 请求后, 做出 "'),v("strong",[_._v("两个承诺, 一个应答")]),_._v('".')])]),_._v(" "),v("h6",{attrs:{id:"_1-prepare阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-prepare阶段"}},[_._v("#")]),_._v(" (1)Prepare阶段")]),_._v(" "),v("p",[_._v("下图演示了"),v("strong",[_._v("两个 Proposer 和三个 Acceptor 的系统")]),_._v("中运行该算法的"),v("strong",[_._v("初始过程")]),_._v(", 每个 Proposer 都会向所有 "),v("strong",[_._v("Acceptor 发送 Prepare 请求")]),_._v(".")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200726162250052.png",alt:""}})]),_._v(" "),v("p",[_._v("当 "),v("strong",[_._v("Acceptor")]),_._v(" 接收到一个 "),v("strong",[_._v("Prepare 请求")]),_._v(", 包含的提议为  "),v("strong",[_._v("[n1, v1]")]),_._v(" , 并且之前还未接收过 Prepare 请求, 那么发送一个 "),v("strong",[_._v("Prepare 响应")]),_._v(", 设置当前接收到的提议为 [n1, v1], 并且保证以后"),v("strong",[_._v("不会再接受序号小于 n1 的提议")]),_._v(".")]),_._v(" "),v("p",[_._v("如下图, Acceptor X 在收到 [n=2, v=8] 的 Prepare 请求时, 由于之前没有接收过提议, 因此就发送一个 [no previous] 的 Prepare 响应, 设置当前接收到的提议为 [n=2, v=8], 并且保证以后"),v("strong",[_._v("不会再接受小于 2 的提议")]),_._v(". 其它的 Acceptor 类似.")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200726163626151.png",alt:""}})]),_._v(" "),v("p",[_._v("如果 Acceptor 接收到一个 Prepare 请求, 包含的提议为 [n2, v2], 并且之前已经接收过提议 [n1, v1]. 如果 n1 > n2, 那么就"),v("strong",[_._v("丢弃")]),_._v("该提议请求; 否则, 发送 Prepare 响应, 该 Prepare 响应包含之前已经接收过的提议 [n1, v1], 设置当前接收到的提议为 [n2, v2], 并且保证以后"),v("strong",[_._v("不会再接受序号小于 n2 的提议")]),_._v(".")]),_._v(" "),v("p",[_._v("如下图, Acceptor Z 收到 Proposer A 发来的 [n=2, v=8] 的 Prepare 请求, 由于之前已经接收过 [n=4, v=5] 的提议, 并且 n > 2, 因此就抛弃该提议请求; Acceptor X 收到 Proposer B 发来的 [n=4, v=5] 的 Prepare 请求, 因为之前接收到的提议为 [n=2, v=8], 并且 2 <= 4, 因此就发送 [n=2, v=8] 的 Prepare 响应, 设置当前接收到的提议为 [n=4, v=5], 并且保证以后不会再接受序号小于 4 的提议. Acceptor Y 类似.")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200726163923339.png",alt:""}})]),_._v(" "),v("h6",{attrs:{id:"_2-accept阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-accept阶段"}},[_._v("#")]),_._v(" (2)Accept阶段")]),_._v(" "),v("p",[v("strong",[_._v("当一个 Proposer 接收到超过一半 Acceptor 的 Prepare 响应时, 就可以发送 Accept 请求")]),_._v(".")]),_._v(" "),v("p",[_._v("Proposer A 接收到两个 Prepare 响应之后, "),v("strong",[_._v("就发送 [n=2, v=8] Accept 请求")]),_._v(". 该 Accept 请求会被所有 Acceptor 丢弃, 因为此时所有 Acceptor 都保证不接受序号小于 4 的提议.")]),_._v(" "),v("p",[_._v("Proposer B 过后也收到了两个 Prepare 响应, 因此也开始发送 Accept 请求. 需要注意的是, Accept 请求的 v 需要取它收到的最大提议编号对应的 v 值, 也就是 8. 因此它"),v("strong",[_._v("发送 [n=4, v=8] 的 Accept 请求")]),_._v(".")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200726164314032.png",alt:""}})]),_._v(" "),v("h6",{attrs:{id:"_3-learn阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-learn阶段"}},[_._v("#")]),_._v(" (3)Learn阶段")]),_._v(" "),v("p",[_._v("Acceptor "),v("strong",[_._v("接收到 Accept 请求时")]),_._v(", 如果序号大于等于该 Acceptor 承诺的最小序号, 那么就"),v("strong",[_._v("发送 Learn 提议给所有的 Learner")]),_._v(". 当 Learner 发现有大多数的 Acceptor 接收了某个提议, 那么该提议的"),v("strong",[_._v("提议值就被 Paxos 选择出来")]),_._v(".")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200726164623042.png",alt:""}})]),_._v(" "),v("h5",{attrs:{id:"_3-约束条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-约束条件"}},[_._v("#")]),_._v(" 3.约束条件")]),_._v(" "),v("h6",{attrs:{id:"_1-正确性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-正确性"}},[_._v("#")]),_._v(" (1)正确性")]),_._v(" "),v("p",[_._v("正确性指"),v("strong",[_._v("只有一个提议值会生效")]),_._v(". 因为 Paxos 协议要求"),v("strong",[_._v("每个生效的提议被多数 Acceptor 接收, 并且 Acceptor 不会接受两个不同的提议")]),_._v(", 因此可以保证正确性.")]),_._v(" "),v("h6",{attrs:{id:"_2-可终止性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-可终止性"}},[_._v("#")]),_._v(" (2)可终止性")]),_._v(" "),v("p",[_._v("可终止性指"),v("strong",[_._v("最后总会有一个提议生效")]),_._v(". Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢, 因此能够保证可终止性.")]),_._v(" "),v("h5",{attrs:{id:"_4-死循环问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-死循环问题"}},[_._v("#")]),_._v(" 4.死循环问题")]),_._v(" "),v("p",[_._v("死循环问题类似于两个人吵架, A 说我是对的, B 说我才是对的, 两个人谁也不让谁.")]),_._v(" "),v("p",[_._v("比如提案者 P1 提出一个方案 "),v("strong",[_._v("M1")]),_._v(", 完成了 "),v("strong",[_._v("Prepare 阶段")]),_._v("的工作, 这个时候 acceptor 则批准了 M1, 但是此时提案者 P2 同时也提出了一个方案 M2, 它也完成了 Prepare 阶段的工作. 然后 P1 的方案已经不能在第二阶段被批准了(因为 acceptor 已经批准了比 M1 更大的 M2), 所以 P1 自增方案变为 M3 重新进入 Prepare 阶段, 然后 acceptor 又批准了新的 M3 方案, 它又不能批准 M2 了, 这个时候 M2 又自增进入 Prepare 阶段.")]),_._v(" "),v("p",[_._v("就这样无休无止的永远提案下去, 这就是 Paxos 算法的"),v("strong",[_._v("死循环问题")]),_._v(".")]),_._v(" "),v("h4",{attrs:{id:"raft算法🌟"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#raft算法🌟"}},[_._v("#")]),_._v(" Raft算法🌟")]),_._v(" "),v("p",[_._v("由于 Paxos 算法非常"),v("strong",[_._v("难以理解与实现")]),_._v(", 所以不断有人尝试优化这一算法, 以易懂性为目标设计了一致性算法: "),v("strong",[_._v("Raft 算法")]),_._v(". 它是一个通俗易懂, 更"),v("strong",[_._v("容易落地")]),_._v("的分布式协议.")]),_._v(" "),v("h5",{attrs:{id:"_1-节点状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-节点状态"}},[_._v("#")]),_._v(" 1.节点状态")]),_._v(" "),v("p",[v("strong",[_._v("每个节点")]),_._v("有"),v("strong",[_._v("三个状态")]),_._v(", 它们会在三个状态之间进行变换. "),v("strong",[_._v("客户端只能从主节点写数据, 从节点里读数据")]),_._v(".")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220103143149911.png",alt:""}})]),_._v(" "),v("h5",{attrs:{id:"_2-算法流程-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-算法流程-3"}},[_._v("#")]),_._v(" 2.算法流程")]),_._v(" "),v("blockquote",[v("p",[_._v("(1)选主流程")])]),_._v(" "),v("p",[_._v("初始是 "),v("strong",[_._v("Follwer 状态节点")]),_._v(", 等 100-300ms 没有收到 Leader 节点的心跳就"),v("strong",[_._v("变候选人")]),_._v(". 候选人给大家发选票, 候选人获得大多数节点的选票就变成了 Leader 节点.")]),_._v(" "),v("p",[_._v("​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220103143515524.png",alt:""}}),_._v("​")]),_._v(" "),v("blockquote",[v("p",[_._v("(2)日志复制流程")])]),_._v(" "),v("p",[_._v("每次改变数据"),v("strong",[_._v("先记录日志")]),_._v(", "),v("strong",[_._v("日志未提交不能改节点的数值")]),_._v(". 然后 Leader 会复制数据给其他 Follower 节点, 并等大多数节点写日志成功再提交数据.")]),_._v(" "),v("p",[_._v("​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220103143841792.png",alt:""}}),_._v("​")]),_._v(" "),v("blockquote",[v("p",[_._v("(3)选举超时")])]),_._v(" "),v("p",[_._v("每个节点随机等 150 到 300MS, 如果时间到了就"),v("strong",[_._v("开始发选票")]),_._v(", 因为有的节点等的时间短, 所以它会先发选票, 从而当选成主节点. 但是如果两个候选人获得的票一样多, 它们之间就要打加时赛, 这个时候又会重新随机等 150 到 300MS, 然后发选票, 直到获得最多票当选成主节点.")]),_._v(" "),v("p",[_._v("​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220103144251603.png",alt:""}}),_._v("​")]),_._v(" "),v("blockquote",[v("p",[_._v("(4)心跳超时")])]),_._v(" "),v("p",[_._v("每个节点会记录主节点是谁, 并且和主节点之间维持一个心跳超时时间, 如果没有收到主节点回复, 从节点就要重新选举候选人节点.")]),_._v(" "),v("p",[_._v("​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220103144439665.png",alt:""}}),_._v("​")]),_._v(" "),v("blockquote",[v("p",[_._v("(5)集群中断")])]),_._v(" "),v("p",[_._v("当集群之间的部分节点失去通讯时, 主节点的日志不能复制给多个从节点就不能进行提交.")]),_._v(" "),v("p",[_._v("​"),v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220103144737904.png",alt:""}}),_._v("​")]),_._v(" "),v("blockquote",[v("p",[_._v("(6)集群恢复")])]),_._v(" "),v("p",[_._v("当集群恢复之后, 原来的主节点发现自己不是选票最多的节点, 就会变成"),v("strong",[_._v("从节点")]),_._v(", 并回滚自己的日志, 最后主节点会同步日志给从节点, 保持主从数据的一致性.")]),_._v(" "),v("h4",{attrs:{id:"其他算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他算法"}},[_._v("#")]),_._v(" 其他算法")]),_._v(" "),v("h5",{attrs:{id:"_1-zab协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-zab协议"}},[_._v("#")]),_._v(" 1.ZAB协议")]),_._v(" "),v("p",[_._v("Zookeeper 实现数据一致性的协议, 主要用于 Leader 选举和保持数据一致性. 参考: ZAB协议与Leader选举概述.")]),_._v(" "),v("p",[_._v("‍")]),_._v(" "),v("h4",{attrs:{id:"参考资料"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[_._v("#")]),_._v(" 参考资料")]),_._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://www.zhihu.com/column/paxos",target:"_blank",rel:"noopener noreferrer"}},[_._v("Paxos, Raft分布式一致性最佳实践"),v("OutboundLink")],1)])]),_._v(" "),v("p",[_._v("‍")]),_._v(" "),v("p",[_._v("‍")]),_._v(" "),v("p",[_._v("‍")])])}),[],!1,null,null,null);v.default=s.exports}}]);