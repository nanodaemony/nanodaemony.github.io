(window.webpackJsonp=window.webpackJsonp||[]).push([[249],{577:function(s,t,a){"use strict";a.r(t);var n=a(4),r=Object(n.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"_10-算法基础理论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-算法基础理论"}},[s._v("#")]),s._v(" 10.算法基础理论")]),s._v(" "),t("h4",{attrs:{id:"数学模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数学模型"}},[s._v("#")]),s._v(" 数学模型")]),s._v(" "),t("h5",{attrs:{id:"_1-近似"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-近似"}},[s._v("#")]),s._v(" 1.近似")]),s._v(" "),t("p",[s._v("N"),t("sup",[s._v("3")]),s._v("/6-N"),t("sup",[s._v("2")]),s._v("/2+N/3 ~ N"),t("sup",[s._v("3")]),s._v("/6. 使用 ~f(N) 来表示所有随着 N 的增大除以 f(N) 的结果趋近于 1 的函数.")]),s._v(" "),t("h5",{attrs:{id:"_2-增长数量级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-增长数量级"}},[s._v("#")]),s._v(" 2.增长数量级")]),s._v(" "),t("p",[s._v("N"),t("sup",[s._v("3")]),s._v("/6-N"),t("sup",[s._v("2")]),s._v("/2+N/3 的增长数量级为 O(N"),t("sup",[s._v("3")]),s._v("). 增长数量级将算法与它的具体实现隔离开来, 一个算法的增长数量级为 O(N"),t("sup",[s._v("3")]),s._v(") 与其实现的编程语言, 是否运行于特定计算机上无关.")]),s._v(" "),t("h5",{attrs:{id:"_3-内循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-内循环"}},[s._v("#")]),s._v(" 3.内循环")]),s._v(" "),t("p",[s._v("执行最频繁的指令决定了程序执行的总时间, 把这些指令称为程序的内循环.")]),s._v(" "),t("h5",{attrs:{id:"_4-成本模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-成本模型"}},[s._v("#")]),s._v(" 4.成本模型")]),s._v(" "),t("p",[s._v("使用成本模型来评估算法, 例如数组的访问次数就是一种成本模型.")]),s._v(" "),t("h4",{attrs:{id:"时间复杂度分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度分析"}},[s._v("#")]),s._v(" 时间复杂度分析")]),s._v(" "),t("h5",{attrs:{id:"_1-大o表示法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-大o表示法"}},[s._v("#")]),s._v(" 1.大O表示法")]),s._v(" "),t("p",[s._v("一般来说, 计算机算法是问题规模 n 的函数 "),t("strong",[s._v("f(n)")]),s._v(", 算法的时间复杂度也因此记做:")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("T(n) = O(f(n))\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("算法执行时间的增长率与 f(n) 的增长率正相关, 称作渐近时间复杂度(Asymptotic Time Complexity), 简称"),t("strong",[s._v("时间复杂度")]),s._v(".")]),s._v(" "),t("p",[s._v("常见的"),t("strong",[s._v("大 O")]),s._v(" 运行时间:")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("O(1)")]),s._v(" 也叫"),t("strong",[s._v("常数时间")])]),s._v(" "),t("li",[t("strong",[s._v("O(log n)")]),s._v(" 也叫"),t("strong",[s._v("对数时间")])]),s._v(" "),t("li",[t("strong",[s._v("O(n)")]),s._v(" 也叫"),t("strong",[s._v("线性时间")])]),s._v(" "),t("li",[t("strong",[s._v("O(n*log n)")])]),s._v(" "),t("li",[t("strong",[s._v("O(n2)")])]),s._v(" "),t("li",[t("strong",[s._v("O(n!)")])])]),s._v(" "),t("p",[s._v("其他表示法:")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("大O")]),s._v(" 表示法分析得到算法"),t("strong",[s._v("最大")]),s._v("的时间需求, 用的最多.")]),s._v(" "),t("li",[t("strong",[s._v("大Ω")]),s._v(" 表示法分析得到算法"),t("strong",[s._v("最小")]),s._v("的时间需求.")]),s._v(" "),t("li",[t("strong",[s._v("大Θ")]),s._v(" 表示法分析得到的是位于上下界之间的复杂度.")])]),s._v(" "),t("h5",{attrs:{id:"_2-算法分析注意事项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-算法分析注意事项"}},[s._v("#")]),s._v(" 2.算法分析注意事项")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("大常数")]),s._v(": 在求近似时, 如果低级项的常数系数很大, 那么近似的结果是错误的.")]),s._v(" "),t("li",[t("strong",[s._v("缓存")]),s._v(": 计算机系统会使用缓存技术来组织内存, 访问数组相邻的元素会比访问不相邻的元素快很多.")]),s._v(" "),t("li",[t("strong",[s._v("对最坏情况下的性能的保证")]),s._v(": 在核反应堆, 心脏起搏器或者刹车控制器中的软件, 最坏情况下的性能是十分重要的.")]),s._v(" "),t("li",[t("strong",[s._v("随机化算法")]),s._v(": 通过打乱输入, 去除算法对输入的依赖.")]),s._v(" "),t("li",[t("strong",[s._v("均摊分析")]),s._v(": 将所有操作的总成本除于操作总数来将成本均摊. 例如对一个空栈进行 N 次连续的 push() 调用需要访问数组的次数为 N + 4 + 8 + 16 +...+ 2N = 5N - 4(N 是向数组写入元素的次数, 其余都是调整数组大小时进行复制需要的访问数组次数), 均摊后访问数组的平均次数为常数.")])]),s._v(" "),t("h5",{attrs:{id:"_2-分析例子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-分析例子"}},[s._v("#")]),s._v(" 2.分析例子")]),s._v(" "),t("p",[s._v("以下两层循环, 内循环常数时间执行 O(1) 复杂度, 外循环 O(n) 复杂度, "),t("strong",[s._v("整体 O(n) 复杂度")]),s._v(".")]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("i "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("to")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token namespace"}},[s._v("n")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("i "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("to")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\t\n        sum "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" sum "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("h4",{attrs:{id:"递归"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#递归"}},[s._v("#")]),s._v(" 递归")]),s._v(" "),t("p",[s._v("自己调用"),t("strong",[s._v("自己")]),s._v("的方法称为递归方法, 递归是将一个问题分成"),t("strong",[s._v("同样的但更小的子问题")]),s._v("的求解过程. 递归一般更消耗内存, 需要设置"),t("strong",[s._v("递归终止条件")]),s._v(", 否则无限递归会导致栈溢出.")]),s._v(" "),t("p",[s._v("递归的两个法则:")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("基准情形")]),s._v(": 必须总要有某些基准的情形, 即 Base Case, 它们不用递归就能求解.")]),s._v(" "),t("li",[t("strong",[s._v("不断推进")]),s._v(": 对于那些要递归求解的情形, 递归调用必须总能够朝着一个"),t("strong",[s._v("基准情形")]),s._v("推进.")])]),s._v(" "),t("h4",{attrs:{id:"动态规划"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[s._v("#")]),s._v(" 动态规划")]),s._v(" "),t("h5",{attrs:{id:"_1-概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[s._v("#")]),s._v(" 1. 概述")]),s._v(" "),t("p",[s._v("动态规划("),t("strong",[s._v("Dynamic")]),s._v(" "),t("strong",[s._v("Programming")]),s._v(")算法的核心思想是: 将大问题划分为小问题进行解决, 从而一步步获取最优解的处理算法.")]),s._v(" "),t("p",[s._v("动态规划算法与分治算法类似, 其基本思想也是将待求解问题分解成若干个子问题, 先求解子问题, 然后从这些子问题的解得到原问题的解.")]),s._v(" "),t("p",[s._v("与分治法不同的是, 适合于用"),t("strong",[s._v("动态规划")]),s._v("求解的问题, 经分解得到子问题往往不是互相独立的 ( "),t("strong",[s._v("即下一个子阶段的求解是建立在上一个子阶段的解的基础上, 进行进一步的求解")]),s._v(" ), 上述的分治法往往没有关系.")]),s._v(" "),t("p",[s._v("动态规划可以通过"),t("strong",[s._v("填表")]),s._v("的方式来逐步推进, 得到"),t("strong",[s._v("最优解")]),s._v(".")]),s._v(" "),t("p",[s._v("递归和动态规划都是将原问题拆成多个子问题然后求解, 他们之间最本质的区别是, "),t("strong",[s._v("动态规划保存了子问题的解, 避免重复计算")]),s._v(".")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/dynamic_programming.png",alt:""}})]),s._v(" "),t("p",[s._v("动态规划一般可分为 4 类:")]),s._v(" "),t("ol",[t("li",[s._v("线性动规")]),s._v(" "),t("li",[s._v("区域动规")]),s._v(" "),t("li",[s._v("树形动规")]),s._v(" "),t("li",[s._v("背包动规")])]),s._v(" "),t("h5",{attrs:{id:"_2-动态规划问题的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-动态规划问题的特点"}},[s._v("#")]),s._v(" 2.动态规划问题的特点")]),s._v(" "),t("h6",{attrs:{id:"_1-最优子结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-最优子结构"}},[s._v("#")]),s._v(" (1)最优子结构")]),s._v(" "),t("p",[s._v("可以通过"),t("strong",[s._v("子问题的最优解")]),s._v(", 推导出当前问题的最优解.")]),s._v(" "),t("h6",{attrs:{id:"_2-无后效性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-无后效性"}},[s._v("#")]),s._v(" (2)无后效性")]),s._v(" "),t("p",[s._v("现在的最优解和以后要发生的事"),t("strong",[s._v("没有关系")]),s._v(".")]),s._v(" "),t("h6",{attrs:{id:"_3-重复子问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-重复子问题"}},[s._v("#")]),s._v(" (3)重复子问题")]),s._v(" "),t("p",[s._v("每个问题的最优解反反复复都是同样的解法, 就是找当前的最优子结构.")]),s._v(" "),t("h4",{attrs:{id:"分治算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分治算法"}},[s._v("#")]),s._v(" 分治算法")]),s._v(" "),t("h5",{attrs:{id:"_1-概述-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述-2"}},[s._v("#")]),s._v(" 1.概述")]),s._v(" "),t("p",[s._v("字面上的解释是 "),t("strong",[s._v("“分而治之”")]),s._v(", 就是把一个复杂的问题"),t("strong",[s._v("分成两个或更多的相同或相似的子问题")]),s._v(", 再把子问题分成更小的子问题, 直到最后子问题可以简单的直接求解, 原问题的解即子问题的解的"),t("strong",[s._v("合并")]),s._v(". 这个技巧是很多高效算法的基础, 如排序算法(快速排序, 归并排序), 傅立叶变换(快速傅立叶变换).")]),s._v(" "),t("p",[s._v("分治算法可以求解的一些经典问题:")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("二分搜索")])]),s._v(" "),t("li",[s._v("大整数乘法")]),s._v(" "),t("li",[s._v("棋盘覆盖")]),s._v(" "),t("li",[t("strong",[s._v("归并排序")])]),s._v(" "),t("li",[t("strong",[s._v("快速排序")])]),s._v(" "),t("li",[s._v("线性时间选")]),s._v(" "),t("li",[s._v("最接近点对问题")]),s._v(" "),t("li",[s._v("循环赛日程表")]),s._v(" "),t("li",[s._v("汉诺塔")])]),s._v(" "),t("p",[s._v("分治法在每一层递归上都有三个步骤:")]),s._v(" "),t("p",[s._v("1), "),t("strong",[s._v("分解")]),s._v(": 将原问题分解为若干个规模较小, 相互独立, 与原问题形式相同的子问题")]),s._v(" "),t("p",[s._v("2), "),t("strong",[s._v("解决")]),s._v(": 若子问题规模较小而容易被解决则"),t("strong",[s._v("直接解")]),s._v(", 否则"),t("strong",[s._v("递归地解")]),s._v("各个子问题")]),s._v(" "),t("p",[s._v("3), "),t("strong",[s._v("合并")]),s._v(": 将各个子问题的解合并为原问题的解.")]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("P")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" ≤ n0\n   then "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("ADHOC")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("P")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 将P分解为较小的子问题 P1 ,P2 ,…,Pk")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" i←"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("to")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token namespace"}},[s._v("k")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("do")]),s._v(" yi ← "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Divide")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("and"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Conquer")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Pi")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("   "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 递归解决Pi")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("T")]),s._v(" ← "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("MERGE")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("y1"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("y2"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("…"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("yk"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("   "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 合并子问题")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("T")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br")])]),t("p",[s._v("其中 |P| 表示问题 P 的规模; n0 为一阈值, 表示当问题 P 的规模不超过 n0 时, 问题已容易直接解出, 不必再继续分解. ADHOC(P) 是该分治法中的基本子算法, 用于直接解小规模的问题 P. 因此, 当 P 的规模不超过 n0 时直接用算法 ADHOC(P) 求解. 算法 MERGE(y1,y2,…,yk) 是该分治法中的"),t("strong",[s._v("合并")]),s._v("子算法, 用于将 P 的子问题 P1, P2 ,…,Pk 的相应的解 y1,y2,…,yk 合并为 P 的解.")]),s._v(" "),t("h5",{attrs:{id:"_2-汉诺塔"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-汉诺塔"}},[s._v("#")]),s._v(" 2.汉诺塔")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563523848296.png",alt:""}})]),s._v(" "),t("p",[s._v("有三个柱子, 分别为 from, buffer, to. 需要将 from 上的圆盘全部移动到 to 上, 并且要保证小圆盘始终在大圆盘上.")]),s._v(" "),t("p",[s._v("这是一个经典的递归问题, 分为三步求解:")]),s._v(" "),t("p",[s._v("① 将 n-1 个圆盘从 from -> buffer")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563523859089.png",alt:""}})]),s._v(" "),t("p",[s._v("② 将 "),t("strong",[s._v("1 个")]),s._v("圆盘从 from -> to")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563523869528.png",alt:""}})]),s._v(" "),t("p",[s._v("③ 将 "),t("strong",[s._v("n-1 个")]),s._v("圆盘从 buffer -> to")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563523881670.png",alt:""}})]),s._v(" "),t("p",[s._v("如果只有"),t("strong",[s._v("一个")]),s._v("圆盘, 那么只需要进行"),t("strong",[s._v("一次移动")]),s._v("操作.")]),s._v(" "),t("p",[s._v("如果我们有 n ≥ 2 的情况, 我们总是可以看做是两个盘.  1.最下边的盘. 2.上面所有的盘看成一个盘.")]),s._v(" "),t("p",[s._v("从上面的讨论可以知道, a"),t("sub",[s._v("n")]),s._v(" = 2 * a"),t("sub",[s._v("n-1")]),s._v(" + 1, 显然 a"),t("sub",[s._v("n")]),s._v(" = 2"),t("sup",[s._v("n")]),s._v(" - 1, n 个圆盘需要移动 2"),t("sup",[s._v("n")]),s._v(" - 1 次.")]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Hanoi")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("move")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" num"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" from"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" buffer"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("to")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("num "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("System")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("out"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("println")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"from "')]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" from "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('" to "')]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("to")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("else")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// num ≥ 2 的情况, 我们总是可以看做是两个盘. 1.最下边的盘. 2.上面所有的盘看成一个盘")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 把上面的n-1个盘移动到buffer")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("move")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("num "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" from"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("to")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" buffer"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 把最下面的盘从from移动到to")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("move")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" from"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" buffer"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("to")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 把buffer的所有盘移动到to")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("move")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("num "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" buffer"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" from"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("to")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("main")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" args"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Hanoi")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("move")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"H1"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"H2"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"H3"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br")])]),t("div",{staticClass:"language-html line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-html"}},[t("code",[s._v("from H1 to H3\nfrom H1 to H2\nfrom H3 to H2\nfrom H1 to H3\nfrom H2 to H1\nfrom H2 to H3\nfrom H1 to H3\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br")])]),t("h4",{attrs:{id:"贪心算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法"}},[s._v("#")]),s._v(" 贪心算法")]),s._v(" "),t("p",[s._v("贪婪算法(贪心算法)是指在对问题进行求解时, 在每一步选择中都采取最好或者最优(即最有利)的选择, 从而希望能够导致结果是最好或者最优的算法.")]),s._v(" "),t("p",[s._v("贪婪算法所得到的结果"),t("strong",[s._v("不一定是最优")]),s._v("的结果(有时候会是最优解), 但是都是相对近似(接近)最优解的结果.")]),s._v(" "),t("p",[s._v("贪心只是一种"),t("strong",[s._v("思想")]),s._v(", 这种思想很多都源于生活.")]),s._v(" "),t("p",[s._v("‍")]),s._v(" "),t("h4",{attrs:{id:"参考资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[s._v("#")]),s._v(" 参考资料")]),s._v(" "),t("ul",[t("li",[s._v("《算法 第四版》")])])])}),[],!1,null,null,null);t.default=r.exports}}]);