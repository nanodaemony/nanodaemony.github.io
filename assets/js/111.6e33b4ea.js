(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{427:function(t,s,a){"use strict";a.r(s);var _=a(7),v=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_340-mysql运维"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_340-mysql运维"}},[t._v("#")]),t._v(" 340.MySQL运维")]),t._v(" "),s("h4",{attrs:{id:"大表表定义变更"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#大表表定义变更"}},[t._v("#")]),t._v(" 大表表定义变更")]),t._v(" "),s("h5",{attrs:{id:"问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),s("p",[t._v("优化 SQL 很多手段都是围绕索引来进行的. 在修改索引的时候, 数据量大的表修改索引和数据量小的表修改索引, 实施方案是完全不一样的.")]),t._v(" "),s("p",[s("mark",[s("strong",[t._v("修改索引或者说表定义变更的核心问题是数据库会加表锁, 直到修改完成")])]),t._v(".")]),t._v(" "),s("p",[t._v("所以当发现 MySQL 性能不行了, 准备新加一个索引的时候, 如果这个表的数据很多, 那么在执行加索引的命令的时候, "),s("strong",[t._v("整张表可能都会被锁住几分钟甚至几个小时")]),t._v(".")]),t._v(" "),s("p",[t._v("可见"),s("strong",[t._v("大表的表结构变更")]),t._v("是一件很麻烦的事情, 一般可以考虑的方案有 3 种.")]),t._v(" "),s("ol",[s("li",[t._v("停机变更, 就是把业务停下来, 然后更新表结构. 如果做得更加精细一点, 那么就可以说只把和这个表有关的功能下线, 但不需要将整个服务或者系统下线.")]),t._v(" "),s("li",[t._v("在业务低谷变更, 比停机更新好一点, 但是业务依旧受到了影响. 而且万一你以为在低谷能完成变更, 结果并没有, 那么就面临着业务在高峰期也不能用的问题.")]),t._v(" "),s("li",[s("strong",[t._v("创建新表, 这是不停机又不想业务受到影响的方案. 具体来说就是创建一张新表, 这张新表就是你准备用的新的表定义. 然后将旧表的数据迁移过去")]),t._v(".")])]),t._v(" "),s("p",[t._v("​"),s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/fe056a99acd3e0f248a5d98a222a4571-20231223175001-7mvpezw.png",alt:""}}),t._v("​")]),t._v(" "),s("p",[t._v("‍")])])}),[],!1,null,null,null);s.default=v.exports}}]);