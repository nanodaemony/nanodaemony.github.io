(window.webpackJsonp=window.webpackJsonp||[]).push([[158],{468:function(s,_,v){"use strict";v.r(_);var t=v(7),r=Object(t.a)({},(function(){var s=this,_=s._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[_("h1",{attrs:{id:"_32-redis主从复制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_32-redis主从复制"}},[s._v("#")]),s._v(" 32.Redis主从复制")]),s._v(" "),_("h4",{attrs:{id:"主从复制基础🌟"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主从复制基础🌟"}},[s._v("#")]),s._v(" 主从复制基础🌟")]),s._v(" "),_("h5",{attrs:{id:"_1-概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[s._v("#")]),s._v(" 1.概述")]),s._v(" "),_("p",[s._v("主从复制能解决"),_("strong",[s._v("单点故障")]),s._v("问题, 是实现分布式系统"),_("strong",[s._v("高可用")]),s._v("的基础. 复制机制下数据可以有多个副本, 这些副本可以用于"),_("strong",[s._v("读写分离, 故障转移, 实时备份")]),s._v("等.")]),s._v(" "),_("p",[_("strong",[s._v("主从复制")]),s._v("是指将一台 Redis 服务器的数据, 复制到其他 Redis 服务器. 前者称为 "),_("strong",[s._v("主节点(master)")]),s._v(" , 后者称为 "),_("strong",[s._v("从节点(slave)")]),s._v(" . 数据复制是"),_("strong",[s._v("单向")]),s._v("的, 只能由"),_("strong",[s._v("主节点到从节点")]),s._v(". Redis 主从复制支持"),_("strong",[s._v("主从同步")]),s._v("和"),_("strong",[s._v("从从同步")]),s._v(", 以减轻主节点的同步负担.")]),s._v(" "),_("blockquote",[_("p",[s._v("主从复制的作用")])]),s._v(" "),_("ul",[_("li",[_("strong",[s._v("数据冗余: "),_("strong",[s._v("​"),_("strong",[_("strong",[s._v("主从复制实现了数据的")])]),s._v("​")]),s._v("热备份")]),s._v(", 是持久化之外的一种数据冗余方式.")]),s._v(" "),_("li",[s._v("**故障恢复: ** 当主节点出现问题时, 可以由从节点提供服务, 实现快速故障恢复, 实际上是一种服务的冗余.")]),s._v(" "),_("li",[s._v("**负载均衡: ** 在主从复制的基础上, 配合读写分离, 可以由主节点提供写服务, 由从节点提供读服务, 即写 Redis 数据时应用连接主节点, 读 Redis 数据时应用连接从节点, 分担服务器负载. 尤其是在写少读多的场景下, 通过多个从节点分担读负载, 可大大提高 Redis 并发量.")]),s._v(" "),_("li",[_("strong",[s._v("高可用基石: "),_("strong",[s._v("​"),_("strong",[_("strong",[s._v("主从复制还是哨兵和集群的")])]),s._v("​")]),s._v("基础")]),s._v(", 也是 Redis 高可用的基础.")])]),s._v(" "),_("h5",{attrs:{id:"_2-主从复制拓扑关系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-主从复制拓扑关系"}},[s._v("#")]),s._v(" 2.主从复制拓扑关系")]),s._v(" "),_("p",[s._v("Redis 复制的拓扑关系可以支持"),_("strong",[s._v("单层或多层")]),s._v("复制关系. 根据复杂性可以分为"),_("strong",[s._v("一主一从, 一主多从, 树状主从结构")]),s._v(".")]),s._v(" "),_("blockquote",[_("p",[s._v("一主一从结构")])]),s._v(" "),_("p",[s._v("最简单的拓扑结构, 用于主节点出现宕机时从节点提供"),_("strong",[s._v("故障转移")]),s._v("支持.")]),s._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522224703826.png",alt:""}})]),s._v(" "),_("p",[s._v("当应用写命令并发量较高时且需要持久化时, 可以只在从节点上开始 AOF, 这样既保证数据安全又避免了持久化对主节点的影响.")]),s._v(" "),_("blockquote",[_("p",[s._v("一主多从结构")])]),s._v(" "),_("p",[s._v("应用端可以利用多个从节点实现"),_("strong",[s._v("读写分离")]),s._v(", 对于"),_("strong",[s._v("读占比较大")]),s._v("的场景, 或者某些"),_("strong",[s._v("耗时")]),s._v("的操作, 可以把读命令发送到"),_("strong",[s._v("从节点")]),s._v("来分担主节点的压力.")]),s._v(" "),_("p",[s._v("对于"),_("strong",[s._v("写并发量较大")]),s._v("的场景, "),_("strong",[s._v("多个从节点")]),s._v("会导致主节点写命令的多次发送到从节点而消耗网络带宽, "),_("strong",[s._v("增大了主节点的负担")]),s._v(".")]),s._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20221105204939898.png",alt:""}})]),s._v(" "),_("blockquote",[_("p",[s._v("树状主从结构")])]),s._v(" "),_("p",[s._v("引入"),_("strong",[s._v("复制中间层")]),s._v(", 可以降低主节点发送给从节点的数据量, "),_("strong",[s._v("减小主节点负担")]),s._v(". 可以缓解"),_("strong",[s._v("主从复制风暴")]),s._v("(多个从节点同时复制主节点导致主节点压力过大).")]),s._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522224921397.png",alt:""}})]),s._v(" "),_("p",[s._v("上图中引入中间层 slave1, 减少主节点传输给从节点的消耗, 而 slave1 可以继续往下复制数据给下一层的节点.")]),s._v(" "),_("h4",{attrs:{id:"主从复制配置"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主从复制配置"}},[s._v("#")]),s._v(" 主从复制配置")]),s._v(" "),_("h5",{attrs:{id:"_1-配置方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-配置方式"}},[s._v("#")]),s._v(" 1.配置方式")]),s._v(" "),_("p",[s._v("参与复制的 Redis 实例分为主节点(master) 和从节点(slave). 复制的数据流是"),_("strong",[s._v("单向")]),s._v("的, 只能由主节点到从节点. 默认情况下, Redis 实例都是主节点.")]),s._v(" "),_("h6",{attrs:{id:"_1-建立复制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-建立复制"}},[s._v("#")]),s._v(" (1)建立复制")]),s._v(" "),_("p",[s._v("通过执行 SLAVEOF 命令或者设置 slaveof 选项, 可以让一个服务器去复制另一个服务器, 以下三种方式是"),_("strong",[s._v("完全等效")]),s._v("的:")]),s._v(" "),_("ul",[_("li",[_("strong",[s._v("配置文件")]),s._v(": 在从服务器的配置文件中加入 "),_("code",[s._v("slaveof <masterip> <masterport>")]),s._v("​.")]),s._v(" "),_("li",[_("strong",[s._v("启动命令")]),s._v(": redis-server 启动命令后加入 "),_("code",[s._v("--slaveof <masterip> <masterport>")]),s._v("​.")]),s._v(" "),_("li",[_("strong",[s._v("客户端命令")]),s._v(": Redis 服务器启动后, 直接通过客户端执行命令 "),_("code",[s._v("slaveof <masterip> <masterport>")]),s._v("​, 让该 Redis 实例成为从节点.")])]),s._v(" "),_("p",[s._v("主从复制的开启, 完全是在"),_("strong",[s._v("从节点发起")]),s._v("的, 不需要主节点做任何事情. 主从节点复制关系建立成功之后可以用 "),_("strong",[s._v("info replication")]),s._v(" 命令查看"),_("strong",[s._v("复制相关状态")]),s._v(".")]),s._v(" "),_("p",[s._v("复制可以使用 "),_("strong",[s._v("sync 和 fsync")]),s._v(", sync 只支持全量复制, 所以主要用"),_("strong",[s._v("后者")]),s._v(".")]),s._v(" "),_("h6",{attrs:{id:"_2-断开复制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-断开复制"}},[s._v("#")]),s._v(" (2)断开复制")]),s._v(" "),_("p",[s._v("在从节点执行 "),_("strong",[s._v("slaveof no one")]),s._v(" 断开主从复制关系. 断开之后从节点变成主节点, 但是原来同步的数据"),_("strong",[s._v("不会丢失")]),s._v(". "),_("strong",[s._v("但是切换主节点")]),s._v(": 如果从节点断开主从复制进而又把"),_("strong",[s._v("另一个")]),s._v("节点当做主节点, 则切换后从节点会"),_("strong",[s._v("清空")]),s._v("之前同步的数据.")]),s._v(" "),_("h6",{attrs:{id:"_3-只读模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-只读模式"}},[s._v("#")]),s._v(" (3)只读模式")]),s._v(" "),_("p",[s._v("默认情况下, 从节点使用 "),_("strong",[s._v("slave-read-only=yes")]),s._v(" 配置为"),_("strong",[s._v("只读模式")]),s._v(". 生产环境这样做! 因为对从节点的修改主节点是不知道的.")]),s._v(" "),_("h5",{attrs:{id:"_2-主从复制过程示例"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-主从复制过程示例"}},[s._v("#")]),s._v(" 2.主从复制过程示例")]),s._v(" "),_("p",[s._v("这里模拟一下主从复制过程.")]),s._v(" "),_("p",[_("strong",[s._v("(1)第一步: 本地启动两个节点")])]),s._v(" "),_("p",[s._v("在安装好 Redis 之后, 可以使用 "),_("code",[s._v("redis-server --port <port>")]),s._v("​ 的方式指定创建两个不同端口的 Redis 服务器实例, 如下所示.")]),s._v(" "),_("div",{staticClass:"language-bash line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 创建两个Redis实例")]),s._v("\nredis-server "),_("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("--port")]),s._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("6379")]),s._v("\nredis-server "),_("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("--port")]),s._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("6380")]),s._v("\n")])]),s._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[s._v("1")]),_("br"),_("span",{staticClass:"line-number"},[s._v("2")]),_("br"),_("span",{staticClass:"line-number"},[s._v("3")]),_("br")])]),_("p",[s._v("两个 Redis 节点启动后, 都默认为"),_("strong",[s._v("主节点")]),s._v(".")]),s._v(" "),_("p",[_("strong",[s._v("(2)第二步: 建立复制")])]),s._v(" "),_("p",[s._v("在 6380 端口的节点中执行 "),_("strong",[s._v("slaveof")]),s._v(" 命令, 使之变为"),_("strong",[s._v("从节点")]),s._v(":")]),s._v(" "),_("div",{staticClass:"language-bash line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 在 6380 端口的 Redis 实例中使用控制台")]),s._v("\nredis-cli "),_("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("-p")]),s._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("6380")]),s._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 成为本地 6379 端口实例的从节点")]),s._v("\n"),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1:638"),_("span",{pre:!0,attrs:{class:"token operator"}},[_("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("0")]),s._v(">")]),s._v(" SLAVEOF "),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1 "),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("6379")]),s._v("\nOK\n")])]),s._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[s._v("1")]),_("br"),_("span",{staticClass:"line-number"},[s._v("2")]),_("br"),_("span",{staticClass:"line-number"},[s._v("3")]),_("br"),_("span",{staticClass:"line-number"},[s._v("4")]),_("br"),_("span",{staticClass:"line-number"},[s._v("5")]),_("br")])]),_("p",[_("strong",[s._v("(3)第三步: 观察效果")])]),s._v(" "),_("p",[s._v("验证一下主节点的数据是否会复制到从节点之中.")]),s._v(" "),_("ul",[_("li",[s._v("先在"),_("strong",[s._v("从节点")]),s._v("查询一个"),_("strong",[s._v("不存在")]),s._v("的 key:")])]),s._v(" "),_("div",{staticClass:"language-bash line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[_("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1:638"),_("span",{pre:!0,attrs:{class:"token operator"}},[_("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("0")]),s._v(">")]),s._v(" GET mykey\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("nil"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[s._v("1")]),_("br"),_("span",{staticClass:"line-number"},[s._v("2")]),_("br")])]),_("ul",[_("li",[s._v("再在"),_("strong",[s._v("主节点")]),s._v("中添加这个 key:")])]),s._v(" "),_("div",{staticClass:"language-bash line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[_("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1:637"),_("span",{pre:!0,attrs:{class:"token operator"}},[_("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("9")]),s._v(">")]),s._v(" SET mykey "),_("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("test")]),s._v("\nOK\n")])]),s._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[s._v("1")]),_("br"),_("span",{staticClass:"line-number"},[s._v("2")]),_("br")])]),_("ul",[_("li",[s._v("此时再从"),_("strong",[s._v("从节点")]),s._v("中查询, 会发现已经从"),_("strong",[s._v("主节点")]),s._v("同步到"),_("strong",[s._v("从节点")]),s._v(":")])]),s._v(" "),_("div",{staticClass:"language-bash line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[_("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1:638"),_("span",{pre:!0,attrs:{class:"token operator"}},[_("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("0")]),s._v(">")]),s._v(" GET mykey\n"),_("span",{pre:!0,attrs:{class:"token string"}},[s._v('"test"')]),s._v("\n")])]),s._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[s._v("1")]),_("br"),_("span",{staticClass:"line-number"},[s._v("2")]),_("br")])]),_("p",[_("strong",[s._v("(4)第四步: 断开复制")])]),s._v(" "),_("p",[s._v('通过 "'),_("code",[s._v("slaveof <masterip> <masterport>")]),s._v('​" 命令建立主从复制关系以后, 可以通过 "'),_("code",[s._v("slaveof no one")]),s._v('​" 命令断开. 需要注意的是, 从节点断开复制后, 不会删除已有的数据, 只是不再接受主节点新的数据变化.')]),s._v(" "),_("p",[s._v('在从节点执行 "'),_("code",[s._v("slaveof no one")]),s._v('​" 之后, 从节点和主节点分别打印日志如下:')]),s._v(" "),_("div",{staticClass:"language-bash line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 从节点打印日志")]),s._v("\n"),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("61496")]),s._v(":M "),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("17")]),s._v(" Mar "),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("2020")]),s._v(" 08:10:22.749 "),_("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# Connection with master lost.")]),s._v("\n"),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("61496")]),s._v(":M "),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("17")]),s._v(" Mar "),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("2020")]),s._v(" 08:10:22.749 * Caching the disconnected master state.\n"),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("61496")]),s._v(":M "),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("17")]),s._v(" Mar "),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("2020")]),s._v(" 08:10:22.749 * Discarding previously cached master state.\n"),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("61496")]),s._v(":M "),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("17")]),s._v(" Mar "),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("2020")]),s._v(" 08:10:22.749 * MASTER MODE enabled "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("user request from "),_("span",{pre:!0,attrs:{class:"token string"}},[s._v("'id=4 addr=127.0.0.1:55096 fd=8 name= age=1664 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=34 qbuf-free=32734 obl=0 oll=0 omem=0 events=r cmd=slaveof'")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 主节点打印日志")]),s._v("\n"),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("61467")]),s._v(":M "),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("17")]),s._v(" Mar "),_("span",{pre:!0,attrs:{class:"token number"}},[s._v("2020")]),s._v(" 08:10:22.749 "),_("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# Connection with replica 127.0.0.1:6380 lost.")]),s._v("\n")])]),s._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[s._v("1")]),_("br"),_("span",{staticClass:"line-number"},[s._v("2")]),_("br"),_("span",{staticClass:"line-number"},[s._v("3")]),_("br"),_("span",{staticClass:"line-number"},[s._v("4")]),_("br"),_("span",{staticClass:"line-number"},[s._v("5")]),_("br"),_("span",{staticClass:"line-number"},[s._v("6")]),_("br"),_("span",{staticClass:"line-number"},[s._v("7")]),_("br"),_("span",{staticClass:"line-number"},[s._v("8")]),_("br")])]),_("h4",{attrs:{id:"主从复制原理🌟"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主从复制原理🌟"}},[s._v("#")]),s._v(" 主从复制原理🌟")]),s._v(" "),_("h5",{attrs:{id:"_1-主从复制过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-主从复制过程"}},[s._v("#")]),s._v(" 1.主从复制过程")]),s._v(" "),_("p",[s._v("复制大致有六个过程:")]),s._v(" "),_("p",[s._v("(1) "),_("strong",[s._v("保存主节点信息")]),s._v(".")]),s._v(" "),_("p",[s._v("(2) "),_("strong",[s._v("连接主节点")]),s._v(". 从节点内部通过每秒运行的"),_("strong",[s._v("定时任务")]),s._v("维护复制相关逻辑, 当定时任务"),_("strong",[s._v("发现存在新的主节点")]),s._v("的时候, 会尝试与该节点"),_("strong",[s._v("建立连接")]),s._v(". 连接成功会产生日志, 连接失败则会无限"),_("strong",[s._v("重连")]),s._v(".")]),s._v(" "),_("p",[s._v("(3) "),_("strong",[s._v("发送 ping 命令")]),s._v(". 从节点发送 ping 指令给主节点进行"),_("strong",[s._v("首次通信")]),s._v(", 用于检测网络情况和主节点是否可以处理请求. 如果返回 pong 失败, 则主节点会"),_("strong",[s._v("断开连接")]),s._v("下一次定时任务继续"),_("strong",[s._v("重连")]),s._v(".")]),s._v(" "),_("p",[s._v("(4) "),_("strong",[s._v("权限认证")]),s._v(". 这发生在主节点设置了 requirepass 参数时.")]),s._v(" "),_("p",[s._v("(5) "),_("strong",[s._v("数据同步")]),s._v(". 主从连接首次通信正常后, 主节点会把持有的数据"),_("strong",[s._v("全部发送")]),s._v("给从节点, 这是"),_("strong",[s._v("非常耗时")]),s._v("的操作.")]),s._v(" "),_("p",[s._v("(6) "),_("strong",[s._v("命令持续复制")]),s._v(". 接下来主节点会"),_("strong",[s._v("持续")]),s._v("把命令发送给从节点, "),_("strong",[s._v("保证主从数据一致性")]),s._v(".")]),s._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200527210920684.png",alt:"image-20200527210920684"}})]),s._v(" "),_("p",[s._v("复制过程中最核心的便是: "),_("mark",[_("strong",[s._v("数据同步")])]),s._v(", 下面详述.")]),s._v(" "),_("h5",{attrs:{id:"_2-psync命令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-psync命令"}},[s._v("#")]),s._v(" 2.psync命令")]),s._v(" "),_("p",[s._v("sync 与 "),_("strong",[s._v("psync")]),s._v(" 命令都能用于实现数据同步, 但 sync 指令只能实现全量复制, 用的较少.")]),s._v(" "),_("p",[_("strong",[s._v("psync 运行需要的核心组件如下")]),s._v(":")]),s._v(" "),_("ul",[_("li",[s._v("主从节点各自"),_("strong",[s._v("复制偏移量")]),s._v(".")]),s._v(" "),_("li",[s._v("主节点"),_("strong",[s._v("复制积压缓冲区")]),s._v(".")]),s._v(" "),_("li",[s._v("主节点"),_("strong",[s._v("运行 id")]),s._v(".")])]),s._v(" "),_("h6",{attrs:{id:"_1-复制偏移量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-复制偏移量"}},[s._v("#")]),s._v(" (1)复制偏移量")]),s._v(" "),_("p",[_("strong",[s._v("参与复制的主从节点都会维护各自的复制偏移量")]),s._v(". 通过对比主从节点的复制偏移量, 可以判断主从节点"),_("strong",[s._v("数据是否一致")]),s._v(". 从节点会每秒上报自己的复制偏移量给主节点.")]),s._v(" "),_("p",[s._v("复制偏移量的统计信息在 "),_("strong",[s._v("info replication")]),s._v(" 中的 "),_("strong",[s._v("master_repl_offset")]),s._v(" 指标中.")]),s._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522225221317.png",alt:""}})]),s._v(" "),_("h6",{attrs:{id:"_2-复制积压缓冲区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-复制积压缓冲区"}},[s._v("#")]),s._v(" (2)复制积压缓冲区")]),s._v(" "),_("p",[_("strong",[s._v("复制积压缓冲区")]),s._v("是保存在"),_("strong",[s._v("主节点")]),s._v("上的一个"),_("strong",[s._v("固定长度的队列")]),s._v(", 默认 "),_("strong",[s._v("1MB")]),s._v(", 当主节点在于从节点连接后创建. 这时候主节点写命令的时候, "),_("strong",[s._v("不但把命令发给从节点, 还会写入到复制积压缓冲区.")])]),s._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522225255149.png",alt:""}})]),s._v(" "),_("p",[s._v("复制积压缓冲区是一个"),_("strong",[s._v("定长的先进先出队列")]),s._v("(FIFO), 所以能够实现"),_("strong",[s._v("保存最近已复制数据")]),s._v("的功能, 用于"),_("strong",[s._v("部分复制和复制命令丢失时的数据补救")]),s._v(".")]),s._v(" "),_("p",[s._v("复制积压缓冲区的统计信息在 "),_("strong",[s._v("info replication")]),s._v(" 中的 "),_("strong",[s._v("repl_backlog_size")]),s._v(" 指标中.")]),s._v(" "),_("h6",{attrs:{id:"_3-主节点运行id"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-主节点运行id"}},[s._v("#")]),s._v(" (3)主节点运行id")]),s._v(" "),_("p",[s._v("每个 Redis "),_("strong",[s._v("结点")]),s._v("启动后会分配动态分配一个 40 位的十六进制字符串作为"),_("strong",[s._v("运行 id")]),s._v(", 可以"),_("strong",[s._v("唯一标识")]),s._v(" Redis 节点.")]),s._v(" "),_("h6",{attrs:{id:"_4-psync使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-psync使用"}},[s._v("#")]),s._v(" (4)psync使用")]),s._v(" "),_("p",[s._v("从节点使用 "),_("strong",[s._v("psync")]),s._v(" 命令完成部分"),_("strong",[s._v("复制和全量复制")]),s._v("功能. 格式如下.")]),s._v(" "),_("div",{staticClass:"language-bash line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# runId: 从节点复制主节点的运行Id")]),s._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# offset: 当前从节点已经复制的偏移量, 第一次参与复制则为-1")]),s._v("\n$ psync "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("runId"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("offset"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("  \n")])]),s._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[s._v("1")]),_("br"),_("span",{staticClass:"line-number"},[s._v("2")]),_("br"),_("span",{staticClass:"line-number"},[s._v("3")]),_("br")])]),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522225350922.png",alt:""}})]),s._v(" "),_("p",[_("strong",[s._v("主节点")]),s._v("根据 psync 参数与自身"),_("strong",[s._v("参数情况")]),s._v("选择进行回复.")]),s._v(" "),_("ul",[_("li",[s._v("+"),_("strong",[s._v("FULLRESYNC")]),s._v(" {runId} {offset}: 从节点触发全量复制.")]),s._v(" "),_("li",[s._v("+"),_("strong",[s._v("CONTINUE")]),s._v(": 从节点触发部分复制.")]),s._v(" "),_("li",[s._v("+"),_("strong",[s._v("ERR")]),s._v(": 主节点版本低于 2.8, 无法识别 psync 命令.")])]),s._v(" "),_("h5",{attrs:{id:"_3-数据同步流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-数据同步流程"}},[s._v("#")]),s._v(" 3.数据同步流程")]),s._v(" "),_("p",[s._v("使用 "),_("strong",[s._v("psync")]),s._v(" 命令完成主从数据同步, 同步可以分为: "),_("strong",[s._v("全量复制, 部分复制")]),s._v(".")]),s._v(" "),_("ul",[_("li",[_("strong",[s._v("全量复制")]),s._v(": 一般用于"),_("strong",[s._v("初次复制")]),s._v("的场景, 开销较大.")]),s._v(" "),_("li",[_("strong",[s._v("部分复制")]),s._v(": 用于处理在主从复制中因"),_("strong",[s._v("网络闪断")]),s._v("等原因造成的"),_("strong",[s._v("数据丢失")]),s._v("场景, 从节点再次连接主节点后, 如果条件允许, 主节点"),_("strong",[s._v("补发")]),s._v("丢失的数据给从节点. 可以避免开销过大.")])]),s._v(" "),_("h6",{attrs:{id:"_1-全量复制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-全量复制"}},[s._v("#")]),s._v(" (1)全量复制")]),s._v(" "),_("p",[s._v("主从"),_("strong",[s._v("第一次建立复制")]),s._v("时必须经历的阶段, 触发全量复制的命令是 "),_("strong",[s._v("fsync")]),s._v(".")]),s._v(" "),_("blockquote",[_("p",[s._v("全量复制流程")])]),s._v(" "),_("p",[s._v("全量复制流程图如下所示:")]),s._v(" "),_("p",[_("img",{attrs:{src:"/img/image-20240106133126-i38g6i9.png",alt:"image"}})]),s._v(" "),_("ul",[_("li",[s._v("由于是第一次复制, 从节点没有复制偏移量和主节点运行 Id, 所以发送 "),_("strong",[s._v("fsync ? -1")]),s._v(".")]),s._v(" "),_("li",[s._v("主节点判断这是全量复制, 返回 +FULLRESYNC.")]),s._v(" "),_("li",[s._v("从节点接收到主节点的响应数据, 即可保存运行 Id 和偏移量 offset.")]),s._v(" "),_("li",[_("strong",[s._v("主节点执行 bgsave 命令保存 RDB 文件到本地")]),s._v(".")]),s._v(" "),_("li",[_("strong",[s._v("主节点把 RDB 文件发送到从节点, 从节点将其作为本地数据文件")]),s._v(". 如果 RDB 文件过大, 那么发送过程可能非常耗时. 这里用 RDB 文件可以在 slave 结点更快速的加载数据.")]),s._v(" "),_("li",[s._v("从节点从开始接收 RDB 快照到接收完成期间, 主节点仍然可以响应指令, 主节点把这一时期的命令数据保存在"),_("strong",[s._v("复制客户端缓冲区")]),s._v("内, 等从节点加载完 RDB 文件后, 主节点再把缓冲区内的数据发送到从节点, 保证"),_("strong",[s._v("数据一致性")]),s._v(".")]),s._v(" "),_("li",[s._v("从节点接收完主节点传送来的数据后会"),_("strong",[s._v("清空自身旧数据")]),s._v(", 然后"),_("strong",[s._v("加载 RDB 文件")]),s._v(".")]),s._v(" "),_("li",[s._v("如果从节点开启了 AOF 持久化, 那么加载完 RDB 后会立即执行 "),_("strong",[s._v("bgrewriteaof")]),s._v(" 操作进行持久化.")])]),s._v(" "),_("p",[s._v("全量复制是一个"),_("strong",[s._v("非常耗时")]),s._v("的操作. 主要"),_("strong",[s._v("时间开销")]),s._v("有:")]),s._v(" "),_("ul",[_("li",[s._v("主节点 bgsave 的时间.")]),s._v(" "),_("li",[s._v("RBD 文件网络传输时间.")]),s._v(" "),_("li",[s._v("从节点清空数据时间.")]),s._v(" "),_("li",[s._v("从节点加载 RDB 时间.")]),s._v(" "),_("li",[s._v("可能的 AOF 重写时间.")])]),s._v(" "),_("p",[s._v("除了"),_("strong",[s._v("第一次")]),s._v("复制执行全量复制之外, 其他的场景应该"),_("strong",[s._v("避免使用全量复制")]),s._v(".")]),s._v(" "),_("blockquote",[_("p",[s._v("全量复制发生的场景")])]),s._v(" "),_("p",[s._v("全量复制开销极大, 需要规避. 这里分析一下全量复制发生的场景.")]),s._v(" "),_("ul",[_("li",[_("strong",[s._v("第一次建立复制")]),s._v(". 不可避免, 建议在"),_("strong",[s._v("低峰")]),s._v("时进行.")]),s._v(" "),_("li",[_("strong",[s._v("节点运行 Id 不匹配")]),s._v(". 主从复制关系建立后, 从节点会保存主节点的运行 id, 如果主节点故障重启, 会造成 id 变化(因为是动态 Id), 从节点发现 id 变化便会认为是一个"),_("strong",[s._v("新的")]),s._v("节点从而进行全量复制. 这种情况需要从架构上规避, 如提供"),_("strong",[s._v("故障转移")]),s._v("功能. 当主节点发生故障之后, 可以采用支持自动故障转移的"),_("strong",[s._v("哨兵或集群")]),s._v("方案, 让"),_("strong",[s._v("从节点成为主节点")]),s._v(".")]),s._v(" "),_("li",[_("strong",[s._v("复制积压缓冲区不足")]),s._v(". 在进行部分复制时, 如果 "),_("strong",[s._v("offset 不在复制积压缓冲区中")]),s._v(", 比如主从断开的时间过长, 复制积压缓冲区记录的命令早就"),_("strong",[s._v("超过")]),s._v("了默认的 1MB, 这时候"),_("strong",[s._v("为了保证数据一致性就会把部分复制退化为全量复制")]),s._v(". 所以大流量的场景需要"),_("strong",[s._v("增大复制积压缓冲区")]),s._v(".")])]),s._v(" "),_("h6",{attrs:{id:"_2-部分复制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-部分复制"}},[s._v("#")]),s._v(" (2)部分复制")]),s._v(" "),_("p",[s._v("当 master 和 slave 断开重连后, 一般都会对整份数据进行复制. 从 redis2.8 版本开始支持部分数据复制的命令 "),_("strong",[s._v("PSYNC")]),s._v(" 去 master 同步数据, slave 与 master 能够在网络连接断开重连后只进行部分数据复制(断点续传).")]),s._v(" "),_("p",[s._v("部分复制流程图如下:")]),s._v(" "),_("p",[_("img",{attrs:{src:"/img/image-20240106133204-8i3kew5.png",alt:"image"}})]),s._v(" "),_("p",[s._v("master 会在其内存中创建一个"),_("strong",[s._v("复制数据用的缓存队列")]),s._v(", 缓存最近一段时间的数据, master 和它所有的 slave 都维护了复制的数据下标 offset 和 master 的进程 id, 因此当网络连接断开后, slave 会请求 master 继续进行未完成的复制, 从所记录的数据下标开始. 如果 master 进程 id 变化了, 或者从节点数据下标 offset 太旧, 已经不在 master 的缓存队列里了, 那么将会进行一次全量数据的复制.")]),s._v(" "),_("p",[s._v("使用如下命令实现部分复制, 可以优化全量复制带来的开销. 如果出现"),_("strong",[s._v("网络闪断或者命令丢")]),s._v("失等异常情况, 从节点会向主节点要求"),_("strong",[s._v("补发丢失的命令数据")]),s._v(", 如果主节点的"),_("strong",[s._v("复制积压缓冲区")]),s._v("内存在这部分数据则可以直接发送给从节点. 大大降低了开销.")]),s._v(" "),_("div",{staticClass:"language-bash line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[s._v("$ psync "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("runId"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("offset"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" \n")])]),s._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[s._v("1")]),_("br")])]),_("blockquote",[_("p",[s._v("部分复制流程")])]),s._v(" "),_("p",[s._v("具体流程如下:")]),s._v(" "),_("ul",[_("li",[s._v("主从节点如果出现网络中断, 时间超过 "),_("strong",[s._v("repl-timeout")]),s._v(" 时就认为从节点故障并中断复制链接.")]),s._v(" "),_("li",[s._v("此时主节点依然可以响应指令, 但是复制链接中断所以"),_("strong",[s._v("无法")]),s._v("发送命令给从节点, 不过主节点内部"),_("strong",[s._v("存在复制积压缓冲区")]),s._v(", 依然"),_("strong",[s._v("可以保存最近一段时间")]),s._v("内的写命令数据.")]),s._v(" "),_("li",[s._v("当主从再次连接之后, 两者通过"),_("strong",[s._v("偏移量 offset")]),s._v(" 在"),_("strong",[s._v("复制积压缓冲区")]),s._v("寻找, 如果 offset "),_("strong",[s._v("在缓冲区")]),s._v("中, 则"),_("strong",[s._v("直接根据这个偏移量补发")]),s._v("数据即可.")])]),s._v(" "),_("h5",{attrs:{id:"_4-心跳机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-心跳机制"}},[s._v("#")]),s._v(" 4.心跳机制")]),s._v(" "),_("p",[s._v("主从结点在建立复制之后, 它们之间维护着"),_("strong",[s._v("长连接")]),s._v("并彼此发送"),_("strong",[s._v("心跳命令")]),s._v(". 心跳机制:")]),s._v(" "),_("ul",[_("li",[s._v("主从节点都有心跳检查机制.")]),s._v(" "),_("li",[s._v("主节点默认每隔 "),_("strong",[s._v("10")]),s._v(" 秒对从节点发送 ping 命令, 判断从节点的状态.")]),s._v(" "),_("li",[s._v("从节点在主线程中每隔 1 秒发送 "),_("code",[s._v("replconf ack {offset}")]),s._v("​ 命令给主节点报告自己的 "),_("strong",[s._v("offset 信息")]),s._v(".")])]),s._v(" "),_("h5",{attrs:{id:"_5-异步复制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-异步复制"}},[s._v("#")]),s._v(" 5.异步复制")]),s._v(" "),_("p",[s._v("主节点不但负责数据读写, 而且还会把写命令同步给从节点. "),_("strong",[s._v("写命令的发送")]),s._v("过程是"),_("strong",[s._v("异步")]),s._v("完成的, 也就是说主节点自身处理完读写命令后"),_("strong",[s._v("直接返回给客户端")]),s._v(", 并"),_("strong",[s._v("不等待从节点复制")]),s._v("完成.")]),s._v(" "),_("p",[_("strong",[s._v("由于主从复制是异步的, 所以会造成从节点的数据相对主节点存在延迟, 可能造成一定的数据不一致")]),s._v(". 具体延迟可以通过 "),_("strong",[s._v("info replication")]),s._v(" 中"),_("strong",[s._v("主从节点的复制偏移量")]),s._v("计算出.")]),s._v(" "),_("h4",{attrs:{id:"主从复制存在的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主从复制存在的问题"}},[s._v("#")]),s._v(" 主从复制存在的问题")]),s._v(" "),_("h5",{attrs:{id:"_1-读写分离引发的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-读写分离引发的问题"}},[s._v("#")]),s._v(" 1.读写分离引发的问题")]),s._v(" "),_("p",[s._v("读写分离: 对于"),_("strong",[s._v("读占比较高")]),s._v("的场景, 可以把一部分读流量分摊到"),_("strong",[s._v("从节点")]),s._v("来减轻主节点的压力, 同时需要"),_("strong",[s._v("写操作永远只在主节点")]),s._v("进行.")]),s._v(" "),_("p",[_("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522230154662.png",alt:""}})]),s._v(" "),_("p",[s._v("当使用从节点响应读请求时, 客户端可能存在"),_("strong",[s._v("复制数据延迟, 读到过期数据, 从节点故障")]),s._v("等问题.")]),s._v(" "),_("h6",{attrs:{id:"_1-数据延迟问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据延迟问题"}},[s._v("#")]),s._v(" (1)数据延迟问题")]),s._v(" "),_("p",[s._v("Redis 复制数据的延迟是由于"),_("strong",[s._v("异步复制的特性")]),s._v("决定而无法改变的, 延迟也取决于网络带宽和命令阻塞等情况. 这会造成刚在主节点写入的数据从节点可能暂时"),_("strong",[s._v("读不到")]),s._v(".")]),s._v(" "),_("p",[s._v("允许"),_("strong",[s._v("短暂延迟")]),s._v("的场景还行, 不行的话可以"),_("strong",[s._v("编写外部监控程序监听主从节点的复制偏移量, "),_("strong",[s._v("​"),_("strong",[_("strong",[s._v('当延迟较大时触发报警或者通知客户端别去读取延迟过高的节点. 具体延迟可以通过 "'),_("strong",[_("strong",[s._v("​")])])]),s._v("info replication")])])]),s._v("​ "),_("strong",[_("strong",[s._v('" 中')])]),s._v("​"),_("strong",[s._v("主从节点的复制偏移量")]),s._v("计算出.")]),s._v(" "),_("p",[s._v("当延迟字节量过高时, 可以采用 Zookeeper 的监听回调机制实现客户端通知. 但这种方式成本比较高.")]),s._v(" "),_("h6",{attrs:{id:"_2-读到过期数据问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-读到过期数据问题"}},[s._v("#")]),s._v(" (2)读到过期数据问题")]),s._v(" "),_("p",[s._v("Redis 键过期删除策略有"),_("strong",[s._v("惰性删除和定时删除")]),s._v(". 如果主节点包含了大量"),_("strong",[s._v("会过期")]),s._v("的数据, 可能主节点数据"),_("strong",[s._v("已经过期")]),s._v(", 但是过期的命令可能还没有来得及发到从节点, 从而导致在"),_("strong",[s._v("从节点读取到过期")]),s._v("的数据. 但是 Redis 3.2 之后的版本, "),_("strong",[s._v("从节点读数据时也会检查过期时间")]),s._v(", 已经"),_("strong",[s._v("解决了")]),s._v("这个问题.")]),s._v(" "),_("h6",{attrs:{id:"_3-从节点故障问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-从节点故障问题"}},[s._v("#")]),s._v(" (3)从节点故障问题")]),s._v(" "),_("p",[s._v("对于从节点故障问题, 需要在客户端维护可用从节点列表. 做 Redis 读写分离其实维护成本挺高, 可以考虑使用 "),_("strong",[s._v("Redis Cluster")]),s._v(" 等分布式解决方案.")]),s._v(" "),_("h5",{attrs:{id:"_2-主从配置不一致问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-主从配置不一致问题"}},[s._v("#")]),s._v(" 2.主从配置不一致问题")]),s._v(" "),_("p",[_("strong",[s._v("主从配置不一致")]),s._v("是一个容易忽视的问题, 主从节点之间有的配置可以不一致, 但是"),_("strong",[s._v("内存相关")]),s._v("的配置最好是一致的, 如 maxmemory.")]),s._v(" "),_("h5",{attrs:{id:"_3-复制风暴问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-复制风暴问题"}},[s._v("#")]),s._v(" 3.复制风暴问题")]),s._v(" "),_("p",[_("strong",[s._v("复制风暴")]),s._v("指的是"),_("strong",[s._v("大量从节点")]),s._v("对同一主节点或者同一台机器的多个主节点在"),_("strong",[s._v("短时间内发起全量复制")]),s._v("的过程, 这会造成主节点开销极大, 需要规避.")]),s._v(" "),_("p",[s._v("在一主多从的架构下, 如果主节点故障重启, "),_("strong",[s._v("运行 id 改变")]),s._v(", 那么就会对"),_("strong",[s._v("各个从节点发起全量复制")]),s._v(". 主节点短时间内需要生成大量 RDB 文件, 传输 RDB 文件也会造成短时间内带宽消耗巨大.")]),s._v(" "),_("p",[s._v("解决方案: "),_("strong",[s._v("减少")]),s._v("单个主节点 挂载从节点数量, 或者使用加入"),_("strong",[s._v("中间层的树状架构")]),s._v("来保护主节点. 如果是单机多个主节点, 可以把主节点部署在不同的机器上.")]),s._v(" "),_("p",[s._v("‍")]),s._v(" "),_("p",[s._v("‍")]),s._v(" "),_("h4",{attrs:{id:"参考资料"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[s._v("#")]),s._v(" 参考资料")]),s._v(" "),_("ul",[_("li",[s._v("《Redis开发与运维》")])])])}),[],!1,null,null,null);_.default=r.exports}}]);