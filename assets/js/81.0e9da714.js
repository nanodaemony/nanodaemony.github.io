(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{395:function(t,a,s){"use strict";s.r(a);var e=s(7),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_23-调优案例分析与实战🌼"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_23-调优案例分析与实战🌼"}},[t._v("#")]),t._v(" 23.调优案例分析与实战🌼")]),t._v(" "),a("p",[t._v("本节对应《深入理解 Java 虚拟机》的第五章")]),t._v(" "),a("p",[t._v("前面系统性地介绍了处理 Java 虚拟机内存问题的知识与工具, 在处理应用中的实际问题时, 除了知识与工具外, 经验同样是一个很重要的因素. 本章将会分享若干较有代表性的实际案例.")]),t._v(" "),a("p",[t._v("考虑到虚拟机的故障处理与调优主要面向各类"),a("strong",[t._v("服务端")]),t._v('应用, 而大多数 Java 程序员较少有机会直接接触生产环境的服务器, 因此本章还准备了一个所有开发人员都能够进行 "亲身实战" 的练习, 希望大家通过实践能获得故障处理, 调优的经验.')]),t._v(" "),a("h4",{attrs:{id:"gc问题处理与调优方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gc问题处理与调优方法"}},[t._v("#")]),t._v(" GC问题处理与调优方法")]),t._v(" "),a("h5",{attrs:{id:"_1-gc调优原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-gc调优原则"}},[t._v("#")]),t._v(" 1.GC调优原则")]),t._v(" "),a("p",[t._v("多数 Java 应用"),a("strong",[t._v("不需要")]),t._v("在服务器上进行 GC 优化; 多数导致 GC 问题的应用, 都不是因为参数设置错误, 而是"),a("strong",[t._v("代码问题")]),t._v("; 在应用上线之前, 先考虑将机器的 "),a("strong",[t._v("JVM 参数设置到最优")]),t._v("; 减少创建对象的数量; "),a("strong",[t._v("减少使用全局变量和大对象")]),t._v("; GC 优化是到最后不得已才采用的手段; 在实际使用中, 分析 GC 情况"),a("strong",[t._v("优化代码")]),t._v("比优化 GC 参数要多得多; "),a("strong",[t._v("JVM 参数大小设置并没有固定标准, 需要根据实际项目情况分析")]),t._v(".")]),t._v(" "),a("p",[t._v("如果满足下面的指标, "),a("strong",[t._v("则一般不需要进行 GC 优化:")]),t._v(" "),a("strong",[a("strong",[t._v("MinorGC 执行时间")])]),t._v("​"),a("strong",[t._v("不到 50ms")]),t._v("; Minor GC 执行"),a("strong",[t._v("不频繁")]),t._v(", 约 10 秒一次; Full GC 执行时间"),a("strong",[t._v("不到 1s")]),t._v("; Full GC 执行频率不算频繁, 不低于 10 分钟 1 次.")]),t._v(" "),a("h5",{attrs:{id:"_2-gc调优目的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-gc调优目的"}},[t._v("#")]),t._v(" 2.GC调优目的")]),t._v(" "),a("p",[a("strong",[t._v("虚拟机调优主要就是: 结合实际业务场景和内存分配的策略进行参数配置. 尽量让垃圾对象在年轻代被消灭掉而不是跑到老年代去了, 减少 Full GC, 同时也控制一下 MinorGC 的次数")]),t._v(".")]),t._v(" "),a("ul",[a("li",[t._v("将转移到"),a("strong",[t._v("老年代")]),t._v("的"),a("strong",[t._v("对象数量降低到最小")]),t._v(".")]),t._v(" "),a("li",[a("strong",[t._v("减少 GC 的执行时间")]),t._v(".")])]),t._v(" "),a("h5",{attrs:{id:"_3-gc调优策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-gc调优策略"}},[t._v("#")]),t._v(" 3.GC调优策略")]),t._v(" "),a("p",[a("strong",[t._v("策略 1:")]),t._v(" "),a("strong",[a("strong",[t._v("将")])]),t._v("​"),a("strong",[t._v("新对象")]),t._v("预留在"),a("strong",[t._v("新生代")]),t._v(', 由于 Full GC 的成本远高于 Minor GC, 因此尽可能将对象分配在新生代是明智的做法, 实际项目中根据 GC 日志分析新生代空间大小分配是否合理, 适当通过 "-'),a("strong",[t._v("Xmn")]),t._v('" 命令调节新生代大小, '),a("strong",[t._v("最大限度降低新对象直接进入老年代的情况")]),t._v(". 对于 Spring 项目, 一般容器内的"),a("strong",[t._v("核心对象")]),t._v(", 如各种 "),a("strong",[t._v("Service 对象")]),t._v("经过多次 Minor GC 后会被分配到"),a("strong",[t._v("老年代")]),t._v("中, 而一些用于"),a("strong",[t._v("处理业务的临时对象尽量控制其在新生代")]),t._v("中, 比如处理一个订单中有一些订单对象是临时的, 使用完后让其在新生代被回收掉即可, 别让它们存活太多导致移动到老年代中了.")]),t._v(" "),a("p",[a("strong",[t._v("策略 2:")]),t._v(" "),a("strong",[a("strong",[t._v("虽然大部分情况下, 将对象分配在新生代是合理的, 但是对于大对象这种做法却值得考量. 大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代, 破坏新生代的对象结构, 可能会出现频繁的 Full GC. 因此对于")])]),t._v("​"),a("strong",[t._v("大对象")]),t._v(", 可以考虑设置"),a("strong",[t._v("直接进入老年代")]),t._v("(当然生命周期较短的大对象对于垃圾回收来说简直就是噩梦). -XX:PretenureSizeThreshold 可以设置直接进入老年代的"),a("strong",[t._v("对象大小")]),t._v(".")]),t._v(" "),a("p",[a("strong",[t._v("策略 3")]),t._v(": 合理设置进入老年代对象的"),a("strong",[t._v("年龄")]),t._v(",  "),a("strong",[t._v("-XX:MaxTenuringThreshold")]),t._v(" 可以设置对象进入老年代的年龄大小, 减少老年代的内存占用, 降低 Full GC 发生的频率.")]),t._v(" "),a("p",[a("strong",[t._v("策略 4")]),t._v(": 设置合理的堆大小, 堆大小设置有两个参数:  "),a("strong",[t._v("-Xms 初始化堆大小")]),t._v(",  "),a("strong",[t._v("-Xmx 最大堆大小")]),t._v(".")]),t._v(" "),a("h5",{attrs:{id:"_4-gc调优步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-gc调优步骤"}},[t._v("#")]),t._v(" 4.GC调优步骤")]),t._v(" "),a("p",[t._v("一般情况下, JVM 调优可通过以下步骤进行:")]),t._v(" "),a("ul",[a("li",[t._v("分析 "),a("strong",[t._v("GC 日志及 dump 文件")]),t._v(", 判断是否需要优化, 确定瓶颈问题点;")]),t._v(" "),a("li",[t._v("确定 JVM 调优"),a("strong",[t._v("量化目标")]),t._v(";")]),t._v(" "),a("li",[t._v("确定 JVM "),a("strong",[t._v("调优参数")]),t._v(";")]),t._v(" "),a("li",[t._v("依次调优内存, 延迟, 吞吐量等指标;")]),t._v(" "),a("li",[t._v("对比观察调优前后的差异;")]),t._v(" "),a("li",[t._v("不断的分析和调整, 直到找到合适的 JVM 参数配置;")]),t._v(" "),a("li",[t._v("找到最合适的参数, 将这些参数应用到所有服务器, 并进行后续跟踪.")])]),t._v(" "),a("h5",{attrs:{id:"_5-参数设置方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-参数设置方式"}},[t._v("#")]),t._v(" 5.参数设置方式")]),t._v(" "),a("p",[a("strong",[t._v("Spring Boot 程序")]),t._v("的 JVM 参数设置格式:")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐jar microservice‐eureka‐server.jar\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("Tomcat 启动直接加在 bin 目录下 catalina.sh 文件里.")]),t._v(" "),a("h4",{attrs:{id:"虚拟机调优案例分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机调优案例分析"}},[t._v("#")]),t._v(" 虚拟机调优案例分析")]),t._v(" "),a("p",[t._v("本章中的案例一部分来源于笔者处理过的实际问题, 还有另一部分来源于网上有特色和代表性的案例总结. 出于对客户商业信息保护的原因, 在不影响前后逻辑的前提下, 笔者对实际环境和用户业务做了一些屏蔽和精简.")]),t._v(" "),a("p",[t._v("本章内容将着重考虑如何在应用部署层面去解决问题, 有不少案例中的问题的确可以在设计和开发阶段就先行避免, 但这并不是本书要讨论的话题. 也有一些问题可以直接通过升级硬件或者使用最新 JDK 版本里的新技术去解决, 但同时也会探讨如何在不改变已有软硬件版本和规格的前提下, 调整部署和配置策略去解决或者缓解问题.")]),t._v(" "),a("p",[a("strong",[t._v("调优全部都是根据业务具体的场景和 JVM 内存分配机制来的")]),t._v(".")]),t._v(" "),a("h5",{attrs:{id:"_1-大内存硬件上的程序部署策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-大内存硬件上的程序部署策略"}},[t._v("#")]),t._v(" 1.大内存硬件上的程序部署策略")]),t._v(" "),a("p",[t._v("这是笔者很久之前处理过的一个案例, 但今天仍然具有代表性. 一个 15 万 PV/日左右的在线文档类型网站最近更换了硬件系统, 服务器的硬件为四路志强处理器, 16GB 物理内存, 操作系统为 64 位 CentOS 5.4, Resin 作为 Web 服务器. 整个服务器暂时没有部署别的应用, 所有硬件资源都可以提供给这访问量并不算太大的文档网站使用. 软件版本选用的是 64 位的 JDK 5, 管理员启用了一个虚拟机实例, 使用 -Xmx 和 -Xms 参数将 Java 堆大小固定在 12GB. 使用一段时间后发现服务器的运行效果十分不理想, 网站经常"),a("strong",[t._v("不定期出现长时间失去响应")]),t._v(".")]),t._v(" "),a("p",[t._v("监控服务器运行状况后发现网站失去响应是由"),a("strong",[t._v("垃圾收集停顿")]),t._v("所导致的, 在该系统软硬件条件下, HotSpot 虚拟机是以"),a("strong",[t._v("服务端模式")]),t._v("运行, 默认使用的是吞吐量优先收集器, 回收 12GB 的 Java 堆, 一次 Full GC 的停顿时间就高达 14 秒. 由于程序设计的原因, 访问文档时会把文档从磁盘提取到内存中, 导致内存中出现"),a("strong",[t._v("很多由文档序列化产生的大对象, 这些大对象大多在分配时就直接进入了老年代")]),t._v(", 没有在 Minor GC 中被清理掉. 这种情况下即使有 12GB 的堆, 内存也很快会被消耗殆尽, 由此导致每隔几分钟出现十几秒的停顿, 令网站开发, 管理员都对使用 Java 技术开发网站感到很失望.")]),t._v(" "),a("p",[t._v("分析此案例的情况, 程序代码问题这里不延伸讨论, 程序部署上的主要问题显然是过大的堆内存进行回收时带来的长时间的停顿. 经调查, 更早之前的硬件使用的是 32 位操作系统, 给 HotSpot 虚拟机只分配了 1.5GB 的堆内存, 当时用户确实感觉到使用网站比较缓慢, 但还不至于发生长达十几秒的明显停顿, 后来将硬件升级到 64 位系统, 16GB 内存希望能提升程序效能, 却反而出现了停顿问题, 尝试过将 Java 堆分配的内存重新缩小到 1.5GB 或者2GB, 这样的确可以避免长时间停顿, 但是在硬件上的投资就显得非常浪费.")]),t._v(" "),a("p",[t._v("每一款 Java 虚拟机中的每一款垃圾收集器都有自己的应用目标与最适合的应用场景, 如果在特定场景中选择了不恰当的配置和部署方式, 自然会事倍功半. 目前单体应用在较大内存的硬件上主要的部署方式有两种:")]),t._v(" "),a("p",[t._v("(1) 通过一个单独的 Java 虚拟机实例来管理大量的 Java 堆内存.")]),t._v(" "),a("p",[t._v("(2) 同时使用若干个 Java 虚拟机, 建立逻辑集群来利用硬件资源.")]),t._v(" "),a("p",[t._v("此案例中的管理员采用了第一种部署方式. "),a("strong",[t._v("对于用户交互性强, 对停顿时间敏感, 内存又较大的系统, 并不是一定要使用 Shenandoah, ZGC 这些明确以控制延迟为目标的垃圾收集器才能解决问题")]),t._v("(当然不可否认, 如果情况允许的话, 这是最值得考虑的方案), 使用 Parallel Scavenge/Old 收集器, 并且给 Java 虚拟机分配较大的堆内存也是有很多运行得很成功的案例的, 但前提是必须把应用的 Full GC 频率控制得足够低, 至少要低到不会在用户使用过程中发生, 譬如十几个小时乃至一整天都不出现一次 Full GC, 这样可以通过在深夜执行定时任务的方式触发 Full GC 甚至是自动重启应用服务器来保持内存可用空间在一个稳定的水平.")]),t._v(" "),a("p",[a("strong",[t._v('控制 Full GC 频率的关键是老年代的相对稳定, 这主要取决于应用中绝大多数对象能否符合 "朝生夕灭" 的原则, 即大多数对象的生存时间不应当太长, 尤其是不能有成批量的, 长生存时间的大对象产生, 这样才能保障老年代空间的稳定')]),t._v(".")]),t._v(" "),a("p",[t._v("在许多网站和 B/S 形式的应用里, 多数对象的生存周期都应该是请求级或者页面级的, 会话级和全局级的长生命对象相对较少. 只要代码写得合理, 实现在超大堆中正常使用没有 Full GC 应当并不困难, 这样的话, 使用超大堆内存时, 应用响应速度才可能会有所保证. 除此之外, 如果读者计划使用"),a("strong",[t._v("单个 Java 虚拟机实例来管理大内存")]),t._v(", 还需要考虑下面可能面临的问题:")]),t._v(" "),a("ul",[a("li",[t._v("回收大块堆内存而导致的长时间停顿, 自从 G1 收集器的出现, 增量回收得到比较好的应用, 这个问题有所缓解, 但要到 ZGC 和 Shenandoah 收集器成熟之后才得到相对彻底地解决.")]),t._v(" "),a("li",[t._v("大内存必须有 64 位 Java 虚拟机的支持, 但由于压缩指针, 处理器缓存行容量(Cache Line)等因素, 64 位虚拟机的性能测试结果普遍略低于相同版本的 32 位虚拟机.")]),t._v(" "),a("li",[t._v("必须"),a("strong",[t._v("保证应用程序足够稳定")]),t._v(", 因为这种大型单体应用要是发生了堆内存溢出, 几乎无法产生堆转储快照(要产生十几 GB 乃至更大的快照文件), 哪怕成功生成了快照也难以进行分析; 如果确实出了问题要进行诊断, 可能就必须应用 JMC 这种能够在生产环境中进行的运维工具.")]),t._v(" "),a("li",[t._v("相同的程序在 64 位虚拟机中消耗的内存一般比 32 位虚拟机要大, 这是由于指针膨胀, 以及数据类型对齐补白等因素导致的, 可以开启(默认即开启)压缩指针功能来缓解.")])]),t._v(" "),a("p",[t._v("鉴于上述这些问题, 现阶段仍然有一些系统管理员选择第二种方式来部署应用: "),a("strong",[t._v("同时使用若干个虚拟机建立逻辑集群来利用硬件资源")]),t._v(". 做法是在一台物理机器上启动多个应用服务器进程, 为每个服务器进程分配不同端口, 然后在前端搭建一个负载均衡器, 以反向代理的方式来分配访问请求. 这里无须太在意均衡器转发所消耗的性能, 即使是使用第一个部署方案, 多数应用也不止有一台服务器, 因此应用中前端的负载均衡器总是免不了的.")]),t._v(" "),a("p",[t._v("考虑到在一台物理机器上建立逻辑集群的目的仅仅是尽可能利用硬件资源, 并不是要按职责, 按领域做应用拆分, 也不需要考虑"),a("strong",[t._v("状态保留, 热转移")]),t._v("之类的高可用性需求, 不需要保证每个虚拟机进程有绝对准确的均衡负载, 因此使用无 Session 复制的亲合式集群是一个相当合适的选择. 仅仅需要保障集群具备亲合性, 也就是均衡器按一定的规则算法(譬如根据 Session ID 分配)将一个固定的用户请求永远分配到一个固定的集群节点进行处理即可, 这样程序开发阶段就几乎不必为集群环境做任何特别的考虑.")]),t._v(" "),a("p",[t._v("当然, 第二种部署方案也不是没有缺点的, 如果读者计划使用逻辑集群的方式来部署程序, 可能会遇到下面这些问题:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("节点竞争全局的资源")]),t._v(", 最典型的就是磁盘竞争, 各个节点如果同时访问某个磁盘文件的话(尤其是并发写操作容易出现问题), 很容易导致 I/O 异常.")]),t._v(" "),a("li",[a("strong",[t._v("很难最高效率地利用某些资源池")]),t._v(", 譬如连接池, 一般都是在各个节点建立自己独立的连接池, 这样有可能导致一些节点的连接池已经满了, 而另外一些节点仍有较多空余. 尽管可以使用集中式的 JNDI 来解决, 但这个方案有一定复杂性并且可能带来额外的性能代价.")]),t._v(" "),a("li",[t._v("大量使用本地缓存(如大量使用 HashMap 作为 K/V 缓存)的应用, 在逻辑集群中会造成较大的内存浪费, 因为每个逻辑节点上都有一份缓存, 这时候可以考虑把本地缓存改为集中式缓存.")])]),t._v(" "),a("p",[t._v("介绍完这两种部署方式, 重新回到这个案例之中, 最后的部署方案并没有选择升级 JDK 版本, 而是调整为建立 5 个 32 位 JDK 的逻辑集群, 每个进程按 2GB 内存计算(其中堆固定为 1.5GB), 占用了 10GB 内存. 另外建立一个 Apache 服务作为前端均衡代理作为访问门户. 考虑到用户对响应速度比较关心, 并且文档服务的主要压力集中在磁盘和内存访问, 处理器资源敏感度较低, 因此"),a("strong",[t._v("改为 CMS 收集器进行垃圾回收")]),t._v(". 部署方式调整后, 服务再没有出现长时间停顿, 速度比起硬件升级前有较大提升.")]),t._v(" "),a("h5",{attrs:{id:"_2-集群间同步导致的内存溢出"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-集群间同步导致的内存溢出"}},[t._v("#")]),t._v(" 2.集群间同步导致的内存溢出")]),t._v(" "),a("p",[t._v("一个基于 B/S 的 MIS 系统, 硬件为两台双路处理器, 8GB 内存的 HP 小型机, 应用中间件是 WebLogic 9.2, 每台机器启动了 3 个 WebLogic 实例, 构成一个 6 个节点的"),a("strong",[t._v("亲合式集群")]),t._v(". 由于是亲合式集群, 节点之间没有进行 Session 同步, 但是有一些需求要实现部分数据在各个节点间共享. 最开始这些数据是存放在数据库中的, 但由于读写频繁, 竞争很激烈, 性能影响较大, 后面使用 JBossCache 构建了一个全局缓存. 全局缓存启用后, 服务正常使用了一段较长的时间. 但在最近不定期出现"),a("strong",[t._v("多次的内存溢出")]),t._v("问题.")]),t._v(" "),a("p",[t._v("在内存溢出异常不出现的时候, 服务内存回收状况一直正常, 每次内存回收后都能恢复到一个稳定的可用空间. 开始怀疑是程序某些不常用的代码路径中存在内存泄漏, 但管理员反映最近程序并未更新, 升级过, 也没有进行什么特别操作. 只好让服务带着 "),a("code",[t._v("-XX: +HeapDumpOnOutOfMemoryError")]),t._v("​ 参数运行了一段时间. 在最近一次溢出之后, 管理员发回了堆转储快照, 发现里面存在着大量的 "),a("strong",[t._v("org.jgroups.protocols.pbcast.NAKACK")]),t._v(" 对象.")]),t._v(" "),a("p",[t._v("JBossCache 是基于自家的 JGroups 进行集群间的数据通信, JGroups 使用协议栈的方式来实现收发数据包的各种所需特性自由组合, 数据包接收和发送时要经过每层协议栈的 up() 和 down() 方法, 其中的 NAKACK 栈用于保障各个包的有效顺序以及重发.")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/Image00098-20240302133505-m3djl5x.jpg",alt:"",title:"JBossCache 协议栈"}})]),t._v(" "),a("p",[t._v("由于信息有传输失败需要重发的可能性, 在确认所有注册在 GMS(Group Membership Service)的节点都收到正确的信息前, "),a("strong",[t._v("发送的信息必须在内存中保留")]),t._v(". 而此 MIS 的服务端中有一个负责安全校验的全局过滤器, 每当接收到请求时, 均会更新一次最后操作时间, 并且将这个时间同步到所有的节点中去, 使得一个用户在一段时间内不能在多台机器上重复登录. 在服务使用过程中, 往往一个页面会产生数次乃至数十次的请求, 因此这个过滤器导致集群各个节点之间网络交互非常频繁. "),a("strong",[t._v("当网络情况不能满足传输要求时, 重发数据在内存中不断堆积, 很快就产生了内存溢出")]),t._v(".")]),t._v(" "),a("p",[t._v("这个案例中的问题, 既有 "),a("strong",[t._v("JBossCache 的缺陷, 也有 MIS 系统实现方式上的缺陷")]),t._v(". JBoss-Cache 官方的邮件讨论组中讨论过很多次类似的内存溢出异常问题, 据说后续版本也有了改进. 而更重要的缺陷是, 这一类被集群共享的数据要使用类似 JBossCache 这种非集中式的集群缓存来同步的话, 可以允许读操作频繁, 因为数据在本地内存有一份副本, 读取的动作不会耗费多少资源, 但不应当有过于频繁的写操作, 会带来很大的网络同步的开销.")]),t._v(" "),a("h5",{attrs:{id:"_3-堆外内存导致的溢出错误"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-堆外内存导致的溢出错误"}},[t._v("#")]),t._v(" 3.堆外内存导致的溢出错误")]),t._v(" "),a("p",[t._v("这是一个学校的小型项目: 基于 B/S 的电子考试系统, 为了实现客户端能实时地从服务器端接收考试数据, 系统使用了逆向 AJAX 技术, 选用 CometD 1.1.1 作为服务端推送框架, 服务器是 Jetty 7.1.4, 硬件为一台很普通 PC 机, Core i5 CPU, 4GB 内存, 运行 32 位 Windows 操作系统.")]),t._v(" "),a("p",[t._v("测试期间发现服务端"),a("strong",[t._v("不定时抛出内存溢出异常")]),t._v(", 服务不一定每次都出现异常, 但假如正式考试时崩溃一次, 那估计整场电子考试都会乱套. 网站管理员尝试过把堆内存调到最大, 32 位系统最多到 1.6GB 基本无法再加大了, 而且开大了基本没效果, 抛出内存溢出异常好像还更加频繁. 加入 "),a("code",[t._v("-XX: +HeapDumpOnOutOfMemoryError")]),t._v("​ 参数, 居然也没有任何反应, 抛出内存溢出异常时什么文件都没有产生. 无奈之下只好挂着 jstat 紧盯屏幕, 发现垃圾收集并不频繁, Eden 区, Survivor 区, 老年代以及方法区的内存全部都很稳定, 压力并不大, 但就是照样不停抛出内存溢出异常. 最后, 在"),a("strong",[t._v("内存溢出后从系统日志中找到异常堆栈")]),t._v("如下所示.")]),t._v(" "),a("blockquote",[a("p",[t._v("代码清单 异常堆栈")])]),t._v(" "),a("div",{staticClass:"language-ziti1 line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("[org.eclipse.jetty.util.log] handle failed java.lang.OutOfMemoryError: null\nat sun.misc.Unsafe.allocateMemory(Native Method)\nat java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:99)\nat java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288)\nat org.eclipse.jetty.io.nio.DirectNIOBuffer.<init>\n...\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("这里看到异常堆栈应该就清楚这个抛出内存溢出异常是怎么回事了. 操作系统对每个进程能管理的内存是有限制的, 这台服务器使用的 32 位 Windows 平台的限制是 2GB, 其中划了 1.6GB 给 Java 堆, "),a("strong",[t._v("而 Direct Memory 耗用的内存并不算入这 1.6GB 的堆之内")]),t._v(", 因此它最大也只能在剩余的 0.4GB 空间中再分出一部分而已. 在此应用中导致溢出的关键是垃圾收集进行时, 虚拟机虽然会对直接内存进行回收, 但是"),a("strong",[t._v('直接内存却不能像新生代, 老年代那样, 发现空间不足了就主动通知收集器进行垃圾回收, 它只能等待老年代满后 Full GC 出现后, "顺便" 帮它清理掉内存的废弃对象')]),t._v(". 否则就不得不一直等到抛出内存溢出异常时, 先捕获到异常, 再在 Catch 块里面通过 System.gc() 命令来触发垃圾收集. 但如果 Java 虚拟机再打开了 "),a("code",[t._v("-XX: +DisableExplicitGC")]),t._v("​ 开关, 禁止了人工触发垃圾收集的话, 那就只能眼睁睁看着堆中还有许多空闲内存, 自己却不得不抛出内存溢出异常了. 而本案例中使用的 CometD 1.1.1 框架, 正好有"),a("strong",[t._v("大量的 NIO 操作")]),t._v("需要使用到直接内存.")]),t._v(" "),a("p",[t._v("从实践经验的角度出发, "),a("strong",[t._v("在处理小内存或者 32 位的应用问题时, 除了 Java 堆和方法区之外, 可以注意到下面这些区域还会占用较多的内存")]),t._v(", 这里所有的内存总和受到操作系统进程最大内存的限制:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("直接内存")]),t._v(": 可通过 "),a("code",[t._v("-XX: MaxDirectMemorySize")]),t._v("​ 调整大小, 内存不足时抛出 OutOfMemoryError 或者 OutOfMemoryError: Direct buffer memory.")]),t._v(" "),a("li",[a("strong",[t._v("线程堆栈")]),t._v(": 可通过 "),a("code",[t._v("-Xss")]),t._v("​ 调整大小, 内存不足时抛出 StackOverflowError(如果线程请求的栈深度大于虚拟机所允许的深度)或者 OutOfMemoryError(如果 Java 虚拟机栈容量可以动态扩展, 当栈扩展时无法申请到足够的内存).")]),t._v(" "),a("li",[a("strong",[t._v("Socket 缓存区")]),t._v(": 每个 Socket 连接都 Receive 和 Send 两个缓存区, 分别占大约 37KB 和 25KB 内存, 连接多的话这块内存占用也比较可观. 如果无法分配, 可能会抛出 IOException: Too many open files 异常.")]),t._v(" "),a("li",[a("strong",[t._v("JNI 代码")]),t._v(": 如果代码中使用了 JNI 调用本地库, 那本地库使用的内存也不在堆中, 而是占用 Java 虚拟机的本地方法栈和本地内存的.")]),t._v(" "),a("li",[a("strong",[t._v("虚拟机和垃圾收集器")]),t._v(": 虚拟机, 垃圾收集器的工作也是要消耗一定数量的内存的.")])]),t._v(" "),a("h5",{attrs:{id:"_4-外部命令导致系统缓慢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-外部命令导致系统缓慢"}},[t._v("#")]),t._v(" 4.外部命令导致系统缓慢")]),t._v(" "),a("p",[t._v("一个数字校园应用系统, 运行在一台四路处理器的 Solaris 10 操作系统上, 中间件为 GlassFish 服务器. 系统在做大并发压力测试的时候, 发现请求响应时间比较慢, 通过操作系统的 mpstat 工具发现处理器使用率很高, 但是系统中占用绝大多数处理器资源的程序并不是该应用本身. 这是个不正常的现象, 通常情况下用户应用的处理器占用率应该占主要地位, 才能说明系统是在正常工作.")]),t._v(" "),a("p",[t._v("通过 Solaris 10 的 dtrace 脚本可以查看当前情况下"),a("strong",[t._v("哪些系统调用花费了最多的处理器资源")]),t._v(', dtrace 运行后发现最消耗处理器资源的竟然是 "fork" 系统调用. 众所周知, "fork" 系统调用是 Linux 用来'),a("strong",[t._v("产生新进程")]),t._v("的, 在 Java 虚拟机中, 用户编写的 Java 代码通常最多只会创建新的线程, 不应当有进程的产生, 这又是个相当不正常的现象.")]),t._v(" "),a("p",[t._v("通过联系该系统的开发人员, 最终找到了答案: "),a("strong",[t._v("每个用户请求的处理都需要执行一个外部 Shell 脚本来获得系统的一些信息")]),t._v(". 执行这个 Shell 脚本是通过 Java 的 "),a("code",[t._v("Runtime.getRuntime().exec()")]),t._v("​ 方法来调用的. 这种调用方式可以达到执行 Shell 脚本的目的, 但是它在 Java 虚拟机中是"),a("strong",[t._v("非常消耗资源")]),t._v("的操作, 即使外部命令本身能很快执行完毕, 频繁调用时创建进程的开销也会非常可观. "),a("strong",[t._v("Java 虚拟机执行这个命令的过程是首先复制一个和当前虚拟机拥有一样环境变量的进程, 再用这个新的进程去执行外部命令, 最后再退出这个进程")]),t._v(". 如果频繁执行这个操作, 系统的消耗必然会很大, 而且不仅是处理器消耗, 内存负担也很重.")]),t._v(" "),a("p",[a("strong",[t._v("用户根据建议去掉这个 Shell 脚本执行的语句")]),t._v(", 改为使用 Java 的 API 去获取这些信息后, 系统很快恢复了正常.")]),t._v(" "),a("h5",{attrs:{id:"_5-服务器虚拟机进程崩溃"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-服务器虚拟机进程崩溃"}},[t._v("#")]),t._v(" 5.服务器虚拟机进程崩溃")]),t._v(" "),a("p",[t._v("一个基于 B/S 的 MIS 系统, 硬件为两台双路处理器, 8GB 内存的 HP 系统, 服务器是 WebLogic 9.2. 正常运行一段时间后, 最近发现在运行期间频繁出现集群节点的"),a("strong",[t._v("虚拟机进程自动关闭")]),t._v("的现象, 留下了一个 "),a("code",[t._v("hs_err_pid###.log")]),t._v("​ 文件后, 虚拟机进程就消失了, 两台物理机器里的每个节点都出现过进程崩溃的现象. 从系统日志中注意到, "),a("strong",[t._v("每个节点的虚拟机进程在崩溃之前, 都发生过大量相同的异常")]),t._v(", 如下所示.")]),t._v(" "),a("blockquote",[a("p",[t._v("代码清单 异常堆栈2")])]),t._v(" "),a("div",{staticClass:"language-ziti1 line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("java.net.SocketException: Connection reset\nat java.net.SocketInputStream.read(SocketInputStream.java:168)\nat java.io.BufferedInputStream.fill(BufferedInputStream.java:218)\nat java.io.BufferedInputStream.read(BufferedInputStream.java:235)\nat org.apache.axis.transport.http.HTTPSender.readHeadersFromSocket(HTTPSender.java:583)\nat org.apache.axis.transport.http.HTTPSender.invoke(HTTPSender.java:143)\n... 99 more\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br")])]),a("p",[t._v("这是一个"),a("strong",[t._v("远端断开连接")]),t._v("的异常, 通过系统管理员了解到系统最近与一个 OA 门户做了集成, 在 MIS 系统工作流的待办事项变化时, 要通过 Web 服务通知 OA 门户系统, 把待办事项的变化同步到 OA 门户之中. 通过 SoapUI 测试了一下同步待办事项的几个 Web 服务, 发现调用后竟然需要"),a("strong",[t._v("长达 3 分钟才能返回")]),t._v(", 并且返回结果都是超时导致的连接中断.")]),t._v(" "),a("p",[t._v("由于 MIS 系统的用户多, 待办事项变化很快, 为了不被 OA 系统速度拖累, 使用了异步的方式调用 Web 服务, 但由于两边服务速度的完全不对等, 时间越长就累积了越多 Web 服务没有调用完成, "),a("strong",[t._v("导致在等待的线程和 Socket 连接越来越多, 最终超过虚拟机的承受能力后导致虚拟机进程崩溃")]),t._v(". 通知 OA 门户方修复无法使用的集成接口, 并将异步调用改为生产者/消费者模式的"),a("strong",[t._v("消息队列")]),t._v("实现后, 系统恢复正常.")]),t._v(" "),a("h5",{attrs:{id:"_6-不恰当数据结构导致内存占用过大"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-不恰当数据结构导致内存占用过大"}},[t._v("#")]),t._v(" 6.不恰当数据结构导致内存占用过大")]),t._v(" "),a("p",[t._v("一个后台 RPC 服务器, 使用 64 位 Java 虚拟机, 内存配置为 "),a("code",[t._v("-Xms4g -Xmx8g -Xmn1g")]),t._v("​, 使用 ParNew 加 CMS 的收集器组合. 平时对外服务的 Minor GC 时间约在 30 毫秒以内, 完全可以接受. 但业务上需要每 10 分钟加载一个约 80MB 的数据文件到内存进行数据分析, 这些数据会在内存中形成超过 100 万个 "),a("code",[t._v("HashMap<Long, Long>Entry")]),t._v("​, 在这段时间里面 Minor GC 就会造成超过 500 毫秒的停顿, 对于这种长度的停顿时间就接受不了了, 具体情况如下面的收集器日志所示.")]),t._v(" "),a("div",{staticClass:"language-ziti1 line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("{Heap before GC invocations=95 (full 4):\n par new generation   total 903168K, used 803142K [0x00002aaaae770000, 0x00002aaaebb70000, 0x00002aaaebb70000)\n    eden space 802816K, 100% used [0x00002aaaae770000, 0x00002aaadf770000, 0x00002aaadf770000)\n    from space 100352K,   0% used [0x00002aaae5970000, 0x00002aaae59c1910, 0x00002aaaebb70000)\n    to   space 100352K,   0% used [0x00002aaadf770000, 0x00002aaadf770000, 0x00002aaae5970000)\nconcurrent mark-sweep generation total 5845540K, used 3898978K [0x00002aaaebb70000, 0x00002aac507f9000, 0x00002aacae770000)\nconcurrent-mark-sweep perm gen total 65536K, used 40333K [0x00002aacae770000, 0x00002aacb2770000, 0x00002aacb2770000)\n2011-10-28T11:40:45.162+0800: 226.504: [GC 226.504: [ParNew: 803142K-> 100352K(903168K), 0.5995670 secs] 4702120K->4056332K(6748708K), 0.5997560 secs] [Times: user=1.46 sys=0.04, real=0.60 secs]\nHeap after GC invocations=96 (full 4):\npar new generation   total 903168K, used 100352K [0x00002aaaae770000, 0x00002-aaaebb70000, 0x00002aaaebb70000)\n    eden space 802816K,   0% used [0x00002aaaae770000, 0x00002aaaae770000, 0x00002aaadf770000)\n    from space 100352K, 100% used [0x00002aaadf770000, 0x00002aaae5970000, 0x00002aaae5970000)\n    to   space 100352K,   0% used [0x00002aaae5970000, 0x00002aaae5970000, 0x00002aaaebb70000)\nconcurrent mark-sweep generation total 5845540K, used 3955980K [0x00002aaaebb70000, 0x00002aac507f9000, 0x00002aacae770000)\nconcurrent-mark-sweep perm gen total 65536K, used 40333K [0x00002aacae770000, 0x00002aacb2770000, 0x00002aacb2770000)\n}\nTotal time for which application threads were stopped: 0.6070570 seconds\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br"),a("span",{staticClass:"line-number"},[t._v("17")]),a("br")])]),a("p",[t._v("观察这个案例的日志, 平时 Minor GC 时间很短, 原因是新生代的绝大部分对象都是可清除的, 在 Minor GC 之后 Eden 和 Survivor 基本上处于完全空闲的状态. 但是在分析数据文件期间, 800MB 的 Eden 空间很快被填满引发垃圾收集, 但 Minor GC 之后, 新生代中绝大部分对象依然是存活的. ParNew 收集器使用的是复制算法, 这个算法的"),a("strong",[t._v('高效是建立在大部分对象都 "朝生夕灭" 的特性上')]),t._v("的, 如果存活对象过多, 把这些对象复制到 Survivor 并维持这些对象引用的正确性就成为一个沉重的负担, 因此导致垃圾收集的暂停时间明显变长.")]),t._v(" "),a("p",[t._v("如果不修改程序, 仅从 GC 调优的角度去解决这个问题, 可以考虑直接将 Survivor 空间去掉(加入参数 "),a("code",[t._v("-XX: SurvivorRatio=65536, -XX: MaxTenuringThreshold=0")]),t._v("​ 或者 "),a("code",[t._v("-XX: +AlwaysTenure")]),t._v("​), 让新生代中存活的对象在第一次 Minor GC 后立即进入老年代, 等到 Major GC 的时候再去清理它们. 这种措施可以治标, 但也有很大副作用; 治本的方案必须要修改程序, 因为这里产生问题的根本原因是用 "),a("code",[t._v("HashMap<Long, Long>")]),t._v("​ 结构来存储数据文件"),a("strong",[t._v("空间效率太低")]),t._v("了.")]),t._v(" "),a("p",[t._v("具体分析一下 HashMap 空间效率, 在 "),a("code",[t._v("HashMap<Long, Long>")]),t._v("​ 结构中, 只有 Key 和 Value 所存放的两个长整型数据是有效数据, 共 16 字节(2 × 8 字节). 这两个长整型数据包装成 java.lang.Long 对象之后, 就分别具有 8 字节的 Mark Word, 8 字节的 Klass 指针, 再加 8 字节存储数据的 long 值. 然后这 2 个 Long 对象组成 Map.Entry 之后, 又多了 16 字节的对象头, 然后一个 8 字节的 next 字段和 4 字节的 int 型的 hash 字段, 为了对齐, 还必须添加 4 字节的空白填充, 最后还有 HashMap 中对这个 Entry 的 8 字节的引用, 这样增加两个长整型数字, 实际耗费的内存为"),a("code",[t._v("(Long(24byte) × 2) + Entry(32byte) + HashMap Ref(8byte) = 88byte")]),t._v("​, 空间效率为有效数据除以全部内存空间, 即 16 字节 / 88 字节 = "),a("strong",[t._v("18%")]),t._v(" , 这确实太低了.")]),t._v(" "),a("h5",{attrs:{id:"_7-由windows虚拟内存导致的长时间停顿"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-由windows虚拟内存导致的长时间停顿"}},[t._v("#")]),t._v(" 7.由Windows虚拟内存导致的长时间停顿")]),t._v(" "),a("p",[t._v("有一个带心跳检测功能的 GUI 桌面程序, 每 15 秒会发送一次心跳检测信号, 如果对方 30 秒以内都没有信号返回, 那就认为和对方程序的连接已经断开. 程序上线后发现心跳检测有误报的可能, 查询日志发现误报的原因是程序会偶尔出现间隔约一分钟的时间完全无日志输出, 处于停顿状态.")]),t._v(" "),a("p",[t._v("因为是桌面程序, 所需的内存并不大(-Xmx256m), 所以开始并没有想到是垃圾收集导致的程序停顿, 但是加入参数 "),a("code",[t._v("-XX: +PrintGCApplicationStoppedTime -XX: +PrintGCDateStamps -Xloggc: gclog.log")]),t._v("​ 后, 从收集器日志文件中确认了停顿确实是由垃圾收集导致的, 大部分收集时间都控制在 100 毫秒以内, 但"),a("strong",[t._v("偶尔就出现一次接近 1 分钟的长时间收集过程")]),t._v(".")]),t._v(" "),a("div",{staticClass:"language-ziti1 line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Total time for which application threads were stopped:  0.0112389 seconds\nTotal time for which application threads were stopped:  0.0001335 seconds\nTotal time for which application threads were stopped:  0.0003246 seconds\nTotal time for which application threads were stopped: 41.4731411 seconds  \nTotal time for which application threads were stopped:  0.0489481 seconds\nTotal time for which application threads were stopped:  0.1110761 seconds\nTotal time for which application threads were stopped:  0.0007286 seconds\nTotal time for which application threads were stopped:  0.0001268 seconds\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("p",[t._v("从收集器日志中找到长时间停顿的具体日志信息(再添加了 "),a("code",[t._v("-XX: +PrintReferenceGC")]),t._v("​ 参数), 找到的日志片段如下所示. 从日志中看到, 真正执行垃圾收集动作的时间不是很长, 但"),a("strong",[t._v("从准备开始收集, 到真正开始收集之间所消耗的时间却占了绝大部分")]),t._v(".")]),t._v(" "),a("div",{staticClass:"language-ziti1 line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("2012-08-29T19:14:30.968+0800: 10069.800: [GC10099.225: [SoftReference, 0 refs, 0.0000109 secs]10099.226: [WeakReference, 4072 refs, 0.0012099 secs]10099.227: [FinalReference, 984 refs, 1.5822450 secs]10100.809: [PhantomReference, 251 refs, 0.0001394 secs]10100.809: [JNI Weak Reference, 0.0994015 secs] [PSYoungGen: 175672K->8528K(167360K)] 251523K->100182K(353152K), 31.1580402 secs] [Times: user=0.61 sys=0.52, real=31.16 secs]\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("除收集器日志之外, 还观察到这个 GUI 程序内存变化的一个特点, 当它最小化的时候, 资源管理中显示的占用内存大幅度减小, 但是虚拟内存则没有变化, 因此怀疑程序"),a("strong",[t._v("在最小化时它的工作内存被自动交换到磁盘的页面文件之中了, 这样发生垃圾收集时就有可能因为恢复页面文件的操作导致不正常的垃圾收集停顿")]),t._v(".")]),t._v(" "),a("p",[t._v('在 MSDN 上查证确认了这种猜想, 在 Java 的 GUI 程序中要避免这种现象, 可以加入参数 "-Dsun.awt.keepWorkingSetOnMinimize=true" 来解决. 在这个案例中加入该参数, 问题马上得到解决.')]),t._v(" "),a("h5",{attrs:{id:"_8-由安全点导致长时间停顿"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-由安全点导致长时间停顿"}},[t._v("#")]),t._v(" 8.由安全点导致长时间停顿")]),t._v(" "),a("p",[t._v("有一个比较大的承担公共计算任务的"),a("strong",[t._v("离线 HBase 集群")]),t._v(", 运行在 JDK 8 上, 使用 G1 收集器. 每天都有大量的 "),a("strong",[t._v("MapReduce 或 Spark 离线分析任务")]),t._v("对其进行访问, 同时有很多其他在线集群 Replication 过来的数据写入, 因为集群"),a("strong",[t._v("读写压力较大")]),t._v(", 而离线分析任务对延迟又不会特别敏感, 所以将 "),a("code",[t._v("-XX: MaxGCPauseMillis")]),t._v("​ 参数设置到了 500 毫秒. 不过运行一段时间后发现垃圾收集的停顿经常达到 3 秒以上, 而且实际垃圾收集器进行回收的动作就只占其中的几百毫秒, 现象如以下日志所示.")]),t._v(" "),a("div",{staticClass:"language-ziti1 line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("[Times: user=1.51 sys=0.67, real=0.14 secs]\n2019-06-25T 12:12:43.376+0800: 3448319.277: Total time for which application threads were stopped: 2.2645818 seconds\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("这里解释一下 user, sys, real 这三个时间的概念:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("user")]),t._v(": 进程执行"),a("strong",[t._v("用户态代码")]),t._v("所耗费的处理器时间.")]),t._v(" "),a("li",[a("strong",[t._v("sys")]),t._v(": 进程执行"),a("strong",[t._v("核心态代码")]),t._v("所耗费的处理器时间.")]),t._v(" "),a("li",[a("strong",[t._v("real")]),t._v(": 执行"),a("strong",[t._v("动作从开始到结束")]),t._v("耗费的时钟时间.")])]),t._v(" "),a("p",[t._v("请注意, 前面两个是处理器时间, 而最后一个是时钟时间, 它们的区别是处理器时间代表的是线程占用处理器一个核心的耗时计数, 而时钟时间就是现实世界中的时间计数. 如果是单核单线程的场景下, 这两者可以认为是等价的, 但如果是多核环境下, 同一个时钟时间内有多少处理器核心正在工作, 就会有多少倍的处理器时间被消耗和记录下来.")]),t._v(" "),a("p",[a("strong",[t._v("在垃圾收集调优时, 主要依据 real 时间为目标来优化程序, 因为最终用户只关心发出请求到得到响应所花费的时间, 也就是响应速度, 而不太关心程序到底使用了多少个线程或者处理器来完成任务")]),t._v(".")]),t._v(" "),a("p",[t._v("日志显示这次垃圾收集一共花费了 0.14 秒, 但其中用户线程却足足停顿了有 2.26 秒, 两者差距已经远远超出了正常的 TTSP(Time To Safepoint)耗时的范畴. 所以先加入参数 "),a("code",[t._v("-XX: +PrintSafepointStatistics")]),t._v("​ 和 "),a("code",[t._v("-XX: PrintSafepointStatisticsCount=1")]),t._v("​ 去查看安全点日志, 具体如下所示:")]),t._v(" "),a("div",{staticClass:"language-ziti1 line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("vmop    [threads: total initially_running wait_to_block]\n65968.203: ForceAsyncSafepoint [931   1   2]\n[time: spin block sync cleanup vmop] page_trap_count\n[2255  0  2255 11  0]  1\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[a("strong",[t._v("日志显示当前虚拟机的操作(VM Operation, VMOP)是等待所有用户线程进入到安全点, 但是有两个线程特别慢, 导致发生了很长时间的自旋等待")]),t._v(". 日志中的 2255 毫秒自旋(Spin)时间就是指由于部分线程已经走到了安全点, 但还有一些特别慢的线程并没有到, 所以垃圾收集线程无法开始工作, 只能"),a("strong",[t._v("空转(自旋)等待")]),t._v(".")]),t._v(" "),a("p",[t._v("解决问题的第一步是把这两个特别慢的线程给找出来, 这个倒不困难, 添加 "),a("code",[t._v("-XX: +SafepointTimeout")]),t._v("​ 和 "),a("code",[t._v("-XX: SafepointTimeoutDelay=2000")]),t._v("​ 两个参数, "),a("strong",[t._v("让虚拟机在等到线程进入安全点的时间超过 2000 毫秒时就认定为超时, 这样就会输出导致问题的线程名称")]),t._v(", 得到的日志如下所示:")]),t._v(" "),a("div",{staticClass:"language-ziti1 line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('# SafepointSynchronize::begin: Timeout detected:\n# SafepointSynchronize::begin: Timed out while spinning to reach a safepoint.\n# SafepointSynchronize::begin: Threads which did not reach the safepoint:\n# "RpcServer.listener,port=24600" #32 daemon prio=5 os_prio=0 tid=0x00007f4c14b22840\n  nid=0xa621 runnable [0x0000000000000000]\njava.lang.Thread.State: RUNNABLE\n# SafepointSynchronize::begin: (End of list)\n')])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br")])]),a("p",[t._v('从错误日志中顺利得到了导致问题的线程名称为 "RpcServer.listener, port=24600". 但是为什么它们会出问题呢? 有什么因素可以阻止线程进入安全点? 前面关于安全点的介绍中, 已经知道安全点是以 "'),a("strong",[t._v("是否具有让程序长时间执行的特征")]),t._v('" 为原则进行选定的, 所以方法调用, 循环跳转, 异常跳转这些位置都可能会设置有安全点, 但是 HotSpot 虚拟机为了避免安全点过多带来过重的负担, 对循环还有一项优化措施, 认为循环次数较少的话, 执行时间应该也不会太长, 所以使用 int 类型或范围更小的数据类型作为索引值的循环默认是不会被放置安全点的. 这种循环被称为可数循环(Counted Loop), 相对应地, 使用 long 或者范围更大的数据类型作为索引值的循环就被称为不可数循环(Uncounted Loop), 将会被放置安全点. 通常情况下这个优化措施是可行的, 但循环执行的时间不单单是由其次数决定, 如果循环体单次执行就特别慢, 那即使是可数循环也可能会耗费很多的时间.')]),t._v(" "),a("p",[t._v("HotSpot 原本提供了 "),a("code",[t._v("-XX: +UseCountedLoopSafepoints")]),t._v("​ 参数去强制在可数循环中也放置安全点, 不过这个参数在 JDK 8下有 Bug, 有导致虚拟机崩溃的风险, 所以就不得不找到 RpcServer 线程里面的缓慢代码来进行修改. 最终查明导致这个问题是 HBase 中一个"),a("strong",[t._v("连接超时清理的函数")]),t._v(", 由于集群会有多个 MapReduce 或 Spark 任务进行访问, 而每个任务又会同时起多个 "),a("code",[t._v("Mapper/Reducer/Executer")]),t._v("​, 其每一个都会作为一个 HBase 的客户端, 这就导致了同时连接的数量会非常多. 更为关键的是, 清理连接的索引值就是 int 类型, 所以这是一个"),a("strong",[t._v("可数循环, HotSpot 不会在循环中插入安全点")]),t._v(". 当垃圾收集发生时, 如果 RpcServer 的 Listener 线程刚好执行到该函数里的可数循环时, 则必须等待循环全部跑完才能进入安全点, 此时其他线程也必须一起等着, 所以从现象上看就是长时间的停顿. 找到了问题, 解决起来就非常简单了, 把循环索引的数据类型从 int 改为 long 即可, 但如果不具备安全点和垃圾收集的知识, 这种问题是很难处理的.")]),t._v(" "),a("h5",{attrs:{id:"_9-电商系统优化jvm参数-parnew-cms"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-电商系统优化jvm参数-parnew-cms"}},[t._v("#")]),t._v(" 9.电商系统优化JVM参数(ParNew+CMS)")]),t._v(" "),a("p",[t._v("大型电商系统后端现在一般都是拆分为多个"),a("strong",[t._v("子系统")]),t._v("部署的, 如商品系统, 库存系统, 订单系统等. 这里以比较核心的订单系统为例, 假设系统日均产生 50W 订单, 当发生促销时, 假设每秒有 1000 单, 共部署 3 台服务器, 每台服务器需每秒处理 300 个订单. 假设每个订单对象 1K, 则每秒产生 300K 的订单对象, 下单过程的各种业务可能会产生其他对象, 这里放大 20 倍, 假设每秒产生 300K * 20 = 6M 的对象. 生成订单可能还涉及查询等操作, 再放大 10 倍, 假设疫苗产生 60M 对象. 但是这些对象会在 1 秒后全部变成垃圾对象.")]),t._v(" "),a("p",[t._v("对于 "),a("strong",[t._v("8G")]),t._v(" 内存的服务器一般是分配 "),a("strong",[t._v("4G")]),t._v(" 内存给 JVM, 一般的 JVM "),a("strong",[t._v("参数配置")]),t._v("如下:")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xms3072M")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xmx3072M")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xmn1536M")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xss1M")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MetaspaceSize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("256")]),t._v("M "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxMetaspaceSize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("256")]),t._v("M  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SurvivorRatio")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[a("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521161117900.png",alt:""}})]),t._v(" "),a("p",[t._v("系统按"),a("strong",[t._v("每秒生成 60MB 的速度")]),t._v("来生成对象, 大概运行 "),a("strong",[t._v("20 秒")]),t._v("就会撑满 eden 区, 会触发 Minor GC, 大概会有 95% 以上对象成为垃圾被回收, 可能最后"),a("strong",[t._v("一两秒")]),t._v("生成的对象"),a("strong",[t._v("还被引用着")]),t._v(", 暂估为 "),a("strong",[t._v("100MB")]),t._v(" 左右, 那么这 100M 会被挪到 "),a("strong",[t._v("S0 区")]),t._v(", 根据"),a("strong",[t._v("动态对象年龄判断原则")]),t._v(", 这 "),a("strong",[t._v("100MB")]),t._v(" 对象同龄而且总和大于 S0 区的 "),a("strong",[t._v("50%")]),t._v(" , 那么这些对象都会被挪到"),a("strong",[t._v("老年代")]),t._v(", 到了老年代不到"),a("strong",[t._v("一秒")]),t._v("又变成了"),a("strong",[t._v("垃圾对象")]),t._v(", 很明显这里 "),a("strong",[t._v("survivor 区")]),t._v("大小设置有点小.")]),t._v(" "),a("p",[t._v("分析下系统业务就知道, 明显"),a("strong",[t._v("大部分")]),t._v("对象都是"),a("strong",[t._v("短生存周期")]),t._v("的, "),a("strong",[t._v("根本不应该频繁进入老年代")]),t._v(", 也"),a("strong",[t._v("没必要给老年代维持过大的内存空间, 得让对象尽量留在新生代里")]),t._v(".")]),t._v(" "),a("p",[t._v("于是可以"),a("strong",[t._v("更新")]),t._v("下 JVM 参数设置:")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xms3072M")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xmx3072M")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xmn2048M")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xss1M")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PermSize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("256")]),t._v("M "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxPermSize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("256")]),t._v("M  \n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SurvivorRatio")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v(" \n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[a("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521161455182.png",alt:""}})]),t._v(" "),a("p",[t._v("这样就降低了因为"),a("strong",[t._v("对象动态年龄判断原则导致的对象频繁进入老年代")]),t._v("的问题, 其实"),a("strong",[t._v("很多优化无非就是让短期存活的对象尽量都留在 survivor 里, 不要进入老年代, 这样在 Minor GC 的时候这些对象都会被回收, 不会进到老年代从而导致 Full GC")]),t._v(".")]),t._v(" "),a("p",[t._v("对于对象年龄应该为多少才移动到老年代比较合适, 本例中一次 Minor GC 要间隔二三十秒, "),a("strong",[t._v("大多数对象一般在几秒内就会变为垃圾")]),t._v(", 完全可以将默认的 15 岁改小一点, 比如改为 5, 那么意味着对象要经过 "),a("strong",[t._v("5 次 Minor GC")]),t._v(" 才会进入老年代, 整个时间也有一两分钟了, 如果对象这么"),a("strong",[t._v("长时间都没被回收")]),t._v(", 完全可以认为这些对象是会存活的比较长的对象, 可以移动到老年代, 而不是继续一直占用 survivor 区空间.")]),t._v(" "),a("p",[t._v("对于多大的对象直接进入老年代(参数 -XX:PretenureSizeThreshold), 这个一般可以结合业务场景看下有没有什么大对象生成, 预估下大对象的大小, 一般来说设置为 "),a("strong",[t._v("1M")]),t._v(" 就差不多了, 很少有超过 1M 的大对象, 这些对象一般就是系统中初始化分配的缓存对象, 比如"),a("strong",[t._v("大的缓存")]),t._v(" List, Map 之类的对象.")]),t._v(" "),a("p",[t._v("可以再次适当调整 JVM 参数如下:")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xms3072M")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xmx3072M")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xmn2048M")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xss1M")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PermSize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("256")]),t._v("M "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxPermSize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("256")]),t._v("M  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SurvivorRatio")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxTenuringThreshold")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PretenureSizeThreshold")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("M "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UseParNewGC")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UseConcMarkSweepGC")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("对于"),a("strong",[t._v("老年代 CMS 的参数")]),t._v("如何设置可以思考下, 首先想下当前这个系统有"),a("strong",[t._v("哪些对象")]),t._v("可能会长期存活躲过 5 次以上  Minor GC 最终进入老年代. "),a("strong",[t._v("无非就是那些 Spring 容器里的 Bean, 线程池对象, 一些初始化缓存数据对象等, 这些加起来充其量也就几十 MB")]),t._v(".")]),t._v(" "),a("p",[t._v("还有就是某次 Minor GC 完了之后还有超过 200M 的对象存活, 那么就会直接"),a("strong",[t._v("进入老年代")]),t._v(", 比如"),a("strong",[t._v("突然某一秒瞬间要处理五六百单, 那么每秒生成的对象可能有一百多 M, 再加上整个系统可能压力剧增, 一个订单要好几秒才能处理完, 下一秒可能又有很多订单过来.")])]),t._v(" "),a("p",[t._v("可以估算下大概每隔"),a("strong",[t._v("五六分钟")]),t._v("出现一次这样的情况, 那么大概"),a("strong",[t._v("半小时到一小时")]),t._v("之间就可能因为老年代满了触发一次 Full GC, Full GC 的触发条件还有之前说过的"),a("strong",[t._v("老年代空间分配担保机制")]),t._v(", 历次的 Minor GC 挪动到老年代的对象大小肯定是非常小的, 所以几乎"),a("strong",[t._v("不会")]),t._v("在 Minor GC 触发之前由于老年代空间分配担保失败而产生 Full GC, 其实在半小时后发生 Full GC, 这时候已经过了抢购的最高峰期, 后续可能几小时才做一次 Full GC. 对于碎片整理, 因为都是 1 小时或几小时才做一次 Full GC, 是可以每做"),a("strong",[t._v("完一次就开始碎片整理")]),t._v(", 或者两到三次之后再做一次也行.")]),t._v(" "),a("p",[t._v("综上只要"),a("strong",[t._v("年轻代")]),t._v("参数设置合理, 老年代 CMS 的参数设置"),a("strong",[t._v("基本都可以用默认值")]),t._v(", 如下所示:")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xms3072M")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xmx3072M")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xmn2048M")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xss1M")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PermSize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("256")]),t._v("M "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxPermSize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("256")]),t._v("M  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SurvivorRatio")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxTenuringThreshold")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PretenureSizeThreshold")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("M "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UseParNewGC")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UseConcMarkSweepGC")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CMSInitiatingOccupancyFaction")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("92")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UseCMSCompactAtFullCollection")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CMSFullGCsBeforeCompaction")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("总结一下, 具体场景具体分析, 核心思想就是: 让"),a("strong",[t._v("长久存活的对象早到老年代")]),t._v(", "),a("strong",[t._v("尽量别让短生命周期的对象跑到老年代去")]),t._v(", 让它们在新生代就被处理掉.")]),t._v(" "),a("p",[t._v("‍")]),t._v(" "),a("h4",{attrs:{id:"jvm参数总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm参数总结"}},[t._v("#")]),t._v(" JVM参数总结")]),t._v(" "),a("h5",{attrs:{id:"_1-内存分配参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-内存分配参数"}},[t._v("#")]),t._v(" 1.内存分配参数")]),t._v(" "),a("h6",{attrs:{id:"_1-堆内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-堆内存"}},[t._v("#")]),t._v(" (1)堆内存")]),t._v(" "),a("p",[t._v("与性能有关的最常见实践之一是根据应用程序要求"),a("strong",[t._v("初始化堆内存")]),t._v(". 以下参数指定"),a("strong",[t._v("最小和最大堆")]),t._v("大小, 推荐显式指定堆大小:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Xms: 堆区初始值")]),t._v(".")]),t._v(" "),a("li",[a("strong",[t._v("Xmx: 堆区最大值")]),t._v(".")])]),t._v(" "),a("p",[t._v("示例:")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xms2G")]),t._v(" 或 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InitialHeapSize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2048")]),t._v("m \t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 最小堆内存2G")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xmx2G")]),t._v(" 或 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxHeapSize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2048")]),t._v("m         "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 最大堆内存2G")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("h6",{attrs:{id:"_2-栈内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-栈内存"}},[t._v("#")]),t._v(" (2)栈内存")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Xss: 线程栈最大值")]),t._v(".")])]),t._v(" "),a("p",[t._v("示例:")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xss256k")]),t._v(" 或 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ThreadStackSize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("256")]),t._v("k\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("栈的大小直接决定函数调用的可达深度. JDK5 以后每个线程堆栈大小为 "),a("strong",[t._v("1M")]),t._v(". 应该根据应用的线程所需内存大小进行调整. 在相同物理内存下, 减小这个值能生成更多的线程. 但是操作系统对一个进程内的线程数还是有限制的, 不能无限生成, 经验值在 3000~5000 左右.")]),t._v(" "),a("h6",{attrs:{id:"_3-年轻代内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-年轻代内存"}},[t._v("#")]),t._v(" (3)年轻代内存")]),t._v(" "),a("p",[t._v("根据 Oracle 官方文档, 在堆总可用内存配置完成之后, 第二大影响因素是"),a("strong",[t._v("年轻代")]),t._v("在堆内存所占的"),a("strong",[t._v("比例")]),t._v(". 默认情况下, 年轻代的最小大小为 "),a("strong",[t._v("1310 MB")]),t._v(", 最大大小为无限制.")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("-XX:NewSize: 年轻代最小内存.")])]),t._v(" "),a("li",[a("strong",[t._v("-XX:MaxNewSize: 年轻代最大内存.")])]),t._v(" "),a("li",[a("strong",[t._v("-Xmn: 年轻代最大内存.")])])]),t._v(" "),a("p",[t._v("示例:")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NewSize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("256")]),t._v("m\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xmn512m")]),t._v(" 或 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxNewSize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("512")]),t._v("m\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("ul",[a("li",[a("strong",[t._v("-XX:NewRatio: 设置新生代和老年代内存的比值.")])])]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置新生代(包括 Eden 和两个 Survivor 区)与老年代的比值为 1. 也就是说: 新生代与老年代所占比值为 1:1, 新生代占整个堆栈的 1/2")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NewRatio")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("  \n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("h6",{attrs:{id:"_4-方法区内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-方法区内存"}},[t._v("#")]),t._v(" (4)方法区内存")]),t._v(" "),a("p",[t._v("JDK8 的时候, 永久代被"),a("strong",[t._v("彻底移除")]),t._v("了, 取而代之是元空间, "),a("strong",[t._v("元空间使用的是直接内存")]),t._v(". 如果没有指定 "),a("strong",[t._v("Metaspace")]),t._v(" 的大小, 随着更多类的创建, 虚拟机会耗尽所有可用的"),a("strong",[t._v("系统内存")]),t._v(".")]),t._v(" "),a("p",[t._v("与元空间的相关参数如下:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("MetaspaceSize: 元数据区初始大小.")]),t._v("  指定元空间触发 Full GC 的初始阈值(元空间无固定初始大小), 以字节为单位, 默认是 21M 左右, 达到该值就会触发 Full GC 进行类型卸载, 同时收集器会对该值进行调整: 如果释放了大量的空间, 就适当降低该值; 如果释放了很少的空间, 那么在不超过 -XX: MaxMetaspaceSize(如果设置了的话)的情况下, 适当提高该值.")]),t._v(" "),a("li",[a("strong",[t._v("MaxMetaspaceSize: 元数据区最大值. 默认是 -1, 即不限制, 但受限于本地内存大小.")])]),t._v(" "),a("li",[a("strong",[t._v("MaxDirectMemorySize: 最大直接内存(堆外)大小.")])])]),t._v(" "),a("p",[t._v("示例:")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MetaspaceSize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("128")]),t._v("m\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxMetaspaceSize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("256")]),t._v("m\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxDirectMemorySize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("256")]),t._v("m\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("由于调整元空间大小需要进行 Full GC, 这是非常昂贵的操作, 如果应用在启动的时候发生大量 Full GC, 通常都是由于永久代或元空间发生了大小调整, 基于这种情况, 一般建议在 JVM 参数中将 MetaspaceSize 和 MaxMetaspaceSize 设置成一样的值, 并设置得比初始值要大. 比如对于 8G 物理内存的机器, 可以将这两个值都设置为 256M.")]),t._v(" "),a("h5",{attrs:{id:"_2-行为参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-行为参数"}},[t._v("#")]),t._v(" 2.行为参数")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("参数及其默认值")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:-DisableExplicitGC")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("禁止调用 System.gc(); 但 JVM 的 GC 仍然有效")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:+MaxFDLimit")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("最大化文件描述符的数量限制")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:+ScavengeBeforeFullGC")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("新生代 GC 优先于 Full GC 执行")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:+UseGCOverheadLimit")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("在抛出 OOM 之前限制 JVM 耗费在 GC 上的时间比例")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:-UseConcMarkSweepGC")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("对老生代采用并发标记交换算法进行 GC")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:-UseParallelGC")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("启用并行 GC, 收集新生代空间")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:-UseParallelOldGC")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("对 Full GC 启用并行, 当 -XX:-UseParallelGC 启用时该项自动启用")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:-UseSerialGC")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("启用串行 GC")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:+UseThreadPriorities")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("启用本地线程优先级")])])])]),t._v(" "),a("h5",{attrs:{id:"_3-性能调优参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-性能调优参数"}},[t._v("#")]),t._v(" 3.性能调优参数")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("参数及其默认值")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:LargePageSizeInBytes=4m")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("设置用于 Java 堆的大页面尺寸")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:MaxHeapFreeRatio=70")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("GC 后 Java 堆中空闲量占的最大比例")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("strong",[t._v("-XX:MaxNewSize=size")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("新生成对象能占用内存的最大值")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("strong",[t._v("-XX:MaxPermSize=64m")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("老生代对象能占用内存的最大值")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:MinHeapFreeRatio=40")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("GC后java堆中空闲量占的最小比例")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:NewRatio=2")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("新生代内存容量与老生代内存容量的比例")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("strong",[t._v("-XX:NewSize=2.125m")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("新生代对象生成时占用内存的默认值")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:ReservedCodeCacheSize=32m")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("保留代码占用的内存容量")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:ThreadStackSize=512")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("设置线程栈大小, 若为 0 则使用系统默认值")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:+UseLargePages")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("使用大页面内存")])])])]),t._v(" "),a("p",[t._v("在日常性能调优中基本上都会用到以上黑体的这几个属性.")]),t._v(" "),a("h5",{attrs:{id:"_4-调试参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-调试参数"}},[t._v("#")]),t._v(" 4.调试参数")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("参数及其默认值")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:-CITime")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("打印消耗在JIT编译的时间")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:ErrorFile=./hs_err_pid.log")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("保存错误日志或者数据到文件中")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("strong",[t._v("-XX:HeapDumpPath=./java_pid<pid>.hprof")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[a("strong",[t._v("指定导出堆转储信息时的路径或文件名")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("strong",[t._v("-XX:-HeapDumpOnOutOfMemoryError")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[a("strong",[t._v("当首次遭遇OOM时导出此时堆中相关信息")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("出现致命ERROR之后运行自定义命令")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v('-XX:OnOutOfMemoryError="(cmd args); (cmd args)"')]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("当首次遭遇OOM时执行自定义命令")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("strong",[t._v("-XX:-PrintConcurrentLocks")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[a("strong",[t._v("遇到Ctrl-Break后打印并发锁的相关信息, 与jstack -l功能相同")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:-PrintCommandLineFlags")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("打印在命令行中出现过的标记")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:-PrintCompilation")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("当一个方法被编译时打印相关信息")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:-PrintGC")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("每次GC时打印相关信息")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:-PrintGC Details")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("每次GC时打印详细信息")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:-PrintGCTimeStamps")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("打印每次GC的时间戳")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:-TraceClassLoading")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("跟踪类的加载信息")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:-TraceClassLoadingPreorder")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("跟踪被引用到的所有类的加载信息")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:-TraceClassResolution")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("跟踪常量池")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:-TraceClassUnloading")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("跟踪类的卸载信息")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:-TraceLoaderConstraints")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("跟踪类加载器约束的相关信息")])])])]),t._v(" "),a("h5",{attrs:{id:"_5-垃圾收集器参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-垃圾收集器参数"}},[t._v("#")]),t._v(" 5.垃圾收集器参数")]),t._v(" "),a("p",[t._v("HotSpot 虚拟机中的各种垃圾收集器到此全部介绍完毕, 在描述过程中提到了很多虚拟机非稳定的运行参数, 下表中整理了这些参数, 供读者实践时参考.")]),t._v(" "),a("blockquote",[a("p",[t._v("垃圾收集相关的常用参数")])]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/Image00050-20240302133505-csonvea.jpg",alt:""}})]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/Image00051-20240302133505-acmvdj2.jpg",alt:""}})]),t._v(" "),a("h4",{attrs:{id:"本章小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本章小结"}},[t._v("#")]),t._v(" 本章小结")]),t._v(" "),a("p",[t._v("Java 虚拟机的内存管理与垃圾收集是虚拟机结构体系中最重要的组成部分, 对程序的性能和稳定有着非常大的影响. 在本书的第 2～5 章里, 笔者从理论知识, 异常现象, 代码, 工具, 案例, 实战等几个方面对其进行讲解, 希望读者能有所收获.")]),t._v(" "),a("p",[t._v("本书关于虚拟机内存管理部分到此就结束了, 下一章将开始学习 Class 文件与虚拟机执行子系统方面的知识.")]),t._v(" "),a("p",[t._v("‍")]),t._v(" "),a("p",[t._v("‍")]),t._v(" "),a("h4",{attrs:{id:"参考资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.jianshu.com/p/832fc4d4cb53",target:"_blank",rel:"noopener noreferrer"}},[t._v("CMS GC 默认新生代是多大? "),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.cnblogs.com/hongdada/p/10277782.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("CMS GC启动参数优化配置"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://tech.meituan.com/2017/12/29/jvm-optimize.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("从实际案例聊聊Java应用的GC优化-美团技术团队"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.choupangxia.com/2019/11/11/interview-jvm-gc-08/",target:"_blank",rel:"noopener noreferrer"}},[t._v("JVM性能调优详解"),a("OutboundLink")],1),t._v(" (2019-11-11)")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://segmentfault.com/a/1190000010603813",target:"_blank",rel:"noopener noreferrer"}},[t._v("JVM参数使用手册"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://tech.meituan.com/jvm_optimize.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("美团技术: 从实际案例聊聊Java应用的GC优化"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.cn/post/6844904048013869064#heading-28",target:"_blank",rel:"noopener noreferrer"}},[t._v("大白话带你认识JVM"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=r.exports}}]);