(window.webpackJsonp=window.webpackJsonp||[]).push([[157],{467:function(t,s,_){"use strict";_.r(s);var v=_(7),r=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_31-redis持久化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_31-redis持久化"}},[t._v("#")]),t._v(" 31.Redis持久化")]),t._v(" "),s("h4",{attrs:{id:"持久化基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#持久化基础"}},[t._v("#")]),t._v(" 持久化基础")]),t._v(" "),s("p",[t._v("Redis 持久化方式: "),s("strong",[t._v("RDB, AOF, 混合持久化")]),t._v(".")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200425182633664.png",alt:"image-20200425182633664"}})]),t._v(" "),s("ol",[s("li",[t._v("客户端向数据库"),s("strong",[t._v("发送写命令")]),t._v(".")]),t._v(" "),s("li",[t._v("数据库"),s("strong",[t._v("接收")]),t._v("到客户端"),s("strong",[t._v("写请求")]),t._v(".")]),t._v(" "),s("li",[t._v("数据库"),s("strong",[t._v("调用系统 API")]),t._v("将数据写入磁盘(数据在内核缓冲区中).")]),t._v(" "),s("li",[t._v("操作系统将"),s("strong",[t._v("写缓冲区")]),t._v("传输到"),s("strong",[t._v("磁盘控控制器")]),t._v("(数据在磁盘缓存中).")]),t._v(" "),s("li",[t._v("操作系统的磁盘控制器将数据写入实际的物理媒介中(数据在磁盘中).")])]),t._v(" "),s("p",[s("strong",[t._v("注意")]),t._v(": 上面的过程其实是 "),s("strong",[t._v("极度精简")]),t._v(" 的, 在实际的操作系统中, "),s("strong",[t._v("缓存")]),t._v("和"),s("strong",[t._v("缓冲区")]),t._v("会比这多得多.")]),t._v(" "),s("h4",{attrs:{id:"rdb持久化🌟"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rdb持久化🌟"}},[t._v("#")]),t._v(" RDB持久化🌟")]),t._v(" "),s("p",[t._v("RDB 持久化是把当前进程的"),s("strong",[t._v("全部数据生成快照")]),t._v("保存到硬盘的过程. 在默认情况下, Redis 将内存数据库快照保存在名字为 dump.rdb 的二进制文件中.")]),t._v(" "),s("h5",{attrs:{id:"_1-触发机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-触发机制"}},[t._v("#")]),t._v(" 1.触发机制")]),t._v(" "),s("p",[t._v("触发 RDB 持久化过程分为"),s("strong",[t._v("手动触发")]),t._v("和"),s("strong",[t._v("自动触发")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_1-手动触发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-手动触发"}},[t._v("#")]),t._v(" (1)手动触发")]),t._v(" "),s("p",[s("strong",[t._v("手动触发")]),t._v("使用 "),s("strong",[t._v("bgsave")]),t._v(" 命令. Redis 进程执行 "),s("strong",[t._v("fork")]),t._v(" 操作创建"),s("strong",[t._v("子进程")]),t._v(", RDB 持久化过程由"),s("strong",[t._v("子进程负责")]),t._v(", 完成后自动结束. "),s("strong",[t._v("阻塞只发生在 fork 创建子进程的阶段, 一般时间很短")]),t._v(", 生产环境可以使用. 注: bg 就是 background 后台执行的意思.")]),t._v(" "),s("p",[t._v("bgsave 是异步执行的, 不阻塞其他命令.")]),t._v(" "),s("h6",{attrs:{id:"_2-自动触发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-自动触发"}},[t._v("#")]),t._v(" (2)自动触发")]),t._v(" "),s("p",[t._v("自动触发的场景如下:")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("save m n")]),t._v(" 表示如果在 m 秒内数据集存在 n 次修改时, "),s("strong",[t._v("自动触发 bgsave")]),t._v('. 比如 save 60 1000 表示 Redis 在满足 "60 秒内有至少有 1000 个键被改动" 这一条件时, 自动保存一次数据集. 配置自动生成 rdb 文件后台使用的是 bgsave 方式.')]),t._v(" "),s("li",[t._v("如果从节点执行"),s("strong",[t._v("全量复制")]),t._v("操作, 主节点自动执行 bgsave 生成 RDB 文件并发送给从节点.")]),t._v(" "),s("li",[t._v("执行 debug reload 命令重新加载 Redis 时, 也会自动触发 save 操作.")]),t._v(" "),s("li",[t._v("默认情况下执行 shutdown 命令时, 如果没有开启 AOF, 则自动执行 bgsave.")])]),t._v(" "),s("h5",{attrs:{id:"_2-工作流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-工作流程"}},[t._v("#")]),t._v(" 2.工作流程")]),t._v(" "),s("h6",{attrs:{id:"_1-bgsave流程与写时复制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-bgsave流程与写时复制"}},[t._v("#")]),t._v(" (1)bgsave流程与写时复制")]),t._v(" "),s("p",[t._v("Redis 借助操作系统提供的"),s("strong",[t._v("写时复制技术")]),t._v("(Copy-On-Write, COW), 在生成快照的同时, 依然可以正常处理写命令. 简单来说, "),s("strong",[t._v("bgsave 子进程是由主线程 fork 生成的, 可以共享主线程的所有内存数据")]),t._v(". bgsave 子进程运行后, 开始读取主线程的内存数据, 并把它们写入 RDB 文件. 此时, 如果主线程对这些数据也都是读操作, 那么主线程和 bgsave 子进程相互不影响. 但如果主线程要修改一块数据, 那这块数据就会被复制一份, 生成该数据的副本. 然后 bgsave 子进程会把这个副本数据写入 RDB 文件, 而在这个过程中, 主线程仍然可以直接修改原来的数据.")]),t._v(" "),s("p",[s("strong",[t._v("bgsave")]),t._v(" 是主流的触发 RDB 持久化的方式, 流程如下.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522212958905.png",alt:""}})]),t._v(" "),s("p",[t._v("(1) Redis 父进程首先判断: 当前"),s("strong",[t._v("是否正在执行")]),t._v(" save 或 bgsave/bgrewriteaof 的子进程, 如果在执行则 bgsave 命令"),s("strong",[t._v("直接返回")]),t._v(". bgsave/bgrewriteaof 的子进程"),s("strong",[t._v("不能同时执行")]),t._v(", 主要是基于性能方面的考虑: 两个并发的子进程同时执行大量的磁盘写操作, 可能引起严重的性能问题.")]),t._v(" "),s("p",[t._v("(2) 父进程执行 "),s("strong",[t._v("fork")]),t._v(" 操作"),s("strong",[t._v("创建子进程")]),t._v(", 这个过程中"),s("strong",[t._v("父进程是阻塞")]),t._v("的, Redis 不能执行来自客户端的任何命令, 但这个阻塞时间"),s("strong",[t._v("很短")]),t._v(".")]),t._v(" "),s("p",[t._v("(3) 父进程 fork 创建完子进程后, "),s("strong",[t._v("bgsave 命令")]),t._v('返回 "Background saving started" 信息并'),s("strong",[t._v("不再阻塞")]),t._v("父进程, 并可以响应其他命令.")]),t._v(" "),s("p",[t._v("(4) 子进程"),s("strong",[t._v("创建 RDB")]),t._v(" 文件, 根据"),s("strong",[t._v("父进程内存快照生成临时快照文件")]),t._v(", 完成后对"),s("strong",[t._v("原有文件")]),t._v("进行"),s("strong",[t._v("原子替换")]),t._v(".")]),t._v(" "),s("p",[t._v("(5) 子进程发送信号给父进程表示完成, 父进程"),s("strong",[t._v("更新统计信息")]),t._v(".")]),t._v(" "),s("h6",{attrs:{id:"_2-写时复制机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-写时复制机制"}},[t._v("#")]),t._v(" (2)写时复制机制")]),t._v(" "),s("p",[t._v('RBD 也叫 "'),s("strong",[t._v("快照")]),t._v('" 持久化. 操作系统多进程写时复制 '),s("strong",[t._v("COW(Copy On Write) 机制")]),t._v(" 十分重要. "),s("strong",[t._v("Redis")]),t._v(" 在持久化时会调用函数 "),s("strong",[t._v("fork()")]),t._v("  产生一个"),s("strong",[t._v("子进程")]),t._v(", 简单理解也就是基于当前进程"),s("strong",[t._v("复制")]),t._v("了一个进程, 主进程和子进程会"),s("strong",[t._v("共享")]),t._v("内存里面的代码块和数据段:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200425182803920.png",alt:"image-20200425182803920"}})]),t._v(" "),s("p",[t._v("所以"),s("strong",[t._v("快照持久化")]),t._v("可以完全交给"),s("strong",[t._v("子进程")]),t._v("来处理, "),s("strong",[t._v("父进程")]),t._v("则继续"),s("strong",[t._v("处理客户端请求")]),t._v(". "),s("strong",[t._v("子进程")]),t._v("做数据持久化, 它"),s("strong",[t._v("不会修改现有的内存数据结构")]),t._v(", 它只是对数据结构进行"),s("strong",[t._v("遍历读取")]),t._v(", 然后序列化写到磁盘中. 但"),s("strong",[t._v("父进程")]),t._v("不一样, 它必须持续服务客户端请求, 然后对"),s("strong",[t._v("内存数据结构进行不间断的修改")]),t._v(".")]),t._v(" "),s("p",[t._v("这时候就会使用操作系统的 "),s("strong",[t._v("Copy On Write 机制")]),t._v("来进行"),s("strong",[t._v("数据段页面")]),t._v("的"),s("strong",[t._v("分离")]),t._v(". 数据段是由很多操作系统的页面组合而成, 当父进程对其中一个页面的数据进行"),s("strong",[t._v("修改")]),t._v("时, 会将"),s("strong",[t._v("被共享的页面复制一份分离")]),t._v("出来, 然后"),s("strong",[t._v("对这个复制的页面进行修改")]),t._v(". 这时"),s("strong",[t._v("子进程")]),t._v("相应的页面是"),s("strong",[t._v("没有变化的")]),t._v(", 还是进程产生时"),s("strong",[t._v("那一瞬间")]),t._v("的数据.")]),t._v(" "),s("p",[t._v("子进程因为数据没有变化, 它能看到的"),s("strong",[t._v("内存里的数据在进程产生的一瞬间就凝固")]),t._v("了, 再也不会改变, 这也是为什么 "),s("strong",[t._v("Redis")]),t._v(" 的持久化"),s("strong",[t._v("叫「快照」的原因")]),t._v("!! 接下来子进程就可以非常安心的遍历数据了进行序列化写磁盘了.")]),t._v(" "),s("h5",{attrs:{id:"_3-rdb文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-rdb文件"}},[t._v("#")]),t._v(" 3.RDB文件")]),t._v(" "),s("p",[t._v("RDB 文件是经过"),s("strong",[t._v("压缩的二进制文件")]),t._v(", Redis 默认采用 "),s("strong",[t._v("LZF 算法")]),t._v("对生成的 RDB 文件做"),s("strong",[t._v("压缩处理")]),t._v(", 压缩后的文件"),s("strong",[t._v("远远小于")]),t._v("内存大小. RDB 文件保存在 dir 配置指定的目录下, 文件名通过 dbfilename 配置.")]),t._v(" "),s("h5",{attrs:{id:"_4-rdb优缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-rdb优缺点"}},[t._v("#")]),t._v(" 4.RDB优缺点")]),t._v(" "),s("p",[s("strong",[t._v("(1)优点")])]),t._v(" "),s("p",[t._v("RDB 文件是紧凑压缩的二进制文件, 消耗"),s("strong",[t._v("空间少")]),t._v(". RDB 文件代表某个时间点上的"),s("strong",[t._v("数据快照")]),t._v(", 所以非常适合于"),s("strong",[t._v("备份, 全量复制")]),t._v("等场景. Redis "),s("strong",[t._v("加载 RDB 文件恢复数据的速度远远快于")]),t._v(" AOF 方式.")]),t._v(" "),s("p",[s("strong",[t._v("(2)缺点")])]),t._v(" "),s("p",[t._v("RDB 持久化的是内存快照, 数据量较大, 所以 RDB 属于"),s("strong",[t._v("重量级操作")]),t._v(", 不能频繁执行, 因此"),s("mark",[s("strong",[t._v("无法做到实时持久化, 秒级持久化")])]),t._v(". 一般用于"),s("strong",[t._v("数据冷备和复制传输")]),t._v(". RDB 是用特定的二进制格式存储, 会出现多版本的格式, 导致新老版本不兼容.")]),t._v(" "),s("h4",{attrs:{id:"aof持久化🌟"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof持久化🌟"}},[t._v("#")]),t._v(" AOF持久化🌟")]),t._v(" "),s("p",[t._v("由于 RDB 不适合实时持久化, 所以 Redis 提供了 AOF 持久化方式. "),s("strong",[t._v("AOF(Append Only File) 持久化")]),t._v(", 是"),s("mark",[s("strong",[t._v("将 Redis 执行的每次写命令记录到单独的日志文件(appendonly.aof)中, 先写入 os cache, 每隔一段时间 fsync 到磁盘, 当 Redis 重启时再次执行 AOF 文件中的命令来恢复数据")])]),t._v(". 与 RDB 相比, AOF 的"),s("strong",[t._v("实时性更好")]),t._v(", 因此已成为主流的持久化方案.")]),t._v(" "),s("h5",{attrs:{id:"_1-配置方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-配置方式"}},[t._v("#")]),t._v(" 1.配置方式")]),t._v(" "),s("p",[t._v("配置文件配置开启 AOF: "),s("strong",[t._v("appendonly yes")]),t._v(".")]),t._v(" "),s("p",[t._v("文件名配置: "),s("strong",[t._v("appendfilename")]),t._v(". 默认 appendonly.aof.")]),t._v(" "),s("p",[t._v("保存路径: "),s("strong",[t._v("dir")]),t._v(".")]),t._v(" "),s("p",[t._v("缓冲区同步文件策略: "),s("strong",[t._v("appendfsync")]),t._v(" 参数配置.")]),t._v(" "),s("p",[t._v("开启配置后, 每当 Redis 执行一个"),s("strong",[t._v("改变数据集的命令")]),t._v("时(比如 SET), 这个命令就会被追加到 AOF 文件的末尾. 这样的话, 当 Redis 重新启动时, 程序就可以通过重新执行 AOF 文件中的命令来达到"),s("strong",[t._v("重建数据集")]),t._v("的目的.")]),t._v(" "),s("h5",{attrs:{id:"_2-aof文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-aof文件"}},[t._v("#")]),t._v(" 2.AOF文件")]),t._v(" "),s("p",[t._v('配置使用 AOF 后, 执行命令 "set nano 666", 则 aof 文件里会记录如下数据.')]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n$"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\nset\n$"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("\nnano\n$"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("666")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("p",[t._v("这是一种 "),s("strong",[t._v("resp 协议格式数据")]),t._v(", 星号后面的数字代表命令有多少个参数, $ 号后面的数字代表这个参数有几个字符. 注意, 如果执行带过期时间的 set 命令, aof 文件里记录的是并不是执行的原始命令, 而是记录 key 过期的时间戳.")]),t._v(" "),s("p",[t._v('比如执行 "set nano 888 ex 1000", 对应 aof 文件里记录如下.')]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n$"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\nset\n$"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),t._v("\nnano\n$"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("888")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n$"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("PEXPIREAT")]),t._v("\n$"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),t._v("\nnano\n$"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("13")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1604249786301")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br")])]),s("h5",{attrs:{id:"_3-工作流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-工作流程"}},[t._v("#")]),t._v(" 3.工作流程")]),t._v(" "),s("p",[t._v("AOF 工作流程如下: 命令写入, 文件同步, 文件重写, 重启加载.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522213407811.png",alt:""}})]),t._v(" "),s("h6",{attrs:{id:"_1-命令写入缓冲区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-命令写入缓冲区"}},[t._v("#")]),t._v(" (1)命令写入缓冲区")]),t._v(" "),s("p",[t._v("命令都是"),s("strong",[t._v("文本协议格式")]),t._v("写入 AOF 文件的, 这样可以提高兼容性同时避免二次处理的开销, 且"),s("strong",[t._v("可读性")]),t._v("更好.")]),t._v(" "),s("p",[t._v("如果每条指令都直接写入硬盘, 那开销太大了, 当对 AOF 日志文件进行写操作时, "),s("strong",[t._v("所有写命令都是先追加到 aod_buf(缓冲区)中, 之后内核会根据一定的同步策略将缓冲区的命令刷到磁盘中")]),t._v(". Redis 可以提供多种缓冲区同步策略, 如下.")]),t._v(" "),s("h6",{attrs:{id:"_2-缓存区同步刷盘策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-缓存区同步刷盘策略"}},[t._v("#")]),t._v(" (2)缓存区同步刷盘策略")]),t._v(" "),s("p",[t._v("有多种 AOF 缓冲区"),s("strong",[t._v("同步文件的策略")]),t._v(", 也就是配置 Redis 多久才将数据 fsync 到磁盘一次, 由 "),s("strong",[t._v("appendfsync")]),t._v(" 参数配置, 可配置值如下.")]),t._v(" "),s("p",[t._v("推荐(并且也是默认)的措施为 "),s("mark",[s("strong",[t._v("everysec")])]),t._v(", 这种策略可以兼顾速度和安全性.")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("同步策略可配置值")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("说明")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("always")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("命令写入 "),s("strong",[t._v("aof_buf")]),t._v(" 后"),s("strong",[t._v("立即调用系统")]),t._v(" "),s("strong",[t._v("fsync 操作")]),t._v("同步到 AOF 文件, fsync 完成后线程返回. 这样"),s("strong",[t._v("每次有写命令都要同步")]),t._v("到 AOF 文件, 硬盘 IO 成为性能瓶颈, 此时只能支持大约"),s("strong",[t._v("几百")]),t._v(" TPS 写入, 别用!!!")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("no")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("命令写入 "),s("strong",[t._v("aof_buf")]),t._v(" 后调用系统 "),s("strong",[t._v("write 操作")]),t._v(", 不对 AOF 文件做 "),s("strong",[t._v("fsync 同步")]),t._v("; 同步"),s("strong",[t._v("由操作系统负责")]),t._v(", 通常同步周期为 "),s("strong",[t._v("30 秒")]),t._v(". 文件同步的时间"),s("strong",[t._v("不可控")]),t._v(", 且缓冲区中堆积的数据会很多, 数据安全性"),s("strong",[t._v("无法保证")]),t._v(".")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("mark",[s("strong",[t._v("everysec")])])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("命令写入 "),s("strong",[t._v("aof_buf")]),t._v(" 后调用系统 "),s("strong",[t._v("write 操作")]),t._v(", write 完成后线程"),s("strong",[t._v("返回")]),t._v("; "),s("strong",[t._v("fsync 同步文件")]),t._v("操作由"),s("strong",[t._v("专门的线程每秒调用一次")]),t._v(". 它是前述两种策略的折中, 是性能和数据安全性的平衡, 因此是 Redis 的"),s("strong",[t._v("默认推荐配置")]),t._v(". 理论上来说系统宕机丢失的数据也在 "),s("strong",[t._v("2 秒")]),t._v("之内(不是 1 秒).")])])])]),t._v(" "),s("blockquote",[s("p",[t._v("关于系统调用write与fsync")])]),t._v(" "),s("p",[s("strong",[t._v("write 系统调用会触发延迟写机制")]),t._v(". Linux 在内核提供页缓冲区来提高硬盘 IO 性能. write 操作在"),s("strong",[t._v("写入系统缓冲区后直接返回")]),t._v(". 同步硬盘操作"),s("strong",[t._v("依赖于系统调度机制")]),t._v(". 同步文件之前, 如果系统宕机, 那么缓冲区内的数据就会丢失.")]),t._v(" "),s("p",[s("strong",[t._v("fsync 系统调用")]),t._v("针对单个文件操作(比如 AOF 文件), 将"),s("strong",[t._v("阻塞")]),t._v("直到数据写入硬盘后返回, 做"),s("strong",[t._v("强制硬盘同步")]),t._v(", 保证数据持久化, 但是开销更大.")]),t._v(" "),s("h6",{attrs:{id:"_3-aof文件重写"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-aof文件重写"}},[t._v("#")]),t._v(" (3)AOF文件重写")]),t._v(" "),s("p",[t._v("Redis 服务器执行的"),s("strong",[t._v("写命令")]),t._v("随时间越来越多, AOF 文件也会"),s("strong",[t._v("越来越大, 并且很多命令可能是没用的")]),t._v("; 过大的 AOF 文件不仅会影响服务器的正常运行, 也会导致数据恢复需要的时间过长. "),s("strong",[t._v("所以 AOF 会定期根据内存的最新数据生成新的 AOF 文件")]),t._v(".")]),t._v(" "),s("p",[t._v("比如执行了如下几条命令:")]),t._v(" "),s("div",{staticClass:"language-sh line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("127.0")]),t._v(".0.1:637"),s("span",{pre:!0,attrs:{class:"token operator"}},[s("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[t._v("9")]),t._v(">")]),t._v(" incr readcount\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("integer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("127.0")]),t._v(".0.1:637"),s("span",{pre:!0,attrs:{class:"token operator"}},[s("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[t._v("9")]),t._v(">")]),t._v(" incr readcount\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("integer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("127.0")]),t._v(".0.1:637"),s("span",{pre:!0,attrs:{class:"token operator"}},[s("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[t._v("9")]),t._v(">")]),t._v(" incr readcount\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("integer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("127.0")]),t._v(".0.1:637"),s("span",{pre:!0,attrs:{class:"token operator"}},[s("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[t._v("9")]),t._v(">")]),t._v(" incr readcount\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("integer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("127.0")]),t._v(".0.1:637"),s("span",{pre:!0,attrs:{class:"token operator"}},[s("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[t._v("9")]),t._v(">")]),t._v(" incr readcount\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("integer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("p",[t._v("这里 AOF 会记录五次变更命令, 对其进行重写(可以手动执行 bgrewriteaof 命令)后 AOF 文件里变成:")]),t._v(" "),s("div",{staticClass:"language-sh line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[t._v("*3\n"),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$3")]),t._v("\nSET\n"),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$2")]),t._v("\nreadcount\n"),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$1")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("p",[t._v("也就是直接将 readcount 设置为 5.")]),t._v(" "),s("blockquote",[s("p",[t._v("AOF持久化方式为什么要文件重写?")])]),t._v(" "),s("p",[s("strong",[t._v("AOF 重写")]),t._v("是指"),s("strong",[t._v("定期重写 AOF 文件")]),t._v(", "),s("strong",[t._v("减小了 AOF 文件的体积")]),t._v(". 由于重写后 AOF 执行的命令减少了, 文件重写既可以减少文件占用的空间, 也可以"),s("strong",[t._v("加快加载恢复的速度")]),t._v(".")]),t._v(" "),s("blockquote",[s("p",[t._v("文件重写为什么能压缩AOF文件?")])]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("过期")]),t._v("的数据不需要再写入文件.")]),t._v(" "),s("li",[s("strong",[t._v("无效的命令")]),t._v("不再写入文件: 如有些数据被重复设值(set mykey v1, set mykey v2), 有些数据被删除了(sadd myset v1, del myset)等.")]),t._v(" "),s("li",[t._v("多条命令可以"),s("strong",[t._v("合并为一个")]),t._v(": 如 sadd myset v1, sadd myset v2, sadd myset v3 可以合并为 sadd myset v1 v2 v3.")])]),t._v(" "),s("p",[t._v("需要注意, "),s("strong",[t._v("AOF 重写")]),t._v("是把 Redis "),s("strong",[t._v("进程内的数据转化为写命令")]),t._v(", 同步到新的 AOF 文件; "),s("strong",[t._v("不会对旧的")]),t._v(" AOF 文件进行任何读写操作!")]),t._v(" "),s("blockquote",[s("p",[t._v("AOF重写何时进行? 触发机制?")])]),t._v(" "),s("p",[s("strong",[t._v("(1)")]),t._v(" "),s("strong",[t._v("手动触发")]),t._v(": 直接调用 "),s("strong",[t._v("bgrewriteaof")]),t._v(" 命令. 该命令的执行与 bgsave 有些类似: 都是 fork 子进程进行具体的工作, 且都只有在 fork 时阻塞.")]),t._v(" "),s("p",[s("strong",[t._v("(2) 自动触发")]),t._v(": 根据 "),s("strong",[t._v("auto-aof-rewrite-min-size")]),t._v(" 和 "),s("strong",[t._v("auto-aof-rewrite-percentage")]),t._v(" 配置, 以及 aof_current_size 和 aof_base_size 状态确定触发时机.")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("auto-aof-rewrite-min-size")]),t._v(": 执行 AOF "),s("strong",[t._v("重写时")]),t._v(", 文件的"),s("strong",[t._v("最小体积")]),t._v(", 默认值为 64MB.")]),t._v(" "),s("li",[t._v("auto-aof-rewrite-percentage: 执行 AOF 重写时, "),s("strong",[t._v("当前")]),t._v(" AOF 大小(即 aof_current_size)和上一次重写时 AOF 大小(aof_base_size)的"),s("strong",[t._v("比值")]),t._v('. 比如 "auto-aof-rewrite-percentage 100" 表示 aof 文件自上一次重写后文件大小增长了 100% 则再次触发重写.')])]),t._v(" "),s("p",[t._v("只有当 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 两个参数"),s("strong",[t._v("同时满足")]),t._v("时, 才会自动触发 AOF 重写, 这样也会执行 "),s("strong",[t._v("bgrewriteaof")]),t._v(" 操作.")]),t._v(" "),s("blockquote",[s("p",[t._v("AOF重写流程")])]),t._v(" "),s("p",[t._v("AOF 重写流程也就是执行 "),s("strong",[t._v("bgrewriteaof")]),t._v(" 的流程, 如下图.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522213612372.png",alt:""}})]),t._v(" "),s("p",[t._v("(1) Redis 父进程首先判断当前是否存在"),s("strong",[t._v("正在执行")]),t._v(" bgsave/bgrewriteaof 的子进程, 如果存在则 bgrewriteaof 命令"),s("strong",[t._v("直接返回")]),t._v("; 如果存在 bgsave 命令则等 bgsave 执行完成后再执行, 这个主要是基于性能方面的考虑.")]),t._v(" "),s("p",[t._v("(2) 父进程执行 "),s("strong",[t._v("fork 操作")]),t._v("创建"),s("strong",[t._v("子进程")]),t._v(", 这个过程中"),s("strong",[t._v("父进程是阻塞")]),t._v("的, 仅这一段时间.")]),t._v(" "),s("p",[t._v("(3) 父进程 fork 后, "),s("strong",[t._v("bgrewriteaof 命令返回")]),t._v(' "Background append only file rewrite started" 信息并'),s("strong",[t._v("不再阻塞")]),t._v("父进程, 然后可以继续响应其他命令. Redis 的所有写命令"),s("strong",[t._v("依然写入 AOF 缓冲区")]),t._v(", 并根据 appendfsync 策略同步到硬盘, 保证原有 AOF 机制的正确.")]),t._v(" "),s("p",[t._v("(4) 由于 fork 操作使用"),s("mark",[s("strong",[t._v("写时复制技术")])]),t._v(", 子进程只能"),s("strong",[t._v("共享 fork 操作时")]),t._v("的内存数据. 由于父进程"),s("strong",[t._v("依然在响应命令")]),t._v(", 因此 Redis 使用 "),s("strong",[t._v("AOF 重写缓冲区")]),t._v("(图中的 aof_rewrite_buf)保存这部分数据, 防止"),s("strong",[t._v("新 AOF 文件生成期间丢失这部分数据")]),t._v(". 也就是说, bgrewriteaof 执行期间, Redis 的"),s("strong",[t._v("写命令同时追加")]),t._v("到 aof_buf 和 aof_rewirte_buf 两个缓冲区. 缓冲区专门用于保存"),s("strong",[t._v("在重写期间操作数据带来的变化")]),t._v(".")]),t._v(" "),s("p",[t._v("(5) 子进程根据"),s("strong",[t._v("内存快照")]),t._v(", 按照命令合并规则写入到"),s("strong",[t._v("新的 AOF")]),t._v(" 文件. 子进程写完新的 AOF 文件后, 向父进程发信号, 父进程更新"),s("strong",[t._v("统计信息")]),t._v(", 具体可以通过 "),s("strong",[t._v("info persistence")]),t._v(" 查看.")]),t._v(" "),s("p",[t._v("(6) 父进程把 AOF "),s("strong",[t._v("重写缓冲区(aof_rewrite_buf)")]),t._v("  的数据写入到"),s("strong",[t._v("新的")]),t._v(" AOF 文件, 这样就保证了新 AOF 文件所保存的数据库状态和服务器"),s("strong",[t._v("当前状态一致")]),t._v(".")]),t._v(" "),s("p",[t._v("(7) 使用新的 AOF 文件"),s("strong",[t._v("替换")]),t._v("老文件, 完成 AOF 重写.")]),t._v(" "),s("p",[t._v("整个过程不会对正常命令处理有太多影响.")]),t._v(" "),s("h6",{attrs:{id:"_4-重启加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-重启加载"}},[t._v("#")]),t._v(" (4)重启加载")]),t._v(" "),s("p",[t._v("当 AOF "),s("strong",[t._v("开启")]),t._v("时, Redis 启动时会"),s("strong",[t._v("优先载入 AOF 文件")]),t._v("来恢复数据; 只有当 "),s("strong",[t._v("AOF 关闭")]),t._v("时, 才会载入 "),s("strong",[t._v("RDB")]),t._v(" 文件恢复数据.")]),t._v(" "),s("p",[s("strong",[t._v("文件校验机制")]),t._v(": 如果"),s("strong",[t._v("加载损坏")]),t._v("的 AOF 文件时会"),s("strong",[t._v("拒绝启动")]),t._v(", 并打印日志.")]),t._v(" "),s("h5",{attrs:{id:"_4-rdb与aof的对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-rdb与aof的对比"}},[t._v("#")]),t._v(" 4.RDB与AOF的对比")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("命令")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("RDB")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("AOF")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("启动优先级")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("低")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("高")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("文件体积")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("小")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("大")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("strong",[t._v("恢复速度")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("快")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("慢(需要重放所有命令)")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("数据安全性")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("容易丢数据")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("根据策略决定")])])])]),t._v(" "),s("p",[t._v("生产环境可以都启用, Redis 启动时如果既有 RDB 文件又有 AOF 文件则优先选择 AOF 文件恢复数据, 因为 AOF 一般来说数据更全一点.")]),t._v(" "),s("h4",{attrs:{id:"混合持久化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#混合持久化"}},[t._v("#")]),t._v(" 混合持久化")]),t._v(" "),s("p",[t._v("重启 Redis 时, 很少使用 RDB 来恢复内存状态, 因为会丢失大量数据. 通常使用 "),s("strong",[t._v("AOF 日志重放")]),t._v(", 但是重放 AOF 日志性能相对 RDB 来说要"),s("strong",[t._v("慢很多")]),t._v(", 这样在 Redis 实例很大的情况下, 启动需要花费很长的时间.")]),t._v(" "),s("p",[s("strong",[t._v("Redis 4.0")]),t._v(" 为了解决这些问题, 新增了一个新的持久化选项: "),s("strong",[t._v("混合持久化")]),t._v(". 将 RDB 文件的内容和增量的 AOF 日志文件"),s("strong",[t._v("存在一起")]),t._v(". 这里的 AOF 日志不再是全量的日志, 而是"),s("strong",[t._v("自持久化开始到持久化结束")]),t._v("的这段时间发生的"),s("strong",[t._v("增量 AOF 日志")]),t._v(", 通常这部分 AOF 日志很小:")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/image-20240106100908-qvhzogn.png",alt:"image"}})]),t._v(" "),s("p",[t._v("于是在 Redis 重启的时候, 可以"),s("strong",[t._v("先加载 RDB 的内容, 然后再重放增量的 AOF 日志")]),t._v("就可以完全替代之前的 AOF 全量文件重放, "),s("strong",[t._v("重启效率因此大幅得到提升")]),t._v(".")]),t._v(" "),s("p",[t._v("通过如下配置可以开启混合持久化(必须先开启 AOF, 因为混合持久化本质上来说其实是 AOF 的优化):")]),t._v(" "),s("div",{staticClass:"language-yml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# aof-use-rdb-preamble yes")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("如果开启了混合持久化, AOF 在重写时, 不再是单纯将内存数据转换为 RESP 命令写入 AOF 文件, 而是将重写这一刻"),s("strong",[t._v("之前的内存做 RDB 快照处理")]),t._v(", 并且将 RDB 快照内容和增量的 AOF 修改内存数据的命令存在一起, 都写入新的 AOF 文件, 新的文件一开始不叫 appendonly.aof, 等到重写完新的 AOF 文件才会进行改名, 覆盖原有的 AOF 文件, 完成新旧两个 AOF 文件的替换.")]),t._v(" "),s("h4",{attrs:{id:"持久化的问题与优化🌟"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#持久化的问题与优化🌟"}},[t._v("#")]),t._v(" 持久化的问题与优化🌟")]),t._v(" "),s("p",[t._v("持久化阻塞主线程场景主要有: "),s("strong",[t._v("fork 阻塞和 AOF 追加阻塞")]),t._v(". "),s("strong",[t._v("fork 阻塞时间跟内存和系统有关, AOF 追加阻塞说明系统硬盘资源紧张.")])]),t._v(" "),s("h5",{attrs:{id:"_1-fork操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-fork操作"}},[t._v("#")]),t._v(" 1.fork操作")]),t._v(" "),s("p",[t._v("当 Redis 做 RDB 或 AOF 重写时, 必不可少的操作就是执行 "),s("strong",[t._v("fork 系统调用来创建子进程")]),t._v(", 但这是一个"),s("strong",[t._v("重量级操作")]),t._v(". 虽然 fork 创建的子进程不需要拷贝父进程的物理空间, 但是会"),s("strong",[t._v("复制父进程的空间内存页表")]),t._v("(页表相当于内存的索引, 目录). 所以 fork 操作耗时与"),s("strong",[t._v("进程总内存量")]),t._v("息息相关. "),s("strong",[t._v("父进程")]),t._v("的数据空间越大, 内存页表越大, fork 时复制"),s("strong",[t._v("耗时也会越多")]),t._v(".")]),t._v(" "),s("blockquote",[s("p",[t._v("如何改善fork操作的耗时?")])]),t._v(" "),s("ul",[s("li",[t._v("控制 Redis 实例"),s("strong",[t._v("最大可用内存")]),t._v(", fork 耗时与内存量成正比. 线上建议一个 Redis 实例内存控制在 10GB 之内.")]),t._v(" "),s("li",[t._v("合理配置 Linux 内存分配策略, 避免"),s("strong",[t._v("物理内存不足")]),t._v("导致 fork 失败.")]),t._v(" "),s("li",[t._v("降低 fork 操作频率, 如可用适当放宽 AOF 自动触发时机.")])]),t._v(" "),s("h5",{attrs:{id:"_2-子进程开销"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-子进程开销"}},[t._v("#")]),t._v(" 2.子进程开销")]),t._v(" "),s("p",[t._v("需要重点关注.")]),t._v(" "),s("ul",[s("li",[t._v("CPU: 尽量保证同一时刻只有一个子进程执行重写操作.")]),t._v(" "),s("li",[t._v("内存: 避免在大量写入时做子进程"),s("strong",[t._v("重写")]),t._v("操作, 这样将导致父进程维护大量页副本, 造成内存消耗.")]),t._v(" "),s("li",[t._v("硬盘: 不要和其他高硬盘负载的服务部署到一起, 如存储服务, 消息队列服务等.")])]),t._v(" "),s("h5",{attrs:{id:"_3-aof追加阻塞"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-aof追加阻塞"}},[t._v("#")]),t._v(" 3.AOF追加阻塞")]),t._v(" "),s("p",[t._v("AOF 持久化时 "),s("strong",[t._v("everysec")]),t._v(" 是常用的同步硬盘策略. Redis 使用"),s("strong",[t._v("另一条线程每秒执行 fsync 同步硬盘")]),t._v(". 当系统资源"),s("strong",[t._v("繁忙")]),t._v("时, 会造成 Redis "),s("strong",[t._v("主线程阻塞")]),t._v(".")]),t._v(" "),s("p",[t._v("注意: "),s("strong",[t._v("everysec")]),t._v(" 配置"),s("strong",[t._v("最多可能丢失 2 秒")]),t._v("内的数据, 不是 1 秒. 如果系统 fsync 缓慢, 将会导致 Redis 线程阻塞影响效率.")]),t._v(" "),s("h4",{attrs:{id:"redis数据备份策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis数据备份策略"}},[t._v("#")]),t._v(" Redis数据备份策略")]),t._v(" "),s("ol",[s("li",[t._v("写 crontab 定时调度脚本, 每小时都 copy 一份 rdb 或 aof 的备份到一个目录中去, 仅仅保留最近 48 小时的备份.")]),t._v(" "),s("li",[t._v("每天都保留一份当日的数据备份到一个目录中去, 可以保留最近 1 个月的备份.")]),t._v(" "),s("li",[t._v("每次 copy 备份的时候, 都把太旧的备份给删了.")]),t._v(" "),s("li",[t._v("每天晚上将当前机器上的备份复制一份到其他机器上, 以防机器损坏.")])]),t._v(" "),s("p",[t._v("‍")]),t._v(" "),s("p",[t._v("‍")]),t._v(" "),s("h4",{attrs:{id:"参考资料"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),s("ul",[s("li",[t._v("《Redis开发与运维》")])])])}),[],!1,null,null,null);s.default=r.exports}}]);