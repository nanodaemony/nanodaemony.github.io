(window.webpackJsonp=window.webpackJsonp||[]).push([[243],{570:function(s,a,t){"use strict";t.r(a);var n=t(4),r=Object(n.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"_2-散列表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-散列表"}},[s._v("#")]),s._v(" 2.散列表")]),s._v(" "),a("p",[s._v("散列表是根据"),a("strong",[s._v("键值(Key value)")]),s._v(" 直接进行访问的数据结构, 它通过把"),a("strong",[s._v("键值映射到表中一个位置")]),s._v("来访问记录, 以加快查找的速度. 散列表通过"),a("strong",[s._v("散列函数")]),s._v("将键映射到对应的位置.")]),s._v(" "),a("h5",{attrs:{id:"_1-散列函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-散列函数"}},[s._v("#")]),s._v(" 1.散列函数")]),s._v(" "),a("h6",{attrs:{id:"_1-定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-定义"}},[s._v("#")]),s._v(" (1)定义")]),s._v(" "),a("p",[s._v("散列表中每个"),a("strong",[s._v("键")]),s._v("被映射到从 "),a("strong",[s._v("0 到 TableSize - 1")]),s._v(" 这个范围的某个数, 并被放到合适的单元中, 这个映射关系就是"),a("strong",[s._v("散列函数")]),s._v(". 对于一个大小为 "),a("strong",[s._v("M")]),s._v(" 的散列表, 散列函数能够把任意键转换为 "),a("strong",[s._v("[0, M - 1]")]),s._v(" 内的正整数, 该正整数即为 "),a("strong",[s._v("hash")]),s._v(" 值.")]),s._v(" "),a("p",[s._v("散列函数对键进行映射时通常应该满足以下"),a("strong",[s._v("三个特性")]),s._v(":")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("一致性")]),s._v(": 相等的键应当有相等的 hash 值, 两个键相等表示调用 equals() 返回的值相等.")]),s._v(" "),a("li",[a("strong",[s._v("高效性")]),s._v(": 计算应当简便高效, 有必要的话可以把 hash 值缓存起来, 在调用 hash 函数时直接返回.")]),s._v(" "),a("li",[a("strong",[s._v("均匀性")]),s._v(": 所有键的 hash 值应当均匀地分布到 [0, M-1] 之间, 不均匀可能产生很多冲突, 从而导致散列表性能下降.")])]),s._v(" "),a("h6",{attrs:{id:"_2-常见散列函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-常见散列函数"}},[s._v("#")]),s._v(" (2)常见散列函数")]),s._v(" "),a("p",[s._v("除留余数法(取模)可以将整数散列到 [0, M-1] 之间, 例如一个正整数 k, 计算 k % M 既可得到一个 [0, M-1] 之间的 hash 值. 注意 "),a("strong",[s._v("M 最好是一个素数")]),s._v(", 否则无法利用键包含的所有信息. 例如 M 为 10"),a("sup",[s._v("k")]),s._v(", 那么只能利用键的后 k 位.")]),s._v(" "),a("p",[s._v("对于其它数值形式的键, 可以将其"),a("strong",[s._v("转换成整数")]),s._v("的形式, 然后利用除留余数法. 例如对于"),a("strong",[s._v("浮点数")]),s._v(", 可以将其的"),a("strong",[s._v("二进制形式")]),s._v("转换成整数.")]),s._v(" "),a("p",[s._v("对于"),a("strong",[s._v("多部分组合")]),s._v("的类型, 每个部分都需要计算 hash 值, 这些 hash 值都具有同等重要的地位. 为了达到这个目的, 可以将该类型看成 R 进制的整数, 每个部分都具有不同的"),a("strong",[s._v("权值")]),s._v(".")]),s._v(" "),a("p",[s._v("例如, 字符串的散列函数实现如下:")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" hash "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v(" s"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("length")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n    hash "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("R")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" hash "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" s"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("charAt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("%")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("M")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("再如拥有"),a("strong",[s._v("多个成员")]),s._v("的自定义类的哈希函数如下:")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" hash "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("day "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("R")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" month"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("%")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("M")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("R")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" year"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("%")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("M")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("R 通常取 "),a("strong",[s._v("31")]),s._v(".")]),s._v(" "),a("p",[s._v("Java 中的 "),a("strong",[s._v("hashCode")]),s._v("() 实现了哈希函数, 但是默认使用对象的"),a("strong",[s._v("内存地址值")]),s._v(". 在使用 hashCode() 时, 应当结合除留余数法来使用. 因为"),a("strong",[s._v("内存地址是 32 位整数")]),s._v(", 计算时只需要 "),a("strong",[s._v("31 位")]),s._v("的非负整数, 因此应当屏蔽符号位之后再使用除留余数法.")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" hash "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("hashCode")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x7fffffff")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("%")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("M")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("使用 Java 的 HashMap 等自带的哈希表实现时, 只需要去实现 "),a("strong",[s._v("Key 类型")]),s._v("的 hashCode() 函数即可. Java 规定 hashCode() 能够将键均匀分布于所有的 32 位整数, Java 中的 String, Integer 等对象的 hashCode() 都能实现这一点. 以下展示了"),a("strong",[s._v("自定义类型")]),s._v("如何覆写 hashCode():")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Transaction")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("private")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" who"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("private")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Date")]),s._v(" when"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("private")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("double")]),s._v(" amount"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Transaction")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" who"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Date")]),s._v(" when"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("double")]),s._v(" amount"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("who "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" who"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("when "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" when"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("amount "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" amount"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 覆写散列函数")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[s._v("@Override")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("hashCode")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" hash "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("17")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("R")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("31")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        hash "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("R")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" hash "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" who"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("hashCode")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        hash "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("R")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" hash "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" when"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("hashCode")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        hash "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("R")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" hash "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Double")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" amount"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("hashCode")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" hash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br")])]),a("h5",{attrs:{id:"_2-散列冲突"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-散列冲突"}},[s._v("#")]),s._v(" 2.散列冲突")]),s._v(" "),a("p",[s._v("当两个"),a("strong",[s._v("不同")]),s._v("的键散列到"),a("strong",[s._v("同一个值")]),s._v("的时候 (hash 值相同), 就产生了散列冲突. 解决散列冲突的简单方法有: "),a("strong",[s._v("拉链法和开放定址法")]),s._v(".")]),s._v(" "),a("h6",{attrs:{id:"_1-拉链法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-拉链法"}},[s._v("#")]),s._v(" (1)拉链法")]),s._v(" "),a("p",[s._v("拉链法使用"),a("strong",[s._v("数组 + 链表")]),s._v("来存储 hash 值相同的键, 从而解决冲突(比如 "),a("strong",[s._v("HashMap")]),s._v(" 类).")]),s._v(" "),a("p",[a("strong",[s._v("查找")]),s._v("需要分两步, 首先查找 Key 所在的"),a("strong",[s._v("链表")]),s._v(" (对应的数据槽), 然后在链表中"),a("strong",[s._v("顺序查找")]),s._v(".")]),s._v(" "),a("p",[s._v("对于 N 个键, M 条链表 (N > M), 如果哈希函数能够满足均匀性的条件, 每条链表的"),a("strong",[s._v("长度趋向于 N/M")]),s._v(", 因此未命中的查找和插入操作所需要的比较次数为 ~N/M.")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563523769927.png",alt:""}})]),s._v(" "),a("p",[s._v("这个详细可看 "),a("strong",[s._v("HashMap")]),s._v(" 的源码.")]),s._v(" "),a("h6",{attrs:{id:"_2-开放地址法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-开放地址法"}},[s._v("#")]),s._v(" (2)开放地址法")]),s._v(" "),a("p",[a("strong",[s._v("线性探测法")]),s._v("使用"),a("strong",[s._v("空位")]),s._v("来解决冲突, 当冲突发生时, "),a("strong",[s._v("向前探测一个空位")]),s._v("来存储冲突的键.")]),s._v(" "),a("p",[s._v("更常见的是, 单元 h0(x), h1(x), ....  相继被试选, 其中")]),s._v(" "),a("p",[a("strong",[a("em",[s._v("h i (x) = (hash(x) + f i (x) ) mod TableSize, 且 f(0) = 0")]),s._v(". ​")])]),s._v(" "),a("p",[a("strong",[s._v("函数 f 是解决冲突解决方法(冲突函数)")]),s._v(". 此方法中"),a("strong",[s._v("所有的数据都需要放入表")]),s._v("内, 所以"),a("strong",[s._v("需要的表比拉链法散列需要的表更大")]),s._v(". 这样的表叫做"),a("strong",[s._v("探测散列表")]),s._v(".")]),s._v(" "),a("p",[s._v("使用线性探测法, 数组的大小 M 应当"),a("strong",[s._v("大于键的个数 N")]),s._v("(M > N).")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/0dbc4f7d-05c9-4aae-8065-7b7ea7e9709e.gif",alt:""}})]),s._v(" "),a("p",[s._v("现考察三种具体的冲突解决方案. "),a("strong",[s._v("线性探测法, 平方探测法, 双散列法")]),s._v(".")]),s._v(" "),a("blockquote",[a("p",[s._v("线性探测法")])]),s._v(" "),a("p",[s._v("线性探测法中典型的情形是"),a("strong",[s._v("冲突函数 f 为一次函数")]),s._v(":")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("f(i) = i\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("这相当于相继"),a("strong",[s._v("逐个探测单元")]),s._v("(必要时可以回绕)以查找出一个"),a("strong",[s._v("空")]),s._v("单元.")]),s._v(" "),a("p",[s._v("存在的"),a("strong",[s._v("问题")]),s._v(": 有时候占据的单元会形成一些"),a("strong",[s._v("区块")]),s._v(", 其结果成为"),a("strong",[s._v("一次聚集")]),s._v(", 就是说散列到"),a("strong",[s._v("区块")]),s._v("中的任何关键字都需要"),a("strong",[s._v("多次尝试")]),s._v("才能解决冲突.")]),s._v(" "),a("p",[s._v("线性探测法的成本取决于连续条目的长度, 连续条目也叫"),a("strong",[s._v("聚簇")]),s._v(". 当聚簇很长时, 在查找和插入时也需要进行"),a("strong",[s._v("很多次探测")]),s._v(". "),a("strong",[s._v("装填因子")]),s._v("的选取很重要.")]),s._v(" "),a("p",[a("strong",[s._v("α = N/M")]),s._v(", 把 α 称为"),a("strong",[s._v("使用率")]),s._v(". 理论证明, 当 α 小于 1/2 时探测的预计次数只在 1.5 到 2.5 之间. 为了保证散列表的性能, 应当调整数组的大小, 使得 "),a("strong",[s._v("α 在 [1/4, 1/2]")]),s._v(" 之间.")]),s._v(" "),a("blockquote",[a("p",[s._v("平方探测法")])]),s._v(" "),a("p",[s._v("平方探测就是"),a("strong",[s._v("冲突函数为二次")]),s._v("的探测方法, 它是"),a("strong",[s._v("消除")]),s._v("线性探测中"),a("strong",[s._v("一次聚集")]),s._v("问题的散列冲突解决方法.")]),s._v(" "),a("p",[s._v("典型的情形是:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("f(i) = i * i\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[a("strong",[s._v("定理")]),s._v(": 如果使用"),a("strong",[s._v("平方探测")]),s._v(", 且表的大小是"),a("strong",[s._v("素数")]),s._v(", 那么当表至少有"),a("strong",[s._v("一半是空")]),s._v("的时候, "),a("strong",[s._v("总能够")]),s._v("插入一个新的元素. 即使表被填充的位置仅仅比"),a("strong",[s._v("一半多一个")]),s._v(", 那么插入都"),a("strong",[s._v("可能失败")]),s._v(".")]),s._v(" "),a("p",[s._v("但平方探测也可能产生"),a("strong",[s._v("二次聚集")]),s._v("问题.")]),s._v(" "),a("blockquote",[a("p",[s._v("双散列法")])]),s._v(" "),a("p",[s._v("双散列法冲突函数一般的选择是:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("f(i) = i * hash2(x)\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("这个公式是说将第二个散列函数应用到 x 并在距离 "),a("strong",[s._v("hash2(x)")]),s._v(", "),a("strong",[s._v("2 hash2(x)....")]),s._v(" 等处进行探测.")]),s._v(" "),a("h5",{attrs:{id:"_3-再散列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-再散列"}},[s._v("#")]),s._v(" 3.再散列")]),s._v(" "),a("p",[s._v("如果散列表装的太满, 那么再插入新元素的时候可能消耗时间很长, 而且可能失败. 解决方法是"),a("strong",[s._v("新建")]),s._v("一个大约 2 倍大的表, 然后扫描整个原始散列表, "),a("strong",[s._v("重新计算元素的新散列值")]),s._v("并装入到新的散列表中, 这个操作就是"),a("strong",[s._v("再散列")]),s._v(". 类似 HashMap 的扩容操作.")]),s._v(" "),a("p",[s._v("再散列显然开销较大.")]),s._v(" "),a("p",[a("strong",[s._v("再散列策略")]),s._v(":")]),s._v(" "),a("ul",[a("li",[s._v("散列表到一半满就再散列.")]),s._v(" "),a("li",[s._v("当插入元素失败才再散列(比较极端).")]),s._v(" "),a("li",[a("strong",[s._v("途中策略")]),s._v(": 当散列表达到一个"),a("strong",[s._v("装填因子")]),s._v("时进行再散列 (较好).")])])])}),[],!1,null,null,null);a.default=r.exports}}]);