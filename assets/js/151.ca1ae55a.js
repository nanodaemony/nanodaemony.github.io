(window.webpackJsonp=window.webpackJsonp||[]).push([[151],{480:function(v,_,t){"use strict";t.r(_);var a=t(4),l=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"_701-代码整洁之道"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_701-代码整洁之道"}},[v._v("#")]),v._v(" 701.代码整洁之道")]),v._v(" "),_("p",[v._v("下面是《Clean Code》的原文摘抄.")]),v._v(" "),_("h4",{attrs:{id:"整洁代码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#整洁代码"}},[v._v("#")]),v._v(" 整洁代码")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("过勒布朗(LeBlanc)法则: "),_("strong",[v._v("稍后等于永不")]),v._v("(Later equals never).")])]),v._v(" "),_("li",[_("p",[v._v("赶上期限的唯一方法——做得快的唯一方法---就是始终尽可能保持代码整洁.")])]),v._v(" "),_("li",[_("p",[v._v("我喜欢优雅和高效的代码. 代码逻辑应当直截了当, 叫缺陷难以隐藏; 尽量减少依赖关系, 使之便于维护; 依据某种分层战略完善错误处理代码; 性能调至最优, 省得引诱别人做没规矩的优化, 搞出一堆混乱来. 整洁的代码只做好一件事. ---Bjarne Stroustrup, C++语言发明者")])]),v._v(" "),_("li",[_("p",[v._v("整洁的代码简单直接. 整洁的代码如同优美的散文. 整洁的代码从不隐藏设计者的意图, 充满了干净利落的抽象和直截了当的控制语句. ---Grady Booch(中译版《面向对象分析与设计》)作者.")])]),v._v(" "),_("li",[_("p",[v._v("以寥寥数段文字概括了本书的全部内容. 不要重复代码, 只做一件事, 表达力, 小规模抽象. 该有的都有了. --Ron.")])])]),v._v(" "),_("h4",{attrs:{id:"有意义的命名"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#有意义的命名"}},[v._v("#")]),v._v(" 有意义的命名")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("变量, 函数或类的名称应该已经答复了所有的大问题. 它该告诉你, 它为什么会存在, 它做什么事, 应该怎么用. 如果名称需要注释来补充, 那就不算是名副其实.")])]),v._v(" "),_("li",[_("p",[v._v("废话是另一种没意义的区分. 假设你有一个 Product 类. 如果还有一个 ProductInfo 或 ProductData 类, 那它们的名称虽然不同, 意思却无区别. Info 和 Data 就像 a, an 和 the 一样, 是意义含混的废话.")])]),v._v(" "),_("li",[_("p",[v._v("废话都是冗余. Variable 一词永远不应当出现在变量名中. Table 一词永远不应当出现在表名中.")])]),v._v(" "),_("li",[_("p",[v._v("长名称胜于短名称, 搜得到的名称胜于用自造编码代写就的名称.")])]),v._v(" "),_("li",[_("p",[v._v("若变量或常量可能在代码中多处使用, 则应赋其以便于搜索的名称.")])]),v._v(" "),_("li",[_("p",[v._v("我喜欢不加修饰的接口. 前导字母 I 被滥用到了说好听点是干扰, 说难听点根本就是废话的程度. 我不想让用户知道我给他们的是接口.")])]),v._v(" "),_("li",[_("p",[v._v("类名和对象名应该是名词或名词短语, 如 Customer, WikiPage, Account 和AddressParser. 避免使用 Manager, Processor, Data 或 Info 这样的类名. 类名不应当是动词.")])]),v._v(" "),_("li",[_("p",[v._v("方法名应当是动词或动词短语, 如 postPayment, deletePage 或 save. 属性访问器, 修改器和断言应该根据其值命名, 并依 Javabean 标准加上 get, set 和 is 前缀.")])]),v._v(" "),_("li",[_("p",[v._v("给每个抽象概念选一个词, 并且一以贯之. 例如, 使用 fetch, retrieve 和 get 来给在多个类中的同种方法命名.")])]),v._v(" "),_("li",[_("p",[v._v("一以贯之的命名法简直就是天降福音.")])]),v._v(" "),_("li",[_("p",[v._v("避免将同一单词用于不同目的.")])])]),v._v(" "),_("h4",{attrs:{id:"函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[v._v("#")]),v._v(" 函数")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("函数的第一规则是要短小. 第二条规则是还要更短小.")])]),v._v(" "),_("li",[_("p",[v._v("每个函数都一目了然. 每个函数都只说一件事. 而且, 每个函数都依序把你带到下一个函数. 这就是函数应该达到的短小程度!")])]),v._v(" "),_("li",[_("p",[v._v("if 语句, else 语句, while 语句等, 其中的代码块应该只有一行. 该行大抵应该是一个函数调用语句. 这样不但能保持函数短小, 而且, 因为块内调用的函数拥有较具说明性的名称, 从而增加了文档上的价值.")])]),v._v(" "),_("li",[_("p",[v._v("函数应该做一件事. 做好这件事. 只做这一件事.")])]),v._v(" "),_("li",[_("p",[v._v("只做一件事的函数无法被合理地切分为多个区段.")])]),v._v(" "),_("li",[_("p",[v._v("别害怕长名称. 长而具有描述性的名称, 要比短而令人费解的名称好")])]),v._v(" "),_("li",[_("p",[v._v("最理想的参数数量是零(零参数函数), 其次是一(单参数函数), 再次是二(双参数函数), 应尽量避免三(三参数函数). 有足够特殊的理由才能用三个以上参数(多参数函数)——所以无论如何也不要这么做.")])]),v._v(" "),_("li",[_("p",[v._v("输出参数比输入参数还要难以理解.")])]),v._v(" "),_("li",[_("p",[v._v("识参数丑陋不堪. 向函数传入布尔值简直就是骇人听闻的做法.")])]),v._v(" "),_("li",[_("p",[v._v("如果函数看来需要两个, 三个或三个以上参数, 就说明其中一些参数应该封装为类了.")])]),v._v(" "),_("li",[_("p",[v._v("函数承诺只做一件事, 但还是会做其他被藏起来的事. 有时, 它会对自己类中的变量做出未能预期的改动. 有时, 它会把变量搞成向函数传递的参数或是系统全局变量. 无论哪种情况, 都是具有破坏性的, 会导致古怪的时序性耦合及顺序依赖.")])]),v._v(" "),_("li",[_("p",[v._v("函数要么做什么事, 要么回答什么事, 但二者不可得兼.")])]),v._v(" "),_("li",[_("p",[v._v("函数应该修改某对象的状态, 或是返回该对象的有关信息. 两样都干常会导致混乱.")])]),v._v(" "),_("li",[_("p",[v._v("Try/catch 代码块丑陋不堪. 它们搞乱了代码结构, 把错误处理与正常流程混为一谈. 最好把 try 和 catch 代码块的主体部分抽离出来, 另外形成函数.")])]),v._v(" "),_("li",[_("p",[v._v("如果关键字 try 在某个函数中存在, 它就该是这个函数的第一个单词, 而且在 catch/finally 代码块后面也不该有其他内容.")])]),v._v(" "),_("li",[_("p",[v._v("使用异常替代错误码, 新异常就可以从异常类派生出来, 无需重新编译或重新部署.")])]),v._v(" "),_("li",[_("p",[v._v("重复可能是软件中一切邪恶的根源. 许多原则与实践规则都是为控制与消除重复而创建")])]),v._v(" "),_("li",[_("p",[v._v("写代码和写别的东西很像. 在写论文或文章时, 你先想什么就写什么, 然后再打磨它. 初稿也许粗陋无序, 你就斟酌推敲, 直至达到你心目中的样子. 我写函数时, 一开始都冗长而复杂. 有太多缩进和嵌套循环. 有过长的参数列表. 名称是随意取的, 也会有重复的代码. 不过我会配上一套单元测试, 覆盖每行丑陋的代码. 然后我打磨这些代码, 分解函数, 修改名称, 消除重复. 我缩短和重新安置方法. 有时我还拆散类. 同时保持测试通过.")])]),v._v(" "),_("li",[_("p",[v._v("我并不从一开始就按照规则写函数.")])])]),v._v(" "),_("h4",{attrs:{id:"注释"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#注释"}},[v._v("#")]),v._v(" 注释")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("什么也比不上放置良好的注释来得有用. 什么也不会比乱七八糟的注释更有本事搞乱一个模块. 什么也不会比陈旧, 提供错误信息的注释更有破坏性.")])]),v._v(" "),_("li",[_("p",[v._v("注释存在的时间越久, 就离其所描述的代码越远, 越来越变得全然错误. 原因很简单. 程序员不能坚持维护注释.")])]),v._v(" "),_("li",[_("p",[v._v("真实只在一处地方有: 代码. 只有代码能忠实地告诉你它做的事. 那是唯一真正准确的信息来源. 所以, 尽管有时也需要注释, 我们也该多花心思尽量减少注释量.")])]),v._v(" "),_("li",[_("p",[v._v("有时, 用于警告其他程序员会出现某种后果的注释也是有用的.")])]),v._v(" "),_("li",[_("p",[v._v("能用函数或变量时就别用注释.")])]),v._v(" "),_("li",[_("p",[v._v("直接把代码注释掉是讨厌的做法. 其他人不敢删除注释掉的代码. 他们会想, 代码依然放在那儿, 一定有其原因, 而且这段代码很重要, 不能删除. 注释掉的代码堆积在一起, 就像破酒瓶底的渣滓一般.")])]),v._v(" "),_("li",[_("p",[v._v("假如你一定要写注释, 请确保它描述了离它最近的代码. 别在本地注释的上下文环境中给出系统级的信息.")])]),v._v(" "),_("li",[_("p",[v._v("别在注释中添加有趣的历史性话题或者无关的细节描述.")])]),v._v(" "),_("li",[_("p",[v._v("注释及其描述的代码之间的联系应该显而易见. 如果你不嫌麻烦要写注释, 至少让读者能看着注释和代码, 并且理解注释所谈何物.")])]),v._v(" "),_("li",[_("p",[v._v("注释的作用是解释未能自行解释的代码.")])]),v._v(" "),_("li",[_("p",[v._v("如果注释本身还需要解释, 就太遗憾了.")])]),v._v(" "),_("li",[_("p",[v._v("很容易说明, 第一个注释完全是多余的, 因为它读起来非常像是 generatePrimes 函数自身. 不过, 我认为这段注释还是省了读者去读具体算法的精力, 所以我倾向于留下它.")])]),v._v(" "),_("li",[_("p",[v._v("过时, 无关或不正确的注释就是废弃的注释.")])]),v._v(" "),_("li",[_("p",[v._v("如果注释描述的是某种充分自我描述了的东西, 那么注释就是多余的.")])]),v._v(" "),_("li",[_("p",[v._v("注释应该谈及代码自身没提到的东西.")])]),v._v(" "),_("li",[_("p",[v._v("看到注释掉的代码, 就删除它!")])])]),v._v(" "),_("h4",{attrs:{id:"格式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#格式"}},[v._v("#")]),v._v(" 格式")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("你应该保持良好的代码格式. 你应该选用一套管理代码格式的简单规则, 然后贯彻这些规则. 如果你在团队中工作, 则团队应该一致同意采用一套简单的格式规则, 所有成员都要遵从. 使用能帮你应用这些格式规则的自动化工具会很有帮助.")])]),v._v(" "),_("li",[_("p",[v._v("源文件也要像报纸文章那样. 名称应当简单且一目了然. 名称本身应该足够告诉我们是否在正确的模块中. 源文件最顶部应该给出高层次概念和算法. 细节应该往下渐次展开, 直至找到源文件中最底层的函数和细节.")])]),v._v(" "),_("li",[_("p",[v._v("紧密相关的代码应该互相靠近.")])]),v._v(" "),_("li",[_("p",[v._v("变量声明. 变量声明应尽可能靠近其使用位置. 因为函数很短, 本地变量应该在函数的顶部出现,")])]),v._v(" "),_("li",[_("p",[v._v("实体变量应该在类的顶部声明.")])]),v._v(" "),_("li",[_("p",[v._v("相关函数. 若某个函数调用了另外一个, 就应该把它们放到一起, 而且调用者应该尽可能放在被调用者上面.")])]),v._v(" "),_("li",[_("p",[v._v("概念相关. 概念相关的代码应该放到一起. 相关性越强, 彼此之间的距离就该越短.")])]),v._v(" "),_("li",[_("p",[v._v("应该尽力保持代码行短小. 死守 80 个字符的上限有点僵化, 而且我也并不反对代码行"),_("strong",[v._v("长度达到 100 个字符或 120 个字符")]),v._v(". 我个人的上限是 120 个字符.")])]),v._v(" "),_("li",[_("p",[v._v("一组开发者应当认同一种格式风格, 每个成员都应该采用那种风格.")])])]),v._v(" "),_("h4",{attrs:{id:"对象和数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象和数据结构"}},[v._v("#")]),v._v(" 对象和数据结构")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("过程式代码(使用数据结构的代码)便于在不改动既有数据结构的前提下添加新函数. 面向对象代码便于在不改动既有函数的前提下添加新类.")])]),v._v(" "),_("li",[_("p",[v._v("过程式代码难以添加新数据结构, 因为必须修改所有函数. 面向对象代码难以添加新函数, 因为必须修改所有类.")])]),v._v(" "),_("li",[_("p",[v._v("方法不应调用由任何函数返回的对象的方法. 换言之, 只跟朋友谈话, 不与陌生人谈话.")])]),v._v(" "),_("li",[_("p",[v._v("下列代码违反了得墨忒耳律(除了违反其他规则之外), 因为它调用了 getOptions() 返回值的 getScratchDir() 函数, 又调用了 getScratchDir() 返回值的 getAbsolutePath()方法. 这类代码常被称作火车失事, 因为它看起来就像是一列火车. 这类连串的调用通常被认为是肮脏的风格, 应该避免.")])])]),v._v(" "),_("div",{staticClass:"language-java line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("final")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("String")]),v._v(" outputDir "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" ctxt"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("getOptions")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("getScratchDir")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("getAbsolutePath")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("h4",{attrs:{id:"错误处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#错误处理"}},[v._v("#")]),v._v(" 错误处理")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("代价是什么? 可控异常的代价就是违反开放/闭合原则. 如果你在方法中抛出可控异常, 而 catch 语句在三个层级之上, 你就得在 catch 语句和抛出异常处之间的每个方法签名中声明该异常. 这意味着对软件中较低层级的修改, 都将波及较高层级的签名. 修改好的模块必须重新构建, 发布, 即便它们自身所关注的任何东西都没改动过.")])]),v._v(" "),_("li",[_("p",[v._v("应创建信息充分的错误消息, 并和异常一起传递出去. 在消息中, 包括失败的操作和失败类型. 如果你的应用程序有日志系统, 传递足够的信息给 catch 块, 并记录下来.")])]),v._v(" "),_("li",[_("p",[v._v("第一项就是返回 null 值.")])]),v._v(" "),_("li",[_("p",[v._v("返回 null 值, 基本上是在给自己增加工作量, 也是在给调用者添乱. 只要有一处没检查 null 值, 应用程序就会失控.")])]),v._v(" "),_("li",[_("p",[v._v("在方法中返回 null 值是糟糕的做法, 但将 null 值传递给其他方法就更糟糕了. 除非 API 要求你向它传递 null 值, 否则就要尽可能避免传递 null 值.")])]),v._v(" "),_("li",[_("p",[v._v("在大多数编程语言中, 没有良好的方法能对付由调用者意外传入的 null 值. 事已如此, 恰当的做法就是禁止传入 null 值.")])])]),v._v(" "),_("h4",{attrs:{id:"边界"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#边界"}},[v._v("#")]),v._v(" 边界")]),v._v(" "),_("ul",[_("li",[v._v("我们建议不要将 Map(或在边界上的其他接口)在系统中传递. 如果你使用类似 Map 这样的边界接口, 就把它保留在类或近亲类中. 避免从公共 API 中返回边界接口, 或将边界接口作为参数传递给公共 API.")])]),v._v(" "),_("h4",{attrs:{id:"单元测试"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单元测试"}},[v._v("#")]),v._v(" 单元测试")]),v._v(" "),_("p",[v._v("这三条定律将你限制在大概 30 秒一个的循环中. 测试与生产代码一起编写, 测试只比生产代码早写几秒钟.")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("定律一 在编写不能通过的单元测试前, 不可编写生产代码.")])]),v._v(" "),_("li",[_("p",[v._v("定律二 只可编写刚好无法通过的单元测试, 不能编译也算不通过.")])]),v._v(" "),_("li",[_("p",[v._v("定律三 只可编写刚好足以通过当前失败测试的生产代码.")])]),v._v(" "),_("li",[_("p",[v._v("整洁的测试有什么要素? 有三个要素: 可读性, 可读性和可读性.")])]),v._v(" "),_("li",[_("p",[v._v("测试应该呈现"),_("strong",[v._v("构造-操作-检验")]),v._v("(BUILD-OPERATE-CHECK)模式. 每个测试都清晰地拆分为三个环节. 第一个环节构造测试数据, 第二个环节操作测试数据, 第三个部分检验操作是否得到期望的结果.")])]),v._v(" "),_("li",[_("p",[v._v("单个测试中的断言数量应该最小化. 更好一些的规则或许是每个测试函数中只测试一个概念.")])]),v._v(" "),_("li",[_("p",[v._v("整洁的测试还遵循以下 5 条规则: 1.快速(Fast) 测试应该够快. 2.独立(Independent) 测试应该相互独立. 3.可重复(Repeatable) 测试应当可在任何环境中重复通过. 4.自足验证(Self-Validating) 测试应该有布尔值输出. 5.及时(Timely) 测试应及时编写.")])])]),v._v(" "),_("h4",{attrs:{id:"类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[v._v("#")]),v._v(" 类")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("遵循标准的 Java 约定, 类应该从一组变量列表开始. 如果有公共静态常量, 应该先出现. 然后是私有静态变量, 以及私有实体变量. 很少会有公共变量.")])]),v._v(" "),_("li",[_("p",[v._v("公共函数应跟在变量列表之后.")])]),v._v(" "),_("li",[_("p",[v._v("关于类的第一条规则是类应该短小. 第二条规则是还要更短小.")])]),v._v(" "),_("li",[_("p",[v._v("单一权责原则(SRP)认为, 类或模块应有且只有一条加以修改的理由. 该原则既给出了权责的定义, 又是关于类的长度的指导方针. 类只应有一个权责——只有一条修改的理由.")])]),v._v(" "),_("li",[_("p",[v._v("再强调一下: 系统应该由许多短小的类而不是少量巨大的类组成. 每个小类封装一个权责, 只有一个修改的原因, 并与少数其他类一起协同达成期望的系统行为.")])]),v._v(" "),_("li",[_("p",[v._v("类应该只有少量实体变量.")])]),v._v(" "),_("li",[_("p",[v._v("内聚性高, 意味着类中的方法和变量互相依赖, 互相结合成一个逻辑整体.")])]),v._v(" "),_("li",[_("p",[v._v("将大函数拆为许多小函数, 往往也是将类拆分为多个小类的时机. 程序会更加有组织, 也会拥有更为透明的结构.")])]),v._v(" "),_("li",[_("p",[v._v("类就遵循了另一条类设计原则, 依赖倒置原则(Dependency Inversion Principle, DIP). 本质而言, DIP 认为类应当依赖于抽象而不是依赖于具体细节.")])])]),v._v(" "),_("h4",{attrs:{id:"系统"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#系统"}},[v._v("#")]),v._v(" 系统")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("复杂要人命. 它消磨开发者的生命, 让产品难以规划, 构建和测试.")])]),v._v(" "),_("li",[_("p",[v._v("将构造与使用分开的方法之一是将全部构造过程搬迁到main或被称之为main的模块中, 设计系统的其余部分时, 假设所有对象都已正确构造和设置.")])]),v._v(" "),_("li",[_("p",[v._v('有一种强大的机制可以实现分离构造与使用, 那就是依赖注入(Dependency Injection, DI), 控制反转(Inversion of Control, IoC)在依赖管理中的一种应用手段. 控制反转将第二权责从对象中拿出来, 转移到另一个专注于此的对象中, 从而遵循了单一权责原则. 在依赖管理情景中, 对象不应负责实体化对自身的依赖. 反之, 它应当将这份权责移交给其他 "有权力" 的机制, 从而实现控制的反转.')])]),v._v(" "),_("li",[_("p",[v._v('"一开始就做对系统" 纯属神话. 反之, 我们应该只去实现今天的用户故事, 然后重构, 明天再扩展系统, 实现新的用户故事. 这就是迭代和增量敏捷的精髓所在. 测试驱动开发, 重构以及它们打造出的整洁代码, 在代码层面保证了这个过程的实现.')])])]),v._v(" "),_("h4",{attrs:{id:"迭进"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#迭进"}},[v._v("#")]),v._v(" 迭进")]),v._v(" "),_("ul",[_("li",[_("p",[v._v('据 Kent 所述, 只要遵循以下规则, 设计就能变得"简单": 运行所有测试; 不可重复; 表达了程序员的意图; 尽可能减少类和方法的数量; 以上规则按其重要程度排列.')])]),v._v(" "),_("li",[_("p",[v._v("重复是拥有良好设计系统的大敌. 它代表着额外的工作, 额外的风险和额外且不必要的复杂度. 重复有多种表现. 极其雷同的代码行当然是重复. 类似的代码往往可以调整得更相似, 这样就能更容易地进行重构.")])]),v._v(" "),_("li",[_("p",[v._v("可以通过应用模板方法模式来消除明显的重复.")])]),v._v(" "),_("li",[_("p",[v._v("软件项目的主要成本在于长期维护. 为了在修改时尽量降低出现缺陷的可能性, 很有必要理解系统是做什么的. 当系统变得越来越复杂, 开发者就需要越来越多的时间来理解它, 而且也极有可能误解. 所以, 代码应当清晰地表达其作者的意图. 作者把代码写得越清晰, 其他人花在理解代码上的时间也就越少, 从而减少缺陷, 缩减维护成本.")])]),v._v(" "),_("li",[_("p",[v._v("可以通过选用好名称来表达. 也可以通过保持函数和类尺寸短小来表达. 还可以通过采用标准命名法来表达. 编写良好的单元测试也具有表达性.")])])]),v._v(" "),_("h4",{attrs:{id:"并发编程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发编程"}},[v._v("#")]),v._v(" 并发编程")]),v._v(" "),_("ul",[_("li",[v._v("下面给出一系列防御并发代码问题的原则和技巧.")]),v._v(" "),_("li",[v._v("单一权责原则(SRP)认为, 方法/类/组件应当只有一个修改的理由. 并发设计自身足够复杂到成为修改的理由, 所以也该从其他代码中分离出来. 不幸的是, 并发实现细节常常直接嵌入到其他生产代码中.")]),v._v(" "),_("li",[v._v("建议: 分离并发相关代码与其他代码.")]),v._v(" "),_("li",[v._v("建议: 谨记数据封装; 严格限制对可能被共享的数据的访问.")]),v._v(" "),_("li",[v._v("让每个线程在自己的世界中存在, 不与其他线程共享数据. 每个线程处理一个客户端请求, 从不共享的源头接纳所有请求数据, 存储为本地变量. 这样一来, 每个线程都像是世界中的唯一线程, 没有同步需要.")]),v._v(" "),_("li",[v._v("关键字 synchronized 制造了锁. 同一个锁维护的所有代码区域在任一时刻保证只有一个线程执行. 锁是昂贵的, 因为它们带来了延迟和额外开销. 所以我们不愿将代码扔给 synchronized 语句了事. 另一方面, 临界区应该被保护起来. 所以, 应该尽可能少地设计临界区.")])]),v._v(" "),_("h4",{attrs:{id:"味道与启发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#味道与启发"}},[v._v("#")]),v._v(" 味道与启发")]),v._v(" "),_("ul",[_("li",[v._v("函数的参数量应该少. 没参数最好, 一个次之, 两个, 三个再次之. 三个以上的参数非常值得质疑, 应坚决避免.")]),v._v(" "),_("li",[v._v("永不被调用的方法应该丢弃. 保留死代码纯属浪费. 别害怕删除函数.")]),v._v(" "),_("li",[v._v('DRY 原则(Don’t Repeat Yourself, 别重复自己). Kent Beck 将它列为极限编程核心原则之一, 并称之为 "一次, 也只一次".')]),v._v(" "),_("li",[v._v("每次看到重复代码, 都代表遗漏了抽象. 重复的代码可能成为子程序或干脆是另一个类.")])]),v._v(" "),_("p",[v._v("‍")]),v._v(" "),_("p",[v._v("‍")]),v._v(" "),_("p",[v._v("‍")])])}),[],!1,null,null,null);_.default=l.exports}}]);