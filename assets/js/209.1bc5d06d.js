(window.webpackJsonp=window.webpackJsonp||[]).push([[209],{538:function(_,v,t){"use strict";t.r(v);var r=t(4),s=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"_1100-dubbo"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1100-dubbo"}},[_._v("#")]),_._v(" 1100.Dubbo")]),_._v(" "),v("p",[_._v("Dubbo 官网: "),v("a",{attrs:{href:"http://dubbo.apache.org/zh-cn/index.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("http://dubbo.apache.org/zh-cn/index.html"),v("OutboundLink")],1)]),_._v(" "),v("p",[_._v("Dubbo 中文文档: "),v("a",{attrs:{href:"http://dubbo.apache.org/zh-cn/index.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("http://dubbo.apache.org/zh-cn/index.html"),v("OutboundLink")],1)]),_._v(" "),v("h4",{attrs:{id:"基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[_._v("#")]),_._v(" 基础")]),_._v(" "),v("p",[_._v("Apache "),v("strong",[_._v("Dubbo")]),_._v(" 是一款高性能, 轻量级开源 "),v("strong",[_._v("RPC 框架")]),_._v(", 它提供了三大核心能力: "),v("strong",[_._v("面向接口的远程方法调用")]),_._v(", "),v("strong",[_._v("智能容错和负载均衡")]),_._v(", "),v("strong",[_._v("以及服务自动注册和发现")]),_._v(". Dubbo 是一个"),v("strong",[_._v("分布式服务框架")]),_._v(", 致力于提供高性能和透明化的 RPC 远程服务调用方案, 以及 SOA 服务治理方案.")]),_._v(" "),v("p",[_._v("Dubbo 具有如下特性:")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("负载均衡")]),_._v(": 同一个服务部署在不同的机器时该调用哪台机器上的服务.")]),_._v(" "),v("li",[v("strong",[_._v("服务调用链路生成")]),_._v(": 随着系统的发展, 服务间依赖关系变得错踪复杂, Dubbo 可以解决服务之间互相调用问题.")]),_._v(" "),v("li",[v("strong",[_._v("服务访问压力以及时长统计, 资源调度和治理")]),_._v(": 基于访问压力实时管理集群容量, 提高集群利用率.")]),_._v(" "),v("li",[v("strong",[_._v("服务降级")]),_._v(": 某个服务挂掉之后调用备用服务.")])]),_._v(" "),v("h4",{attrs:{id:"dubbo架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dubbo架构"}},[_._v("#")]),_._v(" Dubbo架构")]),_._v(" "),v("p",[_._v("Dubbo 官网给出的架构图如下:")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200727143735467.png",alt:""}})]),_._v(" "),v("p",[v("strong",[_._v("节点说明:")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("Provider")]),_._v(": 暴露服务的"),v("strong",[_._v("服务提供方")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("Consumer")]),_._v(": 调用远程服务的"),v("strong",[_._v("服务消费方")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("Registry")]),_._v(": 服务注册与发现的"),v("strong",[_._v("注册中心")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("Monitor")]),_._v(": 统计服务的调用次数和调用时间的"),v("strong",[_._v("监控中心")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("Container")]),_._v(": 服务运行"),v("strong",[_._v("容器")]),_._v(".")])]),_._v(" "),v("p",[v("strong",[_._v("调用关系:")])]),_._v(" "),v("ol",[v("li",[_._v("服务容器负责启动, 加载, 运行服务提供者.")]),_._v(" "),v("li",[_._v("服务"),v("strong",[_._v("提供者")]),_._v("在启动时, 向注册中心"),v("strong",[_._v("注册")]),_._v("自己提供的服务.")]),_._v(" "),v("li",[_._v("服务"),v("strong",[_._v("消费者")]),_._v("在启动时, 向注册中心"),v("strong",[_._v("订阅")]),_._v("自己所需的服务.")]),_._v(" "),v("li",[_._v("注册中心返回服务提供者地址列表给"),v("strong",[_._v("消费者")]),_._v(", 如果有变更, 注册中心将基于长连接"),v("strong",[_._v("推送变更数据")]),_._v("给消费者.")]),_._v(" "),v("li",[_._v("服务消费者, 从提供者地址列表中, 基于"),v("strong",[_._v("软负载均衡算法")]),_._v(", 选一台提供者进行调用, 如果调用失败, 再选另一台调用.")]),_._v(" "),v("li",[_._v("服务消费者和提供者, 在内存中累计调用次数和调用时间, 定时每分钟发送一次统计数据到"),v("strong",[_._v("监控中心")]),_._v(".")])]),_._v(" "),v("p",[v("strong",[_._v("要点总结:")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("注册中心负责服务地址的注册与查找, 相当于目录服务, 服务提供者和消费者只在启动时与注册中心交互, 注册中心不转发请求, 压力较小")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("监控中心负责统计各服务调用次数, 调用时间等, 统计先在内存汇总后每分钟一次发送到监控中心服务器, 并以报表展示")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("注册中心, 服务提供者, 服务消费者三者之间均为长连接, 监控中心除外")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("注册中心通过长连接感知服务提供者的存在, 服务提供者宕机, 注册中心将立即推送事件通知消费者")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("注册中心和监控中心全部宕机, 不影响已运行的提供者和消费者, 消费者在本地缓存了提供者列表")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("注册中心和监控中心都是可选的, 服务消费者可以直连服务提供者")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("服务提供者无状态, 任意一台宕掉后, 不影响使用")]),_._v(".")]),_._v(" "),v("li",[v("strong",[_._v("服务提供者全部宕掉后, 服务消费者应用将无法使用, 并无限次重连等待服务提供者恢复")]),_._v(".")])]),_._v(" "),v("h4",{attrs:{id:"dubbo负载均衡"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dubbo负载均衡"}},[_._v("#")]),_._v(" Dubbo负载均衡")]),_._v(" "),v("h5",{attrs:{id:"_1-dubbo负载均衡策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-dubbo负载均衡策略"}},[_._v("#")]),_._v(" 1.Dubbo负载均衡策略")]),_._v(" "),v("p",[_._v("负载均衡就是为了避免单个服务器响应同一请求, 容易造成服务器宕机, 崩溃等问题. 在集群负载均衡时, Dubbo 提供了"),v("strong",[_._v("多种均衡策略")]),_._v(", 默认为 "),v("strong",[_._v("random 随机调用")]),_._v(". 可以自行扩展负载均衡策略.")]),_._v(" "),v("h6",{attrs:{id:"_1-基于权重的随机负载均衡机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-基于权重的随机负载均衡机制"}},[_._v("#")]),_._v(" (1)基于权重的随机负载均衡机制")]),_._v(" "),v("p",[_._v("默认策略, 基于权重的随机负载均衡机制. 在一个截面上碰撞的概率高, 但调用量越大分布越均匀, 而且按概率使用权重后也比较均匀, 有利于动态调整提供者权重.")]),_._v(" "),v("h6",{attrs:{id:"_2-基于权重的轮询负载均衡机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-基于权重的轮询负载均衡机制"}},[_._v("#")]),_._v(" (2)基于权重的轮询负载均衡机制")]),_._v(" "),v("p",[v("strong",[_._v("不推荐")]),_._v(". 轮循方式存在慢的提供者请求累积的问题, 比如: 第二台机器很慢, 但没挂, 当请求调到第二台时就卡在那, 久而久之, 所有请求都卡在调到第二台上.")]),_._v(" "),v("h6",{attrs:{id:"_3-最少活跃调用数机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-最少活跃调用数机制"}},[_._v("#")]),_._v(" (3)最少活跃调用数机制")]),_._v(" "),v("p",[_._v("最少活跃调用数, 相同活跃数的随机, 活跃数指调用前后计数差. 使慢的提供者收到更少请求, 因为越慢的提供者的调用前后计数差会越大.")]),_._v(" "),v("h6",{attrs:{id:"_4-一致性哈希机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-一致性哈希机制"}},[_._v("#")]),_._v(" (4)一致性哈希机制")]),_._v(" "),v("p",[v("strong",[_._v("相同参数的请求总是发到同一提供者")]),_._v(". 如果需要的不是随机负载均衡, 是要一类请求都到一个节点, 那就用这个一致性 hash 策略. 当某一台提供者挂时, 原本发往该提供者的请求, 基于虚拟节点, 平摊到其它提供者, 不会引起剧烈变动.")])])}),[],!1,null,null,null);v.default=s.exports}}]);