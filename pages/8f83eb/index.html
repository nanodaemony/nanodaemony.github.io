<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>回溯算法题目 | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/207.cd7dd729.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>数据结构</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/98aed1/" class="sidebar-link">常见数据结构</a></li><li><a href="/pages/a31d9e/" class="sidebar-link">树</a></li><li><a href="/pages/ba361a/" class="sidebar-link">图</a></li><li><a href="/pages/b1729c/" class="sidebar-link">高级数据结构</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>基本算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/eae2ee/" class="sidebar-link">基础理论</a></li><li><a href="/pages/a21366/" class="sidebar-link">查找算法</a></li><li><a href="/pages/090e7c/" class="sidebar-link">排序算法</a></li><li><a href="/pages/24be70/" class="sidebar-link">字符串算法</a></li><li><a href="/pages/6be858/" class="sidebar-link">数据结构与算法之美(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>算法题目🌟</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/87a808/" class="sidebar-link">刷题经验</a></li><li><a href="/pages/d4049d/" class="sidebar-link">力扣Hot100</a></li><li><a href="/pages/33313a/" class="sidebar-link">数组题目</a></li><li><a href="/pages/ec2a3c/" class="sidebar-link">哈希表题目</a></li><li><a href="/pages/7c3a80/" class="sidebar-link">元素查找题目</a></li><li><a href="/pages/9b9829/" class="sidebar-link">双指针题目</a></li><li><a href="/pages/44b844/" class="sidebar-link">排序题目</a></li><li><a href="/pages/8a6c4a/" class="sidebar-link">字符串题目</a></li><li><a href="/pages/eedc87/" class="sidebar-link">链表题目</a></li><li><a href="/pages/6b2c46/" class="sidebar-link">队列与栈题目</a></li><li><a href="/pages/f4c3b6/" class="sidebar-link">树题目</a></li><li><a href="/pages/8f069b/" class="sidebar-link">贪心算法题目</a></li><li><a href="/pages/0f1cc4/" class="sidebar-link">动态规划题目</a></li><li><a href="/pages/8f83eb/" aria-current="page" class="active sidebar-link">回溯算法题目</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/0b48f4/" class="sidebar-link">图与搜索题目</a></li><li><a href="/pages/9c1a16/" class="sidebar-link">数学与位运算题目</a></li><li><a href="/pages/d06400/" class="sidebar-link">大数据与空间限制题目</a></li><li><a href="/pages/cf4131/" class="sidebar-link">业务算法题目</a></li><li><a href="/pages/d1fc13/" class="sidebar-link">智力题目</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/algorithm/#算法" data-v-06970110>算法</a></li><li data-v-06970110><a href="/algorithm/#算法" data-v-06970110>算法</a></li><li data-v-06970110><a href="/algorithm/#算法题目🌟" data-v-06970110>算法题目🌟</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">回溯算法题目<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_1150-回溯算法题目"><a href="#_1150-回溯算法题目" class="header-anchor">#</a> 1150.回溯算法题目</h1> <h4 id="理论基础"><a href="#理论基础" class="header-anchor">#</a> 理论基础</h4> <h6 id="什么是回溯"><a href="#什么是回溯" class="header-anchor">#</a> 什么是回溯</h6> <p>回溯法也可以叫做回溯搜索法, 它是一种<strong>搜索的方式</strong>. 回溯是递归的副产品, 只要有递归就会有回溯. 所以以下讲解中, 回溯函数也就是递归函数, 指的都是一个函数.</p> <p>回溯是<strong>深度优先搜索</strong>的一种<strong>特例</strong>, 它在一次搜索过程中需要<strong>设置一些</strong>本次搜索过程的<strong>局部状态</strong>, 并在本次搜索结束之后<strong>清除状态</strong>. 而普通的深度优先搜索并不需要使用这些局部状态, 虽然还是有可能设置一些全局状态.</p> <h6 id="回溯的效率"><a href="#回溯的效率" class="header-anchor">#</a> 回溯的效率</h6> <p>回溯法并不是什么高效的算法.</p> <p><mark><strong>因为回溯的本质是穷举, 穷举所有可能, 然后选出想要的答案, 如果想让回溯法高效一些, 可以加一些剪枝的操作, 但也改不了回溯法就是穷举的本质.</strong></mark></p> <p>那么既然回溯法并不高效为什么还要用它呢? 因为没得选, 一些问题能暴力搜出来就不错了, 撑死了再剪枝一下, 还没有更高效的解法.</p> <h6 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="header-anchor">#</a> 回溯法解决的问题</h6> <p>回溯法, 一般可以解决如下几种问题:</p> <ul><li><strong>组合问题</strong>: N 个数里面按一定规则找出 K 个数的集合</li> <li><strong>切割问题</strong>: 一个字符串按一定规则有几种切割方式</li> <li><strong>子集问题</strong>: 一个 N 个数的集合里有多少符合条件的子集</li> <li><strong>排列问题</strong>: N 个数按一定规则全排列, 有几种排列方式</li> <li><strong>棋盘问题</strong>: N 皇后, 解数独等等</li></ul> <p>一些人可能分不清什么是组合, 什么是排列? <mark><strong>组合是不强调元素顺序的, 排列是强调元素顺序</strong></mark>.</p> <p>例如: {1, 2} 和 {2, 1} 在组合上, 就是一个<strong>集合</strong>, 因为不强调顺序, 而要是排列的话, {1, 2} 和 {2, 1} 就是两个集合了.</p> <h6 id="如何理解回溯"><a href="#如何理解回溯" class="header-anchor">#</a> 如何理解回溯</h6> <p><mark><strong>回溯法解决的问题都可以抽象为树形结构!!Backtracking(回溯)属于 DFS</strong></mark>.</p> <p>因为回溯法解决的都是在集合中递归查找子集, <strong>集合的大小就构成了树的宽度, 递归的深度, 就构成的树的深度</strong>. 递归就要有终止条件, 所以必然是一棵高度有限的树(N 叉树).</p> <h6 id="回溯模板"><a href="#回溯模板" class="header-anchor">#</a> 回溯模板</h6> <p>下面看看回溯三部曲.</p> <blockquote><p>回溯函数模板返回值以及参数</p></blockquote> <p>回溯算法中函数<strong>返回值一般为 void</strong>. 再来看一下参数, 因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来, 所以一般是先写逻辑, 然后需要什么参数, 就填什么参数.</p> <p>回溯方法伪代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>参数<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>回溯函数终止条件</p></blockquote> <p>既然是树形结构, 那么遍历树形结构一定要有<strong>终止条件</strong>. 所以回溯也有要终止条件.</p> <p>什么时候达到了终止条件, 树中就可以看出, 一般来说<strong>搜到叶子节点了, 也就找到了满足条件的一条答案, 把这个答案存放起来, 并结束本层递归</strong>.</p> <p>所以回溯函数终止条件伪代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    存放结果<span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>回溯搜索的遍历过程</p></blockquote> <p>在上面提到, 回溯法一般是<strong>在集合中递归搜索, 集合的大小构成了树的宽度, 递归的深度构成的树的深度</strong>.</p> <p>如图:</p> <p><img src="/img/net-img-20210130173631174-20240302152356-ylkitm8.png" alt="回溯算法理论基础"></p> <p>注意图特意举例<strong>集合大小和孩子的数量是相等</strong>的!</p> <p>回溯函数遍历过程伪代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>选择<span class="token operator">:</span> 本层集合中元素<span class="token punctuation">(</span>树中节点孩子的数量就是集合的大小<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    处理节点<span class="token punctuation">;</span>
    <span class="token function">backtracking</span><span class="token punctuation">(</span>路径<span class="token punctuation">,</span> 选择列表<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归</span>
    回溯<span class="token punctuation">,</span> 撤销处理结果
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>for 循环就是遍历集合区间, 可以理解<strong>一个节点有多少个孩子, 这个 for 循环就执行多少次</strong>. backtracking 这里自己调用自己, 实现递归. 可以从图中看出 <mark><strong>for 循环可以理解是横向遍历, backtracking (递归)就是纵向遍历</strong></mark>, 这样就把这棵树全遍历完了, 一般来说, 搜索叶子节点就是找的其中一个结果了.</p> <p>分析完过程, 回溯算法模板框架如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>参数<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        存放结果<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>选择<span class="token operator">:</span> 本层集合中元素<span class="token punctuation">(</span>树中节点孩子的数量就是集合的大小<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        处理节点<span class="token punctuation">,</span> 做选择<span class="token punctuation">;</span>
        <span class="token function">backtracking</span><span class="token punctuation">(</span>路径<span class="token punctuation">,</span> 选择列表<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归</span>
        回溯<span class="token punctuation">,</span> 撤销处理结果
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>其核心就是 for 循环里面的递归, 在递归调用之前「做选择」, 在递归调用之后「撤销选择」</strong> . <strong>只要在递归之前做出选择, 在递归之后撤销刚才的选择</strong>, 就能正确得到每个节点的选择列表和路径.</p> <h6 id="回溯技巧"><a href="#回溯技巧" class="header-anchor">#</a> 回溯技巧</h6> <p>结合上述的回溯模板, 总结一些技巧:</p> <ul><li><strong>一般在递归方法外层使用两个变量 resList 和 path 来记录最终的结果和回溯过程的路径值, 这样递归方法可以少一些参数. path 可以使用 LinkedList, 这样回溯时直接使用 removeLast() 方法即可</strong>.</li> <li><strong>回溯递归方法 backtracking 一般是无返回参数的, 入参是需要递归遍历的对象, 如字符串, 数组等. 如果递归时不能重复选取元素, 比如分割回文串这种, 那么一般需要一个 startIndex 参数, 来表明当前的回溯的起始位置. 如果允许重复选取元素, 那么每次循环就从头开始即可</strong>.</li> <li><strong>回溯方法中的 for 循环就是选取元素的过程, 可以根据场景进行剪枝, 如果选取元素成功, 就记录到 path 中, 满足递归终止条件就可以处理 path 中的数据</strong>.</li> <li><strong>如果不允许结果集重复, 可以考虑对原始数组排个序, 这样遍历到一个元素时, 如果发现与之前的一样, 就不需要再处理了</strong>.</li> <li><strong>对于排列的题目, 一般需要使用一个额外的数组记录元素已经使用过了</strong>.</li></ul> <p>算法题目分类:</p> <p><img src="/img/image-20240302151840-sxaqp0u.png" alt="image"></p> <h4 id="组合问题"><a href="#组合问题" class="header-anchor">#</a> 组合问题</h4> <h5 id="组合-77-中等-🌸💯"><a href="#组合-77-中等-🌸💯" class="header-anchor">#</a> 组合(77-中等)🌸💯</h5> <h6 id="题目描述"><a href="#题目描述" class="header-anchor">#</a> 题目描述</h6> <p>给定两个整数 n 和 k, 返回 1 ... n 中<strong>所有可能的 k 个数的组合</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>示例<span class="token operator">:</span> 输入<span class="token operator">:</span> n <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">2</span> 输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p><a href="https://leetcode.cn/problems/combinations/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/combinations/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h6 id="回溯法"><a href="#回溯法" class="header-anchor">#</a> 回溯法</h6> <p>本题是回溯法的经典题目. 直接的解法当然是使用 for 循环, 例如示例中 k 为 2, 很容易想到用两个 for 循环. 代码如下:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> j <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>输入: n = 100, k = 3 那么就三层 for 循环, 代码如下:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> u <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> u <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> j <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> u <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>如果 n 为 100, k 为 50 呢, 那就 50 层 for 循环, 是不是开始窒息. 此时就会发现虽然想暴力搜索, 但是用 for 循环嵌套连暴力都写不出来!</p> <p>回溯搜索法来了, 虽然<strong>回溯法也是暴力</strong>, 但至少能写出来, 不像 for 循环嵌套 k 层让人绝望.</p> <p>那么回溯法怎么暴力搜呢? <strong>回溯法就用递归来解决嵌套层数的问题</strong>. 递归来做层叠嵌套(可以理解是开 k 层 for 循环), <strong>每一次的递归中嵌套一个 for 循环, 那么递归就可以用于解决多层嵌套循环的问题了</strong>.</p> <p>此时递归的层数大家应该知道了, 例如: n 为 100, k 为 50 的情况下, 就是<strong>递归 50 层</strong>.</p> <p>如果脑洞模拟回溯搜索的过程, 绝对可以让人窒息, 所以需要抽象<strong>图形结构</strong>来进一步理解. 回溯法解决的问题都可以抽象为树形结构(N 叉树), 用树形结构来理解回溯就容易多了.</p> <p>下面把组合问题抽象为如下树形结构:</p> <p><img src="/img/net-img-20201123195223940-20240302153035-3qwk70g.png" alt="77.组合"></p> <p>可以看出这棵树, 一开始集合是 1, 2, 3, 4, <strong>从左向右取数, 取过的数, 不再重复取</strong>. 第一次取 1, 集合变为 2, 3, 4, 因为 k 为 2, 只需要再取一个数就可以了, 分别取 2, 3, 4, 得到集合 [1,2] [1,3] [1,4], 以此类推.</p> <p><strong>每次从集合中选取元素, 可选择的范围随着选择的进行而收缩, 调整可选择的范围. 图中可以发现 n 相当于树的宽度, k 相当于树的深度.</strong></p> <p>那么如何在这个树上遍历, 然后收集到要的结果集呢?</p> <p><strong>图中每次搜索到了叶子节点, 就找到了一个结果</strong>. 相当于只需要把达到叶子节点的结果收集起来, 就可以求得 n 个数中 k 个数的组合集合.</p> <p>前面回溯法三部曲, 那么下面按照回溯法三部曲开始正式讲解代码了.</p> <blockquote><p>递归函数的返回值以及参数</p></blockquote> <p>在这里要定义两个<strong>全局变量</strong>, 一个用来存放符合条件单一结果, 一个用来存放符合条件结果的集合.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;&gt;</span> result<span class="token punctuation">;</span>   <span class="token comment">// 存放符合条件结果的集合</span>
List<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;</span> path<span class="token punctuation">;</span>           <span class="token comment">// 用来存放符合条件结果</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>其实不定义这两个全局变量也是可以的, 把这两个变量放进递归函数的参数里, 但函数里参数太多影响可读性, 所以就定义全局变量了.</p> <p>函数里一定有两个参数, 既然是集合 n 里面取 k 个数, 那么 n 和 k 是两个 int 型的参数. 然后还需要一个参数, 为 int 型变量 startIndex, 这个参数用来<strong>记录本层递归的中, 集合从哪里开始遍历</strong>(集合就是[1,...,n]).</p> <p>为什么要有这个 startIndex 呢? <strong>startIndex 就是防止出现重复的组合</strong>. 从下图中红线部分可以看出, 在集合 [1,2,3,4] 取 1 之后, 下一层递归, 就要在 [2,3,4] 中取数了, 那么下一层递归如何知道从 [2,3,4] 中取数呢, 靠的就是 startIndex.</p> <p><img src="/img/net-img-20201123195328976-20240302153035-bx4c3cl.png" alt="77.组合2"></p> <p><strong>所以需要 startIndex 来记录下一层递归, 搜索的起始位置.</strong></p> <blockquote><p>回溯函数终止条件</p></blockquote> <p>什么时候到达所谓的叶子节点了呢? path 这个数组的大小如果达到 k, 说明就找到了一个子集大小为 k 的组合了, 在图中 path 存的就是根节点到叶子节点的路径. 此时用 result 二维数组, 把 path 保存起来, 并<strong>终止本层递归</strong>.</p> <p>所以终止条件代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>单层搜索的过程</p></blockquote> <p>回溯法的搜索过程就是一个<strong>树型结构的遍历过程</strong>, 在如下图中, 看出 for 循环用来横向遍历, 递归的过程是纵向遍历.</p> <p><img src="/img/net-img-20201123195242899-20240302153035-az21j6o.png" alt="77.组合1"></p> <p>如此才遍历完图中的这棵树. for 循环每次从 startIndex 开始遍历, 然后用 path 保存取到的节点 i.</p> <p>代码如下:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 控制树的横向遍历</span>
    path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 处理节点</span>
    <span class="token function">backtracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归: 控制树的纵向遍历, 注意下一层搜索要从i+1开始</span>
    path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 回溯, 撤销处理的节点</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>可以看出 backtracking(递归函数)通过<strong>不断调用自己一直往深处遍历, 总会遇到叶子节点</strong>, 遇到了叶子节点就要返回.</p> <p><mark><strong>backtracking 的下面部分就是回溯的操作了, 撤销本次处理的结果</strong></mark>.</p> <p>完整代码如下:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 记录最终的结果</span>
<span class="token keyword">private</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;&gt;</span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ArrayList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 记录一个组合的路径</span>
<span class="token keyword">private</span> LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;</span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">LinkedList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;&gt;</span> <span class="token function">combine</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 注意题目给的取值范围是从1开始的</span>
    <span class="token function">backtrack</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> <span class="token keyword">int</span> startNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 递归终止条件, 也就是找到一组目标组合</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ArrayList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 从开始索引处继续递归</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startNum<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 路径中记录当前的结点值</span>
        path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 递归, 这里startNum要加1, 因为不允许出现重复的元素</span>
        <span class="token function">backtrack</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> count<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 回溯-去掉前面添加的结点</span>
        path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><ul><li>时间复杂度: O(n * 2^n)</li> <li>空间复杂度: O(n)</li></ul> <p>对比一下回溯模板, 非常类似:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>参数<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        存放结果<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>选择<span class="token operator">:</span> 本层集合中元素<span class="token punctuation">(</span>树中节点孩子的数量就是集合的大小<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        处理节点<span class="token punctuation">;</span>
        <span class="token function">backtracking</span><span class="token punctuation">(</span>路径<span class="token punctuation">,</span> 选择列表<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归</span>
        回溯<span class="token punctuation">,</span> 撤销处理结果
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>这个组合问题是回溯法解决的经典问题, 一开始开始的时候列举了一个很形象的例子, 就是 n 为 100, k 为 50 的话, 直接想法就需要 50 层 for 循环. 从而<strong>引出了回溯法就是解决这种 k 层 for 循环嵌套的问题</strong>. 然后进一步把回溯法的搜索过程抽象为树形结构, 可以直观的看出搜索的过程.</p> <h6 id="剪枝优化"><a href="#剪枝优化" class="header-anchor">#</a> 剪枝优化</h6> <p>回溯法虽然是暴力搜索, 但也有时候可以有点剪枝优化一下的. 在遍历的过程中有如下代码:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 缓存当前的结点值</span>
    path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 递归</span>
    <span class="token function">backtracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 回溯-去掉前面添加的结点</span>
    path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这个<strong>遍历的范围是可以剪枝优化的</strong>.</p> <p><strong>举个例子, n = 4, k = 4 的话, 那么第一层 for 循环的时候, 从元素 2 开始的遍历都没有意义了. 在第二层 for 循环, 从元素 3 开始的遍历都没有意义了</strong>.</p> <p>这么说有点抽象, 如图所示:</p> <p><img src="/img/net-img-20210130194335207-20230310134409532-20240302153035-0shq5v8.png" alt="77.组合4"></p> <p><strong>图中每一个节点(图中为矩形), 就代表本层的一个 for 循环, 那么每一层的 for 循环从第二个数开始遍历的话, 都没有意义, 都是无效遍历. 所以可以剪枝的地方就在递归中每一层的 for 循环所选择的起始位置. 如果 for 循环选择的起始位置之后的元素个数已经不足需要的元素个数了, 那么就没有必要搜索了.</strong></p> <p>注意代码中 i, 就是 for 循环里选择的起始位置.</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>for (int i = startIndex; i &amp;lt;= n; i++) {
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>看一下优化过程如下:</p> <ol><li>已经选择的元素个数: path.size();</li> <li>还需要的元素个数为: k - path.size();</li> <li>在集合 n 中<strong>至多</strong>要从该起始位置 : n - (k - path.size()) + 1, 开始遍历</li></ol> <p>为什么有个 +1 呢, 因为包括起始位置, 要是一个左闭的集合.</p> <p>举个例子, n = 4, k = 3, 目前已经选取的元素为 0(path.size 为 0), n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2. 从 2 开始搜索都是合理的, 可以是组合 [2, 3, 4].</p> <p>所以优化之后的 for 循环是:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// i 为本次搜索的起始位置</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>优化后整体代码如下:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 记录最终的结果</span>
<span class="token keyword">private</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;&gt;</span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ArrayList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 记录一个组合的路径</span>
<span class="token keyword">private</span> LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;</span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">LinkedList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 剪枝后的版本</span>
<span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;&gt;</span> <span class="token function">combine</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">backtrack</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 每次从集合中选取元素, 可选择的范围随着选择的进行而收缩, 调整可选择的范围, 就是要靠startIndex</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 终止条件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ArrayList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> num <span class="token operator">-</span> <span class="token punctuation">(</span>count <span class="token operator">-</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">backtrack</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> count<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h5 id="组合总和iii-216-中等-🌸"><a href="#组合总和iii-216-中等-🌸" class="header-anchor">#</a> 组合总和III(216-中等)🌸</h5> <h6 id="题目描述-2"><a href="#题目描述-2" class="header-anchor">#</a> 题目描述</h6> <p><strong>找出所有相加之和为 n 的 k 个数的组合. 组合中只允许含有 1 - 9 的正整数, 并且每种组合中不存在重复的数字</strong>.</p> <p>注意所有数字都是正整数, 解集不能包含重复的组合.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>示例 <span class="token number">1</span><span class="token operator">:</span> 输入<span class="token operator">:</span> k <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">7</span> 输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
示例 <span class="token number">2</span><span class="token operator">:</span> 输入<span class="token operator">:</span> k <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">9</span> 输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p><a href="https://leetcode.cn/problems/combination-sum-iii/description/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/combination-sum-iii/description/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h6 id="回溯法-2"><a href="#回溯法-2" class="header-anchor">#</a> 回溯法</h6> <p>本题就是在 [1,2,3,4,5,6,7,8,9] 这个集合中找到和为 n 的 k 个数的组合. 相对于题目 77-组合, 无非就是<strong>多了一个限制</strong>, 本题是要找到和为 n 的 k 个数的组合, 而整个集合已经是固定的 [1,...,9].</p> <p>本题 k 相当于树的深度, 9(因为整个集合就是 9 个数)就是树的宽度. 例如 k = 2, n = 4 的话, 就是在集合 [1,2,3,4,5,6,7,8,9] 中求 k(个数) = 2, n(和) = 4 的组合.</p> <p>选取过程如图:</p> <p><img src="/img/net-img-20201123195717975-20240302155911-fukvphr.png" alt="216.组合总和III"></p> <p>可以看出, 只有最后取到集合(1, 3)和为 4 符合条件.</p> <p>别忘了<strong>处理过程和回溯过程是一一对应</strong>的, 处理有加, 回溯就要有减! 与上一题的区别在于回溯函数多了一个当前的和, 这样方便进行结果判断.</p> <p>整体代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 记录最终的结果</span>
<span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 记录一个组合的路径</span>
<span class="token keyword">private</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">combinationSum3</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">backTracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backTracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> targetSum<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> curSum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 剪枝</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>curSum <span class="token operator">&gt;</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 处理并记录数据</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>curSum <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 记录路径</span>
        path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 更新当前和</span>
        curSum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
        <span class="token function">backTracking</span><span class="token punctuation">(</span>targetSum<span class="token punctuation">,</span> count<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> curSum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 回溯</span>
        path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        curSum <span class="token operator">-=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><blockquote><p>剪枝优化</p></blockquote> <p>本题的剪枝与 组合(77-中等) 的剪枝的思想是一样的, 只不过遍历的上限最多到 9,</p> <p><img src="/img/net-img-2020112319580476-20240302155912-qwcvsu1.png" alt="216.组合总和III1"></p> <p><strong>已选元素总和如果已经大于 n(图中数值为 4)了, 那么往后遍历就没有意义了, 直接剪掉</strong>. 因此, for 循环的范围也可以剪枝, <code>i &lt;= 9 - (k - path.size()) + 1</code>​ 就可以了.</p> <h5 id="电话号码的字母组合-17-中等-🌸💯"><a href="#电话号码的字母组合-17-中等-🌸💯" class="header-anchor">#</a> 电话号码的字母组合(17-中等)🌸💯</h5> <h6 id="题目描述-3"><a href="#题目描述-3" class="header-anchor">#</a> 题目描述</h6> <p>给定一个仅包含数字 2-9 的字符串, 返回所有它能表示的字母组合. 给出数字到字母的映射如下(与电话按键相同). 注意 1 不对应任何字母.</p> <p><img src="/img/image-20240302163829-74pfi65.png" alt="image"></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>示例<span class="token operator">:</span> 输入<span class="token operator">:</span> <span class="token string">&quot;23&quot;</span>  输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;ad&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;ae&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;af&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bd&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;be&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bf&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cd&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;ce&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cf&quot;</span><span class="token punctuation">]</span><span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>说明: 尽管上面的答案是按字典序排列的, 但可以任意选择答案输出的顺序.</p> <blockquote><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h6 id="回溯法-3"><a href="#回溯法-3" class="header-anchor">#</a> 回溯法</h6> <p>从示例上来说, 输入 &quot;23&quot;, 最直接的想法就是两层 for 循环遍历了吧, 正好把组合的情况都输出了. 那如果输入 &quot;233&quot; 呢, 那么就三层 for 循环, 如果 &quot;2333 &quot;呢, 就四层 for 循环..</p> <p>此时又是回溯法登场的时候了. 理解本题后, 要解决如下三个问题:</p> <ol><li><strong>数字和字母如何映射</strong></li> <li>两个字母就两个 for 循环, 三个字符就三个 for 循环, 以此类推, 然后发现代码根本写不出来.</li> <li>输入 <code>1 * #</code>​ 按键等等异常情况.</li></ol> <p>可以<strong>使用 map 或者定义一个二维数组</strong>来做映射, 这里定义一个二维数组, 代码如下:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">const</span> string letterMap<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 0</span>
    <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 1</span>
    <span class="token string">&quot;abc&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 2</span>
    <span class="token string">&quot;def&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 3</span>
    <span class="token string">&quot;ghi&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 4</span>
    <span class="token string">&quot;jkl&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 5</span>
    <span class="token string">&quot;mno&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 6</span>
    <span class="token string">&quot;pqrs&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 7</span>
    <span class="token string">&quot;tuv&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 8</span>
    <span class="token string">&quot;wxyz&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 9</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>例如: 输入: &quot;23&quot;, 抽象为树形结构, 如图所示:</p> <p><img src="/img/net-img-20201123200304469-20240302163702-tp8p92y.png" alt="17. 电话号码的字母组合"></p> <p>图中可以<strong>看出遍历的深度, 就是输入 &quot;23&quot; 的长度, 而叶子节点就是要收集的结果</strong>, 输出 [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</p> <p>回溯三部曲:</p> <blockquote><p>确定回溯函数参数</p></blockquote> <p>首先需要一个<strong>字符串 s 来收集叶子节点的结果, 然后用一个字符串数组 result 保存起来</strong>, 这两个变量依然定义为全局变量.</p> <p>再来看参数, 参数指定是有题目中给的字符串 digits, 然后还要有一个参数就是 int 型的 index. 注意这个 index 可不是 <code>77.组合</code>​ 和 <code>216.组合总和III</code>​ 中的 startIndex 了. 这个 index 是记录<strong>遍历第几个数字</strong>了, 就是用来遍历 digits 的(题目中给出数字字符串), 同时 index 也表示<strong>树的深度</strong>.</p> <blockquote><p>确定终止条件</p></blockquote> <p>例如输入用例 &quot;23&quot;, 两个数字, 那么根节点往下递归两层就可以了, 叶子节点就是要收集的结果集. 那么终止条件就是<strong>如果 index 等于输入的数字个数(digits.size())</strong>  了 (本来 index 就是用来遍历 digits 的). 然后收集结果, 结束本层递归.</p> <p>代码如下:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> digits<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>确定单层遍历逻辑</p></blockquote> <p>首先<strong>要取 index 指向的数字, 并找到对应的字符集(手机键盘的字符集)</strong> . 然后 for 循环来处理这个字符集, 代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> digit <span class="token operator">=</span> digits<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>        <span class="token comment">// 将 index 指向的数字转为 int</span>
<span class="token class-name">String</span> letters <span class="token operator">=</span> letterMap<span class="token punctuation">[</span>digit<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 取数字对应的字符集</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> letters<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>letters<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 处理</span>
    <span class="token function">backtracking</span><span class="token punctuation">(</span>digits<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 递归, 注意 index+1, 一下层要处理下一个数字了</span>
    s<span class="token punctuation">.</span><span class="token function">deleteCharAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 回溯</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>注意这里 for 循环是从 0 开始的, 因为需要处理当前这个按键上的所有的字母</strong>. 因为本题<strong>每一个数字代表的是不同集合, 也就是求不同集合之间的组合</strong>, 而 <code>77.组合</code>​ 和 <code>216.组合总和III</code>​ 都是求同一个集合中的组合!</p> <p>注意: 输入按键等等异常情况. 代码中最好考虑这些异常情况, 但题目的测试数据中应该没有异常情况的数据, 所以这里就没有加了. <strong>但是要知道会有这些异常, 如果是现场面试中, 一定要考虑到!</strong></p> <p>整体代码如下所示:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 设置全局列表存储最后的结果</span>
<span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 初始对应所有的数字, 为了直接对应2-9, 新增了两个无效的字符串&quot;&quot;</span>
<span class="token keyword">private</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num2String <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;def&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;ghi&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;jkl&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;mno&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;pqrs&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;tuv&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;wxyz&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">letterCombinations</span><span class="token punctuation">(</span><span class="token class-name">String</span> digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>digits <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> digits<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">backTracking</span><span class="token punctuation">(</span>digits<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 每次迭代获取一个字符串, 所以会设计大量的字符串拼接, 所以这里选择更为高效的 StringBuilder</span>
<span class="token keyword">private</span> <span class="token class-name">StringBuilder</span> pathBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 比如digits为&quot;23&quot;, num为0, 则str表示2对应的abc</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backTracking</span><span class="token punctuation">(</span><span class="token class-name">String</span> digits<span class="token punctuation">,</span> <span class="token keyword">int</span> digitIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 递归接收条件为长度已经足够了</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>digitIndex <span class="token operator">==</span> digits<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pathBuilder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 获取当前num对应的字符串</span>
    <span class="token class-name">String</span> charStr <span class="token operator">=</span> num2String<span class="token punctuation">[</span>digits<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>digitIndex<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// 注意这里每个数字的所有字符都需要处理一次 所以循环从0开始</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> charStr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 记录当前路径的字符</span>
        pathBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>charStr<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// digitIndex+1表示下一轮需要处理下一个给定的数字</span>
        <span class="token function">backTracking</span><span class="token punctuation">(</span>digits<span class="token punctuation">,</span> digitIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 回溯</span>
        pathBuilder<span class="token punctuation">.</span><span class="token function">deleteCharAt</span><span class="token punctuation">(</span>pathBuilder<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><ul><li>时间复杂度: <code>O(3^m * 4^n)</code>​, 其中 m 是对应四个字母的数字个数, n 是对应三个字母的数字个数.</li> <li>空间复杂度: <code>O(3^m * 4^n)</code>​</li></ul> <p>本题是需要遍历全部的情况的, 所以就不需要剪枝了.</p> <h5 id="组合总和-39-中等-🌸💯"><a href="#组合总和-39-中等-🌸💯" class="header-anchor">#</a> 组合总和(39-中等)🌸💯</h5> <h6 id="题目描述-4"><a href="#题目描述-4" class="header-anchor">#</a> 题目描述</h6> <p>给定一个<strong>无重复元素</strong>的数组 candidates 和一个目标数 target, 找出 candidates 中所有可以使数字和为 target 的组合. candidates 中的数字<strong>可以无限制重复被选取</strong>.</p> <p>说明: 所有数字(包括 target)都是正整数且互不相同. <mark><strong>解集不能包含重复的组合.</strong></mark></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>输入<span class="token operator">:</span> candidates <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token number">7</span>   输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
输入<span class="token operator">:</span> candidates <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token number">8</span>     输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p><a href="https://leetcode.cn/problems/combination-sum/description/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/combination-sum/description/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h6 id="回溯法-4"><a href="#回溯法-4" class="header-anchor">#</a> 回溯法</h6> <p>本题和 <code>77.组合</code>​, <code>216.组合总和III</code>​ 的区别是: <strong>本题没有数量要求, 可以无限重复, 但是有总和的限制, 所以间接的也是有个数的限制</strong>.</p> <p>本题搜索的过程抽象成树形结构如下:</p> <p>​<img src="/img/net-img-20201223170730367-20240302175621-x8w0049.png" alt="39.组合总和">注意图中叶子节点的返回条件, 因为本题<strong>没有组合数量要求, 仅仅是总和的限制, 所以递归没有层数的限制, 只要选取的元素总和超过 target, 就返回</strong>!</p> <blockquote><p>递归函数参数</p></blockquote> <p><strong>本题需要使用 startIndex 来控制 for 循环的起始位置, 对于组合问题, 什么时候需要 startIndex 呢?</strong></p> <p><mark><strong>如果是一个集合来求组合的话, 就需要 startIndex</strong></mark>, 例如: <code>77.组合</code>​, <code>216.组合总和III</code>​. 如果是<strong>多个集合取组合, 各个集合之间相互不影响</strong>, 那么就不用 startIndex, 例如: <code>17.电话号码的字母组合</code>​.</p> <p>注意以上只是说求<strong>组合</strong>的情况, 如果是<strong>排列</strong>问题, 又是另一套分析的套路.</p> <blockquote><p>递归终止条件</p></blockquote> <p>在如下树形结构中:</p> <p><img src="/img/net-img-20201223170730367-20230310135337214-20240302175621-qxqlj0q.png" alt="39.组合总和"></p> <p>从叶子节点可以清晰看到, 终止只有两种情况, <strong>sum 大于 target 和 sum 等于 target</strong>. sum 等于 target 的时候, 需要收集结果, 代码如下:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><p>单层搜索的逻辑</p></blockquote> <p>单层 for 循环依然是<strong>从 startIndex 开始, 搜索 candidates 集合</strong>.</p> <p>在这个树形结构中:</p> <p><img src="/img/net-img-20201223170730367-20230310135342472-20240302175621-yu1s889.png" alt="39.组合总和"></p> <p>对于 sum 已经大于 target 的情况, 其实是依然进入了下一层递归, 只是下一层递归结束判断的时候, 会判断 <code>sum &gt; target</code>​ 的话就返回.</p> <p><strong>其实如果已经知道下一层的 sum 会大于 target, 就没有必要进入下一层递归了. 这样就能实现剪枝了</strong>.</p> <p>那么可以在 for 循环的<strong>搜索范围</strong>上做文章了.</p> <p><mark><strong>对总集合排序之后, 如果下一层的 sum(就是本层的 sum + candidates[i])已经大于 target, 就可以结束本轮 for 循环的遍历, 而且这样能保证不出现重复的结果</strong></mark>.</p> <p>如图:</p> <p><img src="/img/net-img-20201223170809182-20240302175622-nmfu3mt.png" alt="39.组合总和1"></p> <p>剪枝后整体代码如下所示:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span> <span class="token keyword">int</span> target<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">combinationSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先进行排序</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>
    <span class="token function">backtracking</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 回溯函数参数: curSum为递归到目前为止的和 startIndex表示从数组的哪个位置开始去计算</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> curSum<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 找到了数字和为target的组合</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>curSum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 剪枝-如果sum + candidates[i] &gt; target 就终止遍历</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>curSum <span class="token operator">+</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        curSum <span class="token operator">=</span> curSum <span class="token operator">+</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 关键点:不用i+1了, 表示可以重复读取当前的数</span>
        <span class="token function">backtracking</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> curSum<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 回溯, 移除路径 path 最后一个元素</span>
        path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        curSum <span class="token operator">=</span> curSum <span class="token operator">-</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p>本题与之前的 <code>77.组合, 216.组合总和III</code>​ 有两点不同:</p> <ul><li><strong>组合没有数量要求</strong></li> <li><strong>元素可无限重复选取</strong></li></ul> <p><mark><strong>在求和问题中, 排序之后加剪枝是常见的套路!</strong></mark></p> <h5 id="组合总和ii-40-中等-🌸"><a href="#组合总和ii-40-中等-🌸" class="header-anchor">#</a> 组合总和II(40-中等)🌸</h5> <h6 id="题目描述-5"><a href="#题目描述-5" class="header-anchor">#</a> 题目描述</h6> <p>给定一个数组 candidates 和一个目标数 target, 找出 candidates 中所有可以使数字和为 target 的组合. <strong>candidates 中的每个数字在每个组合中只能使用一次</strong>. 说明: 所有数字(包括目标数)都是正整数. 解集不能包含重复的组合.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>输入<span class="token operator">:</span> candidates <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">,</span>
输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p><a href="https://leetcode.cn/problems/combination-sum-ii/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/combination-sum-ii/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h6 id="回溯法-5"><a href="#回溯法-5" class="header-anchor">#</a> 回溯法</h6> <p>这道题目和 <code>39.组合总和</code>​ 如下区别:</p> <ol><li>本题 candidates 中的每个数字在每个组合中<strong>只能使用一次</strong>.</li> <li>本题数组 candidates 的元素是<strong>有重复</strong>的, 而 <code>39.组合总和</code>​ 是无重复元素的数组 candidates</li></ol> <p>最后本题和<code>39.组合总和</code>​要求一样, 解集<strong>不能包含重复的组合</strong>.</p> <p><strong>本题的难点在于区别 2 中:</strong> <mark><strong>集合(数组 candidates)有重复元素, 但不能有重复的组合</strong></mark>.</p> <p>因此, 先对整个数组进行排序, 这样就能应对结果重复的情况. 回溯方法中进行遍历时, 由于不能重复选取元素, 所以每次起始索引会增加. 同时, 为了去掉重复的结果, 如果遍历时遇到当前元素与前一个元素一样, 则直接跳过当前元素了.</p> <p>整体代码如下所示:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">int</span> target <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">combinationSum2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> candidates<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>
    <span class="token comment">// 关键步骤: 数组排序 这样可以去除重复的结果</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">dfs</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * @param candidates 候选数组
 * @param startIndex 从候选数组的 begin 位置开始搜索
 * @param curSum     目前的累加和
 */</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> curSum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 找到一个结果</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>curSum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 不能重复选取元素 所以每次起始索引会增加</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 剪枝: 加上candidates[i]大于目标值, 再加后面的candidates[i + 1], candidates[i + 2]肯定也大于, 因此用 break</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>curSum <span class="token operator">+</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 小剪枝: 同一层相同数值的结点, 从第 2 个开始, 候选数更少, 结果一定发生重复, 因此跳过, 用continue</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> startIndex <span class="token operator">&amp;&amp;</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> candidates<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        path<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 因为元素不可以重复使用, 这里递归传递下去的是 i + 1 而不是 i</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> curSum <span class="token operator">+</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 回溯</span>
        path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br></div></div><ul><li>时间复杂度: O(n * 2^n)</li> <li>空间复杂度: O(n)</li></ul> <h5 id="分割回文串-131-中等-🌸💯"><a href="#分割回文串-131-中等-🌸💯" class="header-anchor">#</a> 分割回文串(131-中等)🌸💯</h5> <h6 id="题目描述-6"><a href="#题目描述-6" class="header-anchor">#</a> 题目描述</h6> <p>给定一个字符串 s, 将 s 分割成一些子串, 使<strong>每个子串都是回文串</strong>. 返回 s 所有可能的分割方案.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>输入<span class="token operator">:</span> <span class="token string">&quot;aab&quot;</span>  输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">&quot;aa&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p><a href="https://leetcode.cn/problems/palindrome-partitioning/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/palindrome-partitioning/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h6 id="回溯法-6"><a href="#回溯法-6" class="header-anchor">#</a> 回溯法</h6> <p>本题这涉及到两个关键问题:</p> <ol><li><strong>切割问题, 有不同的切割方式</strong></li> <li><strong>判断回文字符串</strong></li></ol> <p>这种题目, 想用 for 循环暴力解法, 可能都不那么容易写出来, 所以要换一种暴力的方式, 就是<strong>回溯</strong>. 来分析一下切割, <strong>其实切割问题类似组合问题</strong>.</p> <p>例如对于字符串 abcdef:</p> <ul><li><strong>组合问题</strong>: 选取一个 a 之后, 在 bcdef 中再去选取第二个, 选取 b 之后在 cdef 中再选取第三个...</li> <li><strong>切割问题</strong>: 切割一个 a 之后, 在 bcdef 中再去切割第二段, 切割 b 之后在 cdef 中再切割第三段...</li></ul> <p>所以切割问题, 也可以抽象为一棵树形结构, 如图:</p> <p>​<img src="/img/image-20241111222608-tf6gxcn.png" alt="image">​</p> <p>递归用来纵向遍历, for 循环用来横向遍历, 切割线(就是图中的红线)切割到字符串的结尾位置, 说明找到了一个切割方法. 此时可以发现, 切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的.</p> <p><strong>回溯三部曲</strong></p> <blockquote><p>递归函数参数</p></blockquote> <p>本题递归函数参数<strong>还需要 startIndex, 因为切割过的地方, 不能重复切割, 和组合问题也是保持一致的</strong>.</p> <blockquote><p>递归函数终止条件</p></blockquote> <p>从树形结构的图中可以看出: <strong>切割线切到了字符串最后面, 说明找到了一种切割方法, 此时就是本层递归的终止条件</strong>.</p> <p><strong>那么在代码里什么是切割线呢?</strong>  在处理组合问题的时候, 递归参数需要传入 startIndex, 表示<strong>下一轮递归遍历的起始位置</strong>, 这个 startIndex 就是切割线.</p> <p>所以终止条件代码如下:</p> <div class="language-CPP line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 如果起始位置大于 s 的大小, 说明找到了一组分割方案</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>startIndex <span class="token operator">&gt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ArrayList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>单层搜索的逻辑</p></blockquote> <p><strong>来看看在递归循环中如何截取子串呢?</strong></p> <p>在 <code>for (int i = startIndex; i &lt; s.size(); i++)</code>​ 循环中, 定义了起始位置 startIndex, 那么 <code>[startIndex, i]</code>​ 就是要截取的<strong>子串</strong>. 首先判断这个子串是不是回文, 如果是回文, 就加入在 <code>List&lt;string&gt; path</code>​ 中, path 用来记录切割过的回文子串.</p> <p>注意切割过的位置, 不能重复切割, 所以 <code>backtracking(s, i + 1);</code>​ 传入下一层的起始位置为 i + 1.</p> <blockquote><p>判断回文子串</p></blockquote> <p>最后看一下回文子串要如何判断了, 判断一个字符串是否是回文. <strong>可以使用双指针法, 一个指针从前向后, 一个指针从后向前, 如果前后指针所指向的元素是相等的, 就是回文字符串了</strong>.</p> <p>整体代码如下:</p> <p>回溯方法中, 由于前面处理过的字符串不能重复选择, 因此从 startIndex 开始构造当前的回文串; 然后循环从 startIndex 开始, 直到字符串结尾, 持续对 [startIndex, i] 这个区间内的字符串进行判断,是回文就缓存起来, 否则继续遍历; 同时递归时, <strong>由于 [startIndex, i] 这个区间已经是回文串, 后面不能再选择了, 所以递归传入的 startIndex 是 i + 1</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">backTracking</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backTracking</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果起始位置大于s的大小, 说明找到了一组分割方案</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>startIndex <span class="token operator">&gt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 前面的元素是构造了回文串的, 不能重复选择, 因此从startIndex开始构造回文串</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 持续判断[startIndex, i]这个区间内的字符串是否是回文串 是则缓存下来</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> str <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>startIndex<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            path<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 由于上面处理的是[startIndex, i]这个区间, 因此后续就需要处理[i + 1, s.length()]这个剩余的区间</span>
        <span class="token function">backTracking</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 回溯</span>
        path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 判断是否是回文串</span>
<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">,</span> j <span class="token operator">=</span> end<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><ul><li>时间复杂度: O(n * 2^n)</li> <li>空间复杂度: O(n^2)</li></ul> <p>这道题目在 leetcode 上是中等, 但可以说是 hard 的题目了, 但是代码其实就是按照模板的样子来的.</p> <p>那么难究竟难在什么地方呢?</p> <p><strong>我列出如下几个难点:</strong></p> <ul><li>切割问题可以抽象为组合问题</li> <li>如何模拟那些切割线</li> <li>切割问题中递归如何终止</li> <li>在递归循环中如何截取子串</li> <li>如何判断回文</li></ul> <p>一些同学可能遇到题目比较难, 但是不知道题目难在哪里, 反正就是很难. 其实这样还是思维不够清晰, 这种总结的能力需要多接触多锻炼.</p> <p><strong>本题我相信很多同学主要卡在了第一个难点上: 就是不知道如何切割, 甚至知道要用回溯法, 也不知道如何用. 也就是没有体会到按照求组合问题的套路就可以解决切割</strong>.</p> <p>如果意识到这一点, 算是重大突破了. 接下来就可以对着模板照葫芦画瓢.</p> <p><strong>但接下来如何模拟切割线, 如何终止, 如何截取子串, 其实都不好想, 最后判断回文算是最简单的了</strong>.</p> <p>关于模拟切割线, 其实就是 index 是上一层已经确定了的分割线, i 是这一层试图寻找的新分割线</p> <p>除了这些难点, <strong>本题还有细节, 例如: 切割过的地方不能重复切割所以递归函数需要传入 i + 1</strong>.</p> <h5 id="复原ip地址-93-中等-🌸"><a href="#复原ip地址-93-中等-🌸" class="header-anchor">#</a> 复原IP地址(93-中等)🌸</h5> <h6 id="题目描述-7"><a href="#题目描述-7" class="header-anchor">#</a> 题目描述</h6> <p>给定一个只包含数字的字符串, 复原它并返回所有可能的 IP 地址格式. 有效的 IP 地址 正好由四个整数(每个整数位于 0 到 255 之间组成, 且不能含有前导 0), 整数之间用 '.' 分隔.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>输入<span class="token operator">:</span> s <span class="token operator">=</span> <span class="token string">&quot;25525511135&quot;</span>   输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;255.255.11.135&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;255.255.111.35&quot;</span><span class="token punctuation">]</span>
输入<span class="token operator">:</span> s <span class="token operator">=</span> <span class="token string">&quot;0000&quot;</span>    输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;0.0.0.0&quot;</span><span class="token punctuation">]</span>
输入<span class="token operator">:</span> s <span class="token operator">=</span> <span class="token string">&quot;1111&quot;</span>    输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;1.1.1.1&quot;</span><span class="token punctuation">]</span>
输入<span class="token operator">:</span> s <span class="token operator">=</span> <span class="token string">&quot;010010&quot;</span>  输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;0.10.0.10&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;0.100.1.0&quot;</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p><a href="https://leetcode.cn/problems/restore-ip-addresses/description/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/restore-ip-addresses/description/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h6 id="回溯法-7"><a href="#回溯法-7" class="header-anchor">#</a> 回溯法</h6> <p>做这道题目之前, 最好先把 <code>131.分割回文串</code>​ 这个题目做了, 这两个题非常类似. 其实只要意识到这是切割问题, <strong>切割问题就可以使用回溯搜索法把所有可能性搜出来</strong>.</p> <p>切割问题可以抽象为树型结构, 如图:</p> <p><img src="/img/net-img-20201123203735933-20240303145658-m8zploh.png" alt="93.复原 IP 地址"></p> <p>本题的回溯函数中进行遍历时, 需要从 startIndex 开始, 由于一个数字最大为 255, 所以最多往后遍历三位即可. startIndex 一定是需要的, 因为不能重复分割, 记录下一层递归分割的起始位置. 遍历时切分出 [startIndex, i] 的子字符串进行判断, 如果是合法的(0-255 且不以 0 开头)就加入到 path 中缓存. 如果遇到刚好有四个合法数字且已经到了字符串末尾, 则认为找到一个结果.</p> <p>完整代码如下:</p> <div class="language-CPP line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">private</span> List<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ArrayList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> LinkedList<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">LinkedList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> <span class="token function">restoreIpAddresses</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 长度不对直接拦截</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">12</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ArrayList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">backTracking</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backTracking</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果已经有四个合法数字了 且已经到了字符串的末尾 则添加一次答案</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span> <span class="token operator">&amp;&amp;</span> startIndex <span class="token operator">&gt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot;.&quot;</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 从指定的起点开始, 由于一个数字最大为255, 所以最多往后遍历三位即可</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> startIndex <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment">// 取出当前范围为[startIndex, i]的子字符串进行判断 </span>
        String sub <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>startIndex<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果字符串非法则忽略</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isValidNum</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 缓存这个子字符串作为一位有序的数字</span>
        path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 这里处理的是[startIndex, i]这个区间字符串, 后面需要继续处理i+1之后的字符串</span>
        <span class="token function">backTracking</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 回溯</span>
        path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> boolean <span class="token function">isValidNum</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 不能以0开头</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&quot;0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 数字范围必须合法</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> num <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> num <span class="token operator">&lt;=</span> <span class="token number">255</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br></div></div><ul><li>时间复杂度: O(3^4), IP 地址最多包含 4 个数字, 每个数字最多有 3 种可能的分割方式, 则搜索树的最大深度为 4, 每个节点最多有 3 个子节点.</li> <li>空间复杂度: O(n)</li></ul> <h5 id="把数字翻译成字符串-lcr-65-中等-🌸🔑"><a href="#把数字翻译成字符串-lcr-65-中等-🌸🔑" class="header-anchor">#</a> 把数字翻译成字符串(LCR-65-中等)🌸🔑</h5> <h6 id="题目描述-8"><a href="#题目描述-8" class="header-anchor">#</a> 题目描述</h6> <p>给定一个数字, 按照如下规则翻译成字符串: <strong>1 翻译成 a</strong>, 2 翻译成 b... <strong>26 翻译成 z</strong>. 计算出一个数字<strong>有多少种不同</strong>的翻译方法.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>输入<span class="token operator">:</span> ciphertext <span class="token operator">=</span> <span class="token number">216612</span>  输出<span class="token operator">:</span> <span class="token number">6</span>
解释<span class="token operator">:</span> <span class="token number">216612</span> 解密后有 <span class="token number">6</span> 种不同的形式<span class="token punctuation">,</span> 分别是 <span class="token string">&quot;cbggbc&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;vggbc&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;vggm&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cbggm&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cqgbc&quot;</span> 和 <span class="token string">&quot;cqgm&quot;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p><a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/description/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/description/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h6 id="回溯法-8"><a href="#回溯法-8" class="header-anchor">#</a> 回溯法</h6> <p>这个题思路与复原 IP 地址基本一样, 只不过不需要回溯了, 只需要采用回溯的模版进行递归即可, 只要翻译到了最后即可算做一种翻译法. 由于一个字母范围是 0-25, 因此递归中 for 循环时, <strong>每次只需要处理以 startIndex 为起点的一个和两个字符的子串</strong>, 并且这里需要过滤掉几种非法的情况: 2 位数且以 0 开头的数字不合法, 大于 26 不合法.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 记录数量</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">crackNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> ciphertext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> data <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ciphertext<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">backTracking</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backTracking</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 翻译到了末尾则认为找到一个合法的结果</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>startIndex <span class="token operator">&gt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 从指定的起点开始, 由于一个合法的数字最大为25, 所以最多往后遍历2位即可</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> startIndex <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment">// 取出当前范围为[startIndex, i]的子字符串进行判断</span>
        <span class="token class-name">String</span> sub <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>startIndex<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 剪枝-如果字符串非法则停止当前的递归: 2位数且以0开头的数字不合法, 大于26不合法</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sub<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> sub<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&quot;0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">26</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 这里处理的是[startIndex, i]这个区间字符串, 前面已经用过的不能重复使用, 后面需要继续处理i+1之后的字符串</span>
        <span class="token function">backTracking</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>本题还有常见的动态规划解法, 参考对应部分即可.</p> <h5 id="子集-78-中等-🌸💯"><a href="#子集-78-中等-🌸💯" class="header-anchor">#</a> 子集(78-中等)🌸💯</h5> <h6 id="题目描述-9"><a href="#题目描述-9" class="header-anchor">#</a> 题目描述</h6> <p>给定一组不含重复元素的整数数组 nums, 返回该数组所有可能的子集(幂集). 说明: 解集不能包含重复的子集.</p> <p>输出:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>输入<span class="token operator">:</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p><a href="https://leetcode.cn/problems/subsets/description/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/subsets/description/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h6 id="回溯法-9"><a href="#回溯法-9" class="header-anchor">#</a> 回溯法</h6> <p>求子集问题和<code>77.组合</code>​和<code>131.分割回文串</code>​又不一样了.</p> <p>如果把子集问题, 组合问题, 分割问题都抽象为一棵树的话, <strong>那么组合问题和分割问题都是收集树的叶子节点, 而子集问题是找树的所有节点!</strong>  其实子集也是一种组合问题, 因为它的集合是<strong>无序</strong>的, 子集 {1,2} 和 子集 {2,1} 是一样的. <strong>那么既然是无序, 取过的元素不能重复取, 写回溯算法的时候, for 就要从 startIndex 开始, 而不是从 0 开始!</strong></p> <p>什么时候 for 可以从 0 开始呢? 求排列问题的时候, 就要从 0 开始, 因为<strong>集合是有序</strong>的, {1, 2} 和 {2, 1} 是两个集合, 排列问题后续就会讲到的.</p> <p>以示例中 nums = [1,2,3] 为例把求子集抽象为树型结构, 如下:</p> <p><img src="/img/net-img-78.%E5%AD%90%E9%9B%86-20240303151558-txdny6m.png" alt="78.子集"></p> <p>从图中红线部分, 可以看出<strong>遍历这个树的时候, 把所有节点都记录下来, 就是要求的子集集合</strong>. <strong>求取子集问题, 不需要任何剪枝! 因为子集就是要遍历整棵树</strong>.</p> <p>完整代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 存放符合条件结果的集合</span>
<span class="token keyword">private</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用来存放符合条件结果</span>

<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">subsets</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token keyword">null</span> <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">backTracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backTracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 遍历这个树的时候, 直接把所有节点都记录下来, 就是要求的子集集合</span>
    result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 终止条件(其实可以不用添加)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>startIndex <span class="token operator">&gt;=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 递归</span>
        <span class="token function">backTracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 回溯</span>
        path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><ul><li>时间复杂度: O(n * 2^n)</li> <li>空间复杂度: O(n)</li></ul> <p><strong>但是要清楚子集问题和组合问题, 分割问题的的区别, 子集是收集树形结构中树的所有节点的结果. 而组合问题, 分割问题是收集树形结构中叶子节点的结果.</strong></p> <h5 id="子集ii-90-中等-🌸"><a href="#子集ii-90-中等-🌸" class="header-anchor">#</a> 子集II(90-中等)🌸</h5> <h6 id="题目描述-10"><a href="#题目描述-10" class="header-anchor">#</a> 题目描述</h6> <p>给定一个<strong>可能包含重复元素</strong>的整数数组 nums, 返回该数组所有可能的子集(幂集). 说明: <strong>解集不能包含重复的子集</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>输入<span class="token operator">:</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>  输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p><a href="https://leetcode.cn/problems/subsets-ii/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/subsets-ii/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h6 id="回溯法-10"><a href="#回溯法-10" class="header-anchor">#</a> 回溯法</h6> <p>做本题之前一定要先做<code>78.子集</code>​. 这道题目和<code>78.子集</code>​区别就是<strong>集合里有重复元素了, 而且求取的子集要去重</strong>. 那么关于回溯算法中的去重问题, 在 <code>40.组合总和II</code>​ 中已经详细讲解过了, 和本题是一个套路.</p> <p><strong>后面要讲解的排列问题里去重也是这个套路, 所以理解 &quot;树层去重&quot; 和 &quot;树枝去重&quot; 非常重要. 注意去重需要先对集合排序.</strong></p> <p>用示例中的 [1, 2, 2] 来举例, 如图所示:</p> <p><img src="/img/net-img-20201124195411977-20240304202241-ebsj4ns.png" alt="90.子集II"></p> <p>从图中可以看出, <strong>同一树层上重复取 2 就要过滤掉, 同一树枝上就可以重复取 2, 因为同一树枝上元素的集合才是唯一子集</strong>!</p> <p>本题就是其实就是再 <code>78-子集</code>​ 的基础上加上了去重, 去重也就是先对元素进行整体排序, 后面变量时, 如果遇到当前元素与前一个元素一样的情况, 则忽略. 所以就直接给出代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 存放符合条件结果的集合</span>
<span class="token keyword">private</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 用来存放符合条件结果</span>
<span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">subsetsWithDup</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 先排个序</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
    used <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">backTacking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backTacking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 记录一种case</span>
    result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 递归结束</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>startIndex <span class="token operator">&gt;=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 去重</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>used<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token comment">// 递归</span>
        <span class="token function">backTacking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 剪枝</span>
        path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><ul><li>时间复杂度: O(n * 2^n)</li> <li>空间复杂度: O(n)</li></ul> <p>还有一种写法: 本题也可以不使用 used 数组来去重, 因为递归的时候下一个 startIndex 是 i + 1 而不是 0. 如果要是全排列的话, 每次要从 0 开始遍历, 为了跳过已入栈的元素, 需要使用 used.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">subsetsWithDupHelper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 跳过当前树层使用过的, 相同的元素</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> start <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">subsetsWithDupHelper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h5 id="递增子序列-491-中等-🌸"><a href="#递增子序列-491-中等-🌸" class="header-anchor">#</a> 递增子序列(491-中等)🌸</h5> <h6 id="题目描述-11"><a href="#题目描述-11" class="header-anchor">#</a> 题目描述</h6> <p>给定一个整型数组, 找到所有该数组的递增子序列, 递增子序列的长度至少是 2. 给定数组中<strong>可能包含重复数字</strong>, 相等的数字应该被视为递增的一种情况.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>输入<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>  输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
输入<span class="token operator">:</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>   输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/non-decreasing-subsequences/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h6 id="回溯法-11"><a href="#回溯法-11" class="header-anchor">#</a> 回溯法</h6> <p>这个递增子序列比较像是<strong>取有序的子集</strong>. 而且本题也要求<strong>不能有相同的递增子序列</strong>. 这又是子集, 又是去重, 是不是不由自主的想起了刚刚讲过的 <code>90.子集II</code>​. 要注意差别所在! 本题求自增子序列, 是<strong>不能对原数组进行排序</strong>的. <strong>所以不能使用之前的去重逻辑, 因此为了实现去重, 就得使用额外的集合来记录当前层已经使用过的元素. 同时本题求子序列, 因此元素不能重复使用, 所以需要 startIndex, 调整下一层递归的起始位置</strong>. 本题其实类似求子集问题, 也是要遍历树形结构找<strong>每一个节点</strong>, 所以也不加终止条件, startIndex 每次都会加 1, 并不会无限递归.</p> <p>这里用 [4, 7, 6, 7] 这个数组来举例, 抽象为树形结构如图:</p> <p><img src="/img/net-img-20201124200229824-20240304203821-aql5psy.png" alt="491. 递增子序列1"></p> <p>在图中可以看出, <mark><strong>同一父节点下的同层上使用过的元素就不能再使用了</strong></mark>​ <strong>.</strong>  这也是需要注意的点, <mark><strong>usedSet 是记录本层元素是否重复使用, 新的一层 usedSet 都会重新定义(清空), 所以要知道 usedSet 只负责本层</strong></mark>! 因此 usedSet 是定义在递归方法中的临时变量.</p> <p>代码如下:</p> <div class="language-CPP line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">private</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;&gt;</span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ArrayList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;</span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">LinkedList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;&gt;</span> <span class="token function">findSubsequences</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">backTracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backTracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ArrayList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 注意这里不要加 return, 因为要取树上的节点, 所以没有终止条件</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 记录本层已经使用过的数字</span>
    Set<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;</span> usedSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">HashSet</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 元素不能重复选取 所以本次遍历从startIndex开始</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 剪枝: 当前元素小于path的最后一个元素 说明是数值降低了 后面就不用再处理了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>path<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> path<span class="token punctuation">.</span><span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 如果同一层已经使用过了当前数字则跳过</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>usedSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 将当前数字记录到已经使用的Set中</span>
        usedSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 递归</span>
        <span class="token function">backTracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 回溯</span>
        path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><ul><li>时间复杂度: O(n * 2^n)</li> <li>空间复杂度: O(n)</li></ul> <p>这里用 set 来记录本层元素是否重复使用. <strong>其实还可以用数组来做哈希, 效率就高了很多</strong>. 注意题目中说了, 数值范围 <code>[-100,100]</code>​, 所以完全可以用数组来做哈希. 也就是用数组的索引来记录是否使用过. 所以, <strong>数组, set, map 都可以做哈希表, 而且数组干的活, map 和 set 都能干, 但如果数值范围小的话能用数组尽量用数组</strong>.</p> <h4 id="排列问题"><a href="#排列问题" class="header-anchor">#</a> 排列问题</h4> <h5 id="全排列-46-中等-🌸💯"><a href="#全排列-46-中等-🌸💯" class="header-anchor">#</a> 全排列(46-中等)🌸💯</h5> <h6 id="题目描述-12"><a href="#题目描述-12" class="header-anchor">#</a> 题目描述</h6> <p>给定一个 <strong>没有重复</strong> 数字的序列, 返回其所有可能的全排列.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>输入<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>  输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p><a href="https://leetcode.cn/problems/permutations/description/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/permutations/description/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h6 id="回溯法-12"><a href="#回溯法-12" class="header-anchor">#</a> 回溯法</h6> <p>前面看了组合问题, 下面来看一看排列问题. 这个排列问题就算是让用 for 循环暴力把结果搜索出来, 这个暴力也不是很好写. 因为一些问题能暴力搜出来就已经很不错了!</p> <p>以 [1,2,3] 为例, 抽象成树形结构如下:</p> <p><img src="/img/net-img-20211027181706-20240304213636-iubxua3.png" alt="46.全排列"></p> <p><mark><strong>排列是有序的, 也就是说 [1,2] 和 [2,1] 是两个集合, 这和之前分析的子集以及组合所不同的地方</strong></mark>​<mark>.</mark></p> <p>可以看出元素 1 在 [1,2] 中已经使用过了, 但是在 [2,1] 中还要在使用一次 1, 所以<strong>处理排列问题就不用使用 startIndex</strong> 了. 但排列问题<strong>需要一个 used 数组, 标记已经选择的元素</strong>, 如图橘黄色部分所示. 可以看出<strong>叶子节点, 就是收割结果的地方</strong>. 当<strong>收集元素的数组 path 的大小达到和 nums 数组一样大的时候</strong>, 说明找到了一个全排列, 也表示到达了叶子节点.</p> <p>这里和之前的组合问题最大的不同就是 <strong>for 循环里不用 startIndex</strong> 了. 因为<mark><strong>排列问题, 每次都要从头开始搜索</strong></mark>, 例如元素 1 在 [1,2] 中已经使用过了, 但是在 [2,1] 中还要再使用一次 1. <mark><strong>而 used 数组就是记录此时 path 里都有哪些元素使用了, 一个排列里一个元素只能使用一次. 注意这里的 used 是一个全局的变量, 因为是否使用时从全局的递归来看的</strong></mark>.</p> <p>​​整体代码如下:​</p> <div class="language-CPP line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">private</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;&gt;</span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ArrayList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;</span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">LinkedList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 记录元素是否已经使用过</span>
<span class="token keyword">private</span> boolean<span class="token punctuation">[</span><span class="token punctuation">]</span> used<span class="token punctuation">;</span>

<span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;&gt;</span> <span class="token function">permute</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    used <span class="token operator">=</span> <span class="token keyword">new</span> boolean<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">permuteHelper</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">permuteHelper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ArrayList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 每次从第一个元素开始遍历</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 记录某个元素是否使用过</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>used<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 递归</span>
        <span class="token function">permuteHelper</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 回溯</span>
        path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><ul><li>时间复杂度: O(n!)</li> <li>空间复杂度: O(n)</li></ul> <p>本题的两个关键点:</p> <ul><li><strong>每层都是从 0 开始搜索而不是 startIndex</strong></li> <li><strong>需要 used 数组记录 path 里都放了哪些元素了</strong></li></ul> <p>当然由于题目限制了不会出现重复元素, 所以还可以直接用 path 来判断元素是否使用过.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">permute</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">backTracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backTracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 递归终止, 找到一个全排列</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 由于是排列, 可以重复选取元素, 因此每次都从第一个开始遍历</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果 path 中已有这个元素(题目已经表示元素不会重复), 则跳过</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 递归</span>
        <span class="token function">backTracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 回溯</span>
        path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><h5 id="全排列ii-47-中等-🌸🔑"><a href="#全排列ii-47-中等-🌸🔑" class="header-anchor">#</a> 全排列II(47-中等)🌸🔑</h5> <h6 id="题目描述-13"><a href="#题目描述-13" class="header-anchor">#</a> 题目描述</h6> <p>给定一个<strong>可能包含重复数字的序列 nums</strong>, 按任意顺序返回所有<strong>不重复的全排列</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>输入<span class="token operator">:</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>  输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
输入<span class="token operator">:</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>  输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p><a href="https://leetcode.cn/problems/permutations-ii/description/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/permutations-ii/description/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h6 id="回溯法-13"><a href="#回溯法-13" class="header-anchor">#</a> 回溯法</h6> <p>这道题目和 <code>46.全排列</code>​ 的区别在与<strong>给定一个可包含重复数字的序列</strong>, 要返回<strong>所有不重复的全排列</strong>. 这里又涉及到去重了. 本题需要<mark><strong>去重, 因此需要对元素进行排序, 这样才方便通过相邻的节点来判断是否重复使用了.</strong></mark></p> <p>图中对<strong>同一树层, 前一位(也就是 nums[i-1])如果使用过, 那么就进行去重</strong>.</p> <p>以示例中的 [1,1,2] 为例(为了方便举例, 已经排序)抽象为一棵树, 去重过程如图:</p> <p><img src="/img/net-img-20201124201331223-20240304215921-e1yq9ty.png" alt="47.全排列II1"></p> <p>本题难以理解的是 (i &gt; 0 &amp;&amp; nums[i] <mark> nums[i - 1] &amp;&amp; !used[i - 1]) 这个条件. for 循环保证了从数组中从前往后一个一个取值, 再用 if 判断条件. 所以 nums[i - 1] 一定比 nums[i] 先被取值和判断. 如果 nums[i - 1] 被取值了, 那 vis[i - 1] 会被置 1, 只有当递归再回退到这一层时再将它置 0. 每递归一层都是在寻找数组对应于递归深度位置的值, 每一层里用 for 循环来寻找. 所以当 vis[i - 1] </mark> 1时, 说明 nums[i - 1] 和 nums[i] 分别属于两层递归中, 也就是要用这<strong>两个数分别放在数组的两个位置, 这时不需要去重</strong>. 但是当 vis[i - 1] == 0 时, 说明 nums[i - 1] 和 nums[i] 属于同一层递归中(只是 for 循环进入下一层循环), 也就是要用这两个数放在数组中的同一个位置上, 这就是要去重的情况.</p> <p>本题的完整代码如下:</p> <div class="language-CPP line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 初始化结果集和临时路径</span>
<span class="token keyword">private</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;&gt;</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ArrayList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;</span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ArrayList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> boolean<span class="token punctuation">[</span><span class="token punctuation">]</span> used<span class="token punctuation">;</span>

<span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;&gt;</span> <span class="token function">permuteUnique</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 排序数组确保相同元素相邻</span>
    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
    used <span class="token operator">=</span> <span class="token keyword">new</span> boolean<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 初始化使用标记数组</span>
    <span class="token function">backTracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backTracking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 找到一组全排列</span>
        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ArrayList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 由于是全排列, 所以每次循环从第一个元素开始遍历</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 由于每次循环都是从头开始的, 因此需要跳过循环中已使用的元素</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>used<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 跳过重复元素(当前元素与上个元素相同, 且上个元素未被使用)</span>
        <span class="token comment">// 如果上个元素被使用了, 说明是在别的层级被使用的, 此时是不需要跳过的, 因此这里跳过的事上个元素未被使用的情况</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>used<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 标记当前元素已使用, 并加入路径</span>
        used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 继续递归</span>
        <span class="token function">backTracking</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 回溯, 取消标记并移除路径中的最后一个元素</span>
        used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><p><mark><strong>需要注意的是: 这里不能简单的用 set 来判断数字是否用过了. 因为 set 会把相同的信息抹掉. 比如一个数组全是 1, 那这个 set 也就全是 1. 用 used 数组记录的是某个索引是否被用过, 保留了元素及其位置信息.</strong></mark></p> <ul><li>时间复杂度: O(n! * n)</li> <li>空间复杂度: O(n)</li></ul> <h5 id="打印从1到最大的n位数-lcr-135-🌸🔑"><a href="#打印从1到最大的n位数-lcr-135-🌸🔑" class="header-anchor">#</a> 打印从1到最大的n位数(LCR-135)🌸🔑</h5> <h6 id="题目描述-14"><a href="#题目描述-14" class="header-anchor">#</a> 题目描述</h6> <p>输入<strong>数字 n</strong>, 按<strong>顺序打印</strong>出从 1 到<strong>最大的 n 位</strong>十进制数. 比如输入 3, 则打印出 1, 2, 3 一直到<strong>最大的 3 位数</strong>即 999.</p> <blockquote><p><a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/description/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/description/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h6 id="深度优先全排列法"><a href="#深度优先全排列法" class="header-anchor">#</a> 深度优先全排列法</h6> <p><strong>由于 n 可能会非常大, 因此不能直接用 int 表示数字, 而是用 char 数组进行存储.</strong></p> <p>这里使用深度优先遍历的方式来对一个数字的每个位都从 0 到 9 进行选择, 当 n 个位都选择完毕时, 就认为找到一个答案. 本题只是采用与回溯类似的写法, 其实不会进行回溯.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 用于记录每个位置元素的数组, 这个数组各个位解析一下就代表一个数字</span>
<span class="token keyword">private</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> number<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">countNumbers</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 存放结果的数组</span>
    res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 初始化一个num数组用于存放每一位</span>
    number <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 初始digit为0</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> digit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 递归终止条件: 递归到叶子结点时, digit的长度等于就等于结果数组的长度</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>digit <span class="token operator">==</span> number<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            res<span class="token punctuation">[</span>counter<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 深度优先遍历: 当前位可以选择的数字是0-9, 每个位都可以重复选, 因此从0开始遍历</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 增加各个位的值</span>
        number<span class="token punctuation">[</span>digit<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>digit <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><h5 id="括号生成-22-中等-🌸💯"><a href="#括号生成-22-中等-🌸💯" class="header-anchor">#</a> 括号生成(22-中等)🌸💯</h5> <h6 id="题目描述-15"><a href="#题目描述-15" class="header-anchor">#</a> 题目描述</h6> <p>数字 n 代表生成括号的对数, 请你设计一个函数, 用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>输入<span class="token operator">:</span> n <span class="token operator">=</span> <span class="token number">3</span>  输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;((()))&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;(()())&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;(())()&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;()(())&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;()()()&quot;</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p><a href="https://leetcode.cn/problems/generate-parentheses/description/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/generate-parentheses/description/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h6 id="深度优先全排列法-2"><a href="#深度优先全排列法-2" class="header-anchor">#</a> 深度优先全排列法</h6> <p>本题与前一个题是类似的, 只不过本题每个位置可选的元素只有两个. 因此, 深度优先递归中, 遍历选择两个括号即可. 同时, 递归方法需要传入目前的左右括号的数量, 用于剪枝. 同时递归时, 应该分别根据当前选择的是左还是右括号, 选择性增加左与右括号的数量.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 存放最终的结果</span>
<span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 存放数据的临时结果</span>
<span class="token keyword">private</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">;</span>
<span class="token comment">// 可选的括号类型</span>
<span class="token keyword">private</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> quetos <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token char">'('</span><span class="token punctuation">,</span> <span class="token char">')'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// n个数</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">generateParenthesis</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> digit<span class="token punctuation">,</span> <span class="token keyword">int</span> leftNum<span class="token punctuation">,</span> <span class="token keyword">int</span> rightNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果右括号的数量大于左则终止</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rightNum <span class="token operator">&gt;</span> leftNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果左或者右的数量超过给定的n了, 那一定不能构成了也终止</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftNum <span class="token operator">&gt;</span> n <span class="token operator">||</span> rightNum <span class="token operator">&gt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// digit等于缓存数组的长度了, 找到一组解法</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>digit <span class="token operator">==</span> temp<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 每个digit都遍历可选的括号</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> quetos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当前digit选择一个括号</span>
        temp<span class="token punctuation">[</span>digit<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>
        <span class="token comment">// 根据选择的括号不同对左右数量递增</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token char">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>digit <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> leftNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rightNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token char">')'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>digit <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> leftNum<span class="token punctuation">,</span> rightNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><h4 id="其他问题"><a href="#其他问题" class="header-anchor">#</a> 其他问题</h4> <h5 id="n皇后-51-困难-🌸💯"><a href="#n皇后-51-困难-🌸💯" class="header-anchor">#</a> N皇后(51-困难)🌸💯</h5> <h6 id="题目描述-16"><a href="#题目描述-16" class="header-anchor">#</a> 题目描述</h6> <p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上, 并且使皇后彼此之间不能相互攻击. 给你一个整数 n, 返回所有不同的 n 皇后问题的解决方案. 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案, 该方案中 'Q' 和 '.' 分别代表了<strong>皇后和空位</strong>.</p> <p><img src="/img/net-img-20211020232201-20240304222525-j1h9cw4.png" alt=""></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>输入<span class="token operator">:</span> n <span class="token operator">=</span> <span class="token number">4</span>  输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">&quot;.Q..&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;...Q&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;Q...&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;..Q.&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">&quot;..Q.&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;Q...&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;...Q&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;.Q..&quot;</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p><a href="https://leetcode.cn/problems/n-queens/description/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/n-queens/description/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h6 id="回溯法-14"><a href="#回溯法-14" class="header-anchor">#</a> 回溯法</h6> <p>首先来看一下皇后们的约束条件:</p> <ol><li>不能同行</li> <li>不能同列</li> <li>不能同斜线</li></ol> <p>确定完约束条件, 来看看究竟要怎么去<strong>搜索皇后们的位置, 其实搜索皇后的位置, 可以抽象为一棵树</strong>. 下面用一个 3 * 3 的棋盘, 将搜索过程抽象为一棵树, 如图:</p> <p><img src="/img/net-img-20210130182532303-20240304222525-opmzuj7.jpg" alt="51.N 皇后"></p> <p>从图中可以看出, <strong>二维矩阵中矩阵的高就是这棵树的高度, 矩阵的宽就是树形结构中每一个节点的宽度</strong>. 那么用皇后们的约束条件, 来回溯搜索这棵树, <strong>只要搜索到了树的叶子节点, 说明就找到了皇后们的合理位置了</strong>.</p> <p>回溯方法中, 定义<strong>全局变量二维数组 result 来记录最终结果</strong>. 参数 n 是棋盘的大小, 然后<strong>用 row 来记录当前遍历到棋盘的第几层</strong>了.</p> <p>递归终止条件是<strong>当递归到棋盘最底层(也就是叶子节点)的时候, 就可以收集结果并返回</strong>了.</p> <p><strong>递归深度就是 row 控制棋盘的行, 每一层里 for 循环的 col 控制棋盘的列, 一行一列, 确定了放置皇后的位置</strong>.</p> <p>每次都是要<mark><strong>从新的一行的起始位置开始搜, 所以都是从 0 开始</strong></mark>. 同时验证当前的棋盘是否合法.</p> <p>完整代码如下:</p> <div class="language-CPP line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">private</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">&gt;&gt;</span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ArrayList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">&gt;&gt;</span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 构造2维棋盘</span>
    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chessboard <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c <span class="token operator">:</span> chessboard<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token char">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">backTracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> chessboard<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backTracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chessboard<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 递归终止条件 找到一个解并记录一下</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>row <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">array2List</span><span class="token punctuation">(</span>chessboard<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 每次都需要从头开始遍历新的行</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 剪枝: 如果当前棋盘不满足要求就剪枝</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isValid</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> n<span class="token punctuation">,</span> chessboard<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 当前放一个皇后</span>
        chessboard<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'Q'</span><span class="token punctuation">;</span>
        <span class="token comment">// 递归下一层</span>
        <span class="token function">backTracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> chessboard<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 回溯</span>
        chessboard<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'.'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> <span class="token function">array2List</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chessboard<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ArrayList</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c <span class="token operator">:</span> chessboard<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">copyValueOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> boolean <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> col<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chessboard<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 检查列</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> row<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 相当于剪枝</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>chessboard<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 检查45度对角线</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> row <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> col <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>chessboard<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 检查135度对角线</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> row <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> col <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>chessboard<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br></div></div><ul><li>时间复杂度: O(n!)</li> <li>空间复杂度: O(n)</li></ul> <p>可以看出, 除了验证棋盘合法性的代码, 省下来部分就是按照回溯法模板来的. 本题<strong>明确给出了棋盘的宽度就是 for 循环的长度, 递归的深度就是棋盘的高度, 这样就可以套进回溯法的模板里了</strong>.</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/40.算法/4000.算法/100.算法题目🌟/1150.回溯算法题目.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/0f1cc4/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">动态规划题目</div></a> <a href="/pages/0b48f4/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">图与搜索题目</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/0f1cc4/" class="prev">动态规划题目</a></span> <span class="next"><a href="/pages/0b48f4/">图与搜索题目</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/207.cd7dd729.js" defer></script>
  </body>
</html>
