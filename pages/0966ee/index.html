<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Zookeeper | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/170.58569530.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>分布式系统理论</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/129626/" class="sidebar-link">分布式系统基础</a></li><li><a href="/pages/fb5d35/" class="sidebar-link">分布式共识算法</a></li><li><a href="/pages/12ac37/" class="sidebar-link">分布式系统组件</a></li><li><a href="/pages/d03ebf/" class="sidebar-link">分布式技术原理与算法解析(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>系统接入层</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/f1b6c4/" class="sidebar-link">Nginx基础</a></li><li><a href="/pages/d4123d/" class="sidebar-link">深入拆解Tomcat与Jetty(极客时间)🌸</a></li><li><a href="/pages/baee2f/" class="sidebar-link">Netty</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>服务治理-注册发现与RPC</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/05077d/" class="sidebar-link">基础</a></li><li><a href="/pages/51b6aa/" class="sidebar-link">RPC实战与核心原理(极客时间)🌸</a></li><li><a href="/pages/0966ee/" aria-current="page" class="active sidebar-link">Zookeeper</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/3b7e05/" class="sidebar-link">Nacos</a></li><li><a href="/pages/7f31f8/" class="sidebar-link">Dubbo</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>服务治理-流量控制</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/44bfa8/" class="sidebar-link">负载均衡</a></li><li><a href="/pages/4d5a6c/" class="sidebar-link">限流</a></li><li><a href="/pages/e0c561/" class="sidebar-link">熔断</a></li><li><a href="/pages/12ae40/" class="sidebar-link">网关路由</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>服务治理-系统监控与安全</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/8c9210/" class="sidebar-link">系统安全性</a></li><li><a href="/pages/c9bf40/" class="sidebar-link">系统监控组件</a></li><li><a href="/pages/3f3cf7/" class="sidebar-link">运维监控系统实战(极客时间)🌸</a></li><li><a href="/pages/e20e02/" class="sidebar-link">OAuth2.0实战课(极客时间)🌟</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>中间件-消息队列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/96d94c/" class="sidebar-link">消息队列基础</a></li><li><a href="/pages/abf16c/" class="sidebar-link">RabbitMQ</a></li><li><a href="/pages/4fc3f1/" class="sidebar-link">Kafka</a></li><li><a href="/pages/013cfe/" class="sidebar-link">RocketMQ</a></li><li><a href="/pages/ed8d92/" class="sidebar-link">Disruptor</a></li><li><a href="/pages/249149/" class="sidebar-link">消息队列高手课(极客时间)🌟</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>中间件-缓存</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/946847/" class="sidebar-link">缓存基础</a></li><li><a href="/pages/e46d56/" class="sidebar-link">本地缓存</a></li><li><a href="/pages/0abfb9/" class="sidebar-link">Redis基础</a></li><li><a href="/pages/09236a/" class="sidebar-link">Redis持久化</a></li><li><a href="/pages/867f9b/" class="sidebar-link">Redis主从复制</a></li><li><a href="/pages/50cae1/" class="sidebar-link">Redis哨兵</a></li><li><a href="/pages/43b45c/" class="sidebar-link">Redis集群</a></li><li><a href="/pages/a32379/" class="sidebar-link">Redis内存管理与运维</a></li><li><a href="/pages/386037/" class="sidebar-link">Redis核心技术与实战(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>中间件-其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/23044d/" class="sidebar-link">定时任务-XXLJob</a></li><li><a href="/pages/459117/" class="sidebar-link">ES与检索</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>系统设计与优化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/41a845/" class="sidebar-link">凤凰架构</a></li><li><a href="/pages/68cc0b/" class="sidebar-link">左耳听风(极客时间)🌟</a></li><li><a href="/pages/e3e99c/" class="sidebar-link">从0开始学微服务(极客时间)🌸</a></li><li><a href="/pages/1e5368/" class="sidebar-link">高并发系统设计40问(极客时间)🌸</a></li><li><a href="/pages/33599f/" class="sidebar-link">系统性能调优必知必会(极客时间)🌸</a></li><li><a href="/pages/c83472/" class="sidebar-link">后端技术面试38讲(极客时间)</a></li><li><a href="/pages/4404b6/" class="sidebar-link">架构实战案例解析(极客时间)🌸</a></li><li><a href="/pages/8f1c1d/" class="sidebar-link">如何设计一个秒杀系统(极客时间)</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>容器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>容器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/582acf/" class="sidebar-link">部署Minikube</a></li><li><a href="/pages/98e5e4/" class="sidebar-link">容器实战高手课(极客时间)🌸</a></li><li><a href="/pages/c6a42c/" class="sidebar-link">Kubernetes实战🌸</a></li><li><a href="/pages/f35c72/" class="sidebar-link">深入剖析Kubernetes(极客时间)🌸</a></li><li><a href="/pages/caa314/" class="sidebar-link">Istio</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>自动化运维</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/beb97f/" class="sidebar-link">持续集成(CICD)</a></li><li><a href="/pages/a0df2d/" class="sidebar-link">DevOps</a></li><li><a href="/pages/765815/" class="sidebar-link">SRE实战手册(极客时间)</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/middleware/#系统" data-v-06970110>系统</a></li><li data-v-06970110><a href="/middleware/#系统" data-v-06970110>系统</a></li><li data-v-06970110><a href="/middleware/#服务治理-注册发现与RPC" data-v-06970110>服务治理-注册发现与RPC</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">Zookeeper<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_110-zookeeper"><a href="#_110-zookeeper" class="header-anchor">#</a> 110.Zookeeper</h1> <h3 id="一-zookeeper基础"><a href="#一-zookeeper基础" class="header-anchor">#</a> 一.Zookeeper基础</h3> <h4 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h4> <p>项目从单体到<strong>分布式</strong>转变之后, 会产生<strong>多个节点之间协同</strong>的问题. 如: 每天的定时任务由谁哪个节点来执行? RPC 调用时的<strong>服务发现</strong>? 如何保证并发请求的<strong>幂等</strong>? 这些可以统一归纳为<strong>多节点协调问题</strong>, 如果靠节点自身进行协调是不可靠的, 性能上也不可取. 应该由一个<mark><strong>独立的服务做协调工作</strong></mark>, 它必须可靠, 而且保证性能.</p> <p>ZK 是用于分布式应用的协调服务. <strong>分布式应用程序可以使用 ZK 的 API 用于同步, 节点状态, 配置等信息, 服务注册等信息</strong>. 其设计目标是将复杂且容易出错的分布式一致性服务封装起来, 构成一个高效可靠的原语集, 并以一系列简单易用的接口提供给用户使用.</p> <p>ZK 虽然是个大管家, 但是它不会直接发号施令, 而是<mark><strong>只是对各个客户的行为做记录</strong></mark>, 不然 ZK 就成了一个中心化的结点, 其可靠性依然有问题.</p> <p><strong>ZK 是一个典型的分布式</strong>​<mark><strong>数据一致性</strong></mark>​**解决方案, 分布式应用程序可以基于 ZK 实现诸如数据发布/订阅, 负载均衡, 命名服务, 分布式协调/通知, 集群管理, Master 选举, 分布式锁和分布式队列等功能. ** 其一致性是通过基于 <strong>Paxos</strong> 算法的 <strong>ZAB 协议</strong>完成的.</p> <p>ZK 作为分布式系统也满足 CAP 定理, 其实现保证了 <mark><strong>CP</strong></mark>(数据一致性与分区容错性).</p> <h4 id="部署与常规配置"><a href="#部署与常规配置" class="header-anchor">#</a> 部署与常规配置</h4> <h5 id="_1-安装与运行"><a href="#_1-安装与运行" class="header-anchor">#</a> 1.安装与运行</h5> <p>ZooKeeper 基于 Java 开发, 运行依赖 JVM 环境. <strong>默认端口号是 2181</strong>.</p> <p>下载地址: <a href="https://zookeeper.apache.org/releases.html#download" target="_blank" rel="noopener noreferrer">https://zookeeper.apache.org/releases.html#download<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>具体部署流程:</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 下载</span>
<span class="token function">wget</span> https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/current/apache-zookeeper-3.5.5-bin.tar.gz
<span class="token comment"># 解压</span>
<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> apache-zookeeper-3.5.5-bin.tar.gz
<span class="token comment"># 拷贝默认配置</span>
<span class="token builtin class-name">cd</span> <span class="token punctuation">{</span>zookeeper_home<span class="token punctuation">}</span>/conf
<span class="token function">cp</span> zoo_sample.cfg zoo.cfg
<span class="token comment"># 启动</span>
<span class="token punctuation">{</span>zookeeper_home<span class="token punctuation">}</span>/bin/zkServer.sh
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Zookeeper 有<strong>集群模式</strong>和<strong>单机模式</strong>等两种运行模式, 单机模式不过多介绍.</p> <h5 id="_2-集群模式与配置文件"><a href="#_2-集群模式与配置文件" class="header-anchor">#</a> 2.集群模式与配置文件</h5> <p>集群模式下一个简单的 zoo.cfg <strong>配置文件</strong>.</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token comment"># ZK中的时间配置最小单位(基本单位), 其他时间配置以整数倍tickTime计算, 这里是2秒</span>
tickTime=2000
<span class="token comment"># Leader允许Follower启动时在initLimit时间内完成数据同步, 它表示tickTime时间倍数 即:initLimit*tickTime, 这里是20秒</span>
initLimit=10
<span class="token comment"># Leader发送心跳包给集群中所有Follower, 若Follower在syncLimit时间内没有响应, 那么Leader就认为该Follower已经挂掉了, 即: syncLimit*tickTime, 这里为10秒</span>
syncLimit=5
<span class="token comment"># 数据存储目录</span>
dataDir=/usr/local/zookeeper/data
<span class="token comment"># 对客户端提供的端口号</span>
clientPort=2181
<span class="token comment"># 配置ZK的日志目录</span>
dataLogDir=/usr/local/zookeeper/logs
<span class="token comment"># 单个客户端与Zookeeper最大并发连接数</span>
maxClientCnxns=60
<span class="token comment"># 保存的数据快照数量, 之外的将会被清除</span>
autopurge.snapRetainCount=3
<span class="token comment"># 自动触发清除任务时间间隔, 小时为单位. 默认为0, 表示不自动清除. </span>
autopurge.purgeInterval=1
<span class="token comment"># ZK集群节点配置, 端口号2888用于集群节点之间数据通信, 端口号3888用于集群中Leader选举</span>
server.1=192.168.123.100<span class="token punctuation">:</span>2888<span class="token punctuation">:</span><span class="token number">3888</span>
server.2=192.168.123.101<span class="token punctuation">:</span>2888<span class="token punctuation">:</span><span class="token number">3888</span>
server.3=192.168.123.102<span class="token punctuation">:</span>2888<span class="token punctuation">:</span><span class="token number">3888</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>集群模式下的多个服务器配置为:</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code>server.id=host<span class="token punctuation">:</span>port<span class="token punctuation">:</span>port
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意: 其中 id 称为 <strong>Server ID</strong>, 标识该机器在集群中的<strong>机器序号</strong>; 同时需要在数据目录(即 dataDir 参数指定的目录)下创建一个 <mark><strong>myid</strong></mark> 文件, 该文件仅有<strong>一行内容, 并且是一个数字</strong>, 即对应于每台机器的 <strong>Server ID 数字</strong>.</p> <p><strong>每个服务器都需要上述配置文件和 myid 文件</strong>.</p> <h5 id="_3-集群部署示例"><a href="#_3-集群部署示例" class="header-anchor">#</a> 3.集群部署示例</h5> <p>配置语法:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>server.&lt;节点ID&gt;=&lt;ip&gt;:&lt;数据同步端口&gt;:&lt;选举端口&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>**节点 ID: ** 服务 id 手动指定 1 至 125 之间的数字, 并写到对应服务节点的  <strong>{dataDir}/myid</strong> 文件中.</li> <li><strong>IP 地址: <strong>​<strong><strong>节点的远程 IP 地址. 各结点的 IP 地址可以相同, 但这种是</strong></strong>​</strong>伪集群</strong>, 注意生产环境不能这么做, 因为一台机器无法实现容错.</li> <li><strong>数据同步端口: <strong>​<strong><strong>主从</strong></strong>​</strong>同步数据复制端口</strong>, 注意伪集群时端口号不能重复.</li> <li><strong>选举端口: <strong>​<strong><strong>主从节点</strong></strong>​</strong>选举端口</strong>, 注意伪集群时端口号不能重复.</li></ul> <p><strong>集群配置流程:</strong></p> <ul><li>分别创建 3 个 data 目录用于存储各节点数据.</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">mkdir</span> data
<span class="token function">mkdir</span> data/1
<span class="token function">mkdir</span> data/3
<span class="token function">mkdir</span> data/3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>创建 myid 文件, 并分别写入 id 号 1,2,3.</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">echo</span> <span class="token number">1</span> <span class="token operator">&gt;</span> data/1/myid
<span class="token builtin class-name">echo</span> <span class="token number">3</span> <span class="token operator">&gt;</span> data/3/myid
<span class="token builtin class-name">echo</span> <span class="token number">2</span> <span class="token operator">&gt;</span> data/2/myid
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>编写配置文件.</li></ul> <p><strong>conf/zoo1.cfg</strong></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token assign-left variable">tickTime</span><span class="token operator">=</span><span class="token number">2000</span>
<span class="token assign-left variable">initLimit</span><span class="token operator">=</span><span class="token number">10</span>
<span class="token assign-left variable">syncLimit</span><span class="token operator">=</span><span class="token number">5</span>
<span class="token assign-left variable">dataDir</span><span class="token operator">=</span>data/1
<span class="token assign-left variable">clientPort</span><span class="token operator">=</span><span class="token number">2181</span>
<span class="token comment"># 集群配置</span>
<span class="token assign-left variable">server.1</span><span class="token operator">=</span><span class="token number">127.0</span>.0.1:2887:3887
<span class="token assign-left variable">server.2</span><span class="token operator">=</span><span class="token number">127.0</span>.0.1:2888:3888
<span class="token assign-left variable">server.3</span><span class="token operator">=</span><span class="token number">127.0</span>.0.1:2889:3889
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>conf/zoo2.cfg</strong></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token assign-left variable">tickTime</span><span class="token operator">=</span><span class="token number">2000</span>
<span class="token assign-left variable">initLimit</span><span class="token operator">=</span><span class="token number">10</span>
<span class="token assign-left variable">syncLimit</span><span class="token operator">=</span><span class="token number">5</span>
<span class="token assign-left variable">dataDir</span><span class="token operator">=</span>data/2
<span class="token assign-left variable">clientPort</span><span class="token operator">=</span><span class="token number">2182</span>
<span class="token comment"># 集群配置</span>
<span class="token assign-left variable">server.1</span><span class="token operator">=</span><span class="token number">127.0</span>.0.1:2887:3887
<span class="token assign-left variable">server.2</span><span class="token operator">=</span><span class="token number">127.0</span>.0.1:2888:3888
<span class="token assign-left variable">server.3</span><span class="token operator">=</span><span class="token number">127.0</span>.0.1:2889:3889
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>conf/zoo3.cfg</strong></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token assign-left variable">tickTime</span><span class="token operator">=</span><span class="token number">2000</span>
<span class="token assign-left variable">initLimit</span><span class="token operator">=</span><span class="token number">10</span>
<span class="token assign-left variable">syncLimit</span><span class="token operator">=</span><span class="token number">5</span>
<span class="token assign-left variable">dataDir</span><span class="token operator">=</span>data/3
<span class="token assign-left variable">clientPort</span><span class="token operator">=</span><span class="token number">2183</span>
<span class="token comment"># 集群配置</span>
<span class="token assign-left variable">server.1</span><span class="token operator">=</span><span class="token number">127.0</span>.0.1:2887:3887
<span class="token assign-left variable">server.2</span><span class="token operator">=</span><span class="token number">127.0</span>.0.1:2888:3888
<span class="token assign-left variable">server.3</span><span class="token operator">=</span><span class="token number">127.0</span>.0.1:2889:3889
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>分别启动结点, 启动时分别选择配置文件启动. 如果当前只有一个启动, 整个集群是不可用的, 只有启动超过一半才行.</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>./bin/zkServer.sh start conf/zoo1.cfg
./bin/zkServer.sh start conf/zoo2.cfg
./bin/zkServer.sh start conf/zoo3.cfg
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>分别查看状态.</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>./bin/zkServer.sh status conf/zoo1.cfg
Mode: follower
./bin/zkServer.sh status conf/zoo2.cfg
Mode: leader
./bin/zkServer.sh status conf/zoo3.cfg
Mode: follower
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>分别连接指定节点: zkCli.sh 后加参数  <strong>-server</strong> 表示连接指定 IP 与端口.</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>./bin/zkCli.sh <span class="token parameter variable">-server</span> <span class="token number">127.0</span>.0.1:2181
./bin/zkCli.sh <span class="token parameter variable">-server</span> <span class="token number">127.0</span>.0.1:2182
./bin/zkCli.sh <span class="token parameter variable">-server</span> <span class="token number">127.0</span>.0.1:2183
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>任意节点中<strong>创建数据</strong>, 查看其它节点已经同步成功.</li></ul> <p>注意: -server 参数后<strong>同时连接多个服务节点</strong>, 并用逗号隔开 127.0.0.1:2181, 127.0.0.1:2182.</p> <p>通过 <code>./bin/zkServer.sh status &lt;zoo配置文件&gt;</code>​ 命令可以查看到<strong>节点状态</strong>.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>./bin/zkServer.sh status conf/zoo1.cfg
Mode: follower
./bin/zkServer.sh status conf/zoo2.cfg
Mode: leader
./bin/zkServer.sh status conf/zoo3.cfg
Mode: follower
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>可以发现中间的 <strong>2182</strong> 是 <strong>leader</strong> 状态.</p> <h3 id="二-zookeeper核心原理"><a href="#二-zookeeper核心原理" class="header-anchor">#</a> 二.ZooKeeper核心原理</h3> <h4 id="系统模型🌟"><a href="#系统模型🌟" class="header-anchor">#</a> 系统模型🌟</h4> <h5 id="_1-数据模型"><a href="#_1-数据模型" class="header-anchor">#</a> 1.数据模型</h5> <p>ZooKeeper 的视图结构和 Unix 文件系统类似, 但没有引入文件系统中目录和文件等相关概念, 而是使用了其特有的 &quot;<strong>数据结点</strong>&quot; 概念, 称之为 <strong>ZNode</strong>.</p> <p><strong>ZNode</strong> 是 ZooKeeper 中数据的最小单元, 也称为结点. 每个 ZNode 上都可以保存数据, 同时还可以挂载<strong>子结点</strong>, 因此构成了一个层次化的命名空间, 形成<strong>一颗树</strong>. 不过 ZNode 没有目录的概念, 不能执行类似 cd 之类的命令.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20211221223925381.png" alt=""></p> <h6 id="_1-事务id"><a href="#_1-事务id" class="header-anchor">#</a> (1)事务ID</h6> <p>在 ZooKeeper 中, 事务是指能够改变 ZooKeeper 服务器状态的操作, 一般包括数据结点<strong>创建与删除, 数据结点内容更新</strong>和<strong>客户端会话创建与失效</strong>等操作. 对于每一个事务请求, ZooKeeper 都会为其分配一个<strong>全局唯一的事务 ID</strong>, 用 <strong>ZXID</strong> 来表示, 通常是一个 64 位的数字. 每一个 ZXID 对应一次<strong>更新</strong>操作, 从这些 ZXID 中可以间接地识别出 ZooKeeper 处理这些更新操作请求的全局顺序.</p> <h5 id="_2-结点znode"><a href="#_2-结点znode" class="header-anchor">#</a> 2.结点ZNode</h5> <h6 id="_1-结点类型"><a href="#_1-结点类型" class="header-anchor">#</a> (1)结点类型</h6> <p><strong>每个数据结点都有其生命周期, 这取决于结点类型</strong>. 数据结点可以按照 <mark><strong>持久与否, 顺序与否</strong></mark> 分为四大类.</p> <blockquote><p><mark><strong>持久结点</strong></mark></p></blockquote> <p><strong>默认</strong>结点类型. 持久结点指该数据结点被创建后, 就会<strong>一直</strong>存在于 ZooKeeper 服务器上, 直到有删除操作来主动清除这个结点.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 默认创建持久结点</span>
create /test <span class="token string">&quot;test&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p><mark><strong>持久顺序结点</strong></mark></p></blockquote> <p>持久顺序结点的基本特性和持久结点是一致的, 额外的特性表现在<strong>顺序性</strong>上. 在 Zookeeper 中, 每个父结点都会为它的<strong>第一级子结点</strong>维护一份顺序, 用于记录下<strong>每个子结点创建的先后顺序</strong>. 在创建结点过程中, ZooKeeper 会自动为给定结点名(路径)加上一个<strong>数字后缀</strong>, 作为一个新的, 完整的结点名. 适合用于<strong>分布式选举</strong>等场景.</p> <p>创建时添加  <strong>-s</strong> 参数即可.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 创建序号结点</span>
create <span class="token parameter variable">-s</span> /test
<span class="token comment"># 返回创建的加了序号的实际路径</span>
Created /test0000000001

<span class="token comment"># 再次创建一个</span>
create <span class="token parameter variable">-s</span> /test
<span class="token comment"># 返回创建的实际路径2, 序号已递增</span>
Created /test0000000002
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><blockquote><p><mark><strong>临时结点</strong></mark></p></blockquote> <p><mark><strong>临时结点的生命周期和客户端会话绑定, 如果客户端会话失效断开连接, 那么这个结点就会被自动删除并清理掉</strong></mark>. 注意, 这里指的是客户端会话失效, 而非 TCP 连接断开. 它可以用于判断客户端是否还在连接, 如果已经断开连接, 那么结点就不在了. <mark><strong>临时结点下面不能包含子结点</strong></mark>, 所以临时结点<strong>只能做叶子结点</strong>. 适用于<strong>心跳, 服务发现等场景</strong>.</p> <p>创建时添加参数  <strong>-e</strong> 即可.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 创建临时结点, 会话端口自动删除</span>
create <span class="token parameter variable">-e</span> /temp <span class="token string">&quot;test&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p><mark><strong>临时顺序结点</strong></mark></p></blockquote> <p>基本特性和临时结点也是一致的, 同样是在临时结点的基础上增加了顺序的特性.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>create <span class="token parameter variable">-e</span> <span class="token parameter variable">-s</span> /temp/seq
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h6 id="_2-结点数据与状态信息"><a href="#_2-结点数据与状态信息" class="header-anchor">#</a> (2)结点数据与状态信息</h6> <p>一个 znode 结点包含如下信息:</p> <ul><li><strong>path</strong>: 唯一路径. 增删改查都是基于 PATH.</li> <li><strong>childNode</strong>: 子结点列表.</li> <li><strong>type</strong>: 结点类型.</li> <li><strong>data</strong>: 数据内容.</li> <li><strong>stat</strong>: 状态属性.</li></ul> <p>每个数据结点除了存储数据内容, 还存储结点本身的一些<strong>状态信息</strong>. <strong>get 命令</strong>可以获取结点信息, 得到结果的第一行是当前数据结点的<strong>数据内容</strong>, 第二行开始就是结点的<strong>状态信息</strong>. 典型的有:</p> <ul><li><strong>czxid</strong>. 即 Created ZXID, 表示数据结点<strong>被创建时的事务 ID</strong>.</li> <li><strong>mzxid</strong>. 即 Modified ZXID, 表示数据结点<strong>最后一次被更新时的事务 ID</strong>.</li> <li>ctime. 结点创建时间.</li> <li>mtime. 结点最后一次被更新时间.</li> <li><strong>version</strong>. 数据结点的版本号.</li> <li><strong>cversion</strong>. 子结点的版本号.</li> <li><strong>aversion</strong>. 结点的 ACL 版本号(权限版本变更次数).</li> <li>ephemeralOwner. 创建该临时结点的会话的 sessionID, 如果为持久结点则此属性为 0.</li> <li>numChildren. 子结点个数.</li> <li><strong>pzxid</strong>. 表示该结点子结点列表最后一次被修改时的事务 ID. 只有子结点列表变更会修改 pzxid, 子结点内容变化不会影响 pzxid.</li></ul> <p>例子:</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>cZxid <span class="token operator">=</span> 0x385
ctime <span class="token operator">=</span> Tue Sep <span class="token number">24</span> <span class="token number">17</span>:26:28 CST <span class="token number">2019</span>
mZxid <span class="token operator">=</span> 0x385 
mtime <span class="token operator">=</span> Tue Sep <span class="token number">24</span> <span class="token number">17</span>:26:28 CST <span class="token number">2019</span>
pZxid <span class="token operator">=</span> 0x385
cversion <span class="token operator">=</span> <span class="token number">0</span>
dataVersion <span class="token operator">=</span> <span class="token number">2</span>
aclVersion <span class="token operator">=</span> <span class="token number">0</span>
ephemeralOwner <span class="token operator">=</span> 0x0
dataLength <span class="token operator">=</span> <span class="token number">17</span>
numChildren <span class="token operator">=</span> <span class="token number">3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h5 id="_3-结点版本-保证分布式数据原子性操作"><a href="#_3-结点版本-保证分布式数据原子性操作" class="header-anchor">#</a> 3.结点版本(保证分布式数据原子性操作)</h5> <p>每个数据结点都有<strong>三种类型的版本信息</strong>.</p> <ul><li><strong>version</strong>. 数据结点<strong>数据内容的版本号</strong>.</li> <li><strong>cversion</strong>. 子结点的版本号.</li> <li><strong>aversion</strong>. 当前结点的 ACL 版本号.</li></ul> <p>这里 &quot;<strong>版本号</strong>&quot; 分别表示对结点<strong>数据内容, 子结点列表, 结点 ACL 信息</strong>的<strong>更新次数</strong>. 比如一个数据结点创建后, 其 version 值为 0, 表示的含义是 &quot;当前结点自创建后, 被更新过 0 次&quot;. 如果对数据内容进行了更新, version 值就会增加(只要是更新操作, 即使内容不变也会增加, 因为这里强调的是变更次数).</p> <p>版本在实现 &quot;乐观锁&quot; 场景下十分有用. 乐观锁一般分为: 数据读取, <strong>写入校验</strong>和数据写入等步骤. 比如 JDK 的 CAS, 对于值 V, 每次更新前都会对比其值是否是预期值 A, 只有符合预期, 才会将 V 原子化等更新到新值 B. ZooKeeper 中的 version 属性正是用于实现乐观锁机制中的 &quot;写入校验&quot; 的.</p> <h5 id="_4-watcher监听-数据变更通知"><a href="#_4-watcher监听-数据变更通知" class="header-anchor">#</a> 4.Watcher监听(数据变更通知)</h5> <h6 id="_1-概述"><a href="#_1-概述" class="header-anchor">#</a> (1)概述</h6> <p><strong>ZK 通过 Watcher 机制来实现分布式通知功能</strong>. ZK 允许客户端向服务端<strong>注册一个 Watcher 监听</strong>, 当服务端的特定事件触发了这个 Watcher, 就会向<strong>指定客户端发送一个事件通知</strong>来实现分布式通知功能. 整个 Watcher 注册与通知过程如下图.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20211225163152279.png" alt=""></p> <p>客户端在向 ZK 注册 Watcher 的同时也会将 Watcher 对象存储在客户端的 <strong>WatcherManager</strong> 中, 当 ZooKeeper 服务器触发 Watcher 事件后, 会向客户端发出通知, 客户端线程从 WatcherManager 取出对应的 Watcher 对象<strong>执行回调逻辑</strong>(执行 process() 方法).</p> <p><strong>客户端</strong>会记录 <strong>Watcher 与数据结点路径的映射关系</strong>. Watcher 注册完成后, 会被保存到 ZKWatcherManager 对象的 dataWatches 属性中, 其数据结构为 <code>Map&lt;String, Set&lt;Watcher&gt;&gt;</code>​, 用于将数据结点的路径和 Watcher 进行映射后管理起来.</p> <h6 id="_2-watcher特性"><a href="#_2-watcher特性" class="header-anchor">#</a> (2)Watcher特性</h6> <blockquote><p>1.一次性</p></blockquote> <p>无论是客户端还是服务端, <mark><strong>一旦一个 Watcher 被触发, Zookeeper 都会将其从相应的存储中移除</strong></mark>. 因此使用 Watcher 时需要进行<mark><strong>反复注册</strong></mark>. 使用后立即失效可以减小服务端压力, 不然需要通知的结点可能很多.</p> <blockquote><p>2.客户端串行执行</p></blockquote> <p>客户端 Watcher 回调是一个<strong>串行同步</strong>的过程. 这保证了顺序.</p> <blockquote><p>3.轻量性</p></blockquote> <p>当服务端发生了事件后, 会通过 Watcher 机制以 <strong>WatchedEvent 消息</strong>的方式告知客户端发送了事件. WatchedEvent 仅包含了<strong>通知状态, 事件类型和结点路径</strong>等三部分内容, <mark><strong>不包含事件的具体内容</strong></mark>. 例如某个结点的子结点列表发生了变更, ZooKeeper 会通过 Watcher 告知客户端此事, 但客户端无法从事件中得到数据结点的原始数据和变更后的子结点数据, <strong>客户端需要</strong>​<mark><strong>主动</strong></mark>​<strong>重新去获取数据</strong>.</p> <h5 id="_5-acl-权限控制"><a href="#_5-acl-权限控制" class="header-anchor">#</a> 5.ACL(权限控制)</h5> <p>ZK 通过 <strong>ACL(Access Control List) 权限控制机制</strong>来<strong>保证数据安全</strong>. ACL 即<strong>访问控制列表</strong>, 可以针对任意用户和组进行细粒度的权限控制.</p> <p>ACL 包含三部分内容, 分别是权限模式(Scheme), 授权对象(ID)与权限(Permission), 通常采用 &quot;<code>scheme : id : permission</code>​&quot; 来标识一个 ACL 信息.</p> <p>权限仅对当前结点有效, 不会被子结点继承.</p> <blockquote><p>权限模式(Scheme)</p></blockquote> <p>权限模式用于确定权限验证时的检验策略. 如:</p> <ul><li>IP: 通过 IP 地址进行权限控制.</li> <li>Digest: 类似于 &quot;username:password&quot; 的方式进行权限配置. <strong>用户密码</strong>认证模式, 只有在会话中添加了认证才可以防问.</li> <li>World: 所有用户都能操作数据.</li> <li>Super: 超级用户.</li></ul> <blockquote><p>授权对象(ID)</p></blockquote> <p>授权对象指权限赋予的用户或一个指定的实体, 例如是 IP 地址或机器.</p> <blockquote><p>权限(Permission)</p></blockquote> <p>权限指通过权限检查后可以执行的操作.</p> <ul><li><strong>CREATE</strong>. <strong>子结点</strong>创建权限. 允许授权对象在该结点下创建子结点.</li> <li><strong>DELETE</strong>. <strong>子结点</strong>删除权限. 允许授权对象删除该数据结点的子结点.</li> <li><strong>READ</strong>. 数据结点的读取权限. 允许授权对象访问该数据结点并读取其数据内容或子结点列表.</li> <li><strong>WRITE</strong>. 数据结点的更新权限. 允许授权对象对该数据结点进行更新操作.</li> <li><strong>ADMIN</strong>. 数据结点的管理权限. 允许授权对象对该数据结点进行 ACL 相关的设置.</li></ul> <h4 id="zk客户端"><a href="#zk客户端" class="header-anchor">#</a> ZK客户端</h4> <h5 id="_1-客户端命令"><a href="#_1-客户端命令" class="header-anchor">#</a> 1.客户端命令</h5> <blockquote><p>基本命令列表</p></blockquote> <ul><li><strong>connect host:port</strong>: 重新连接指定 ZooKeeper 服务.</li> <li><strong>create [-s] [-e] [-c] [-t ttl] path [data] [acl]</strong> : 创建结点.</li> <li><strong>delete [-v version] path</strong>: 删除结点(不能存在子结点).</li> <li><strong>deleteall path</strong>: 删除路径及所有子结点.</li> <li><strong>setquota -n|-b val path</strong>: 设置结点限额. -n 子结点数, -b 字节数.</li> <li><strong>listquota path</strong>: 查看结点限额.</li> <li><strong>delquota [-n|-b] path</strong>: 删除结点限额.</li> <li><strong>get [-s] [-w] path</strong>: 查看结点数据. -s 包含结点状态, -w 添加监听.</li> <li><strong>ls [-s] [-w] [-R] path</strong>: 列出子结点. -s 状态, -R 递归查看所有子结点, -w 添加监听.</li> <li><strong>setAcl [-s] [-v version] [-R] path acl</strong>: 为结点设置 ACL 权限.</li> <li><strong>stat [-w] path</strong>: 查看结点状态. -w 添加监听.</li></ul> <p><strong>node 数据的增删改查</strong>:</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 列出子结点 </span>
<span class="token function">ls</span> /
<span class="token comment"># 创建结点</span>
create /student <span class="token string">&quot;nano&quot;</span>
<span class="token comment"># 查看结点</span>
get /student
<span class="token comment"># 创建子结点 </span>
create /student/height <span class="token string">&quot;32&quot;</span>
<span class="token comment"># 删除结点</span>
delete /student/height
<span class="token comment"># 删除所有结点包括子结点</span>
deleteall /student
<span class="token comment"># 修改结点</span>
<span class="token builtin class-name">set</span> /student <span class="token string">&quot;woman&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h5 id="_2-java客户端"><a href="#_2-java客户端" class="header-anchor">#</a> 2.Java客户端</h5> <p>可以使用 Java 客户端进行 ZK 访问与操作. 比如 ZkClient 和 Curator 等.</p> <p>ZooKeeper 提供的客户端. 依赖:</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.zookeeper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>zookeeper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.5.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>初始连接:</strong></p> <p>常规的客户端类是 org.apache.zookeeper.<strong>ZooKeeper</strong>, 实例化该类之后将会<strong>自动与集群建立连接</strong>.</p> <p><strong>监听结点</strong>:</p> <p>在 <strong>getData()</strong>  与 <strong>getChildren()</strong>  两个方法中可分别设置<strong>监听数据变化和子结点变化</strong>. 通过<strong>设置 watch 为 true</strong>, 当前事件触发时会调用 zookeeper() 构建函数中 <strong>Watcher.process()</strong>  方法. 也可以添加 watcher 参数来实现<strong>自定义监听</strong>. 一般采用后者.</p> <p>注意: 所有的监听都是<strong>一次性的, 如果要持续监听需要触发后在添加一次监听</strong>.</p> <h5 id="_3-会话session"><a href="#_3-会话session" class="header-anchor">#</a> 3.会话Session</h5> <p>Session 指 ZK <strong>服务器与客户端</strong>会话. 一个客户端连接指客户端和服务器之间的一个 <strong>TCP 长连接</strong>. 客户端启动时, 首先会与服务器建立一个 TCP 连接, 从第一次连接建立开始, 客户端会话的生命周期也开始了. 通过这个连接, 客户端能够通过<strong>心跳检测</strong>与服务器保持有效的会话, 也能够向服务器发送请求并接受响应, 同时还能够通过该<strong>连接接收来自服务器的 Watch 事件通知</strong>.</p> <p>Session 的 sessionTimeout 参数用来设置一个客户端会话的<strong>超时时间</strong>. 即使因为网络故障或是客户端主动断开连接等各种原因导致客户端连接断开, 只要在 sessionTimeout 时间内能够重新连接上集群中任意一台服务器, 那么之前创建的会话仍然有效.</p> <p>在为客户端创建会话之前, 服务端首先会为每个客户端都分配一个 <strong>sessionID</strong>. 由于 sessionID 是 Zookeeper 会话的一个重要标识, 许多与会话相关的运行机制都是基于这个 sessionID 的, 因此无论是哪台服务器为客户端分配的 sessionID, 都务必保证<strong>全局唯一</strong>.</p> <p>会话还有对应的<strong>事件</strong>, 如 CONNECTION_LOSS(连接丢失事件), SESSION_MOVED(会话转移事件), SESSION_EXPIRED(会话超时失效事件).</p> <h5 id="_4-客户端会话创建过程"><a href="#_4-客户端会话创建过程" class="header-anchor">#</a> 4.客户端会话创建过程</h5> <p>Zookeeper 客户端核心组件如下:</p> <ul><li>Zookeeper 实例. 客户端的入口.</li> <li>ClientWatchManage. 客户端的 Watcher 管理器.</li> <li>HostProvider. 客户端地址列表管理器.</li> <li><strong>ClientCnxn</strong>. 客户端核心线程, 其内部包含 SendThread 和 EventThread 两个线程. SendThread 是一个 IO 线程, 负责 Zookeeper 客户端与服务器之间的网络 IO 通信. EventThread 是一个事件线程, 负责对服务端的事件进行处理.</li></ul> <p><strong>(1) 初始化阶段</strong></p> <ul><li>初始化 Zookeeper 对象.</li> <li>设置会话默认 Watcher.</li> <li>构造 Zookeeper 服务器地址列表管理器 HostProvider.</li> <li>创建并初始化客户端网络连接器 ClientCnxn. 创建 ClientCnxn 的同时, 还会创建客户端的两个核心队列: outgoingQueue(客户端请求发送队列)和 pendingQueue(服务端响应等待队列).</li> <li>初始化 SendThread 和 EventThread.</li></ul> <p><strong>(2) 会话创建阶段</strong></p> <ul><li>启动 SendThread 和 EventThread.</li> <li>获取一个服务器地址.</li> <li>创建 TCP 连接. ClientCnxnSocket 负责与服务器创建一个 TCP 长连接.</li> <li>构造 ConnectRequest 请求.</li> <li>发送请求.</li></ul> <p><strong>(3) 响应处理阶段</strong></p> <ul><li>接收服务端响应.</li> <li>处理 response.</li> <li>查询 Watcher.</li> <li>处理事件. EventThread 不断从 waitingEvents 队列中取出待处理的 Watcher 对象, 然后直接调用该对象的 process 方法进行事件回调.</li></ul> <h4 id="序列化与协议"><a href="#序列化与协议" class="header-anchor">#</a> 序列化与协议</h4> <p>Zookeeper 客户端与服务端会进行一些列网络数据传输, ZooKeeper 使用 <strong>Jute</strong> 序列化组件实现通信数据的序列化与反序列化操作.</p> <p>Zookeeper 设计了基于 TCP/IP 协议的独有的<strong>应用层通信协议</strong>, 实现数据的高效传输.</p> <h4 id="服务器启动流程分析"><a href="#服务器启动流程分析" class="header-anchor">#</a> 服务器启动流程分析</h4> <p>Zookeeper 服务端整体架构如下:</p> <p>​<img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220106231854447.png" alt="">​</p> <p>Zookeeper 服务器的启动大致可以分为以下五个步骤:</p> <ol><li>配置文件解析.</li> <li>初始化数据管理器.</li> <li>初始化网络 IO 管理器.</li> <li>数据恢复.</li> <li>对外服务.</li></ol> <h5 id="_1-单机版服务器启动"><a href="#_1-单机版服务器启动" class="header-anchor">#</a> 1.单机版服务器启动</h5> <p>单机版服务器的启动其流程图如下.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220106232948829.png" alt="image-20220106232948829"></p> <p>上图的过程可以分为<strong>预启动</strong>和<strong>初始化</strong>过程.</p> <blockquote><p>(1)预启动</p></blockquote> <ol><li>统一由 QuorumPeerMain 作为<strong>启动类</strong>. 无论单机或集群, 在 zkServer.cmd 和 zkServer.sh 中都配置了 QuorumPeerMain 作为启动入口类.</li> <li>解析配置文件 zoo.cfg. zoo.cfg 配置运行时基本参数, 如 tickTime, dataDir, clientPort 等.</li> <li>创建并启动历史文件清理器 DatadirCleanupManager. 对事务日志和快照数据文件进行定时清理.</li> <li>判断当前是集群还是单机模式启动. 若是单机模式, 则委托给 ZooKeeperServerMain 进行启动.</li> <li>再次解析配置文件 zoo.cfg.</li> <li>创建服务器实例 ZooKeeperServer. ZooKeeper 服务器首先会进行服务器实例的创建, 然后对该服务器实例进行初始化, 包括连接器, 内存数据库, 请求处理器等组件的初始化.</li></ol> <blockquote><p>(2)初始化</p></blockquote> <ol><li>创建服务器统计器 ServerStats. ServerStats 是 Zookeeper 服务器运行时的统计器.</li> <li>创建 Zookeeper 数据管理器 FileTxnSnapLog. FileTxnSnapLog 是 Zookeeper 上层服务器和底层数据存储之间的对接层, 提供了一系列操作数据文件的接口, 如事务日志文件和快照数据文件. Zookeeper 根据 zoo.cfg 文件中解析出的快照数据目录 dataDir 和事务日志目录 dataLogDir 来创建 FileTxnSnapLog.</li> <li>设置服务器 tickTime 和会话超时时间限制.</li> <li>创建 ServerCnxnFactory. 通过配置系统属性 zookeper.serverCnxnFactory 来指定使用 Zookeeper 自己实现的 NIO 还是使用 Netty 框架作为 Zookeeper 服务端网络连接工厂.</li> <li>初始化 ServerCnxnFactory. Zookeeper 会初始化 Thread 作为 ServerCnxnFactory 的主线程, 然后再初始化 NIO 服务器.</li> <li>启动 ServerCnxnFactory 主线程. 进入 Thread 的 run 方法, 此时服务端还不能处理客户端请求.</li> <li>恢复本地数据. 启动时, 需要从本地快照数据文件和事务日志文件进行数据恢复.</li> <li>创建并启动会话管理器. Zookeeper 会创建会话管理器 SessionTracker 进行会话管理.</li> <li>初始化 Zookeeper 的请求处理链. Zookeeper 请求处理方式为<strong>责任链模式</strong>的实现. 会有多个请求处理器依次处理一个客户端请求, 在服务器启动时, 会将这些请求处理器串联成一个请求处理链.</li> <li>注册 JMX 服务. Zookeeper 会将服务器运行时的一些信息以 JMX 的方式暴露给外部.</li> <li>注册 Zookeeper 服务器实例. 将 Zookeeper 服务器实例注册给 ServerCnxnFactory, 之后 Zookeeper 就可以对外提供服务.</li></ol> <p>至此, 单机版的 Zookeeper 服务器启动完毕.</p> <h5 id="_2-集群版服务器启动"><a href="#_2-集群版服务器启动" class="header-anchor">#</a> 2.集群版服务器启动</h5> <p>单机和集群服务器的启动在很多地方是一致的, 其流程图如下.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220106233835547.png" alt="image-20220106233835547"></p> <p>上图的过程可以分为<strong>预启动, 初始化, Leader选举, Leader 与 Follower 启动期交互过程, Leader 与 Follower 启动</strong>等过程.</p> <blockquote><p>(1)预启动</p></blockquote> <ol><li>统一由 QuorumPeerMain 作为启动类.</li> <li>解析配置文件 zoo.cfg.</li> <li>创建并启动历史文件清理器 DatadirCleanupFactory.</li> <li>判断当前是集群还是单机模式的启动. 在集群模式中, 在 zoo.cfg 文件中配置了多个服务器地址, 可以选择集群启动.</li></ol> <blockquote><p>(2)初始化</p></blockquote> <ol><li>创建 ServerCnxnFactory.</li> <li>初始化 ServerCnxnFactory.</li> <li>创建 Zookeeper 数据管理器 FileTxnSnapLog.</li> <li>创建 QuorumPeer 实例. Quorum 是集群模式下特有的对象, 是 Zookeeper 服务器实例(ZooKeeperServer)的托管者, QuorumPeer 代表了集群中的一台机器, 在运行期间, QuorumPeer 会不断检测当前服务器实例的运行状态, 同时根据情况发起 Leader 选举.</li> <li>创建<strong>内存数据库</strong> ZKDatabase. ZKDatabase 负责管理 ZooKeeper 的所有会话记录以及 DataTree 和事务日志的存储.</li> <li>初始化 QuorumPeer. 将核心组件如 FileTxnSnapLog, ServerCnxnFactory, ZKDatabase 注册到 QuorumPeer 中, 同时配置 QuorumPeer 的参数, 如服务器列表地址, Leader 选举算法和会话超时时间限制等.</li> <li>恢复本地数据.</li> <li>启动 ServerCnxnFactory 主线程.</li></ol> <blockquote><p>(3)Leader选举</p></blockquote> <ol><li><strong>初始化 Leader 选举</strong>. 集群模式特有, Zookeeper 首先会根据自身的服务器 ID(SID), 最新的 ZXID(lastLoggedZxid) 和当前的服务器 epoch(currentEpoch) 来生成一个<strong>初始化投票</strong>, 在初始化过程中, 每个服务器都会给自己投票. 然后根据 zoo.cfg 配置创建相应 Leader 选举算法实现, Zookeeper 提供三种默认算法(LeaderElection, AuthFastLeaderElection, FastLeaderElection), 可通过 zoo.cfg 中的 electionAlg 属性来指定. 在初始化阶段, Zookeeper 会创建 Leader 选举所需的网络 I/O 层 QuorumCnxManager, 同时启动对 Leader 选举端口的监听, 等待集群中其他服务器创建连接.</li> <li>注册 JMX 服务.</li> <li>检测当前服务器状态. 运行期间, QuorumPeer 会不断检测当前服务器状态. 正常情况下, Zookeeper 服务器的状态在 LOOKING, LEADING, FOLLOWING/OBSERVING 之间进行切换. 在启动阶段, QuorumPeer 的初始状态是 LOOKING, 因此开始进行 Leader 选举.</li> <li><strong>Leader 选举</strong>. 通过投票确定 Leader, 其余机器称为 Follower 和 Observer. 具体算法在后面会给出.</li></ol> <blockquote><p>(4)Leader和Follower启动期交互过程</p></blockquote> <ol><li><strong>创建 Leader 服务器和 Follower 服务器</strong>. 完成 Leader 选举后, 每个服务器会根据自己服务器的角色创建相应的服务器实例, 并进入各自角色的主流程.</li> <li>Leader 服务器启动 Follower 接收器 LearnerCnxAcceptor. 运行期间, Leader 服务器需要和所有其余的服务器(统称为 Learner)保持连接以确集群的机器存活情况, LearnerCnxAcceptor 负责接收所有非 Leader 服务器的连接请求.</li> <li>Leader 服务器开始和 Leader 建立连接. 所有 Learner 会找到 Leader 服务器, 并与其建立连接.</li> <li>Leader 服务器创建 LearnerHandler. Leader 接收到来自其他机器连接创建请求后, 会创建一个 LearnerHandler 实例, 每个 LearnerHandler 实例都对应一个 Leader 与 Learner 服务器之间的连接, 其负责 Leader 和 Learner 服务器之间几乎所有的消息通信和数据同步.</li> <li>向 Leader 注册. Learner 完成和 Leader 的连接后, 会向 Leader 进行注册, 即将 Learner 服务器的基本信息(LearnerInfo), 包括 SID 和 ZXID, 发送给 Leader 服务器.</li> <li>Leader 解析 Learner 信息, 计算新的 epoch. Leader 接收到 Learner 服务器基本信息后, 会解析出该 Learner 的 SID 和 ZXID, 然后根据 ZXID 解析出对应的 epoch_of_learner, 并和当前 Leader 服务器的 epoch_of_leader 进行比较, 如果该 Learner 的 epoch_of_learner 更大, 则更新 Leader 的 epoch_of_leader = epoch_of_learner + 1. 然后 LearnHandler 进行等待, 直到过半 Learner 已经向 Leader 进行了注册, 同时更新了 epoch_of_leader 后, Leader 就可以确定当前集群的 epoch 了.</li> <li>发送 Leader 状态. 计算出新的 epoch 后, Leader 会将该信息以一个 LEADERINFO 消息的形式发送给 Learner, 并等待 Learner 的响应.</li> <li>Learner 发送 ACK 消息. Learner 接收到 LEADERINFO 后, 会解析出 epoch 和 ZXID, 然后向 Leader 反馈一个 ACKEPOCH 响应.</li> <li>数据同步. Leader 收到 Learner 的 ACKEPOCH 后, 即可进行数据同步.</li> <li>启动 Leader 和 Learner 服务器. 当有过半 Learner 已经完成了数据同步, 那么 Leader 和 Learner 服务器实例就可以启动了.</li></ol> <blockquote><p>(5)Leader和Follower启动</p></blockquote> <ol><li>创建启动会话管理器.</li> <li>初始化 Zookeeper 请求处理链, 集群模式的每个处理器也会在启动阶段串联请求处理链.</li> <li>注册 JMX 服务.</li></ol> <p>至此, 集群版的 Zookeeper 服务器启动完毕.</p> <h4 id="leader选举与zab协议🌟"><a href="#leader选举与zab协议🌟" class="header-anchor">#</a> Leader选举与ZAB协议🌟</h4> <h5 id="_1-集群与服务器角色"><a href="#_1-集群与服务器角色" class="header-anchor">#</a> 1.集群与服务器角色</h5> <p>ZooKeeper 服务器集群中有 <strong>Leader, Follower 和 Observer</strong> 三种类型角色.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220106234805740.png" alt="image-20220106234805740"></p> <p>ZooKeeper 集群中的所有机器通过一个 <strong>Leader 选举过程</strong>来选定一台 &quot;Leader&quot; 机器, Leader 既可以<strong>为客户端提供写服务又能提供读服务</strong>. 除 Leader 外, Follower 和 Observer 都只能提供<strong>读服务</strong>. Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程, 也不参与写操作的 &quot;<strong>过半写成功</strong>&quot; 策略, 因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能.</p> <h6 id="_1-leader"><a href="#_1-leader" class="header-anchor">#</a> (1)Leader</h6> <p>Leader 服务器是 ZK 集群工作的核心, 是集群中唯一的<strong>写请求</strong>处理者, 其主要工作如下:</p> <ul><li>事务请求的唯一调度和处理者, 保证集群事务处理的顺序性.</li> <li>集群内部各服务器的调度者.</li></ul> <blockquote><p>请求处理链</p></blockquote> <p>Zookeeper <strong>使用责任链来处理每个客户端的请求</strong>, Leader 服务器的请求<strong>处理链</strong>如下:</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220107201550224.png" alt="image-20220107201550224"></p> <p>典型的处理器有:</p> <ul><li>PrepRequestProcessor. 请求预处理器.</li> <li>ProposalRequestProcessor. 事务投票处理器.</li> <li>SyncRequestProcessor. 事务日志记录处理器.</li></ul> <blockquote><p>LearnerHandler</p></blockquote> <p>为了保证整个集群内部的实时通信, 同时为了确保可以控制所有的 Follower/Observer 服务器, Leader 服务器会与每个 Follower/Observer 服务器建立一个 <strong>TCP 长连接</strong>. 同时也会为每个 Follower/Observer 服务器创建一个名为 LearnerHandler 的实体. LearnerHandler 是 Learner 服务器的管理者, 主要负责 Follower/Observer 服务器和 Leader 服务器之间的一系列网络通信, 包括数据同步, 请求转发和 Proposal 提议的投票等. Leader 服务器中保存了所有 Follower/Observer 对应的LearnerHandler.</p> <h6 id="_2-follower"><a href="#_2-follower" class="header-anchor">#</a> (2)Follower</h6> <p>Follower 是 ZooKeeper 集群中的<strong>跟随者</strong>, 其主要工作如下:</p> <ul><li><strong>处理客户端非事务性请求(读取数据), 转发事务请求给 Leader 服务器</strong>.</li> <li>参与事务请求 Proposal 的投票.</li> <li>参与 Leader 选举投票.</li></ul> <p>Follower 也采用了<strong>责任链模式</strong>组装的请求处理链来处理每一个客户端请求, 由于不需要对事务请求的投票处理, 因此 Follower 的请求处理链相对简单.</p> <h6 id="_3-observer"><a href="#_3-observer" class="header-anchor">#</a> (3)Observer</h6> <p>Observer 充当<strong>观察者</strong>角色, 观察 Zookeeper 集群的最新状态变化并将这些状态同步过来, 其对于非事务请求可以进行独立处理, 对于事务请求, 则会转发给 Leader 服务器进行处理. Observer 不会参与任何形式的投票, 包括事务请求 Proposal 的投票和 Leader 选举投票.</p> <h5 id="_2-zab协议与leader选举概述"><a href="#_2-zab协议与leader选举概述" class="header-anchor">#</a> 2.ZAB协议与Leader选举概述</h5> <p><mark><strong>为达成集群数据一致性, ZooKeeper 并没有完全采用 Paxos 算法, 而是使用 ZAB(ZooKeeper Atomic Broadcast 原子广播)协议作为其保证分布式数据一致性的核心算法</strong></mark>. ZAB 协议并不像 Paxos 算法那样是一种通用的分布式一致性算法, 它是一种<strong>特别为 Zookeeper 设计的崩溃可恢复的原子消息广播算法</strong>. 基于该协议, ZooKeeper 实现了一种<strong>主备模式</strong>的系统架构来保持集群中各个副本之间的数据一致性.</p> <p>Leader 选举是保证分布式数据一致性的关键所在. 当 Zookeeper 集群中的一台服务器出现以下两种情况之一时, 需要进入 Leader 选举.</p> <ul><li>服务器<strong>初始化</strong>启动.</li> <li>服务器<strong>运行期间无法和 Leader 保持连接</strong>.</li></ul> <p>下面就两种情况进行分析讲解.</p> <h6 id="_1-服务器启动时期的leader选举"><a href="#_1-服务器启动时期的leader选举" class="header-anchor">#</a> (1)服务器启动时期的Leader选举</h6> <p>进行选举至少需要 2 台服务器, 这里以 3 台机器的集群为例说明. 在集群初始化阶段, 当服务器 Server1 启动时, 其单独无法进行和完成 Leader 选举; 当服务器 Server2 启动时, 此时两台机器可以相互通信, 每台机器都试图找到 Leader, 于是进入 Leader 选举过程.</p> <p>选举过程如下:</p> <ol><li><p><strong>每个 Server 发出一个投票</strong>. 由于是初始情况, Server1 和 Server2 都会将<strong>自己</strong>作为 Leader 服务器来进行投票, 每次投票会包含所推举的服务器的 myid 和 ZXID, 使用  <strong>(myid, ZXID)</strong>  来表示, 此时 Server1 的投票为 (1, 0), Server2 的投票为 (2, 0), 然后各自将这个投票发给集群中其他机器.</p></li> <li><p><strong>接受来自各个服务器的投票</strong>. 集群的每个服务器收到投票后, 首先判断该投票的有效性, 如检查是否是本轮投票, 是否来自 LOOKING 状态的服务器.</p></li> <li><p><strong>处理投票</strong>. 针对每一个投票, 服务器都需要将别人的投票和自己的投票进行 PK, PK 规则如下:</p> <ul><li><strong>优先检查 ZXID</strong>. ZXID 比较大的服务器优先作为 Leader.</li> <li><strong>如果 ZXID 相同, 那么就比较 myid</strong>. myid 较大的服务器作为 Leader 服务器.</li></ul> <p>对于 Server1 而言, 它的投票是 (1, 0), 接收 Server2 的投票为(2, 0), 首先会比较两者的 ZXID, 均为 0, 再比较 myid, 此时 Server2 的 myid 最大, 于是更新自己的投票为 (2, 0), 然后重新投票. 对于 Server2 而言, 其无须更新自己的投票, 只是再次向集群中所有机器发出上一次投票信息即可.</p></li> <li><p><strong>统计投票</strong>. 每次投票后, 服务器都会统计投票信息, 判断是否已经有过半机器接受到相同的投票信息, 对于 Server1, Server2 而言, 都统计出集群中已经有两台机器接受了 (2, 0) 的投票信息, 此时便认为已经选出了 Leader.</p></li> <li><p><strong>改变服务器状态</strong>. 一旦确定了 Leader, 每个服务器就会更新自己的状态, 如果是 Follower, 那么就变更为 FOLLOWING, 如果是 Leader, 就变更为 LEADING.</p></li></ol> <h6 id="_2-服务器运行时期的leader选举"><a href="#_2-服务器运行时期的leader选举" class="header-anchor">#</a> (2)服务器运行时期的Leader选举</h6> <p>在 ZK 运行期间, 有非 Leader 服务器宕机或新加入也不会影响 Leader, 但一旦 Leader 服务器挂了, 那么整个集群将<strong>暂停</strong>对外服务, 进入新一轮 Leader 选举, 其过程和启动时期的选举过程基本一致.</p> <p>假设正在运行的有 Server1, Server2, Server3 三台服务器, 当前 Leader 是 Server2, 若某一时刻 Leader 挂了, 此时便开始 Leader 选举.</p> <p>选举过程如下:</p> <ol><li><strong>变更状态</strong>. Leader 挂后, 余下的非 Observer 服务器都会将自己的状态变更为 LOOKING, 然后开始进入 Leader 选举过程.</li> <li><strong>每个 Server 发出一个投票</strong>. 在运行期间, 每个服务器上的 ZXID 可能<strong>不同</strong>, 此时假定 Server1 的 ZXID 为 123, Server3 的 ZXID 为 122; 在第一轮投票中, Server1 和 Server3 都会投<strong>自己</strong>, 产生投票 (1, 123), (3, 122), 然后各自将投票发送给集群中所有机器.</li> <li><strong>接收来自各个服务器的投票</strong>. 与启动时过程相同.</li> <li><strong>处理投票</strong>. 与启动时过程相同, 此时 Server1 将会成为 Leader.</li> <li><strong>统计投票</strong>. 与启动时过程相同.</li> <li><strong>改变服务器的状态</strong>. 与启动时过程相同.</li></ol> <h5 id="_3-leader选举算法分析"><a href="#_3-leader选举算法分析" class="header-anchor">#</a> 3.Leader选举算法分析</h5> <p>在 3.4.0 后的 ZK 版本只保留了 TCP 版本的 <strong>FastLeaderElection</strong> 选举算法.</p> <h6 id="_1-术语解释"><a href="#_1-术语解释" class="header-anchor">#</a> (1)术语解释</h6> <ul><li><strong>SID(服务器ID)</strong> : 一个数字, 标识 ZK 集群中的一台机器, 每台机器不能重复. SID 与 <strong>myid</strong> 的值一致.</li> <li><strong>ZXID(事务ID)</strong> : ZXID 是一个事务 ID, 用来唯一标识因此服务器状态的变更. 在某一个时刻, 集群中每台机器的 ZXID 值<strong>不一定完全都一致</strong>.</li> <li><strong>Vote(投票)</strong> : Leader 选举需通过投票实现, 当集群中的机器发现自己无法检测到 Leader 机器的时候, 就会开始尝试进行投票.</li> <li><strong>Quorum(过半数机器</strong>): 一个量词, 通常指过半数的机器.</li></ul> <h6 id="_2-算法流程分析"><a href="#_2-算法流程分析" class="header-anchor">#</a> (2)算法流程分析</h6> <p>当一台机器进入 Leader 选举时, 当前集群可能会处于以下两种状态:</p> <ul><li>集群中已经存在 Leader.</li> <li>集群中不存在 Leader.</li></ul> <p>对于<strong>集群中已经存在 Leader</strong> 而言, 比如集群加入新机器. 这种情况下新机器试图去选举 Leader 时, 会被告知当前服务器的 Leader 信息, 对于新机器而言, 仅仅需要和 Leader 机器建立连接并进行状态同步即可.</p> <p>而在<strong>集群中不存在 Leader</strong> 情况下则会相对复杂, 其步骤如下:</p> <blockquote><p>1.第一次投票</p></blockquote> <p>无论哪种情况导致进行 Leader 选举, 集群的所有机器都处于<strong>试图选举出一个 Leader 的状态</strong>, 即 <strong>LOOKING</strong> 状态, LOOKING 机器会向所有其他机器发送消息, 该消息称为<strong>投票</strong>. 投票中包含了 SID(服务器的唯一标识) 和 ZXID(事务ID),  <strong>(SID, ZXID) 形式来标识一次投票信息</strong>.</p> <p>假设集群由 5 台机器组成, SID 分别为 1, 2, 3, 4, 5, ZXID 分别为 9, 9, 9, 8, 8, 并且此时 SID 为 2 的机器是 Leader 机器, 某一时刻, 1, 2 所在机器出现故障, 因此集群开始进行 Leader 选举. 在第一次投票时, 每台机器都会将<strong>自己</strong>作为投票对象, 于是 SID 为 3, 4, 5 的机器投票情况分别为 (3, 9), (4, 8), (5, 8).</p> <blockquote><p>2.变更投票</p></blockquote> <p>每台机器发出投票后, 也会<strong>收到</strong>其他机器的投票, 每台机器会根据一定规则来处理收到的其他机器的投票, 并以此来决定是否需要变更自己的投票, 这个规则也是整个 Leader 选举算法的核心所在, 其描述如下:</p> <ul><li><strong>vote_sid</strong>: 接收到的投票中所推举 Leader 服务器的 SID.</li> <li><strong>vote_zxid</strong>: 接收到的投票中所推举 Leader 服务器的 ZXID.</li> <li><strong>self_sid</strong>: 当前服务器自己的 SID.</li> <li><strong>self_zxid</strong>: 当前服务器自己的 ZXID.</li></ul> <p>每次对收到的投票的处理, 都是对  <strong>(vote_sid, vote_zxid)</strong>  和  <strong>(self_sid, self_zxid)</strong>  进行对比的过程.</p> <ul><li><strong>规则一</strong>: 如果 vote_zxid 大于 self_zxid, 就认可当前收到的投票, 并再次将该投票发送出去.</li> <li><strong>规则二</strong>: 如果 vote_zxid 小于 self_zxid, 那么坚持自己的投票, 不做任何变更.</li> <li><strong>规则三</strong>: 如果 vote_zxid 等于 self_zxid, 那么就对比两者的 SID, 如果 vote_sid 大于 self_sid, 那么就认可当前收到的投票, 并再次将该投票发送出去.</li> <li><strong>规则四</strong>: 如果 vote_zxid 等于 self_zxid, 并且 vote_sid 小于 self_sid, 那么坚持自己的投票, 不做任何变更.</li></ul> <p>简而言之就是: <mark><strong>ZXID 大的优先, ZXID 相同时 SID 大的优先</strong></mark>.</p> <p>结合上面规则, 给出下面的集群变更过程.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220107210442583.png" alt="image-20220107210442583"></p> <blockquote><p>3.确定Leader</p></blockquote> <p>经过第二轮投票后, 集群中的每台机器都会再次接收到其他机器的投票, 然后开始统计投票, 如果一台机器收到了<strong>超过半数</strong>的相同投票, 那么这个投票对应的 SID 机器即为 Leader. 此时 Server3 将成为 Leader.</p> <p>由上面规则可知, <mark><strong>通常哪台服务器上的数据越新(ZXID 会越大), 其成为 Leader 的可能性越大, 也就越能够保证数据的恢复. 如果 ZXID 相同, 则 SID 越大机会越大</strong></mark>.</p> <h5 id="_4-leader选举实现细节"><a href="#_4-leader选举实现细节" class="header-anchor">#</a> 4.Leader选举实现细节</h5> <h6 id="_1-服务器状态"><a href="#_1-服务器状态" class="header-anchor">#</a> (1)服务器状态</h6> <p>服务器具有<strong>四种状态</strong>, 分别是 LOOKING, FOLLOWING, LEADING, OBSERVING.</p> <ul><li><strong>LOOKING</strong>: 寻找 Leader 状态. 当服务器处于该状态时, 它会认为当前集群中没有 Leader, 因此需要进入 Leader 选举状态.</li> <li><strong>FOLLOWING</strong>: 跟随者状态. 表明当前服务器角色是 Follower.</li> <li><strong>LEADING</strong>: 领导者状态. 表明当前服务器角色是 Leader.</li> <li><strong>OBSERVING</strong>: 观察者状态. 表明当前服务器角色是 Observer.</li></ul> <h6 id="_2-投票数据结构"><a href="#_2-投票数据结构" class="header-anchor">#</a> (2)投票数据结构</h6> <p>每个投票中包含了两个最基本的信息, 所推举服务器的 <strong>SID 和 ZXID</strong>, 投票(Vote) 在 ZK 中包含字段如下:</p> <ul><li><strong>id</strong>: 被推举的 Leader 的 SID.</li> <li><strong>zxid</strong>: 被推举的 Leader 事务 ID.</li> <li><strong>electionEpoch</strong>: 逻辑时钟, 用来判断多个投票是否在<strong>同一轮选举周期</strong>中, 该值在服务端是一个自增序列, 每次进入新一轮的投票后, 都会对该值进行加 1 操作.</li> <li><strong>peerEpoch</strong>: 被推举的 Leader 的 epoch.</li> <li><strong>state</strong>: 当前服务器的状态.</li></ul> <h6 id="_3-quorumcnxmanager-网络i-o"><a href="#_3-quorumcnxmanager-网络i-o" class="header-anchor">#</a> (3)QuorumCnxManager(网络I/O)</h6> <p>每台服务器在启动过程中, 会启动一个 QuorumPeerManager, 负责各台服务器之间的底层 Leader 选举过程中的网络通信.</p> <blockquote><p>1.消息队列</p></blockquote> <p>QuorumCnxManager 内部维护了一系列的队列, 用来保存接收到的, 待发送的消息以及消息的发送器, 除接收队列以外, 其他队列都按照 SID 分组形成队列集合, 如一个集群中除了自身还有 3 台机器, 那么就会为这 3 台机器分别创建一个发送队列, 互不干扰.</p> <ul><li><strong>recvQueue</strong>: 消息接收队列, 用于存放那些从其他服务器接收到的消息.</li> <li><strong>queueSendMap</strong>: 消息发送队列, 用于保存那些待发送的消息, 按照 SID 进行分组.</li> <li><strong>senderWorkerMap</strong>: 发送器集合, 每个 SenderWorker 消息发送器, 都对应一台远程 ZK 服务器, 负责消息的发送, 也按照 SID 进行分组.</li> <li><strong>lastMessageSent</strong>: 最近发送过的消息, 为每个 SID 保留最近发送过的一个消息.</li></ul> <blockquote><p>2.建立连接</p></blockquote> <p>为了能够相互投票, ZK 集群中的所有机器都需要两两建立网络连接. QuorumCnxManager 在启动时会创建一个 ServerSocket 来监听 Leader 选举的通信端口(默认为 3888). 开启监听后, ZK 能够不断地接收到来自其他服务器的创建连接请求, 在接收到其他服务器的 TCP 连接请求时, 会进行处理. 一旦连接建立, 就会根据远程服务器的 SID 来创建相应的消息发送器 SendWorker 和消息接收器 RecvWorker, 并启动.</p> <blockquote><p>3.消息接收与发送</p></blockquote> <p><strong>消息接收</strong>: 由消息接收器 RecvWorker 负责, 由于 Zookeeper 为每个远程服务器都分配一个单独的 RecvWorker, 因此每个 RecvWorker 只需要不断地从这个 TCP 连接中读取消息, 并将其保存到 recvQueue 队列中.</p> <p><strong>消息发送</strong>: 由于 ZK 为每个远程服务器都分配一个单独的 SendWorker, 因此每个 SendWorker 只需要不断地从对应的消息发送队列中获取出一个消息发送即可, 同时将这个消息放入 lastMessageSent 中. 在 SendWorker 中, 一旦 Zookeeper 发现针对当前服务器的消息发送队列为空, 那么此时需要从 lastMessageSent 中取出一个最近发送过的消息来进行再次发送, 这是为了解决接收方在消息接收前或者接收到消息后服务器挂了, 导致消息尚未被正确处理.</p> <h6 id="_4-fastleaderelection-选举算法核心"><a href="#_4-fastleaderelection-选举算法核心" class="header-anchor">#</a> (4)FastLeaderElection(选举算法核心)</h6> <p>几个核心概念:</p> <ul><li><strong>外部投票</strong>: 特指其他服务器发来的投票.</li> <li><strong>内部投票</strong>: 服务器自身当前的投票.</li> <li><strong>选举轮次</strong>: Leader 选举的轮次, 即 logicalclock.</li> <li><strong>PK</strong>: 对内部投票和外部投票进行对比来确定是否需要变更内部投票.</li></ul> <blockquote><p>1.选票管理</p></blockquote> <p>下图是选票管理过程中相关组件之间的协作关系.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220107210956395.png" alt=""></p> <ul><li><strong>sendqueue</strong>: 选票发送队列, 用于保存待发送的选票.</li> <li><strong>recvqueue</strong>: 选票接收队列, 用于保存接收到的外部投票.</li> <li><strong>WorkerReceiver</strong>: 选票接收器. 其会不断地从 QuorumCnxManager 中获取其他服务器发来的选举消息, 并将其转换成一个选票, 然后保存到 recvqueue 中, 在选票接收过程中, 如果发现该外部选票的选举轮次小于当前服务器的, 那么忽略该外部投票, 同时立即发送自己的内部投票.</li> <li><strong>WorkerSender</strong>: 选票发送器, 不断地从 sendqueue 中获取待发送的选票, 并将其传递到底层 QuorumCnxManager 中.</li></ul> <blockquote><p>2.算法核心</p></blockquote> <p>上图展示了 FastLeaderElection 模块是如何与底层网络 I/O 进行交互的. Leader 选举的基本流程如下:</p> <p>(1) ** 自增选举轮次**. Zookeeper 规定所有有效的投票都必须在同一轮次中, 在开始新一轮投票时, 会首先对 logicalclock 进行自增操作.</p> <p>(2) ** 初始化选票**. 在开始进行新一轮投票之前, 每个服务器都会初始化自身的选票, 每台服务器在初始化阶段都会将自己推举为 Leader.</p> <p>(3) ** 发送初始化选票**. 完成选票的初始化后, 服务器就会发起第一次投票. ZK 会将刚刚初始化好的选票放入 sendqueue 中, 由发送器 WorkerSender 发送出去.</p> <p>(4) ** 接收外部投票**. 每台服务器会不断从 recvqueue 队列中获取外部选票.</p> <p>(5) ** 判断选举轮次**. 在发送完初始化选票之后, 接着开始处理外部投票. 在处理外部投票时, 会根据<strong>选举轮次</strong>来进行不同的处理.</p> <ul><li><strong>外部投票的选举轮次大于内部投票</strong>. 若服务器自身的选举轮次落后于该外部投票对应服务器的选举轮次, 那么就会立即<strong>更新自己的选举轮次</strong>(logicalclock), 并清空所有已经收到的投票, 然后使用初始化的投票来进行 PK 以确定是否变更内部投票. 最终再将内部投票发送出去.</li> <li><strong>外部投票的选举轮次小于内部投票</strong>. 若服务器接收的外选票的选举轮次落后于自身的选举轮次, 那么 ZK 就会直接<strong>忽略该外部投票</strong>, 不做任何处理, 并返回步骤 4.</li> <li><strong>外部投票的选举轮次等于内部投票</strong>. 此时可以开始进行选票 PK.</li></ul> <p>(6) ** 选票PK**. 在进行选票 PK 时, 符合任意一个条件就需要变更投票.</p> <ul><li>若外部投票中推举的 Leader 服务器的<strong>选举轮次</strong>大于内部投票, 那么需要变更投票.</li> <li>若选举轮次一致, 那么就对比两者的 ZXID, 若外部投票的 ZXID 大, 那么需要变更投票.</li> <li>若两者的 ZXID 一致, 那么就对比两者的 SID, 若外部投票的 SID 大, 那么就需要变更投票.</li></ul> <p>(7) ** 变更投票**. 经过 PK 后, 若确定了外部投票优于内部投票, 那么就变更投票, 即使用外部投票的选票信息来覆盖内部投票, 变更完成后, 再次将这个变更后的内部投票发送出去.</p> <p>(8) ** 选票归档**. 无论是否变更了投票, 都会将刚刚收到的那份外部投票放入选票集合 recvset 中进行归档. recvset 用于记录当前服务器在本轮次的 Leader 选举中收到的所有外部投票 (按照服务队的 SID 区别, 如 {(1, vote1), (2, vote2)...}).</p> <p>(9) ** 统计投票**. 完成选票归档后, 就可以开始统计投票, 统计投票是为了统计集群中是否已经有过半的服务器认可了当前的内部投票, 如果确定已经有过半服务器认可了该投票, 则终止投票. 否则返回步骤 4.</p> <p>(10) ** 更新服务器状态**. 若已经确定可以终止投票, 那么就开始更新服务器状态, 服务器首选判断当前被过半服务器认可的投票所对应的 Leader 服务器是否是自己, 若是自己, 则将自己的服务器状态更新为 LEADING, 若不是, 则根据具体情况来确定自己是 FOLLOWING 或是 OBSERVING.</p> <p>以上 10 个步骤就是 FastLeaderElection 的核心, 其中步骤 4-9 会经过几轮循环, 直到有 Leader 选举产生.</p> <h5 id="_5-数据同步机制"><a href="#_5-数据同步机制" class="header-anchor">#</a> 5.数据同步机制</h5> <p>ZK 的数据同步是为了保证各结点中的<strong>数据一致性</strong>, 同步时涉及两个流程, 一个是正常的<strong>客户端数据提交</strong>, 另一个是集群某个结点宕机在恢复后的<strong>数据同步</strong>.</p> <p><strong>客户端写入请求: 写入请求的大至流程是, Leader 接收客户端写请求, 并同步给各个子结点</strong>. 如下图:</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220107211151215.png" alt=""></p> <p>但实际情况要复杂的多, 比如 client 并不知道哪个结点是 Leader, 有可能写的请求会发给 Follower, 由 Follower 再<strong>转发</strong>给 Leader 进行<strong>同步</strong>处理.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220107212056670.png" alt=""></p> <p>客户端<strong>写入流程</strong>说明:</p> <ol><li>client 向 ZK 中的 server 发送写请求, 如果该 server 不是 Leader, 则会将该写<strong>请求转发</strong>给 Leader, Leader 将请求事务以 <strong>proposal</strong> 形式分发给 Follower.</li> <li>当 Follower 收到 Leader 的 proposal 时, 根据接收的<strong>先后顺序</strong>处理 proposal.</li> <li>当 Leader 收到 Follower 针对某个 proposal <strong>过半的 ack 后</strong>, 则发起<strong>事务提交</strong>, 重新发起一个 <strong>commit</strong> 的 proposal.</li> <li>Follower 收到 commit 的 proposal 后, <strong>记录事务提交</strong>, 并把数据更新到<strong>内存数据库</strong>.</li> <li>当写成功后, 反馈给 client.</li></ol> <p><strong>服务结点初始化同步:</strong></p> <p>在集群运行过程当中如果有一个 Follower 结点宕机, 由于宕机结点没过半, 集群仍然能正常服务. 当 Leader 收到新的客户端请求, 此时无法同步给宕机的结点. 造成数据不一致. 为解决这个问题, 当<strong>结点启动</strong>时, 第一件事情就是找当前的 Leader, 比对数据是否一致. 如果不一致则开始<strong>同步</strong>, 同步完成之后在进行对外提供服务.</p> <p>如何比对 Leader 的数据<strong>版本</strong>呢, 这里通过 <strong>ZXID 事务 ID</strong> 来确认. 比 Leader 低就需要同步.</p> <p><strong>ZXID: <strong>​<strong><strong>ZXID 是一个长度 64 位的数字, 其中低 32 位是按照数字递增, <strong><strong>​</strong></strong></strong>任何数据的变更</strong></strong></strong>​<strong><strong>都会导致低 32 位的数字简单加 1. 高 32 位是 leader 周期编号, 每当选举出一个新的 Leader 时, 新的 Leader 就从本地事务日志中取出 ZXID, 然后解析出高 32 位的周期编号, 进行</strong></strong>​<strong>加 1</strong>, 再将<strong>低 32 位的全部设置为 0</strong>. 这样就保证每次<strong>新选举 Leader 后</strong> ZXID 的<strong>唯一且递增</strong>.</p> <h4 id="数据与存储"><a href="#数据与存储" class="header-anchor">#</a> 数据与存储</h4> <p>ZK 的数据模型是树结构, 在<strong>内存数据库</strong>存储了整棵树的内容, 包括所有结点路径, 结点数据, ACL 信息. ZK 会定时将这个数据存储到磁盘上. 在 ZK 服务器启动期间, 首先会进行数据初始化工作, 将存储在磁盘上的数据文件加载到服务器内存中.</p> <h5 id="_1-内存数据"><a href="#_1-内存数据" class="header-anchor">#</a> 1.内存数据</h5> <p><strong>DataTree</strong> 是内存数据存储的核心, 是一个树结构, <strong>代表了内存中一份完整的数据</strong>. DataTree 不包含任何与网络, 客户端连接及请求处理相关的业务逻辑, 是一个独立的组件.</p> <p><strong>DataNode 是数据存储的最小单元</strong>, 其内部除了保存了结点的数据内容, ACL 列表, 结点状态之外, 还记录了父结点的引用和子结点列表两个属性, 其也提供了对子结点列表进行操作的接口.</p> <p><strong>ZKDatabase</strong> 是 ZK 的内存数据库, 管理 ZK 的所有会话, DataTree 存储和事务日志. ZKDatabase 会定时向磁盘 dump 快照数据, 同时在 ZK 启动时, 会通过磁盘的事务日志和快照文件<strong>恢复</strong>成一个完整的内存数据库.</p> <h5 id="_2-事务日志"><a href="#_2-事务日志" class="header-anchor">#</a> 2.事务日志</h5> <p>在配置 ZK 集群时需要配置 dataDir 目录, 其用来存储事务日志文件.</p> <h5 id="_3-数据快照-snapshot"><a href="#_3-数据快照-snapshot" class="header-anchor">#</a> 3.数据快照(snapshot)</h5> <p>数据快照是 ZK 数据存储中非常核心的运行机制, 数据快照用来记录 ZK 服务器上某一时刻的<strong>全量</strong>内存数据内容, 并将其写入指定的<strong>磁盘</strong>文件中.</p> <h3 id="三-zookeeper应用"><a href="#三-zookeeper应用" class="header-anchor">#</a> 三.ZooKeeper应用</h3> <p>Zookeeper 是一个典型的发布/订阅模式的分布式数据管理与协调框架, 基于分布式的<strong>数据发布与订阅</strong>可以有诸多应用场景. 可以用在<strong>名字服务, 配置管理, 集群管理, 集群选举, 分布式锁, 队列管理, 消息订阅</strong> 等场景.</p> <h4 id="命名服务-注册中心🌟"><a href="#命名服务-注册中心🌟" class="header-anchor">#</a> 命名服务/注册中心🌟</h4> <p>命名服务功能主要是根据指定名字来获取资源或服务的地址, 提供者等信息, 利用其 znode 和 watcher 机制, 将其作为动态注册和获取服务信息的配置中心, 统一管理服务名称和其对应的服务器列表信息, 系统能够实时感知<strong>服务器的状态</strong>(上线, 下线, 宕机).</p> <p>因此 ZK 可以作为<strong>注册中心</strong>.</p> <h5 id="_1-负载均衡"><a href="#_1-负载均衡" class="header-anchor">#</a> 1.负载均衡</h5> <p>轮询服务注册表, 尽可能将服务请求均匀分配到所有注册有效的服务器上.</p> <h5 id="_2-健康检查-心跳监测"><a href="#_2-健康检查-心跳监测" class="header-anchor">#</a> 2.健康检查/心跳监测</h5> <p>动态维护服务地址注册表, 利用心跳请求实时监控注册服务状态, 删除无效服务节点, 维护有效的地址注册表. 可以让不同的机器都在 ZK 的一个指定节点下创建临时子节点. 不同机器之间可以根据这个临时节点来判断对应的客户端机器是否存活.</p> <h5 id="_3-调用监控"><a href="#_3-调用监控" class="header-anchor">#</a> 3.调用监控</h5> <p>通过统计注册表各个子节点被<strong>访问次数</strong>来监控服务调用情况.</p> <h5 id="_4-动态路由"><a href="#_4-动态路由" class="header-anchor">#</a> 4.动态路由</h5> <p>可以通过配置注册表参数, 在不修改服务代码的情况下, <strong>动态指定服务访问的机器</strong>.</p> <h5 id="_5-动态配置"><a href="#_5-动态配置" class="header-anchor">#</a> 5.动态配置</h5> <p>一般发布订阅有两种模式: 推模式和拉模式.</p> <ul><li>**推模式: ** 服务端主动将数据更新发送给所有订阅的客户端.</li> <li>**拉模式: ** 客户端主动发起请求以定时轮询的方式获取最新数据.</li></ul> <p>发布者将数据发布到 ZK 的一个或多个节点上, 订阅者进行数据订阅以动态获取数据, 从而实现配置信息的集中式管理与数据的动态更新.</p> <p>ZK 采取了推拉结合的模式. <strong>客户端向服务端注册自己需要关注的节点, 一旦节点的数据发生变更, 那么服务端就会向相应的客户端发送 Watcher 事件通知. 客户端收到这个通知之后, 需要主动到服务端获取最新的数据</strong>.</p> <p>配置中心的数据有几个特点:</p> <ul><li>数据量较小.</li> <li>数据内容可以动态变化.</li> <li>集群多个机器共享配置信息.</li></ul> <p>可以把数据库的配置信息存放到 Zookeeper 中, 机器初始化的时候去读取一次数据库配置信息, 并在配置节点上注册一个监听数据变更的 Watcher 监听. 如果配置信息改变, Zookeeper 可以告知机器配置信息发生变更, 机器重新拉取配置信息即可.</p> <h4 id="分布式锁🌟"><a href="#分布式锁🌟" class="header-anchor">#</a> 分布式锁🌟</h4> <p>分布式锁是控制分布式系统之间同步访问共享资源的一种方式.</p> <h5 id="_1-排他锁"><a href="#_1-排他锁" class="header-anchor">#</a> 1.排他锁</h5> <p>排他锁(Exclusive Locks, 简称 X 锁), 又称为<strong>写锁或独占锁</strong>. 如果事务 T1 对数据对象 O1 加上了排他锁, 那么整个加锁期间, 只允许事务 T1 对 O1 进行读取和操作, 其他任何事务都不能再对这个数据对象进行读写操作, 直到事务释放了排他锁.</p> <p>排他锁的核心是如何保证当前有且仅有一个事务获得锁, 并且锁被释放后, 所有正在获得锁的事务都能被通知到.</p> <h6 id="_1-定义锁"><a href="#_1-定义锁" class="header-anchor">#</a> (1)定义锁</h6> <p>ZK 中通过<strong>数据节点</strong>来表示一个锁, 例如 /exclusive/lock 节点就可以被定义为一个锁.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20211120203357763-7638936.png" alt=""></p> <h6 id="_2-获取锁"><a href="#_2-获取锁" class="header-anchor">#</a> (2)获取锁</h6> <p>在需要获取锁时, <strong>所有竞争的客户端</strong>都会试图调用 <strong>create()</strong>  接口, 尝试在 /exclusive 节点下创建<mark><strong>临时子节点</strong></mark> /exclusive/lock. ZK 保证所有客户端最终只有一个客户端能<strong>创建成功</strong>, 就可以认为该客户端获取了锁. 其他没获取锁的客户端会在 /exclusive 节点上注册一个子节点变更的 <strong>Watcher 监听</strong>, 以便实时监听到 lock 节点的变更情况.</p> <h6 id="_3-释放锁"><a href="#_3-释放锁" class="header-anchor">#</a> (3)释放锁</h6> <p>由于 /exclusive/lock 是一个<mark><strong>临时节点</strong></mark>, 因此在以下两种情况下, 都可能释放锁.</p> <ul><li>当前获取锁的<strong>客户端机器发生宕机, 那么此临时节点就会被移除</strong>.</li> <li>正常<strong>执行完</strong>业务逻辑后, 客户端会主动将自己创建的临时节点<strong>删除</strong>.</li></ul> <p>无论什么情况下移除了 /exclusive/lock 节点, Zookeeper 都会<strong>通知所有在 /exclusive 节点上注册了子节点变更 Watcher 监听的客户端</strong>, 客户端收到通知之后, 就会重新发起分布式锁获取, 即<strong>重复 &quot;获取锁&quot;</strong>  过程.</p> <p>整个排他锁获取与释放流程如下.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20211120202211006-7638936.png" alt="image-20211120202211006"></p> <h5 id="_2-共享锁"><a href="#_2-共享锁" class="header-anchor">#</a> 2.共享锁</h5> <p>共享锁(Shared Locks, 简称 S 锁), 又称<strong>读锁</strong>. 如果事务 T1 对数据对象 O1 加上了<strong>共享锁</strong>, 那么当前事务只能对 O1 进行<strong>读取操作</strong>, 其他事务也只能对这个数据对象加<strong>共享锁</strong>, 直到该数据对象上的<strong>所有共享锁都被释放</strong>.</p> <p>共享锁与排他锁的根本区别在于, <strong>加上排他锁后, 数据对象只对一个事务可见, 而加上共享锁后, 数据对所有事务都可见</strong>.</p> <h6 id="_1-定义锁-2"><a href="#_1-定义锁-2" class="header-anchor">#</a> (1)定义锁</h6> <p>同样通过 Zookeeper 上的数据节点表示一个锁, 是一个类似于  <strong>/shared/[Hostname]-请求类型-序号</strong> 的<strong>临时顺序节点</strong>.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20211120203629801-7638936.png" alt=""></p> <h6 id="_2-获取锁-2"><a href="#_2-获取锁-2" class="header-anchor">#</a> (2)获取锁</h6> <p>在需要获取共享锁时, 所有客户端都会到 /shared 这个节点下创建一个<mark><strong>临时顺序节点</strong></mark>. 如果当前是<strong>读请求</strong>, 那么就创建例如 <code>/shared/192.168.0.2-R-000000001</code>​ 的节点; 如果是<strong>写请求</strong>, 那么就创建例如 <code>/shared/192.168.0.2-W-000000001</code>​ 的节点.</p> <h6 id="_3-判断读写顺序"><a href="#_3-判断读写顺序" class="header-anchor">#</a> (3)判断读写顺序</h6> <p>根据共享锁的定义, <strong>不同的事务</strong>都可以同时对同一个数据对象进行<strong>读取操作</strong>, 而<strong>更新操作</strong>必须在当前没有任何事务进行<strong>读写操作</strong>的情况下进行. 基于这个原则, 通过 Zookeeper 的节点可以确定分布式读写顺序, 大致可以分为以下四个步骤:</p> <ul><li>创建完节点后, 获取 /shared 节点下的<strong>所有子节点, 并对该节点注册子节点变更的 Watcher 监听</strong>.</li> <li>确定自己的节点序号在所有子节点的顺序.</li> <li>对于<strong>读请求</strong>. 如果没有比自己序号小的子节点, 或是所有比自己序号小的子节点都是<strong>读请求</strong>, 那么表明自己已经成功<strong>获取到了共享锁</strong>, 同时开始执行读取逻辑; 如果比自己序号小的子节点中有<strong>写请求</strong>, 那么需要进入等待. 对于<strong>写请求</strong>. 如果自己不是序号最小的子节点, 就需要进入等待.</li> <li>接收到 Watcher 通知后, 重复步骤 1.</li></ul> <h6 id="_4-释放锁"><a href="#_4-释放锁" class="header-anchor">#</a> (4)释放锁</h6> <p>释放锁的逻辑和排他锁是一致的. 整个共享锁的获取与释放流程如下图所示.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20211219124304328-7638936.png" alt="image-20211219124304328"></p> <h5 id="_3-羊群效应"><a href="#_3-羊群效应" class="header-anchor">#</a> 3.羊群效应</h5> <p>上述的共享锁过程基本能满足一般分布式集群竞争锁的需求(一般 10 台机器以内). 但如果<strong>机器规模扩大</strong>后, 就会存在问题. 这里重点看看 &quot;判断读写顺序&quot; 的过程. 下面是一个<strong>共享锁</strong>的实例.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20211219125047199-7638936.png" alt=""></p> <p>分析一下上面的情况.</p> <ul><li>host1 这台机器首先进行读操作, 完成读操作后将节点 host1-R-000000001 <strong>删除</strong>.</li> <li>剩下的 4 台机器<strong>都收到了这个节点被删除的通知</strong>. 然后<strong>重新从 /shared 节点上获取一份最新的子节点列表</strong>.</li> <li><strong>每个机器判断自己的读写顺序</strong>. 其中 host2 这个机器发现自己已经是序号最小的机器了, 于是开始进行写操作. 其他机器发现没有轮到自己进行读或写操作, 于是继续等待.</li> <li>重复上述流程...</li></ul> <p>可以看到, host1 这个客户端在移除自己的共享锁之后, Zookeeper 发送了<mark><strong>子节点变更 Watcher 通知给所有机器</strong></mark>, 这个通知实际上仅对 host2 机器产生了实际的影响, 对其他的全部机器都没有任何作用.</p> <p>上述过程可以看到, 在整个分布式锁的竞争过程中, <mark><strong>大量的 &quot;Watcher 通知&quot; 和 &quot;子结点列表获取&quot; 两个操作重复进行</strong></mark>. 且大多数运行的结果都是判断出自己并非是序号最小的结点, 从而继续等待下一轮通知. <strong>如果集群规模比较大, 就会对 Zookeeper 服务器造成巨大的性能影响和网络冲击; 而且如果同一时刻有多个结点对应的客户端完成事务或是事务中断引起结点消失, Zookeeper 服务器就会在短时间内向其余客户端发送大量的事件通知</strong>, 这就是  **&quot;**​<mark><strong>羊群效应</strong></mark>​ <strong>&quot;</strong> .</p> <p>上述的 Zookeeper 分布式共享锁的实现中出现羊群效应的<strong>根源在于没有找准客户端真正的关注点</strong>. 前述的分布式锁竞争过程的核心逻辑在于, 判断自己是否是所有子节点中序号最小的. 因此很容易想到<strong>每个结点对应的客户端其实只需要关注比自己序号小的那个相关结点的变更情况就可以了, 而不需要关注全局的子列表变更情况</strong>.</p> <h5 id="_4-改进分布式锁"><a href="#_4-改进分布式锁" class="header-anchor">#</a> 4.改进分布式锁</h5> <p>前述的共享锁实现思路是对的, 这里的改进主要在于: <mark><strong>每个锁竞争者, 只需要关注 /shared 结点下序号比自己小的那个结点是否存在即可</strong></mark>. 如下图所示.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20211219131144732-7638936.png" alt="image-20211219131144732"></p> <p>具体步骤如下:</p> <ol><li>客户端调用 create() 方法创建一个类似与 &quot; <strong>/shared/[Hostname]-请求类型-序号</strong>&quot; 的临时顺序结点.</li> <li>客户端调用 getChildren() 接口来获取所有已经创建的<strong>子结点列表</strong>. 注意对比之前的实现: 这里<strong>不需要注册任何 Watcher</strong>.</li> <li>如果无法获取共享锁, 那么就调用 exist() 来<strong>向比自己小的那个结点注册 Watcher</strong>. 注意: 这里 &quot;比自己小的结点&quot; 具体得看是读请求还是写请求.</li></ol> <ul><li><strong>读请求: 向比自己序号小的最后一个写请求结点注册 Watcher 监听.</strong></li> <li><strong>写请求: 向比自己序号小的最后一个结点注册 Watcher 监听.</strong></li></ul> <ol start="4"><li>等待 Watcher 通知, 继续进入步骤 2.</li></ol> <p>这个改进过程其实就是尽量去<strong>缩小锁的范围</strong>. 具体选哪种实现可以根据<strong>具体的场景选择</strong>. 在集群规模不大, 网络资源丰富的情况下, 采用第一种实现是简单实用的选择; 如果集群达到一定规模, 且希望能精细化的控制分布式锁, 那可以采用改进版的分布式锁实现.</p> <h4 id="框架与系统应用"><a href="#框架与系统应用" class="header-anchor">#</a> 框架与系统应用</h4> <p>介绍下 ZK 在各种框架中的应用.</p> <blockquote><p>Hadoop</p></blockquote> <p>Hadoop 利用 Zookeeper 实现 HA(High Availability).</p> <blockquote><p>HBase</p></blockquote> <p>HBase 利用 Zookeeper 实现整个系统的分布式协调工作.</p> <blockquote><p>Kafka</p></blockquote> <p>Kafka 使用 Zookeeper 作为注册系统来对整个集群的 <strong>Broker 服务器</strong>进行管理. 在 Zookeeper 上会有一个专门用来进行 Broker 服务器列表记录的结点(记为 Broker 结点), 其路径为 &quot;/brokers/ids&quot;. 每个 Broker 服务器在启动时, 都会到 Zookeeper 上进行注册, 即到 Broker 结点下创建属于自己的结点, 其结点路径为 &quot;/brokers/ids/[0-N]&quot;.</p> <p>在 Kafka 中, 使用一个全局唯一的数字(可称为 Broker ID)来代表每一个 Broker 服务器, 不同的 Broker 必须使用不同的  Broker ID 进行注册, 如 &quot;/brokers/ids/1&quot; 和 &quot;/brokers/ids/2&quot; 分别代表了两个 Broker 服务器. 创建完 Broker 结点后, 每个 Broker 会将自己的 IP 地址和端口信息写入到该结点下去.</p> <p>Broker 创建的结点是一个临时结点, 一旦这个 Broker 服务器宕机或者下线, 对应的 Zookeeper 结点也会删除. 因此可以通过 Zookeeper 上 Broker 结点的变化情况来动态表征 Broker 服务器的可用性.</p> <p>除了 Broker 之外, Topic 注册也是类似的逻辑.</p> <p>参考: Kafka与Zookeeper.</p> <blockquote><p>Dubbo</p></blockquote> <p><strong>Zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心(提供发布订阅服务). <strong>​<strong><strong>服务生产者将自己提供的服务注册到 Zookeeper 中心, 服务的消费者在进行服务调用的时候先到 Zookeeper 中查找服务, 获取到服务生产者的详细信息之后, 再去调用服务生产者的内容与数据. 在 Dubbo 中 Zookeeper 就担任了</strong></strong>​</strong>注册中心</strong>的角色.</p> <p>分布式服务节点很多, 不可能在客户端手动配置, 这就需要一个<strong>中间服务</strong>, 专门用于<strong>帮助客户端发现服务节点</strong>, 就是<strong>服务发现</strong>.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220107212259512-7638936.png" alt=""></p> <p>一个完整的<strong>注册中心</strong>涵盖以下功能特性:</p> <ul><li><strong>服务注册: <strong>​<strong><strong>服务端</strong></strong>​</strong>上线时</strong>将自<strong>提供的服务提交给注册中心</strong>.</li> <li><strong>服务注销: <strong>​<strong><strong>通知客户端服务端</strong></strong>​</strong>下线</strong>.</li> <li><strong>服务订阅</strong>: 动态实时接收服务<strong>变更消息</strong>.</li> <li><strong>可靠性</strong>: 注册服务本身是<strong>集群</strong>的, 数据<strong>冗余存储</strong>. 避免单点故障, 及数据丢失.</li> <li><strong>容错性</strong>: 当服务提供者出现宕机, 断电等极端情况时, 注册中心能够<strong>动态感知</strong>并通知客户端服务提供者的状态.</li></ul> <p>Dubbo 基于 Zookeeper 实现服务<strong>注册中心</strong>. 所有服务提供者在 Zookeeper 上创建的结点都是<strong>临时结点</strong>, 这利用了临时结点的生命周期与客户端会话相关的特性, 可以表明服务提供者的在线状态.</p> <p><strong>Dubbo 注册中心存储</strong>结构如下:</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220107214039226-7638936.png" alt=""></p> <p><strong>节点说明</strong></p> <table><thead><tr><th style="text-align:center;"><strong>类别</strong></th> <th style="text-align:center;"><strong>属性</strong></th> <th style="text-align:center;"><strong>说明</strong></th></tr></thead> <tbody><tr><td style="text-align:center;"><strong>Root</strong></td> <td style="text-align:center;"><strong>持久节点</strong></td> <td style="text-align:center;">根节点名称, 默认是 &quot;dubbo&quot;</td></tr> <tr><td style="text-align:center;"><strong>Service</strong></td> <td style="text-align:center;"><strong>持久节点</strong></td> <td style="text-align:center;"><strong>服务名称</strong>, 完整的服务类名</td></tr> <tr><td style="text-align:center;"><strong>type</strong></td> <td style="text-align:center;"><strong>持久节点</strong></td> <td style="text-align:center;">可选值: <strong>providers</strong>(提供者), <strong>consumers</strong>(消费者), <strong>configurators</strong>(动态配置), <strong>routers</strong></td></tr> <tr><td style="text-align:center;"><strong>URL</strong></td> <td style="text-align:center;"><strong>临时节点</strong></td> <td style="text-align:center;">URL 名称: 包含服务提供者的 IP 端口及配置等信息.</td></tr></tbody></table> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/30.系统/3000.系统/200.服务治理-注册发现与RPC/110.Zookeeper.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/51b6aa/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">RPC实战与核心原理(极客时间)🌸</div></a> <a href="/pages/3b7e05/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Nacos</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/51b6aa/" class="prev">RPC实战与核心原理(极客时间)🌸</a></span> <span class="next"><a href="/pages/3b7e05/">Nacos</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/170.58569530.js" defer></script>
  </body>
</html>
