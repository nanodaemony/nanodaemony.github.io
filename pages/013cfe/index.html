<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>RocketMQ | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/151.b7093623.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>分布式系统理论</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/129626/" class="sidebar-link">分布式系统基础</a></li><li><a href="/pages/fb5d35/" class="sidebar-link">分布式共识算法</a></li><li><a href="/pages/12ac37/" class="sidebar-link">分布式系统组件</a></li><li><a href="/pages/d03ebf/" class="sidebar-link">分布式技术原理与算法解析(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>系统接入层</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/f1b6c4/" class="sidebar-link">Nginx基础</a></li><li><a href="/pages/d4123d/" class="sidebar-link">深入拆解Tomcat与Jetty(极客时间)🌸</a></li><li><a href="/pages/baee2f/" class="sidebar-link">Netty</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>服务治理-注册发现与RPC</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/05077d/" class="sidebar-link">基础</a></li><li><a href="/pages/51b6aa/" class="sidebar-link">RPC实战与核心原理(极客时间)🌸</a></li><li><a href="/pages/0966ee/" class="sidebar-link">Zookeeper</a></li><li><a href="/pages/3b7e05/" class="sidebar-link">Nacos</a></li><li><a href="/pages/7f31f8/" class="sidebar-link">Dubbo</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>服务治理-流量控制</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/44bfa8/" class="sidebar-link">负载均衡</a></li><li><a href="/pages/4d5a6c/" class="sidebar-link">限流</a></li><li><a href="/pages/e0c561/" class="sidebar-link">熔断</a></li><li><a href="/pages/12ae40/" class="sidebar-link">网关路由</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>服务治理-系统监控与安全</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/8c9210/" class="sidebar-link">系统安全性</a></li><li><a href="/pages/c9bf40/" class="sidebar-link">系统监控组件</a></li><li><a href="/pages/3f3cf7/" class="sidebar-link">运维监控系统实战(极客时间)🌸</a></li><li><a href="/pages/e20e02/" class="sidebar-link">OAuth2.0实战课(极客时间)🌟</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>中间件-消息队列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/96d94c/" class="sidebar-link">消息队列基础</a></li><li><a href="/pages/abf16c/" class="sidebar-link">RabbitMQ</a></li><li><a href="/pages/4fc3f1/" class="sidebar-link">Kafka</a></li><li><a href="/pages/013cfe/" aria-current="page" class="active sidebar-link">RocketMQ</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/ed8d92/" class="sidebar-link">Disruptor</a></li><li><a href="/pages/249149/" class="sidebar-link">消息队列高手课(极客时间)🌟</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>中间件-缓存</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/946847/" class="sidebar-link">缓存基础</a></li><li><a href="/pages/e46d56/" class="sidebar-link">本地缓存</a></li><li><a href="/pages/0abfb9/" class="sidebar-link">Redis基础</a></li><li><a href="/pages/09236a/" class="sidebar-link">Redis持久化</a></li><li><a href="/pages/867f9b/" class="sidebar-link">Redis主从复制</a></li><li><a href="/pages/50cae1/" class="sidebar-link">Redis哨兵</a></li><li><a href="/pages/43b45c/" class="sidebar-link">Redis集群</a></li><li><a href="/pages/a32379/" class="sidebar-link">Redis内存管理与运维</a></li><li><a href="/pages/386037/" class="sidebar-link">Redis核心技术与实战(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>中间件-其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/23044d/" class="sidebar-link">定时任务-XXLJob</a></li><li><a href="/pages/459117/" class="sidebar-link">ES与检索</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>系统设计与优化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/41a845/" class="sidebar-link">凤凰架构</a></li><li><a href="/pages/68cc0b/" class="sidebar-link">左耳听风(极客时间)🌟</a></li><li><a href="/pages/e3e99c/" class="sidebar-link">从0开始学微服务(极客时间)🌸</a></li><li><a href="/pages/1e5368/" class="sidebar-link">高并发系统设计40问(极客时间)🌸</a></li><li><a href="/pages/33599f/" class="sidebar-link">系统性能调优必知必会(极客时间)🌸</a></li><li><a href="/pages/c83472/" class="sidebar-link">后端技术面试38讲(极客时间)</a></li><li><a href="/pages/4404b6/" class="sidebar-link">架构实战案例解析(极客时间)🌸</a></li><li><a href="/pages/8f1c1d/" class="sidebar-link">如何设计一个秒杀系统(极客时间)</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>容器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>容器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/582acf/" class="sidebar-link">部署Minikube</a></li><li><a href="/pages/98e5e4/" class="sidebar-link">容器实战高手课(极客时间)🌸</a></li><li><a href="/pages/c6a42c/" class="sidebar-link">Kubernetes实战🌸</a></li><li><a href="/pages/f35c72/" class="sidebar-link">深入剖析Kubernetes(极客时间)🌸</a></li><li><a href="/pages/caa314/" class="sidebar-link">Istio</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>自动化运维</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/beb97f/" class="sidebar-link">持续集成(CICD)</a></li><li><a href="/pages/a0df2d/" class="sidebar-link">DevOps</a></li><li><a href="/pages/765815/" class="sidebar-link">SRE实战手册(极客时间)</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/middleware/#系统" data-v-06970110>系统</a></li><li data-v-06970110><a href="/middleware/#系统" data-v-06970110>系统</a></li><li data-v-06970110><a href="/middleware/#中间件-消息队列" data-v-06970110>中间件-消息队列</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">RocketMQ<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_4-rocketmq"><a href="#_4-rocketmq" class="header-anchor">#</a> 4.RocketMQ</h1> <p>本文为 RocketMQ 5.0 官方文档: <a href="https://rocketmq.apache.org/zh/docs/" target="_blank" rel="noopener noreferrer">https://rocketmq.apache.org/zh/docs/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h3> <blockquote><p>为什么选择RocketMQ</p></blockquote> <p><strong>RocketMQ</strong> 是一个 <strong>队列模型</strong> 的消息中间件, 具有<strong>高性能, 高可靠, 高实时, 分布式</strong> 等特点. 是一个基于 Java 开发的分布式消息系统.</p> <p>在阿里孕育 RocketMQ 的雏形时期, 我们将其用于异步通信, 搜索, 社交网络活动流, 数据管道, 贸易流程中. 随着我们的贸易业务吞吐量的上升, 源自我们的消息传递集群的压力也变得紧迫.</p> <p>随着队列和虚拟主题使用的增加, ActiveMQ IO 模块达到了一个瓶颈. 我们尽力通过节流, 断路器或降级来解决这个问题, 但效果并不理想. 于是我们尝试了流行的消息传递解决方案 Kafka. 不幸的是, Kafka 不能满足要求, 其尤其表现在<strong>低延迟和高可靠性</strong>方面, 详见下文. 在这种情况下, 我们决定发明一个新的消息传递引擎来处理更广泛的消息用例, 覆盖从传统的 pub/sub 场景到高容量的实时零误差的交易系统.</p> <p>RocketMQ 自诞生以来, 因其架构简单, 业务功能丰富, 具备极强可扩展性等特点被众多企业开发者以及云厂商广泛采用. 历经十余年的大规模场景打磨, RocketMQ 已经成为业内共识的金融级可靠业务消息首选方案, 被广泛应用于互联网, 大数据, 移动互联网, 物联网等领域的业务场景.</p> <h4 id="基本概念与名词定义"><a href="#基本概念与名词定义" class="header-anchor">#</a> 基本概念与名词定义</h4> <p>这里介绍 RocketMQ 的基本概念, 以便更好地理解和使用 RocketMQ.</p> <blockquote><p>主题(Topic)</p></blockquote> <p><strong>RocketMQ 中消息传输和存储的顶层容器, 用于标识同一类业务逻辑的消息</strong>. 主题通过 TopicName 来做唯一标识和区分. 更多信息, 参考: 主题(Topic).</p> <blockquote><p>消息类型(MessageType)</p></blockquote> <p><strong>RocketMQ 中按照消息传输特性的不同而定义的分类, 用于类型管理和安全校验</strong>. RocketMQ 支持的消息类型有<strong>普通消息, 顺序消息, 事务消息和定时/延时消息</strong>.</p> <p>RocketMQ 从 5.0 版本开始, 支持强制校验消息类型, 即每个主题 Topic 只允许发送一种消息类型的消息, 这样可以更好的运维和管理生产系统, 避免混乱. 但同时保证向下兼容 4.x 版本行为, 强制校验功能默认开启.</p> <blockquote><p>消息队列(MessageQueue)</p></blockquote> <p><strong>队列是 RocketMQ 中消息存储和传输的实际容器, 也是消息的最小存储单元</strong>. RocketMQ 的<strong>所有主题都是由多个队列组成, 以此实现队列数量的水平拆分和队列内部的流式存储</strong>. 队列通过 QueueId 来做唯一标识和区分. 更多信息, 请参见<a href="https://rocketmq.apache.org/zh/docs/domainModel/03messagequeue" target="_blank" rel="noopener noreferrer">队列(MessageQueue)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <blockquote><p>消息(Message)</p></blockquote> <p>消息是 RocketMQ 中的最小数据传输单元. 生产者将业务数据的负载和拓展属性包装成消息发送到服务端, 服务端按照相关语义将消息投递到消费端进行消费. 更多信息, 请参见<a href="https://rocketmq.apache.org/zh/docs/domainModel/04message" target="_blank" rel="noopener noreferrer">消息(Message)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <blockquote><p>消息视图(MessageView)</p></blockquote> <p>消息视图是 RocketMQ 面向开发视角提供的一种消息只读接口. 通过消息视图可以读取消息内部的多个属性和负载信息, 但是不能对消息本身做任何修改.</p> <blockquote><p>消息标签(MessageTag)</p></blockquote> <p>消息标签是 RocketMQ 提供的细粒度消息分类属性, 可以在主题层级之下做消息类型的细分. 消费者通过订阅特定的标签来实现细粒度过滤. 更多信息参考: 队列(MessageQueue).</p> <blockquote><p>消息位点(MessageQueueOffset)</p></blockquote> <p><strong>消息是按到达 RocketMQ 服务端的先后顺序存储在指定主题的多个队列中, 每条消息在队列中都有一个唯一的 Long 类型坐标, 这个坐标被定义为消息位点</strong>. 更多信息参考: 消费进度管理.</p> <blockquote><p>消费位点(ConsumerOffset)</p></blockquote> <p><strong>一条消息被某个消费者消费完成后不会立即从队列中删除, RocketMQ 会基于每个消费者分组记录消费过的最新一条消息的位点, 即消费位点</strong>. 更多信息参考: 消费进度管理.</p> <blockquote><p>消息索引(MessageKey)</p></blockquote> <p>消息索引是 RocketMQ 提供的<strong>面向消息的索引属性</strong>. 通过设置的消息索引可以快速查找到对应的消息内容.</p> <blockquote><p>生产者(Producer)</p></blockquote> <p>生产者是 RocketMQ 系统中用来构建并传输消息到服务端的运行实体. 生产者通常被集成在业务系统中, <strong>将业务消息按照要求封装成消息并发送至服务端</strong>. 更多信息参考: 生产者(Producer).</p> <blockquote><p>事务检查器(TransactionChecker)</p></blockquote> <p>RocketMQ 中生产者用来执行本地事务检查和异常事务恢复的监听器. 事务检查器应该通过业务侧数据的状态来检查和判断事务消息的状态. 更多信息参考: 事务消息.</p> <blockquote><p>事务状态(TransactionResolution)</p></blockquote> <p>RocketMQ 中事务消息发送过程中, 事务提交的状态标识, 服务端通过事务状态控制事务消息是否应该提交和投递. <strong>事务状态包括事务提交, 事务回滚和事务未决</strong>. 更多信息参考: 事务消息.</p> <blockquote><p>消费者分组(ConsumerGroup)</p></blockquote> <p>消费者分组是 RocketMQ 系统中<strong>承载多个消费行为一致的消费者的负载均衡分组</strong>. 和消费者不同, 消费者分组并不是运行实体, 而是一个<strong>逻辑资源</strong>. 在 RocketMQ 中, <strong>通过消费者分组内初始化多个消费者实现消费性能的水平扩展以及高可用容灾</strong>. 更多信息参考: 消费者分组(ConsumerGroup).</p> <blockquote><p>消费者(Consumer)</p></blockquote> <p>消费者是 RocketMQ 中用来<strong>接收并处理消息的运行实体</strong>. 消费者通常被集成在业务系统中, 从服务端获取消息, 并将消息转化成业务可理解的信息, 供业务逻辑处理. 更多信息参考: 消费者(Consumer).</p> <blockquote><p>消费结果(ConsumeResult)</p></blockquote> <p>RocketMQ 中 PushConsumer 消费监听器<strong>处理消息完成后返回的处理结果, 用来标识本次消息是否正确处理</strong>. 消费结果包含<strong>消费成功和消费失败</strong>.</p> <blockquote><p>订阅关系(Subscription)</p></blockquote> <p>订阅关系是 RocketMQ 系统中<strong>消费者获取消息, 处理消息的规则和状态配置</strong>. 订阅关系由消费者分组动态注册到服务端系统, 并在后续的消息传输中按照订阅关系定义的过滤规则进行消息匹配和消费进度维护. 更多信息参考: 订阅关系(Subscription).</p> <blockquote><p>消息过滤</p></blockquote> <p><strong>消费者可以通过订阅指定消息标签(Tag)对消息进行过滤, 确保最终只接收被过滤后的消息合集</strong>. 过滤规则的计算和匹配在 RocketMQ 的服务端完成. 更多信息参考: 消息过滤.</p> <blockquote><p>重置消费位点</p></blockquote> <p>以时间轴为坐标, 在消息持久化存储的时间范围内, <strong>重新设置消费者分组对已订阅主题的消费进度, 设置完成后消费者将接收设定时间点之后, 由生产者发送到 RocketMQ 服务端的消息</strong>. 更多信息参考: 重置消费位点(回溯消费).</p> <blockquote><p>消息轨迹</p></blockquote> <p><strong>在一条消息从生产者发出到消费者接收并处理过程中, 由各个相关节点的时间, 地点等数据汇聚而成的完整链路信息</strong>. 通过消息轨迹能清晰定位消息从生产者发出, 经由 RocketMQ 服务端, 投递给消费者的完整链路, 方便定位排查问题.</p> <blockquote><p>消息堆积</p></blockquote> <p>生产者已经将消息发送到 RocketMQ 的服务端, 但由于消费者的消费能力有限, 未能在短时间内将所有消息正确消费掉, 此时<strong>在服务端保存着未被消费的消息, 该状态即消息堆积</strong>.</p> <blockquote><p>事务消息</p></blockquote> <p>事务消息是 RocketMQ 提供的一种高级消息类型, 支持<strong>在分布式场景下保障消息生产和本地事务的最终一致性</strong>.</p> <blockquote><p>定时/延时消息</p></blockquote> <p>定时/延时消息是 RocketMQ 提供的一种高级消息类型, <strong>消息被发送至服务端后, 在指定时间后才能被消费者消费</strong>. 通过设置一定的定时时间可以实现<strong>分布式场景的延时调度触发效果</strong>.</p> <blockquote><p>顺序消息</p></blockquote> <p>顺序消息是 RocketMQ 提供的一种高级消息类型, <strong>支持消费者按照发送消息的先后顺序获取消息</strong>, 从而实现业务场景中的顺序处理.</p> <h3 id="领域模型"><a href="#领域模型" class="header-anchor">#</a> 领域模型</h3> <h4 id="领域模型概述"><a href="#领域模型概述" class="header-anchor">#</a> 领域模型概述</h4> <h5 id="rocketmq领域模型"><a href="#rocketmq领域模型" class="header-anchor">#</a> RocketMQ领域模型</h5> <p>RocketMQ 是一款典型的分布式架构下的中间件产品, 使用<strong>异步通信方式和发布订阅的消息传输模型</strong>. 通信方式和传输模型的具体说明, 请参见下文<strong>通信方式介绍</strong>和<strong>消息传输模型</strong>介绍. RocketMQ 产品具备异步通信的优势, 系统拓扑简单, 上下游耦合较弱, 主要应用于异步解耦, 流量削峰填谷等场景.</p> <p>对于<strong>主题模型</strong>的实现来说<strong>每个消息中间件的底层设计都是不一样的</strong>, 比如 Kafka 中的 <strong>分区</strong>, RocketMQ 中的 <strong>队列</strong>, RabbitMQ 中的 <strong>Exchange</strong>. 可以理解为 <strong>主题模型/发布订阅模型 就是一个标准</strong>, 那些中间件只不过照着这个标准去实现而已.</p> <p>RocketQM 消息模型如下图所示.</p> <p>​<img src="/img/image-20240825152228-7xzqjfp.png" alt="image">​</p> <p>如上图所示, RocketMQ 中<strong>消息的生命周期主要分为</strong>​<mark><strong>消息生产, 消息存储, 消息消费</strong></mark>这三部分.</p> <p><strong>生产者生产消息并发送至 RocketMQ 服务端, 消息被存储在服务端的主题中, 消费者通过订阅主题消费消息</strong>.</p> <blockquote><p>消息生产</p></blockquote> <p><strong>生产者(Producer)</strong> : 用于产生消息的运行实体, 一般集成于业务调用链路的上游. 生产者是轻量级匿名无身份的.</p> <blockquote><p>消息存储</p></blockquote> <p><strong>主题(Topic)</strong> : RocketMQ 消息传输和存储的分组容器, 主题内部由多个队列组成, 消息的存储和水平扩展实际是通过主题内的队列实现的.</p> <p><strong>队列(MessageQueue)</strong> : RocketMQ 消息传输和存储的实际单元容器, 类比于其他消息队列中的<strong>分区</strong>. RocketMQ 通过流式特性的<strong>无限队列</strong>结构来存储消息, <strong>消息在队列内具备顺序性存储特征</strong>.</p> <p><strong>消息(Message)</strong> : RocketMQ 的最小传输单元. <strong>消息具备不可变性, 在初始化发送和完成存储后即不可变</strong>.</p> <blockquote><p>消息消费</p></blockquote> <p><strong>消费者分组(ConsumerGroup)</strong> : RocketMQ 发布订阅模型中定义的独立的消费身份分组, 用于统一管理底层运行的多个消费者(Consumer). <strong>同一个消费组的多个消费者必须保持消费逻辑和配置一致, 共同分担该消费组订阅的消息, 实现消费能力的水平扩展</strong>.</p> <p><strong>消费者(Consumer)</strong> : RocketMQ 消费消息的运行实体, 一般集成在业务调用链路的下游. 消费者必须被指定到某一个消费组中.</p> <p><strong>订阅关系(Subscription)</strong> : RocketMQ 发布订阅模型中<strong>消息过滤, 重试, 消费进度的规则配置</strong>. 订阅关系以消费组粒度进行管理, 消费组通过定义订阅关系控制指定消费组下的消费者如何实现消息过滤, 消费重试及消费进度恢复等. RocketMQ 的订阅关系除过滤表达式之外都是<strong>持久化</strong>的, 即服务端重启或请求断开, 订阅关系依然保留.</p> <h5 id="通信方式"><a href="#通信方式" class="header-anchor">#</a> 通信方式</h5> <p>分布式系统架构思想下, 将复杂系统拆分为多个独立的<strong>子模块</strong>, 例如微服务模块. 此时就需要考虑<strong>子模块间的远程通信</strong>, 典型的通信模式分为以下两种, <strong>一种是同步的 RPC 远程调用; 一种是基于中间件代理的异步通信方式</strong>.</p> <blockquote><p>同步RPC调用模型</p></blockquote> <p><img src="/img/syncarchi-ebbd41e1afd6adf432792ee2d7a91748-20240422213136-3uinp43.png" alt="同步调用"></p> <p>同步 RPC 调用模型下, 不同系统之间<strong>直接进行调用通信</strong>, 每个请求直接从调用方发送到被调用方, 然后要求被调用方立即返回响应结果给调用方, 以确定本次调用结果是否成功. <strong>注意</strong>: 此处的同步并不代表 RPC 的编程接口方式, RPC也可以有异步非阻塞调用的编程方式, 但本质上仍然是需要在指定时间内得到目标端的直接响应.</p> <blockquote><p>异步通信模型</p></blockquote> <p><img src="/img/asyncarchi-e7ee18dd77aca472fb80bb2238d9528b-20240422213136-4t02gve.png" alt="异步调用"></p> <p>异步消息通信模式下, <strong>各子系统之间无需强耦合直接连接, 调用方只需要将请求转化成异步事件(消息)发送给中间代理, 发送成功即可认为该异步链路调用完成, 剩下的工作中间代理会负责将事件可靠通知到下游的调用系统, 确保任务执行完成</strong>. 该中间代理一般就是<strong>消息中间件</strong>.</p> <p>异步通信的优势如下:</p> <ul><li>系统拓扑简单. 由于调用方和被调用方统一和中间代理通信, 系统是星型结构, 易于维护和管理.</li> <li><strong>上下游耦合性弱</strong>. 上下游系统之间弱耦合, 结构更灵活, 由中间代理负责缓冲和异步恢复.  上下游系统间可以独立升级和变更, 不会互相影响.</li> <li>容量削峰填谷. 基于消息的中间代理往往具备很强的流量缓冲和整形能力, 业务流量高峰到来时不会击垮下游.</li></ul> <h5 id="消息传输模型"><a href="#消息传输模型" class="header-anchor">#</a> 消息传输模型</h5> <p>主流的消息中间件的传输模型主要为<strong>点对点模型和发布订阅模型</strong>. (参考: 消息传输模型).</p> <p>RocketMQ 使用的传输模型为<strong>发布订阅模型</strong>, 因此也具有发布订阅模型的特点.</p> <h4 id="rocketmq部署架构🌟"><a href="#rocketmq部署架构🌟" class="header-anchor">#</a> RocketMQ部署架构🌟</h4> <h5 id="_1-基本架构"><a href="#_1-基本架构" class="header-anchor">#</a> 1.基本架构</h5> <p>RocketMQ 架构中有四大角色 <strong>NameServer, Broker, Producer, Consumer</strong>.</p> <ul><li><strong>Broker</strong>: 主要负责消息的<strong>存储, 投递和查询以及服务高可用保证</strong>. 其实就是消息队列服务器, 生产者生产消息到 Broker, 消费者从 Broker 拉取消息并消费.</li> <li><strong>NameServer</strong>: 其实也是一个 <strong>注册中心</strong>, 主要提供两个功能: <strong>Broker 管理和路由信息管理</strong>. Broker 会<strong>将自己的信息注册到 NameServer</strong>, 此时 NameServer 就存放了很多 Broker 的信息(Broker 的路由表), <strong>消费者和生产者就从 NameServer 中获取路由表然后照着路由表的信息于对应的 Broker 进行通信</strong>(生产者和消费者定期会向 NameServer 去查询相关的 Broker 的信息).</li> <li><strong>Producer</strong>: <strong>消息发布</strong>的角色, 就是<strong>生产者</strong>, 支持分布式集群方式部署.</li> <li><strong>Consumer</strong>: <strong>消息消费</strong>的角色, 就是<strong>消费者</strong>, 支持分布式集群方式部署. 支持以 <strong>push 推, pull 拉两种模式</strong>对消息进行消费. 同时也支持集群方式和广播方式的消费, 它提供实时消息订阅机制.</li></ul> <p>四个组件关系如下图所示.</p> <p>​<img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230211215719467.png" alt="">​</p> <h5 id="_2-集群架构"><a href="#_2-集群架构" class="header-anchor">#</a> 2.集群架构</h5> <p>RocketMQ 生产环境下的架构更加复杂, 因为上面的四个角色都是需要做<strong>集群</strong>的.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200728144455669.png" alt="image-20200728144455669"></p> <p>集群架构与之前的架构图也没什么区别, 主要是一些细节上的差别.</p> <p>第一, Broker 做了集群并且还进行了<strong>主从部署</strong>, 由于<strong>消息分布在各个 Broker 上</strong>. 一旦某个 Broker 宕机, 则该 Broker 上的消息读写都会受到影响. 所以 RocketMQ 提供了 <strong>master/slave</strong> 的结构, salve 定时从 master 同步数据(同步刷盘或者异步刷盘), 如果 master 宕机, 则 slave 提供消费服务, 但是不能写入消息.</p> <p>第二, 为了保证 <strong>HA</strong>, NameServer 也做了<strong>集群部署</strong>, 但是注意它是<strong>去中心化</strong>的. 也就意味着<strong>它没有主节点</strong>, NameServer 的所有节点是<strong>没有进行信息同步</strong>的, 在 RocketMQ 中是通过单个 Broker 和<strong>所有 NameServer 保持长连接</strong>, 并且在每隔 30 秒 Broker 会向所有 Nameserver <strong>发送心跳</strong>, 心跳包含了自身的 Topic 配置信息, 这个步骤就对应这上面的 Routing Info.</p> <p>第三, <strong>生产者</strong>需要向 Broker <strong>发送消息</strong>的时候, 需要先<strong>从 NameServer 获取关于 Broker 的路由信息</strong>, 然后通过<strong>轮询</strong>的方法去向每个队列中生产数据以达到<strong>负载均衡</strong>的效果.</p> <p>第四, <strong>消费者</strong>通过 NameServer 获取所有 Broker 的路由信息后, 向 <strong>Broker 发送 Pull 请求</strong>来获取消息数据. Consumer 可以以两种模式启动: <strong>广播</strong>(Broadcast)<strong>和集群</strong>(Cluster). 广播模式下, 一条消息会发送给同一个消费组中的所有消费者, 集群模式下消息只会发送给一个消费者.</p> <h4 id="broker模型🌟"><a href="#broker模型🌟" class="header-anchor">#</a> Broker模型🌟</h4> <h5 id="基础-2"><a href="#基础-2" class="header-anchor">#</a> 基础</h5> <p><strong>Broker 就是消息服务器</strong>. 一个 Topic 中存在多个队列, 一个 Topic 分布在多个 Broker 上, 一个 Broker 可以配置多个 Topic , 它们是多对多的关系. 如果某个 Topic 消息量很大, 应该给它多配置多个<strong>队列</strong>(提高并发能力), 并且尽量多分布在不同 Broker 上, 以减轻某个 Broker 的压力. Topic 消息量都比较均匀的情况下, 如果某个 broker 上的队列越多, 则该 broker 压力越大. 所以一般需要配置多个 Broker.</p> <p>Broker 与 Topic 的关系如下所示:</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230211214523542.png" alt=""></p> <h5 id="broker角色"><a href="#broker角色" class="header-anchor">#</a> Broker角色</h5> <p><strong>Broker 角色分为 ASYNC_MASTER(异步主机), SYNC_MASTER(同步主机)以及 SLAVE(从机)</strong> . 如果对消息的可靠性要求比较严格, 可以采用 SYNC_MASTER 加 SLAVE 的部署方式. 如果对消息可靠性要求不高, 可以采用ASYNC_MASTER 加 SLAVE 的部署方式.</p> <h5 id="broker参数配置"><a href="#broker参数配置" class="header-anchor">#</a> Broker参数配置</h5> <table><thead><tr><th style="text-align:center;">参数名</th> <th>默认值</th> <th>说明</th></tr></thead> <tbody><tr><td style="text-align:center;">listenPort</td> <td>10911</td> <td>接受客户端连接的监听端口</td></tr> <tr><td style="text-align:center;">namesrvAddr</td> <td>null</td> <td>nameServer 地址</td></tr> <tr><td style="text-align:center;">brokerIP1</td> <td>网卡的 InetAddress</td> <td>当前 broker 监听的 IP</td></tr> <tr><td style="text-align:center;">brokerIP2</td> <td>跟 brokerIP1 一样</td> <td>存在主从 broker 时, 如果在 broker 主节点上配置了 brokerIP2 属性, broker 从节点会连接主节点配置的 brokerIP2 进行同步</td></tr> <tr><td style="text-align:center;">brokerName</td> <td>null</td> <td>broker 的名称</td></tr> <tr><td style="text-align:center;">brokerClusterName</td> <td>DefaultCluster</td> <td>本 broker 所属的 Cluser 名称</td></tr> <tr><td style="text-align:center;">brokerId</td> <td>0</td> <td>broker id, 0 表示 master, 其他的正整数表示 slave</td></tr> <tr><td style="text-align:center;">storePathCommitLog</td> <td>$HOME/store/commitlog/</td> <td>存储 commit log 的路径</td></tr> <tr><td style="text-align:center;">storePathConsumerQueue</td> <td>$HOME/store/consumequeue/</td> <td>存储 consume queue 的路径</td></tr> <tr><td style="text-align:center;">mapedFileSizeCommitLog</td> <td>1024 * 1024 * 1024(1G)</td> <td>commit log 的映射文件大小</td></tr> <tr><td style="text-align:center;">deleteWhen</td> <td>04</td> <td>在每天的什么时间删除已经超过文件保留时间的 commit log</td></tr> <tr><td style="text-align:center;">fileReservedTime</td> <td>72</td> <td>以小时计算的文件保留时间</td></tr> <tr><td style="text-align:center;">brokerRole</td> <td>ASYNC_MASTER</td> <td>SYNC_MASTER/ASYNC_MASTER/SLAVE</td></tr> <tr><td style="text-align:center;">flushDiskType</td> <td>ASYNC_FLUSH</td> <td>SYNC_FLUSH/ASYNC_FLUSH SYNC_FLUSH 模式下的 broker 保证在收到确认生产者之前将消息刷盘. ASYNC_FLUSH 模式下的 broker 则利用刷盘一组消息的模式, 可以取得更好的性能.</td></tr></tbody></table> <h5 id="最佳实践"><a href="#最佳实践" class="header-anchor">#</a> 最佳实践</h5> <blockquote><p>Broker崩溃以后有什么影响?</p></blockquote> <p><strong>Master 节点崩溃</strong>. 消息不能再发送到该 Broker 集群, 但是如果有另一个可用的 Broker 集群, 那么在主题存在的条件下仍然可以发送消息. 消息仍然可以从 Slave 节点消费.</p> <p><strong>一些 Slave 节点崩溃</strong>. 只要有另一个工作的 Slave, 就不会影响发送消息. 对消费消息也不会产生影响, 除非消费者组设置为优先从该 Slave 消费. 默认情况下, 消费者组从 Master 消费.</p> <p><strong>所有 Slave 节点崩溃</strong>. 向 Master 发送消息不会有任何影响, 但如果 Master是 SYNC_MASTER, Producer会得到一个 SLAVE_NOT_AVAILABLE, 表示消息没有发送给任何 Slave. 对消费消息也没有影响, 除非消费者组设置为优先从 Slave 消费. 默认情况下, 消费者组从 Master 消费.</p> <blockquote><p>如何增加一个新的Broker?</p></blockquote> <p><strong>启动一个新的 Broker 并将其注册到 NameServer 中的 Broker 列表里</strong>.</p> <p>默认只自动创建内部系统 Topic 和 Consumer Group. 如果您希望在新节点上拥有您的业务主题和消费者组, 请从现有的 Broker 中复制它们. RocketMQ 提供了管理工具和命令行来处理此问题.</p> <blockquote><p>FlushDiskType</p></blockquote> <p><strong>SYNC_FLUSH(同步刷新)相比于 ASYNC_FLUSH(异步处理)会损失很多性能</strong>, 但是也更可靠, 所以需要根据实际的业务场景做好权衡.</p> <h4 id="nameserver🌟"><a href="#nameserver🌟" class="header-anchor">#</a> NameServer🌟</h4> <blockquote><p>NameServer 干啥用的? 直接 Producer, Consumer 和 Broker 直接进行生产消息, 消费消息不就好了么?</p></blockquote> <p>Broker 是需要保证高可用的, 如果整个系统仅仅靠着一个 Broker 来维持的话, 那么这个 Broker 的压力会很大, 所以需要使用多个 Broker 来保证 <strong>负载均衡</strong>. 如果消费者和生产者<strong>直接</strong>和多个 Broker 相连, 那么当 Broker 修改的时候必定会<strong>牵连着每个生产者和消费者</strong>, 这样就会产生<strong>耦合问题</strong>, 而 <strong>NameServer 注册中心</strong>就是用来解决这个问题的.</p> <blockquote><p>RocketMQ 为什么不使用 ZooKeeper 作为注册中心? 以及自制的 NameServer 优缺点?</p></blockquote> <p>ZooKeeper 作为支持顺序一致性的中间件, 在某些情况下, 它<strong>为了满足一致性, 会丢失一定时间内的可用性</strong>, RocketMQ 需要<strong>注册中心只是为了发现组件地址</strong>, 在某些情况下, RocketMQ 的注册中心<strong>可以出现数据不一致性</strong>, 这同时也是 NameServer 的缺点, 因为 NameServer 集群间<strong>互不通信</strong>, 它们之间的注册信息可能会不一致. 另外, 当有新的服务器加入时, NameServer 并<strong>不会立马通知</strong>到 Produer, 而是由 Produer 定时去请求 NameServer 获取最新的 Broker/Consumer 信息.</p> <h4 id="主题-topic"><a href="#主题-topic" class="header-anchor">#</a> 主题(Topic)</h4> <h5 id="定义与模型关系"><a href="#定义与模型关系" class="header-anchor">#</a> 定义与模型关系</h5> <p>主题是 RocketMQ 中消息传输和存储的顶层容器, 用于<strong>标识同一类业务逻辑的消息</strong>. 主题的作用主要如下:</p> <ul><li><strong>定义数据的分类隔离:</strong>  在 RocketMQ 的方案设计中, 建议<strong>将不同业务类型的数据拆分到不同的主题中管理, 通过主题实现存储的隔离性和订阅隔离性</strong>.</li> <li><strong>定义数据的身份和权限:</strong>  RocketMQ 的消息本身是<strong>匿名无身份</strong>的, 同一分类的消息使用相同的主题来做身份识别和权限管理.</li></ul> <p>在整个 RocketMQ 的领域模型中, 主题所处的流程和位置如下:</p> <p>​<img src="/img/image-20240825152228-7xzqjfp.png" alt="image">​</p> <p>主题是 RocketMQ 的顶层存储, 所有<strong>消息资源的定义都在主题内部完成</strong>, 但主题是一个逻辑概念, 并不是实际的消息容器.</p> <p><strong>主题内部由多个队列组成, 消息的存储和水平扩展能力最终是由队列实现的; 并且针对主题的所有约束和属性设置, 最终也是通过主题内部的队列来实现</strong>.</p> <h5 id="内部属性"><a href="#内部属性" class="header-anchor">#</a> 内部属性</h5> <blockquote><p>主题名称</p></blockquote> <p>定义: 主题的名称, 用于标识主题, 主题名称集群内全局唯一.</p> <p>取值: 由用户创建主题时定义.</p> <blockquote><p>队列列表</p></blockquote> <p>定义: 队列作为主题的组成单元, <strong>是消息存储的实际容器, 一个主题内包含一个或多个队列, 消息实际存储在主题的各队列内</strong>.</p> <p>取值: 系统根据队列数量给主题分配队列, 队列数量创建主题时定义.</p> <p>约束: 一个主题内至少包含一个队列.</p> <blockquote><p>消息类型</p></blockquote> <p>定义: 主题所支持的消息类型.</p> <p>取值: 创建主题时选择<strong>消息类型</strong>. RocketMQ 支持的主题类型如下:</p> <ul><li><strong>Normal</strong>: 普通消息(参考: 普通消息), 消息本身无特殊语义, 消息之间也<strong>没有任何关联</strong>.</li> <li><strong>FIFO</strong>: 顺序消息(参考: 顺序消息), RocketMQ 通过消<strong>息分组 MessageGroup 标记一组特定消息的先后顺序, 可以保证消息的投递顺序严格按照消息发送时的顺序</strong>.</li> <li><strong>Delay</strong>: 定时/延时消息(参考: 定时延时消息), 通过指定延时时间控制消息生产后不要立即投递, 而是在延时间隔后才对消费者可见.</li> <li><strong>Transaction</strong>: 事务消息(参考: 事务消息), RocketMQ 支持分布式事务消息, 支持应用数据库更新和消息调用的事务一致性保障.</li></ul> <p>约束: RocketMQ 从 5.0 版本开始, 支持强制校验消息类型, 即<strong>每个主题只允许发送一种消息类型的消息</strong>, 这样可以更好的运维和管理生产系统, 避免混乱. 强制校验功能默认开启.</p> <h5 id="行为约束"><a href="#行为约束" class="header-anchor">#</a> 行为约束</h5> <blockquote><p>消息类型强制校验</p></blockquote> <p>RocketMQ 5.x 版本支持将消息类型拆分到主题中进行独立运维和处理, 因此系统会对发送的消息类型和主题定的消息类型进行强制校验, 若校验不通过, 则消息发送请求会被拒绝, 并返回类型不匹配异常. 校验原则如下:</p> <ul><li><strong>消息类型必须一致</strong>: 发送的消息的类型, 必须和目标主题定义的消息类型一致.</li> <li><strong>主题类型必须单一</strong>: 每个主题只支持一种消息类型, 不允许将多种类型的消息发送到同一个主题中.</li></ul> <blockquote><p>常见错误使用场景</p></blockquote> <ul><li>发送的消息类型不匹配例如, 创建主题时消息类型定义为顺序消息, 发送消息时发送事务消息到该主题中, 此时消息发送请求会被拒绝, 并返回类型不匹配异常.</li> <li>单一消息主题混用例如, 创建主题时消息类型定义为普通消息, 发送消息时同时发送普通消息和顺序消息到该主题中, 则顺序消息的发送请求会被拒绝, 并返回类型不匹配异常.</li></ul> <h5 id="使用示例"><a href="#使用示例" class="header-anchor">#</a> 使用示例</h5> <p>RocketMQ 5.0 版本下<strong>创建主题</strong>操作, 推荐使用 mqadmin 工具, 需要注意的是, 对于消息类型需要通过属性参数添加. 示例如下:</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token function">sh</span> mqadmin updateTopic <span class="token parameter variable">-n</span> <span class="token operator">&lt;</span>nameserver_address<span class="token operator">&gt;</span> <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>topic_name<span class="token operator">&gt;</span> <span class="token parameter variable">-c</span> <span class="token operator">&lt;</span>cluster_name<span class="token operator">&gt;</span> <span class="token parameter variable">-a</span> +message.type<span class="token operator">=</span><span class="token operator">&lt;</span>message_type<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其中 message_type 根据消息类型设置成 <code>Normal/FIFO/Delay/Transaction</code>​. 如果不设置, 默认为 Normal 类型.</p> <h5 id="使用建议"><a href="#使用建议" class="header-anchor">#</a> 使用建议</h5> <blockquote><p>按照业务分类合理拆分主题</p></blockquote> <p>RocketMQ 的主题拆分设计应遵循大类统一原则, 即<strong>将相同业务域内同一功能属性的消息划分为同一主题</strong>. 拆分主题时, 可以从以下角度考虑拆分粒度:</p> <ul><li><strong>消息类型是否一致</strong>: 不同类型的消息, 如顺序消息和普通消息需要使用不同的主题.</li> <li><strong>消息业务是否关联</strong>: 如果业务没有直接关联, 比如, 淘宝交易消息和盒马物流消息没有业务交集, 需要使用不同的消息主题; 同样是淘宝交易消息, 女装类订单和男装类订单可以使用同一个订单. 当然, 如果业务量较大或其他子模块应用处理业务时需要进一步拆分订单类型, 您也可以将男装订单和女装订单的消息拆分到两个主题中.</li> <li><strong>消息量级是否一样</strong>: 数量级不同或时效性不同的业务消息建议使用不同的主题, 例如某些业务消息量很小但是时效性要求很强, 如果跟某些万亿级消息量的业务使用同一个主题, 会增加消息的等待时长.</li></ul> <p><strong>正确拆分示例:</strong>  线上商品购买场景下, 订单交易如订单创建, 支付, 取消等流程消息使用一个主题, 物流相关消息使用一个主题, 积分管理相关消息使用一个主题.</p> <p><strong>错误拆分示例</strong>:</p> <ul><li>拆分粒度过粗: 会导致业务隔离性差, 不利于独立运维和故障处理. 例如, 所有交易消息和物流消息都共用一个主题.</li> <li>拆分粒度过细: 会消耗大量主题资源, 造成系统负载过重. 例如, 按照用户 ID 区分, 每个用户 ID 使用一个主题.</li></ul> <blockquote><p>单一主题只收发一种类型消息, 避免混用</p></blockquote> <p>RocketMQ 主题的设计原则为<mark><strong>通过主题隔离业务, 不同业务逻辑的消息建议使用不同的主题</strong></mark>. 同一业务逻辑消息的类型都相同, 因此, 对于指定主题, 应该只收发同一种类型的消息.</p> <h4 id="队列-messagequeue"><a href="#队列-messagequeue" class="header-anchor">#</a> 队列(MessageQueue)</h4> <h5 id="定义与模型关系-2"><a href="#定义与模型关系-2" class="header-anchor">#</a> 定义与模型关系</h5> <p>队列是 RocketMQ 中<strong>消息存储和传输的实际容器</strong>, 也是 RocketMQ 消息的最小存储单元. RocketMQ 的<strong>所有主题都是由多个队列组成, 以此实现队列数量的水平拆分和队列内部的流式存储</strong>.</p> <p>队列的主要作用如下:</p> <ul><li><strong>存储顺序性</strong>: 队列天然具备顺序性, 即<strong>消息按照进入队列的顺序写入存储, 同一队列间的消息天然存在顺序关系, 队列头部为最早写入的消息, 队列尾部为最新写入的消息</strong>. 消息在队列中的位置和消息之间的顺序通过位点(<strong>Offset</strong>)进行标记管理.</li> <li><strong>流式操作语义</strong>: RocketMQ 基于队列的存储模型可确保消息<strong>从任意位点读取任意数量的消息</strong>, 以此实现类似聚合读取, 回溯读取等特性, 这些特性是 RabbitMQ, ActiveMQ 等非队列存储模型不具备的.</li></ul> <p>在整个 RocketMQ 的领域模型中, 队列所处的流程和位置如下:</p> <p>​<img src="/img/image-20240825152228-7xzqjfp.png" alt="image">​</p> <p>RocketMQ 默认提供消息可靠存储机制, <strong>所有发送成功的消息都被持久化存储到队列中, 配合生产者和消费者客户端的调用可实现至少投递一次的可靠性语义</strong>.</p> <p><strong>RocketMQ 确保所有消息至少传递一次, 因为还可以重置消费位点进行重复消费</strong>. 在大多数情况下, 消息不会重复.</p> <p><strong>RocketMQ 队列模型和 Kafka 的分区(Partition)模型类似</strong>. 在 RocketMQ 消息收发模型中, 队列属于主题的一部分, 虽然所有的消息资源以主题粒度管理, 但实际的操作实现是面向队列. 例如, 生产者指定某个主题, 向主题内发送消息, 但实际消息发送到该主题下的某个队列中.</p> <p>RocketMQ 中<strong>通过修改队列数量, 以此实现横向的水平扩容和缩容</strong>.</p> <h5 id="使用建议-2"><a href="#使用建议-2" class="header-anchor">#</a> 使用建议</h5> <p>每个主题下会由一到多个队列来存储消息, 每个主题对应的队列数与消息类型以及实例所处地域(Region)相关.</p> <p>在开发过程中, <strong>建议不要对队列名称做任何假设和绑定</strong>. 如果在代码中自定义拼接队列名称并和其他操作进行绑定, 一旦服务端版本升级, 可能会出现队列名称无法解析的兼容性问题.</p> <blockquote><p>按照实际业务消耗设置队列数</p></blockquote> <p>RocketMQ 的队列数可在创建主题或变更主题时设置修改, 队列数量的设置应<strong>遵循少用够用原则</strong>, 避免随意增加队列数量.</p> <p>主题内队列数过多可能对导致如下问题:</p> <ul><li><strong>集群元数据膨胀</strong>: RocketMQ 会以队列粒度采集指标和监控数据, 队列过多容易造成管控元数据膨胀.</li> <li><strong>客户端压力过大</strong>: RocketMQ 的消息读写都是针对队列进行操作, 队列过多对应更多的轮询请求, 增加系统负荷.</li></ul> <blockquote><p>常见需要队列增加的场景</p></blockquote> <p><strong>需要增加队列实现物理节点负载均衡</strong>: RocketMQ 每个主题的<strong>多个队列可以分布在不同的服务节点上, 在集群水平扩容增加节点后, 为了保证集群流量的负载均衡</strong>, 建议在新的服务节点上新增队列, 或将旧的队列迁移到新的服务节点上.</p> <h4 id="消息-message"><a href="#消息-message" class="header-anchor">#</a> 消息(Message)</h4> <h5 id="定义与模型关系-3"><a href="#定义与模型关系-3" class="header-anchor">#</a> 定义与模型关系</h5> <p>消息是 RocketMQ 中的<strong>最小数据传输单元</strong>. 生产者将业务数据的负载和拓展属性包装成消息发送到 RocketMQ 服务端, 服务端按照相关语义将消息投递到消费端进行消费.</p> <p>RocketMQ 的消息模型具备如下特点:</p> <ul><li><strong>消息不可变性</strong>: 消息本质上是已经产生并确定的事件, 一旦产生后, <strong>消息的内容不会发生改变</strong>. 即使经过传输链路的控制也不会发生变化, 消费端获取的消息都是只读消息视图.</li> <li><strong>消息持久化</strong>: RocketMQ 会默认<strong>对消息进行持久化</strong>, 即<strong>将接收到的消息存储到 RocketMQ 服务端的存储文件中, 保证消息的可回溯性和系统故障场景下的可恢复性</strong>.</li></ul> <p>在整个 RocketMQ 的领域模型中, 消息所处的流程和位置如下:</p> <p>​<img src="/img/image-20240825152228-7xzqjfp.png" alt="image">​</p> <ol><li>消息由生产者初始化并发送到 RocketMQ 服务端.</li> <li>消息按照到达 RocketMQ 服务端的顺序存储到队列中.</li> <li>消费者按照指定的订阅关系从 RocketMQ 服务端中获取消息并消费.</li></ol> <h5 id="内部属性-2"><a href="#内部属性-2" class="header-anchor">#</a> 内部属性</h5> <p>下面是消息中包含的属性.</p> <blockquote><p>主题名称</p></blockquote> <p>定义: 当前消息所属的主题的名称. 集群内全局唯一.</p> <p>取值: 从客户端 SDK 接口获取.</p> <blockquote><p>消息类型</p></blockquote> <p>定义: 当前消息的类型.</p> <p>取值: 从客户端 SDK 接口获取. RocketMQ 支持的消息类型如下: 普通消息, 顺序消息, 延时消息, 事务消息.</p> <blockquote><p>消息队列</p></blockquote> <p>定义: 实际存储当前消息的队列.</p> <p>取值: 由服务端指定并填充.</p> <blockquote><p>消息位点</p></blockquote> <p>定义: 当前消息存储在队列中的位置.</p> <p>取值: 由服务端指定并填充. 取值范围: 0~long.Max.</p> <blockquote><p>消息ID</p></blockquote> <p>定义: <strong>消息的唯一标识, 集群内每条消息的 ID 全局唯一</strong>.</p> <p>取值: 生产者客户端系统自动生成. 固定为数字和大写字母组成的 32 位字符串.</p> <blockquote><p>索引Key列表(可选)</p></blockquote> <p>定义: 消息的索引键, 可通过设置不同的 Key 区分消息和快速查找消息.</p> <p>取值: 由生产者客户端定义.</p> <blockquote><p>过滤标签Tag(可选)</p></blockquote> <p>定义: 消息的过滤标签. 消费者可通过 Tag 对消息进行过滤, 仅接收指定标签的消息.</p> <p>取值: 由生产者客户端定义.</p> <p>约束: 一条消息仅支持设置一个标签.</p> <blockquote><p>定时时间(可选)</p></blockquote> <p>定义: 定时场景下, 消息触发延时投递的毫秒级时间戳.</p> <p>取值: 由消息生产者定义.</p> <p>约束: 最大可设置定时时长为 40 天.</p> <blockquote><p>消息发送时间</p></blockquote> <p>定义: 消息发送时, 生产者客户端系统的本地毫秒级时间戳.</p> <p>取值: 由生产者客户端系统填充.</p> <p>说明: 客户端系统时钟和服务端系统时钟可能存在偏差, 消息发送时间是以客户端系统时钟为准.</p> <blockquote><p>消息保存时间戳</p></blockquote> <p>定义: 消息在 RocketMQ 服务端完成存储时, 服务端系统的本地毫秒级时间戳. 对于定时消息和事务消息, 消息保存时间指的是消息生效对消费方可见的服务端系统时间.</p> <p>取值: 由服务端系统填充.</p> <p>说明: 客户端系统时钟和服务端系统时钟可能存在偏差, 消息保留时间是以服务端系统时钟为准.</p> <blockquote><p>消费重试次数</p></blockquote> <p>定义: 消息消费失败后, RocketMQ 服务端重新投递的次数. 每次重试后, 重试次数加 1.</p> <p>取值: 由服务端系统标记. 首次消费, 重试次数为 0; 消费失败首次重试时, 重试次数为 1.</p> <blockquote><p>业务自定义属性</p></blockquote> <p>定义: 生产者可以自定义设置的扩展信息.</p> <p>取值: 由消息生产者自定义, 按照字符串键值对设置.</p> <blockquote><p>消息负载</p></blockquote> <p>定义: <strong>业务消息的实际报文数据</strong>.</p> <p>取值: 由生产者负责序列化编码, 按照二进制字节传输.</p> <h5 id="使用建议-3"><a href="#使用建议-3" class="header-anchor">#</a> 使用建议</h5> <blockquote><p>单条消息不建议传输超大负载</p></blockquote> <p>作为一款消息中间件产品, RocketMQ 一般传输的是都是<strong>业务事件数据</strong>. 单个原子消息事件的数据大小需要严格控制, 如果单条消息过大容易造成网络传输层压力, 不利于异常重试和流量控制.</p> <p>生产环境中如果需要传输超大负载, 建议按照<strong>固定大小做报文拆分, 或者结合文件存储</strong>等方法进行传输.</p> <blockquote><p>消息中转时做好不可变设计</p></blockquote> <p>RocketMQ 服务端 5.x 版本中, 消息本身不可编辑, 消费端获取的消息都是<strong>只读消息视图</strong>. 但在历史版本 3.x 和 4.x 版本中消息不可变性没有强约束, 因此如果需要在使用过程中对消息进行中转操作, 务必将消息重新初始化.</p> <p>正确使用示例如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Message</span> m <span class="token operator">=</span> <span class="token class-name">Consumer</span><span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Message</span> m2 <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">buildFrom</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Producer</span><span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>m2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>错误使用示例如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Message</span> m <span class="token operator">=</span> <span class="token class-name">Consumer</span><span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token class-name">Producer</span><span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="生产者-producer"><a href="#生产者-producer" class="header-anchor">#</a> 生产者(Producer)</h4> <h5 id="定义与模型关系-4"><a href="#定义与模型关系-4" class="header-anchor">#</a> 定义与模型关系</h5> <p>生产者是 RocketMQ 系统中用来<strong>构建并传输消息到服务端的运行实体</strong>. 生产者通常被集成在业务系统中, 将<strong>业务消息按照要求封装成消息(Message)并发送至服务端</strong>.</p> <p>在消息生产者中, 可以定义如下传输行为:</p> <ul><li><strong>发送方式</strong>: 生产者可通过 API 接口设置消息发送的方式. RocketMQ 支持<strong>同步传输和异步传输</strong>.</li> <li><strong>批量发送</strong>: 生产者可通过 API 接口设置消息批量传输的方式. 例如, 批量发送的消息条数或消息大小.</li> <li><strong>事务行为</strong>: RocketMQ 支持事务消息, 对于事务消息需要生产者配合进行事务检查等行为保障事务的最终一致性.</li></ul> <p><strong>生产者和主题的关系为多对多关系</strong>, 即同一个生产者可以向多个主题发送消息, 对于平台类场景如果需要发送消息到多个主题, 并不需要创建多个生产者; 同一个主题也可以接收多个生产者的消息, 以此可以实现生产者性能的水平扩展和容灾.</p> <p><img src="/img/image-20240825201852-r6gjbvl.png" alt="image"></p> <p>在 RocketMQ 的领域模型中, 生产者的位置和流程如下:</p> <p>​<img src="/img/image-20240825152228-7xzqjfp.png" alt="image">​</p> <ol><li>消息由生产者初始化并发送到 RocketMQ 服务端.</li> <li>消息按照到达 RocketMQ 服务端的顺序存储到主题的指定队列中.</li> <li>消费者按照指定的订阅关系从 RocketMQ 服务端中获取消息并消费.</li></ol> <h5 id="内部属性-3"><a href="#内部属性-3" class="header-anchor">#</a> 内部属性</h5> <p>下面是生产者包含的内部属性信息.</p> <blockquote><p>客户端ID</p></blockquote> <p>定义: 生产者客户端的标识, 用于区分不同的生产者. 集群内全局唯一.</p> <p>取值: 客户端 ID 由 RocketMQ 的 SDK 自动生成, 主要用于日志查看, 问题定位等运维场景, 不支持修改.</p> <blockquote><p>通信参数</p></blockquote> <p><strong>接入点信息(必选)</strong> : 连接服务端的接入地址, 用于识别服务端集群. 接入点必须按格式配置, 建议使用域名, 避免使用 IP 地址, 防止节点变更无法进行热点迁移.</p> <p><strong>身份认证信息(可选)</strong> : 客户端用于身份验证的凭证信息.  仅在服务端开启身份识别和认证时需要传输.</p> <p><strong>请求超时时间(可选)</strong> : 客户端网络请求调用的超时时间.</p> <blockquote><p>预绑定主题列表</p></blockquote> <p>定义: RocketMQ 的生产者需要将消息发送到的目标主题列表, 主要作用如下:</p> <ul><li><strong>事务消息(必须设置)</strong> : 事务消息场景下, 生产者在故障, 重启恢复时, 需要检查事务消息的主题中是否有未提交的事务消息. 避免生产者发送新消息后, 主题中的旧事务消息一直处于未提交状态, 造成业务延迟.</li> <li><strong>非事务消息(建议设置)</strong> : 服务端会在生产者初始化时根据预绑定主题列表, 检查目标主题的访问权限和合法性, 而不需要等到应用启动后再检查. 若未设置, 或后续消息发送的目标主题动态变更, RocketMQ 会对目标主题进行动态补充检验.</li></ul> <p>约束: 对于事务消息, 预绑定列表必须设置, 且需要和事务检查器一起配合使用.</p> <blockquote><p>事务检查器</p></blockquote> <p>定义: RocketMQ 的事务消息机制中, 为保证异常场景下事务的最终一致性, 生产者需要主动实现事务检查器的接口.</p> <p>发送事务消息时, 事务检查器必须设置, 且需要和预绑定主题列表一起配合使用.</p> <blockquote><p>发送重试策略</p></blockquote> <p>定义: 生产者在消息发送失败时的重试策略.</p> <h5 id="使用建议-4"><a href="#使用建议-4" class="header-anchor">#</a> 使用建议</h5> <blockquote><p>不建议单一进程创建大量生产者</p></blockquote> <p>RocketMQ 的生产者和主题是多对多的关系, 支持同一个生产者向多个主题发送消息. 对于生产者的创建和初始化, 建议遵循够用即可, 最大化复用原则, 如果有需要发送消息到多个主题的场景, 无需为每个主题都创建一个生产者.</p> <blockquote><p>不建议频繁创建和销毁生产者</p></blockquote> <p>RocketMQ 的生产者是可以<strong>重复利用的底层资源</strong>, 类似数据库的连接池. 因此不需要在每次发送消息时动态创建生产者, 且在发送结束后销毁生产者. 这样频繁的创建销毁会在服务端产生大量短连接请求, 严重影响系统性能.</p> <p>正确示例:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Producer</span> p <span class="token operator">=</span> <span class="token class-name">ProducerBuilder</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Message</span> m <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
p<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>典型错误示例:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">Producer</span> p <span class="token operator">=</span> <span class="token class-name">ProducerBuilder</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Message</span> m <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="消费者分组-consumergroup"><a href="#消费者分组-consumergroup" class="header-anchor">#</a> 消费者分组(ConsumerGroup)</h4> <h5 id="定义与模型关系-5"><a href="#定义与模型关系-5" class="header-anchor">#</a> 定义与模型关系</h5> <p><strong>消费者分组是 RocketMQ 系统中承载多个消费行为一致的消费者的负载均衡分组</strong>.</p> <p>和消费者不同, 消费者分组并不是运行实体, 而是一个逻辑资源. 在 RocketMQ 中, <strong>通过消费者分组内初始化多个消费者实现消费性能的水平扩展以及高可用容灾</strong>.</p> <p>在消费者分组中, 统一定义以下<strong>消费行为</strong>, 同一分组下的多个消费者将按照分组内统一的消费行为和负载均衡策略消费消息.</p> <ul><li><strong>订阅关系</strong>: RocketMQ 以消费者分组的粒度管理订阅关系, 实现订阅关系的管理和追溯. 具体信息参考: 订阅关系(Subscription).</li> <li><strong>投递顺序性</strong>: RocketMQ 的服务端将消息投递给消费者消费时, 支持顺序投递和并发投递, 投递方式在消费者分组中统一配置.</li> <li><strong>消费重试策略</strong>: 消费者消费消息失败时的重试策略, 包括重试次数, 死信队列设置等. 具体信息参考: 消费重试.</li></ul> <p>在 RocketMQ 的领域模型中, <strong>消费者分组的位置和流程</strong>如下:</p> <p>​<img src="/img/image-20240825152228-7xzqjfp.png" alt="image">​</p> <ol><li>消息由生产者初始化并发送到 RocketMQ 服务端.</li> <li>消息按照到达 RocketMQ 服务端的顺序存储到主题的指定队列中.</li> <li>消费者按照指定的订阅关系从 RocketMQ 服务端中获取消息并消费.</li></ol> <h5 id="内部属性-4"><a href="#内部属性-4" class="header-anchor">#</a> 内部属性</h5> <p>消费者分组可能包含的属性如下.</p> <blockquote><p>消费者分组名称</p></blockquote> <p>定义: 消费者分组的名称, 用于区分不同的消费者分组. 集群内全局唯一.</p> <p>取值: 消费者分组由用户设置并创建.</p> <blockquote><p>投递顺序性</p></blockquote> <p>定义: 消费者消费消息时, RocketMQ 向消费者客户端投递消息的顺序. 根据不同的消费场景, RocketMQ 提供<strong>顺序投递和并发投递</strong>两种方式.</p> <p>取值: 默认投递方式为并发投递.</p> <blockquote><p>消费重试策略</p></blockquote> <p>定义: 消费者消费消息失败时, 系统的重试策略. 消费者消费消息失败时, 系统会按照重试策略, 将指定消息投递给消费者重新消费.</p> <p>取值: 重试策略包括:</p> <ul><li><strong>最大重试次数</strong>: 表示消息可以重新被投递的最大次数, 超过最大重试次数还没被成功消费, 消息将被投递至死信队列或丢弃.</li> <li><strong>重试间隔</strong>: RocketMQ 服务端重新投递消息的间隔时间.</li></ul> <p>约束: 重试间隔仅在 PushConsumer 消费类型下有效.</p> <blockquote><p>订阅关系</p></blockquote> <p>定义: 当前消费者分组关联的订阅关系集合. 包括消费者订阅的主题, 以及消息的过滤规则等. 订阅关系由消费者动态注册到消费者分组中, RocketMQ 服务端会持久化订阅关系并匹配消息的消费进度.</p> <h5 id="使用建议-5"><a href="#使用建议-5" class="header-anchor">#</a> 使用建议</h5> <blockquote><p>按照业务合理拆分分组</p></blockquote> <p>RocketMQ 的消费者和主题是多对多的关系, 对于消费者分组的拆分设计, 建议遵循以下原则:</p> <ul><li><strong>消费者的投递顺序一致</strong>: 同一消费者分组下所有消费者的消费投递顺序是相同的, 统一都是顺序投递或并发投递, 不同业务场景不能混用消费者分组.</li> <li><strong>消费者业务类型一致</strong>: 一般消费者分组和主题对应, 不同业务域对消息消费的要求不同, 例如消息过滤属性, 消费重试策略不同. 因此, 不同业务域主题的消费建议使用不同的消费者分组, 避免一个消费者分组消费超过10个主题.</li></ul> <h4 id="消费者-consumer"><a href="#消费者-consumer" class="header-anchor">#</a> 消费者(Consumer)</h4> <h5 id="定义与模型关系-6"><a href="#定义与模型关系-6" class="header-anchor">#</a> 定义与模型关系</h5> <p><strong>消费者是 RocketMQ 中用来接收并处理消息的运行实体</strong>. 消费者通常被集成在业务系统中, 从 RocketMQ 服务端获取消息, 并将消息转化成业务可理解的信息, 供业务逻辑处理.</p> <p>在消息消费端, 可以定义如下<strong>传输行为</strong>:</p> <ul><li><strong>消费者身份</strong>: 消费者必须关联一个指定的消费者分组, 以获取分组内统一定义的行为配置和消费状态.</li> <li><strong>消费者类型</strong>: RocketMQ 面向不同的开发场景提供了多样的消费者类型, 包括 PushConsumer 类型, SimpleConsumer 类型, PullConsumer 类型(仅推荐流处理场景使用)等.</li> <li><strong>消费者本地运行配置</strong>: 消费者根据不同的消费者类型, 控制消费者客户端本地的运行配置. 例如消费者客户端的线程数, 消费并发度等, 实现不同的传输效果.</li></ul> <p>在 RocketMQ 的领域模型中, 消费者的位置和流程如下:</p> <p>​<img src="/img/image-20240825152228-7xzqjfp.png" alt="image">​</p> <ol><li>消息由生产者初始化并发送到 RocketMQ 服务端.</li> <li>消息按照到达 RocketMQ 服务端的顺序存储到主题的指定队列中.</li> <li>消费者按照指定的订阅关系从 RocketMQ 服务端中获取消息并消费.</li></ol> <h5 id="内部属性-5"><a href="#内部属性-5" class="header-anchor">#</a> 内部属性</h5> <p>下面是消费者可能包含的属性信息.</p> <blockquote><p>消费者分组名称</p></blockquote> <p>定义: 当前消费者关联的消费者分组名称, 消费者必须关联到指定的消费者分组, 通过消费者分组获取消费行为. 更多信息.</p> <p>取值: 消费者分组为 RocketMQ 的逻辑资源, 需要提前通过控制台或 OpenAPI 创建.</p> <blockquote><p>客户端ID</p></blockquote> <p>定义: 消费者客户端的标识, 用于区分不同的消费者. 集群内全局唯一.</p> <p>取值: 客户端 ID 由 RocketMQ 的 SDK 自动生成, 主要用于日志查看, 问题定位等运维场景, 不支持修改.</p> <blockquote><p>通信参数</p></blockquote> <p><strong>接入点信息(必选)</strong> : 连接服务端的接入地址, 用于识别服务端集群. 接入点必须按格式配置, 建议使用域名, 避免使用IP地址, 防止节点变更无法进行热点迁移.</p> <p><strong>身份认证信息(可选)</strong> : 客户端用于身份验证的凭证信息. 仅在服务端开启身份识别和认证时需要传输.</p> <p><strong>请求超时时间(可选)</strong> : 客户端网络请求调用的超时时间.</p> <blockquote><p>预绑定订阅关系列表</p></blockquote> <p>定义: 指定消费者的订阅关系列表. RocketMQ 服务端可在消费者初始化阶段, 根据预绑定的订阅关系列表对目标主题进行权限及合法性校验, 无需等到应用启动后才能校验.</p> <p>取值: <strong>建议在消费者初始化阶段明确订阅关系即要订阅的主题列表</strong>, 若未设置, 或订阅的主题动态变更, RocketMQ 会对目标主题进行动态补充校验.</p> <blockquote><p>消费监听器</p></blockquote> <p>定义: RocketMQ 服务端将消息推送给消费者后, 消费者调用消息消费逻辑的监听器.</p> <p>取值: 由消费者客户端本地配置.</p> <p>约束: 使用 PushConsumer 类型的消费者消费消息时, 消费者客户端必须设置消费监听器.</p> <h5 id="行为约束-2"><a href="#行为约束-2" class="header-anchor">#</a> 行为约束</h5> <p>在 RocketMQ 领域模型中, 消费者的管理通过消费者分组实现, 同一分组内的消费者共同分摊消息进行消费. 因此, 为了保证分组内消息的正常负载和消费.</p> <p>RocketMQ 要求<strong>同一分组下的所有消费者</strong>以下消费行为保持一致:</p> <ul><li><strong>投递顺序</strong></li> <li><strong>消费重试策略</strong></li></ul> <h5 id="使用建议-6"><a href="#使用建议-6" class="header-anchor">#</a> 使用建议</h5> <blockquote><p>不建议在单一进程内创建大量消费者</p></blockquote> <p>RocketMQ 的消费者在通信协议层面支持非阻塞传输模式, 网络通信效率较高, 并且支持多线程并发访问. 因此, <strong>大部分场景下, 单一进程内同一个消费分组只需要初始化唯一的一个消费者即可</strong>, 开发过程中应避免以相同的配置初始化多个消费者.</p> <blockquote><p>不建议频繁创建和销毁消费者</p></blockquote> <p>RocketMQ 的消费者是可以<strong>重复利用的底层资源, 类似数据库的连接池</strong>. 因此不需要在每次接收消息时动态创建消费者, 且在消费完成后销毁消费者. 这样频繁地创建销毁会在服务端产生大量短连接请求, 严重影响系统性能.</p> <p>正确示例:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Consumer</span> c <span class="token operator">=</span> <span class="token class-name">ConsumerBuilder</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Message</span> m<span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// process message</span>
<span class="token punctuation">}</span>
c<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>典型错误示例:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Consumer</span> c <span class="token operator">=</span> <span class="token class-name">ConsumerBuilder</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Message</span> m <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//process message</span>
    c<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="订阅关系-subscription"><a href="#订阅关系-subscription" class="header-anchor">#</a> 订阅关系(Subscription)</h4> <h5 id="定义与模型关系-7"><a href="#定义与模型关系-7" class="header-anchor">#</a> 定义与模型关系</h5> <p>订阅关系是 RocketMQ 系统中<strong>消费者获取消息, 处理消息的规则和状态配置</strong>.</p> <p><strong>订阅关系由消费者分组动态注册到服务端系统, 并在后续的消息传输中按照订阅关系定义的过滤规则进行消息匹配和消费进度维护</strong>.</p> <p>通过配置订阅关系, 可控制如下传输行为:</p> <ul><li><strong>消息过滤规则</strong>: 用于控制消费者在消费消息时, 选择主题内的哪些消息进行消费, 设置消费过滤规则可以高效地过滤消费者需要的消息集合, 灵活根据不同的业务场景设置不同的消息接收范围. 具体信息参考: 消息过滤.</li> <li><strong>消费状态</strong>: RocketMQ 服务端默认提供订阅关系持久化的能力, 即消费者分组在服务端注册订阅关系后, 当消费者离线并再次上线后, 可以获取离线前的消费进度并继续消费.</li></ul> <p>在 RocketMQ 的领域模型中, 订阅关系的位置和流程如下:</p> <p>​<img src="/img/image-20240825152228-7xzqjfp.png" alt="image">​</p> <ol><li>消息由生产者初始化并发送到 RocketMQ 服务端.</li> <li>消息按照到达 RocketMQ 服务端的顺序存储到主题的指定队列中.</li> <li><strong>消费者按照指定的订阅关系从 RocketMQ 服务端中获取消息并消费</strong>.</li></ol> <h5 id="订阅关系判断原则"><a href="#订阅关系判断原则" class="header-anchor">#</a> 订阅关系判断原则</h5> <p>RocketMQ 的订阅关系按照消费者分组和主题粒度设计, 因此, <strong>一个订阅关系指的是指定某个消费者分组对于某个主题的订阅</strong>, 判断原则如下:</p> <p>(1) <strong>不同消费者分组对于同一个主题的订阅相互独立</strong>. 如下图所示, 消费者分组 Group A 和消费者分组 Group B 分别以不同的订阅关系订阅了同一个主题 Topic A, 这两个订阅关系<strong>互相独立, 可以各自定义, 不受影响</strong>.</p> <p><img src="/img/image-20240825202448-jivhi4j.png" alt="image"></p> <p>(2) <strong>同一个消费者分组对于不同主题的订阅也相互独立</strong>. 如下图所示, 消费者分组 Group A 订阅了两个主题 Topic A 和 Topic B, 对于 Group A 中的消费者来说, 订阅的 Topic A 为一个订阅关系, 订阅的 Topic B 为另外一个订阅关系, 且这<strong>两个订阅关系互相独立, 可以各自定义, 不受影响</strong>.</p> <p>​<img src="/img/image-20240825203052-x4izu2m.png" alt="image">​</p> <h5 id="内部属性-6"><a href="#内部属性-6" class="header-anchor">#</a> 内部属性</h5> <blockquote><p>过滤类型</p></blockquote> <p>定义: 消息过滤规则的类型. <strong>订阅关系中设置消息过滤规则后, 系统将按照过滤规则匹配主题中的消息, 只将符合条件的消息投递给消费者消费, 实现消息的再次分类</strong>.</p> <p>取值:</p> <ul><li><strong>TAG 过滤</strong>: 按照 Tag 字符串进行全文过滤匹配.</li> <li>SQL92 过滤: 按照 SQL 语法对消息属性进行过滤匹配.</li></ul> <blockquote><p>过滤表达式</p></blockquote> <p>定义: 自定义的过滤规则表达式.</p> <h5 id="行为约束-3"><a href="#行为约束-3" class="header-anchor">#</a> 行为约束</h5> <blockquote><p>订阅关系一致</p></blockquote> <p>RocketMQ 是按照消费者分组粒度管理订阅关系, 因此, <strong>同一消费者分组内的消费者在消费逻辑上必须保持一致</strong>, 否则会出现消费冲突, 导致部分消息消费异常.</p> <p>正确示例</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Consumer c1</span>
<span class="token class-name">Consumer</span> c1 <span class="token operator">=</span> <span class="token class-name">ConsumerBuilder</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>groupA<span class="token punctuation">)</span><span class="token punctuation">;</span>
c1<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>topicA<span class="token punctuation">,</span> <span class="token string">&quot;TagA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Consumer c2</span>
<span class="token class-name">Consumer</span> c2 <span class="token operator">=</span> <span class="token class-name">ConsumerBuilder</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>groupA<span class="token punctuation">)</span><span class="token punctuation">;</span>
c2<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>topicA<span class="token punctuation">,</span> <span class="token string">&quot;TagA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>错误示例</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Consumer c1</span>
<span class="token class-name">Consumer</span> c1 <span class="token operator">=</span> <span class="token class-name">ConsumerBuilder</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>groupA<span class="token punctuation">)</span><span class="token punctuation">;</span>
c1<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>topicA<span class="token punctuation">,</span> <span class="token string">&quot;TagA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Consumer c2</span>
<span class="token class-name">Consumer</span> c2 <span class="token operator">=</span> <span class="token class-name">ConsumerBuilder</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>groupA<span class="token punctuation">)</span><span class="token punctuation">;</span>
c2<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>topicA<span class="token punctuation">,</span> <span class="token string">&quot;TagB&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h5 id="使用建议-7"><a href="#使用建议-7" class="header-anchor">#</a> 使用建议</h5> <blockquote><p>建议不要频繁修改订阅关系</p></blockquote> <p>在 RocketMQ 领域模型中, <strong>订阅关系关联了过滤规则, 消费进度等元数据和相关配置, 同时系统需要保证消费者分组下的所有消费者的消费行为, 消费逻辑, 负载策略等一致, 整体运算逻辑比较复杂</strong>. 因此, 不建议在生产环境中通过频繁修改订阅关系来实现业务逻辑的变更, 这样可能会导致客户端一直处于负载均衡调整和变更的过程, 从而影响消息接收.</p> <h5 id="订阅关系一致"><a href="#订阅关系一致" class="header-anchor">#</a> 订阅关系一致</h5> <p><strong>订阅关系一致是指, 同一个消费者组下所有消费者实例所订阅的 Topic, Tag 必须完全一致</strong>. 如果订阅关系(消费者分组名-Topic-Tag)不一致, <strong>会导致消费消息紊乱, 甚至消息丢失</strong>.</p> <h6 id="_1-正确订阅关系示例"><a href="#_1-正确订阅关系示例" class="header-anchor">#</a> 1.正确订阅关系示例</h6> <blockquote><p>订阅的Topic一样, 且过滤表达式一致</p></blockquote> <p>如下图所示, 同一 ConsumerGroup 下的三个 Consumer 实例 C1, C2 和 C3 分别都订阅了 TopicA, 且订阅 TopicA 的 Tag 也都是 Tag1, 符合订阅关系一致原则.</p> <p><img src="/img/image-20240825203437-8yxu1ur.png" alt="image"></p> <p>正确示例代码: C1, C2, C3 的订阅关系一致, 即 C1, C2, C3 订阅消息的代码必须完全一致, 代码示例如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">PushConsumer</span> consumer1 <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">newPushConsumerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setConsumerGroup</span><span class="token punctuation">(</span><span class="token string">&quot;GroupA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
consumer1<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;TopicA&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">FilterExpression</span><span class="token punctuation">(</span><span class="token string">&quot;TagA&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FilterExpressionType</span><span class="token punctuation">.</span><span class="token constant">TAG</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
<span class="token class-name">PushConsumer</span> consumer2 <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">newPushConsumerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setConsumerGroup</span><span class="token punctuation">(</span><span class="token string">&quot;GroupA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
consumer2<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;TopicA&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">FilterExpression</span><span class="token punctuation">(</span><span class="token string">&quot;TagA&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FilterExpressionType</span><span class="token punctuation">.</span><span class="token constant">TAG</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
<span class="token class-name">PushConsumer</span> consumer3 <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">newPushConsumerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setConsumerGroup</span><span class="token punctuation">(</span><span class="token string">&quot;GroupA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
consumer3<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;TopicA&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">FilterExpression</span><span class="token punctuation">(</span><span class="token string">&quot;TagA&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FilterExpressionType</span><span class="token punctuation">.</span><span class="token constant">TAG</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>信息: RocketMQ 强调订阅关系一致, <strong>核心是指相同 ConsumerGroup 的每个 Consumer 之间一致, 因为在服务端视角看来一个 Group 下的所有 Consumer 都应该是相同的副本逻辑</strong>.</p> <p>强调订阅关系一致, 并不是指一个 Consumer 不能订阅多个 Topic, 每个 Consumer 仍然可以按照需要订阅多个 Topic, 但前提是相同消费者分组下的 Consumer 要一致.</p> <h6 id="_2-订阅关系不一致的排查"><a href="#_2-订阅关系不一致的排查" class="header-anchor">#</a> 2.订阅关系不一致的排查</h6> <p><strong>问题描述</strong></p> <p>在使用 RocketMQ 时, 可能会出现订阅关系不一致的情况, 具体的问题现象如下:</p> <ul><li>RocketMQ 控制台中订阅关系是否一致显示为否.</li> <li>消费者(Consumer)实例未收到订阅的消息.</li></ul> <p><strong>请参考以下步骤进行检查</strong></p> <p><strong>可在消息 RocketMQ 的控制台或者 CLi 工具查看指定 Group 的订阅关系是否一致</strong>. 若查询结果不一致, 请参见(常见订阅关系不一致问题)排查 Consumer 实例的消费代码.</p> <ol><li>检查 Consumer 实例中与订阅相关的配置代码, 确保配置同一个 ConsumerGroup 的所有 Consumer 实例均订阅相同的 Topic 及 Tag.</li> <li>使用控制台或者 Cli 命令 ConsumerConnection 查看生效的订阅关系是否一致.</li> <li>测试并确认消息能够被预期的 Consumer 实例所消费.</li></ol> <h6 id="_3-常见订阅关系不一致问题"><a href="#_3-常见订阅关系不一致问题" class="header-anchor">#</a> 3.常见订阅关系不一致问题</h6> <blockquote><p>同一ConsumerGroup下的Consumer实例订阅的Topic不同(3.x, 4.x SDK适用)</p></blockquote> <p>在早期 3.x/4.x 版本的 SDK 中, 如下图所示, 同一 ConsumerGroup 下的三个 Consumer 实例 C1, C2 和 C3 分别订阅了 TopicA, TopicB 和 TopicC, 订阅的 Topic 不一致, 不符合订阅关系一致性原则.</p> <p>备注: <strong>5.x 版本 SDK 已经支持同一个 ConsumerGroup 下的 Consumer 实例订阅不同的Topic</strong>.</p> <p><img src="/img/image-20240825203600-bkid0ye.png" alt="image"></p> <blockquote><p>同一ConsumerGroup下的Consumer实例订阅的Topic相同, 但订阅的Tag不一致</p></blockquote> <p>如下图所示, 同一 ConsumerGroup 下的三个 Consumer 实例 C1, C2 和 C3 分别都订阅了 TopicA, 但是 C1 订阅 TopicA 的 Tag 为 <strong>Tag1</strong>, C2 和 C3 订阅的 TopicA 的 Tag 为 <strong>Tag2</strong>, 订阅同一 Topic 的 Tag 不一致, <strong>不符合订阅关系一致性原则</strong>.</p> <p><img src="/img/image-20240825203729-iduc7yn.png" alt="image"></p> <p>**错误示例代码: **</p> <p>Consumer 实例 2-1:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">PushConsumer</span> consumer1 <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">newPushConsumerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setConsumerGroup</span><span class="token punctuation">(</span><span class="token string">&quot;GroupA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
consumer1<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;TopicA&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">FilterExpression</span><span class="token punctuation">(</span><span class="token string">&quot;Tag1&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FilterExpressionType</span><span class="token punctuation">.</span><span class="token constant">TAG</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Consumer 实例 2-2:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">PushConsumer</span> consumer2 <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">newPushConsumerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setConsumerGroup</span><span class="token punctuation">(</span><span class="token string">&quot;GroupA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
consumer2<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;TopicA&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">FilterExpression</span><span class="token punctuation">(</span><span class="token string">&quot;Tag2&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FilterExpressionType</span><span class="token punctuation">.</span><span class="token constant">TAG</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Consumer 实例 2-3:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">PushConsumer</span> consumer3 <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">newPushConsumerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setConsumerGroup</span><span class="token punctuation">(</span><span class="token string">&quot;GroupA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
consumer3<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;TopicA&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">FilterExpression</span><span class="token punctuation">(</span><span class="token string">&quot;Tag2&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FilterExpressionType</span><span class="token punctuation">.</span><span class="token constant">TAG</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="功能特性"><a href="#功能特性" class="header-anchor">#</a> 功能特性</h3> <h4 id="普通消息"><a href="#普通消息" class="header-anchor">#</a> 普通消息</h4> <h5 id="基础-3"><a href="#基础-3" class="header-anchor">#</a> 基础</h5> <blockquote><p>什么是普通消息</p></blockquote> <p>普通消息是 RocketMQ 基本消息功能, 支持生产者和消费者的异步解耦通信. 普通消息是 RocketMQ 中最基础的消息, 区别于有特性的顺序消息, 定时/延时消息和事务消息.</p> <blockquote><p>消息类型一致性</p></blockquote> <p>普通消息仅支持使用 MessageType 为 Normal 主题, 即普通消息只能发送至类型为普通消息的主题中, 发送的消息的类型必须和主题的类型一致.</p> <h5 id="功能原理"><a href="#功能原理" class="header-anchor">#</a> 功能原理</h5> <p>​<img src="/img/image-20240825204003-idkl4at.png" alt="image">​</p> <blockquote><p>普通消息生命周期</p></blockquote> <ul><li><strong>初始化</strong>: 消息被生产者构建并完成初始化, 待发送到服务端的状态.</li> <li><strong>待消费</strong>: 消息被发送到服务端, <strong>对消费者可见, 等待消费者消费的状态</strong>.</li> <li><strong>消费中</strong>: 消息被消费者获取, 并按照消费者<strong>本地的业务逻辑</strong>进行处理的过程. 此时服务端会等待消费者<strong>完成消费并提交消费结果</strong>, 如果一定时间后没有收到消费者的响应, RocketMQ 会对消息进行重试处理. 具体信息参考: 消费重试.</li> <li><strong>消费提交</strong>: 消费者完成消费处理, 并<strong>向服务端提交消费结果, 服务端标记当前消息已经被处理(包括消费成功和失败)</strong> . RocketMQ 默认支持保留所有消息, 此时<strong>消息数据并不会立即被删除, 只是逻辑标记已消费. 消息在保存时间到期或存储空间不足被删除前, 消费者仍然可以回溯消息重新消费</strong>.</li> <li><strong>消息删除</strong>: RocketMQ 按照消息<strong>保存机制滚动清理最早的消息数据</strong>, 将消息从物理文件中删除. 更多信息参考: 消息存储和清理机制.</li></ul> <h5 id="使用示例-2"><a href="#使用示例-2" class="header-anchor">#</a> 使用示例</h5> <blockquote><p>创建主题</p></blockquote> <p>RocketMQ 5.0 版本下创建主题操作, 推荐使用 mqadmin 工具, 需要注意的是, 对于消息类型需要通过属性参数添加. 示例如下:</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token function">sh</span> mqadmin updateTopic <span class="token parameter variable">-n</span> <span class="token operator">&lt;</span>nameserver_address<span class="token operator">&gt;</span> <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>topic_name<span class="token operator">&gt;</span> <span class="token parameter variable">-c</span> <span class="token operator">&lt;</span>cluster_name<span class="token operator">&gt;</span> <span class="token parameter variable">-a</span> +message.type<span class="token operator">=</span>NORMAL
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>发送与消费消息</p></blockquote> <p><strong>普通消息支持设置消息索引键, 消息过滤标签等信息, 用于消息过滤和搜索查找</strong>. 以 Java 语言为例, 收发普通消息的示例代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 普通消息发送. </span>
<span class="token class-name">MessageBuilder</span> messageBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageBuilderImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Message</span> message <span class="token operator">=</span> messageBuilder<span class="token punctuation">.</span><span class="token function">setTopic</span><span class="token punctuation">(</span><span class="token string">&quot;topic&quot;</span><span class="token punctuation">)</span>
    <span class="token comment">// 设置消息索引键, 可根据关键字精确查找某条消息. </span>
    <span class="token punctuation">.</span><span class="token function">setKeys</span><span class="token punctuation">(</span><span class="token string">&quot;messageKey&quot;</span><span class="token punctuation">)</span>
    <span class="token comment">// 设置消息Tag, 用于消费端根据指定Tag过滤消息. </span>
    <span class="token punctuation">.</span><span class="token function">setTag</span><span class="token punctuation">(</span><span class="token string">&quot;messageTag&quot;</span><span class="token punctuation">)</span>
    <span class="token comment">// 消息体. </span>
    <span class="token punctuation">.</span><span class="token function">setBody</span><span class="token punctuation">(</span><span class="token string">&quot;messageBody&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 发送消息, 需要关注发送结果, 并捕获失败等异常. </span>
    <span class="token class-name">SendReceipt</span> sendReceipt <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sendReceipt<span class="token punctuation">.</span><span class="token function">getMessageId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>消费消息示例如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 消费示例一: 使用PushConsumer消费普通消息, 只需要在消费监听器中处理即可. </span>
<span class="token class-name">MessageListener</span> messageListener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">ConsumeResult</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">MessageView</span> messageView<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>messageView<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 根据消费结果返回状态. </span>
        <span class="token keyword">return</span> <span class="token class-name">ConsumeResult</span><span class="token punctuation">.</span><span class="token constant">SUCCESS</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 消费示例二: 使用SimpleConsumer消费普通消息, 主动获取消息进行消费处理并提交消费结果. </span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageView</span><span class="token punctuation">&gt;</span></span> messageViewList <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    messageViewList <span class="token operator">=</span> simpleConsumer<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    messageViewList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>messageView <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>messageView<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 消费处理完成后, 需要主动调用ACK提交消费结果. </span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            simpleConsumer<span class="token punctuation">.</span><span class="token function">ack</span><span class="token punctuation">(</span>messageView<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果遇到系统流控等原因造成拉取失败, 需要重新发起获取消息请求. </span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h5 id="使用建议-8"><a href="#使用建议-8" class="header-anchor">#</a> 使用建议</h5> <blockquote><p>设置全局唯一业务索引键, 方便问题追踪</p></blockquote> <p>RocketMQ 支持自定义索引键(消息的 Key), 在<strong>消息查询和轨迹查询时, 可以通过索引键高效精确地查询到消息</strong>. 因此, 发送消息时, <mark><strong>建议设置业务上唯一的信息作为索引, 方便后续快速定位消息</strong></mark>. 例如, 订单ID, 用户ID等.</p> <h5 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h5> <p>普通消息一般应用于<strong>微服务解耦, 事件驱动, 数据集成</strong>等场景, 这些场景大多数要求数据传输通道具有可靠传输的能力, 且<strong>对消息的处理时机, 处理顺序没有特别要求</strong>.</p> <blockquote><p>典型场景一: 微服务异步解耦</p></blockquote> <p>​<img src="/img/onlineprocess-cfd38e3de3a5fc1ee76f17331cc5b828-20240422214103-hjoe2wb.png" alt="在线消息处理">​</p> <p>如上图所示, 以在线的电商交易场景为例, 上游订单系统将用户下单支付这一业务事件封装成独立的普通消息并发送至 RocketMQ 服务端, 下游按需从服务端订阅消息并按照本地消费逻辑处理下游任务. <strong>每个消息之间都是相互独立的, 且不需要产生关联</strong>.</p> <blockquote><p>典型场景二: 数据集成传输</p></blockquote> <p>​<img src="/img/offlineprocess-027f6f1642db3d78ff29890abbe38bf8-20240422214104-ar6joga.png" alt="数据传输">​</p> <p>如上图所示, 以<strong>离线的日志收集</strong>场景为例, 通过埋点组件收集前端应用的相关操作日志, 并转发到 RocketMQ. 每条消息都是一段日志数据, RocketMQ 不做任何处理, 只需要<strong>将日志数据可靠投递到下游的存储系统和分析系统</strong>即可, 后续功能由后端应用完成.</p> <h4 id="定时延时消息"><a href="#定时延时消息" class="header-anchor">#</a> 定时延时消息</h4> <h5 id="基础-4"><a href="#基础-4" class="header-anchor">#</a> 基础</h5> <p>定时消息是 RocketMQ 提供的一种高级消息类型, 消息被发送至服务端后, 在<strong>指定时间后才能被消费者消费</strong>. 通过设置一定的定时时间可以实现分布式场景的延时调度触发效果.</p> <p>定时消息和延时消息本质相同, 都是服务端<strong>根据消息设置的定时时间在某一固定时刻将消息投递给消费者消费</strong>. 因此, 下文统一用定时消息描述.</p> <h5 id="功能原理-2"><a href="#功能原理-2" class="header-anchor">#</a> 功能原理</h5> <blockquote><p>定时时间设置原则</p></blockquote> <ul><li>RocketMQ 定时消息设置的定时时间是一个<strong>预期触发的系统时间戳</strong>, 延时时间也需要转换成当前系统时间后的某一个时间戳, 而不是一段延时时长.</li> <li>定时时间的格式为毫秒级的 Unix 时间戳, 需要将要设置的时刻转换成时间戳形式.</li> <li>定时时间必须设置在定时时长范围内, 超过范围则定时不生效, 服务端会立即投递消息.</li> <li>定时时长最大值默认为 24 小时, 不支持自定义修改.</li> <li>定时时间必须设置为当前时间之后, 若设置到当前时间之前, 则定时不生效, 服务端会立即投递消息.</li></ul> <p>示例如下:</p> <ul><li>定时消息: 例如, 当前系统时间为 2022-06-09 17:30:00, 您希望消息在下午 19:20:00 定时投递, 则定时时间为 2022-06-09 19:20:00, 转换成时间戳格式为 1654773600000.</li> <li>延时消息: 例如, 当前系统时间为 2022-06-09 17:30:00, 您希望延时 1 个小时后投递消息, 则您需要根据当前时间和延时时长换算成定时时刻, 即消息投递时间为 2022-06-09 18:30:00, 转换为时间戳格式为 1654770600000.</li></ul> <p>RocketMQ 定时消息的定时时长参数精确到毫秒级, 但是默认精度为 1000ms, 即<strong>定时消息为秒级精度</strong>.</p> <p>RocketMQ 定时消息的状态支持持久化存储, 系统由于故障重启后, 仍支持按照原来设置的定时时间触发消息投递. 若存储系统异常重启, <strong>可能会导致定时消息投递出现一定延迟</strong>.</p> <blockquote><p>定时消息生命周期</p></blockquote> <p>​<img src="/img/image-20240825204130-4y286tg.png" alt="image">​</p> <ul><li><strong>初始化</strong>: 消息被生产者构建并完成初始化, 待发送到服务端的状态.</li> <li><strong>定时中</strong>: 消息被发送到服务端, 和普通消息不同的是, <strong>服务端不会直接构建消息索引, 而是会将定时消息单独存储在定时存储系统中, 等待定时时刻到达</strong>.</li> <li><strong>待消费</strong>: 定时时刻到达后, <strong>服务端将消息重新写入普通存储引擎, 对下游消费者可见, 等待消费者消费的状态</strong>.</li> <li><strong>消费中</strong>: 消息被消费者获取, 并按照消费者本地的业务逻辑进行处理的过程. 此时服务端会等待消费者完成消费并提交消费结果, 如果一定时间后没有收到消费者的响应, RocketMQ 会对消息进行重试处理.</li> <li><strong>消费提交</strong>: 消费者完成消费处理, 并向服务端提交消费结果, 服务端标记当前消息已经被处理(包括消费成功和失败). RocketMQ 默认支持保留所有消息, 此时消息数据并不会立即被删除, 只是逻辑标记已消费. 消息在保存时间到期或存储空间不足被删除前, 消费者仍然可以回溯消息重新消费.</li> <li><strong>消息删除</strong>: RocketMQ 按照消息保存机制滚动清理最早的消息数据, 将消息从物理文件中删除.</li></ul> <blockquote><p>消息类型一致性</p></blockquote> <p>定时消息仅支持在 <strong>MessageType 为 Delay 的主题内使用</strong>, 即定时消息只能发送至类型为定时消息的主题中, 发送的消息的类型必须和主题的类型一致.</p> <h5 id="使用示例-3"><a href="#使用示例-3" class="header-anchor">#</a> 使用示例</h5> <blockquote><p>创建主题</p></blockquote> <p>RocketMQ 5.0 版本下创建主题操作, 推荐使用 mqadmin 工具, 需要注意的是, 对于消息类型需要通过属性参数添加. 示例如下:</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token function">sh</span> mqadmin updateTopic <span class="token parameter variable">-n</span> <span class="token operator">&lt;</span>nameserver_address<span class="token operator">&gt;</span> <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>topic_name<span class="token operator">&gt;</span> <span class="token parameter variable">-c</span> <span class="token operator">&lt;</span>cluster_name<span class="token operator">&gt;</span> <span class="token parameter variable">-a</span> +message.type<span class="token operator">=</span>DELAY
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>发送消息</p></blockquote> <p>和普通消息相比, 定时消费发送时, 必须设置<strong>定时触发的目标时间戳</strong>.</p> <blockquote><p>创建延迟主题</p></blockquote> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>/bin/mqadmin updateTopic <span class="token parameter variable">-c</span> DefaultCluster <span class="token parameter variable">-t</span> DelayTopic <span class="token parameter variable">-n</span> <span class="token number">127.0</span>.0.1:9876 <span class="token parameter variable">-a</span> +message.type<span class="token operator">=</span>DELAY
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>-c 集群名称</li> <li>-t Topic名称</li> <li>-n nameserver地址</li> <li>-a 额外属性, 本例给主题添加了 <code>message.type</code>​ 为 <code>DELAY</code>​ 的属性用来支持延迟消息</li></ul> <p>以 Java 语言为例, 使用定时消息示例参考如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 定时/延时消息发送</span>
<span class="token class-name">MessageBuilder</span> messageBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageBuilderImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token comment">// 以下示例表示: 延迟时间为10分钟之后的Unix时间戳. </span>
<span class="token class-name">Long</span> deliverTimeStamp <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">10L</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>
<span class="token class-name">Message</span> message <span class="token operator">=</span> messageBuilder<span class="token punctuation">.</span><span class="token function">setTopic</span><span class="token punctuation">(</span><span class="token string">&quot;topic&quot;</span><span class="token punctuation">)</span>
        <span class="token comment">// 设置消息索引键, 可根据关键字精确查找某条消息. </span>
        <span class="token punctuation">.</span><span class="token function">setKeys</span><span class="token punctuation">(</span><span class="token string">&quot;messageKey&quot;</span><span class="token punctuation">)</span>
        <span class="token comment">// 设置消息Tag, 用于消费端根据指定Tag过滤消息. </span>
        <span class="token punctuation">.</span><span class="token function">setTag</span><span class="token punctuation">(</span><span class="token string">&quot;messageTag&quot;</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">setDeliveryTimestamp</span><span class="token punctuation">(</span>deliverTimeStamp<span class="token punctuation">)</span>
        <span class="token comment">// 消息体</span>
        <span class="token punctuation">.</span><span class="token function">setBody</span><span class="token punctuation">(</span><span class="token string">&quot;messageBody&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 发送消息, 需要关注发送结果, 并捕获失败等异常. </span>
    <span class="token class-name">SendReceipt</span> sendReceipt <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sendReceipt<span class="token punctuation">.</span><span class="token function">getMessageId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>消息消费示例:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 消费示例一: 使用PushConsumer消费定时消息, 只需要在消费监听器处理即可. </span>
<span class="token class-name">MessageListener</span> messageListener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">ConsumeResult</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">MessageView</span> messageView<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>messageView<span class="token punctuation">.</span><span class="token function">getDeliveryTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 根据消费结果返回状态. </span>
        <span class="token keyword">return</span> <span class="token class-name">ConsumeResult</span><span class="token punctuation">.</span><span class="token constant">SUCCESS</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 消费示例二: 使用SimpleConsumer消费定时消息, 主动获取消息进行消费处理并提交消费结果. </span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageView</span><span class="token punctuation">&gt;</span></span> messageViewList <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    messageViewList <span class="token operator">=</span> simpleConsumer<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    messageViewList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>messageView <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>messageView<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 消费处理完成后, 需要主动调用ACK提交消费结果. </span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            simpleConsumer<span class="token punctuation">.</span><span class="token function">ack</span><span class="token punctuation">(</span>messageView<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果遇到系统流控等原因造成拉取失败, 需要重新发起获取消息请求. </span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h5 id="使用建议-9"><a href="#使用建议-9" class="header-anchor">#</a> 使用建议</h5> <blockquote><p>避免创建大量相同定时时刻的消息</p></blockquote> <p>定时消息的实现逻辑需要先经过定时存储等待触发, 定时时间到达后才会被投递给消费者. 因此, <strong>如果将大量定时消息的定时时间设置为同一时刻, 则到达该时刻后会有大量消息同时需要被处理, 会造成系统压力过大, 导致消息分发延迟, 影响定时精度</strong>.</p> <h5 id="应用场景-2"><a href="#应用场景-2" class="header-anchor">#</a> 应用场景</h5> <p>在分布式定时调度触发, 任务超时处理等场景, 需要实现精准, 可靠的定时事件触发. 使用 RocketMQ 的定时消息可以<strong>简化定时调度任务的开发逻辑, 实现高性能, 可扩展, 高可靠的定时触发能力</strong>.</p> <blockquote><p>典型场景一: 分布式定时调度</p></blockquote> <p><img src="/img/delaywork-e9647b539ae35898102a336a27d3ad94-20240422214120-vvv7pjl.png" alt="定时消息"></p> <p>在分布式定时调度场景下, 需要实现各类精度的定时任务, 例如每天 5 点执行文件清理, 每隔 2 分钟触发一次消息推送等需求. 传统基于数据库的定时调度方案在分布式场景下, 性能不高, 实现复杂. 基于 RocketMQ 的<strong>定时消息可以封装出多种类型的定时触发器</strong>.</p> <blockquote><p>典型场景二: 任务超时处理</p></blockquote> <p><img src="/img/scheduletask-1944aea7bf2a4a4c56be4d90ead4f1f3-20240422214120-dix6mzp.png" alt="超时任务处理"></p> <p>以电商交易场景为例, <mark><strong>订单下单后暂未支付, 此时不可以直接关闭订单, 而是需要等待一段时间后才能关闭订单</strong></mark>. 使用 RocketMQ 定时消息可以实现超时任务的检查触发.</p> <p>基于定时消息的超时任务处理具备如下优势:</p> <ul><li><strong>精度高, 开发门槛低</strong>: 基于消息通知方式不存在定时阶梯间隔. 可以轻松实现任意精度事件触发, 无需业务去重.</li> <li><strong>高性能可扩展</strong>: 传统的数据库扫描方式较为复杂, 需要频繁调用接口扫描, 容易产生性能瓶颈. RocketMQ 的定时消息具有高并发和水平扩展的能力.</li></ul> <h4 id="顺序消息"><a href="#顺序消息" class="header-anchor">#</a> 顺序消息</h4> <h5 id="基础-5"><a href="#基础-5" class="header-anchor">#</a> 基础</h5> <blockquote><p>什么是顺序消息</p></blockquote> <p>顺序消息是 RocketMQ 提供的一种高级消息类型, 支持<strong>消费者按照发送消息的先后顺序获取消息</strong>, 从而实现业务场景中的顺序处理. 相比其他类型消息, 顺序消息在发送, 存储和投递的处理过程中, 更多<strong>强调多条消息间的先后顺序关系</strong>.</p> <p><strong>顺序消息的顺序关系通过消息组(MessageGroup)判定和识别, 发送顺序消息时需要为每条消息设置归属的消息组, 相同消息组的多条消息之间遵循先进先出的顺序关系, 不同消息组, 无消息组的消息之间不涉及顺序性</strong>.</p> <p>基于消息组的顺序判定逻辑, 支持按照业务逻辑做细粒度拆分, 可以在满足业务局部顺序的前提下提高系统的并行度和吞吐能力.</p> <h5 id="功能原理-3"><a href="#功能原理-3" class="header-anchor">#</a> 功能原理</h5> <blockquote><p>如何保证消息的顺序性</p></blockquote> <p>消息的顺序性分为两部分, <strong>生产顺序性和消费顺序性</strong>.</p> <p><strong>生产顺序性</strong>: RocketMQ 通过<strong>生产者和服务端的协议保障单个生产者串行地发送消息, 并按序存储和持久化</strong>.</p> <p><strong>如需保证消息生产的顺序性</strong>, 则必须满足以下条件:</p> <ul><li><strong>单一生产者</strong>: 消息生产的顺序性仅支持单一生产者, 不同生产者分布在不同的系统, 即使设置相同的消息组, 不同生产者之间产生的消息也无法判定其先后顺序.</li> <li><strong>串行发送</strong>: 生产者客户端支持多线程安全访问, 但如果生产者使用多线程并行发送, 则不同线程间产生的消息将无法判定其先后顺序.</li></ul> <p>满足以上条件的生产者, 将顺序消息发送至 RocketMQ 后, 会保证设置了同一消息组的消息, <strong>按照发送顺序存储在同一队列中</strong>. 服务端顺序存储逻辑如下:</p> <ul><li><strong>相同消息组的消息按照先后顺序被存储在同一个队列</strong>.</li> <li><strong>不同消息组的消息可以混合在同一个队列中, 且不保证连续</strong>.</li></ul> <p>​<img src="/img/image-20240830225324-uk6asey.png" alt="image">​</p> <p>如上图所示, 消息组 1 和消息组 4 的消息混合存储在队列 1 中, RocketMQ 保证消息组 1 中的消息 G1-M1, G1-M2, G1-M3 是按发送顺序存储, 且消息组 4 的消息 G4-M1, G4-M2 也是按顺序存储, 但消息组 1 和消息组 4 中的消息不涉及顺序关系.</p> <p><strong>消费顺序性</strong>: RocketMQ 通过消费者和服务端的协议保障消息消费严格按照存储的先后顺序来处理.</p> <p>如需<strong>保证消息消费的顺序性</strong>, 则必须满足以下条件:</p> <ul><li><strong>投递顺序</strong>: RocketMQ 通过客户端 SDK 和服务端通信协议保障消息按照服务端存储顺序投递, 但业务方消费消息时需要严格按照<strong>接收-处理-应答</strong>的语义处理消息, 避免因异步处理导致消息乱序. 备注: 消费者类型为 PushConsumer 时, <strong>RocketMQ 保证消息按照存储顺序一条一条投递给消费者</strong>, 若消费者类型为 SimpleConsumer, 则消费者有可能一次拉取多条消息. 此时, <strong>消息消费的顺序性需要由业务方自行保证</strong>.</li> <li><strong>有限重试</strong>: RocketMQ 顺序消息投递仅在重试次数限定范围内, 即一条消息如果一直重试失败, 超过最大重试次数后<strong>将不再重试, 跳过这条消息消费, 不会一直阻塞后续消息处理</strong>. 对于需要严格保证消费顺序的场景, 请务设置合理的重试次数, 避免参数不合理导致消息乱序.</li></ul> <p>如果使用普通消息, Producer 生产消息的时候可能会向同一主题的不同消息队列发送消息. 比如此时有几个消息分别是同一个订单的创建, 支付, 发货, 在轮询的策略下这三个消息会<strong>被发送到不同队列</strong>, 因为在<strong>不同的队列此时就无法使用 RocketMQ 带来的队列有序特性来保证消息有序性</strong>了. 要解决此问题, 只需要<strong>将同一语义下的消息放入同一个队列</strong>(比如这里是同一个订单), 那就可以使用 <strong>Hash 取模法</strong> 来<strong>保证同一个订单在同一个队列</strong>中就行了.</p> <blockquote><p>生产顺序性和消费顺序性组合</p></blockquote> <p>如果消息需要严格按照先进先出(FIFO)的原则处理, 即<strong>先发送的先消费, 后发送的后消费</strong>, 则必须要同时满足生产顺序性和消费顺序性.</p> <p>一般业务场景下, 同一个生产者可能对接多个下游消费者, 不一定所有的消费者业务都需要顺序消费, 可以将生产顺序性和消费顺序性进行差异化组合, 应用于不同的业务场景. 例如发送顺序消息, 但使用非顺序的并发消费方式来提高吞吐能力. 更多组合方式如下表所示:</p> <table><thead><tr><th>生产顺序</th> <th>消费顺序</th> <th>顺序性效果</th></tr></thead> <tbody><tr><td>设置消息组, 保证消息顺序发送.</td> <td>顺序消费</td> <td>按照消息组粒度, 严格保证消息顺序. 同一消息组内的消息的消费顺序和发送顺序完全一致.</td></tr> <tr><td>设置消息组, 保证消息顺序发送.</td> <td>并发消费</td> <td>并发消费, 尽可能按时间顺序处理.</td></tr> <tr><td>未设置消息组, 消息乱序发送.</td> <td>顺序消费</td> <td>按队列存储粒度, 严格顺序. 基于 RocketMQ 本身队列的属性, 消费顺序和队列存储的顺序一致, 但不保证和发送顺序一致.</td></tr> <tr><td>未设置消息组, 消息乱序发送.</td> <td>并发消费</td> <td>并发消费, 尽可能按照时间顺序处理.</td></tr></tbody></table> <blockquote><p>顺序消息生命周期</p></blockquote> <p>​<img src="/img/image-20240825204232-sc2tfqj.png" alt="image">​</p> <ul><li><strong>初始化</strong>: 消息被生产者构建并完成初始化, 待发送到服务端的状态.</li> <li><strong>待消费</strong>: 消息被发送到服务端, 对消费者可见, 等待消费者消费的状态.</li> <li><strong>消费中</strong>: 消息被消费者获取, 并按照消费者本地的业务逻辑进行处理的过程. 此时服务端会等待消费者完成消费并提交消费结果, 如果一定时间后没有收到消费者的响应, RocketMQ 会对消息进行重试处理.</li> <li><strong>消费提交</strong>: 消费者完成消费处理, 并向服务端提交消费结果, 服务端标记当前消息已经被处理(包括消费成功和失败). RocketMQ 默认支持保留所有消息, 此时消息数据并不会立即被删除, 只是逻辑标记已消费. 消息在保存时间到期或存储空间不足被删除前, 消费者仍然可以回溯消息重新消费.</li> <li><strong>消息删除</strong>: RocketMQ 按照消息保存机制滚动清理最早的消息数据, 将消息从物理文件中删除.</li></ul> <p><strong>备注:</strong></p> <ul><li><strong>消息消费失败或消费超时, 会触发服务端重试逻辑, 重试消息属于新的消息, 原消息的生命周期已结束</strong>.</li> <li><strong>顺序消息消费失败进行消费重试时, 为保障消息的顺序性, 后续消息不可被消费, 必须等待前面的消息消费完成后才能被处理</strong>.</li></ul> <blockquote><p>消息类型一致性</p></blockquote> <p>顺序消息仅支持使用 <strong>MessageType 为 FIFO 的主题</strong>, 即顺序消息只能发送至类型为顺序消息的主题中, 发送的消息的类型必须和主题的类型一致.</p> <h5 id="使用示例-4"><a href="#使用示例-4" class="header-anchor">#</a> 使用示例</h5> <blockquote><p>创建主题</p></blockquote> <p>RocketMQ 5.0 版本下创建主题操作, 推荐使用 mqadmin 工具, 需要注意的是, 对于消息类型需要通过属性参数添加. 示例如下:</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token function">sh</span> mqadmin updateTopic <span class="token parameter variable">-n</span> <span class="token operator">&lt;</span>nameserver_address<span class="token operator">&gt;</span> <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>topic_name<span class="token operator">&gt;</span> <span class="token parameter variable">-c</span> <span class="token operator">&lt;</span>cluster_name<span class="token operator">&gt;</span> <span class="token parameter variable">-a</span> +message.type<span class="token operator">=</span>FIFO
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>发送消息</p></blockquote> <p>和普通消息发送相比, <strong>顺序消息发送必须要设置消息组</strong>. 消息组的粒度建议按照业务场景, 尽可能细粒度设计, 以便实现业务拆分和并发扩展.</p> <blockquote><p>创建FIFO主题</p></blockquote> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>./bin/mqadmin updateTopic <span class="token parameter variable">-c</span> DefaultCluster <span class="token parameter variable">-t</span> FIFOTopic <span class="token parameter variable">-o</span> <span class="token boolean">true</span> <span class="token parameter variable">-n</span> <span class="token number">127.0</span>.0.1:9876 <span class="token parameter variable">-a</span> +message.type<span class="token operator">=</span>FIFO
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>-c 集群名称</li> <li>-t Topic名称</li> <li>-n nameserver地址</li> <li>-o 创建顺序消息</li></ul> <p>以 Java 语言为例, 收发顺序消息的示例代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 顺序消息发送. </span>
<span class="token class-name">MessageBuilder</span> messageBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageBuilderImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token class-name">Message</span> message <span class="token operator">=</span> messageBuilder<span class="token punctuation">.</span><span class="token function">setTopic</span><span class="token punctuation">(</span><span class="token string">&quot;topic&quot;</span><span class="token punctuation">)</span>
        <span class="token comment">// 设置消息索引键, 可根据关键字精确查找某条消息. </span>
        <span class="token punctuation">.</span><span class="token function">setKeys</span><span class="token punctuation">(</span><span class="token string">&quot;messageKey&quot;</span><span class="token punctuation">)</span>
        <span class="token comment">// 设置消息Tag, 用于消费端根据指定Tag过滤消息. </span>
        <span class="token punctuation">.</span><span class="token function">setTag</span><span class="token punctuation">(</span><span class="token string">&quot;messageTag&quot;</span><span class="token punctuation">)</span>
        <span class="token comment">// 设置顺序消息的排序分组, 该分组尽量保持离散, 避免热点排序分组. </span>
        <span class="token punctuation">.</span><span class="token function">setMessageGroup</span><span class="token punctuation">(</span><span class="token string">&quot;fifoGroup001&quot;</span><span class="token punctuation">)</span>
        <span class="token comment">// 消息体. </span>
        <span class="token punctuation">.</span><span class="token function">setBody</span><span class="token punctuation">(</span><span class="token string">&quot;messageBody&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 发送消息, 需要关注发送结果, 并捕获失败等异常</span>
    <span class="token class-name">SendReceipt</span> sendReceipt <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sendReceipt<span class="token punctuation">.</span><span class="token function">getMessageId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>消息消费示例:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 消费顺序消息时, 需要确保当前消费者分组是顺序投递模式, 否则仍然按并发乱序投递. </span>
<span class="token comment">// 消费示例一: 使用PushConsumer消费顺序消息, 只需要在消费监听器处理即可. </span>
<span class="token class-name">MessageListener</span> messageListener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">ConsumeResult</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">MessageView</span> messageView<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>messageView<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 根据消费结果返回状态. </span>
        <span class="token keyword">return</span> <span class="token class-name">ConsumeResult</span><span class="token punctuation">.</span><span class="token constant">SUCCESS</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 消费示例二: 使用SimpleConsumer消费顺序消息, 主动获取消息进行消费处理并提交消费结果. </span>
<span class="token comment">// 需要注意的是, 同一个MessageGroup的消息, 如果前序消息没有消费完成, 再次调用Receive是获取不到后续消息的. </span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageView</span><span class="token punctuation">&gt;</span></span> messageViewList <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    messageViewList <span class="token operator">=</span> simpleConsumer<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    messageViewList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>messageView <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>messageView<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 消费处理完成后, 需要主动调用ACK提交消费结果. </span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            simpleConsumer<span class="token punctuation">.</span><span class="token function">ack</span><span class="token punctuation">(</span>messageView<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果遇到系统流控等原因造成拉取失败, 需要重新发起获取消息请求. </span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h5 id="使用建议-10"><a href="#使用建议-10" class="header-anchor">#</a> 使用建议</h5> <blockquote><p>建议串行消费, 避免批量消费导致乱序</p></blockquote> <p>消息消费<strong>建议串行处理, 避免一次消费多条消息, 否则可能出现乱序情况</strong>.</p> <p>例如: 发送顺序为 1-&gt;2-&gt;3-&gt;4, 消费时批量消费, 消费顺序为 1-&gt;23(批量处理, 失败)-&gt;23(重试处理)-&gt;4, 此时可能<strong>由于消息 3 的失败导致消息 2 被重复处理, 最后导致消息消费乱序</strong>.</p> <blockquote><p>消息组尽可能打散, 避免集中导致热点</p></blockquote> <p>RocketMQ 保证相同消息组的消息存储在同一个队列中, 如果不同业务场景的消息都集中在少量或一个消息组中, 则这些消息存储压力都会<strong>集中到服务端的少量队列或一个队列中</strong>. 容易导致性能热点, 且不利于扩展. <strong>一般建议的消息组设计会采用订单 ID, 用户 ID 作为顺序参考, 即同一个终端用户的消息保证顺序, 不同用户的消息无需保证顺序</strong>.</p> <p>因此<strong>建议将业务以消息组粒度进行拆分</strong>, 例如, 将订单 ID, 用户 ID 作为消息组关键字, 可实现同一终端用户的消息按照顺序处理, 不同用户的消息无需保证顺序.</p> <h5 id="应用场景-3"><a href="#应用场景-3" class="header-anchor">#</a> 应用场景</h5> <p>在<strong>有序事件处理, 撮合交易, 数据实时增量同步</strong>等场景下, 异构系统间需要维持<strong>强一致的状态同步</strong>, 上游的事件变更需要按照顺序传递到下游进行处理. 在这类场景下使用 RocketMQ 的顺序消息可以有效保证数据传输的顺序性.</p> <blockquote><p>典型场景一: 撮合交易</p></blockquote> <p>​<img src="/img/fifo_trade-a8bac55b8fb3fceb995891c64c2f0a5a-20240422214145-8cl0k93.png" alt="交易撮合">​</p> <p>以证券, 股票交易撮合场景为例, <strong>对于出价相同的交易单, 坚持按照先出价先交易的原则</strong>, 下游处理订单的系统需要严格按照出价顺序来处理订单.</p> <blockquote><p>典型场景二: 数据实时增量同步</p></blockquote> <p><strong>普通消息</strong></p> <p><img src="/img/tradewithnormal-5273283ffa54ec08017f356227411f83-20240422214145-tc7d6pt.png" alt="普通消息"></p> <p><strong>顺序消息</strong></p> <p><img src="/img/tradewithfifo-30884dfeb909c54d7379641fcec437fa-20240422214145-s7p2m7m.png" alt="顺序消息"></p> <p>以<strong>数据库变更增量同步</strong>场景为例, <strong>上游源端数据库按需执行增删改操作, 将二进制操作日志作为消息</strong>, 通过RocketMQ 传输到下游搜索系统, 下游系统按顺序还原消息数据, 实现状态数据按序刷新. <strong>如果是普通消息则可能会导致状态混乱, 和预期操作结果不符, 基于顺序消息可以实现下游状态和上游操作结果一致</strong>.</p> <h4 id="事务消息"><a href="#事务消息" class="header-anchor">#</a> 事务消息</h4> <h5 id="功能原理-4"><a href="#功能原理-4" class="header-anchor">#</a> 功能原理</h5> <blockquote><p>什么是事务消息</p></blockquote> <p>事务消息是 RocketMQ 提供的一种高级消息类型, 支持在分布式场景下<strong>保障消息生产和本地事务的最终一致性</strong>.</p> <blockquote><p>事务消息处理流程</p></blockquote> <p>事务消息交互流程如下图所示.</p> <p>​<img src="/img/image-20240830230155-l0pjfod.png" alt="image">​</p> <ol><li><p><strong>生产者将消息发送至 RocketMQ 服务端</strong>.</p></li> <li><p>RocketMQ 服务端<strong>将消息持久化</strong>成功之后, 向生产者返回 Ack 确认消息已经发送成功, 此时消息被标记为 &quot;<strong>暂不能投递</strong>&quot;, 这种状态下的消息即为<strong>半事务消息</strong>.</p></li> <li><p><strong>生产者开始执行本地事务逻辑</strong>.</p></li> <li><p><strong>生产者根据本地事务执行结果向服务端提交二次确认结果(Commit 或是 Rollback)</strong> , 服务端收到确认结果后处理逻辑如下:</p> <ul><li><strong>二次确认结果为 Commit: 服务端将半事务消息标记为可投递, 并投递给消费者</strong>.</li> <li><strong>二次确认结果为 Rollback: 服务端将回滚事务, 不会将半事务消息投递给消费者</strong>.</li></ul></li> <li><p>在断网或者是生产者应用重启的特殊情况下, 若服务端未收到发送者提交的二次确认结果, 或服务端收到的二次确认结果为 Unknown 未知状态, 经过固定时间后, <strong>服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查</strong>. 服务端回查的间隔时间默认值: 60秒.</p></li> <li><p><strong>生产者收到消息回查后, 需要检查对应消息的本地事务执行的最终结果</strong>.</p></li> <li><p><strong>生产者根据检查到的本地事务的最终状态再次提交二次确认, 服务端仍按照步骤 4 对半事务消息进行处理</strong>.</p></li></ol> <blockquote><p>事务消息生命周期</p></blockquote> <p>​<img src="/img/image-20240825204408-9usjcp4.png" alt="image">​</p> <ul><li><strong>初始化</strong>: 半事务消息被生产者构建并完成初始化, 待发送到服务端的状态.</li> <li><strong>事务待提交</strong>: 半事务消息被发送到服务端, 和普通消息不同, <strong>并不会直接被服务端持久化, 而是会被单独存储到事务存储系统中, 等待第二阶段本地事务返回执行结果后再提交</strong>. 此时消息对下游消费者不可见.</li> <li><strong>消息回滚</strong>: 第二阶段<strong>如果事务执行结果明确为回滚, 服务端会将半事务消息回滚, 该事务消息流程终止</strong>.</li> <li><strong>提交待消费</strong>: 第二阶段<strong>如果事务执行结果明确为提交, 服务端会将半事务消息重新存储到普通存储系统中, 此时消息对下游消费者可见, 等待被消费者获取并消费</strong>.</li> <li><strong>消费中</strong>: 消息被消费者获取, 并按照消费者本地的业务逻辑进行处理的过程. 此时服务端会等待消费者完成消费并提交消费结果, 如果一定时间后没有收到消费者的响应, RocketMQ 会对消息进行重试处理.</li> <li><strong>消费提交</strong>: 消费者完成消费处理, 并向服务端提交消费结果, 服务端标记当前消息已经被处理(包括消费成功和失败). RocketMQ 默认支持保留所有消息, 此时消息数据并不会立即被删除, 只是逻辑标记已消费. 消息在保存时间到期或存储空间不足被删除前, 消费者仍然可以回溯消息重新消费.</li> <li><strong>消息删除</strong>: RocketMQ 按照消息保存机制滚动清理最早的消息数据, 将消息从物理文件中删除.</li></ul> <h5 id="使用限制"><a href="#使用限制" class="header-anchor">#</a> 使用限制</h5> <blockquote><p>消息类型一致性</p></blockquote> <p>事务消息仅支持在 <strong>MessageType 为 Transaction 的主题内使用</strong>, 即事务消息只能发送至类型为事务消息的主题中, 发送的消息的类型必须和主题的类型一致.</p> <blockquote><p>消费事务性</p></blockquote> <p><strong>事务消息保证本地主分支事务和下游消息发送事务的一致性, 但不保证消息消费结果和上游事务的一致性</strong>. 因此需要下游业务分支自行保证消息正确处理, 建议消费端做好消费重试, 如果有短暂失败可以利用重试机制保证最终处理成功.</p> <blockquote><p>中间状态可见性</p></blockquote> <p><strong>RocketMQ 事务消息为最终一致性, 即在消息提交到下游消费端处理完成之前, 下游分支和上游事务之间的状态会不一致. 因此, 事务消息仅适合接受异步执行的事务场景.</strong></p> <blockquote><p>事务超时机制</p></blockquote> <p>RocketMQ 事务消息的生命周期存在超时机制, 即半事务消息被生产者发送服务端后, 如果在指定时间内服务端无法确认提交或者回滚状态, 则消息默认会被回滚.</p> <h5 id="使用示例-5"><a href="#使用示例-5" class="header-anchor">#</a> 使用示例</h5> <blockquote><p>创建主题</p></blockquote> <p>RocketMQ 5.0版本下创建主题操作, 推荐使用 mqadmin 工具, 需要注意的是, 对于消息类型需要通过属性参数添加. 示例如下:</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token function">sh</span> mqadmin updateTopic <span class="token parameter variable">-n</span> <span class="token operator">&lt;</span>nameserver_address<span class="token operator">&gt;</span> <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>topic_name<span class="token operator">&gt;</span> <span class="token parameter variable">-c</span> <span class="token operator">&lt;</span>cluster_name<span class="token operator">&gt;</span> <span class="token parameter variable">-a</span> +message.type<span class="token operator">=</span>TRANSACTION
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>发送消息</p></blockquote> <p>事务消息相比普通消息发送时需要修改以下几点:</p> <ul><li><strong>发送事务消息前, 需要开启事务并关联本地的事务执行</strong>.</li> <li><strong>为保证事务一致性, 在构建生产者时, 必须设置事务检查器和预绑定事务消息发送的主题列表, 客户端内置的事务检查器会对绑定的事务主题做异常状态恢复</strong>.</li></ul> <blockquote><p>创建事务主题</p></blockquote> <p>NORMAL 类型 Topic 不支持 TRANSACTION 类型消息, 生产消息会报错.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>./bin/mqadmin updatetopic <span class="token parameter variable">-n</span> localhost:9876 <span class="token parameter variable">-t</span> TestTopic <span class="token parameter variable">-c</span> DefaultCluster <span class="token parameter variable">-a</span> +message.type<span class="token operator">=</span>TRANSACTION
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>-c 集群名称</li> <li>-t Topic名称</li> <li>-n nameserver地址</li> <li>-a 额外属性, 本例给主题添加了 <code>message.type</code>​ 为 <code>TRANSACTION</code>​ 的属性用来支持事务消息</li></ul> <p>以 Java 语言为例, 使用事务消息示例参考如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 演示demo, 模拟订单表查询服务, 用来确认订单事务是否提交成功. </span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">checkOrderById</span><span class="token punctuation">(</span><span class="token class-name">String</span> orderId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 演示demo, 模拟本地事务的执行结果. </span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">doLocalTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClientException</span> <span class="token punctuation">{</span>
    <span class="token class-name">ClientServiceProvider</span> provider <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClientServiceProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">MessageBuilder</span> messageBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageBuilderImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 构造事务生产者: 事务消息需要生产者构建一个事务检查器, 用于检查确认异常半事务的中间状态. </span>
    <span class="token class-name">Producer</span> producer <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">newProducerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setTransactionChecker</span><span class="token punctuation">(</span>messageView <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token comment">/**
                 * 事务检查器一般是根据业务的ID去检查本地事务是否正确提交还是回滚, 此处以订单ID属性为例. 
                 * 在订单表找到了这个订单, 说明本地事务插入订单的操作已经正确提交; 如果订单表没有订单, 说明本地事务已经回滚. 
                 */</span>
                <span class="token keyword">final</span> <span class="token class-name">String</span> orderId <span class="token operator">=</span> messageView<span class="token punctuation">.</span><span class="token function">getProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;OrderId&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Strings</span><span class="token punctuation">.</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 错误的消息, 直接返回Rollback. </span>
                    <span class="token keyword">return</span> <span class="token class-name">TransactionResolution</span><span class="token punctuation">.</span><span class="token constant">ROLLBACK</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> <span class="token function">checkOrderById</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token class-name">TransactionResolution</span><span class="token punctuation">.</span><span class="token constant">COMMIT</span> <span class="token operator">:</span> <span class="token class-name">TransactionResolution</span><span class="token punctuation">.</span><span class="token constant">ROLLBACK</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 开启事务分支. </span>
    <span class="token keyword">final</span> <span class="token class-name">Transaction</span> transaction<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        transaction <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 事务分支开启失败, 直接退出. </span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token class-name">Message</span> message <span class="token operator">=</span> messageBuilder<span class="token punctuation">.</span><span class="token function">setTopic</span><span class="token punctuation">(</span><span class="token string">&quot;topic&quot;</span><span class="token punctuation">)</span>
            <span class="token comment">// 设置消息索引键, 可根据关键字精确查找某条消息. </span>
            <span class="token punctuation">.</span><span class="token function">setKeys</span><span class="token punctuation">(</span><span class="token string">&quot;messageKey&quot;</span><span class="token punctuation">)</span>
            <span class="token comment">// 设置消息Tag, 用于消费端根据指定Tag过滤消息. </span>
            <span class="token punctuation">.</span><span class="token function">setTag</span><span class="token punctuation">(</span><span class="token string">&quot;messageTag&quot;</span><span class="token punctuation">)</span>
            <span class="token comment">// 一般事务消息都会设置一个本地事务关联的唯一ID, 用来做本地事务回查的校验. </span>
            <span class="token punctuation">.</span><span class="token function">addProperty</span><span class="token punctuation">(</span><span class="token string">&quot;OrderId&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;xxx&quot;</span><span class="token punctuation">)</span>
            <span class="token comment">// 消息体. </span>
            <span class="token punctuation">.</span><span class="token function">setBody</span><span class="token punctuation">(</span><span class="token string">&quot;messageBody&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 发送半事务消息</span>
    <span class="token keyword">final</span> <span class="token class-name">SendReceipt</span> sendReceipt<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        sendReceipt <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> transaction<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 半事务消息发送失败, 事务可以直接退出并回滚. </span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 执行本地事务, 并确定本地事务结果. 
     * 1. 如果本地事务提交成功, 则提交消息事务. 
     * 2. 如果本地事务提交失败, 则回滚消息事务. 
     * 3. 如果本地事务未知异常, 则不处理, 等待事务消息回查. 
     */</span>
    <span class="token keyword">boolean</span> localTransactionOk <span class="token operator">=</span> <span class="token function">doLocalTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>localTransactionOk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            transaction<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 业务可以自身对实时性的要求选择是否重试, 如果放弃重试, 可以依赖事务消息回查机制进行事务状态的提交. </span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            transaction<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 建议记录异常信息, 回滚异常时可以无需重试, 依赖事务消息回查机制进行事务状态的提交. </span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br></div></div><h5 id="使用建议-11"><a href="#使用建议-11" class="header-anchor">#</a> 使用建议</h5> <blockquote><p>避免大量未决事务导致超时</p></blockquote> <p>RocketMQ 支持在<strong>事务提交阶段异常的情况下发起事务回查, 保证事务一致性</strong>. 但生产者应该尽量避免本地事务返回未知结果. 大量的事务检查会导致系统性能受损, 容易导致事务处理延迟.</p> <blockquote><p>需要正确处理&quot;进行中&quot;的事务</p></blockquote> <p><strong>消息回查时, 对于正在进行中的事务不要返回 Rollback 或 Commit 结果, 应继续保持 Unknown 的状态</strong>. 一般出现消息回查时事务正在处理的原因为: 事务执行较慢, 消息回查太快. 解决方案如下:</p> <ul><li><strong>将第一次事务回查时间设置较大一些</strong>, 但可能导致依赖回查的事务提交延迟较大.</li> <li>程序能正确识别正在进行中的事务.</li></ul> <h5 id="应用场景-4"><a href="#应用场景-4" class="header-anchor">#</a> 应用场景</h5> <blockquote><p>分布式事务的诉求</p></blockquote> <p>分布式系统调用的特点为<strong>一个核心业务逻辑的执行, 同时需要调用多个下游业务进行处理</strong>. 因此, <strong>如何保证核心业务和多个下游业务的执行结果完全一致, 是分布式事务需要解决的主要问题</strong>.</p> <p><img src="/img/tradetrans01-636d42fb6584de6c51692d0889af5c2d-20240422214206-xpwoorj.png" alt="事务消息诉求"></p> <p>以电商交易场景为例, 用户支付订单这一核心操作的同时会涉及到下游物流发货, 积分变更, 购物车状态清空等多个子系统的变更. 当前业务的<strong>处理分支</strong>包括:</p> <ul><li>主分支订单系统状态更新: 由未支付变更为支付成功.</li> <li>物流系统状态新增: 新增待发货物流记录, 创建订单物流记录.</li> <li>积分系统状态变更: 变更用户积分, 更新用户积分表.</li> <li>购物车系统状态变更: 清空购物车, 更新用户购物车记录.</li></ul> <p><strong>传统XA事务方案: 性能不足</strong></p> <p>为了保证上述四个分支的执行结果一致性, 典型方案是<strong>基于 XA 协议</strong>的分布式事务系统来实现. 将四个调用分支封装成包含四个独立事务分支的大事务. 基于 XA 分布式事务的方案可以满足业务处理结果的正确性, 但最大的缺点是<strong>多分支环境下资源锁定范围大, 并发度低, 随着下游分支的增加, 系统性能会越来越差</strong>.</p> <p><strong>基于普通消息方案: 一致性保障困难</strong></p> <p>将上述基于 XA 事务的方案进行简化, 将订单系统变更作为<strong>本地事务</strong>, 剩下的系统变更作为普通消息的下游来执行, 事务分支简化成<strong>普通消息+订单表事务</strong>, 充分利用消息异步化的能力缩短链路, 提高并发度.</p> <p><img src="/img/transwithnormal-f7d951385520fc18aea8d85f0cd86c27-20240422214206-g1dw9g9.png" alt="普通消息方案"></p> <p>该方案中消息下游分支和订单系统变更的主分支很容易<strong>出现不一致的现象</strong>, 例如:</p> <ul><li>消息发送成功, 订单没有执行成功, 需要回滚整个事务.</li> <li>订单执行成功, 消息没有发送成功, 需要额外补偿才能发现不一致.</li> <li>消息发送超时未知, 此时无法判断需要回滚订单还是提交订单变更.</li></ul> <p><strong>基于 RocketMQ 分布式事务消息: 支持最终一致性</strong></p> <p>上述普通消息方案中, 普通消息和订单事务无法保证一致的原因, 本质上是由于<strong>普通消息无法像单机数据库事务一样, 具备提交, 回滚和统一协调的能力</strong>.</p> <p>而<strong>基于 RocketMQ 实现的分布式事务消息功能, 在普通消息基础上, 支持二阶段的提交能力. 将二阶段提交和本地事务绑定, 实现全局提交结果的一致性</strong>.</p> <p><img src="/img/tradewithtrans-25be17fcdedb8343a0d2633e693d126d-20240422214206-v7x2zty.png" alt="事务消息"></p> <p>RocketMQ 事务消息的方案, 具备高性能, 可扩展, 业务开发简单的优势. 具体事务消息的原理和流程, 请参见下文的功能原理.</p> <h4 id="消息发送重试和流控机制"><a href="#消息发送重试和流控机制" class="header-anchor">#</a> 消息发送重试和流控机制</h4> <p>本文介绍 RocketMQ 的<strong>消息发送重试机制和消息流控机制</strong>.</p> <p>RocketMQ 的<strong>消息发送重试机制</strong>主要解答如下问题:</p> <ul><li>部分节点异常是否影响消息发送?</li> <li>请求重试是否会阻塞业务调用?</li> <li>请求重试会带来什么不足?</li></ul> <h5 id="消息发送重试机制"><a href="#消息发送重试机制" class="header-anchor">#</a> 消息发送重试机制</h5> <h6 id="重试基本概念"><a href="#重试基本概念" class="header-anchor">#</a> 重试基本概念</h6> <p><strong>RocketMQ 客户端连接服务端发起消息发送请求时, 可能会因为网络故障, 服务异常等原因导致调用失败. 为保证消息的可靠性, RocketMQ 在客户端 SDK 中内置请求重试逻辑, 尝试通过重试发送达到最终调用成功的效果</strong>.</p> <p>同步发送和异步发送模式均支持消息发送重试.</p> <blockquote><p>重试触发条件</p></blockquote> <p>触发消息发送重试机制的条件如下:</p> <ul><li><p>客户端消息发送请求调用失败或请求超时</p></li> <li><p>网络异常造成连接失败或请求超时.</p></li> <li><p>服务端节点处于重启或下线等状态造成连接失败.</p></li> <li><p>服务端运行慢造成请求超时.</p></li> <li><p>服务端返回失败错误码:</p> <ul><li>系统逻辑错误: 因运行逻辑不正确造成的错误.</li> <li>系统流控错误: 因容量超限造成的流控错误.</li></ul></li></ul> <p>备注: 对于事务消息, 只会进行<strong>透明重试</strong>(transparent retries), 网络超时或异常等场景不会进行重试.</p> <h6 id="重试流程"><a href="#重试流程" class="header-anchor">#</a> 重试流程</h6> <p><strong>生产者在初始化时设置消息发送最大重试次数</strong>, 当出现上述触发条件的场景时, 生产者客户端会按照设置的重试次数一直重试发送消息, 直到消息发送成功或达到最大重试次数重试结束, 并在最后一次重试失败后返回调用错误响应.</p> <ul><li>同步发送: 调用线程会一直阻塞, 直到某次重试成功或最终重试失败, 抛出错误码和异常.</li> <li>异步发送: 调用线程不会阻塞, 但调用结果会通过异常事件或者成功事件返回.</li></ul> <h6 id="重试间隔"><a href="#重试间隔" class="header-anchor">#</a> 重试间隔</h6> <p>除服务端返回系统流控错误场景外, 其他触发条件触发重试后, <strong>均会立即进行重试, 无等待间隔</strong>.</p> <p>若由于服务端返回流控错误触发重试, 系统会按照<strong>指数退避策略</strong>进行延迟重试. 指数退避算法通过以下参数控制重试行为:</p> <ul><li>INITIAL_BACKOFF: 第一次失败重试前后需等待多久, 默认值: 1秒.</li> <li>MULTIPLIER: 指数退避因子, 即退避倍率, 默认值: 1.6.</li> <li>JITTER: 随机抖动因子, 默认值: 0.2.</li> <li>MAX_BACKOFF: 等待间隔时间上限, 默认值: 120秒</li> <li>MIN_CONNECT_TIMEOUT: 最短重试间隔, 默认值: 20秒.</li></ul> <p><strong>建议算法如下:</strong></p> <div class="language-unknow line-numbers-mode"><pre class="language-text"><code>ConnectWithBackoff()
  current_backoff = INITIAL_BACKOFF
  current_deadline = now() + INITIAL_BACKOFF
  while (TryConnect(Max(current_deadline, now() + MIN_CONNECT_TIMEOUT)) != SUCCESS)
    SleepUntil(current_deadline)
    current_backoff = Min(current_backoff * MULTIPLIER, MAX_BACKOFF)
    current_deadline = now() + current_backoff + UniformRandom(-JITTER * current_backoff, JITTER * current_backoff)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h6 id="功能约束"><a href="#功能约束" class="header-anchor">#</a> 功能约束</h6> <p><strong>链路耗时阻塞评估</strong>: 从上述重试机制可以看出, 在重试流程中生产者仅能控制最大重试次数. 若由于系统异常触发了 SDK 内置的重试逻辑, 则服务端需要等待最终重试结果, 可能会导致消息发送请求链路被阻塞. 对于某些实时调用类场景, <strong>需要合理评估每次调用请求的超时时间以及最大重试次数, 避免影响全链路的耗时</strong>.</p> <p><strong>最终异常兜底</strong>: RocketMQ 客户端内置的发送请求重试机制并不能保证消息发送一定成功. 当最终重试仍然失败时, 业务方调用需要捕获异常, 并做好冗余保护处理, 避免消息发送结果不一致.</p> <p><strong>消息重复问题</strong>: 因远程调用的不确定性, 当 RocketMQ 客户端因请求超时触发消息发送重试流程, 此时客户端无法感知服务端的处理结果, 客户端进行的<strong>消息发送重试可能会产生消息重复问题</strong>, 业务逻辑需要自行处理消息重复问题.</p> <h5 id="消息流控机制"><a href="#消息流控机制" class="header-anchor">#</a> 消息流控机制</h5> <p>RocketMQ 的<strong>流控机制</strong>主要解答如下问题:</p> <ul><li>系统在什么情况下会触发流控?</li> <li>触发流控时客户端行为是什么?</li> <li>应该如何避免触发流控, 以及如何应对突发流控?</li></ul> <blockquote><p>消息流控定义</p></blockquote> <p>消息流控指的是<strong>系统容量或水位过高, RocketMQ 服务端会通过快速失败返回流控错误来避免底层资源承受过高压力</strong>.</p> <h6 id="触发条件"><a href="#触发条件" class="header-anchor">#</a> 触发条件</h6> <p>RocketMQ 的消息流控触发条件如下:</p> <ul><li><strong>存储压力大</strong>: 参考消费进度管理的原理机制, 消费者分组的初始消费位点为当前队列的最大消费位点. 若某些场景例如<strong>业务上新等需要回溯到指定时刻前开始消费, 此时队列的存储压力会瞬间飙升, 触发消息流控</strong>.</li> <li><strong>服务端请求任务排队溢出</strong>: 若消费者消费能力不足, 导致队列中有大量堆积消息, 当堆积消息超过一定数量后会触发消息流控, 减少下游消费系统压力.</li></ul> <h6 id="流控行为"><a href="#流控行为" class="header-anchor">#</a> 流控行为</h6> <p>当系统触发消息发送流控时, <strong>客户端会收到系统限流错误和异常</strong>, 错误码信息如下:</p> <ul><li>reply-code: 530</li> <li>reply-text: TOO_MANY_REQUESTS</li></ul> <p>客户端收到系统流控错误码后, 会<strong>根据指数退避策略进行消息发送重试</strong>.</p> <h6 id="处理建议"><a href="#处理建议" class="header-anchor">#</a> 处理建议</h6> <p><strong>如何避免触发消息流控</strong>: 触发限流的根本原因是系统容量或水位过高, 可以利用可观测性功能监控系统水位容量等, 保证底层资源充足, 避免触发流控机制.</p> <p><strong>突发消息流控处理</strong>: 如果因为突发原因触发消息流控, 且客户端内置的重试流程执行失败, 则建议业务方将请求调用临时替换到其他系统进行应急处理.</p> <h4 id="消费者分类"><a href="#消费者分类" class="header-anchor">#</a> 消费者分类</h4> <p>RocketMQ 支持 <mark><strong>PushConsumer, SimpleConsumer 以及 PullConsumer</strong></mark> 这三种类型的消费者, 本文分别从使用方式, 实现原理, 可靠性重试和适用场景等方面介绍这三种类型的消费者.</p> <p>RocketMQ 面向不同的业务场景提供了不同消费者类型, <strong>每种消费者类型的集成方式和控制方式都不一样</strong>. 了解如下问题, 可以帮助选择更匹配业务场景的消费者类型.</p> <ul><li><strong>如何实现并发消费</strong>: 消费者如何使用并发的多线程机制处理消息, 以此提高消息处理效率?</li> <li><strong>如何实现同步, 异步消息处理</strong>: 对于不同的集成场景, 消费者获取消息后可能会将消息异步分发到业务逻辑中处理, 此时, 消息异步化处理如何实现?</li> <li><strong>如何实现消息可靠处理</strong>: 消费者处理消息时如何返回响应结果? 如何在消息异常情况进行重试, 保证消息的可靠处理?</li></ul> <p>以上问题的具体答案, 请参考下文.</p> <h5 id="功能概述"><a href="#功能概述" class="header-anchor">#</a> 功能概述</h5> <p><img src="/img/image-20240830231712-mcxg4jw.png" alt="image"></p> <p>如上图所示, RocketMQ 的消费者处理消息时主要经过以下阶段: <mark><strong>消息获取-&gt;消息处理-&gt;消费状态提交</strong></mark>.</p> <p>针对以上几个阶段, RocketMQ 提供了不同的消费者类型: <strong>PushConsumer, SimpleConsumer 和 PullConsumer</strong>. 这几种类型的消费者通过不同的实现方式和接口可满足不同业务场景下的消费需求.</p> <p>具体差异如下:</p> <table><thead><tr><th style="text-align:center;">对比项</th> <th>PushConsumer</th> <th>SimpleConsumer</th> <th>PullConsumer</th></tr></thead> <tbody><tr><td style="text-align:center;">接口方式</td> <td><strong>使用监听器回调接口返回消费结果</strong>, 消费者仅允许在监听器范围内处理消费逻辑.</td> <td>业务方自行实现消息处理, 并主动调用接口返回消费结果.</td> <td><strong>业务方自行按队列拉取消息, 并可选择性地提交消费结果</strong></td></tr> <tr><td style="text-align:center;">消费并发度管理</td> <td>由 SDK 管理消费并发度.</td> <td>由业务方消费逻辑自行管理消费线程.</td> <td>由业务方消费逻辑自行管理消费线程.</td></tr> <tr><td style="text-align:center;">负载均衡粒度</td> <td>5.0 SDK 是消息粒度, 更均衡, 早期版本是队列维度</td> <td>消息粒度, 更均衡</td> <td>队列粒度, 吞吐攒批性能更好, 但容易不均衡</td></tr> <tr><td style="text-align:center;">接口灵活度</td> <td>高度封装, 不够灵活.</td> <td><strong>原子接口, 可灵活自定义</strong>.</td> <td>原子接口, 可灵活自定义.</td></tr> <tr><td style="text-align:center;">适用场景</td> <td>适用于无自定义流程的业务消息开发场景.</td> <td><strong>适用于需要高度自定义业务流程的业务开发场景</strong>.</td> <td>仅推荐在<strong>流处理框架场景</strong>下集成使用</td></tr></tbody></table> <p>在实际使用场景中, <strong>PullConsumer 仅推荐在流处理框架中集成使用, 大多数消息收发场景使用 PushConsumer 和 SimpleConsumer 就可以满足需求</strong>.</p> <p>若业务场景发生变更, 或当前使用的消费者类型不适合当前业务, 可以选择在 PushConsumer 和 SimpleConsumer 之间<strong>变更</strong>消费者类型. <strong>变更消费者类型不影响当前 RocketMQ 资源的使用和业务处理</strong>.</p> <p>注意: 生产环境中相同的 ConsumerGroup 下严禁混用 PullConsumer 和其他两种消费者, 否则会导致消息消费异常.</p> <h5 id="pushconsumer"><a href="#pushconsumer" class="header-anchor">#</a> PushConsumer</h5> <p>PushConsumers 是一种<strong>高度封装的消费者类型</strong>, 消费消息仅通过消费监听器处理业务并返回消费结果. 消息的获取, 消费状态提交以及消费重试都通过 RocketMQ 的客户端 SDK 完成.</p> <blockquote><p>使用方式</p></blockquote> <p>PushConsumer 的使用方式比较固定, 在消费者初始化时注册一个消费监听器, 并在消费监听器内部实现消息处理逻辑. 由 RocketMQ 的 SDK <strong>在后台完成消息获取, 触发监听器调用以及进行消息重试处理</strong>.</p> <p>示例代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 消费示例: 使用PushConsumer消费普通消息. </span>
<span class="token class-name">ClientServiceProvider</span> provider <span class="token operator">=</span> <span class="token class-name">ClientServiceProvider</span><span class="token punctuation">.</span><span class="token function">loadService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> topic <span class="token operator">=</span> <span class="token string">&quot;YourTopic&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">FilterExpression</span> filterExpression <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterExpression</span><span class="token punctuation">(</span><span class="token string">&quot;YourFilterTag&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FilterExpressionType</span><span class="token punctuation">.</span><span class="token constant">TAG</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">PushConsumer</span> pushConsumer <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">newPushConsumerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 设置消费者分组. </span>
    <span class="token punctuation">.</span><span class="token function">setConsumerGroup</span><span class="token punctuation">(</span><span class="token string">&quot;YourConsumerGroup&quot;</span><span class="token punctuation">)</span>
    <span class="token comment">// 设置接入点. </span>
    <span class="token punctuation">.</span><span class="token function">setClientConfiguration</span><span class="token punctuation">(</span><span class="token class-name">ClientConfiguration</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setEndpoints</span><span class="token punctuation">(</span><span class="token string">&quot;YourEndpoint&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 设置预绑定的订阅关系. </span>
    <span class="token punctuation">.</span><span class="token function">setSubscriptionExpressions</span><span class="token punctuation">(</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonMap</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> filterExpression<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 设置消费监听器. </span>
    <span class="token punctuation">.</span><span class="token function">setMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">ConsumeResult</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">MessageView</span> messageView<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 消费消息并返回处理结果. </span>
            <span class="token keyword">return</span> <span class="token class-name">ConsumeResult</span><span class="token punctuation">.</span><span class="token constant">SUCCESS</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>PushConsumer 的消费监听器执行结果分为以下三种情况:</p> <ul><li><strong>返回消费成功</strong>: 以 Java SDK 为例, 返回 <code>ConsumeResult.SUCCESS</code>​, 表示该消息处理成功, 服务端按照消费结果更新消费进度.</li> <li><strong>返回消费失败</strong>: 以 Java SDK 为例, 返回 <code>ConsumeResult.FAILURE</code>​, 表示该消息处理失败, 需要根据消费重试逻辑判断是否进行重试消费.</li> <li><strong>出现非预期失败</strong>: 例如抛异常等行为, 该结果按照消费失败处理, 需要根据消费重试逻辑判断是否进行重试消费.</li></ul> <p>PushConsumer 消费消息时, 若消息处理逻辑出现预期之外的阻塞导致消息处理一直无法执行成功, SDK 会按照消费<strong>超时处理强制提交消费失败结果</strong>, 并按照消费重试逻辑进行处理.</p> <p>注意: 出现消费超时情况时, SDK 虽然提交消费失败结果, 但是当前消费线程可能仍然无法响应中断, 还会继续处理消息.</p> <blockquote><p>内部原理</p></blockquote> <p>在 PushConsumer 类型中, 消息的实时处理能力是基于 SDK 内部的典型 <strong>Reactor 线程模型</strong>实现的. 如下图所示, SDK 内置了一个长轮询线程, <strong>先将消息异步拉取(pull)到 SDK 内置的缓存队列中, 再分别提交到消费线程中, 触发监听器执行本地消费逻辑</strong>.</p> <p>​<img src="/img/pushconsumer-26b909b090d4f911a40d5050d3ceba1d-20240422214326-2aj4nia.png" alt="PushConsumer原理">​</p> <blockquote><p>可靠性重试</p></blockquote> <p>PushConsumer 消费者类型中, 客户端 SDK 和消费逻辑的唯一边界是<strong>消费监听器接口</strong>. 客户端 SDK 严格按照监听器的返回结果判断消息是否消费成功, 并做可靠性重试. 所有消息必须<strong>以同步方式进行消费处理</strong>, 并在监听器接口结束时返回调用结果, 不允许再做异步化分发.</p> <p>使用 PushConsumer 消费者消费时, <strong>不允许使用以下方式处理消息, 否则无法保证消息的可靠性</strong>.</p> <ul><li>错误方式一: 消息还未处理完成, 就提前返回消费成功结果. 此时如果消息消费失败, RocketMQ 服务端是无法感知的, 因此不会进行消费重试.</li> <li>错误方式二: 在消费监听器内将消息再次分发到自定义的其他线程, 消费监听器提前返回消费结果. 此时如果消息消费失败, RocketMQ 服务端同样无法感知, 因此也不会进行消费重试.</li></ul> <blockquote><p>顺序性保障</p></blockquote> <p>基于 RocketMQ 顺序消息的定义, 如果消费者分组<strong>设置了顺序消费模式</strong>, 则 PushConsumer 在触发消费监听器时, 严格遵循消息的先后顺序. 业务处理逻辑无感知即可保证消息的消费顺序.</p> <p>消息消费按照顺序处理的前提是遵循同步提交原则, 如果业务逻辑自定义实现了异步分发, 则 RocketMQ 无法保证消息的顺序性.</p> <blockquote><p>适用场景</p></blockquote> <p><strong>PushConsumer 严格限制了消息同步处理及每条消息的处理超时时间</strong>, 适用于以下场景:</p> <ul><li><strong>消息处理时间可预估场景</strong>: 如果不确定消息处理耗时, 经常有预期之外的长时间耗时的消息, PushConsumer 的可靠性保证会频繁触发消息重试机制造成大量重复消息.</li> <li><strong>无异步化, 高级定制场景</strong>: PushConsumer 限制了消费逻辑的线程模型, 由客户端 SDK 内部按最大吞吐量触发消息处理. 该模型开发逻辑简单, 但是不允许使用异步化和自定义处理流程.</li></ul> <h5 id="simpleconsumer"><a href="#simpleconsumer" class="header-anchor">#</a> SimpleConsumer</h5> <p>SimpleConsumer 是一种接口原子型的消费者类型, 消息的获取, 消费状态提交以及消费重试都是<strong>通过</strong>​<mark><strong>消费者业务逻辑</strong></mark>​<strong>主动发起调用完成</strong>.</p> <blockquote><p>使用方式</p></blockquote> <p>SimpleConsumer 的使用涉及多个接口调用, <strong>由业务逻辑按需调用接口获取消息, 然后分发给业务线程处理消息, 最后按照处理的结果调用提交接口, 返回服务端当前消息的处理结果</strong>. 示例如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 消费示例: 使用 SimpleConsumer 消费普通消息, 主动获取消息处理并提交.  </span>
<span class="token class-name">ClientServiceProvider</span> provider <span class="token operator">=</span> <span class="token class-name">ClientServiceProvider</span><span class="token punctuation">.</span><span class="token function">loadService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> topic <span class="token operator">=</span> <span class="token string">&quot;YourTopic&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">FilterExpression</span> filterExpression <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterExpression</span><span class="token punctuation">(</span><span class="token string">&quot;YourFilterTag&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FilterExpressionType</span><span class="token punctuation">.</span><span class="token constant">TAG</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SimpleConsumer</span> simpleConsumer <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">newSimpleConsumerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// 设置消费者分组. </span>
        <span class="token punctuation">.</span><span class="token function">setConsumerGroup</span><span class="token punctuation">(</span><span class="token string">&quot;YourConsumerGroup&quot;</span><span class="token punctuation">)</span>
        <span class="token comment">// 设置接入点. </span>
        <span class="token punctuation">.</span><span class="token function">setClientConfiguration</span><span class="token punctuation">(</span><span class="token class-name">ClientConfiguration</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setEndpoints</span><span class="token punctuation">(</span><span class="token string">&quot;YourEndpoint&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 设置预绑定的订阅关系. </span>
        <span class="token punctuation">.</span><span class="token function">setSubscriptionExpressions</span><span class="token punctuation">(</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonMap</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> filterExpression<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 设置从服务端接受消息的最大等待时间</span>
        <span class="token punctuation">.</span><span class="token function">setAwaitDuration</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// SimpleConsumer 需要主动获取消息并处理. </span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageView</span><span class="token punctuation">&gt;</span></span> messageViewList <span class="token operator">=</span> simpleConsumer<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    messageViewList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>messageView <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>messageView<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 消费处理完成后, 需要主动调用 ACK 提交消费结果. </span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            simpleConsumer<span class="token punctuation">.</span><span class="token function">ack</span><span class="token punctuation">(</span>messageView<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;Failed to ack message, messageId={}&quot;</span><span class="token punctuation">,</span> messageView<span class="token punctuation">.</span><span class="token function">getMessageId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果遇到系统流控等原因造成拉取失败, 需要重新发起获取消息请求. </span>
    logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;Failed to receive message&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>SimpleConsumer 主要涉及以下几个接口行为:</p> <table><thead><tr><th>接口名称</th> <th>主要作用</th> <th>可修改参数</th></tr></thead> <tbody><tr><td>​<code>ReceiveMessage</code>​</td> <td>消费者主动调用该接口从服务端获取消息. 说明由于服务端存储为分布式, 可能会出现服务端实际有消息, 但是返回为空的现象. 一般可通过重新发起 ReceiveMessage 调用或提高 ReceiveMessage 的并发度解决.</td> <td><strong>批量拉取消息数</strong>: SimpleConsumer可以一次性批量获取多条消息实现批量消费, 该接口可修改批量获取的消息数量. <strong>消费不可见时间</strong>: 消息的最长处理耗时, 该参数用于控制消费失败时的消息重试间隔. 消费者调用<code>ReceiveMessage</code>​接口时需要指定消费不可见时间.</td></tr> <tr><td>​<code>AckMessage</code>​</td> <td>消费者成功消费消息后, 主动调用该接口向服务端返回消费成功响应.</td> <td>无</td></tr> <tr><td>​<code>ChangeInvisibleDuration</code>​</td> <td>消费重试场景下, 消费者可通过该接口修改消息处理时长, 即控制消息的重试间隔.</td> <td>消费不可见时间: 调用本接口可修改<code>ReceiveMessage</code>​接口预设的消费不可见时间的参数值. 一般用于需要延长消息处理时长的场景.</td></tr></tbody></table> <blockquote><p>可靠性重试</p></blockquote> <p>SimpleConsumer 消费者类型中, 客户端 SDK 和服务端通过 <code>ReceiveMessage</code>​ 和 <code>AckMessage</code>​ 接口通信. 客户端 SDK 如果处理消息成功则调用 <code>AckMessage</code>​ 接口; 如果处理失败只需要不回复 ACK 响应, 即可在定义的消费不可见时间到达后触发消费重试流程.</p> <blockquote><p>顺序性保障</p></blockquote> <p>基于顺序消息的定义, SimpleConsumer 在处理顺序消息时, 会<strong>按照消息存储的先后顺序获取消息</strong>. 即需要保持顺序的一组消息中, 如果前面的消息未处理完成, 则无法获取到后面的消息.</p> <blockquote><p>适用场景</p></blockquote> <p><strong>SimpleConsumer 提供原子接口, 用于消息获取和提交消费结果, 相对于 PushConsumer 方式更加灵活</strong>.</p> <p>SimpleConsumer 适用于以下场景:</p> <ul><li><strong>消息处理时长不可控</strong>: 如果消息处理时长无法预估, 经常有长时间耗时的消息处理情况. 建议使用 SimpleConsumer 消费类型, 可以在消费时自定义消息的预估处理时长, 若实际业务中预估的消息处理时长不符合预期, 也可以通过接口提前修改.</li> <li><strong>需要异步化, 批量消费等高级定制场景</strong>: SimpleConsumer 在 SDK 内部没有复杂的线程封装, 完全由业务逻辑自由定制, 可以实现异步分发, 批量消费等高级定制场景.</li> <li><strong>需要自定义消费速率</strong>: SimpleConsumer 是由业务逻辑主动调用接口获取消息, 因此可以自由调整获取消息的频率, 自定义控制消费速率.</li></ul> <h5 id="pullconsumer"><a href="#pullconsumer" class="header-anchor">#</a> PullConsumer</h5> <p>待补充.</p> <h5 id="使用建议-12"><a href="#使用建议-12" class="header-anchor">#</a> 使用建议</h5> <blockquote><p>PushConsumer合理控制消费耗时,避免无限阻塞</p></blockquote> <p>对于 PushConsumer 消费类型, 需要严格控制消息的消费耗时, 尽量<strong>避免出现消息处理超时导致消息重复</strong>. 如果业务经常会出现一些预期外的长时间耗时的消息, 建议使用 SimpleConsumer, 并设置好消费不可见时间.</p> <blockquote><p>怎么设置消费者线程数?</p></blockquote> <p>当<strong>启动消费者的时候, 可以设置属性</strong>. 不同版本的参数名不一样.</p> <h4 id="消息过滤"><a href="#消息过滤" class="header-anchor">#</a> 消息过滤</h4> <h5 id="基础-6"><a href="#基础-6" class="header-anchor">#</a> 基础</h5> <p>消费者订阅了某个主题后, RocketMQ 会将该主题中的所有消息投递给消费者. <strong>若消费者只需要关注部分消息, 可通过设置过滤条件在 RocketMQ 服务端进行过滤, 只获取到需要关注的消息子集, 避免接收到大量无效的消息</strong>. 本文介绍消息过滤的定义, 原理, 分类及不同过滤方式的使用方法, 配置示例等.</p> <blockquote><p>消息过滤定义</p></blockquote> <p><mark><strong>过滤的含义指的是 RocketMQ 服务端将符合条件的消息投递给消费者, 而不是消费者将匹配到的消息过滤掉</strong></mark>.</p> <p>RocketMQ 的消息过滤功能通过生产者和消费者对消息的<strong>属性, 标签</strong>进行定义, 并在 RocketMQ <strong>服务端根据过滤条件进行筛选匹配, 将符合条件的消息投递给消费者进行消费</strong>.</p> <blockquote><p>应用场景</p></blockquote> <p>RocketMQ 作为发布订阅模型的消息中间件广泛应用于上下游业务集成场景. 在实际业务场景中, 同一个主题下的消息往往会被<strong>多个不同的下游业务方处理, 各下游的处理逻辑不同, 只关注自身逻辑需要的消息子集</strong>.</p> <p>使用 RocketMQ 的<strong>消息过滤功能, 可以帮助消费者更高效地过滤自己需要的消息集合</strong>, 避免大量无效消息投递给消费者, 降低下游系统处理压力.</p> <p>RocketMQ 主要解决的<strong>单个业务域即同一个主题内不同消息子集的过滤问题</strong>, 一般是基于同一业务下更具体的分类进行过滤匹配. 如果是需要对不同业务域的消息进行拆分, 建议使用不同主题处理不同业务域的消息.</p> <h5 id="功能概述-2"><a href="#功能概述-2" class="header-anchor">#</a> 功能概述</h5> <blockquote><p>消息过滤原理</p></blockquote> <p>​<img src="/img/messagefilter0-ad2c8360f54b9a622238f8cffea12068-20240422214351-ejehgfo.png" alt="消息过滤">​</p> <p>消息过滤主要通过以下几个关键流程实现:</p> <ul><li><strong>生产者</strong>: 生产者在初始化消息时<strong>预先为消息设置一些属性和标签, 用于后续消费时指定过滤目标</strong>.</li> <li><strong>消费者</strong>: 消费者在初始化及后续消费流程中通过<strong>调用订阅关系注册接口</strong>, 向服务端上报需要订阅指定主题的哪些消息, 即过滤条件.</li> <li><strong>服务端</strong>: 消费者获取消息时会<strong>触发服务端的动态过滤计算, RocketMQ 服务端根据消费者上报的过滤条件的表达式进行匹配, 并将符合条件的消息投递给消费者</strong>.</li></ul> <blockquote><p>消息过滤分类</p></blockquote> <p><mark><strong>RocketMQ 支持 Tag 标签过滤和 SQL 属性过滤</strong></mark>, 这两种过滤方式对比如下:</p> <table><thead><tr><th style="text-align:center;">对比项</th> <th>Tag标签过滤</th> <th>SQL属性过滤</th></tr></thead> <tbody><tr><td style="text-align:center;">过滤目标</td> <td>消息的 Tag 标签.</td> <td>消息的属性, 包括用户自定义属性以及系统属性(Tag 是一种系统属性).</td></tr> <tr><td style="text-align:center;">过滤能力</td> <td>精准匹配.</td> <td>SQL 语法匹配.</td></tr> <tr><td style="text-align:center;">适用场景</td> <td>简单过滤场景, 计算逻辑简单轻量.</td> <td>复杂过滤场景, 计算逻辑较复杂.</td></tr></tbody></table> <p>具体的使用方式及示例, 请参见下文的 Tag 标签过滤和 SQL 属性过滤.</p> <p>过滤表达式属于订阅关系的一部分, RocketMQ 的领域模型规定, 同一消费者分组内的多个消费者的订阅关系包括过滤表达式, 必须保持一致, 否则可能会导致部分消息消费不到.</p> <h5 id="tag标签过滤"><a href="#tag标签过滤" class="header-anchor">#</a> Tag标签过滤</h5> <p>Tag 标签过滤方式是 RocketMQ 提供的基础消息过滤能力, 基于生产者为消息设置的 Tag 标签进行匹配. <strong>生产者在发送消息时, 设置消息的 Tag 标签, 消费者需指定已有的 Tag 标签来进行匹配订阅</strong>.</p> <blockquote><p>场景示例</p></blockquote> <p>以下图电商交易场景为例, 从客户下单到收到商品这一过程会生产一系列消息:</p> <ul><li>订单消息</li> <li>支付消息</li> <li>物流消息</li></ul> <p>这些消息会发送到名称为 Trade_Topic 的 Topic 中, 被各个不同的下游系统所订阅:</p> <ul><li>支付系统: 只需订阅支付消息.</li> <li>物流系统: 只需订阅物流消息.</li> <li>交易成功率分析系统: 需订阅订单和支付消息.</li> <li>实时计算系统: 需要订阅所有和交易相关的消息.</li></ul> <p>过滤效果如下图所示:</p> <p>​<img src="/img/messagefilter-09e82bf396d7c4100ed742e8d0d2c185-20240422214351-ykzv7m7.png" alt="Tag过滤">​</p> <blockquote><p>Tag标签设置</p></blockquote> <ul><li>Tag 由生产者发送消息时设置, <strong>每条消息允许设置一个 Tag 标签</strong>.</li> <li>Tag 使用可见字符, 建议长度不超过 128 字符.</li></ul> <blockquote><p>Tag标签过滤规则</p></blockquote> <p>Tag 标签过滤为<strong>精准字符串匹配</strong>, 过滤规则设置格式如下:</p> <ul><li><strong>单 Tag 匹配</strong>: 过滤表达式为目标 Tag. 表示只有消息标签为指定目标 Tag 的消息符合匹配条件, 会被发送给消费者.</li> <li><strong>多 Tag 匹配</strong>: 多个 <strong>Tag 之间为或的关系</strong>, 不同 Tag 间使用两个竖线(||)隔开. 例如, <code>Tag1||Tag2||Tag3</code>​, 表示标签为 Tag1 或 Tag2 或 Tag3 的消息都满足匹配条件, 都会被发送给消费者进行消费.</li> <li><strong>全部匹配</strong>: 使用星号(*)作为全匹配表达式. 表示主题下的所有消息都将被发送给消费者进行消费.</li></ul> <blockquote><p>使用示例</p></blockquote> <p>发送消息, 设置 Tag 标签.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Message</span> message <span class="token operator">=</span> messageBuilder<span class="token punctuation">.</span><span class="token function">setTopic</span><span class="token punctuation">(</span><span class="token string">&quot;topic&quot;</span><span class="token punctuation">)</span>
<span class="token comment">// 设置消息索引键, 可根据关键字精确查找某条消息. </span>
<span class="token punctuation">.</span><span class="token function">setKeys</span><span class="token punctuation">(</span><span class="token string">&quot;messageKey&quot;</span><span class="token punctuation">)</span>
<span class="token comment">// 设置消息Tag, 用于消费端根据指定Tag过滤消息. </span>
<span class="token comment">// 该示例表示消息的Tag设置为&quot;TagA&quot;. </span>
<span class="token punctuation">.</span><span class="token function">setTag</span><span class="token punctuation">(</span><span class="token string">&quot;TagA&quot;</span><span class="token punctuation">)</span>
<span class="token comment">// 消息体. </span>
<span class="token punctuation">.</span><span class="token function">setBody</span><span class="token punctuation">(</span><span class="token string">&quot;messageBody&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>订阅消息, 匹配单个 Tag 标签.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> topic <span class="token operator">=</span> <span class="token string">&quot;Your Topic&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 只订阅消息标签为&quot;TagA&quot;的消息.</span>
<span class="token class-name">FilterExpression</span> filterExpression <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterExpression</span><span class="token punctuation">(</span><span class="token string">&quot;TagA&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FilterExpressionType</span><span class="token punctuation">.</span><span class="token constant">TAG</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pushConsumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> filterExpression<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>订阅消息, 匹配多个 Tag 标签.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> topic <span class="token operator">=</span> <span class="token string">&quot;Your Topic&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 只订阅消息标签为&quot;TagA&quot;, &quot;TagB&quot;或&quot;TagC&quot;的消息. </span>
<span class="token class-name">FilterExpression</span> filterExpression <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterExpression</span><span class="token punctuation">(</span><span class="token string">&quot;TagA||TagB||TagC&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FilterExpressionType</span><span class="token punctuation">.</span><span class="token constant">TAG</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pushConsumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> filterExpression<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>订阅消息, 匹配 Topic 中的所有消息, 不进行过滤.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> topic <span class="token operator">=</span> <span class="token string">&quot;Your Topic&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 使用Tag标签过滤消息, 订阅所有消息. </span>
<span class="token class-name">FilterExpression</span> filterExpression <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterExpression</span><span class="token punctuation">(</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FilterExpressionType</span><span class="token punctuation">.</span><span class="token constant">TAG</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pushConsumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> filterExpression<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h5 id="sql属性过滤"><a href="#sql属性过滤" class="header-anchor">#</a> SQL属性过滤</h5> <p>SQL 属性过滤是 RocketMQ 提供的高级消息过滤方式, 通过<strong>生产者为消息设置的属性(Key)及属性值(Value)进行匹配</strong>. 生产者在发送消息时可设置多个属性, 消费者订阅时可设置 SQL 语法的过滤表达式过滤多个属性.</p> <p>注意: Tag 是一种系统属性, 所以 SQL 过滤方式也兼容 Tag 标签过滤. 在 SQL 语法中, Tag 的属性名称为 TAGS.</p> <blockquote><p>使用场景示例</p></blockquote> <p>以下图电商交易场景为例, 从客户下单到收到商品这一过程会生产一系列消息, 按照类型将消息分为<strong>订单消息和物流消息</strong>, 其中给物流消息定义地域属性, 按照地域分为杭州和上海:</p> <ul><li><p>订单消息</p></li> <li><p>物流消息</p> <ul><li>物流消息且地域为杭州</li> <li>物流消息且地域为上海</li></ul></li></ul> <p>这些消息会发送到名称为 Trade_Topic 的 Topic 中, 被各个不同的系统所订阅:</p> <ul><li>物流系统 1: 只需订阅物流消息且消息地域为杭州.</li> <li>物流系统 2: 只需订阅物流消息且消息地域为杭州或上海.</li> <li>订单跟踪系统: 只需订阅订单消息.</li> <li>实时计算系统: 需要订阅所有和交易相关的消息.</li></ul> <p>过滤效果如下图所示:</p> <p>​<img src="/img/messagefilter2-dbf55cf4a63ac6d3b9c5f02603ce92ce-20240422214351-dmzc7k4.png" alt="sql过滤">​</p> <blockquote><p>消息属性设置</p></blockquote> <p>生产者发送消息时可以<strong>自定义消息属性, 每个属性都是一个自定义的键值对(Key-Value)</strong> . 每条消息支持设置多个属性.</p> <blockquote><p>SQL属性过滤规则</p></blockquote> <p>SQL 属性过滤使用 SQL92 语法作为过滤规则表达式, 语法规范如下:</p> <table><thead><tr><th>语法</th> <th>说明</th> <th>示例</th></tr></thead> <tbody><tr><td>IS NULL</td> <td>判断属性不存在.</td> <td>​<code>a IS NULL</code>​: 属性 a 不存在.</td></tr> <tr><td>IS NOT NULL</td> <td>判断属性存在.</td> <td>​<code>a IS NOT NULL</code>​: 属性 a 存在.</td></tr> <tr><td><em>&gt;</em>   &gt;=   <em>&lt;</em>   &lt;=</td> <td>用于比较数字, 不能用于比较字符串, 否则消费者客户端启动时会报错. <strong>说明</strong>可转化为数字的字符串也被认为是数字.</td> <td>​<code>a IS NOT NULL AND a &gt; 100</code>​: 属性 a 存在且属性 a 的值大于 100. <code>a IS NOT NULL AND a &gt; 'abc'</code>​: 错误示例, abc 为字符串, 不能用于比较大小.</td></tr> <tr><td>BETWEEN xxx AND xxx</td> <td>用于比较数字, 不能用于比较字符串, 否则消费者客户端启动时会报错. 等价于&gt;= xxx AND \&lt;= xxx. 表示属性值在两个数字之间.</td> <td>​<code>a IS NOT NULL AND (a BETWEEN 10 AND 100)</code>​: 属性 a 存在且属性 a 的值大于等于 10 且小于等于 100.</td></tr> <tr><td>NOT BETWEEN xxx AND xxx</td> <td>用于比较数字, 不能用于比较字符串, 否则消费者客户端启动会报错. 等价于\&lt; xxx OR &gt; xxx, 表示属性值在两个值的区间之外.</td> <td>​<code>a IS NOT NULL AND (a NOT BETWEEN 10 AND 100)</code>​: 属性 a 存在且属性 a 的值小于 10 或大于 100.</td></tr> <tr><td>IN (xxx, xxx)</td> <td>表示属性的值在某个集合内. 集合的元素只能是字符串.</td> <td>​<code>a IS NOT NULL AND (a IN ('abc', 'def'))</code>​: 属性 a 存在且属性 a 的值为 abc 或 def.</td></tr> <tr><td>=  &lt;&gt;</td> <td>等于和不等于. 可用于比较数字和字符串.</td> <td>​<code>a IS NOT NULL AND (a = 'abc' OR a&lt;&gt;'def')</code>​: 属性 a 存在且属性 a 的值为 abc 或 a 的值不为 def.</td></tr> <tr><td>AND OR</td> <td>逻辑与, 逻辑或. 可用于组合任意简单的逻辑判断, 需要将每个逻辑判断内容放入括号内.</td> <td>​<code>a IS NOT NULL AND (a &gt; 100) OR (b IS NULL)</code>​: 属性 a 存在且属性 a 的值大于 100 或属性 b 不存在.</td></tr></tbody></table> <p>由于 SQL 属性过滤是生产者定义消息属性, 消费者设置 SQL 过滤条件, 因此<strong>过滤条件的计算结果具有不确定性</strong>, 服务端的处理方式如下:</p> <ul><li><strong>异常情况处理</strong>: 如果过滤条件的表达式计算抛异常, 消息默认被过滤, 不会被投递给消费者. 例如比较数字和非数字类型的值.</li> <li><strong>空值情况处理</strong>: 如果过滤条件的表达式计算值为 null 或不是布尔类型(true和false), 则消息默认被过滤, 不会被投递给消费者. 例如发送消息时未定义某个属性, 在订阅时过滤条件中直接使用该属性, 则过滤条件的表达式计算结果为 null.</li> <li><strong>数值类型不符处理</strong>: 如果消息自定义属性为浮点型, 但过滤条件中使用整数进行判断, 则消息默认被过滤, 不会被投递给消费者.</li></ul> <blockquote><p>使用示例</p></blockquote> <p>发送消息, 同时设置消息 Tag 标签和自定义属性.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Message</span> message <span class="token operator">=</span> messageBuilder<span class="token punctuation">.</span><span class="token function">setTopic</span><span class="token punctuation">(</span><span class="token string">&quot;topic&quot;</span><span class="token punctuation">)</span>
<span class="token comment">// 设置消息索引键, 可根据关键字精确查找某条消息. </span>
<span class="token punctuation">.</span><span class="token function">setKeys</span><span class="token punctuation">(</span><span class="token string">&quot;messageKey&quot;</span><span class="token punctuation">)</span>
<span class="token comment">// 设置消息Tag, 用于消费端根据指定Tag过滤消息. </span>
<span class="token comment">// 该示例表示消息的Tag设置为&quot;messageTag&quot;. </span>
<span class="token punctuation">.</span><span class="token function">setTag</span><span class="token punctuation">(</span><span class="token string">&quot;messageTag&quot;</span><span class="token punctuation">)</span>
<span class="token comment">// 消息也可以设置自定义的分类属性, 例如环境标签, 地域, 逻辑分支. </span>
<span class="token comment">// 该示例表示为消息自定义一个属性, 该属性为地域, 属性值为杭州. </span>
<span class="token punctuation">.</span><span class="token function">addProperty</span><span class="token punctuation">(</span><span class="token string">&quot;Region&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Hangzhou&quot;</span><span class="token punctuation">)</span>
<span class="token comment">// 消息体. </span>
<span class="token punctuation">.</span><span class="token function">setBody</span><span class="token punctuation">(</span><span class="token string">&quot;messageBody&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>订阅消息, 根据单个自定义属性匹配消息.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> topic <span class="token operator">=</span> <span class="token string">&quot;topic&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 只订阅地域属性为杭州的消息. </span>
<span class="token class-name">FilterExpression</span> filterExpression <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterExpression</span><span class="token punctuation">(</span><span class="token string">&quot;Region IS NOT NULL AND Region='Hangzhou'&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FilterExpressionType</span><span class="token punctuation">.</span><span class="token constant">SQL92</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
simpleConsumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> filterExpression<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>订阅消息, 同时根据多个自定义属性匹配消息.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> topic <span class="token operator">=</span> <span class="token string">&quot;topic&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 只订阅地域属性为杭州且价格属性大于30的消息. </span>
<span class="token class-name">FilterExpression</span> filterExpression <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterExpression</span><span class="token punctuation">(</span><span class="token string">&quot;Region IS NOT NULL AND price IS NOT NULL AND Region = 'Hangzhou' AND price &gt; 30&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FilterExpressionType</span><span class="token punctuation">.</span><span class="token constant">SQL92</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
simpleConsumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> filterExpression<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>订阅消息, 匹配 Topic 中的所有消息, 不进行过滤.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> topic <span class="token operator">=</span> <span class="token string">&quot;topic&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 订阅所有消息. </span>
<span class="token class-name">FilterExpression</span> filterExpression <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterExpression</span><span class="token punctuation">(</span><span class="token string">&quot;True&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FilterExpressionType</span><span class="token punctuation">.</span><span class="token constant">SQL92</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
simpleConsumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> filterExpression<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h5 id="使用建议-13"><a href="#使用建议-13" class="header-anchor">#</a> 使用建议</h5> <blockquote><p>合理划分主题和Tag标签</p></blockquote> <p>从消息的过滤机制和主题的原理机制可以看出, <strong>业务消息的拆分可以基于主题进行筛选, 也可以基于主题内消息的 Tag 标签及属性进行筛选</strong>. 关于拆分方式的选择, 应遵循以下原则:</p> <ul><li><strong>消息类型是否一致</strong>: 不同类型的消息, 如顺序消息和普通消息需要使用不同的主题进行拆分, 无法通过 Tag 标签进行分类.</li> <li><strong>业务域是否相同</strong>: 不同业务域和部门的消息应该拆分不同的主题. 例如物流消息和支付消息应该使用两个不同的主题; 同样是一个主题内的物流消息, 普通物流消息和加急物流消息则可以通过不同的 Tag 进行区分.</li> <li><strong>消息量级和重要性是否一致</strong>: 如果消息的量级规模存在巨大差异, 或者说消息的链路重要程度存在差异, 则应该使用不同的主题进行隔离拆分.</li></ul> <h4 id="消费者负载均衡"><a href="#消费者负载均衡" class="header-anchor">#</a> 消费者负载均衡</h4> <h5 id="基础-7"><a href="#基础-7" class="header-anchor">#</a> 基础</h5> <p>消费者从 RocketMQ 获取消息消费时, 通过<strong>消费者负载均衡策略, 可将主题内的消息分配给指定消费者分组中的多个消费者共同分担, 提高消费并发能力和消费者的水平扩展能力</strong>. 本文介绍 RocketMQ <mark><strong>消费者的负载均衡策略</strong></mark>.</p> <p>了解消费者负载均衡策略, 可以帮助解决以下问题:</p> <ul><li><strong>消息消费处理的容灾策略</strong>: 可以根据消费者负载均衡策略, 明确当局部节点出现故障时, 消息如何进行消费重试和容灾切换.</li> <li><strong>消息消费的顺序性机制</strong>: 通过消费者负载均衡策略, 可以进一步了解消息消费时, 如何保证同一消息组内消息的先后顺序.</li> <li><strong>消息分配的水平拆分策略</strong>: 了解消费者负载均衡策略, 可以明确消息消费压力如何被分配到不同节点, 有针对性地进行流量迁移和水平扩缩容.</li></ul> <h5 id="广播消费和共享消费"><a href="#广播消费和共享消费" class="header-anchor">#</a> 广播消费和共享消费</h5> <p>在 RocketMQ 领域模型中, <strong>同一条消息支持被多个消费者分组订阅, 同时, 对于每个消费者分组可以初始化多个消费者</strong>.</p> <p>可以根据消费者分组和消费者的不同组合, 实现以下两种不同的消费效果:</p> <p>​<img src="/img/image-20240830232922-fx66jb1.png" alt="image">​</p> <ul><li><strong>消费组间广播消费</strong>: 如上图所示, <strong>每个消费者分组只初始化唯一一个消费者</strong>, 每个消费者可消费到消费者分组内所有的消息, 各消费者分组都订阅相同的消息, 以此实现单客户端级别的广播一对多推送效果. 该方式一般可用于<mark><strong>网关推送, 配置推送</strong></mark>等场景.</li> <li><strong>消费组内共享消费</strong>: 如上图所示, <strong>每个消费者分组下初始化了多个消费者</strong>, 这些消费者共同分担消费者分组内的所有消息, 实现消费者分组内流量的<strong>水平拆分和均衡负载</strong>. 该方式一般可用于<strong>微服务解耦</strong>场景.</li></ul> <h5 id="什么是消费者负载均衡"><a href="#什么是消费者负载均衡" class="header-anchor">#</a> 什么是消费者负载均衡</h5> <p>如上文所述, <strong>消费组间广播消费场景下, 每个消费者分组内只有一个消费者, 因此不涉及消费者的负载均衡</strong>.</p> <p>消费组内<strong>共享消费</strong>场景下, <strong>消费者分组内多个消费者共同分担消息, 消息按照哪种逻辑分配给哪个消费者, 就是由消费者负载均衡策略所决定的</strong>.</p> <p>根据消费者类型的不同, 消费者负载均衡策略分为以下两种模式:</p> <ul><li><strong>消息粒度负载均衡</strong>: PushConsumer 和 SimpleConsumer 默认负载策略.</li> <li><strong>队列粒度负载均衡</strong>: PullConsumer 默认负载策略.</li></ul> <h5 id="消息粒度负载均衡"><a href="#消息粒度负载均衡" class="header-anchor">#</a> 消息粒度负载均衡</h5> <p><mark><strong>消息粒度的负载均衡策略从 RocketMQ 服务端 5.0 版本开始支持, 历史版本 4.x/3.x 版本仅支持队列粒度的负载均衡策略</strong></mark>. 当使用的 RocketMQ 服务端版本为 5.x 版本时, 两种消费者负载均衡策略均支持, 具体生效的负载均衡策略依客户端版本和消费者类型而定.</p> <blockquote><p>使用范围</p></blockquote> <p>对于 PushConsumer 和 SimpleConsumer 类型的消费者, 默认且仅使用<strong>消息粒度负载均衡策略</strong>.</p> <p>上述说明是指 5.0 SDK 下, PushConsumer 默认使用消息粒度负载均衡, 对于 3.x/4.x 等 Remoting 协议 SDK 仍然使用了队列粒度负载均衡. 业务集成如无特殊需求, 建议使用新版本机制.</p> <blockquote><p>策略原理</p></blockquote> <p><mark><strong>消息粒度负载均衡策略中, 同一消费者分组内的多个消费者将按照消息粒度平均分摊主题中的所有消息, 即同一个队列中的消息, 可被平均分配给多个消费者共同消费</strong></mark>.</p> <p>​<img src="/img/image-20240830233412-1q1tily.png" alt="image">​</p> <p>如上图所示, 消费者分组 Group A 中有三个消费者 A1, A2 和 A3, 这<strong>三个消费者将共同消费主题中同一队列 Queue1 中的多条消息</strong>. 注意: 消息粒度负载均衡策略保证同一个队列的消息可以被多个消费者共同处理, 但是该策略使用的<mark><strong>消息分配算法结果是随机的, 并不能指定消息被哪一个特定的消费者处理</strong></mark>.</p> <p>消息粒度的负载均衡机制, 是基于内部的单条消息确认语义实现的. <strong>消费者获取某条消息后, 服务端会将该消息加锁, 保证这条消息对其他消费者不可见, 直到该消息消费成功或消费超时. 因此, 即使多个消费者同时消费同一队列的消息, 服务端也可保证消息不会被多个消费者重复消费</strong>.</p> <blockquote><p>顺序消息负载机制</p></blockquote> <p>在顺序消息中, 消息的顺序性指的是同一消息组内的多个消息之间的先后顺序. 因此, <strong>顺序消息场景下, 消息粒度负载均衡策略还需要保证同一消息组内的消息, 按照服务端存储的先后顺序进行消费. 不同消费者处理同一个消息组内的消息时, 会严格按照先后顺序锁定消息状态, 确保同一消息组的消息串行消费</strong>.</p> <p>​<img src="/img/image-20240830233943-smkwfww.png" alt="image">​</p> <p>如上图所述, 队列 Queue1 中有 4 条顺序消息, 这 4 条消息属于同一消息组 G1, 存储顺序由 M1 到 M4. 在消费过程中, 前面的消息 M1, M2 被消费者 Consumer A1 处理时, <strong>只要消费状态没有提交, 消费者 A2 是无法并行消费后续的 M3, M4 消息的, 必须等前面的消息提交消费状态后才能消费后面的消息</strong>.</p> <blockquote><p>策略特点</p></blockquote> <p>相对于队列粒度负载均衡策略, 消息粒度负载均衡策略有以下特点:</p> <ul><li><strong>消费分摊更均衡</strong>: 对于传统队列级的负载均衡策略, 如果队列数量和消费者数量不均衡, 则可能会出现部分消费者空闲, 或部分消费者处理过多消息的情况. 消息粒度负载均衡策略无需关注消费者和队列的相对数量, 能够更均匀地分摊消息.</li> <li><strong>对非对等消费者更友好</strong>: 在线上生产环境中, 由于网络机房分区延迟, 消费者物理资源规格不一致等原因, 消费者的处理能力可能会不一致, 如果按照队列分配消息, 则可能出现部分消费者消息堆积, 部分消费者空闲的情况. 消息粒度负载均衡策略按需分配, 消费者处理任务更均衡.</li> <li><strong>队列分配运维更方便</strong>: 传统基于绑定队列的负载均衡策略必须保证队列数量大于等于消费者数量, 以免产生部分消费者获取不到队列出现空转的情况, 而消息粒度负载均衡策略则无需关注队列数.</li></ul> <blockquote><p>适用场景</p></blockquote> <p>消息粒度消费负载均衡策略下, <strong>同一队列内的消息离散地分布于多个消费者, 适用于绝大多数在线事件处理的场景</strong>. 只需要基本的消息处理能力, 对消息之间没有批量聚合的诉求. 而对于流式处理, 聚合计算场景, 需要明确地对消息进行聚合, 批处理时, 更适合使用队列粒度的负载均衡策略.</p> <blockquote><p>使用示例</p></blockquote> <p><mark><strong>消息粒度负载均衡策略不需要额外设置, 对于 PushConsumer 和 SimpleConsumer 消费者类型默认启用</strong></mark>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">SimpleConsumer</span> simpleConsumer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 消费示例一: 使用PushConsumer消费普通消息, 只需要在消费监听器处理即可, 无需关注消息负载均衡. </span>
<span class="token class-name">MessageListener</span> messageListener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">ConsumeResult</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">MessageView</span> messageView<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>messageView<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 根据消费结果返回状态. </span>
        <span class="token keyword">return</span> <span class="token class-name">ConsumeResult</span><span class="token punctuation">.</span><span class="token constant">SUCCESS</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 消费示例二: 使用SimpleConsumer消费普通消息, 主动获取消息处理并提交. </span>
<span class="token comment">// 会按照订阅的主题自动获取, 无需关注消息负载均衡. </span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageView</span><span class="token punctuation">&gt;</span></span> messageViewList <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    messageViewList <span class="token operator">=</span> simpleConsumer<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    messageViewList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>messageView <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>messageView<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 消费处理完成后, 需要主动调用ACK提交消费结果. </span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            simpleConsumer<span class="token punctuation">.</span><span class="token function">ack</span><span class="token punctuation">(</span>messageView<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果遇到系统流控等原因造成拉取失败, 需要重新发起获取消息请求. </span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h5 id="队列粒度负载均衡"><a href="#队列粒度负载均衡" class="header-anchor">#</a> 队列粒度负载均衡</h5> <blockquote><p>使用范围</p></blockquote> <p>对于历史版本(服务端 4.x/3.x 版本)的消费者, 包括 PullConsumer, DefaultPushConsumer, DefaultPullConsumer, LitePullConsumer 等, 默认且仅能使用队列粒度负载均衡策略.</p> <blockquote><p>策略原理</p></blockquote> <p>队列粒度负载均衡策略中, <strong>同一消费者分组内的多个消费者将按照队列粒度消费消息, 即每个队列仅被一个消费者消费</strong>.</p> <p>​<img src="/img/image-20240830234246-5ixerx1.png" alt="image">​</p> <p>如上图所示, 主题中的三个队列 Queue1, Queue2, Queue3 被分配给消费者分组中的两个消费者, <strong>每个队列只能分配给一个消费者消费</strong>, 该示例中由于队列数大于消费者数, 因此, <strong>消费者 A2 被分配了两个队列. 若队列数小于消费者数量, 可能会出现部分消费者无绑定队列的情况</strong>.</p> <p>队列粒度的负载均衡, 基于队列数量, 消费者数量等运行数据进行统一的算法分配, 将每个队列绑定到特定的消费者, 然后每个消费者按照<strong>取消息 &gt; 提交消费位点 &gt; 持久化消费位点</strong>的消费语义处理消息, 取消息过程不提交消费状态, 因此, 为了避免消息被多个消费者重复消费, 每个队列仅支持被一个消费者消费.</p> <p>备注: 队列粒度负载均衡策略保证同一个队列仅被一个消费者处理, 该策略的实现依赖消费者和服务端的信息协商机制, RocketMQ 并不能保证协商结果完全强一致. 因此, <strong>在消费者数量, 队列数量发生变化时, 可能会出现短暂的队列分配结果不一致, 从而导致少量消息被重复处理</strong>.</p> <blockquote><p>策略特点</p></blockquote> <p>相对于消息粒度负载均衡策略, 队列粒度负载均衡策略<strong>分配粒度较大, 不够灵活</strong>. 但<strong>该策略在流式处理场景下有天然优势, 能够保证同一队列的消息被相同的消费者处理, 对于批量处理, 聚合处理更友好</strong>.</p> <blockquote><p>适用场景</p></blockquote> <p>队列粒度负载均衡策略<strong>适用于流式计算, 数据聚合等需要明确对消息进行聚合, 批处理的场景</strong>.</p> <blockquote><p>使用示例</p></blockquote> <p>队列粒度负载均衡策略不需要额外设置, 对于历史版本(服务端4.x/3.x版本)的消费者类型 PullConsumer 默认启用.</p> <p>具体示例代码, 请访问<a href="https://github.com/apache/rocketmq/blob/develop/example/src/main/java/org/apache/rocketmq/example/simple/LitePullConsumerAssign.java" target="_blank" rel="noopener noreferrer">RocketMQ代码库<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>获取.</p> <h5 id="使用建议-14"><a href="#使用建议-14" class="header-anchor">#</a> 使用建议</h5> <blockquote><p>针对消费逻辑做消息幂等</p></blockquote> <p><mark><strong>无论是消息粒度负载均衡策略还是队列粒度负载均衡策略, 在消费者上线或下线, 服务端扩缩容等场景下, 都会触发短暂的重新负载均衡动作. 此时可能会存在短暂的负载不一致情况, 出现少量消息重复的现象. 因此, 需要在下游消费逻辑中做好消息幂等去重处理</strong></mark>.</p> <h4 id="消费进度管理"><a href="#消费进度管理" class="header-anchor">#</a> 消费进度管理</h4> <p>RocketMQ 通过<strong>消费位点管理消费进度</strong>, 本文介绍 RocketMQ 的消费进度管理机制.</p> <p>RocketMQ 的生产者和消费者在进行消息收发时, 必然会涉及以下场景, <strong>消息先生产后订阅或先订阅后生产</strong>. 这两种场景下, 消费者客户端启动后从哪里开始消费? 如何标记已消费的消息? 这些都是由 RocketMQ 的消费进度管理机制来定义的.</p> <p>通过了解 RocketMQ 的消费进度管理机制, 可以解答以下问题:</p> <ul><li>消费者启动后从哪里开始消费消息?</li> <li>消费者每次消费成功后如何标记消息状态, 确保下次不会再重复处理该消息?</li> <li>某消息被指定消费者消费过一次后, 如果业务出现异常需要做故障恢复, 该消息能否被重新消费?</li></ul> <h5 id="消费进度原理"><a href="#消费进度原理" class="header-anchor">#</a> 消费进度原理</h5> <blockquote><p>消息位点(Offset)</p></blockquote> <p>参考 RocketMQ 主题和队列的定义, <strong>消息是按到达服务端的先后顺序存储在指定主题的多个队列中, 每条消息在队列中都有一个唯一的 Long 类型坐标, 这个坐标被定义为</strong>​<mark><strong>消息位点</strong></mark>.</p> <p><strong>任意一个消息队列在逻辑上都是无限存储, 即消息位点会从 0 到 Long.MAX 无限增加</strong>. 通过主题, 队列和位点就可以定位任意一条消息的位置, 具体关系如下图所示:</p> <p><img src="/img/image-20240825210515-6zmvhe7.png" alt="image"></p> <p><strong>RocketMQ 定义队列中最早一条消息的位点为最小消息位点(MinOffset); 最新一条消息的位点为最大消息位点(MaxOffset)</strong> . 虽然消息队列逻辑上是无限存储, 但由于服务端物理节点的存储空间有限, RocketMQ 会<strong>滚动删除队列中存储最早的消息</strong>. 因此, <strong>消息的最小消费位点和最大消费位点会一直递增变化</strong>.</p> <p><img src="/img/image-20240825211501-wadrlsi.png" alt="image"></p> <blockquote><p>消费位点(ConsumerOffset)</p></blockquote> <p>RocketMQ 领域模型为发布订阅模式, <strong>每个主题的队列都可以被多个消费者分组订阅. 若某条消息被某个消费者消费后直接被删除, 则其他订阅了该主题的消费者将无法消费该消息</strong>.</p> <p>因此, RocketMQ 通过消费位点管理消息的消费进度. <strong>每条消息被某个消费者消费完成后不会立即在队列中删除, RocketMQ 会基于每个消费者分组维护一份消费记录, 该记录指定消费者分组消费某一个队列时, 消费过的最新一条消息的位点, 即消费位点</strong>.</p> <p><strong>当消费者客户端离线, 又再次重新上线时, 会严格按照服务端保存的消费进度继续处理消息. 如果服务端保存的历史位点信息已过期被删除, 此时消费位点向前移动至服务端存储的最小位点</strong>.</p> <p><strong>消费位点的保存和恢复是基于 RocketMQ 服务端的存储实现, 和任何消费者无关</strong>. 因此 RocketMQ 支持跨消费者的消费进度恢复.</p> <p>队列中消息位点 MinOffset, MaxOffset 和每个消费者分组的消费位点 ConsumerOffset 的关系如下:</p> <p><img src="/img/image-20240825211515-ezfa5lq.png" alt="image"></p> <ul><li><p>​<code>ConsumerOffset ≤ MaxOffset</code>​:</p> <ul><li>当消费速度和生产速度一致, 且全部消息都处理完成时, 最大消息位点和消费位点相同, 即ConsumerOffset = MaxOffset.</li> <li>当消费速度较慢小于生产速度时, 队列中会有部分消息未消费, 此时<strong>消费位点小于最大消息位点</strong>, 即ConsumerOffset &lt; MaxOffset, 两者之差就是该队列中<strong>堆积的消息量</strong>.</li></ul></li> <li><p>​<code>ConsumerOffset ≥ MinOffset</code>​: 正常情况下有效的消费位点 ConsumerOffset 必然大于等于最小消息位点 MinOffset. 消费位点小于最小消息位点时是无效的, <strong>相当于消费者要消费的消息已经从队列中删除了, 是无法消费到的, 此时服务端会将消费位点强制纠正到合法的消息位点</strong>.</p></li></ul> <p><mark><strong>每个消费组在每个队列上维护一个消费位点(ConsumerOffset), 因为在发布订阅模式中一般会涉及到多个消费者组, 而每个消费者组在每个队列中的消费位置都是不同的</strong></mark>. 如果此时有多个消费者组, 那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要), 它仅仅是为每个消费者组维护一个<strong>消费位点</strong>, 每次消费者组消费完会返回一个成功的响应, 然后队列再把维护的消费位移加一, 这样就不会出现刚刚消费过的消息再一次被消费了.</p> <p>​<img src="/img/image-20240829222216-3qe4uml.png" alt="image">​</p> <p>所以总结来说, RocketMQ 通过使用在一个 <strong>Topic 中配置多个队列并且每个队列维护每个消费者组的消费位置</strong> 实现了主题模式/发布订阅模式.</p> <blockquote><p>消费位点初始值</p></blockquote> <p>消费位点初始值指的是<strong>消费者分组首次启动消费者消费消息时, 服务端保存的消费位点的初始值</strong>.</p> <p>RocketMQ <strong>定义消费位点的初始值为消费者首次获取消息时, 该时刻队列中的最大消息位点.</strong> <mark><strong>相当于消费者将从队列中最新的消息开始消费</strong></mark>.</p> <blockquote><p>新创建的ConsumerGroup从哪里开始消费消息?</p></blockquote> <p>5.x SDK, <mark><strong>在首次上线时会从服务器中的最新消息开始消费, 也就是从队列的尾部开始消费; 再次重新启动后, 会从最后一次的消费位置继续消费</strong></mark>.</p> <h5 id="重置消费位点-回溯消费"><a href="#重置消费位点-回溯消费" class="header-anchor">#</a> 重置消费位点(回溯消费)</h5> <p>若消费者分组的初始消费位点或当前消费位点不符合业务预期, 可以通过<strong>重置消费位点调整消费进度</strong>.</p> <p>回溯消费是指<strong>已经消费成功</strong>的消息, 由于业务上需求需要<strong>重新消费</strong>. 在 RocketMQ 中, Broker 在向 Consumer 投递成功消息后, <strong>消息仍然需要保留</strong>. 并且重新消费一般是按照<strong>时间维度</strong>, 例如由于 Consumer 系统故障, 恢复后需要重新消费 <strong>1 小时前</strong>的数据, 那么 Broker 要提供一种机制, 可以按照时间维度来回退消费进度. <strong>RocketMQ 支持按照时间回溯消费, 时间维度精确到毫秒.</strong></p> <blockquote><p>适用场景</p></blockquote> <ul><li><strong>初始消费位点不符合需求</strong>: 因初始消费位点为当前队列的最大消息位点, 即客户端会直接从最新消息开始消费. 若业务上线时需要消费部分历史消息, 可以通过<strong>重置消费位点功能消费到指定时刻前的消息</strong>.</li> <li><strong>消费堆积快速清理</strong>: 当下游消费系统性能不足或消费速度小于生产速度时, 会<strong>产生大量堆积消息</strong>. 若这部分堆积消息可以丢弃, 可以通过重置消费位点快速将消费位点更新到指定位置, <strong>绕过这部分堆积的消息</strong>, 减少下游处理压力.</li> <li><strong>业务回溯, 纠正处理</strong>: 由于业务消费逻辑出现异常, 消息被错误处理. 若希望重新消费这些已被处理的消息, 可以通过重置消费位点快速将消费位点更新到历史指定位置, 实现<strong>消费回溯</strong>.</li></ul> <blockquote><p>重置功能</p></blockquote> <p>RocketMQ 的重置消费位点提供以下能力:</p> <ul><li><strong>重置到队列中的指定位点</strong>.</li> <li><strong>重置到某一时刻对应的消费位点, 匹配位点时, 服务端会根据自动匹配到该时刻最接近的消费位点</strong>.</li></ul> <blockquote><p>使用限制</p></blockquote> <ul><li>重置消费位点后消费者将直接从重置后的位点开始消费, 对于回溯重置类场景, <strong>重置后的历史消息大多属于存储冷数据, 可能会造成系统压力上升, 一般称为冷读现象</strong>. 因此, 需要谨慎评估重置消费位点后的影响. 建议严格控制重置消费位点接口的调用权限, 避免无意义, 高频次的消费位点重置.</li> <li>重置消费位点功能<strong>只能重置对消费者可见的消息, 不能重置定时中, 重试等待中的消息</strong>.</li></ul> <h5 id="消息堆积问题"><a href="#消息堆积问题" class="header-anchor">#</a> 消息堆积问题</h5> <p>消息队列一个很重要的功能是<strong>削峰</strong>, 但峰值太大可能造成导致消息堆积在队列中. 产生消息堆积的根源其实就只有两个: <strong>生产者生产太快或消费者消费太慢</strong>.</p> <p>可以从多个角度去思考解决这个问题, 当流量到峰值的时候是因为<strong>生产者生产太快</strong>, 可以使用一些<strong>限流降级</strong>的方法, 当然也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增. 如果<strong>消费者消费过慢</strong>的话, 可以先检查<strong>是否是消费者出现了大量的消费错误</strong>, 或者判断是否出现线程卡死或者锁资源不释放等问题.</p> <p>通常解决消息堆积问题的方法还是<strong>增加消费者实例</strong>. 对于 4.X 版本的 RocketMQ, 同时还需要增加每个主题的队列数量, 因为一个队列只会被一个消费者消费. 对于 5.X 版本的 RocketMQ, 已经支持消息粒度的负载均衡, 所以只需要增加消费者即可. 此外, 在性能支持的情况下, 还可以<strong>提高消费者的线程数来提高消费并行度</strong>.</p> <h5 id="使用建议-15"><a href="#使用建议-15" class="header-anchor">#</a> 使用建议</h5> <blockquote><p>严格控制消费位点重置的权限</p></blockquote> <p><strong>重置消费位点会给系统带来额外处理压力, 可能会影响新消息的读写性能</strong>. 因此该操作请在适用场景下<strong>谨慎执行</strong>, 并提前做好合理性和必要性评估.</p> <h4 id="消费重试"><a href="#消费重试" class="header-anchor">#</a> 消费重试</h4> <h5 id="基础-8"><a href="#基础-8" class="header-anchor">#</a> 基础</h5> <p><strong>消费者出现异常, 消费某条消息失败时, RocketMQ 会根据消费重试策略重新投递该消息进行故障恢复</strong>. 本文介绍消费重试机制的原理, 版本兼容性和使用建议.</p> <p>RocketMQ 的消费重试主要<strong>解决的是业务处理逻辑失败导致的消费完整性问题, 是一种为业务兜底的策略, 不应该被用做业务流程控制</strong>. 建议以下消费失败场景使用重试机制:</p> <p>推荐使用消息重试场景如下:</p> <ul><li><strong>业务处理失败, 且失败原因跟当前的消息内容相关</strong>, 比如该消息对应的事务状态还未获取到, 预期一段时间后可执行成功.</li> <li><strong>消费失败的原因不会导致连续性, 即当前消息消费失败是一个小概率事件, 不是常态化的失败, 后面的消息大概率会消费成功</strong>. 此时可以对当前消息进行重试, 避免进程阻塞.</li></ul> <p>典型错误使用场景如下:</p> <ul><li>消费处理逻辑中<strong>使用消费失败来做条件判断的结果分流</strong>, 是不合理的, 因为处理逻辑已经预见了一定会大量出现该判断分支.</li> <li>消费处理中使<strong>用消费失败来做处理速率限流, 是不合理的</strong>. 限流的目的是将超出流量的消息暂时堆积在队列中达到削峰的作用, 而不是让消息进入重试链路.</li></ul> <p>消息中间件做异步解耦时的一个典型问题是如果下游服务处理消息事件失败, 如何保证整个调用链路的完整性. RocketMQ 作为金融级的可靠业务消息中间件, 在消息投递处理机制的设计上天然支持可靠传输策略, <strong>通过完整的确认和重试机制保证每条消息都按照业务的预期被处理</strong>.</p> <p>了解 RocketMQ 的消息确认机制以及消费重试策略可以分析如下问题:</p> <ul><li><strong>如何保证业务完整处理消息</strong>: 了解消费重试策略, 可以在设计实现消费者逻辑时<strong>保证每条消息处理的完整性, 避免部分消息出现异常时被忽略, 导致业务状态不一致</strong>.</li> <li><strong>系统异常时处理中的消息状态如何恢复</strong>: 帮助了解当系统出现异常(宕机故障)等场景时, 处理中的消息状态如何恢复, 是否会出现状态不一致.</li></ul> <h5 id="消费重试策略概述"><a href="#消费重试策略概述" class="header-anchor">#</a> 消费重试策略概述</h5> <p>消费重试指的是, <strong>消费者在消费某条消息失败后, RocketMQ 服务端会根据重试策略重新消费该消息, 超过一次定数后若还未消费成功, 则该消息将不再继续重试, 直接被发送到</strong>​<mark><strong>死信队列</strong></mark>​<strong>中</strong>.</p> <blockquote><p>消息重试的触发条件</p></blockquote> <ul><li><strong>消费失败, 包括消费者返回消息失败状态标识或抛出非预期异常</strong>.</li> <li><strong>消息处理超时</strong>, 包括在 PushConsumer 中排队超时.</li></ul> <blockquote><p>消息重试策略主要行为</p></blockquote> <ul><li><strong>重试过程状态机</strong>: 控制消息在重试流程中的状态和变化逻辑.</li> <li><strong>重试间隔</strong>: 上一次消费失败或超时后, 下次重新尝试消费的间隔时间.</li> <li><strong>最大重试次数</strong>: 消息可被重试消费的最大次数.</li></ul> <blockquote><p>消息重试策略差异</p></blockquote> <p>根据<strong>消费者类型</strong>不同, 消息重试策略的具体内部机制和设置方法有所不同, 具体差异如下:</p> <table><thead><tr><th>消费者类型</th> <th>重试过程状态机</th> <th>重试间隔</th> <th>最大重试次数</th></tr></thead> <tbody><tr><td>PushConsumer</td> <td>已就绪 处理中 待重试 提交 死信</td> <td>消费者分组创建时元数据控制. <strong>无序消息</strong>: 阶梯间隔  <strong>顺序消息</strong>: 固定间隔时间</td> <td>消费者分组创建时的元数据控制.</td></tr> <tr><td>SimpleConsumer</td> <td>已就绪 处理中 提交 死信</td> <td>通过 API 修改获取消息时的不可见时间.</td> <td>消费者分组创建时的元数据控制.</td></tr></tbody></table> <p>具体的重试策略, 请参见下文 PushConsumer 消费重试策略和 SimpleConsumer 消费重试策略.</p> <h5 id="pushconsumer消费重试策略"><a href="#pushconsumer消费重试策略" class="header-anchor">#</a> PushConsumer消费重试策略</h5> <blockquote><p>重试状态机</p></blockquote> <p>PushConsumer 消费消息时, 消息的几个主要状态如下:</p> <p><img src="/img/retrymachinestatus-37ddbd0a20b8736e34bb88f565945d16-20240422214454-rbkyt52.png" alt="Push消费状态机"></p> <ul><li><strong>Ready: 已就绪状态</strong>. 消息在 RocketMQ 服务端已就绪, 可以被消费者消费.</li> <li><strong>Inflight: 处理中状态</strong>. 消息被消费者客户端获取, 处于消费中还未返回消费结果的状态.</li> <li><strong>WaitingRetry: 待重试状态, PushConsumer 独有的状态</strong>. 当消费者消息处理失败或消费超时, 会触发消费重试逻辑判断. 如果当前重试次数未达到最大次数, 则该<strong>消息变为待重试状态, 经过重试间隔后, 消息将重新变为已就绪状态可被重新消费</strong>. 多次重试之间, 可通过<mark><strong>重试间隔进行延长, 防止无效高频的失败</strong></mark>.</li> <li><strong>Commit: 提交状态</strong>. 消费成功的状态, 消费者返回成功响应即可结束消息的状态机.</li> <li><strong>DLQ: 死信状态</strong>. 消费逻辑的最终兜底机制, <strong>若消息一直处理失败并不断进行重试, 直到超过最大重试次数还未成功, 此时消息不会再重试, 会被投递至死信队列</strong>. 可以通过消费死信队列的消息进行业务恢复.</li></ul> <p>消息重试过程中, 每次重试消息状态都会经过<strong>已就绪 &gt; 处理中 &gt; 待重试</strong>的变化, 两次消费间的间隔时间实际由消费耗时及重试间隔控制, 消费耗时的最大上限受服务端系统参数控制, 一般不应该超过上限时间.</p> <p>​<img src="/img/retrytimeline-27247ef53fbcf08c745b9f7d356de6f9-20240422214454-m5ttq5q.png" alt="消息间隔时间">​</p> <blockquote><p>最大重试次数</p></blockquote> <p>PushConsumer 的最大重试次数由<strong>消费者分组创建时的元数据控制</strong>.</p> <p>例如, 最大重试次数为 3 次, 则该消息最多可被投递 4 次, 1 次为原始消息, 3 次为重试投递次数.</p> <blockquote><p>重试间隔时间</p></blockquote> <p><strong>无序消息(非顺序消息)</strong> : 重试间隔为阶梯时间, 具体时间如下:</p> <table><thead><tr><th style="text-align:center;">第几次重试</th> <th style="text-align:center;">与上次重试的间隔时间</th> <th style="text-align:center;">第几次重试</th> <th style="text-align:center;">与上次重试的间隔时间</th></tr></thead> <tbody><tr><td style="text-align:center;">1</td> <td style="text-align:center;">10秒</td> <td style="text-align:center;">9</td> <td style="text-align:center;">7分钟</td></tr> <tr><td style="text-align:center;">2</td> <td style="text-align:center;">30秒</td> <td style="text-align:center;">10</td> <td style="text-align:center;">8分钟</td></tr> <tr><td style="text-align:center;">3</td> <td style="text-align:center;">1分钟</td> <td style="text-align:center;">11</td> <td style="text-align:center;">9分钟</td></tr> <tr><td style="text-align:center;">4</td> <td style="text-align:center;">2分钟</td> <td style="text-align:center;">12</td> <td style="text-align:center;">10分钟</td></tr> <tr><td style="text-align:center;">5</td> <td style="text-align:center;">3分钟</td> <td style="text-align:center;">13</td> <td style="text-align:center;">20分钟</td></tr> <tr><td style="text-align:center;">6</td> <td style="text-align:center;">4分钟</td> <td style="text-align:center;">14</td> <td style="text-align:center;">30分钟</td></tr> <tr><td style="text-align:center;">7</td> <td style="text-align:center;">5分钟</td> <td style="text-align:center;">15</td> <td style="text-align:center;">1小时</td></tr> <tr><td style="text-align:center;">8</td> <td style="text-align:center;">6分钟</td> <td style="text-align:center;">16</td> <td style="text-align:center;">2小时</td></tr></tbody></table> <p>若重试次数超过 16 次, 后面每次重试间隔都为 2 小时.</p> <p><strong>顺序消息</strong>: 重试间隔为固定时间 3000ms.</p> <blockquote><p>使用示例</p></blockquote> <p>PushConsumer 触发消息重试只需要<strong>返回消费失败的状态码</strong>即可, 当出现非预期的异常时, 也会被 SDK 捕获.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">SimpleConsumer</span> simpleConsumer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 消费示例: 使用PushConsumer消费普通消息, 如果消费失败返回错误, 即可触发重试. </span>
<span class="token class-name">MessageListener</span> messageListener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">ConsumeResult</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">MessageView</span> messageView<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>messageView<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 返回消费失败, 会自动重试, 直至到达最大重试次数. </span>
        <span class="token keyword">return</span> <span class="token class-name">ConsumeResult</span><span class="token punctuation">.</span><span class="token constant">FAILURE</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h5 id="simpleconsumer消费重试策略"><a href="#simpleconsumer消费重试策略" class="header-anchor">#</a> SimpleConsumer消费重试策略</h5> <blockquote><p>重试状态机</p></blockquote> <p>SimpleConsumer 消费消息时, 消息的几个主要状态如下:</p> <p><img src="/img/simplemachinestatus-1844bd0115b315e32661cf20b1732db0-20240422214454-0gyb4cb.png" alt="SimpleConsumer状态机"></p> <ul><li><strong>Ready: 已就绪状态</strong>. 消息在 RocketMQ 服务端已就绪, 可以被消费者消费.</li> <li><strong>Inflight: 处理中状态</strong>. 消息被消费者客户端获取, 处于消费中还未返回消费结果的状态.</li> <li><strong>Commit: 提交状态</strong>. 消费成功的状态, 消费者返回成功响应即可结束消息的状态机.</li> <li><strong>DLQ: 死信状态</strong>. 消费逻辑的最终兜底机制, 若消息一直处理失败并不断进行重试, 直到超过最大重试次数还未成功, 此时消息不会再重试, 会被投递至死信队列. 可以通过消费死信队列的消息进行业务恢复.</li></ul> <p>和 PushConsumer 消费重试策略不同的是, SimpleConsumer 消费者的<strong>重试间隔是预分配的</strong>, 每次获取消息消费者会在调用 API 时设置一个不可见时间参数 InvisibleDuration, 即消息的最大处理时长. 若消息消费失败触发重试, <strong>不需要设置下一次重试的时间间隔, 直接复用不可见时间参数的取值</strong>.</p> <p>​<img src="/img/simpletimeline-130218b5dca33422638d2ee6409a8330-20240422214454-xrcwhjj.png" alt="simpleconsumer重试">​</p> <p>由于不可见时间为预分配的, 可能和实际业务中的消息处理时间差别较大, 可以通过 API 接口修改不可见时间.</p> <p>例如, 预设消息处理耗时最多 20 ms, 但实际业务中 20 ms 内消息处理不完, 可以修改消息不可见时间, 延长消息处理时间, 避免消息触发重试机制.</p> <p>修改消息不可见时间需要满足以下条件:</p> <ul><li>消息处理未超时</li> <li>消息处理未提交消费状态</li></ul> <p>如下图所示, 消息不可见时间修改后立即生效, 即从调用 API 时刻开始, 重新计算消息不可见时间.</p> <p><img src="/img/changeInvisibletime-769fd45237e26f2ff333ee1149e66d47-20240422214454-l35irdz.png" alt="修改不可见时间"></p> <blockquote><p>最大重试次数</p></blockquote> <p>SimpleConsumer 的最大重试次数由消费者分组创建时的元数据控制, 具体参数参见<a href="https://rocketmq.apache.org/zh/docs/domainModel/07consumergroup" target="_blank" rel="noopener noreferrer">消费者分组<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <blockquote><p>消息重试间隔</p></blockquote> <p>消息重试间隔 = 不可见时间 - 消息实际处理时长</p> <p>SimpleConsumer 的消费重试间隔通过消息的不可见时间控制. 例如, 消息不可见时间为 30 ms, 实际消息处理用了 10 ms 就返回失败响应, 则距下次消息重试还需要 20 ms, 此时的消息重试间隔即为 20 ms; 若直到 30 ms 消息还未处理完成且未返回结果, 则消息超时, 立即重试, 此时重试间隔即为 0 ms.</p> <blockquote><p>使用示例</p></blockquote> <p>SimpleConsumer 触发消息重试只需要等待即可.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code> <span class="token comment">// 消费示例: 使用SimpleConsumer消费普通消息, 如果希望重试, 只需要静默等待超时即可, 服务端会自动重试. </span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageView</span><span class="token punctuation">&gt;</span></span> messageViewList <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    messageViewList <span class="token operator">=</span> simpleConsumer<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    messageViewList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>messageView <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>messageView<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果处理失败, 希望服务端重试, 只需要忽略即可, 等待消息再次可见后即可重试获取. </span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果遇到系统流控等原因造成拉取失败, 需要重新发起获取消息请求. </span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h5 id="使用建议-16"><a href="#使用建议-16" class="header-anchor">#</a> 使用建议</h5> <blockquote><p>合理重试, 避免因限流等诉求触发消费重试</p></blockquote> <p>前面应用场景中提到, <strong>消息重试适用业务处理失败且当前消费为小概率事件的场景, 不适合在连续性失败的场景下使用, 例如消费限流场景</strong>.</p> <ul><li>错误示例: 如果当前消费速度过高触发限流, 则返回消费失败, 等待下次重新消费.</li> <li>正确示例: <strong>如果当前消费速度过高触发限流, 则延迟获取消息, 稍后再消费</strong>.</li></ul> <blockquote><p>合理控制重试次数, 避免无限重试</p></blockquote> <p>虽然 RocketMQ 支持自定义消费重试次数, 但是<strong>建议通过减少重试次数 + 延长重试间隔来降低系统压力</strong>, 避免出现无限重试或大量重试的情况.</p> <h5 id="最佳实践-2"><a href="#最佳实践-2" class="header-anchor">#</a> 最佳实践</h5> <blockquote><p>当消费失败的时候如何重新消费消息?</p></blockquote> <p>在集群模式下, 消费的业务逻辑代码会返回消费失败状态, 或者抛出异常, 如果一条消息消费失败, 则会按照设置的最大重试次数<strong>重试</strong>, 之后该消息会被<strong>丢弃</strong>.</p> <p>在广播消费模式下, 广播消费仍然保证消息至少被消费一次, 但不提供重发的选项.</p> <blockquote><p>当消费失败的时候如何找到失败的消息?</p></blockquote> <p>使用<strong>按时间的主题查询</strong>, 可以查询到一段时间内的消息.</p> <p>使用<strong>主题和消息 ID 来准确查询</strong>消息.</p> <p>使用<strong>主题和消息的 Key 来准确查询</strong>所有消息 Key 相同的消息.</p> <h4 id="消息存储和清理机制"><a href="#消息存储和清理机制" class="header-anchor">#</a> 消息存储和清理机制</h4> <h5 id="基础-9"><a href="#基础-9" class="header-anchor">#</a> 基础</h5> <p>本文介绍 RocketMQ 中消息的存储机制, 包括消息的存储粒度, 判断依据及后续处理策略等.</p> <p>参考 RocketMQ 中队列的定义, 消息按照达到服务器的先后顺序被存储到队列中, <strong>理论上每个队列都支持无限存储</strong>.</p> <p>但是在实际部署场景中, <strong>服务端节点的物理存储空间有限, 消息无法做到永久存储</strong>. 因此, 在实际使用中需要考虑以下问题, <strong>消息在服务端中的存储以什么维度为判定条件? 消息存储以什么粒度进行管理? 消息存储超过限制后如何处理? 这些问题都是由消息存储和过期清理机制来定义的</strong>.</p> <p>了解消息存储和过期清理机制, 可以从以下方面更好的进行运维管理:</p> <ul><li>提供消息存储时间 SLA, 为业务提供安全冗余空间: 消息存储时间的承诺本质上代表业务侧可以自由获取消息的时间范围. 对于消费时间长, 消息堆积, 故障恢复等场景非常关键.</li> <li>评估和控制存储成本: RocketMQ 消息一般存储于磁盘介质上, 可以通过存储机制评估消息存储空间, 提前预留存储资源.</li></ul> <h5 id="消息存储机制"><a href="#消息存储机制" class="header-anchor">#</a> 消息存储机制</h5> <blockquote><p>原理机制</p></blockquote> <p><strong>RocketMQ 使用</strong>​<mark><strong>存储时长</strong></mark>​<strong>作为消息存储的依据, 即每个节点对外承诺消息的存储时长. 在存储时长范围内的消息都会被保留, 无论消息是否被消费; 超过时长限制的消息则会被清理掉</strong>.</p> <p>消息存储机制主要定义以下关键问题:</p> <ul><li><strong>消息存储管理粒度</strong>: RocketMQ 按存储节点管理<strong>消息的存储时长</strong>, 并不是按照主题或队列粒度来管理.</li> <li><strong>消息存储判断依据</strong>: 消息存储按照存储时间作为判断依据, 相对于消息数量, 消息大小等条件, 使用存储时间作为判断依据, 更利于业务方对消息数据的价值进行评估.</li> <li><strong>消息存储和是否消费状态无关</strong>: RocketMQ 的消息存储是按照消息的生产时间计算, 和消息是否被消费无关. 按照统一的计算策略可以有效地简化存储机制.</li></ul> <p>消息在队列中的存储情况如下:</p> <p><img src="/img/image-20240825211913-g3o2fjg.png" alt="image"></p> <blockquote><p>消息存储管理粒度说明</p></blockquote> <p>RocketMQ 按照<strong>服务端节点粒度管理存储时长而非队列或主题</strong>, 原因如下:</p> <ul><li><strong>消息存储优势权衡</strong>: RocketMQ 基于统一的物理日志队列和轻量化逻辑队列的二级组织方式, 管理物理数据. 这种机制可以带来<strong>顺序读写, 高吞吐, 高性能</strong>等优势, 但缺点是不支持按主题和队列单独管理.</li> <li><strong>安全生产和容量保障风险要求</strong>: 即使 RocketMQ 按照主题或者队列独立生成存储文件, 但存储层本质还是共享存储介质. 单独根据主题或队列控制存储时长, 这种方式看似更灵活, 但实际上整个集群仍然存在容量风险, 可能会导致存储时长 SLA 被打破. 从安全生产角度考虑, 最合理的方式是将不同存储时长的消息通过不同集群进行分离治理.</li></ul> <blockquote><p>消息存储和消费状态关系说明</p></blockquote> <p>RocketMQ <strong>统一管理消息的存储时长, 无论消息是否被消费</strong>.</p> <p><mark><strong>当消费者不在线或消息消费异常时, 会造成队列中大量消息堆积, 且该现象暂时无法有效控制. 若此时按照消费状态考虑将未消费的消息全部保留, 则很容易导致存储空间不足, 进而影响到新消息的读写速度</strong></mark>.</p> <p>根据统一地存储时长管理消息, 可以帮助消费者业务清晰地判断每条消息的生命周期. 只要消息在有效期内可以随时被消费, 或通过重置消费位点功能使消息可被消费多次.</p> <blockquote><p>消息存储文件结构说明</p></blockquote> <p>RocketMQ 消息<strong>默认存储在本地磁盘文件中</strong>, 存储文件的根目录由配置参数 storePathRootDir 决定, 存储结构如下图所示, 其中 <strong>commitlog 文件夹存储消息物理文件, consumeCQueue文件夹存储逻辑队列索引</strong>, 其他文件的详细作用可以参考代码解析.</p> <p><img src="/img/store-2eb2d519dd4030480ca3ea63f2dc1b70-20240422214502-qg8m0bs.jpg" alt="消息存储"></p> <h5 id="消息过期清理机制"><a href="#消息过期清理机制" class="header-anchor">#</a> 消息过期清理机制</h5> <p>在 RocketMQ 中, 消息保存时长并不能完整控制消息的实际保存时间, 因为消息存储仍然使用本地磁盘, <strong>本地磁盘空间不足时, 为保证服务稳定性消息仍然会被强制清理, 导致消息的实际保存时长小于设置的保存时长</strong>.</p> <blockquote><p>消息在服务器上可以保存多长时间?</p></blockquote> <p><strong>存储的消息将最多保存 3 天, 超过 3 天未使用的消息将被删除</strong>.</p> <h5 id="使用建议-17"><a href="#使用建议-17" class="header-anchor">#</a> 使用建议</h5> <blockquote><p>消息存储时长建议适当增加</p></blockquote> <p>RocketMQ 按存储时长统一控制消息是否保留. 建议在存储成本可控的前提下, <strong>尽可能延长消息存储时长</strong>. 延长消息存储时长, 可以为紧急故障恢复, 应急问题排查和消息回溯带来更多的可操作空间.</p> <h4 id="最佳实践-3"><a href="#最佳实践-3" class="header-anchor">#</a> 最佳实践</h4> <h5 id="生产者"><a href="#生产者" class="header-anchor">#</a> 生产者</h5> <h6 id="发送消息注意事项"><a href="#发送消息注意事项" class="header-anchor">#</a> 发送消息注意事项</h6> <blockquote><p>Tag的使用</p></blockquote> <p><mark><strong>一个应用尽可能用一个 Topic, 而消息子类型则可以用 tags 来标识</strong></mark>. tags 可以由应用自由设置, 只有生产者在发送消息设置了 tags, 消费方在订阅消息时才可以利用 tags 通过 broker 做消息过滤, 5.x SDK 可以调用messageBuilder.setTag(&quot;messageTag&quot;), 历史版本可以调用 message.setTags(&quot;messageTag&quot;).</p> <blockquote><p>Keys的使用</p></blockquote> <p><strong>每个消息在业务层面一般建议映射到业务的唯一标识并设置到 keys 字段, 方便将来定位消息丢失问题</strong>. 服务器会为每个消息创建索引(哈希索引), 应用可以通过 topic, key 来查询这条消息内容, 以及消息被谁消费. 由于是哈希索引, 请<strong>务必保证 key 尽可能唯一, 这样可以避免潜在的哈希冲突</strong>. 常见的设置策略使用订单 Id, 用户 Id, 请求 Id 等比较离散的唯一标识来处理.</p> <blockquote><p>日志的打印</p></blockquote> <p><strong>消息发送成功或者失败要打印消息日志, 用于业务排查问题</strong>. Send 消息方法只要不抛异常, 就代表发送成功.</p> <h6 id="消息发送失败处理方式"><a href="#消息发送失败处理方式" class="header-anchor">#</a> 消息发送失败处理方式</h6> <p>Producer 的 send 方法本身支持内部重试, 5.x SDK 的重试逻辑参考发送重试策略.</p> <p>以上策略也是在一定程度上<strong>保证了消息可以发送成功</strong>. 如果业务要求消息发送不能丢, 仍然需要对可能出现的异常做兜底, 比如调用 send 同步方法发送失败时, 则尝试将消息存储到 db, 然后由后台线程定时重试, 确保消息一定到达 Broker.</p> <p>上述 DB 重试方式为什么没有集成到 MQ 客户端内部做, 而是要求应用自己去完成, 主要基于以下几点考虑: 首先, MQ 的客户端设计为无状态模式, 方便任意的水平扩展, 且对机器资源的消耗仅仅是 cpu, 内存, 网络. 其次, 如果 MQ 客户端内部集成一个 KV 存储模块, 那么数据只有同步落盘才能较可靠, 而同步落盘本身性能开销较大, 所以通常会采用异步落盘, 又由于应用关闭过程不受 MQ 运维人员控制, 可能经常会发生 kill -9 这样暴力方式关闭, 造成数据没有及时落盘而丢失. 第三, Producer 所在机器的可靠性较低, 一般为虚拟机, 不适合存储重要数据. 综上, <strong>建议重试过程交由应用来控制</strong>.</p> <h5 id="消费者"><a href="#消费者" class="header-anchor">#</a> 消费者</h5> <h6 id="消费过程幂等"><a href="#消费过程幂等" class="header-anchor">#</a> 消费过程幂等</h6> <p><mark><strong>RocketMQ 无法避免消息重复(Exactly-Once), 所以如果业务对消费重复非常敏感, 务必要在业务层面进行去重处理</strong></mark>. 可以借助关系数据库进行去重. <strong>首先需要确定消息的唯一键, 可以是 msgId, 也可以是消息内容中的唯一标识字段, 例如订单 Id 等. 在消费之前判断唯一键是否在关系数据库中存在. 如果不存在则插入, 并消费, 否则跳过</strong>. (实际过程要考虑原子性问题, 判断是否存在可以尝试插入, 如果报主键冲突, 则插入失败, 直接跳过). 也可以使用写入 <strong>Redis</strong> 来保证, 因为 Redis 的 key 和 value 就是<strong>天然支持幂等</strong>的.</p> <p>msgId 一定是全局唯一标识符, 但是实际使用中, 可能会存在相同的消息有两个不同 msgId 的情况(消费者主动重发, 因客户端重投机制导致的重复等), 这种情况就需要使业务字段进行重复消费.</p> <p>需要<strong>根据特定场景使用特定的解决方案</strong>, 要明确消息重复消费是否是<strong>完全不能忍受还是可以忍受</strong>, 然后再选择<strong>强校验和弱校验</strong>的方式.</p> <h6 id="消费速度慢的处理方式"><a href="#消费速度慢的处理方式" class="header-anchor">#</a> 消费速度慢的处理方式</h6> <blockquote><p>提高消费并行度</p></blockquote> <p><strong>绝大部分消息消费行为都属于 IO 密集型</strong>, 即可能是操作数据库, 或者调用 RPC, 这类消费行为的消费速度在于后端数据库或者外系统的吞吐量, 通过<strong>增加消费并行度, 可以提高总的消费吞吐量</strong>, 但是并行度增加到一定程度, 反而会下降. 所以, 应用必须要设置合理的并行度.</p> <p>如下有几种修改消费并行度的方法:</p> <ul><li>同一个 ConsumerGroup 下, 通过<strong>增加 Consumer 实例数量来提高并行度</strong>. 可以通过加机器, 或者在已有机器启动多个进程的方式.</li> <li><strong>提高单个 Consumer 的消费并行线程</strong>, 5.x PushConsumer SDK 可以通过PushConsumerBuilder.setConsumptionThreadCount() <strong>设置线程数</strong>, SimpleConsumer 可以由业务线程自由增加并发, 底层线程安全; 历史版本 SDK PushConsumer 可以通过修改参数 consumeThreadMin, consumeThreadMax 实现.</li></ul> <blockquote><p>批量方式消费</p></blockquote> <p><strong>某些业务流程如果支持批量方式消费, 则可以很大程度上提高消费吞吐量</strong>, 例如订单扣款类应用, 一次处理一个订单耗时 1s, 一次处理 10 个订单可能也只耗时 2s, 这样即可大幅度提高消费的吞吐量. 建议使用 5.x SDK 的SimpleConsumer, 每次接口调用设置批次大小, 一次性拉取消费多条消息.</p> <blockquote><p>重置位点跳过非重要消息</p></blockquote> <p>发生消息堆积时, 如果消费速度一直追不上发送速度, <strong>如果业务对数据要求不高的话, 可以选择丢弃不重要的消息</strong>. 建议使用重置位点功能直接调整消费位点到指定时刻或者指定位置.</p> <blockquote><p>优化每条消息消费过程</p></blockquote> <p>举例如下, 某条消息的消费过程如下:</p> <ul><li>根据消息从 DB 查询【数据 1】</li> <li>根据消息从 DB 查询【数据 2】</li> <li>复杂的业务计算</li> <li>向 DB 插入【数据 3】</li> <li>向 DB 插入【数据 4】</li></ul> <p>这条消息的消费过程中有 4 次与 DB 的交互, 如果按照每次 5ms 计算, 那么总共耗时 20ms, 假设业务计算耗时 5ms, 那么总过耗时 25ms, 所以如果能把 4 次 DB 交互优化为 2 次, 那么总耗时就可以优化到 15ms, 即总体性能提高了 40%. 所以应用如果对时延敏感的话, 可以把 DB 部署在 SSD 硬盘, 相比于 SCSI 磁盘, 前者的 RT 会小很多.</p> <h6 id="消费打印日志"><a href="#消费打印日志" class="header-anchor">#</a> 消费打印日志</h6> <p><strong>如果消息量较少, 建议在消费入口方法打印消息, 消费耗时等, 方便后续排查问题</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">ConsumeResult</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">MessageView</span> messageView<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token constant">LOGGER</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Consume message={}&quot;</span><span class="token punctuation">,</span> messageView<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// Do your consume process</span>
        <span class="token keyword">return</span> <span class="token class-name">ConsumeResult</span><span class="token punctuation">.</span><span class="token constant">SUCCESS</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>如果能打印每条消息消费耗时, 那么在排查消费慢等线上问题时, 会更方便. 但如果线上环境 TPS 很高, 不建议开启, 避免日志太多影响性能.</p> <h5 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h5> <blockquote><p>主题管理尽量避免自动化机制</p></blockquote> <p>在 RocketMQ 架构中, 主题属于顶层资源和容器, 拥有独立的权限管理, 可观测性指标采集和监控等能力, 创建和管理主题会占用一定的系统资源. 消费分组属于状态管理类的逻辑资源, 每个消费分组都会涉及关联的消费状态, 堆积信息, 可观测指标和监控采集数据. 因此, <strong>生产环境需要严格管理主题和消费者组资源, 请勿随意进行增, 删, 改, 查操作</strong>.</p> <p>RocketMQ 虽然提供了自动创建主题的功能, 但是建议仅在测试环境使用, 生产环境请勿打开, 避免产生大量垃圾主题, 无法管理和回收并浪费系统资源.</p> <h4 id="参数约束和建议"><a href="#参数约束和建议" class="header-anchor">#</a> 参数约束和建议</h4> <p>RocketMQ 系统中存在很多自定义参数和资源命名, 在使用 RocketMQ 时建议参考如下说明规范系统设置, 避对某些具体参数设置不合理导致应用出现异常.</p> <blockquote><p>Topic名称与ConsumerGroup名称</p></blockquote> <p>字符建议: 字母 a~z 或 A~Z, 数字 0~9 以及下划线(_), 短划线(-)和百分号(%).</p> <p>长度建议: <strong>1~64 个字符</strong>.</p> <p>Topic 命名应该尽量使用简短, 常用的字符, 避免使用特殊字符. 特殊字符会导致系统解析出现异常, 字符过长可能会导致消息收发被拒绝.</p> <blockquote><p>请求超时时间</p></blockquote> <p><strong>默认值: 3000 毫秒</strong>.</p> <p>取值范围: 该参数为客户端本地行为, 取值范围建议不要超过 30000 毫秒.</p> <p>请求超时时间是客户端本地同步调用的等待时间, 请根据实际应用设置合理的取值, 避免线程阻塞时间过长.</p> <blockquote><p>消息大小</p></blockquote> <p>默认值: 不超过 4 MB. 不涉及消息压缩, 仅计算消息体 body 的大小.</p> <p>取值范围: 建议不超过 4 MB.</p> <p>消息传输应尽量压缩和控制负载大小, 避免超大文件传输. <strong>若消息大小不满足限制要求, 可以尝试分割消息或使用 OSS 存储, 用消息传输 URL</strong>.</p> <blockquote><p>MessageGroup</p></blockquote> <p>字符限制: 所有可见字符.</p> <p>长度建议: 1~64 字节.</p> <p>MessageGroup 是<strong>顺序消息的分组标识</strong>. 一般设置为需要保证顺序的一组消息标识, 例如订单 ID, 用户 ID 等.</p> <blockquote><p>消息发送重试次数</p></blockquote> <p><strong>默认值: 3 次</strong>.</p> <p>取值范围: 无限制.</p> <p>消息发送重试是客户端 SDK 内置的重试策略, 对应用不可见, <strong>建议取值不要过大, 避免阻塞业务线程</strong>. 如果消息达到最大重试次数后还未发送成功, 建议业务侧做好兜底处理, 保证消息可靠性.</p> <blockquote><p>消息消费重试次数</p></blockquote> <p><strong>默认值: 16 次.</strong></p> <p>消费重试次数应<strong>根据实际业务需求设置合理的参数值</strong>, 避免使用重试进行无限触发. 重试次数过大容易造成系统压力过量增加.</p> <blockquote><p>事务异常检查间隔</p></blockquote> <p>默认值: 60 秒.</p> <p>事务异常检查间隔指的是, 半事务消息因系统重启或异常情况导致没有提交, 生产者客户端会按照该间隔时间进行事务状态回查. 间隔时长不建议设置过短, 否则频繁的回查调用会影响系统性能.</p> <blockquote><p>半事务消息第一次回查时间</p></blockquote> <p>默认值: 取值等于 [事务异常检查间隔] * 最大限制: 不超过 1 小时.</p> <blockquote><p>半事务消息最大超时时长</p></blockquote> <p>默认值: 4 小时. 取值范围: 不支持自定义修改.</p> <p>半事务消息因系统重启或异常情况导致没有提交, 生产者客户端会按照事务异常检查间隔时间进行回查, 若超过半事务消息超时时长后没有返回结果, 半事务消息将会被强制回滚. 您可以通过监控该指标避免异常事务.</p> <blockquote><p>PushConsumer本地缓存</p></blockquote> <p>默认值: 最大缓存数量: 1024 条. 最大缓存大小: 64 M.</p> <p>取值范围: 支持用户自定义设置, 无限制.</p> <p><strong>消费者类型为 PushConsumer 时, 为提高消费者吞吐量和性能, 客户端会在 SDK 本地缓存部分消息. 缓存的消息的数量和大小应设置在系统内存允许的范围内.</strong></p> <blockquote><p>PushConsumer消费并发度</p></blockquote> <p>默认值: 20 个线程.</p> <blockquote><p>获取消息最大批次</p></blockquote> <p>默认值: 32 条.</p> <p>消费者从服务端获取消息时, 一次获取到最大消息条数. 建议按照实际业务设置合理的参数值, <strong>一次获取消息数量过大容易在消费失败时造成大批量消息重复</strong>.</p> <h3 id="部署与运维"><a href="#部署与运维" class="header-anchor">#</a> 部署与运维</h3> <h4 id="快速安装与消息发送实例"><a href="#快速安装与消息发送实例" class="header-anchor">#</a> 快速安装与消息发送实例</h4> <p>这一节介绍如何快速<strong>部署一个单节点单副本 RocketMQ 服务, 并完成简单的消息收发</strong>.</p> <p>系统要求: 64 位操作系统, 推荐 Linux/Unix/macOS; 64 位 JDK 1.8+.</p> <blockquote><p>1.安装RocketMQ</p></blockquote> <p>RocketMQ 的安装包分为两种, 二进制包和源码包.  点击<a href="https://dist.apache.org/repos/dist/release/rocketmq/5.2.0/rocketmq-all-5.2.0-source-release.zip" target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 下载 RocketMQ 5.2.0 的源码包. 也可以从<a href="https://dist.apache.org/repos/dist/release/rocketmq/5.2.0/rocketmq-all-5.2.0-bin-release.zip" target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 下载到二进制包. 二进制包是已经编译完成后可以直接运行的, 源码包是需要编译后运行的.</p> <p>这里以在 Linux 环境下利用社区 5.2.0 的源码包为例, 介绍 RocketMQ 安装过程.</p> <p>解压 5.2.0 的源码包并编译构建二进制可执行文件:</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>$ <span class="token function">unzip</span> rocketmq-all-5.2.0-source-release.zip
$ <span class="token builtin class-name">cd</span> rocketmq-all-5.2.0-source-release/
$ mvn -Prelease-all <span class="token parameter variable">-DskipTests</span> <span class="token parameter variable">-Dspotbugs.skip</span><span class="token operator">=</span>true clean <span class="token function">install</span> <span class="token parameter variable">-U</span>
$ <span class="token builtin class-name">cd</span> distribution/target/rocketmq-5.2.0/rocketmq-5.2.0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>2.启动NameServer</p></blockquote> <p>安装完 RocketMQ 包后, 启动 NameServer.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># 启动namesrv</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqnamesrv <span class="token operator">&amp;</span>
<span class="token comment"># 验证namesrv是否启动成功</span>
$ <span class="token function">tail</span> <span class="token parameter variable">-f</span> ~/logs/rocketmqlogs/namesrv.log
The Name Server boot success<span class="token punctuation">..</span>.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>可以在 namesrv.log 中看到 'The Name Server boot success..', 表示NameServer 已成功启动.</p> <blockquote><p>3.启动Broker+Proxy</p></blockquote> <p>NameServer成功启动后, 启动 Broker 和 Proxy, 5.x 版本下建议使用 Local 模式部署, 即 Broker 和 Proxy 同进程部署. 5.x 版本也支持 Broker 和 Proxy 分离部署以实现更灵活的集群能力.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># 先启动broker</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> localhost:9876 --enable-proxy <span class="token operator">&amp;</span>

<span class="token comment"># 验证broker是否启动成功, 比如broker的ip是192.168.1.2 然后名字是broker-a</span>
$ <span class="token function">tail</span> <span class="token parameter variable">-f</span> ~/logs/rocketmqlogs/proxy.log 
The broker<span class="token punctuation">[</span>broker-a,192.169.1.2:10911<span class="token punctuation">]</span> boot success<span class="token punctuation">..</span>.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>可以在 proxy.log 中看到 &quot;The broker[brokerName,ip:port] boot success..&quot;, 这表明 broker 已成功启动.</p> <p>至此, 一个单节点副本的 RocketMQ 集群已经部署起来了, 可以利用脚本进行简单的消息收发.</p> <blockquote><p>4.工具测试消息收发</p></blockquote> <p>在进行工具测试消息收发之前, 需要告诉客户端 NameServer 的地址, RocketMQ 有多种方式在客户端中设置 NameServer 地址, 这里 利用环境变量 <code>NAMESRV_ADDR</code>​.</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">NAMESRV_ADDR</span><span class="token operator">=</span>localhost:9876
$ <span class="token function">sh</span> bin/tools.sh org.apache.rocketmq.example.quickstart.Producer
 SendResult <span class="token punctuation">[</span>sendStatus<span class="token operator">=</span>SEND_OK, <span class="token assign-left variable">msgId</span><span class="token operator">=</span> <span class="token punctuation">..</span>.

$ <span class="token function">sh</span> bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer
 ConsumeMessageThread_%d Receive New Messages: <span class="token punctuation">[</span>MessageExt<span class="token punctuation">..</span>.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p>5.SDK测试消息收发</p></blockquote> <p>工具测试完成后, 可以尝试使用 SDK 收发消息. 这里以 Java SDK 为例介绍一下消息收发过程, 可以从 <a href="https://github.com/apache/rocketmq-clients" target="_blank" rel="noopener noreferrer">rocketmq-clients<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 中参阅更多细节.</p> <p>(1) 在 IDEA 中创建一个 Java 工程.</p> <p>(2) 在 pom.xml 文件中添加以下依赖引入 Java 依赖库, 将 <code>rocketmq-client-java-version</code>​ 替换成<a href="https://search.maven.org/search?q=g:org.apache.rocketmq%20AND%20a:rocketmq-client-java" target="_blank" rel="noopener noreferrer">最新的版本<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.rocketmq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>rocketmq-client-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${rocketmq-client-java-version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>(3) 通过 mqadmin 创建 Topic.</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>$ <span class="token function">sh</span> bin/mqadmin updatetopic <span class="token parameter variable">-n</span> localhost:9876 <span class="token parameter variable">-t</span> TestTopic <span class="token parameter variable">-c</span> DefaultCluster
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>(4) 在已创建的 Java 工程中, 创建发送普通消息程序并运行, 示例代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>apis<span class="token punctuation">.</span></span><span class="token class-name">ClientConfiguration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>apis<span class="token punctuation">.</span></span><span class="token class-name">ClientConfigurationBuilder</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>apis<span class="token punctuation">.</span></span><span class="token class-name">ClientException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>apis<span class="token punctuation">.</span></span><span class="token class-name">ClientServiceProvider</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>apis<span class="token punctuation">.</span>message<span class="token punctuation">.</span></span><span class="token class-name">Message</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>apis<span class="token punctuation">.</span>producer<span class="token punctuation">.</span></span><span class="token class-name">Producer</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>apis<span class="token punctuation">.</span>producer<span class="token punctuation">.</span></span><span class="token class-name">SendReceipt</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Logger</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">LoggerFactory</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProducerExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">ProducerExample</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClientException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 接入点地址, 需要设置成Proxy的地址和端口列表, 一般是xxx:8081;xxx:8081. </span>
        <span class="token class-name">String</span> endpoint <span class="token operator">=</span> <span class="token string">&quot;localhost:8081&quot;</span><span class="token punctuation">;</span>
        <span class="token comment">// 消息发送的目标Topic名称, 需要提前创建. </span>
        <span class="token class-name">String</span> topic <span class="token operator">=</span> <span class="token string">&quot;TestTopic&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">ClientServiceProvider</span> provider <span class="token operator">=</span> <span class="token class-name">ClientServiceProvider</span><span class="token punctuation">.</span><span class="token function">loadService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ClientConfigurationBuilder</span> builder <span class="token operator">=</span> <span class="token class-name">ClientConfiguration</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setEndpoints</span><span class="token punctuation">(</span>endpoint<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ClientConfiguration</span> configuration <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 初始化Producer时需要设置通信配置以及预绑定的Topic. </span>
        <span class="token class-name">Producer</span> producer <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">newProducerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setTopics</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setClientConfiguration</span><span class="token punctuation">(</span>configuration<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 普通消息发送. </span>
        <span class="token class-name">Message</span> message <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">newMessageBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setTopic</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span>
            <span class="token comment">// 设置消息索引键, 可根据关键字精确查找某条消息. </span>
            <span class="token punctuation">.</span><span class="token function">setKeys</span><span class="token punctuation">(</span><span class="token string">&quot;messageKey&quot;</span><span class="token punctuation">)</span>
            <span class="token comment">// 设置消息Tag, 用于消费端根据指定Tag过滤消息. </span>
            <span class="token punctuation">.</span><span class="token function">setTag</span><span class="token punctuation">(</span><span class="token string">&quot;messageTag&quot;</span><span class="token punctuation">)</span>
            <span class="token comment">// 消息体. </span>
            <span class="token punctuation">.</span><span class="token function">setBody</span><span class="token punctuation">(</span><span class="token string">&quot;messageBody&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 发送消息, 需要关注发送结果, 并捕获失败等异常. </span>
            <span class="token class-name">SendReceipt</span> sendReceipt <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
            logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Send message successfully, messageId={}&quot;</span><span class="token punctuation">,</span> sendReceipt<span class="token punctuation">.</span><span class="token function">getMessageId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;Failed to send message&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// producer.close();</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><p>(5) 在已创建的 Java 工程中, 创建订阅普通消息程序并运行. <strong>RocketMQ 支持 SimpleConsumer 和 PushConsumer 两种消费者类型</strong>, 可以选择以下任意一种方式订阅消息.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Collections</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>apis<span class="token punctuation">.</span></span><span class="token class-name">ClientConfiguration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>apis<span class="token punctuation">.</span></span><span class="token class-name">ClientException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>apis<span class="token punctuation">.</span></span><span class="token class-name">ClientServiceProvider</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>apis<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span></span><span class="token class-name">ConsumeResult</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>apis<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span></span><span class="token class-name">FilterExpression</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>apis<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span></span><span class="token class-name">FilterExpressionType</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>apis<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span></span><span class="token class-name">PushConsumer</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Logger</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">LoggerFactory</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PushConsumerExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">PushConsumerExample</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">PushConsumerExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClientException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token class-name">ClientServiceProvider</span> provider <span class="token operator">=</span> <span class="token class-name">ClientServiceProvider</span><span class="token punctuation">.</span><span class="token function">loadService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 接入点地址, 需要设置成Proxy的地址和端口列表, 一般是xxx:8081;xxx:8081. </span>
        <span class="token class-name">String</span> endpoints <span class="token operator">=</span> <span class="token string">&quot;localhost:8081&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">ClientConfiguration</span> clientConfiguration <span class="token operator">=</span> <span class="token class-name">ClientConfiguration</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setEndpoints</span><span class="token punctuation">(</span>endpoints<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 订阅消息的过滤规则, 表示订阅所有Tag的消息. </span>
        <span class="token class-name">String</span> tag <span class="token operator">=</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">FilterExpression</span> filterExpression <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterExpression</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> <span class="token class-name">FilterExpressionType</span><span class="token punctuation">.</span><span class="token constant">TAG</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 为消费者指定所属的消费者分组, Group需要提前创建. </span>
        <span class="token class-name">String</span> consumerGroup <span class="token operator">=</span> <span class="token string">&quot;YourConsumerGroup&quot;</span><span class="token punctuation">;</span>
        <span class="token comment">// 指定需要订阅哪个目标Topic, Topic需要提前创建. </span>
        <span class="token class-name">String</span> topic <span class="token operator">=</span> <span class="token string">&quot;TestTopic&quot;</span><span class="token punctuation">;</span>
        <span class="token comment">// 初始化PushConsumer, 需要绑定消费者分组ConsumerGroup, 通信参数以及订阅关系. </span>
        <span class="token class-name">PushConsumer</span> pushConsumer <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">newPushConsumerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setClientConfiguration</span><span class="token punctuation">(</span>clientConfiguration<span class="token punctuation">)</span>
            <span class="token comment">// 设置消费者分组. </span>
            <span class="token punctuation">.</span><span class="token function">setConsumerGroup</span><span class="token punctuation">(</span>consumerGroup<span class="token punctuation">)</span>
            <span class="token comment">// 设置预绑定的订阅关系. </span>
            <span class="token punctuation">.</span><span class="token function">setSubscriptionExpressions</span><span class="token punctuation">(</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonMap</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> filterExpression<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment">// 设置消费监听器. </span>
            <span class="token punctuation">.</span><span class="token function">setMessageListener</span><span class="token punctuation">(</span>messageView <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token comment">// 处理消息并返回消费结果. </span>
                logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Consume message successfully, messageId={}&quot;</span><span class="token punctuation">,</span> messageView<span class="token punctuation">.</span><span class="token function">getMessageId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token class-name">ConsumeResult</span><span class="token punctuation">.</span><span class="token constant">SUCCESS</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果不需要再使用 PushConsumer, 可关闭该实例. </span>
        <span class="token comment">// pushConsumer.close();</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><h4 id="部署方式"><a href="#部署方式" class="header-anchor">#</a> 部署方式</h4> <p>RocketMQ 5.0 版本完成基本消息收发, 包括 NameServer, Broker, Proxy 组件. 在 5.0 版本中 <strong>Proxy 和 Broker 根据实际诉求可以分为 Local 模式和 Cluster 模式</strong>, 一般情况下如果没有特殊需求, 或者遵循从早期版本平滑升级的思路, 可以选用 Local 模式.</p> <ul><li>在 Local 模式下, <strong>Broker 和 Proxy 是同进程部署</strong>, 只是在原有 Broker 的配置基础上新增 Proxy 的简易配置就可以运行.</li> <li>在 Cluster 模式下, <strong>Broker 和 Proxy 分别部署</strong>, 即在原有的集群基础上, 额外再部署 Proxy 即可.</li></ul> <h5 id="local模式部署"><a href="#local模式部署" class="header-anchor">#</a> Local模式部署</h5> <p><strong>由于 Local 模式下 Proxy 和 Broker 是同进程部署, Proxy 本身无状态, 因此主要的集群配置仍然以 Broker 为基础进行即可</strong>.</p> <h6 id="启动nameserver"><a href="#启动nameserver" class="header-anchor">#</a> 启动NameServer</h6> <p><strong>NameServer 需要先于 Broker 启动</strong>, 且如果在生产环境使用, 为了保证高可用, 建议<strong>一般规模的集群启动 3 个NameServer</strong>, 各节点的启动命令相同, 如下:</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 首先启动Name Server</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> mqnamesrv <span class="token operator">&amp;</span>
 
<span class="token comment"># 验证Name Server 是否启动成功</span>
$ <span class="token function">tail</span> <span class="token parameter variable">-f</span> ~/logs/rocketmqlogs/namesrv.log
The Name Server boot success<span class="token punctuation">..</span>.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h6 id="启动broker-proxy"><a href="#启动broker-proxy" class="header-anchor">#</a> 启动Broker+Proxy</h6> <blockquote><p>多组节点(集群)单副本模式</p></blockquote> <p><strong>一个集群内全部部署 Master 角色, 不部署 Slave 副本</strong>, 例如 2 个 Master 或者 3 个 Master, 这种模式的优缺点如下:</p> <ul><li>优点: 配置简单, 单个 Master 宕机或重启维护对应用无影响, 在磁盘配置为 RAID10 时, 即使机器宕机不可恢复情况下, 由于 RAID10 磁盘非常可靠, 消息也不会丢(异步刷盘丢失少量消息, 同步刷盘一条不丢), 性能最高;</li> <li>缺点: 单台机器宕机期间, 这台机器上未被消费的消息在机器恢复之前不可订阅, 消息实时性会受到影响.</li></ul> <p>启动 Broker+Proxy 集群</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 在机器A, 启动第一个Master, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-noslave/broker-a.properties --enable-proxy <span class="token operator">&amp;</span>
<span class="token comment"># 在机器B, 启动第二个Master, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-noslave/broker-b.properties --enable-proxy <span class="token operator">&amp;</span>
<span class="token punctuation">..</span>.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如上启动命令是在单个 NameServer 情况下使用的. 对于多个 NameServer 的集群, Broker 启动命令中 <code>-n</code>​ 后面的地址列表用分号隔开即可, 例如 <code>192.168.1.1:9876;192.161.2:9876</code>​.</p> <blockquote><p>多节点(集群)多副本模式-异步复制</p></blockquote> <p><strong>每个 Master 配置一个 Slave, 有多组 Master-Slave, HA 采用异步复制方式</strong>, 主备有短暂消息延迟(毫秒级), 这种模式的优缺点如下:</p> <ul><li>优点: 即使磁盘损坏, 消息丢失的非常少, 且消息实时性不会受影响, 同时 Master 宕机后, 消费者仍然可以从 Slave 消费, 而且此过程对应用透明, 不需要人工干预, 性能同多 Master 模式几乎一样;</li> <li>缺点: Master 宕机, 磁盘损坏情况下会丢失少量消息.</li></ul> <p>启动 Broker+Proxy 集群:</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 在机器A, 启动第一个Master, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-2s-async/broker-a.properties --enable-proxy <span class="token operator">&amp;</span>
 
<span class="token comment"># 在机器B, 启动第二个Master, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-2s-async/broker-b.properties --enable-proxy <span class="token operator">&amp;</span>
 
<span class="token comment"># 在机器C, 启动第一个Slave, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-2s-async/broker-a-s.properties --enable-proxy <span class="token operator">&amp;</span>
 
<span class="token comment"># 在机器D, 启动第二个Slave, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-2s-async/broker-b-s.properties --enable-proxy <span class="token operator">&amp;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>多节点(集群)多副本模式-同步双写</p></blockquote> <p><strong>每个 Master 配置一个 Slave, 有多对 Master-Slave, HA 采用同步双写方式</strong>, 即只有主备都写成功, 才向应用返回成功, 这种模式的优缺点如下:</p> <ul><li>优点: 数据与服务都无单点故障, Master 宕机情况下, 消息无延迟, 服务可用性与数据可用性都非常高;</li> <li>缺点: 性能比异步复制模式略低(大约低 10% 左右), 发送单个消息的 RT 会略高, 且目前版本在主节点宕机后, 备机不能自动切换为主机.</li></ul> <p>启动 Broker+Proxy 集群</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 在机器A, 启动第一个Master, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-2s-sync/broker-a.properties --enable-proxy <span class="token operator">&amp;</span>
 
<span class="token comment"># 在机器B, 启动第二个Master, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-2s-sync/broker-b.properties --enable-proxy <span class="token operator">&amp;</span>
 
<span class="token comment"># 在机器C, 启动第一个Slave, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-2s-sync/broker-a-s.properties --enable-proxy <span class="token operator">&amp;</span>
 
<span class="token comment"># 在机器D, 启动第二个Slave, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-2s-sync/broker-b-s.properties --enable-proxy <span class="token operator">&amp;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>提示: 以上 Broker 与 Slave 配对是通过指定相同的 BrokerName 参数来配对, Master 的 BrokerId 必须是 0, Slave 的 BrokerId 必须是大于 0 的数. 另外一个 Master 下面可以挂载多个 Slave, 同一 Master 下的多个 Slave 通过指定不同的 BrokerId 来区分. $ROCKETMQ_HOME 指的 RocketMQ 安装目录, 需要用户自己设置此环境变量.</p> <blockquote><p>5.0 HA新模式</p></blockquote> <p>提供更具灵活性的 HA 机制, 让用户更好的平衡成本, 服务可用性, 数据可靠性, 同时支持业务消息和流存储的场景.</p> <h5 id="cluster模式部署"><a href="#cluster模式部署" class="header-anchor">#</a> Cluster模式部署</h5> <p><strong>在 Cluster 模式下, Broker 与 Proxy 分别部署, 可以在 NameServer 和 Broker 都启动完成之后再部署 Proxy</strong>.</p> <p>在 Cluster 模式下, 一个 Proxy 集群和 Broker 集群为一一对应的关系, 可以在 Proxy 的配置文件 <code>rmq-proxy.json</code>​ 中使用 <code>rocketMQClusterName</code>​ 进行配置.</p> <h6 id="启动nameserver-2"><a href="#启动nameserver-2" class="header-anchor">#</a> 启动NameServer</h6> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 首先启动Name Server</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> mqnamesrv <span class="token operator">&amp;</span>
 
<span class="token comment"># 验证Name Server 是否启动成功</span>
$ <span class="token function">tail</span> <span class="token parameter variable">-f</span> ~/logs/rocketmqlogs/namesrv.log
The Name Server boot success<span class="token punctuation">..</span>.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h6 id="启动broker"><a href="#启动broker" class="header-anchor">#</a> 启动Broker</h6> <blockquote><p>多组节点(集群)单副本模式</p></blockquote> <p><strong>一个集群内全部部署 Master 角色, 不部署 Slave 副本</strong>, 例如 2 个 Master 或者 3 个 Master, 这种模式的优缺点如下:</p> <ul><li>优点: 配置简单, <strong>单个 Master 宕机或重启维护对应用无影响</strong>, 在磁盘配置为 RAID10 时, 即使机器宕机不可恢复情况下, 由于 RAID10 磁盘非常可靠, 消息也不会丢(异步刷盘丢失少量消息, 同步刷盘一条不丢), 性能最高;</li> <li>缺点: 单台机器宕机期间, 这台机器上未被消费的消息在机器恢复之前不可订阅, 消息实时性会受到影响.</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 在机器A, 启动第一个Master, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-noslave/broker-a.properties <span class="token operator">&amp;</span>
 
<span class="token comment"># 在机器B, 启动第二个Master, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-noslave/broker-b.properties <span class="token operator">&amp;</span>

<span class="token punctuation">..</span>.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>备注: 如上启动命令是在单个 NameServer 情况下使用的. 对于多个 NameServer 的集群, Broker 启动命令中 <code>-n</code>​ 后面的地址列表用分号隔开即可, 例如 <code>192.168.1.1:9876;192.161.2:9876</code>​.</p> <blockquote><p>多节点(集群)多副本模式-异步复制</p></blockquote> <p><strong>每个 Master 配置一个 Slave, 有多组 Master-Slave, HA 采用异步复制方式, 主备有短暂消息延迟</strong>(毫秒级), 这种模式的优缺点如下:</p> <ul><li>优点: 即使磁盘损坏, 消息丢失的非常少, 且消息实时性不会受影响, 同时 Master 宕机后, 消费者仍然可以从 Slave 消费, 而且此过程对应用透明, 不需要人工干预, 性能同多 Master 模式几乎一样;</li> <li>缺点: Master 宕机, 磁盘损坏情况下会丢失少量消息.</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 在机器A, 启动第一个Master, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-2s-async/broker-a.properties <span class="token operator">&amp;</span>
 
<span class="token comment"># 在机器B, 启动第二个Master, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-2s-async/broker-b.properties <span class="token operator">&amp;</span>
 
<span class="token comment"># 在机器C, 启动第一个Slave, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-2s-async/broker-a-s.properties <span class="token operator">&amp;</span>
 
<span class="token comment"># 在机器D, 启动第二个Slave, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-2s-async/broker-b-s.properties <span class="token operator">&amp;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>多节点(集群)多副本模式-同步双写</p></blockquote> <p><strong>每个 Master 配置一个 Slave, 有多对 Master-Slave, HA 采用同步双写方式, 即只有主备都写成功</strong>, 才向应用返回成功, 这种模式的优缺点如下:</p> <ul><li>优点: 数据与服务都无单点故障, Master 宕机情况下, 消息无延迟, 服务可用性与数据可用性都非常高;</li> <li>缺点: 性能比异步复制模式略低(大约低 10% 左右), 发送单个消息的 RT 会略高, 且目前版本在主节点宕机后, 备机不能自动切换为主机.</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 在机器A, 启动第一个Master, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-2s-sync/broker-a.properties <span class="token operator">&amp;</span>
 
<span class="token comment"># 在机器B, 启动第二个Master, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-2s-sync/broker-b.properties <span class="token operator">&amp;</span>
 
<span class="token comment"># 在机器C, 启动第一个Slave, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-2s-sync/broker-a-s.properties <span class="token operator">&amp;</span>
 
<span class="token comment"># 在机器D, 启动第二个Slave, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-c</span> <span class="token variable">$ROCKETMQ_HOME</span>/conf/2m-2s-sync/broker-b-s.properties <span class="token operator">&amp;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>提示: 以上 Broker 与 Slave 配对是通过指定相同的 BrokerName 参数来配对, Master 的 BrokerId 必须是 0, Slave 的 BrokerId 必须是大于 0 的数. 另外一个 Master 下面可以挂载多个 Slave, 同一 Master 下的多个 Slave 通过指定不同的 BrokerId 来区分. <code>$ROCKETMQ_HOME</code>​ 指的 RocketMQ 安装目录, 需要用户自己设置此环境变量.</p> <blockquote><p>5.0 HA新模式</p></blockquote> <p>提供更具灵活性的 HA 机制, 让用户更好的平衡成本, 服务可用性, 数据可靠性, 同时支持业务消息和流存储的场景.</p> <h6 id="启动proxy"><a href="#启动proxy" class="header-anchor">#</a> 启动Proxy</h6> <p>可以在多台机器启动多个 Proxy.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># 在机器A, 启动第一个Proxy, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqproxy <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token operator">&amp;</span>

<span class="token comment"># 在机器B, 启动第二个Proxy, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqproxy <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token operator">&amp;</span>

<span class="token comment"># 在机器C, 启动第三个Proxy, 例如NameServer的IP为: 192.168.1.1</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqproxy <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token operator">&amp;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>若需要指定配置文件, 可以使用 <code>-pc</code>​ 或者 <code>--proxyConfigPath</code>​ 进行指定.</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment">### 自定义配置文件</span>
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqproxy <span class="token parameter variable">-n</span> <span class="token number">192.168</span>.1.1:9876 <span class="token parameter variable">-pc</span> /path/to/proxyConfig.json <span class="token operator">&amp;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="主备自动切换模式部署"><a href="#主备自动切换模式部署" class="header-anchor">#</a> 主备自动切换模式部署</h4> <h5 id="基础-10"><a href="#基础-10" class="header-anchor">#</a> 基础</h5> <p><img src="/img/controller%E6%9E%B6%E6%9E%84-d431b0cc0815713f46cf9adbe3e26957-20240422215206-bi8cbwh.png" alt="架构图"></p> <p>该文档主要介绍<strong>如何部署支持自动主从切换的 RocketMQ 集群</strong>, 其架构如上图所示, 主要增加支持自动主从切换的 Controller 组件, 其可以独立部署也可以内嵌在 NameServer 中.</p> <p>详细可参考 <a href="https://github.com/apache/rocketmq/blob/develop/docs/cn/controller/design.md" target="_blank" rel="noopener noreferrer">设计思想<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和 <a href="https://github.com/apache/rocketmq/blob/develop/docs/cn/controller/quick_start.md" target="_blank" rel="noopener noreferrer">快速开始<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <h5 id="controller部署"><a href="#controller部署" class="header-anchor">#</a> Controller部署</h5> <p><strong>Controller 组件提供选主能力, 若需要保证 Controller 具备容错能力, Controller 部署需要三副本及以上(遵循 Raft 的多数派协议)</strong> .</p> <p>注意: Controller 若只部署单副本也能完成 Broker Failover, 但若该单点 Controller 故障, 会影响切换能力, 但不会影响存量集群的正常收发.</p> <p>Controller 部署有两种方式. <strong>一种是嵌入于 NameServer 进行部署</strong>, 可以通过配置 enableControllerInNamesrv 打开(可以选择性打开, 并不强制要求每一台 NameServer 都打开), 在该模式下, NameServer 本身能力仍然是无状态的, 也就是内嵌模式下若 NameServer 挂掉多数派, 只影响切换能力, 不影响原来路由获取等功能. 另一种是<strong>独立部署, 需要单独部署 Controller 组件</strong>.</p> <h6 id="controller嵌入nameserver部署"><a href="#controller嵌入nameserver部署" class="header-anchor">#</a> Controller嵌入NameServer部署</h6> <p><img src="/img/Controller-as-plugin-afd8d004541eb46736d8ea20594a4bb8-20240422215206-uu3jh6r.png" alt="内嵌部署图"></p> <p>嵌入 NameServer 部署时只需要在 NameServer 的配置文件中设置 <code>enableControllerInNamesrv=true</code>​, 并填上 Controller 的配置即可.</p> <div class="language-properties line-numbers-mode"><pre class="language-properties"><code><span class="token key attr-name">enableControllerInNamesrv</span> <span class="token punctuation">=</span> <span class="token value attr-value">true</span>
<span class="token key attr-name">controllerDLegerGroup</span> <span class="token punctuation">=</span> <span class="token value attr-value">group1</span>
<span class="token key attr-name">controllerDLegerPeers</span> <span class="token punctuation">=</span> <span class="token value attr-value">n0-127.0.0.1:9877;n1-127.0.0.1:9878;n2-127.0.0.1:9879</span>
<span class="token key attr-name">controllerDLegerSelfId</span> <span class="token punctuation">=</span> <span class="token value attr-value">n0</span>
<span class="token key attr-name">controllerStorePath</span> <span class="token punctuation">=</span> <span class="token value attr-value">/home/admin/DledgerController</span>
<span class="token key attr-name">enableElectUncleanMaster</span> <span class="token punctuation">=</span> <span class="token value attr-value">false</span>
<span class="token key attr-name">notifyBrokerRoleChanged</span> <span class="token punctuation">=</span> <span class="token value attr-value">true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>参数解释:</p> <ul><li>enableControllerInNamesrv: Nameserver 中是否开启 controller, 默认 false.</li> <li>controllerDLegerGroup: DLedger Raft Group 的名字, 同一个 DLedger Raft Group 保持一致即可.</li> <li>controllerDLegerPeers: DLedger Group 内各节点的端口信息, 同一个 Group 内的各个节点配置必须要保证一致.</li> <li>controllerDLegerSelfId: 节点 id, 必须属于 controllerDLegerPeers 中的一个; 同 Group 内各个节点要唯一.</li> <li>controllerStorePath: controller 日志存储位置. controller 是有状态的, controller 重启或宕机需要依靠日志来恢复数据, 该目录非常重要, 不可以轻易删除.</li> <li>enableElectUncleanMaster: 是否可以从 SyncStateSet 以外选举 Master, 若为 true, 可能会选取数据落后的副本作为 Master 而丢失消息, 默认为 false.</li> <li>notifyBrokerRoleChanged: 当 Broker 副本组上角色发生变化时是否主动通知, 默认为 true.</li></ul> <p>参数设置完成后, 指定配置文件启动 Nameserver 即可.</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqnamesrv <span class="token parameter variable">-c</span> namesrv.conf <span class="token operator">&amp;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h6 id="controller独立部署"><a href="#controller独立部署" class="header-anchor">#</a> Controller独立部署</h6> <p><img src="/img/Controller-deploy-indepdent-76249b759fd9d4e728e09a10d278467e-20240422215206-sfvhb80.png" alt="架构图"></p> <p>独立部署执行以下脚本即可.</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqcontroller <span class="token parameter variable">-c</span> controller.conf <span class="token operator">&amp;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>mqcontroller 脚本在源码包 distribution/bin/mqcontroller, 配置参数与内嵌模式相同.</p> <p>注意: 独立部署 Controller 后, 仍然需要单独部署 NameServer 提供路由发现能力.</p> <h5 id="broker部署"><a href="#broker部署" class="header-anchor">#</a> Broker部署</h5> <p>Broker 启动方法与之前相同, 增加以下参数:</p> <ul><li>enableControllerMode: Broker controller 模式的总开关, 只有该值为 true, 自动主从切换模式才会打开. 默认为 false.</li> <li>controllerAddr: controller 的地址, 多个 controller 中间用分号隔开. 例如 <code>controllerAddr = 127.0.0.1:9877;127.0.0.1:9878;127.0.0.1:9879</code>​</li> <li>syncBrokerMetadataPeriod: 向 controller 同步 Broker 副本信息的时间间隔. 默认 5000(5s).</li> <li>checkSyncStateSetPeriod: 检查 SyncStateSet 的时间间隔, 检查 SyncStateSet 可能会 shrink SyncState. 默认 5000(5s).</li> <li>syncControllerMetadataPeriod: 同步 controller 元数据的时间间隔, 主要是获取 active controller 的地址. 默认10000(10s).</li> <li>haMaxTimeSlaveNotCatchup: 表示 Slave 没有跟上 Master 的最大时间间隔, 若在 SyncStateSet 中的 slave 超过该时间间隔会将其从 SyncStateSet 移除. 默认为 15000(15s).</li> <li>storePathEpochFile: 存储 epoch 文件的位置. epoch 文件非常重要, 不可以随意删除. 默认在 store 目录下.</li> <li>allAckInSyncStateSet: 若该值为 true, 则一条消息需要复制到 SyncStateSet 中的每一个副本才会向客户端返回成功, 可以保证消息不丢失. 默认为 false.</li> <li>syncFromLastFile: 若 slave 是空盘启动, 是否从最后一个文件进行复制. 默认为 false.</li> <li>asyncLearner: 若该值为 true, 则该副本不会进入 SyncStateSet, 也就是不会被选举成 Master, 而是一直作为一个 learner 副本进行异步复制. 默认为 false.</li> <li><strong>inSyncReplicas</strong>: 需保持同步的副本组数量, 默认为 1, allAckInSyncStateSet=true 时该参数无效.</li> <li><strong>minInSyncReplicas</strong>: 最小需保持同步的副本组数量, 若 SyncStateSet 中副本个数小于 minInSyncReplicas 则 putMessage 直接返回 PutMessageStatus.IN_SYNC_REPLICAS_NOT_ENOUGH, 默认为 1.</li></ul> <p>在 Controller 模式下, Broker 配置必须设置 <code>enableControllerMode=true</code>​, 并填写 controllerAddr, 并以下面命令启动:</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-c</span> broker.conf <span class="token operator">&amp;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意: 自动主备切换模式下 Broker 无需指定 brokerId 和 brokerRole, 其由 Controller 组件进行分配.</p> <h4 id="rocketmq-dashboard"><a href="#rocketmq-dashboard" class="header-anchor">#</a> RocketMQ Dashboard</h4> <p>​​RocketMQ Dashboard​ 是 RocketMQ 的管控利器, 为用户<strong>提供客户端和应用程序的各种事件, 性能的统计信息, 支持以可视化工具代替 Topic 配置, Broker 管理等命令行操作</strong>.</p> <h5 id="基础-11"><a href="#基础-11" class="header-anchor">#</a> 基础</h5> <p>功能概览如下:</p> <table><thead><tr><th style="text-align:center;">面板</th> <th>功能</th></tr></thead> <tbody><tr><td style="text-align:center;">运维</td> <td>修改nameserver 地址;  选用 <code>VIPChannel</code>​</td></tr> <tr><td style="text-align:center;">驾驶舱</td> <td>查看 broker, topic 消息量</td></tr> <tr><td style="text-align:center;">集群</td> <td>集群分布, broker 配置, 运行信息</td></tr> <tr><td style="text-align:center;">主题</td> <td>搜索, 筛选, 删除, 更新/新增主题, 消息路由, 发送消息, 重置消费位点</td></tr> <tr><td style="text-align:center;">消费者</td> <td>搜索, 删除, 新增/更新消费者组, 终端, 消费详情, 配置</td></tr> <tr><td style="text-align:center;">消息</td> <td>消息记录, 私信消息, 消息轨迹等消息详情</td></tr></tbody></table> <p>操作面板:</p> <p><img src="/img/1_dashboard-ab01f6bdd465d1202b5a7ff715cd6076-20240422215223-h25pnhx.png" alt="1657630174311"></p> <h5 id="快速开始"><a href="#快速开始" class="header-anchor">#</a> 快速开始</h5> <p>系统要求:</p> <ol><li>Linux/Unix/Mac</li> <li>64bit JDK 1.8+</li> <li>Maven 3.2.x</li> <li>启动 <a href="https://rocketmq.apache.org/docs/quick-start/" target="_blank" rel="noopener noreferrer">RocketMQ<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <p>网络配置:</p> <ol><li>云服务器可远程访问或本地虚拟机可 PING 通外网.</li> <li>​<code>rocketmq</code>​ 配置文件 <code>broker.conf / broker-x.properties</code>​ 设置 nameserver 地址和端口号.</li> <li>用配置文件启动 broker.</li></ol> <blockquote><p>docker镜像安装</p></blockquote> <p>① 安装docker, 拉取 <code>rocketmq-dashboard</code>​ 镜像:</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>$ <span class="token function">docker</span> pull apacherocketmq/rocketmq-dashboard:latest
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>② docker 容器中运行 <code>rocketmq-dashboard</code>​:</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> rocketmq-dashboard <span class="token parameter variable">-e</span> <span class="token string">&quot;JAVA_OPTS=-Drocketmq.namesrv.addr=127.0.0.1:9876&quot;</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8080 <span class="token parameter variable">-t</span> apacherocketmq/rocketmq-dashboard:latest
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>提示: <code>namesrv.addr:port</code>​ 替换为 <code>rocketmq</code>​ 中配置的 nameserver 地址: 端口号.</p> <p>开放端口号: 8080, 9876, 10911, 11011 端口.</p> <ul><li>云服务器: 设置安全组访问规则</li> <li>本地虚拟机: 关闭防火墙, 或 <code>-add-port</code>​</li></ul> <h5 id="使用教程"><a href="#使用教程" class="header-anchor">#</a> 使用教程</h5> <p>基本用法如下:</p> <blockquote><p>创建主题Topic</p></blockquote> <p><img src="/img/2_createTopic-e384f0c6d87ddb0d73a9be06cbcb4d87-20240422215223-nrsphmz.png" alt="1657547091545"></p> <blockquote><p>创建消费者组consumer</p></blockquote> <p>​<img src="/img/3_createConsumer-f88ab5dd052b4838381dc1eb1b0afca1-20240422215223-cqceyle.png" alt="1657547745254">​</p> <blockquote><p>重置消费位点</p></blockquote> <p>​<img src="/img/4_resetOffset-1eee0933f962ba710d8c7a05119acdf1-20240422215223-2dj56nr.png" alt="1657547891994">​</p> <p><strong>tips</strong>:</p> <ul><li>集群消费支持重置消费位点, 广播模式不支持.</li> <li>消费者不在线不能重置消费位点.</li></ul> <blockquote><p>扩容Topic队列</p></blockquote> <p><img src="/img/5_enlargeTopic-2490dbf79885d9e2b434926c09ff4706-20240422215223-f87txm3.png" alt="1657548375401"></p> <blockquote><p>扩容Broker</p></blockquote> <ul><li>安装部署一个新的 broker, nameserver 地址和当前集群一样</li></ul> <p>​<img src="/img/6_cluster-328c0c9a35f26d6c2890aba4ab488093-20240422215223-jq2n6ee.png" alt="1657549432610">​</p> <ul><li>更新 Topic 的BROKER_NAME</li></ul> <p>​<img src="/img/7_enlargeBroker-5bdd47824115dba426d8596f6c9c67ee-20240422215223-x6hzrlb.png" alt="1657549599728">​</p> <blockquote><p>发送消息</p></blockquote> <ul><li>向指定 Topic 发送消息</li></ul> <p>​<img src="/img/8_sendMessage-ea4cdf06c5195eabfc93ef8b6ff482f5-20240422215223-3uo1pgz.png" alt="1657550506673">​</p> <ul><li>发送结果</li></ul> <p>​<img src="/img/9_sendResult-9f60e816de687e657f556555f5c611ff-20240422215223-cilnzu3.png" alt="1657550592049">​</p> <h4 id="rocketmq-promethus-exporter"><a href="#rocketmq-promethus-exporter" class="header-anchor">#</a> RocketMQ Promethus Exporter</h4> <h5 id="基础-12"><a href="#基础-12" class="header-anchor">#</a> 基础</h5> <p>​​Rocketmq-exporter​ 是用于<strong>监控 RocketMQ broker 端和客户端所有相关指标的系统</strong>, 通过 <code>mqAdmin</code>​ 从 broker 端获取指标值后封装成 87 个 cache.</p> <p><strong>Rocketmq-expoter 获取监控指标的流程</strong>如下图所示, <mark><strong>Expoter 通过 MQAdminExt 向 MQ 集群请求数据, 请求到的数据通过 MetricService 规范化成 Prometheus 需要的格式, 然后通过 /metics 接口暴露给 Promethus</strong></mark>.</p> <p>​<img src="/img/image-20240830234727-y2iv9hy.png" alt="image">​</p> <h6 id="metric结构"><a href="#metric结构" class="header-anchor">#</a> Metric结构</h6> <p>​<code>Metric</code>​ 类位于 <code>org.apache.rocketmq.expoter.model.metrics</code>​ 包下, 实质上是一些实体类, 每个实体类代表一类指标, <strong>总共 14 个 Metric 类</strong>. 这些类作为 87 个 Cache 的 key, 用不同的 label 值进行区分.</p> <p>实体类中包含了 label 的三个维度: broker, consumer, producer</p> <ul><li><strong>broker 相关 metric 类有</strong>: BrokerRuntimeMetric, BrokerMetric, DLQTopicOffsetMetric, TopicPutNumMetric.</li> <li><strong>消费者相关类有</strong>: ConsumerRuntimeConsumeFailedMsgsMetric, ConsumerRuntimeConsumeFailedTPSMetric, ConsumerRuntimeConsumeOKTPSMetric, ConsumerRuntimeConsumeRTMetric, ConsumerRuntimePullRTMetric, ConsumerRuntimePullTPSMetric, ConsumerCountMetric, ConsumerMetric, ConsumerTopicDiffMetric.</li> <li><strong>生产者相关 metric 类有</strong>: ProducerMetric.</li></ul> <h6 id="prometheus拉取metrics的过程"><a href="#prometheus拉取metrics的过程" class="header-anchor">#</a> Prometheus拉取metrics的过程</h6> <p>​<code>RocketMQ-exporter</code>​ 项目和 <code>Prometheus</code>​ 相当于<strong>服务器和客户端</strong>的关系, <strong>RocketMQ-exporter 项目引入了 Prometheus 的 client 包, 该包中规定了需要获取的信息的类型即项目中的 MetricFamilySamples 类, Prometheus 向 expoter 请求 metrics, expoter 将信息封装成相应的类型之后返回给 Prometheus</strong>.</p> <p>rocketmq-expoter 项目启动后, 会获取 rocketmq 的各项 metrics 收集到 mfs 对象中, 当浏览器或 Prometheus 访问相应的接口时, 会通过 service 将 mfs 对象中的 samples 生成 Prometheus 所支持的格式化数据.</p> <p>主要包含以下步骤:</p> <p>浏览器通过访问 <code>ip:5557/metrics</code>​, 会调用 RMQMetricsController 类下的 metrics 方法, 其中 ip 为 rocketmq-expoter 项目运行的主机 ip.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">metrics</span><span class="token punctuation">(</span><span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token class-name">StringWriter</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    metricsService<span class="token punctuation">.</span><span class="token function">metrics</span><span class="token punctuation">(</span>writer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Content-Type&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;text/plain; version=0.0.4; charset=utf-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    response<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>writer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>通过新建 StringWriter 对象用于收集 metrics 指标, 调用 MetricsService 类中的方法 metrics 将 expoter 中提取到的指标收集到 writer 对象中, 最后将收集到的指标输出到网页上.</p> <p>收集到的指标格式为:</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>metric name<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>label name<span class="token operator">&gt;=</span><span class="token operator">&lt;</span>label value<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">}</span> <span class="token operator">&lt;</span>metric value<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如:</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>rocketmq_group_diff<span class="token punctuation">{</span>group<span class="token operator">=</span><span class="token string">&quot;rmq_group_test_20220114&quot;</span><span class="token punctuation">,</span>topic<span class="token operator">=</span><span class="token string">&quot;fusion_console_tst&quot;</span><span class="token punctuation">,</span>countOfOnlineConsumers<span class="token operator">=</span><span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span>msgModel<span class="token operator">=</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span><span class="token punctuation">}</span> <span class="token number">23.0</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h6 id="metriccollecttask类中的5个定时任务"><a href="#metriccollecttask类中的5个定时任务" class="header-anchor">#</a> MetricCollectTask类中的5个定时任务</h6> <p>MetricCollectTask 类中有 5 个定时任务, 分别为 collectTopicOffset, collectConsumerOffset, collectBrokerStatsTopic, collectBrokerStats 和 collectBrokerRuntimeStats. <strong>用于收集消费位点信息以及 Broker 状态信息等</strong>. 其 cron 表达式为: <code>cron: 15 0/1 * * * ?</code>​, 表示每分钟会收集一次. 其核心功能是通过 mqAdminExt 对象从集群中获取 broker 中的信息, 然后将其添加到对应的 87 个监控指标中.</p> <p>以 collectTopicOffset 为例:</p> <ol><li>首先初始化 TopicList 对象, 通过 mqAdminExt.fetchAllTopicList() 方法获取到集群的所有 topic 信息.</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>TopicList topicList <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>  topicList <span class="token operator">=</span> mqAdminExt<span class="token punctuation">.</span><span class="token function">fetchAllTopicList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>Exception ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;collectTopicOffset-exception comes getting topic list from namesrv, address is %s&quot;</span><span class="token punctuation">,</span>
        <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>mqAdminExt<span class="token punctuation">.</span><span class="token function">getNameServerAddressList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ol start="2"><li>将 topic 加入到 topicSet 中, 循环遍历每一个 topic, 通过 mqAdminExt.examineTopicStats(topic) 函数来检查 topic 状态.</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>Set <span class="token operator">&lt;</span> String <span class="token operator">&gt;</span> topicSet <span class="token operator">=</span> topicList <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> topicList<span class="token punctuation">.</span><span class="token function">getTopicList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>String topic<span class="token operator">:</span> topicSet<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    TopicStatsTable topicStats <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        topicStats <span class="token operator">=</span> mqAdminExt<span class="token punctuation">.</span><span class="token function">examineTopicStats</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>Exception ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;collectTopicOffset-getting topic(%s) stats error. the namesrv address is %s&quot;</span><span class="token punctuation">,</span>
         topic<span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>mqAdminExt<span class="token punctuation">.</span><span class="token function">getNameServerAddressList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ol start="3"><li>初始化 topic 状态 set, 用于用于按 broker 划分的 topic 信息位点的 hash 表 brokerOffsetMap, 以及一个用于按 broker 名字为 key 的用于存储更新时间戳的 hash 表 brokerUpdateTimestampMap.</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>MessageQueue<span class="token punctuation">,</span> TopicOffset<span class="token operator">&gt;&gt;</span> topicStatusEntries <span class="token operator">=</span> topicStats<span class="token punctuation">.</span><span class="token function">getOffsetTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Long<span class="token operator">&gt;</span> brokerOffsetMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Long<span class="token operator">&gt;</span> brokerUpdateTimestampMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>MessageQueue<span class="token punctuation">,</span> TopicOffset<span class="token operator">&gt;</span> topicStatusEntry <span class="token operator">:</span> topicStatusEntries<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    MessageQueue q <span class="token operator">=</span> topicStatusEntry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    TopicOffset offset <span class="token operator">=</span> topicStatusEntry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>brokerOffsetMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">getBrokerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        brokerOffsetMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">getBrokerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> brokerOffsetMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">getBrokerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> offset<span class="token punctuation">.</span><span class="token function">getMaxOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        brokerOffsetMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">getBrokerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> offset<span class="token punctuation">.</span><span class="token function">getMaxOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>brokerUpdateTimestampMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">getBrokerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>offset<span class="token punctuation">.</span><span class="token function">getLastUpdateTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> brokerUpdateTimestampMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">getBrokerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            brokerUpdateTimestampMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">getBrokerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> offset<span class="token punctuation">.</span><span class="token function">getLastUpdateTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        brokerUpdateTimestampMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">getBrokerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        offset<span class="token punctuation">.</span><span class="token function">getLastUpdateTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><ol start="4"><li>最后通过遍历 brokerOffsetMap 中的每一项, 通过调用 metricsService 获取到 metricCollector 对象, 调用 RMQMetricsCollector 类中的 addTopicOffsetMetric 方法, 将相应的值添加到 RMQMetricsCollector 类中 87 个指标对应的其中一个指标的 cache 中.</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code> Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Long<span class="token operator">&gt;&gt;</span> brokerOffsetEntries <span class="token operator">=</span> brokerOffsetMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Long<span class="token operator">&gt;</span> brokerOffsetEntry <span class="token operator">:</span> brokerOffsetEntries<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            metricsService<span class="token punctuation">.</span><span class="token function">getCollector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTopicOffsetMetric</span><span class="token punctuation">(</span>clusterName<span class="token punctuation">,</span> brokerOffsetEntry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> topic<span class="token punctuation">,</span>
                brokerUpdateTimestampMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>brokerOffsetEntry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> brokerOffsetEntry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;topic offset collection task finished....&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h6 id="rocketmq-exporter收集指标流程图"><a href="#rocketmq-exporter收集指标流程图" class="header-anchor">#</a> Rocketmq-exporter收集指标流程图</h6> <p><img src="/img/RocketMQ%20Prometheus%20Exporter%20-%202-fdd37b4d6c89244c23bac2bf87ff7e26-20240422215237-axgwerf.jpeg" alt="95680458234"></p> <h5 id="快速开始-2"><a href="#快速开始-2" class="header-anchor">#</a> 快速开始</h5> <blockquote><p>配置application.yml</p></blockquote> <p>​<code>application.yml</code>​ 中重要的配置主要有:</p> <ul><li>server.port 设置 promethus 监听 rocketmq-exporter 的端口, 默认为 5557.</li> <li>rocketmq.config.webTelemetryPath 配置 promethus 获取指标的路径, 默认为 /metrics , 使用默认值即可.</li> <li>rocketmq.config.enableACL 如果 RocketMQ 集群开启了 ACL 验证,需要配置为 true, 并在 accessKey 和 secretKey 中配置相应的 ak, sk.</li> <li>rocketmq.config.outOfTimeSeconds 用于配置存储指标和相应的值的过期时间,若超过该时间, cache 中的 key 对应的节点没有发生写更改,则会进行删除. 一般配置为 60s 即可(根据 promethus 获取指标的时间间隔进行合理配置, 只要保证过期时间大于等于 promethus 收集指标的时间间隔即可).</li> <li>task.cron 配置 exporter 从 broker 拉取指标的定时任务的时间间隔, 默认值为 &quot;<code>15 0/1 * * ?</code>​&quot; 每分钟的 15s 拉取一次指标.</li></ul> <blockquote><p>启动exporter项目</p></blockquote> <blockquote><p>按照promethus官网配置启动</p></blockquote> <p>配置 promethus 的 <code>static_config: -targets</code>​ 为 exporter 的启动 IP 和端口, 如: localhost:5557.</p> <blockquote><p>访问promethus页面</p></blockquote> <p>本地启动默认为: localhost:9090, 则可对收集到的指标值进行查看, 如下图所示:</p> <p>​<img src="/img/RocketMQ%20Prometheus%20Exporter-3-f5d7bc508a5e4f791de91d2835b261b7-20240422215237-oz1sqxa.jpeg" alt="906876098423">​</p> <h5 id="可观测性指标"><a href="#可观测性指标" class="header-anchor">#</a> 可观测性指标</h5> <p>可观测性指标主要包括两个大类: <strong>服务端指标和客户端指标, 服务端指标由服务端直接生成, 客户端指标在客户端产生, 由服务端通过 rpc 请求客户端获取到</strong>. 客户端指标又可细分为生产端指标和消费端指标.</p> <h4 id="dledger"><a href="#dledger" class="header-anchor">#</a> Dledger</h4> <p><strong>DLedger 是一套基于 Raft 协议的分布式日志存储组件, 部署 RocketMQ 时可以根据需要选择使用 DLeger 来替换原生的副本存储机制</strong>. 本文档主要介绍如何快速构建和部署基于 DLedger 的可以自动容灾切换的 RocketMQ 集群.</p> <h5 id="dledger快速搭建示例"><a href="#dledger快速搭建示例" class="header-anchor">#</a> Dledger快速搭建示例</h5> <blockquote><p>源码构建</p></blockquote> <p>构建分为两个部分, 需要先构建 DLedger, 然后构建 RocketMQ.</p> <p><strong>构建 DLedger</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>$ <span class="token function">git</span> clone https://github.com/openmessaging/dledger.git
$ <span class="token builtin class-name">cd</span> dledger
$ mvn clean <span class="token function">install</span> <span class="token parameter variable">-DskipTests</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>构建 RocketMQ</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>$ <span class="token function">git</span> clone https://github.com/apache/rocketmq.git
$ <span class="token builtin class-name">cd</span> rocketmq
$ <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> develop origin/develop
$ mvn -Prelease-all <span class="token parameter variable">-DskipTests</span> clean <span class="token function">install</span> <span class="token parameter variable">-U</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>快速部署</p></blockquote> <p>在构建成功后:</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment">#{rocketmq-version} replace with rocketmq actual version. example: 5.1.0</span>
$ <span class="token builtin class-name">cd</span> distribution/target/rocketmq-<span class="token punctuation">{</span>rocketmq-version<span class="token punctuation">}</span>/rocketmq-<span class="token punctuation">{</span>rocketmq-version<span class="token punctuation">}</span>

$ <span class="token function">sh</span> bin/dledger/fast-try.sh start
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果上面的步骤执行成功, 可以通过 mqadmin 运维命令查看集群状态.</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>$ <span class="token function">sh</span> bin/mqadmin clusterList <span class="token parameter variable">-n</span> <span class="token number">127.0</span>.0.1:9876
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>顺利的话, 会看到如下内容:</p> <p>​<img src="/img/TB11Z-20240422215725-4sbtxsf.ZyCzqK1RjSZFLXXcn2XXa" alt="ClusterList">​</p> <p>BID 为 0 的表示 Master, 其余都是 Follower. 启动成功, 现在可以向集群收发消息, 并<strong>进行容灾切换测试</strong>了.</p> <p>关闭快速集群, 可以执行:</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>$ <span class="token function">sh</span> bin/dledger/fast-try.sh stop
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>快速部署, 默认配置在 conf/dledger 里面, 默认的存储路径在 /tmp/rmqstore.</p> <blockquote><p>容灾切换</p></blockquote> <p>部署成功, <strong>杀掉 Leader 之后</strong>(在上面的例子中, 杀掉端口 30931 所在的进程), 等待约 10s 左右, 用 clusterList 命令查看集群, 就会<strong>发现 Leader 切换到另一个节点</strong>了.</p> <h5 id="dledger集群搭建"><a href="#dledger集群搭建" class="header-anchor">#</a> Dledger集群搭建</h5> <p>本部分主要介绍如何部署自动容灾切换的 RocketMQ-on-DLedger Group.</p> <p>RocketMQ-on-DLedger Group 是指一组<strong>相同名称</strong>的 Broker, 至少需要 3 个节点, <strong>通过 Raft 自动选举出一个 Leader, 其余节点 作为 Follower, 并在 Leader 和 Follower 之间复制数据以保证高可用</strong>. RocketMQ-on-DLedger Group 能自动容灾切换, 并保证数据一致. RocketMQ-on-DLedger Group 是可以水平扩展的, 也即可以部署任意多个 RocketMQ-on-DLedger Group 同时对外提供服务.</p> <blockquote><p>1.1 编写配置</p></blockquote> <p>每个 RocketMQ-on-DLedger Group 至少准备三台机器(本文假设为 3). 编写 3 个配置文件, 建议参考 conf/dledger 目录下的配置文件样例. 关键配置介绍:</p> <table><thead><tr><th style="text-align:center;">name</th> <th>含义</th> <th>举例</th></tr></thead> <tbody><tr><td style="text-align:center;">enableDLegerCommitLog</td> <td>是否启动 DLedger</td> <td>true</td></tr> <tr><td style="text-align:center;">dLegerGroup</td> <td>DLedger Raft Group的名字, 建议和 brokerName 保持一致</td> <td>RaftNode00</td></tr> <tr><td style="text-align:center;">dLegerPeers</td> <td>DLedger Group 内各节点的端口信息, 同一个 Group 内的各个节点配置必须要保证一致</td> <td>n0-127.0.0.1:40911;n1-127.0.0.1:40912;n2-127.0.0.1:40913</td></tr> <tr><td style="text-align:center;">dLegerSelfId</td> <td>节点 id, 必须属于 dLegerPeers 中的一个; 同 Group 内各个节点要唯一</td> <td>n0</td></tr> <tr><td style="text-align:center;">sendMessageThreadPoolNums</td> <td>发送线程个数, 建议配置成 Cpu 核数</td> <td>16</td></tr></tbody></table> <p>这里贴出 conf/dledger/broker-n0.conf 的配置举例.</p> <div class="language-properties line-numbers-mode"><pre class="language-properties"><code><span class="token key attr-name">brokerClusterName</span> <span class="token punctuation">=</span> <span class="token value attr-value">RaftCluster</span>
<span class="token key attr-name">brokerName</span><span class="token punctuation">=</span><span class="token value attr-value">RaftNode00</span>
<span class="token key attr-name">listenPort</span><span class="token punctuation">=</span><span class="token value attr-value">30911</span>
<span class="token key attr-name">namesrvAddr</span><span class="token punctuation">=</span><span class="token value attr-value">127.0.0.1:9876</span>
<span class="token key attr-name">storePathRootDir</span><span class="token punctuation">=</span><span class="token value attr-value">/tmp/rmqstore/node00</span>
<span class="token key attr-name">storePathCommitLog</span><span class="token punctuation">=</span><span class="token value attr-value">/tmp/rmqstore/node00/commitlog</span>
<span class="token key attr-name">enableDLegerCommitLog</span><span class="token punctuation">=</span><span class="token value attr-value">true</span>
<span class="token key attr-name">dLegerGroup</span><span class="token punctuation">=</span><span class="token value attr-value">RaftNode00</span>
<span class="token key attr-name">dLegerPeers</span><span class="token punctuation">=</span><span class="token value attr-value">n0-127.0.0.1:40911;n1-127.0.0.1:40912;n2-127.0.0.1:40913</span>
<span class="token comment">## must be unique</span>
<span class="token key attr-name">dLegerSelfId</span><span class="token punctuation">=</span><span class="token value attr-value">n0</span>
<span class="token key attr-name">sendMessageThreadPoolNums</span><span class="token punctuation">=</span><span class="token value attr-value">16</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><blockquote><p>1.2 启动Broker</p></blockquote> <p>与老版本的启动方式一致.</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-c</span> conf/dledger/xxx-n0.conf <span class="token operator">&amp;</span> 
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-c</span> conf/dledger/xxx-n1.conf <span class="token operator">&amp;</span> 
$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqbroker <span class="token parameter variable">-c</span> conf/dledger/xxx-n2.conf <span class="token operator">&amp;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="权限控制"><a href="#权限控制" class="header-anchor">#</a> 权限控制</h4> <p><strong>权限控制(ACL)主要为 RocketMQ 提供 Topic 资源级别的高级访问控制功能</strong>. 用户在使用 RocketMQ 权限控制时, 可以在 Client 客户端注入用户名和密码参数实现签名, <strong>服务端通过权限控制参数实现各个资源的权限管理和校验</strong>.</p> <p>信息: ACL 控制在增强集群访问控制安全性的同时也会带来部署流程和运维管理的复杂度.</p> <p><strong>一般仅建议在网络环境不安全, 业务数据敏感, 多部门租户混用的场景下使用</strong>. 如果生产集群本身是私有集群不会被外部部门租户访问, 可以不开启.</p> <h4 id="jvm与os配置"><a href="#jvm与os配置" class="header-anchor">#</a> JVM与OS配置</h4> <p>本小节主要介绍系统(JVM/OS)相关的配置.</p> <h5 id="_1-jvm选项"><a href="#_1-jvm选项" class="header-anchor">#</a> 1.JVM选项</h5> <p>推荐使用最新发布的 JDK 版本. 通过<strong>设置相同的 Xms 和 Xmx 值来防止 JVM 调整堆大小以获得更好的性能</strong>. 生产环境 JVM 配置如下所示:</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>-server -Xms8g -Xmx8g -Xmn4g 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>当 JVM 是默认 8 字节对齐, <strong>建议配置最大堆内存不要超过 32G, 否则会影响 JVM 的指针压缩技术, 浪费内存</strong>.</p> <p>如果不关心 RocketMQ Broker 的启动时间, 还有一种更好的选择, 就是通过 &quot;预触摸&quot; Java 堆以确保在 JVM 初始化期间每个页面都将被分配. 那些不关心启动时间的人可以启用它:</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>-XX:+AlwaysPreTouch  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>信息: 生产环境集群 Broker 一般建议配置足够的内存, 避免使用小规格内存机器部署. <strong>因为 Broker 是重度依赖内存 PageCache 做性能优化的, 内存过小可能造成性能不稳定</strong>.</p> <p><strong>禁用偏置锁定可能会减少 JVM 暂停</strong>:</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>-XX:-UseBiasedLocking   
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>垃圾回收, <strong>建议使用 JDK 1.8 自带的 G1 收集器</strong>:</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>-XX:+UseG1GC 
-XX:G1HeapRegionSize=16m   
-XX:G1ReservePercent=25 
-XX:InitiatingHeapOccupancyPercent=30
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这些 GC 选项看起来有点激进, 但事实证明它在生产环境中具有良好的性能.</p> <p>另外不要把 -XX:MaxGCPauseMillis 的值设置太小, 否则 JVM 将使用一个小的年轻代来实现这个目标, 这将导致非常频繁的 minor GC, 所以建议使用 rolling GC 日志文件:</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>-XX:+UseGCLogFileRotation   
-XX:NumberOfGCLogFiles=5 
-XX:GCLogFileSize=30m
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果写入 GC 文件会增加代理的延迟, 可以考虑将 GC 日志文件重定向到内存文件系统:</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>-Xloggc:/dev/shm/mq_gc_%p.log123   
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h5 id="_2-linux内核参数"><a href="#_2-linux内核参数" class="header-anchor">#</a> 2.Linux内核参数</h5> <p><strong>os.sh 脚本在 bin 文件夹中列出了许多内核参数, 可以进行微小的更改然后用于生产用途</strong>. 下面的参数需要注意, 更多细节请参考 <code>/proc/sys/vm/*</code>​ 的<a href="https://www.kernel.org/doc/Documentation/sysctl/vm.txt" target="_blank" rel="noopener noreferrer">文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <ul><li><strong>vm.extra_free_kbytes</strong>: 告诉 VM 在后台回收(kswapd)启动的阈值与直接回收(通过分配进程)的阈值之间保留额外的可用内存. RocketMQ 使用此参数来避免内存分配中的长延迟.</li> <li><strong>vm.min_free_kbytes</strong>: 如果将其设置为低于 1024 KB, 将会巧妙的将系统破坏, 并且系统在高负载下容易出现死锁.</li> <li><strong>vm.max_map_count</strong>: 限制一个进程可能具有的最大内存映射区域数. RocketMQ 将使用 MMAP 加载 CommitLog 和 ConsumeQueue, 因此建议将为此参数设置较大的值.</li> <li><strong>vm.swappiness</strong>: 定义内核交换内存页面的积极程度. 较高的值会增加攻击性, 较低的值会减少交换量. 建议将值设置为 10 来避免交换延迟.</li> <li><strong>File descriptor limits</strong>: RocketMQ 需要为文件(CommitLog 和 ConsumeQueue)和网络连接打开文件描述符. <strong>建议设置文件描述符的值为 655350</strong>.</li> <li>Disk scheduler: RocketMQ 建议使用 I/O 截止时间调度器, 它试图为请求提供有保证的延迟.</li></ul> <h4 id="客户端sdk"><a href="#客户端sdk" class="header-anchor">#</a> 客户端SDK</h4> <p>本节文档介绍 RocketMQ 5.x 版本的客户端 SDK 演进历程, 选型对比和最佳实践.</p> <h5 id="演进历程-选型对比"><a href="#演进历程-选型对比" class="header-anchor">#</a> 演进历程&amp;选型对比</h5> <p>RocketMQ 项目自诞生之初演进到当前 5.x 版本, 根据<strong>底层通信协议的差异主要支持两个系列的客户端 SDK</strong>, 分别是 <strong>Remoting 协议和 gRPC 协议</strong>.</p> <p><strong>Remoting 协议</strong>作为早期组件间默认通信协议, 内置的客户端 SDK 一直和主仓库同步演进和迭代. <strong>Remoting 协议</strong> SDK 一直以绑定仓库的方式伴随服务端代码版本迭代, 主要支持 Java 为主的语言.</p> <p><mark><strong>gRPC 协议自 5.0 版本全新推出, 旨在以云原生主流技术演进更加轻量, 标准, 易扩展的客户端服务端通信协议</strong></mark>. <strong>gRPC 协议</strong> SDK 是以独立仓库<a href="https://github.com/apache/rocketmq-clients" target="_blank" rel="noopener noreferrer"> RocketMQ Clients <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>方式演进, 支持 Java/C++/.NET/Go/Rust 等语言. 客户端和服务端之间相对解耦, 遵循<a href="https://github.com/apache/rocketmq-apis" target="_blank" rel="noopener noreferrer"> RocketMQ API <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>协议接口约定.</p> <p>关于 Remoting 协议 SDK 和 gRPC 协议 SDK 的对比参考如下:</p> <table><thead><tr><th><strong>对比项</strong></th> <th><strong>Remoting 协议 SDK</strong></th> <th><strong>gRPC 协议 SDK</strong></th></tr></thead> <tbody><tr><td>多语言支持</td> <td>Java 为主, 其他语言为第三方仓库实现</td> <td>Java/C/C++/.NET/Go/Rust, 其他语言迭代中<br>详情参考<a href="https://github.com/apache/rocketmq-clients" target="_blank" rel="noopener noreferrer">链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td></tr> <tr><td>接口范围</td> <td>Producer<br>PushConsumer<br>PullConsumer<br>LitePullConsumer<br>Admin</td> <td>Producer<br>PushConsumer(仅Java)<br>SimpleConsumer<br>PullConsumer(进行中)</td></tr> <tr><td>兼容版本</td> <td>兼容 4.x, 5.x 版本服务端</td> <td><strong>仅支持 5.x 版本服务端</strong></td></tr> <tr><td>演进方向</td> <td>Remoting 协议主要作为服务端内部组件通信演进</td> <td>gRPC 协议作为轻量化多语言客户端首选, 后续逐步推广补齐所有能力</td></tr></tbody></table> <h5 id="remoting协议sdk"><a href="#remoting协议sdk" class="header-anchor">#</a> Remoting协议SDK</h5> <p>Remoting 协议 SDK 作为 RocketMQ 最初演进的 SDK, 使用 RocketMQ 内部组件的 Remoting 通信协议, 一方面用于服务内部组件的通信, 一方面也支持客户端收发消息和管控操作的 API 通信. Remoting 协议 SDK 和服务端主仓库同步演进迭代. 目前支持的开发语言和代码仓库详情如下:</p> <table><thead><tr><th><strong>语言</strong></th> <th><strong>ReleaseNote</strong></th> <th><strong>SDK仓库</strong></th></tr></thead> <tbody><tr><td>Java</td> <td><a href="https://github.com/apache/rocketmq/releases" target="_blank" rel="noopener noreferrer">主仓库版本列表<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td> <td><a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener noreferrer">主仓库地址<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td></tr> <tr><td>Go</td> <td><a href="https://github.com/apache/rocketmq-client-go/releases" target="_blank" rel="noopener noreferrer">主仓库版本列表<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td> <td><a href="https://github.com/apache/rocketmq-client-go" target="_blank" rel="noopener noreferrer">主仓库地址<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td></tr></tbody></table> <h5 id="grpc协议sdk"><a href="#grpc协议sdk" class="header-anchor">#</a> gRPC协议SDK</h5> <p>gRPC 协议 SDK 自 RocketMQ 5.0 版本, 旨在提供包含 Java, C++, C#, Golang, JavaScript, Rust 在内的所有主流编程语言的云原生的健壮的客户端解决方案. gRPC SDK 遵从 <a href="https://github.com/apache/rocketmq-apis" target="_blank" rel="noopener noreferrer">rocketmq-apis<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 约束, 使用 Protocol Buffers 和 gRPC 替代了 4.x 的旧有协议.</p> <p>gRPC SDK 相比早期 Remoting 协议 SDK 具备如下优势:</p> <ul><li>接口简洁性更好, 易理解, 不易错误使用.</li> <li>接口确定性设计更完善, 参数, 异常类型明确.</li> <li>接口不可变性设计, 避免透传, 漏传参数和信息导致的业务异常.</li> <li>多语言支持更完善, 由于 gRPC 协议的多语言优势, 可以更低成本演进出行为一致的多语言 sdk. 详细的设计思考和演进方向, 参考 <a href="https://shimo.im/docs/m5kv92OeRRU8olqX" target="_blank" rel="noopener noreferrer">RIP-37: New and Unified APIs<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和 <a href="https://shimo.im/docs/gXqmeEPYgdUw5bqo" target="_blank" rel="noopener noreferrer">RIP-39: Support gRPC protocol<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</li></ul> <p>目前支持的开发语言和代码仓库详情可直接参考 <a href="https://github.com/apache/rocketmq-clients#features-and-status" target="_blank" rel="noopener noreferrer">rocketmq-clients<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> SDK 仓库信息.</p> <p>‍</p> <h3 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h3> <ul><li>RocketMQ 官方文档: <a href="https://rocketmq.apache.org/zh/docs/" target="_blank" rel="noopener noreferrer">https://rocketmq.apache.org/zh/docs/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>《RocketMQ技术内幕》: <a href="https://blog.csdn.net/prestigeding/article/details/85233529" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/prestigeding/article/details/85233529<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>关于 RocketMQ 对 MappedByteBuffer 的一点优化: <a href="https://lishoubo.github.io/2017/09/27/MappedByteBuffer%E7%9A%84%E4%B8%80%E7%82%B9%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener noreferrer">https://lishoubo.github.io/2017/09/27/MappedByteBuffer%E7%9A%84%E4%B8%80%E7%82%B9%E4%BC%98%E5%8C%96/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>阿里中间件团队博客-十分钟入门RocketMQ: <a href="http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/" target="_blank" rel="noopener noreferrer">http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>分布式事务的种类以及 RocketMQ 支持的分布式消息: <a href="https://www.infoq.cn/article/2018/08/rocketmq-4.3-release" target="_blank" rel="noopener noreferrer">https://www.infoq.cn/article/2018/08/rocketmq-4.3-release<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>滴滴出行基于RocketMQ构建企业级消息队列服务的实践: <a href="https://yq.aliyun.com/articles/664608" target="_blank" rel="noopener noreferrer">https://yq.aliyun.com/articles/664608<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>基于《RocketMQ技术内幕》源码注释: <a href="https://github.com/LiWenGu/awesome-rocketmq" target="_blank" rel="noopener noreferrer">https://github.com/LiWenGu/awesome-rocketmq<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/30.系统/3000.系统/1100.中间件-消息队列/4.RocketMQ.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/4fc3f1/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Kafka</div></a> <a href="/pages/ed8d92/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Disruptor</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/4fc3f1/" class="prev">Kafka</a></span> <span class="next"><a href="/pages/ed8d92/">Disruptor</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/151.b7093623.js" defer></script>
  </body>
</html>
