<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>内存分配与垃圾收集 | Pangolin</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.76d9f797.css" as="style"><link rel="preload" href="/assets/js/app.5bc2c979.js" as="script"><link rel="preload" href="/assets/js/2.eccd4273.js" as="script"><link rel="preload" href="/assets/js/166.995d24ad.js" as="script"><link rel="prefetch" href="/assets/js/10.8a8038d8.js"><link rel="prefetch" href="/assets/js/100.db890b43.js"><link rel="prefetch" href="/assets/js/101.9b9a913e.js"><link rel="prefetch" href="/assets/js/102.b98098b4.js"><link rel="prefetch" href="/assets/js/103.20eafae5.js"><link rel="prefetch" href="/assets/js/104.5f942f86.js"><link rel="prefetch" href="/assets/js/105.a443c173.js"><link rel="prefetch" href="/assets/js/106.6530e112.js"><link rel="prefetch" href="/assets/js/107.7b05a1d1.js"><link rel="prefetch" href="/assets/js/108.8c45adc4.js"><link rel="prefetch" href="/assets/js/109.ea29e43c.js"><link rel="prefetch" href="/assets/js/11.8d2b228f.js"><link rel="prefetch" href="/assets/js/110.0765054b.js"><link rel="prefetch" href="/assets/js/111.ae06b85d.js"><link rel="prefetch" href="/assets/js/112.b27bb80e.js"><link rel="prefetch" href="/assets/js/113.592e5b3f.js"><link rel="prefetch" href="/assets/js/114.677c3c60.js"><link rel="prefetch" href="/assets/js/115.fb35062d.js"><link rel="prefetch" href="/assets/js/116.19de2d57.js"><link rel="prefetch" href="/assets/js/117.ac783334.js"><link rel="prefetch" href="/assets/js/118.06b27dd3.js"><link rel="prefetch" href="/assets/js/119.cf6bb932.js"><link rel="prefetch" href="/assets/js/12.8764d408.js"><link rel="prefetch" href="/assets/js/120.ba8e09a5.js"><link rel="prefetch" href="/assets/js/121.bc501a72.js"><link rel="prefetch" href="/assets/js/122.c9a3dd47.js"><link rel="prefetch" href="/assets/js/123.b474c20b.js"><link rel="prefetch" href="/assets/js/124.f405a8c5.js"><link rel="prefetch" href="/assets/js/125.24083f67.js"><link rel="prefetch" href="/assets/js/126.3c5c6c33.js"><link rel="prefetch" href="/assets/js/127.b561056f.js"><link rel="prefetch" href="/assets/js/128.58891fb1.js"><link rel="prefetch" href="/assets/js/129.5073fbfd.js"><link rel="prefetch" href="/assets/js/13.1034e1a1.js"><link rel="prefetch" href="/assets/js/130.ca12ca1d.js"><link rel="prefetch" href="/assets/js/131.8e520e7f.js"><link rel="prefetch" href="/assets/js/132.0f186ee2.js"><link rel="prefetch" href="/assets/js/133.1d8479f7.js"><link rel="prefetch" href="/assets/js/134.9c30d69b.js"><link rel="prefetch" href="/assets/js/135.91463dab.js"><link rel="prefetch" href="/assets/js/136.5e57454a.js"><link rel="prefetch" href="/assets/js/137.1d4e51f0.js"><link rel="prefetch" href="/assets/js/138.6cd3ac7f.js"><link rel="prefetch" href="/assets/js/139.7bd789a6.js"><link rel="prefetch" href="/assets/js/14.ead46968.js"><link rel="prefetch" href="/assets/js/140.e1d92390.js"><link rel="prefetch" href="/assets/js/141.23e11057.js"><link rel="prefetch" href="/assets/js/142.c8cc0f38.js"><link rel="prefetch" href="/assets/js/143.fc738cb7.js"><link rel="prefetch" href="/assets/js/144.67c64203.js"><link rel="prefetch" href="/assets/js/145.cc73ed45.js"><link rel="prefetch" href="/assets/js/146.adaac4c0.js"><link rel="prefetch" href="/assets/js/147.0e83b5c1.js"><link rel="prefetch" href="/assets/js/148.1f253a46.js"><link rel="prefetch" href="/assets/js/149.ab428593.js"><link rel="prefetch" href="/assets/js/15.198f32e1.js"><link rel="prefetch" href="/assets/js/150.64cd514e.js"><link rel="prefetch" href="/assets/js/151.ca1ae55a.js"><link rel="prefetch" href="/assets/js/152.4119b23d.js"><link rel="prefetch" href="/assets/js/153.ed663263.js"><link rel="prefetch" href="/assets/js/154.71b836f6.js"><link rel="prefetch" href="/assets/js/155.c47e2e88.js"><link rel="prefetch" href="/assets/js/156.3e91e0f4.js"><link rel="prefetch" href="/assets/js/157.811b1421.js"><link rel="prefetch" href="/assets/js/158.71193c19.js"><link rel="prefetch" href="/assets/js/159.f09778fd.js"><link rel="prefetch" href="/assets/js/16.03096de2.js"><link rel="prefetch" href="/assets/js/160.15d99de4.js"><link rel="prefetch" href="/assets/js/161.813166a0.js"><link rel="prefetch" href="/assets/js/162.c52bbf77.js"><link rel="prefetch" href="/assets/js/163.ada6991a.js"><link rel="prefetch" href="/assets/js/164.d8ceba57.js"><link rel="prefetch" href="/assets/js/165.a645ef3a.js"><link rel="prefetch" href="/assets/js/167.d7278e80.js"><link rel="prefetch" href="/assets/js/168.e388905a.js"><link rel="prefetch" href="/assets/js/169.52edabbb.js"><link rel="prefetch" href="/assets/js/17.a49f9c19.js"><link rel="prefetch" href="/assets/js/170.0b62c5b4.js"><link rel="prefetch" href="/assets/js/171.017c8997.js"><link rel="prefetch" href="/assets/js/172.f0763c39.js"><link rel="prefetch" href="/assets/js/173.c961bf43.js"><link rel="prefetch" href="/assets/js/174.395224c0.js"><link rel="prefetch" href="/assets/js/175.52fbdc96.js"><link rel="prefetch" href="/assets/js/176.14e0a3b2.js"><link rel="prefetch" href="/assets/js/177.78f7d89f.js"><link rel="prefetch" href="/assets/js/178.c08bdd65.js"><link rel="prefetch" href="/assets/js/179.b634397c.js"><link rel="prefetch" href="/assets/js/18.9786a034.js"><link rel="prefetch" href="/assets/js/180.284b6c99.js"><link rel="prefetch" href="/assets/js/181.b4744ee7.js"><link rel="prefetch" href="/assets/js/182.8bfd08cd.js"><link rel="prefetch" href="/assets/js/183.59b0b92b.js"><link rel="prefetch" href="/assets/js/184.a5fae95c.js"><link rel="prefetch" href="/assets/js/185.dcf55c72.js"><link rel="prefetch" href="/assets/js/186.6b1cf319.js"><link rel="prefetch" href="/assets/js/187.312708d0.js"><link rel="prefetch" href="/assets/js/188.71de21d0.js"><link rel="prefetch" href="/assets/js/189.7d72c108.js"><link rel="prefetch" href="/assets/js/19.089d6618.js"><link rel="prefetch" href="/assets/js/190.85dce0bd.js"><link rel="prefetch" href="/assets/js/191.08f7136b.js"><link rel="prefetch" href="/assets/js/192.6a155217.js"><link rel="prefetch" href="/assets/js/193.64f71670.js"><link rel="prefetch" href="/assets/js/194.c4d60c72.js"><link rel="prefetch" href="/assets/js/195.748850e9.js"><link rel="prefetch" href="/assets/js/196.887ef31c.js"><link rel="prefetch" href="/assets/js/197.4473c177.js"><link rel="prefetch" href="/assets/js/198.ea53a990.js"><link rel="prefetch" href="/assets/js/199.886f6490.js"><link rel="prefetch" href="/assets/js/20.a52783e8.js"><link rel="prefetch" href="/assets/js/200.7619a798.js"><link rel="prefetch" href="/assets/js/201.d3f5de5f.js"><link rel="prefetch" href="/assets/js/202.ed4c18cc.js"><link rel="prefetch" href="/assets/js/203.7937068e.js"><link rel="prefetch" href="/assets/js/204.3dbdd61c.js"><link rel="prefetch" href="/assets/js/205.52bc6fdf.js"><link rel="prefetch" href="/assets/js/206.4393998f.js"><link rel="prefetch" href="/assets/js/207.ec8e121d.js"><link rel="prefetch" href="/assets/js/208.f54d4e42.js"><link rel="prefetch" href="/assets/js/209.1bc5d06d.js"><link rel="prefetch" href="/assets/js/21.2e3bed21.js"><link rel="prefetch" href="/assets/js/210.2a3dc088.js"><link rel="prefetch" href="/assets/js/211.7084c526.js"><link rel="prefetch" href="/assets/js/212.de742850.js"><link rel="prefetch" href="/assets/js/213.fc775028.js"><link rel="prefetch" href="/assets/js/214.e338168c.js"><link rel="prefetch" href="/assets/js/215.3e89c57e.js"><link rel="prefetch" href="/assets/js/216.ecfe7587.js"><link rel="prefetch" href="/assets/js/217.14dcd4a2.js"><link rel="prefetch" href="/assets/js/218.ee7d57f7.js"><link rel="prefetch" href="/assets/js/219.c263c1e8.js"><link rel="prefetch" href="/assets/js/22.3d09766f.js"><link rel="prefetch" href="/assets/js/220.33f2bfd2.js"><link rel="prefetch" href="/assets/js/221.cd55e739.js"><link rel="prefetch" href="/assets/js/222.63107647.js"><link rel="prefetch" href="/assets/js/223.768ef403.js"><link rel="prefetch" href="/assets/js/224.54357078.js"><link rel="prefetch" href="/assets/js/225.b8e46582.js"><link rel="prefetch" href="/assets/js/226.1d0dcae9.js"><link rel="prefetch" href="/assets/js/227.a351c0a1.js"><link rel="prefetch" href="/assets/js/228.f7b8c278.js"><link rel="prefetch" href="/assets/js/229.8e4aba4d.js"><link rel="prefetch" href="/assets/js/23.b87e3933.js"><link rel="prefetch" href="/assets/js/230.186bd7a5.js"><link rel="prefetch" href="/assets/js/231.dad483e1.js"><link rel="prefetch" href="/assets/js/232.26555358.js"><link rel="prefetch" href="/assets/js/233.658ba0e4.js"><link rel="prefetch" href="/assets/js/234.7994cee0.js"><link rel="prefetch" href="/assets/js/235.3934d057.js"><link rel="prefetch" href="/assets/js/236.59cb6eac.js"><link rel="prefetch" href="/assets/js/237.baa1c655.js"><link rel="prefetch" href="/assets/js/238.8ee9f8ae.js"><link rel="prefetch" href="/assets/js/239.b0fe3966.js"><link rel="prefetch" href="/assets/js/24.afe2a3c4.js"><link rel="prefetch" href="/assets/js/240.d06483fa.js"><link rel="prefetch" href="/assets/js/241.81a2223e.js"><link rel="prefetch" href="/assets/js/242.8f6eee74.js"><link rel="prefetch" href="/assets/js/243.874461fa.js"><link rel="prefetch" href="/assets/js/244.ec0bb622.js"><link rel="prefetch" href="/assets/js/245.2ecf61f8.js"><link rel="prefetch" href="/assets/js/246.e7f6e55c.js"><link rel="prefetch" href="/assets/js/247.f32a1a4b.js"><link rel="prefetch" href="/assets/js/248.4302c4d8.js"><link rel="prefetch" href="/assets/js/249.9b0a4d9f.js"><link rel="prefetch" href="/assets/js/25.a22777b8.js"><link rel="prefetch" href="/assets/js/250.1295326c.js"><link rel="prefetch" href="/assets/js/251.d1cdb160.js"><link rel="prefetch" href="/assets/js/252.4e9d56fe.js"><link rel="prefetch" href="/assets/js/253.5a23b42d.js"><link rel="prefetch" href="/assets/js/254.8777547c.js"><link rel="prefetch" href="/assets/js/255.b8825033.js"><link rel="prefetch" href="/assets/js/256.0ee3689d.js"><link rel="prefetch" href="/assets/js/257.4a684795.js"><link rel="prefetch" href="/assets/js/258.ca696e72.js"><link rel="prefetch" href="/assets/js/259.fdf867d0.js"><link rel="prefetch" href="/assets/js/26.c84357e5.js"><link rel="prefetch" href="/assets/js/260.d35d60d5.js"><link rel="prefetch" href="/assets/js/261.c162cef5.js"><link rel="prefetch" href="/assets/js/262.8cbc5289.js"><link rel="prefetch" href="/assets/js/263.c05bbe4c.js"><link rel="prefetch" href="/assets/js/264.2e7c8f69.js"><link rel="prefetch" href="/assets/js/265.372a0632.js"><link rel="prefetch" href="/assets/js/266.49c38b9d.js"><link rel="prefetch" href="/assets/js/267.f7406d35.js"><link rel="prefetch" href="/assets/js/268.c7846c3e.js"><link rel="prefetch" href="/assets/js/269.e30bdc7f.js"><link rel="prefetch" href="/assets/js/27.0b3da7b9.js"><link rel="prefetch" href="/assets/js/270.8a3786ce.js"><link rel="prefetch" href="/assets/js/271.4b771c95.js"><link rel="prefetch" href="/assets/js/272.c710d2d6.js"><link rel="prefetch" href="/assets/js/273.43fb2872.js"><link rel="prefetch" href="/assets/js/274.d8a9dff2.js"><link rel="prefetch" href="/assets/js/275.c2812b68.js"><link rel="prefetch" href="/assets/js/276.406503c4.js"><link rel="prefetch" href="/assets/js/277.10c29e54.js"><link rel="prefetch" href="/assets/js/278.5f4b657a.js"><link rel="prefetch" href="/assets/js/279.84b86ae8.js"><link rel="prefetch" href="/assets/js/28.1c1fd5a6.js"><link rel="prefetch" href="/assets/js/280.8a2ba3b2.js"><link rel="prefetch" href="/assets/js/281.4a7f2b91.js"><link rel="prefetch" href="/assets/js/282.7b2f2668.js"><link rel="prefetch" href="/assets/js/283.455f93df.js"><link rel="prefetch" href="/assets/js/284.1a448478.js"><link rel="prefetch" href="/assets/js/285.19eebc05.js"><link rel="prefetch" href="/assets/js/286.5423cfc6.js"><link rel="prefetch" href="/assets/js/287.afbe115e.js"><link rel="prefetch" href="/assets/js/288.d4f4f247.js"><link rel="prefetch" href="/assets/js/289.da477465.js"><link rel="prefetch" href="/assets/js/29.103209e9.js"><link rel="prefetch" href="/assets/js/290.abf99800.js"><link rel="prefetch" href="/assets/js/291.71fe3ae6.js"><link rel="prefetch" href="/assets/js/292.455169ca.js"><link rel="prefetch" href="/assets/js/293.d23ffed4.js"><link rel="prefetch" href="/assets/js/294.1a753204.js"><link rel="prefetch" href="/assets/js/295.badfa110.js"><link rel="prefetch" href="/assets/js/296.344206a1.js"><link rel="prefetch" href="/assets/js/297.29e4f914.js"><link rel="prefetch" href="/assets/js/298.f9db8940.js"><link rel="prefetch" href="/assets/js/299.2253c1e7.js"><link rel="prefetch" href="/assets/js/3.e5ca1c51.js"><link rel="prefetch" href="/assets/js/30.e76a827e.js"><link rel="prefetch" href="/assets/js/300.e5bfd607.js"><link rel="prefetch" href="/assets/js/301.cc3e786e.js"><link rel="prefetch" href="/assets/js/302.7fdc62b6.js"><link rel="prefetch" href="/assets/js/303.b1db491f.js"><link rel="prefetch" href="/assets/js/304.18917b0f.js"><link rel="prefetch" href="/assets/js/305.d352aeb5.js"><link rel="prefetch" href="/assets/js/306.8bc72324.js"><link rel="prefetch" href="/assets/js/307.854b4037.js"><link rel="prefetch" href="/assets/js/308.6a0e4a18.js"><link rel="prefetch" href="/assets/js/309.d184df6f.js"><link rel="prefetch" href="/assets/js/31.7e4b200d.js"><link rel="prefetch" href="/assets/js/310.8e0af1ab.js"><link rel="prefetch" href="/assets/js/311.00bae85e.js"><link rel="prefetch" href="/assets/js/312.bc92cba9.js"><link rel="prefetch" href="/assets/js/313.8f70a987.js"><link rel="prefetch" href="/assets/js/314.8f190f1f.js"><link rel="prefetch" href="/assets/js/315.4b8506c7.js"><link rel="prefetch" href="/assets/js/316.5911c1f9.js"><link rel="prefetch" href="/assets/js/317.58cca547.js"><link rel="prefetch" href="/assets/js/318.4f23c053.js"><link rel="prefetch" href="/assets/js/319.941f5d3e.js"><link rel="prefetch" href="/assets/js/32.9c188bac.js"><link rel="prefetch" href="/assets/js/320.a3f15adc.js"><link rel="prefetch" href="/assets/js/321.14c74686.js"><link rel="prefetch" href="/assets/js/322.5f7b1b87.js"><link rel="prefetch" href="/assets/js/323.ab05eccb.js"><link rel="prefetch" href="/assets/js/324.292806ba.js"><link rel="prefetch" href="/assets/js/325.b96314dd.js"><link rel="prefetch" href="/assets/js/326.3d8f6329.js"><link rel="prefetch" href="/assets/js/327.49cf9268.js"><link rel="prefetch" href="/assets/js/328.be56ec05.js"><link rel="prefetch" href="/assets/js/329.8c390111.js"><link rel="prefetch" href="/assets/js/33.2435d797.js"><link rel="prefetch" href="/assets/js/330.b961e5fd.js"><link rel="prefetch" href="/assets/js/331.24ce8c0b.js"><link rel="prefetch" href="/assets/js/332.115b7546.js"><link rel="prefetch" href="/assets/js/333.957e0728.js"><link rel="prefetch" href="/assets/js/334.68825ff7.js"><link rel="prefetch" href="/assets/js/335.b662f33d.js"><link rel="prefetch" href="/assets/js/336.d8818747.js"><link rel="prefetch" href="/assets/js/337.9d24e096.js"><link rel="prefetch" href="/assets/js/338.3b669645.js"><link rel="prefetch" href="/assets/js/339.51cc2773.js"><link rel="prefetch" href="/assets/js/34.d57f3bb9.js"><link rel="prefetch" href="/assets/js/340.28cfadfb.js"><link rel="prefetch" href="/assets/js/341.4e6b0bdd.js"><link rel="prefetch" href="/assets/js/342.310c1a3e.js"><link rel="prefetch" href="/assets/js/343.0e61677a.js"><link rel="prefetch" href="/assets/js/344.340a39bd.js"><link rel="prefetch" href="/assets/js/345.fff51053.js"><link rel="prefetch" href="/assets/js/346.93c709db.js"><link rel="prefetch" href="/assets/js/347.dc863ac9.js"><link rel="prefetch" href="/assets/js/348.13c191d7.js"><link rel="prefetch" href="/assets/js/349.8aea43f7.js"><link rel="prefetch" href="/assets/js/35.e20cb4ac.js"><link rel="prefetch" href="/assets/js/350.49b72b87.js"><link rel="prefetch" href="/assets/js/351.3e6e6379.js"><link rel="prefetch" href="/assets/js/352.e2524a53.js"><link rel="prefetch" href="/assets/js/353.b71b2a33.js"><link rel="prefetch" href="/assets/js/354.a4720902.js"><link rel="prefetch" href="/assets/js/355.5a8970e1.js"><link rel="prefetch" href="/assets/js/356.353f0a9c.js"><link rel="prefetch" href="/assets/js/357.648060ca.js"><link rel="prefetch" href="/assets/js/358.643b787c.js"><link rel="prefetch" href="/assets/js/359.b1bc0c81.js"><link rel="prefetch" href="/assets/js/36.6a79f8ad.js"><link rel="prefetch" href="/assets/js/360.748faf07.js"><link rel="prefetch" href="/assets/js/361.cddfbfab.js"><link rel="prefetch" href="/assets/js/362.46990756.js"><link rel="prefetch" href="/assets/js/363.f4846a88.js"><link rel="prefetch" href="/assets/js/364.e7fd6af2.js"><link rel="prefetch" href="/assets/js/365.41693194.js"><link rel="prefetch" href="/assets/js/366.60931b9e.js"><link rel="prefetch" href="/assets/js/367.c7a310db.js"><link rel="prefetch" href="/assets/js/368.cae4028a.js"><link rel="prefetch" href="/assets/js/369.e3bcd2c2.js"><link rel="prefetch" href="/assets/js/37.4ccc31d6.js"><link rel="prefetch" href="/assets/js/370.2ea3b181.js"><link rel="prefetch" href="/assets/js/371.978056e5.js"><link rel="prefetch" href="/assets/js/372.aa13db83.js"><link rel="prefetch" href="/assets/js/373.f3791afe.js"><link rel="prefetch" href="/assets/js/374.b108af2d.js"><link rel="prefetch" href="/assets/js/375.dc75d5b1.js"><link rel="prefetch" href="/assets/js/376.8a663da6.js"><link rel="prefetch" href="/assets/js/38.9816dff1.js"><link rel="prefetch" href="/assets/js/39.03d551c0.js"><link rel="prefetch" href="/assets/js/4.611d42c4.js"><link rel="prefetch" href="/assets/js/40.ce442bf2.js"><link rel="prefetch" href="/assets/js/41.d596832c.js"><link rel="prefetch" href="/assets/js/42.29309c56.js"><link rel="prefetch" href="/assets/js/43.d47b7a06.js"><link rel="prefetch" href="/assets/js/44.87716237.js"><link rel="prefetch" href="/assets/js/45.d5ef3d2b.js"><link rel="prefetch" href="/assets/js/46.21cef7ff.js"><link rel="prefetch" href="/assets/js/47.75c67941.js"><link rel="prefetch" href="/assets/js/48.b94040d3.js"><link rel="prefetch" href="/assets/js/49.507fb28d.js"><link rel="prefetch" href="/assets/js/5.e6d623f8.js"><link rel="prefetch" href="/assets/js/50.4013f17e.js"><link rel="prefetch" href="/assets/js/51.6e81cba9.js"><link rel="prefetch" href="/assets/js/52.07e4aadf.js"><link rel="prefetch" href="/assets/js/53.1d325b49.js"><link rel="prefetch" href="/assets/js/54.79ff5e8c.js"><link rel="prefetch" href="/assets/js/55.77160bdd.js"><link rel="prefetch" href="/assets/js/56.a3041056.js"><link rel="prefetch" href="/assets/js/57.b7c0602c.js"><link rel="prefetch" href="/assets/js/58.a4af9a23.js"><link rel="prefetch" href="/assets/js/59.61a80d59.js"><link rel="prefetch" href="/assets/js/6.dc644b59.js"><link rel="prefetch" href="/assets/js/60.4ae1e1f0.js"><link rel="prefetch" href="/assets/js/61.b733273a.js"><link rel="prefetch" href="/assets/js/62.63b8d77d.js"><link rel="prefetch" href="/assets/js/63.46a84bd8.js"><link rel="prefetch" href="/assets/js/64.ce8c5891.js"><link rel="prefetch" href="/assets/js/65.8abe6836.js"><link rel="prefetch" href="/assets/js/66.6f9a9cf9.js"><link rel="prefetch" href="/assets/js/67.6bc415b9.js"><link rel="prefetch" href="/assets/js/68.b100ab24.js"><link rel="prefetch" href="/assets/js/69.5d9ed0d7.js"><link rel="prefetch" href="/assets/js/7.7da3e776.js"><link rel="prefetch" href="/assets/js/70.f213eb63.js"><link rel="prefetch" href="/assets/js/71.9dbed333.js"><link rel="prefetch" href="/assets/js/72.1129fb4b.js"><link rel="prefetch" href="/assets/js/73.7459f6b0.js"><link rel="prefetch" href="/assets/js/74.2364da14.js"><link rel="prefetch" href="/assets/js/75.72e5d347.js"><link rel="prefetch" href="/assets/js/76.7f1bc93d.js"><link rel="prefetch" href="/assets/js/77.7f9bb46a.js"><link rel="prefetch" href="/assets/js/78.16497536.js"><link rel="prefetch" href="/assets/js/79.1598ba88.js"><link rel="prefetch" href="/assets/js/8.91ce867e.js"><link rel="prefetch" href="/assets/js/80.d7595902.js"><link rel="prefetch" href="/assets/js/81.c808c887.js"><link rel="prefetch" href="/assets/js/82.49dc6011.js"><link rel="prefetch" href="/assets/js/83.6e151bae.js"><link rel="prefetch" href="/assets/js/84.9d3d5086.js"><link rel="prefetch" href="/assets/js/85.2c4d111e.js"><link rel="prefetch" href="/assets/js/86.cff98baa.js"><link rel="prefetch" href="/assets/js/87.655584a0.js"><link rel="prefetch" href="/assets/js/88.109ad4f1.js"><link rel="prefetch" href="/assets/js/89.46f7ed5c.js"><link rel="prefetch" href="/assets/js/9.8a2e5f54.js"><link rel="prefetch" href="/assets/js/90.1a91e9ca.js"><link rel="prefetch" href="/assets/js/91.26a98055.js"><link rel="prefetch" href="/assets/js/92.6ed9cb6e.js"><link rel="prefetch" href="/assets/js/93.14253412.js"><link rel="prefetch" href="/assets/js/94.54415bcf.js"><link rel="prefetch" href="/assets/js/95.0e1c9d0a.js"><link rel="prefetch" href="/assets/js/96.8654188f.js"><link rel="prefetch" href="/assets/js/97.d338a1d8.js"><link rel="prefetch" href="/assets/js/98.efa1e5c5.js"><link rel="prefetch" href="/assets/js/99.83fa6575.js">
    <link rel="stylesheet" href="/assets/css/0.styles.76d9f797.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin" class="logo"> <span class="site-name can-hide">Pangolin</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">中间件</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">读书笔记</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">个人</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/operating_system/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》</a></li><li class="dropdown-subitem"><a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》</a></li><li class="dropdown-subitem"><a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><a href="/basic/" class="link-title">基础</a> <span class="title" style="display:none;">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》</a></li><li class="dropdown-subitem"><a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》</a></li><li class="dropdown-subitem"><a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="页面" class="dropdown-title"><a href="/ui/" class="link-title">页面</a> <span class="title" style="display:none;">页面</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/0a83b083bdf257cb/" class="nav-link">CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatar.jpeg"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">中间件</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">读书笔记</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">个人</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/operating_system/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》</a></li><li class="dropdown-subitem"><a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》</a></li><li class="dropdown-subitem"><a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><a href="/basic/" class="link-title">基础</a> <span class="title" style="display:none;">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》</a></li><li class="dropdown-subitem"><a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》</a></li><li class="dropdown-subitem"><a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="页面" class="dropdown-title"><a href="/ui/" class="link-title">页面</a> <span class="title" style="display:none;">页面</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/0a83b083bdf257cb/" class="nav-link">CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>ORM框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/4553db/" class="sidebar-link">MyBatis</a></li><li><a href="/pages/d426ff/" class="sidebar-link">Spring集成MyBatis</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Java</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/45687a/" class="sidebar-link">基础</a></li><li><a href="/pages/669da3/" class="sidebar-link">Java基础</a></li><li><a href="/pages/06424b/" class="sidebar-link">类与继承</a></li><li><a href="/pages/a29a57/" class="sidebar-link">抽象类与接口</a></li><li><a href="/pages/575ca7/" class="sidebar-link">内部类</a></li><li><a href="/pages/1d42f5/" class="sidebar-link">枚举类</a></li><li><a href="/pages/68df7d/" class="sidebar-link">常用类</a></li><li><a href="/pages/208d9a/" class="sidebar-link">关键字</a></li><li><a href="/pages/19431a/" class="sidebar-link">注解</a></li><li><a href="/pages/98c0c9/" class="sidebar-link">异常</a></li><li><a href="/pages/a08fb2/" class="sidebar-link">泛型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>集合类</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/e52b1c/" class="sidebar-link">集合类</a></li><li><a href="/pages/20a058/" class="sidebar-link">集合容器类概述</a></li><li><a href="/pages/71ab62/" class="sidebar-link">ArrayList与LinkedList</a></li><li><a href="/pages/dd747b/" class="sidebar-link">ArrayDeque</a></li><li><a href="/pages/f0ecf7/" class="sidebar-link">PriorityQueue</a></li><li><a href="/pages/a577c4/" class="sidebar-link">HashMap与HashSet</a></li><li><a href="/pages/b65f71/" class="sidebar-link">LinkedHashMap</a></li><li><a href="/pages/02deb8/" class="sidebar-link">TreeMap与TreeSet</a></li><li><a href="/pages/8b70b6/" class="sidebar-link">WeakHashMap</a></li><li><a href="/pages/098b2b/" class="sidebar-link">CopyOnWriteArrayList</a></li><li><a href="/pages/380128/" class="sidebar-link">ConcurrentHashMap</a></li><li><a href="/pages/b23642/" class="sidebar-link">BlockingQueue</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/5d5b55/" class="sidebar-link">并发</a></li><li><a href="/pages/ef591d/" class="sidebar-link">多线程基础</a></li><li><a href="/pages/870f46/" class="sidebar-link">JMM与Volatile</a></li><li><a href="/pages/70bfda/" class="sidebar-link">JUC与AQS</a></li><li><a href="/pages/60c2c3/" class="sidebar-link">锁与互斥同步</a></li><li><a href="/pages/6e4dfa/" class="sidebar-link">显式锁与ReetrantLock</a></li><li><a href="/pages/a0d56d/" class="sidebar-link">线程安全总结</a></li><li><a href="/pages/b92a49/" class="sidebar-link">JUC组件与线程协作</a></li><li><a href="/pages/103bb5/" class="sidebar-link">Atomic原子变量与Unsafe类与CAS</a></li><li><a href="/pages/065f55/" class="sidebar-link">线程池与定时任务</a></li><li><a href="/pages/dd3660/" class="sidebar-link">ThreadLocal</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>IO</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/7db050/" class="sidebar-link">IO</a></li><li><a href="/pages/ccb0a7/" class="sidebar-link">文件操作</a></li><li><a href="/pages/45bc73/" class="sidebar-link">IO流操作</a></li><li><a href="/pages/404e82/" class="sidebar-link">网络IO操作</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Java高级特性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/396bd1/" class="sidebar-link">Java高级特性</a></li><li><a href="/pages/eaa98b/" class="sidebar-link">Lambda表达式</a></li><li><a href="/pages/40af88/" class="sidebar-link">流Stream</a></li><li><a href="/pages/402b10/" class="sidebar-link">反射</a></li><li><a href="/pages/a5ebcd/" class="sidebar-link">代理</a></li><li><a href="/pages/b48bfe/" class="sidebar-link">Java性能问题定位分析</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/20204f/" class="sidebar-link">其他</a></li><li><a href="/pages/e4cde0/" class="sidebar-link">杂记</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>规范&amp;amp;风格</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ee7259/" class="sidebar-link">规范&amp;amp;风格</a></li><li><a href="/pages/139e3f/" class="sidebar-link">代码整洁之道</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Spring</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ed8d11/" class="sidebar-link">Web基础</a></li><li><a href="/pages/a228d7/" class="sidebar-link">Spring(Boot)基础</a></li><li><a href="/pages/ecd8b6/" class="sidebar-link">Spring Boot应用整合</a></li><li><a href="/pages/76dc08/" class="sidebar-link">Spring MVC</a></li><li><a href="/pages/b9aa73/" class="sidebar-link">Spring AOP</a></li><li><a href="/pages/dc74be/" class="sidebar-link">Spring事务</a></li><li><a href="/pages/b43c8c/" class="sidebar-link">Spring IOC源码分析-概览</a></li><li><a href="/pages/d9b4a5/" class="sidebar-link">Spring IOC源码分析-getBean()</a></li><li><a href="/pages/59dd3e/" class="sidebar-link">Spring IOC源码分析-createBean()</a></li><li><a href="/pages/691b21/" class="sidebar-link">Spring AOP源码分析</a></li><li><a href="/pages/d31e18/" class="sidebar-link">Spring事务源码分析</a></li><li><a href="/pages/f16cdb/" class="sidebar-link">Spring Boot源码分析</a></li><li><a href="/pages/b13a90/" class="sidebar-link">Spring MVC源码分析</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JVM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/943c23/" class="sidebar-link">JVM内存区域与对象解析</a></li><li><a href="/pages/05acae/" aria-current="page" class="active sidebar-link">内存分配与垃圾收集</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/d09a16/" class="sidebar-link">JVM监控与故障处理工具</a></li><li><a href="/pages/06e4ad/" class="sidebar-link">类文件结构与类加载机制</a></li><li><a href="/pages/3d00d5/" class="sidebar-link">虚拟机方法调用与指令执行引擎</a></li><li><a href="/pages/eba070/" class="sidebar-link">程序编译与代码优化</a></li><li><a href="/pages/83896f/" class="sidebar-link">虚拟机调优及参数总结</a></li><li><a href="/pages/8a0034/" class="sidebar-link">GraalVM</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/f6cd57/" class="sidebar-link">数据库系统原理</a></li><li><a href="/pages/410bf5/" class="sidebar-link">MySQL必知必会</a></li><li><a href="/pages/495264/" class="sidebar-link">MySQL开发与优化</a></li><li><a href="/pages/ec7e76/" class="sidebar-link">MySQL架构与日志</a></li><li><a href="/pages/4dbe1f/" class="sidebar-link">MySQL索引</a></li><li><a href="/pages/cbc7ab/" class="sidebar-link">MySQL优化</a></li><li><a href="/pages/4afd3a/" class="sidebar-link">MySQL锁机制与事务并发控制</a></li><li><a href="/pages/412461/" class="sidebar-link">MySQL高级特性</a></li><li><a href="/pages/41888c/" class="sidebar-link">MySQL设计规范</a></li><li><a href="/pages/087de5/" class="sidebar-link">MySQL架构篇</a></li><li><a href="/pages/b0952c/" class="sidebar-link">MySQL复制</a></li><li><a href="/pages/ee884d/" class="sidebar-link">MySQL高可用</a></li><li><a href="/pages/6d4f47/" class="sidebar-link">MySQL运维篇</a></li><li><a href="/pages/b8bad7/" class="sidebar-link">MySQL常用工具</a></li><li><a href="/pages/8bd691/" class="sidebar-link">MySQL日志</a></li><li><a href="/pages/5db7ef/" class="sidebar-link">MySQL备份与恢复</a></li><li><a href="/pages/3e3d3a/" class="sidebar-link">MySQL权限与安全</a></li><li><a href="/pages/5f2a5c/" class="sidebar-link">MySQL监控</a></li><li><a href="/pages/bf28eb/" class="sidebar-link">数据库LeetCode题目</a></li><li><a href="/pages/d4f878/" class="sidebar-link">数据库面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工具</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/2bed26/" class="sidebar-link">Arthas</a></li><li><a href="/pages/84ff17/" class="sidebar-link">CICD</a></li><li><a href="/pages/a7e6ff/" class="sidebar-link">Maven</a></li><li><a href="/pages/2a3f45/" class="sidebar-link">Typora主题</a></li><li><a href="/pages/f28f56/" class="sidebar-link">VuePress</a></li><li><a href="/pages/9d673a/" class="sidebar-link">思源笔记</a></li><li><a href="/pages/538b8a/" class="sidebar-link">环境搭建</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>ORM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c83270/" class="sidebar-link">MyBatis</a></li><li><a href="/pages/29ba44/" class="sidebar-link">Spring集成MyBatis</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/e55b6f/" class="sidebar-link">测试基础</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/develop/#开发" data-v-06225672>开发</a></li><li data-v-06225672><a href="/develop/#JVM" data-v-06225672>JVM</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06225672>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-06-08</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><!---->内存分配与垃圾收集<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_2-内存分配与垃圾收集"><a href="#_2-内存分配与垃圾收集" class="header-anchor">#</a> 2.内存分配与垃圾收集</h1> <p>JVM 需解决问题: 对象是如何分配内存的? 何时进行垃圾回收? 怎么回收? Java 自动内存管理最核心的功能是<strong>堆</strong>内存中对象<strong>内存的分配与回收</strong>.</p> <h4 id="堆的基本结构"><a href="#堆的基本结构" class="header-anchor">#</a> 堆的基本结构</h4> <p>HotSpot 虚拟机堆内存的基本结构如下, 分为:</p> <ul><li><strong>新生代</strong>: 含 Eden 区, From Survivor 区和 To Survivor 区.</li> <li><strong>老年代</strong></li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220517230027658.png" alt=""></p> <p>Java 堆是垃圾收集器管理的主要区域, 因此也被称作 <strong>GC 堆(Garbage Collected Heap)</strong>. 从垃圾回收的角度, 由于现在收集器基本都采用<strong>分代垃圾收集算法</strong>, 所以 Java 堆还可以细分为: <strong>新生代和老年代</strong>. 再细致一点分的话分成: Eden 空间, From Survivor, To Survivor 空间等. <strong>进一步划分的目的是更好地回收内存, 或者更快地分配内存</strong>.</p> <blockquote><p>S0 与 S1 的区别与联系?</p></blockquote> <p>经过一次 GC 后, Eden 区和 &quot;From&quot; 区已经被<strong>清空</strong>. 这个时候, &quot;From&quot; 和 &quot;To&quot; 会<strong>交换</strong>他们的角色(复制), 也就是新的 &quot;To&quot; 就是上次 GC 前的 &quot;From&quot;, 新的 &quot;From&quot; 就是上次 GC 前的 &quot;To&quot;.</p> <p>不管怎样, 都会保证名为 <strong>To</strong> 的 Survivor 区域是<strong>空的</strong>. Minor GC 会一直重复这样的过程, 直到 &quot;To&quot; 区被填满, &quot;To&quot; 区被填满之后, 会将所有对象移动到<strong>老年代</strong>中. 这两个区一次<strong>只用一个</strong>, Minor GC 时采用<strong>复制算法</strong>将 Eden 区和一个 Survivor 区的存活对象复制到另一个 Survivor 区中. 因此在新生代中垃圾回收算法多为<strong>复制算法</strong>.</p> <h4 id="对象的内存分配策略"><a href="#对象的内存分配策略" class="header-anchor">#</a> 对象的内存分配策略</h4> <p>对象内存分配流程图大体如下所示.</p> <p><img src="assets/image-20230325163536-k63gzvs.png" alt="https://www.processon.com/diagraming/641ea4c11fae9069cfbe5358"></p> <p>基于上述<strong>堆结构</strong>的划分, 以下是 Hotspot 虚拟机在 <strong>Serial/Serial Old</strong> 收集器下(<strong>注意这个前提</strong>)的内存分配与回收策略</p> <h5 id="_1-对象栈上分配"><a href="#_1-对象栈上分配" class="header-anchor">#</a> 1.对象栈上分配</h5> <p>普遍的认识是对象都在堆区分配, 但是也可能分配到虚拟机栈上.</p> <p>大部分对象都是在堆上进行分配, 当对象没有被引用的时候, 需要依靠 GC 进行回收内存, 如果对象数量较多的时候, 会给 GC 带来较大压力, 也间接影响了应用的性能. 为了减少临时对象在堆内分配的数量, JVM 通过逃逸分析确定该对象不会被外部访问. 如果不会逃逸可以<strong>将该对象在栈上分配内存</strong>, 这样<strong>该对象所占用的内存空间就可以随栈帧出栈而销毁, 就减轻了垃圾回收的压力</strong>.</p> <p>对象逃逸分析: 就是分析对象动态作用域, 当一个对象在方法中被定义后, 它可能被外部方法所引用, 例如作为调用参数传递到其他地方中.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;Jack&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">// TODO 保存到数据库</span>
   <span class="token keyword">return</span> user<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;Jack&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">// TODO 保存到数据库</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>很显然 test1() 方法中的 user 对象被返回了, 这个对象的作用域范围不确定, test2() 方法中的 user 对象可以确定当方法结束这个对象就可以认为是无效对象了, 对于这样的对象其实可以将其分配在栈内存里, 让其在方法结束时跟随栈内存一起被回收掉.</p> <p>JVM 对于这种情况可以通过开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置, 使其通过标量替换优先分配在栈上(栈上分配), JDK7 之后默认开启逃逸分析, 如果要关闭使用参数(-XX:-DoEscapeAnalysis)</p> <p><strong>标量替换</strong>: 通过逃逸分析确定该对象不会被外部访问, 并且对象可以被进一步分解时, JVM 不会创建该对象, 而是<strong>将该对象成员变量分解若干个被这个方法使用的成员变量</strong>所代替, 这些代替的成员变量在栈帧或寄存器上分配空间, 这样就不会因为没有一大块连续空间导致对象内存不够分配. 开启标量替换参数(-XX:+EliminateAllocations), JDK7 之后默认开启.</p> <p>标量与聚合量: 标量即不可被进一步分解的量, 而 JAVA 的基本数据类型就是标量(如: int, long等基本数据类型以及 reference 类型等), 标量的对立就是可以被进一步分解的量, 而这种量称之为聚合量. 而在 JAVA 中对象就是可以被进一步分解的聚合量.</p> <p>栈上分配对象示例:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * 栈上分配, 标量替换
 * 代码调用了1亿次alloc(), 如果是分配到堆上, 大概需要1GB以上堆空间, 如果堆空间小于该值, 必然会触发GC. 
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AllotOnStack</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;Jack&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>对于上面的测试, 如果采用如下的参数执行, 则一般不会发生 GC. 其实就是开启了逃逸分析和标量替换, 使得 user 对象都分配到栈上了, 方法结束后就被销毁了, 所以不会 GC.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 使用如下参数不会发生GC</span>
<span class="token operator">-</span><span class="token class-name">Xmx15m</span> <span class="token operator">-</span><span class="token class-name">Xms15m</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">DoEscapeAnalysis</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">PrintGC</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">EliminateAllocations</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果使用下面的参数执行代码, 也就是关闭逃逸分析和标量替换, 使得 user 对象都分配到堆上了, 方法结束后对象一直在堆中, 从而触发了较多的 GC.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 使用如下参数都会发生大量GC</span>
<span class="token operator">-</span><span class="token class-name">Xmx15m</span> <span class="token operator">-</span><span class="token class-name">Xms15m</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">-</span><span class="token class-name">DoEscapeAnalysis</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">PrintGC</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">EliminateAllocations</span>
<span class="token operator">-</span><span class="token class-name">Xmx15m</span> <span class="token operator">-</span><span class="token class-name">Xms15m</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">DoEscapeAnalysis</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">PrintGC</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">-</span><span class="token class-name">EliminateAllocations</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>结论: 栈上分配依赖于逃逸分析和标量替换.</strong></p> <h5 id="_2-对象在eden区分配"><a href="#_2-对象在eden区分配" class="header-anchor">#</a> 2.对象在Eden区分配</h5> <p>大多数情况下, 对象优先在<strong>新生代的 Eden 区</strong> 上分配, 当 Eden 空间不够时则触发 <strong>Minor GC</strong>, Minor GC 后存活的<strong>对象 Survivor 区放不下, 则会被移到老年代</strong>.</p> <p>看看 demo: 添加 -XX:+PrintGCDetails 可以<strong>打印 GC 日志</strong>. 这里分配 <strong>Eden 区</strong>大概 60M, From 与 To 区大概 10M.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 添加运行JVM参数: -XX:+PrintGCDetails</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GCTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">;</span>
        <span class="token comment">// 这里分配60M空间</span>
        allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">60000</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>运行结果:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Heap</span>
<span class="token class-name">PSYoungGen</span>      total <span class="token number">76288</span>K<span class="token punctuation">,</span> used <span class="token number">65536</span>K <span class="token punctuation">[</span><span class="token number">0x000000076b400000</span><span class="token punctuation">,</span> <span class="token number">0x0000000770900000</span><span class="token punctuation">,</span> <span class="token number">0x00000007c0000000</span><span class="token punctuation">)</span>
<span class="token comment">// Eden区用了100%</span>
eden space <span class="token number">65536</span>K<span class="token punctuation">,</span> <span class="token number">100</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x000000076b400000</span><span class="token punctuation">,</span><span class="token number">0x000000076f400000</span><span class="token punctuation">,</span><span class="token number">0x000000076f400000</span><span class="token punctuation">)</span>
from space <span class="token number">10752</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x000000076fe80000</span><span class="token punctuation">,</span><span class="token number">0x000000076fe80000</span><span class="token punctuation">,</span><span class="token number">0x0000000770900000</span><span class="token punctuation">)</span>
<span class="token keyword">to</span>   <span class="token namespace">space</span> <span class="token number">10752</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x000000076f400000</span><span class="token punctuation">,</span><span class="token number">0x000000076f400000</span><span class="token punctuation">,</span><span class="token number">0x000000076fe80000</span><span class="token punctuation">)</span>
<span class="token comment">// 老年代用了0K</span>
<span class="token class-name">ParOldGen</span>       total <span class="token number">175104</span>K<span class="token punctuation">,</span> used <span class="token number">0</span>K <span class="token punctuation">[</span><span class="token number">0x00000006c1c00000</span><span class="token punctuation">,</span> <span class="token number">0x00000006cc700000</span><span class="token punctuation">,</span> <span class="token number">0x000000076b400000</span><span class="token punctuation">)</span>
object space <span class="token number">175104</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000006c1c00000</span><span class="token punctuation">,</span><span class="token number">0x00000006c1c00000</span><span class="token punctuation">,</span><span class="token number">0x00000006cc700000</span><span class="token punctuation">)</span>
<span class="token comment">// 元空间</span>
<span class="token class-name">Metaspace</span>       used <span class="token number">3342</span>K<span class="token punctuation">,</span> capacity <span class="token number">4496</span>K<span class="token punctuation">,</span> committed <span class="token number">4864</span>K<span class="token punctuation">,</span> reserved <span class="token number">1056768</span>K
<span class="token keyword">class</span> space    used <span class="token number">361</span>K<span class="token punctuation">,</span> capacity <span class="token number">388</span>K<span class="token punctuation">,</span> committed <span class="token number">512</span>K<span class="token punctuation">,</span> reserved <span class="token number">1048576</span>K
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>可以看出 eden 区内存几乎已经<strong>被分配完全</strong>. <strong>假如再为 allocation2 分配内存会出现什么情况?</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 添加运行JVM参数: -XX:+PrintGCDetails</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GCTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token punctuation">;</span>
        <span class="token comment">// 这里分配60M</span>
        allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">60000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 这里再分配8M</span>
        allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">8000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>运行结果:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token punctuation">[</span><span class="token constant">GC</span> <span class="token punctuation">(</span><span class="token class-name">Allocation</span> <span class="token class-name">Failure</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token class-name">PSYoungGen</span><span class="token operator">:</span> <span class="token number">65253</span>K<span class="token operator">-&gt;</span><span class="token function">936K</span><span class="token punctuation">(</span><span class="token number">76288</span>K<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token number">65253</span>K<span class="token operator">-&gt;</span><span class="token function">60944K</span><span class="token punctuation">(</span><span class="token number">251392</span>K<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0279083</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token class-name">Times</span><span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.13</span> sys<span class="token operator">=</span><span class="token number">0.02</span><span class="token punctuation">,</span> real<span class="token operator">=</span><span class="token number">0.03</span> secs<span class="token punctuation">]</span> 
<span class="token class-name">Heap</span>
<span class="token comment">// 年轻代用了9591K, 大概就是8M+其他的一些内部对象的内存</span>
<span class="token class-name">PSYoungGen</span>      total <span class="token number">76288</span>K<span class="token punctuation">,</span> used <span class="token number">9591</span>K <span class="token punctuation">[</span><span class="token number">0x000000076b400000</span><span class="token punctuation">,</span> <span class="token number">0x0000000774900000</span><span class="token punctuation">,</span> <span class="token number">0x00000007c0000000</span><span class="token punctuation">)</span>
eden space <span class="token number">65536</span>K<span class="token punctuation">,</span> <span class="token number">13</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x000000076b400000</span><span class="token punctuation">,</span><span class="token number">0x000000076bc73ef8</span><span class="token punctuation">,</span><span class="token number">0x000000076f400000</span><span class="token punctuation">)</span>
from space <span class="token number">10752</span>K<span class="token punctuation">,</span> <span class="token number">8</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x000000076f400000</span><span class="token punctuation">,</span><span class="token number">0x000000076f4ea020</span><span class="token punctuation">,</span><span class="token number">0x000000076fe80000</span><span class="token punctuation">)</span>
<span class="token keyword">to</span>   <span class="token namespace">space</span> <span class="token number">10752</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x0000000773e80000</span><span class="token punctuation">,</span><span class="token number">0x0000000773e80000</span><span class="token punctuation">,</span><span class="token number">0x0000000774900000</span><span class="token punctuation">)</span>
<span class="token comment">// 老年代用了60M</span>
<span class="token class-name">ParOldGen</span>       total <span class="token number">175104</span>K<span class="token punctuation">,</span> used <span class="token number">60008</span>K <span class="token punctuation">[</span><span class="token number">0x00000006c1c00000</span><span class="token punctuation">,</span> <span class="token number">0x00000006cc700000</span><span class="token punctuation">,</span> <span class="token number">0x000000076b400000</span><span class="token punctuation">)</span>
object space <span class="token number">175104</span>K<span class="token punctuation">,</span> <span class="token number">34</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000006c1c00000</span><span class="token punctuation">,</span><span class="token number">0x00000006c569a010</span><span class="token punctuation">,</span><span class="token number">0x00000006cc700000</span><span class="token punctuation">)</span>
<span class="token class-name">Metaspace</span>       used <span class="token number">3342</span>K<span class="token punctuation">,</span> capacity <span class="token number">4496</span>K<span class="token punctuation">,</span> committed <span class="token number">4864</span>K<span class="token punctuation">,</span> reserved <span class="token number">1056768</span>K
<span class="token keyword">class</span> space    used <span class="token number">361</span>K<span class="token punctuation">,</span> capacity <span class="token number">388</span>K<span class="token punctuation">,</span> committed <span class="token number">512</span>K<span class="token punctuation">,</span> reserved <span class="token number">1048576</span>K
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>对比之前, 可以看到<strong>第一行</strong>就打印了 GC 日志.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token punctuation">[</span><span class="token constant">GC</span> <span class="token punctuation">(</span><span class="token class-name">Allocation</span> <span class="token class-name">Failure</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token class-name">PSYoungGen</span><span class="token operator">:</span> <span class="token number">65253</span>K<span class="token operator">-&gt;</span><span class="token function">936K</span><span class="token punctuation">(</span><span class="token number">76288</span>K<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token number">65253</span>K<span class="token operator">-&gt;</span><span class="token function">60944K</span><span class="token punctuation">(</span><span class="token number">251392</span>K<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0279083</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token class-name">Times</span><span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.13</span> sys<span class="token operator">=</span><span class="token number">0.02</span><span class="token punctuation">,</span> real<span class="token operator">=</span><span class="token number">0.03</span> secs<span class="token punctuation">]</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这里就是第一次在 Eden 区放了一个 <strong>60M</strong> 的大对象, 第二次分配 8M 对象时, <strong>Eden 区满了</strong>, 触发一次 <strong>Minor GC</strong>, 就会尝试将 60M 的放到 <strong>From 区</strong>, 但是 From 区只有 10M 放不下, 所以把原来 <strong>60M 的对象放到老年代</strong>. 之后就会把 <strong>8M 新对象</strong>放到 Eden 区中. 因为给 allocation2 分配内存的时候 eden 区内存<strong>几乎已经被分配完</strong>了, 当 Eden 区没有足够空间进行分配时, 虚拟机将发起一次 Minor GC, GC 期间虚拟机又发现 allocation1 无法存入 Survior 空间, 所以只好把<strong>新生代</strong>的对象<strong>提前转移到老年代</strong>中去, 老年代上的空间<strong>足够存放 allocation1</strong>, 所以不会出现 <strong>Full GC</strong>. 执行 Minor GC 后, 后面分配的对象如果能够存在 eden 区的话, 还是会在 eden 区分配内存.</p> <p>下面验证一下再加几个 <strong>1M</strong> 的小对象:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GCTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token punctuation">,</span> allocation3<span class="token punctuation">,</span> allocation4<span class="token punctuation">,</span> allocation5<span class="token punctuation">,</span> allocation6<span class="token punctuation">;</span>
        <span class="token comment">// 60M的对象</span>
        allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">60000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 8M的对象</span>
        allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">8000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 再加几个1M的对象</span>
        allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        allocation5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        allocation6 <span class="token operator">=</span> <span class="token keyword">new</span> sbyte<span class="token punctuation">[</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>测试结果:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token punctuation">[</span><span class="token constant">GC</span> <span class="token punctuation">(</span><span class="token class-name">Allocation</span> <span class="token class-name">Failure</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token class-name">PSYoungGen</span><span class="token operator">:</span> <span class="token number">65253</span>K<span class="token operator">-&gt;</span><span class="token function">952K</span><span class="token punctuation">(</span><span class="token number">76288</span>K<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token number">65253</span>K<span class="token operator">-&gt;</span><span class="token function">60960K</span><span class="token punctuation">(</span><span class="token number">251392</span>K<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0311467</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token class-name">Times</span><span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.08</span> sys<span class="token operator">=</span><span class="token number">0.02</span><span class="token punctuation">,</span> real<span class="token operator">=</span><span class="token number">0.03</span> secs<span class="token punctuation">]</span> 
<span class="token class-name">Heap</span>
<span class="token class-name">PSYoungGen</span> total <span class="token number">76288</span>K<span class="token punctuation">,</span> used <span class="token number">13878</span>K <span class="token punctuation">[</span><span class="token number">0x000000076b400000</span><span class="token punctuation">,</span> <span class="token number">0x0000000774900000</span><span class="token punctuation">,</span> <span class="token number">0x00000007c0000000</span><span class="token punctuation">)</span>
<span class="token comment">// 新的几个1M对象分配到Eden区</span>
eden space <span class="token number">65536</span>K<span class="token punctuation">,</span> <span class="token number">19</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x000000076b400000</span><span class="token punctuation">,</span><span class="token number">0x000000076c09fb68</span><span class="token punctuation">,</span><span class="token number">0x000000076f400000</span><span class="token punctuation">)</span>
from space <span class="token number">10752</span>K<span class="token punctuation">,</span> <span class="token number">8</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x000000076f400000</span><span class="token punctuation">,</span><span class="token number">0x000000076f4ee030</span><span class="token punctuation">,</span><span class="token number">0x000000076fe80000</span><span class="token punctuation">)</span>
<span class="token keyword">to</span>   <span class="token namespace">space</span> <span class="token number">10752</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x0000000773e80000</span><span class="token punctuation">,</span><span class="token number">0x0000000773e80000</span><span class="token punctuation">,</span><span class="token number">0x0000000774900000</span><span class="token punctuation">)</span>
<span class="token comment">// 老年代没变化</span>
<span class="token class-name">ParOldGen</span>       total <span class="token number">175104</span>K<span class="token punctuation">,</span> used <span class="token number">60008</span>K <span class="token punctuation">[</span><span class="token number">0x00000006c1c00000</span><span class="token punctuation">,</span> <span class="token number">0x00000006cc700000</span><span class="token punctuation">,</span> <span class="token number">0x000000076b400000</span><span class="token punctuation">)</span>
object space <span class="token number">175104</span>K<span class="token punctuation">,</span> <span class="token number">34</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000006c1c00000</span><span class="token punctuation">,</span><span class="token number">0x00000006c569a010</span><span class="token punctuation">,</span><span class="token number">0x00000006cc700000</span><span class="token punctuation">)</span>
<span class="token class-name">Metaspace</span>       used <span class="token number">3343</span>K<span class="token punctuation">,</span> capacity <span class="token number">4496</span>K<span class="token punctuation">,</span> committed <span class="token number">4864</span>K<span class="token punctuation">,</span> reserved <span class="token number">1056768</span>K
<span class="token keyword">class</span> space    used <span class="token number">361</span>K<span class="token punctuation">,</span> capacity <span class="token number">388</span>K<span class="token punctuation">,</span> committed <span class="token number">512</span>K<span class="token punctuation">,</span> reserved <span class="token number">1048576</span>K
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>跟上面的类似, 新增的几个比较小的 <strong>1M</strong> 的对象都是分配在 <strong>Eden 区</strong>的.</p> <blockquote><p>Eden与Survivor区默认8:1:1</p></blockquote> <p>大量的对象被分配在 <strong>eden 区</strong>, eden 区满了后会触发 <strong>Minor GC</strong>, 可能会有 99% 以上的对象成为垃圾被回收掉, 剩余存活的对象会被挪到为空的那块 survivor 区, 下一次 eden 区满了后又会触发 Minor GC, 把 eden 区和 survivor 区的垃圾对象回收, 把剩余存活的对象一次性挪动到另外一块为空的 survivor 区, 因为新生代的对象大部分都是朝生夕死的, <strong>存活时间很短, 所以 JVM 默认的 8:1:1 的比例是很合适的</strong>, 让 eden 区尽量的大, survivor 区够用即可.</p> <p>JVM 默认有这个参数 -XX:+UseAdaptiveSizePolicy(默认开启), 会导致这个 8:1:1 比例自动变化, 因此线上实际可能不是这个比例值. 如果不想这个比例有变化可以设置参数 -XX:-UseAdaptiveSizePolicy.</p> <h5 id="_3-大对象直接进入老年代"><a href="#_3-大对象直接进入老年代" class="header-anchor">#</a> 3.大对象直接进入老年代</h5> <p><strong>大对象</strong>是指需要<strong>连续内存空间</strong>的对象, 最典型的大对象是<strong>很长的字符串及数组</strong>. 如果一个对象的大小直接已经超过了 Eden 区的大小, 则<strong>直接就放到老年代</strong>了. 经常出现大对象会提<strong>前触</strong>发垃圾收集以获取足够的连续空间分配给大对象. 避免为大对象分配内存时由于<strong>分配担保机制</strong>带来的复制而<strong>降低效率</strong>.</p> <p><strong>Serial 和 ParNew 两个垃圾收集器</strong>可以使用参数 <strong>-XX:PretenureSizeThreshold</strong> 配置大于此值的对象<strong>直接在老年代</strong>分配, 避免在 Eden 和 Survivor 之间的大量内存复制(新生代采用复制算法收集内存).</p> <p><strong>为什么要这样呢? ​</strong>​<strong><strong>这是为了避免为</strong></strong>​<strong>大对象分配内存时的复制操作而降低效率</strong>. 举个例子: 如果 Eden 区 60M, From 和 To 都是 10M, 当一个对象 4M 时, 假设会一直引用这个对象, 那么这个 4M 的对象就会因为 Minor GC 在 From 和 To 之间不断移动, 影响 GC 性能.</p> <h5 id="_4-长期存活的对象进入老年代"><a href="#_4-长期存活的对象进入老年代" class="header-anchor">#</a> 4.长期存活的对象进入老年代</h5> <p>既然虚拟机采用了分代收集的思想来管理内存, 那么内存回收时就必须能识别哪些对象应放在新生代, 哪些对象应放在老年代中. 因此虚拟机给每个对象设置了一个<strong>对象年龄(Age)计数器</strong>.</p> <p>对象在 Eden 出生并经过 <strong>Minor GC</strong> 依然存活, 将移动到 <strong>Survivor</strong> 中, 年龄就增加 1 岁, 增加到<strong>一定年龄</strong>则移动到老年代中. 默认晋升年龄并不都是 <strong>15</strong>, 这个是要<strong>区分垃圾收集器</strong>的, CMS 就是 6.</p> <p>如果对象在 Eden 出生并经过第一次 <strong>Minor GC</strong> 后仍然能够存活, 并且能被 <strong>Survivor 容纳</strong>的话, 将被移动到 Survivor 空间中, 并将对象年龄设为 1. 对象在 Survivor 中每熬过一次 MinorGC, 年龄就增加 1 岁, 当它的年龄增加到一定程度, 就会被晋升到<strong>老年代</strong>中.</p> <p>参数 -<strong>XX:MaxTenuringThreshold</strong> 用来定义<strong>年龄的阈值</strong>. 年龄阈值默认为 <strong>15</strong> 岁, CMS 收集器默认 6 岁, 不同的垃圾收集器会略微有点不同.</p> <h5 id="_5-对象动态年龄判定机制"><a href="#_5-对象动态年龄判定机制" class="header-anchor">#</a> 5.对象动态年龄判定机制</h5> <p>虚拟机并不是永远要求对象的年龄必须达到 <strong>MaxTenuringThreshold</strong> 才能晋升老年代, 如果在 <strong>Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半</strong>, 则年龄大于或等于该年龄的对象可以直接进入老年代, <strong>无需</strong>等到 MaxTenuringThreshold 参数指定的年龄.</p> <p>当前放对象的 <strong>Survivor</strong> 区域里(其中一块区域, 放对象的那块 S 区), 一批对象的总大小大于这块 Survivor 区域内存大小的 <strong>50%</strong>(参数 -XX:TargetSurvivorRatio 可以指定), 那么此时<strong>大于等于</strong>这批对象年龄最大值的对象, 就可以<strong>直接</strong>进入老年代.</p> <p>例如 Survivor 区域里现在有一批对象, 年龄 1 + 年龄 2 + 年龄 n 的多个年龄对象<strong>总和超过了 Survivor 区域的 50%</strong>, 此时就会把年龄 n(含) 以上的对象<strong>都放入</strong>老年代. 这个规则其实是希望那些<strong>可能是长期存活</strong>的对象, 尽早进入老年代.</p> <p><strong>对象动态年龄判断机制一般是在 Minor GC 之后触发的.</strong></p> <h5 id="_6-老年代空间分配担保机制"><a href="#_6-老年代空间分配担保机制" class="header-anchor">#</a> 6.老年代空间分配担保机制</h5> <p>在发生 <strong>Minor GC</strong> 之前, 虚拟机<strong>先检查老年代最大可用的连续空间</strong>是否大于<strong>新生代所有对象的总空间</strong>, 如果条件成立的话, 那么 Minor GC 可以确认是<strong>安全</strong>的, 这就是<strong>老年代空间分配担保机制</strong>. <strong>担保失败</strong>可能会触发 <strong>Full GC</strong>.</p> <p>如果<strong>不成立</strong>的话虚拟机会查看 <strong>HandlePromotionFailure</strong>(可以理解成<strong>担保参数</strong>) 的值是否<strong>允许担保失败</strong>, 如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小, 如果大于, 将尝试着进行一次 <strong>Minor GC</strong>; 如果<strong>小于</strong>(则空间分配担保<strong>失败</strong>), 或者 HandlePromotionFailure 的值<strong>不允许冒险</strong>, 那么就要进行一次 <strong>Full GC</strong>.</p> <p>这里其实就是<strong>假设</strong>年轻代的<strong>全部对象</strong>都突然一下子放到老年代中, 如果老年代<strong>都能放得下</strong>, 就可以<strong>放心做 Minor GC</strong>了, 因为 Minor GC <strong>最多</strong>也就是把年轻代的全部对象都放到老年代中, 如果不能全部放下, 那就需要考虑一下是<strong>否有必要执行一次 Full GC</strong> 来清理老年代的空间来存放可能到来的年轻代对象了. <strong>担保的含义</strong>就是担保老年代中一定有空间来存放年轻代中可能来的对象.</p> <p>年轻代每次 <strong>Minor GC</strong> 之前 JVM 都会计算下老年代<strong>剩余可用空间</strong>. 如果这个可用空间<strong>小于年轻代里现有的所有对象大小之和</strong>(<strong>包括垃圾对象</strong>), 就会看是否设置了担保参数 &quot;-XX:-<strong>HandlePromotionFailure</strong>&quot;(JDK1.8 默认设置), 如果有这个参数, 就会看看老年代的可用内存大小, 是否大于之前每一次<a href=""></a>Minor GC 后进入老年代的对象的<strong>平均大小</strong>. 如果上一步结果是<strong>小于或者之前说的参数没有设置</strong>, 那么就会<strong>触发一次 Full GC</strong>, 对<strong>老年代和年轻代一起回收一次垃圾</strong>, 如果回收完还是没有足够空间存放新的对象就会发生 &quot;<strong>OOM</strong>&quot;.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521114637643.png" alt=""></p> <p><strong>为何这样做</strong>? 其实原因就是如果 Minor GC 执行后, 如果老年代空间不够依然需要进行 Full GC 的话, <strong>不如直接一来就进行一次 Full GC</strong>, 还能同时对<strong>堆的所有位置</strong>进行垃圾收集, 免得 Minor GC 做了之后还要做 Full GC. 而且做了 Full GC 之后 Minor GC 也可以不用做了.</p> <h4 id="minor-gc与full-gc"><a href="#minor-gc与full-gc" class="header-anchor">#</a> Minor GC与Full GC</h4> <p>针对<strong>新生代</strong>和<strong>老年代</strong>有不同的 <strong>GC 方法</strong>即 Minor GC 和 Full GC.</p> <h5 id="_1-对比"><a href="#_1-对比" class="header-anchor">#</a> 1.对比</h5> <ul><li><strong>新生代 GC(Minor GC/Young GC)</strong>: 指发生<strong>新生代</strong>的的垃圾收集动作, Minor GC 非常<strong>频繁</strong>, 回收速度一般也比较快.</li> <li><strong>老年代 GC(Full GC/Major GC)</strong>: 一般会同时回收<strong>老年代, 年轻代, 方法区</strong>的垃圾, 出现了 Major GC 经常会伴随至少一次的 Minor GC(并非绝对), Major GC 的速度一般会比 Minor GC 的<strong>慢</strong> 10 倍以上.</li></ul> <h5 id="_2-minor-gc触发条件"><a href="#_2-minor-gc触发条件" class="header-anchor">#</a> 2.Minor GC触发条件</h5> <p>Minor GC 发生在<strong>新生代</strong>上, 因为新生代对象存活时间很短, 因此 Minor GC 会<strong>频繁</strong>执行, 执行速度一般比较快.</p> <p><strong>Eden 区满了</strong>就触发了 Minor GC.</p> <ul><li>新生代中的垃圾收集动作, 采用的是<strong>复制算法</strong>.</li> <li>对于较大的对象, 在 Minor GC 的时候可以直接进入<strong>老年代</strong>.</li></ul> <h5 id="_3-full-gc触发条件"><a href="#_3-full-gc触发条件" class="header-anchor">#</a> 3.Full GC触发条件</h5> <p>Full GC 发生在<strong>老年代</strong>上, 老年代对象存活时间长, 因此 Full GC <strong>很少执行</strong>, 执行速度会比 Minor GC 慢很多.</p> <p>Full GC 触发相对复杂, 有以下条件:</p> <h6 id="_1-调用system-gc"><a href="#_1-调用system-gc" class="header-anchor">#</a> (1)调用System.gc()</h6> <p>只是<strong>建议</strong>虚拟机执行 Full GC, 但是虚拟机<strong>不一定</strong>真正去执行. 不建议使用这种方式, 而是让虚拟机管理内存. (常考)</p> <h6 id="_2-老年代空间不足"><a href="#_2-老年代空间不足" class="header-anchor">#</a> (2)老年代空间不足</h6> <p><strong>老年代空间不足</strong>的常见场景为大对象直接进入老年代, 长期存活的对象进入老年代等. 为避免以上原因引起 Full GC, 应当尽量<strong>不要创建过大的对象以及数组</strong>.</p> <p>除此之外, 可以<strong>通过 -Xmn 虚拟机参数调大新生代的大小, 让对象尽量在新生代被回收掉</strong>, 不进入老年代.</p> <p>还可以通过 <strong>-XX:MaxTenuringThreshold</strong> 调大对象进入老年代的<strong>年龄</strong>, 让<strong>对象在新生代多存活一段时间</strong>.</p> <h6 id="_3-空间分配担保失败"><a href="#_3-空间分配担保失败" class="header-anchor">#</a> (3)空间分配担保失败</h6> <p>使用<strong>复制算法</strong>的 Minor GC 需要老年代的内存空间作<strong>担保</strong>, 如果<strong>担保失败</strong>会执行一次 <strong>Full GC</strong>.</p> <h6 id="_4-jdk7及以前的永久代空间不足"><a href="#_4-jdk7及以前的永久代空间不足" class="header-anchor">#</a> (4)JDK7及以前的永久代空间不足</h6> <p>在 JDK 1.7 及以前, HotSpot 虚拟机中的<strong>方法区是用永久代</strong>实现的, 永久代中存放的为一些 Class 的信息, 常量, 静态变量等数据. 当系统中要加载的类, <strong>反射的类</strong>和调用的方法较多时, 永久代可能会<strong>被占满</strong>. Spring 经常使用反射, 在未配置为采用 CMS GC 的情况下就能触发 Full GC. 如果经过 Full GC 仍然回收不了, 就会抛出 java.lang.OutOfMemoryError.</p> <p>为避免以上原因引起的 Full GC, 可采用的方法为<strong>增大永久代空间或转为使用 CMS GC</strong>.</p> <h6 id="_5-concurrent-mode-failure"><a href="#_5-concurrent-mode-failure" class="header-anchor">#</a> (5)Concurrent Mode Failure</h6> <p>执行 CMS GC 的过程中同时有对象要放入老年代, 而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足), 便会报 Concurrent Mode Failure 错误, 并触发 Full GC. 解决办法就是要<strong>让年老代留有足够的空间</strong>, 以保证新对象空间的分配.</p> <h4 id="判断对象是否可回收"><a href="#判断对象是否可回收" class="header-anchor">#</a> 判断对象是否可回收?</h4> <h5 id="_1-引用计数算法"><a href="#_1-引用计数算法" class="header-anchor">#</a> 1.引用计数算法</h5> <p>为对象添加一个<strong>引用计数器</strong>, 当对象增加一个引用时计数器加 1, 引用失效时减 1, 引用计数为 0 的对象就能被回收.</p> <p>主流虚拟机中并没有选择这个算法来管理内存, 因为它很难解决对象之间<strong>相互循环引用</strong>的问题. 在两个对象出现<strong>循环引用</strong>的情况下, 此时引用计数器永远不为 0, 导致<strong>无法</strong>对它们进行回收, 造成<strong>内存泄漏</strong>问题.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CircularReferenceTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">Object</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">CircularReferenceTest</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CircularReferenceTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">CircularReferenceTest</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CircularReferenceTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 循环引用</span>
        a<span class="token punctuation">.</span>instance <span class="token operator">=</span> b<span class="token punctuation">;</span>
        b<span class="token punctuation">.</span>instance <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token comment">// 同时置空</span>
        a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        b <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// doSomething();</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>这里实例 a 与 b 互相持有对方的引用, 因此当把对 a 与 b 的引用去除之后, 由于两个对象还存在互相之间的引用, 如果采用引用计数法就会导致这两个对象无法被回收.</p> <h5 id="_2-可达性分析算法"><a href="#_2-可达性分析算法" class="header-anchor">#</a> 2.可达性分析算法</h5> <p>可达性分析算法就是以 <strong>GC Roots</strong> 为<strong>起始点</strong>进行搜索, <strong>可达</strong>的对象都是<strong>存活</strong>的, 不可达的对象被认定为垃圾对象可被回收. 是主流的判断方法.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521121813327.png" alt=""></p> <p>Java 虚拟机使用该算法来判断对象是否可被回收, <strong>GC Roots 对象</strong>有如下:</p> <ul><li><strong>==线程栈的本地变量==</strong>. 其实就是方法执行过程中产生的对象, 这些对象实际分配到<strong>堆</strong>中, 方法栈中保存着这些对象到堆区的引用. 在 GC 的时候, 如果这个方法的栈帧依然是有效的, 那这里面指向的对象就不能被回收, 因此需要以它们为 GC Root 来寻找存活的对象. 但是当线程结束之后, 这些对象就没有任何引用了.</li> <li><strong>方法区中的静态变量. ​</strong>静态变量所指向的对象也是在堆中的, 因此会用静态变量作为 Root 来找堆中的存活对象.</li> <li><strong>常量池</strong>中<strong>常量</strong>引用的对象.</li> <li><strong>本地方法栈</strong>中 JNI(即一般说的 Native 方法) 引用的对象.</li></ul> <p>GC Roots 的节点主要在<strong>全局性的引用</strong>(例如常量或类静态属性) 与<strong>执行上下文</strong>(例如栈帧中的本地变量表) 中.</p> <h5 id="_3-对象自救与finalize"><a href="#_3-对象自救与finalize" class="header-anchor">#</a> 3.对象自救与finalize</h5> <p><strong>不可达的对象并非&quot;非死不可&quot;</strong>. 即使在可达性分析法中<strong>不可达</strong>的对象, 也并非是&quot;非死不可&quot;的, 这时候它们暂时处于 &quot;<strong>缓刑阶段</strong>&quot;, 要真正宣告一个对象死亡, 至少要经历<strong>两次标记</strong>过程.</p> <p><strong>标记的前提是对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链.</strong></p> <p><strong>第一次标记</strong>: 可达性分析法中<strong>不可达的对象</strong>被<strong>第一次标记</strong>并且进行一次<strong>筛选</strong>, 筛选的条件是<strong>此对象是否有必要执行 finalize() 方法</strong>. 当对象没有<strong>覆写</strong> finalize() 方法, 或 finalize() 方法已经被虚拟机<strong>调用过</strong>时, 对象将被<strong>直接回收</strong>.</p> <p><strong>第二次标记</strong>: 如果这个对象覆写了 finalize() 方法, finalize() 方法是对象脱逃死亡命运的<strong>最后一次机会</strong>, 如果对象要在 finalize() 中成功拯救自己, 只要<strong>重新与 GC Root 引用链上的任何的一个对象建立关联</strong>即可, 譬如把自己<strong>赋值给某个类变量或对象的成员变量</strong>, 那在第二次标记时它将移除出 &quot;即将回收&quot; 的集合. 如果对象这时候还没逃脱, 那基本上它就真的被回收了.</p> <p>注意: 一个对象的 finalize() 方法<strong>只会被执行一次</strong>, 也就是说通过调用 finalize() 方法自我救命的机会<strong>就一次</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 静态变量, 这里就是一个GCRoot对象</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> userList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用静态变量来挂钩GCRoot对象</span>
    <span class="token class-name">Test</span><span class="token punctuation">.</span>userList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;关闭资源, userid=&quot;</span> <span class="token operator">+</span> id <span class="token operator">+</span> <span class="token string">&quot;即将被回收&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>总结如何自我救赎:</strong></p> <ol><li>对象<strong>覆写</strong>了 <strong>finalize</strong>() 方法(这样在被<strong>判死后才会调用此方法</strong>, 才有机会做最后的救赎).</li> <li>在 <strong>finalize</strong>() 方法中<strong>重新引用到 &quot;GC  Roots&quot; 链</strong>上(如把当前对象的引用 this 赋值给某对象的类变量/成员变量, 重新建立可达的引用).</li></ol> <p>虽然以上以对象救赎举例, 但 finalize() 的作用往往被认为是<strong>用来做最后的资源回收</strong>. 而且 finalize() 的调用具有<strong>不确定性</strong>, 只保证方法会调用, 但<strong>不保证方法里的任务会被执行完</strong>(比如一个对象可能还在自救的过程中, 就被回收了). 它用来回收资源也不会有什么好的表现. 综上: finalize() 方法<strong>并没有什么鸟用</strong>.</p> <p>finalize() 方法的运行代价高昂, 不确定性大, 无法保证各个对象的调用顺序, 如今已被官方明确声明为不推荐使用的语法.</p> <h4 id="静态方法区回收"><a href="#静态方法区回收" class="header-anchor">#</a> 静态方法区回收</h4> <p>Java 虚拟机规范中规定可以<strong>不要求虚拟机在方法区实现垃圾收集</strong>. 因为方法区主要存放<strong>永久代</strong>对象, 而永久代对象的回收率比新生代低很多, 所以在方法区上进行<strong>回收性价比不高</strong>, 且回收的条件非常<strong>苛刻</strong>.</p> <p>但是为了避免内存溢出, 在大量使用<strong>反射, 动态代理, GGLib 等</strong> ByteCode 框架, OSGI 这类<strong>频繁自定义 ClassLoader</strong> 的场景都需要<strong>虚拟机具备类卸载</strong>的功能, 以保证永久代<strong>不会溢出</strong>.</p> <blockquote><p>方法区的垃圾回收主要是对常量池的回收和对类的卸载.(废弃常量与无用的类)</p></blockquote> <p><strong>类的卸载</strong>条件很多, 需要满足以下三个条件, 并且满足了条件也不一定会被卸载, 同时满足以下的条件才是<strong>无用</strong>的类:</p> <ul><li>该类所有的<strong>实例都已经被回收</strong>, 此时堆中不存在该类的任何实例.</li> <li>加载该类的 <strong>ClassLoader</strong> 已经被回收.</li> <li>该类对应的 <strong>Class 对象</strong>没有在任何地方被<strong>引用</strong>, 无法在任何地方通过<strong>反射访问</strong>该类方法.</li></ul> <blockquote><p>如何判断一个常量是废弃常量?</p></blockquote> <p>Java 8 之后运行时常量池从<strong>方法区</strong>移动到了<strong>堆</strong>中, 因此也有 <strong>GC</strong> 发生. 运行时常量池主要回收的是<strong>废弃的常量</strong>. 如何判断一个常量是废弃常量呢?</p> <p>假如在常量池中存在字符串 &quot;abc&quot;, 如果<strong>当前没有任何 String 对象引用该字符串常量</strong>的话, 就说明常量 &quot;abc&quot; 就是废弃常量, 如果这时发生内存回收的话而且有必要的话, &quot;abc&quot; 就会被系统清理出常量池.</p> <h4 id="引用类型"><a href="#引用类型" class="header-anchor">#</a> 引用类型</h4> <p>无论是通过引用计数算法判断对象的引用数量, 还是通过可达性分析算法判断对象是否可达, 判定<strong>对象是否可被回收都与引用</strong>有关. Java 提供了四种强度不同的引用类型: <strong>强软弱虚</strong>(强度递减).</p> <h5 id="_1-强引用"><a href="#_1-强引用" class="header-anchor">#</a> 1.强引用</h5> <p>最常见的普通变量引用就是强引用.</p> <p>被强引用的对象<strong>不会</strong>被回收. 使用 new 一个新对象的方式来创建强引用, 最普遍, 类似<strong>生活必需品</strong>.</p> <p>当内存空间不足时, 虚拟机<strong>宁愿</strong>抛出 OutOfMemoryError 错误使程序异常终止, 也<strong>不会</strong>靠随意回收具有强引用的对象来解决内存不足问题.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h5 id="_2-软引用"><a href="#_2-软引用" class="header-anchor">#</a> 2.软引用</h5> <p>被<strong>软引用</strong>关联的对象只有在<strong>内存不够</strong>的情况下才会被回收. 将对象用 SoftReference 软引用类型的对象包裹, 正常情况不会被回收, 但是 <strong>GC 做完</strong>后发现释放不出空间存放新的对象, 则会把这些软引用的对象回收掉. <strong>类似可有可无的生活用品</strong>. 如果内存<strong>足够</strong>, 垃圾回收器就<strong>不会</strong>回收它, 如果没有回收, 那么就可以继续使用.</p> <p><strong>软引用可用来实现内存敏感的高速缓存. ​</strong>比如可以用于缓存浏览器的历史页面实现后退按钮.</p> <p>使用 <strong>SoftReference</strong> 类来创建软引用.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// 使对象只被软引用关联</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h5 id="_3-弱引用"><a href="#_3-弱引用" class="header-anchor">#</a> 3.弱引用</h5> <p>弱引用与软引用的区别在于: <strong>只具有弱引用的对象拥有更短暂的生命周期</strong>. 发生 <strong>GC 的时候</strong>, 如果发现有<strong>弱引用对象</strong>, 不管内存够不够<strong>都会直接进行回收</strong>.</p> <p>使用 <strong>WeakReference</strong> 类来创建弱引用.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> wf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h5 id="_4-虚引用"><a href="#_4-虚引用" class="header-anchor">#</a> 4.虚引用</h5> <p>又称为幽灵引用或者幻影引用, 一个对象是否有虚引用的存在, 不会对其生存时间造成影响, 也<strong>无法</strong>通过虚引用得到一个对象. 如果一个对象仅持有虚引用, 那么它就和<strong>没有任何引用一样</strong>, 在<strong>任何时候都可能被垃圾回收</strong>. 为一个对象设置虚引用的<strong>唯一目的</strong>是能在这个对象被回收时收到一个系统通知.</p> <p>使用 <strong>PhantomReference</strong> 来创建虚引用.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> pf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h5 id="_5-引用队列"><a href="#_5-引用队列" class="header-anchor">#</a> 5.引用队列</h5> <p><strong>软引用和弱引用</strong>都可以和一个<strong>引用队列</strong>(ReferenceQueue) 联合使用, 如果软引用或弱引用所引用的对象<strong>被垃圾回收</strong>, 虚拟机就会把这个软引用或弱引用加入到<strong>与之关联的引用队列中</strong>. 虚引用必须和引用队列(ReferenceQueue) 联合使用. 当垃圾回收器准备回收一个对象时, 如果发现它还有虚引用, 就会在回收对象的内存之前, 把这个虚引用加入到与之关联的引用队列中. 程序可以通过判断引用队列中是否已经加入了虚引用, 来了解被引用的对象是否将要被垃圾回收. 程序如果发现某个虚引用已经被加入到引用队列, 那么就可以在所引用的对象的内存被回收之前采取必要的行动.</p> <h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="header-anchor">#</a> 垃圾收集算法</h4> <p>主要有四种算法. 四种算法可以应用在不同的区域及场合.</p> <h5 id="_1-标记-清除算法"><a href="#_1-标记-清除算法" class="header-anchor">#</a> 1.标记-清除算法</h5> <p>主要分为<strong>标记</strong>与<strong>清除</strong>两个步骤.</p> <p><strong>标记阶段</strong>: 程序会检查每个对象是否为<strong>活动对象</strong>, 如果是活动对象, 则程序会在<strong>对象头部</strong>打上标记.</p> <p><strong>清除阶段</strong>: 会进行对象回收并取消标志位, 另外还会判断回收后的分块与前一个空闲分块是否连续, 若连续, 会<strong>合并这两个分块</strong>. 回收对象就是把对象作为分块, <strong>连接到被称为 &quot;空闲链表&quot; 的单向链表</strong>, 之后进行分配时只需要<strong>遍历</strong>这个空闲链表, 就可以找到分块.</p> <p>在<strong>分配</strong>时, 程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block. 如果它找到的块等于 size, 会直接返回这个分块; 如果找到的块大于 size, 会将块分割成大小为 size 与 (block - size) 的两部分, 返回大小为 size 的分块, 并把大小为 (block - size) 的块返回给空闲链表.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521125600745.png" alt=""></p> <p><strong>问题</strong>:</p> <ul><li>效率问题. 如果需要标记的对象太多, 效率不高.</li> <li>空间问题. 标记清除后会产生大量不连续的<strong>内存碎片</strong>, 导致无法给<strong>大对象</strong>分配内存. 如果后面一直没有内存给大对象就会一直触发 <strong>Full GC</strong>.</li></ul> <h5 id="_2-复制算法"><a href="#_2-复制算法" class="header-anchor">#</a> 2.复制算法</h5> <p>将<strong>内存</strong>划分为大小相等的<strong>两块</strong>, 每次<strong>只使用其中一块</strong>, 当这一块内存用完了就将还存活的对象复制到<strong>另一块上面</strong>, 然后再把使用过的内存空间进行一次清理.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521130236760.png" alt=""></p> <p>现在的商业虚拟机<strong>都采用</strong>这种收集算法回收<strong>新生代</strong>, 但<strong>并不是划分为大小相等</strong>的两块, 而是一块<strong>较大的 Eden 空间和两块较小的 Survivor 空间</strong>, 每次使用 Eden 和其中<strong>一块 Survivor</strong>. 即前述的 <strong>S0 和 S1 区域</strong>, 回收时将 Eden 和 Survivor 中还存活的对象全部<strong>复制到另一块 Survivor</strong> 上, 最后清理 Eden 和使用过的那一块 Survivor, 确保总是有一半是干净的内存. 而且由于新生代大部分对象存活率<strong>都低</strong>, 所以复制的时候需要<strong>复制的对象一般也不多</strong>, 因此效率还不错.</p> <p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 <strong>8:1:1</strong>, 保证了内存的利用率达到 90%. 如果每次回收有多于 10% 的对象存活, 那么一块 Survivor 就<strong>不够用</strong>了, 此时需要依赖于<strong>老年代进行空间分配担保</strong>, 也就是借用老年代的空间存储放不下的对象. 如果空间担保失败, 则触发 Full GC.</p> <p><strong>不足</strong>: 主要不足是只使用了<strong>一半</strong>的内存, 而且如果存活对象过多时导致<strong>复制</strong>开销较大.</p> <h5 id="_3-标记-整理算法"><a href="#_3-标记-整理算法" class="header-anchor">#</a> 3.标记-整理算法</h5> <p>让所有存活的对象都<strong>向一端移动</strong>, 然后直接清理掉端边界以外的内存. 适用于<strong>老年代</strong>的特点(大对象, 且存活时间长的对象).</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521132900524.png" alt=""></p> <p><strong>优点</strong>: <strong>不会产生内存碎片</strong>.</p> <p><strong>不足</strong>: 需要<strong>移动</strong>大量对象, 处理效率比较低.</p> <h5 id="_4-分代收集算法"><a href="#_4-分代收集算法" class="header-anchor">#</a> 4.分代收集算法</h5> <p>现在的商业虚拟机几乎都采用<strong>分代收集算法</strong>, 这种算法没有什么新的思想, 它根据<strong>对象存活周期的不同将内存划分为几块(如新生代, 老年代)</strong>, 然后根据各个年代的<strong>特点</strong>选择<strong>合适</strong>的垃圾收集算法(这也是为什么一般将堆分为<strong>新生代和老年代</strong>的原因).</p> <ul><li><strong>新生代</strong>使用: <strong>复制算法</strong>. 在<strong>新生代</strong>中, 每次收集都会有<strong>大量对象死去</strong>, 所以可以选择<strong>复制算法</strong>, 每次垃圾收集需要复制的对象通常<strong>不会太多</strong>.</li> <li><strong>老年代</strong>使用: <strong>标记-清除</strong> 或者 <strong>标记-整理</strong> 算法(老年代中对象存活率较高). 老年代的<strong>对象存活几率是比较高</strong>的, 而且没有额外的空间对它进行分配担保, 所以必须选择 &quot;<strong>标记-清除</strong>&quot; 或 &quot;<strong>标记-整理</strong>&quot; 算法进行垃圾收集. &quot;<strong>标记-清除</strong>&quot; 或 &quot;<strong>标记-整理</strong>&quot; 算法会比复制算法<strong>慢</strong> 10 倍以上.</li></ul> <h4 id="hotspot虚拟机垃圾收集算法实现"><a href="#hotspot虚拟机垃圾收集算法实现" class="header-anchor">#</a> HotSpot虚拟机垃圾收集算法实现</h4> <h5 id="_1-枚举根节点gc-roots"><a href="#_1-枚举根节点gc-roots" class="header-anchor">#</a> 1.枚举根节点GC Roots</h5> <p>以<strong>可达性分析</strong>中从 <strong>GC Roots</strong> 节点找引用链的操作为例, 可以作为 GC Roots 的节点主要在<strong>全局性的引用</strong>(例如常量或者类静态属性)与<strong>执行上下文</strong>(例如栈帧中的本地变量表) 中.</p> <p>但是现在很多应用仅仅<strong>方法区</strong>就有数百兆, 如果要<strong>逐个检查</strong>这里面的引用, 就会消耗很多的时间. 另外, 可达性分析对<strong>执行时间的敏感</strong>还体现在 <strong>GC 停顿</strong>上, 因为这项分析工作必须在一个能确保一致性的快照中进行---这里的“一致性”指的是在整个分析过程中整个执行系统看起来就像是被冻结在某个时间点上, 不可以出现分析过程中对象引用关系还在不停变化的情况, 该点不满足的话分析结果准确性就无法得到保证.</p> <p>这个点是<strong>导致 GC 进行时必须停顿</strong>所有执行线程的其中一个重要原因, 即使是号称不会发生停顿的 CMS 收集器中, 枚举根节点也是必须要停顿的.</p> <p>由于目前主流 Java 虚拟机使用的都是<strong>准确式 GC</strong>, 所以当执行系统停顿下来后, 并不需要一个不漏的检查完成所有执行上下文和全局的引用位置, <strong>虚拟机应当是有办法直接得知那些地方存放着对象引用的. ​</strong>​<strong><strong>在 HotSpot 实现中, 是使用一组被称为 ​</strong></strong>​<strong><strong><strong>OopMap<strong><strong><strong>​</strong></strong>​ 的数据结构来达到这个目的, 在</strong></strong>​</strong>类加载完成</strong>的时候, HotSpot 就把对象上什么偏移量是什么类型计算出来, 并<strong>放入 OopMap</strong> 数据结构中了; 在 JIT 编译过程中, 也会在特定的位置记录下栈和寄存器中哪些位置是引用.</p> <p>这样, <strong>GC 在扫描</strong>时就可以直接得知这些信息了.</p> <h5 id="_2-安全点"><a href="#_2-安全点" class="header-anchor">#</a> 2.安全点</h5> <p>在 <strong>OopMap</strong> 的帮助下, HotSpot 可以<strong>快速并且准确</strong>的<strong>完成 GC Roots 枚举</strong>(也就是找到所有的 GC Roots), 但是这<strong>可能导致引用关系变化</strong>, 也就是说在执行程序的时候 GC Roots 的引用关系可能因为<strong>代码的执行而发生变化</strong>, 这时候进入 GC 就可能出问题.</p> <p>实际上 HotSpot 也的确没有为每一条指令都生成 OopMap, 只是在 <strong>&quot;特定的位置&quot; 记录了这些信息</strong>, 这些位置被称为是<strong>安全点</strong>, <strong>即程序执行时并非是在所有地方都能停顿下来开始 GC, 只有到达安全点时才能暂停.</strong></p> <p>安全点的选择既不能太少以至于让 GC 等待太长时间, 也不能过于频繁导致增大运行时负荷.</p> <p><strong>所以, 安全点的选定基本上是以程序 &quot;是否具有让程序长时间执行的特征&quot; 为标准进行选定的. 因为每条指令执行的时间都非常短暂, 程序不太可能因为指令流长度太长这个原因而过长时间运行, &quot;长时间执行&quot; 的最明显特征就是指令序列复用, 例如方法调用, 循环跳转, 异常跳转等, 所以具有这些功能的指令才会产生安全点.</strong></p> <p><strong>安全点</strong>就是指代码中一些<strong>特定的位置</strong>, 当线程运行到这些位置时它的<strong>状态是确定的</strong>, 这样 JVM 就可以<strong>安全的进行一些操作</strong>, 比如 <strong>GC</strong> 等, <strong>所以 GC 不是想什么时候做就立即触发的, 是需要等待所有线程运行到安全点后才能触发</strong>.</p> <p>这些特定的安全点位置主要有以下几种:</p> <ol><li>方法返回之前</li> <li>调用某个方法之后</li> <li>抛出异常的位置</li> <li>循环的末尾</li></ol> <p>大体实现思想是当垃圾收集需要<strong>中断线程</strong>的时候, 不直接对线程操作, 仅仅简单地设置一个<strong>标志位</strong>, 各个线程执行过程时会不停地主动去<strong>轮询这个标志</strong>, 一旦发现中断标志为真时就自己在<strong>最近的安全点上主动中断挂起</strong>. 轮询标志的地方和安全点是重合的.</p> <h5 id="_3-安全区域"><a href="#_3-安全区域" class="header-anchor">#</a> 3.安全区域</h5> <p>使用安全点似乎已经完美解决了<strong>如何进入 GC 的问题</strong>, 但实际情况却并不一定, 安全点机制保证了程序执行, 在不太长的时间内就会遇到可以进入 GC 的安全点.</p> <p>但是线程 &quot;不执行&quot; 的时候呢? 所谓不执行就是没有分配 CPU 时间, 典型的例子就是线程处于 Sleep 状态或者 Blocked 状态, 这时候线程无法响应 JVM 的中断请求, &quot;走&quot; 到安全点去中断挂起, JVM 显然也不太可能等待线程重新被分配 CPU 时间.</p> <p>对于这种状况, 就需要<strong>安全区域</strong>来解决. <strong>安全区域就是在一段代码片段中, 引用关系不会发生变化, 在这个区域中的任意地方开始 GC 都是安全的.</strong></p> <p>在线程执行到安全区域中的代码时, 首先标识自己已经进入了安全区域, 当这段时间里 JVM 要发起 GC 时, 就<strong>不用管</strong>标识自己为安全区域状态的线程了. 当线程要离开安全区域时, 它要检查系统是否已经完成了根节点枚举(或者是整个 GC 过程), 如果完成了, 那线程就继续执行, 否则它就必须等待直到收到可以安全离开安全区域的信号为止.</p> <p>安全点是对<strong>正在执行的线程设定</strong>的. 如果一个线程处于 Sleep 或中断状态, 它就不能响应 JVM 的中断请求, 再运行到安全点上. 因此 JVM 引入了安全区域. 安全区域是指在一段代码片段中, <strong>引用关系不会发生变化</strong>. 在这个区域内的<strong>任意地方开始 GC 都是安全的</strong>.</p> <h4 id="垃圾收集器"><a href="#垃圾收集器" class="header-anchor">#</a> 垃圾收集器</h4> <p><strong>如果说收集算法是内存回收的方法论, 那么垃圾收集器就是内存回收算法的具体实现. ​</strong></p> <p>虽然对各个收集器进行比较, 但并非为了挑选出一个最好的收集器. 因为直到现在为止还没有最好的垃圾收集器出现, 更加没有万能的垃圾收集器, 能做的就是<strong>根据具体应用场景选择适合自己的垃圾收集器</strong>. 如果有一种在任何场景下都适用的完美收集器存在, 那么就不会实现那么多不同的垃圾收集器了.</p> <p><strong>垃圾收集范围</strong>: 垃圾收集主要是针对<strong>堆和方法区</strong>进行. <strong>程序计数器, 虚拟机栈和本地方法栈这三个区域属于线程私有</strong>的, 只存在于线程的生命周期内, 线程结束之后就会消失, 因此<strong>不需要</strong>对这三个区域进行垃圾回收.</p> <p>下图是 HotSpot 虚拟机中的 7 个垃圾收集器, <strong>连线</strong>表示垃圾收集器可以<strong>配合使用</strong>. 注意哪些收集器使用的范围.</p> <ul><li><strong>新生代收集器</strong>: Serial, ParNew, Parallel Scavenge 收集器.</li> <li><strong>老年代收集器</strong>: Serial Old, ParNew Old, <strong>CMS 收集器</strong>.</li> <li><strong>新生代与老年代均可</strong>: <strong>G1 收集器, ZGC 等</strong>.</li></ul> <p><img src="assets/image-20230326141727-e2hy6yx.png" alt="image"></p> <blockquote><p>几个概念</p></blockquote> <ul><li><strong>单线程与多线程</strong>: 单线程指的是垃圾收集器<strong>只使用一个线程</strong>, 而多线程使用多个线程.</li> <li><strong>串行与并行</strong>: <strong>串行</strong>指的是垃圾收集器与用户程序<strong>交替执行</strong>, 这意味着在执行垃圾收集的时候需要<strong>停顿用户程序</strong>; <strong>并行</strong>指的是垃圾收集器和用户程序<strong>同时执行</strong>, 只有 <strong>CMS 和 G1 是并行</strong>执行.</li></ul> <blockquote><p>停顿时间与吞吐量的权衡</p></blockquote> <ul><li><strong>停顿时间越短就越适合需要与用户交互的程序, 良好的响应速度能提升用户体验. ​</strong>使用 <strong>Parallel Scavenge 和 Parallel Old</strong> 收集器. 缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小, 垃圾回收变得频繁, 导致吞吐量下降.</li> <li><strong>高吞吐量则可以高效率地利用 CPU 时间, 尽快完成程序的运算任务, 适合在后台运算而不需要太多交互的任务. ​</strong>可以使用 <strong>CMS</strong> 收集器.</li></ul> <blockquote><p>STW = Stop The World</p></blockquote> <p>就是进行垃圾收集工作的时候必须暂停其他所有的<strong>工作线程</strong>.</p> <h5 id="_1-serial收集器"><a href="#_1-serial收集器" class="header-anchor">#</a> 1.Serial收集器</h5> <p>配置参数: <strong>-XX:+UseSerialGC  -XX:+UseSerialOldGC</strong>.</p> <p>Serial 翻译为<strong>串行</strong>, 也就是说它以<strong>串行的方式执行</strong>. 它是<strong>单线程</strong>的收集器, 只会使用一个线程进行垃圾收集工作. 它在垃圾收集时<strong>必须暂停其他</strong>的工作线程(STW), 直到收集结束. 参考下图.</p> <p>下图是 Serial 配合 Serial Old 一起使用, 这里<strong>新生代采用复制算法, 老年代采用标记-整理算法.</strong></p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521141659319.png" alt=""></p> <p>它的优点是<strong>简单高效</strong>, 在<strong>单个 CPU</strong> 环境下, 由于没有线程交互的开销, 因此拥有<strong>最高的单线程收集效率</strong>.</p> <p>它是虚拟机运行在 <strong>Client</strong> 模式下的默认新生代收集器, 因为在该场景下内存一般不会很大.</p> <h5 id="_2-parnew收集器"><a href="#_2-parnew收集器" class="header-anchor">#</a> 2.ParNew收集器</h5> <p>Serial 收集器适合单 CPU 下工作, 如果有<strong>多 CPU</strong>, 那么可以考虑用 ParNew 收集器. 它是 <strong>Serial</strong> 收集器对应的<strong>多线程</strong>版本. 多条垃圾收集线程<strong>并行</strong>工作, 依然需要暂停全部用户线程(STW), 除多个线程并行执行垃圾收集外, 其余行为(控制参数, 收集算法, 回收策略等等) 和 Serial 收集器<strong>完全一样</strong>.</p> <p>它是虚拟机在 <strong>Server</strong> 模式下默认的<strong>新生代收集器</strong>. 下图是 ParNew 配合 SerialOld 收集器进行, 这里<strong>新生代采用复制算法, 老年代采用标记-整理算法.</strong></p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521142052614.png" alt=""></p> <p><strong>默认</strong>开启的<strong>线程数量</strong>与 <strong>CPU 数量</strong>相同, 可以使用 -XX:ParallelGCThreads 参数来设置<strong>线程数</strong>.</p> <h5 id="_3-parallel-scavenge收集器"><a href="#_3-parallel-scavenge收集器" class="header-anchor">#</a> 3.Parallel Scavenge收集器</h5> <p>与 ParNew 一样是<strong>多线程</strong>收集器. 但是主要关注<strong>吞吐量</strong>. 因此它被称为 <strong>&quot;吞吐量优先&quot;</strong> 收集器. 这里的<strong>吞吐量</strong>指 CPU 用于运行用户代码的时间占总时间的比值.</p> <blockquote><p>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)</p></blockquote> <p>下图是 Parallel Scavenge 搭配 Parallel Old, 这里<strong>新生代采用复制算法, 老年代采用标记-整理算法.</strong></p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521142336388.png" alt=""></p> <p>可以通过 <strong>-XX:+UserAdaptiveSizePolicy</strong> 参数打开 GC <strong>自适应的调节策略</strong>, 就不需要手工指定新生代的大小, Eden 和 Survivor 区的比例, 晋升老年代对象年龄等细节参数了. 虚拟机会根据当前系统的运行情况收集性能监控信息, <strong>动态调整</strong>这些参数以提供最合适的停顿时间或者最大的吞吐量.</p> <p><strong>停顿时间越短</strong>就越适合需要与用户交互的程序, 良好的响应速度能提升用户体验. 而<strong>高吞吐量</strong>则可以高效率地利用 CPU 时间, 尽快完成程序的运算任务, 主要适合在<strong>后台运算</strong>而不需要太多交互的任务.</p> <p><strong>与 ParNew 的不同之处: 自适应调节策略</strong>是 Parallel Scavenge 与 ParNew 收集器的一个<strong>重要区别</strong>. 此外, Parallel Scavenge 收集器关注点是<strong>吞吐量</strong>(高效率的利用 CPU), 许多收集器关注点更多的是用户线程的停顿时间(提高用户体验).</p> <p>Parallel Scavenge 收集器提供了两个参数用于<strong>精确控制吞吐量</strong>:</p> <ul><li><strong>最大垃圾收集停顿时间: ​</strong>​****-XX:MaxGCPauseMills, 这个参数允许的值是一个大于 0 的毫秒数, 收集器将尽可能地保证内存回收所花费的时间****​<strong>不超过设定值</strong>. 但 GC 的停顿时间缩短是以牺牲吞吐量和新生代空间来换取的. 停顿时间下降, 但吞吐量也降下来了.</li> <li><strong>吞吐量大小: ​</strong>​****-XX:GCTimeRatio, 这个参数的值是一个大于 0 且小于 100 的整数, 也就是****​<strong>垃圾收集时间占总时间的比例</strong>, 相当于吞吐量的倒数. 区间 1/(1+99) ~ 1/(1+1), 即 1% ~ 50%.</li></ul> <h5 id="_4-serial-old收集器"><a href="#_4-serial-old收集器" class="header-anchor">#</a> 4.Serial Old收集器</h5> <p>是 <strong>Serial</strong> 收集器的<strong>老年代</strong>版本, 也是给 <strong>Client</strong> 场景下的虚拟机使用. 它同样是一个<strong>单线程</strong>收集器, 使用 &quot;标记-整理&quot; 算法.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521141659319.png" alt=""></p> <p>如果用在 Server 场景下, 它有两大用途:</p> <ul><li>在 JDK5 以及之前版本(Parallel Old 诞生以前) 中与 Parallel Scavenge 收集器搭配使用.</li> <li>作为 CMS 收集器的后备预案, 在并发收集发生 Concurrent Mode Failure 时使用.</li></ul> <h5 id="_5-parallel-old收集器"><a href="#_5-parallel-old收集器" class="header-anchor">#</a> 5.Parallel Old收集器</h5> <p>是 <strong>Parallel Scavenge</strong> 收集器的<strong>老年代</strong>版本, 也是关注<strong>吞吐量</strong>. 使用多线程和 &quot;标记-整理&quot; 算法.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521142336388.png" alt=""></p> <p>在注重<strong>吞吐量</strong>以及 <strong>CPU 资源敏感</strong>的场合, 都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器.</p> <h5 id="_6-cms收集器"><a href="#_6-cms收集器" class="header-anchor">#</a> 6.CMS收集器</h5> <p>CMS 只能用在<strong>老年代</strong>, 通常搭配 <strong>ParNew</strong> 使用(JDK 1.8 之前).</p> <p>CMS(Concurrent Mark Sweep), Concurrent 指<strong>并发</strong>, Mark Sweep 指的是 <strong>&quot;标记-清除&quot; 算法</strong>. 是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器, 注重用户体验. 比如<strong>服务器尤其重视服务响应速度</strong>, 希望系统的停顿时间最短. <strong>它非常符合在注重用户体验的应用上使用, 它是 HotSpot 虚拟机第一款真正意义上的并发收集器, 它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作.</strong></p> <h6 id="_1-收集流程"><a href="#_1-收集流程" class="header-anchor">#</a> (1)收集流程</h6> <p>分为以下几个流程:</p> <ul><li><strong>初始标记</strong>: <strong>暂停所有</strong>其他线程, 并记录下 GC Roots <strong>直接能引用的对象(也就是 GC Root 直接连接的对象, 后面的引用链上的对象不管)</strong>, 虽然会存在 STW 但是<strong>速度很快</strong>.</li> <li><strong>并发标记</strong>: 并发标记阶段就是从上一步找到的 GC Roots 的<strong>直接关联对象</strong>开始<strong>遍历整个对象图</strong>的过程, 从而得到所有跟 GC Root 连接的对象, 这个过程耗时<strong>最长</strong>但是<strong>不需要停顿</strong>用户线程, 可以与垃圾收集线程一起<strong>并发运行</strong>. 因为用户程序继续运行, 可能会有导致已经标记过的对象状态发生改变. 比如有的对象在开始并发标记的时候是存活的, 但是并发标记不会 STW, 随着用户线程释放后就变成垃圾对象了.</li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521143207389.png" alt=""></p> <ul><li><strong>重新标记</strong>: 为了<strong>修正并发标记</strong>期间因用户程序<strong>继续运作而导致标记产生变动</strong>的那一部分对象的标记记录(主要是处理漏标问题), 也需要进行 STW. <strong>这个阶段的停顿时间一般会比初始标记阶段的时间稍长, 但也远远比并发标记阶段时间短</strong>. <strong>这个阶段主要用到</strong>​**==三色标记里的增量更新算法==<strong>​</strong>做重新标记**.</li> <li><strong>并发清理</strong>: 开启用户线程, 同时 GC 线程开始对未标记的区域做<strong>清扫</strong>. <strong>不需要</strong>停顿. 这个阶段如果有<strong>新增对象会被标记为黑色</strong>不做任何处理.</li> <li><strong>重置清理</strong>: 重置本次 GC 过程中的标记数据.</li></ul> <p>在整个过程中<strong>耗时最长的并发标记和并发清除</strong>过程中, 收集器线程都可以与用户线程一起工作, <strong>不需要进行停顿</strong>. 需要 STW 的地方都是耗时比较短的初始标记和重新标记阶段.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521154058783.png" alt=""></p> <h6 id="_2-优缺点"><a href="#_2-优缺点" class="header-anchor">#</a> (2)优缺点</h6> <p><strong>优点</strong>: <strong>并发收集, 低停顿</strong>.</p> <p><strong>缺点:</strong></p> <ul><li><strong>对 CPU 资源敏感吞吐量低. ​</strong>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的, 新生代空间变小, 垃圾回收变得频繁, 导致吞吐量下降. 导致 CPU 利用率不够高. 垃圾收集会和服务<strong>抢资源</strong>.</li> <li><strong>==无法处理浮动垃圾, 从而导致执行过程存在不确定性==<strong>​</strong>. 浮动垃圾</strong>是指并发清除阶段由于<strong>用户线程继续运行</strong>而产生的垃圾, 这部分垃圾只能到<strong>下一次</strong> GC 时才能进行回收. 可能出现上一次垃圾回收还没执行完, 然后垃圾回收又被触发的情况, 特别是在并发标记和并发清理阶段会出现, 一边回收, 系统一边运行, 也许没回收完就再次触发 Full GC, 也就是 <strong>Concurrent Mode Failure</strong>(不会 OOM), 这时虚拟机将 STW 并临时启用 <strong>Serial Old</strong> 来替代 CMS 进行垃圾收集.</li> <li><strong>&quot;标记-清除&quot; 算法导致的空间碎片</strong>, 往往出现老年代空间剩余, 但无法找到<strong>足够大连续空间</strong>来分配当前对象, 不得不提前触发一次 <strong>Full GC</strong>. 当然通过参数 -XX:+UseCMSCompactAtFullCollection 可以让 JVM 在执行完标记清除后再做整理.</li></ul> <h6 id="_3-参数设置"><a href="#_3-参数设置" class="header-anchor">#</a> (3)参数设置</h6> <p>CMS 相关虚拟机参数:</p> <ul><li>-XX:+UseConcMarkSweepGC: <strong>启用 CMS</strong>.</li> <li>-XX:ConcGCThreads: 并发的 GC 线程数.</li> <li>-XX:+UseCMSCompactAtFullCollection: FullGC 之后做压缩整理(减少碎片), Mark Sweep 不会自动进行碎片整理, 需要在此配置.</li> <li>-XX:CMSFullGCsBeforeCompaction: 多少次 FullGC 之后<strong>压缩一次</strong>, 默认是 0, 代表每次 FullGC 后都会压缩一次.</li> <li>-XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该<strong>比例</strong>时会触发 FullGC.</li> <li>-XX:+UseCMSInitiatingOccupancyOnly: 只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction 设定的值), 如果不指定, JVM 仅在第一次使用设定值, 后续则会自动调整.</li> <li>-XX:+CMSScavengeBeforeRemark: 在 CMS GC <strong>前启动一次 Minor GC</strong>, 目的在于<strong>减少老年代对年轻代的引用</strong>(因为年轻代很多对象都是垃圾对象), 降低 CMS GC 的标记阶段时的开销, 一般 CMS 的 GC 耗时 80% 都在<strong>并发标记阶段</strong>.</li> <li>-XX:+CMSParallellnitialMarkEnabled: 表示在初始标记的多线程执行, 减少 STW.</li> <li>-XX:+CMSParallelRemarkEnabled: 在重新标记的时候多线程执行, 降低 STW.</li></ul> <h6 id="_4-应用实例"><a href="#_4-应用实例" class="header-anchor">#</a> (4)应用实例</h6> <p><strong>内存较小</strong>的系统可以使用: <strong>ParNew + CMS, ​</strong>一般的应用场景可以用这个组合.</p> <h5 id="_7-g1收集器"><a href="#_7-g1收集器" class="header-anchor">#</a> 7.G1收集器</h5> <h6 id="_1-概述"><a href="#_1-概述" class="header-anchor">#</a> (1)概述</h6> <p><strong>G1</strong>(Garbage-First) 是一款<strong>面向服务端</strong>应用的垃圾收集器, 主要针对配备<strong>多颗处理器及大容量内存</strong>的机器, <strong>以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征</strong>. JDK9 中默认的垃圾收集器就是 G1.</p> <p><strong>G1 可以同时用在年轻代和老年代. ​</strong>​<strong><strong>堆被分为新生代和老年代, 其它收集器进行收集的范围都是整个新生代或者老年代中的一个, 而 ​</strong></strong>​<strong><strong><strong>G1 可以直接对新生代和老年代一起回收. ​<strong><strong><strong>​</strong></strong></strong></strong>G1 的设计原则就是简单可行的性能调优, G1 将新生代, 老年代的</strong></strong><strong><strong>​</strong></strong><strong>物理空间<strong><strong><strong>​</strong></strong>划分</strong></strong>​<strong>取消</strong>了.</p> <p>G1 把<strong>堆</strong>划分成多个大小相等的<strong>独立区域</strong>(Region), 新生代和老年代<strong>不再</strong>物理隔离, 各个区域是<strong>不一定连续</strong>的. 如下图所示.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521153429792.png" alt=""></p> <p>一般 <strong>Region</strong> 大小等于<strong>堆大小除以 2048(个)</strong>, 比如堆大小为 4096 M, 则 Region 大小为 2M, 当然也可以用参数 &quot;-XX:G1HeapRegionSize&quot; 手动指定 Region 大小, 推荐默认的计算方式.</p> <p>G1 保留了<strong>年轻代和老年代的概念</strong>, 但<strong>不再是物理隔离</strong>了, 它们都是可以不连续 Region 的集合. 默认<strong>年轻代</strong>对堆内存的占比是 <strong>5%</strong>, 如果堆大小为 4096 M, 那么年轻代占据 200MB 左右的内存, 对应大概是 100 个 Region, 可以通过 &quot;-XX:G1NewSizePercent&quot; 设置<strong>年轻代初始占比</strong>, 在系统运行中, JVM 会<strong>不停的给年轻代增加更多</strong>的 Region, 但是最多<strong>新生代的占比不会超过 60%</strong>, 可以通过 &quot;-XX:G1MaxNewSizePercent&quot; 调整. 年轻代中的 Eden 和 Survivor 对应的 region 也跟之前一样, 默认 <strong>8:1:1</strong>, 假设年轻代现在有 1000 个 region, eden 区对应 800 个, s0 对应 100 个, s1 对应 100 个.</p> <p>一个 Region 可能之前是年轻代, 如果 Region 进行了垃圾回收, 之后可能又会变成老年代, 也就是说 Region 的<strong>区域功能可能会动态变化</strong>.</p> <p>G1 垃圾收集器对于对象什么时候会转移到老年代跟之前的原则(参考对象内存分配原则)一样, <strong>唯一不同的是对大对象的处理</strong>, G1 有<strong>专门分配大对象</strong>的 Region 叫 <strong>Humongous 区</strong>, 而<strong>不是让大对象直接进入老年代的 Region</strong> 中. 在 G1 中, 大对象的判定规则就是一个<strong>大对象</strong>超过了一个 <strong>Region 大小的 50%</strong>, 比如按照上面算的, 每个 Region 是 2M, 只要一个大对象超过了 1M, 就会被放入 <strong>Humongous</strong> 中, 而且一个大对象如果太大, 可能会<strong>横跨多个</strong> Region 来存放. 用 <strong>Humongous</strong> 区专门<strong>存放短期巨型对象</strong>, 不用直接进老年代, 可以节约老年代的空间, 避免因为老年代空间不够的 GC 开销. Full GC 的时候除了收集年轻代和老年代之外, 也会将 Humongous 区一并回收.</p> <p>通过引入 <strong>Region</strong> 的概念, 从而将原来的一整块内存空间划分成多个的<strong>小空间</strong>, 使得每个<strong>小空间</strong>可以<strong>单独</strong>进行垃圾回收. 这种划分方法带来了很大的灵活性, 使得<strong>可预测的停顿时间</strong>模型成为可能. 通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得), 并维护一个<strong>优先列表</strong>, 每次根据允许的收集时间, 优先回收<strong>价值最大</strong>的 Region. 每个 Region 都有一个 <strong>Remembered Set</strong>, 用来记录该 Region 对象的引用对象所在的 Region. 通过使用 Remembered Set, 在做可达性分析的时候就可以<strong>避免全堆扫描</strong>.</p> <h6 id="_2-收集流程"><a href="#_2-收集流程" class="header-anchor">#</a> (2)收集流程</h6> <p>对比 CMS 与 G1 的前面几个步骤都类似, 初始标记, 并发标记, 再次标记(最终标记), 不同主要在于最后一步的筛选回收的部分, G1 通过分 region 的方式可以设置<strong>具体的停顿时间</strong>, 并且 G1 不会产生内存碎片.</p> <p>如果<strong>不计算</strong>维护 Remembered Set 的操作, G1 收集器的运作大致可划分为以下几个步骤, 前几个步骤与 CMS 收集器类似, 主要区别在于<strong>第四步</strong>:</p> <ul><li><strong>初始标记(STW)</strong>: 类似 CMS 的初始标记, 暂停所有的其他线程, 并记录下 GC Roots 直接能引用的对象, <strong>速度很快</strong> .</li> <li><strong>并发标记</strong>: 类似 CMS 的并发标记.</li> <li><strong>最终标记(STW)</strong>: 类似 CMS 的重新标记. 为了修正在<strong>并发标记期间</strong>因用户线程<strong>继续运作</strong>而导致标记产生变动的那一部分标记记录, 虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面, 最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中. 这阶段需要停顿线程, 但是可并行执行.</li> <li><strong>筛选回收(STW)</strong>: 首先对各个 Region 中的**==回收价值和成本进行排序==<strong>, 根据用户所期望的 GC <strong>停顿 STW 时间(可以用参数 -XX:MaxGCPauseMillis 指定)</strong> 来制定回收计划. 比如老年代有 1000 个 Region 都满了, 但是根据预期设置的停顿时间, 本次垃圾回收可能</strong>只能停顿 200 毫秒**, 那么通过之前回收成本计算得知回收其中 800 个 Region 刚好需要 200ms, 那么就只会回收 800 个 Region, 尽量把 GC 导致的停顿时间控制在<strong>指定的范围内</strong>. 此阶段其实也可以做到与用户程序一起并发执行, 但是因为只回收<strong>一部分 Region</strong>, 时间是用户可控制的, 而且停顿用户线程将大幅度提高收集效率. G1 不管是年轻代或是老年代, <strong>回收算法主要用的是复制算法</strong>, <strong>将一个 region 中的存活对象复制到另一个 region 中, 这种不会像 CMS 那样回收完因为有很多内存碎片还需要整理一次, G1 采用复制算法回收几乎不会有太多内存碎片</strong>. 看上图觉得可能也会有很多空格, 这不算内存碎片, 因为一个 region 格子可以存放很多对象. (注意: CMS 回收阶段是跟用户线程一起并发执行的, G1 因为内部实现太复杂暂时没实现并发回收, 不过到了 ZGC, Shenandoah 就实现了并发收集, Shenandoah 可以看成是 G1 的升级版本).</li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521154201453.png" alt=""></p> <p><strong>G1 收集器在后台维护了一个优先列表, 每次根据允许的收集时间, 优先选择回收价值最大的 Region, 这也就是它的名字 Garbage-First 的由来. 比如一个 Region 花 200ms 能回收 10M 垃圾, 另外一个 Region 花 50ms 能回收 20M 垃圾, 在回收时间有限情况下, G1 当然会优先选择后面这个 Region 回收</strong>. 这种使用 Region 划分内存空间以及有<strong>优先级</strong>的区域回收方式, 保证了 G1 收集器在<strong>有限时间内可以尽可能高的收集效率</strong>.</p> <h6 id="_3-特点"><a href="#_3-特点" class="header-anchor">#</a> (3)特点</h6> <p>具备如下<strong>特点</strong>:</p> <ul><li><strong>并行与并发</strong>. G1 能充分利用 CPU, 多核环境下的硬件优势, 使用多 CPU 来<strong>缩短</strong> STW 停顿时间. 部分其他收集器原本需要停顿用户线程来执行 GC, G1 收集器可以通过并发的方式让用户线程继续执行.</li> <li>分代收集: 虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆, 但是依然保留了分代的概念.</li> <li><strong>空间整合</strong>: G1 从<strong>整体</strong>来看是基于 &quot;<strong>标记-整理</strong>&quot; 算法实现的收集器; 从<strong>局部</strong>(两个 Region 之间) 上来看是基于 &quot;<strong>复制</strong>&quot; 算法实现的, 这意味着运行期间<strong>不会产生内存空间碎片</strong>.</li> <li><strong>==可预测的停顿==</strong>: 这是 G1 相对于 CMS 的另一个大<strong>优势</strong>, <strong>降低 STW 时间</strong>是 G1 和 CMS 共同的关注点, 但 G1 除了追求低停顿外, 还能建立<strong>可预测的停顿时间模型</strong>, 能让使用者明确指定在一个**长度为 M 毫秒的时间片段(参数&quot;-XX:MaxGCPauseMillis&quot;)**内完成垃圾收集.</li></ul> <p>可以<strong>由用户指定期望的停顿时间</strong>是 G1 收集器很强大的一个功能, 设置不同的期望停顿时间, 可使得 G1 在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡. 不过这里设置的 &quot;期望值&quot; 必须是符合实际的, 毕竟 G1 需要暂停用户线程来复制对象, 这个停顿时间再怎么低也得有个<strong>限度</strong>. 它默认的停顿目标为 <strong>200ms</strong>. 一般来说, 回收阶段占到几十到一百甚至接近两百毫秒都很正常, 但如果把停顿时间调得非常低如二十毫秒, 很可能出现的结果就是由于停顿目标时间太短, 导致每次选出来的回收集只占堆内存很小的一部分, 收集器收集的速度逐渐跟不上分配器分配的速度, 导致<strong>垃圾慢慢堆积</strong>. 应用运行时间一长就不行了, 最终占满堆引发 Full GC 反而降低性能, 所以通常把期望停顿时间设置为 <strong>100-300 ms</strong> 会是比较合理的.</p> <h6 id="_4-参数设置"><a href="#_4-参数设置" class="header-anchor">#</a> (4)参数设置</h6> <p>可配置的虚拟机参数如下:</p> <ul><li>-XX:<strong>+UseG1GC</strong>: 使用 G1 收集器.</li> <li>-XX:<strong>ParallelGCThreads</strong>: 指定 GC 工作的<strong>线程数量</strong>.</li> <li>-XX:G1HeapRegionSize: 指定 Region 大小(1MB ~ 32MB, 且必须是 2 的幂), 默认将整堆划分为 2048 个 region.</li> <li>-<strong>XX:MaxGCPauseMillis</strong>: <strong>目标暂停时间</strong>(默认 <strong>200ms</strong>).</li> <li>-XX:G1NewSizePercent: 新生代内存初始空间(默认整堆 5%).</li> <li>-XX:G1MaxNewSizePercent: 新生代内存最大空间.</li> <li>-XX:TargetSurvivorRatio: Survivor 区的填充容量(默认 50%), Survivor 区域里的一批对象(年龄1 + 年龄2 + 年龄n 的多个年龄对象)总和超过了 Survivor 区域的 50%, 此时就会把年龄 n (含)以上的对象都放入老年代.</li> <li>-XX:MaxTenuringThreshold: 最大年龄阈值(默认 15).</li> <li>-XX:InitiatingHeapOccupancyPercent: 老年代占用空间达到整堆内存阈值(默认 45%), 则执行新生代和老年代的混合收集(<strong>MixedGC</strong>), 比如堆默认有 2048 个 Region, 如果有接近 1000 个 Region 都是老年代的, 则可能就要触发 MixedGC.</li> <li>-XX:G1HeapWastePercent(默认 5%): GC 过程中空出来的 region 是否充足阈值, 在混合回收的时候, 对 Region 回收都是基于复制算法进行的, 都是把要回收的 Region 里的存活对象放入其他 Region, 然后这个 Region 中的垃圾对象全部清理掉, 这样的话在回收过程就会不断空出来新的 Region, 一旦空闲出来的 Region 数量达到了堆内存的 5%, 此时就会立即停止混合回收, 意味着本次混合回收就结束了.</li> <li>-XX:G1MixedGCLiveThresholdPercent(默认85%): Region 中的存活对象低于这个值时才会回收该 Region, 如果超过这个值, 存活对象过多, 回收的意义不大.</li> <li>-XX:G1MixedGCCountTarget: 在一次回收过程中指定做几次筛选回收(默认 8 次), 在最后一个筛选回收阶段可以回收一会, 然后暂停回收, 恢复系统运行, 一会再开始回收, 这样可以让系统不至于单次停顿时间过长.</li></ul> <h6 id="_5-g1垃圾收集类型"><a href="#_5-g1垃圾收集类型" class="header-anchor">#</a> (5)G1垃圾收集类型</h6> <ul><li><p><strong>Young GC</strong>: Young GC 并不是说现有的 Eden 区放满了就会马上触发, G1 会计算下现在 Eden 区回收大概要多久时间, 如果回收时间远远小于参数 -XX:MaxGCPauseMills 设定的值, 那么<strong>增加年轻代的 region</strong>, 继续存放新对象, 不会马上做 Young GC, <strong>直到下一次 Eden 区放满</strong>. 当计算回收时间接近参数 -<strong>XX:MaxGCPauseMills</strong> 设定的值, 那么就会触发 Young GC.</p></li> <li><p><strong>Mixed GC</strong>: 不是 Full GC, 老年代的堆占有率达到参数(<strong>-XX:InitiatingHeapOccupancyPercent</strong>) 设定的值则触发, 回收<strong>所有的 Young 和部分 Old</strong>(根据期望的 GC 停顿时间确定 old 区垃圾收集的优先顺序)以及大对象区, 正常情况 G1 的垃圾收集是先做 <strong>Mixed GC</strong>, 主要使用<strong>复制算法</strong>, 需要把各个 region 中存活的对象拷贝到别的 region 里去, 拷贝过程中如果发现<strong>没有足够的空 region</strong> 能够承载拷贝对象就会触发一次 Full GC. 大对象也会在 Mixed GC 中回收.</p></li> <li><p><strong>Full GC</strong>: 停止<strong>系统程序</strong>, 然后采用单线程进行标记, 清理和压缩整理, 好空闲出来一批 Region 来供下一次 Mixed GC 使用, 这个过程非常耗时. (Shenandoah 优化成多线程收集了)</p></li></ul> <h6 id="_6-g1垃圾收集器优化建议"><a href="#_6-g1垃圾收集器优化建议" class="header-anchor">#</a> (6)G1垃圾收集器优化建议</h6> <p><strong>核心在于调节 -XX:MaxGCPauseMills(期望停顿时间) 参数的值</strong>, 需要保证<strong>年轻代 GC 别太频繁</strong>的同时, 还得考虑每次 GC 过后的存活对象有多少, 避免存活对象太多快速进入老年代, <strong>频繁触发 Mixed GC</strong>.</p> <p>假设参数 -<strong>XX:MaxGCPauseMills</strong> 设置的<strong>很大</strong>, 导致系统运行很久, 年轻代可能都占用了堆内存的 60%了, 此时才触发年轻代 GC. 那么存活下来的对象可能就会<strong>很多</strong>, 此时就会导致 Survivor 区域放不下那么多的对象, 就会进入<strong>老年代</strong>中. 或者是年轻代 GC 过后, 存活下来的对象过多, 导致进入 Survivor 区域后触发了动态年龄判定规则, 达到了 Survivor 区域的 50%, 也会快速导致一些对象进入老年代中. 但是 -<strong>XX:MaxGCPauseMills ​</strong>也不能设置的很小, 因为很小的情况下会导致每次 GC 可以清理的对象太少, 久而久之可能就触发 Full GC 了.</p> <blockquote><p>什么场景适合使​用G1?</p></blockquote> <ol><li>50% 以上的堆被<strong>存活对象</strong>占用.</li> <li>对象分配和晋升的<strong>速度变化</strong>非常大.</li> <li>垃圾回收<strong>时间特别长</strong>, 超过 1 秒.</li> <li>8GB 以上的<strong>堆内存</strong>(建议值), 即<strong>大内存</strong>下.</li> <li>停顿时间是 <strong>500ms 以内</strong>.</li></ol> <h6 id="_7-g1应用实例"><a href="#_7-g1应用实例" class="header-anchor">#</a> (7)G1应用实例</h6> <p>对于 Kafka 这种高并发消息的系统来说, <strong>每秒处理几万甚至几十万消息</strong>是很正常的, 一般部署 Kafka 需要用<strong>大内存机器</strong>(比如 64G), 也就是说可以给年轻代分配三四十 G 的内存用来支撑高并发处理. 这里就涉及到一个问题, 之前说对于 eden 区的 Young GC 是<strong>很快</strong>的, 这种情况下它的执行还会很快吗? 很显然不可能, 因为内存太大, 处理还是要花不少时间的, 假设三四十 G 内存回收可能最快也要<strong>几秒钟</strong>, 按 Kafka 这个<strong>并发量放满三四十 G 的 eden 区可能也就一两分钟</strong>, 那么意味着整个系统<strong>每运行一两分钟就会因为 Young GC 卡顿几秒钟</strong>没法处理新消息, 这显然不行. 这种情况可以使用 G1 收集器, 设置 -<strong>XX:MaxGCPauseMills</strong> 为 <strong>50ms</strong>, 假设 50ms 能够回收三到四个 G 内存, 然后 50ms 的卡顿完全能够接受, 用户几乎无感知, 那么整个系统就可以在卡顿几乎无感知的情况下<strong>一边处理业务一边收集垃圾</strong>.</p> <p><strong>G1 天生就适合这种大内存机器的 JVM 运行, 可以比较完美的解决大内存垃圾回收时间过长的问题. 如果用 CMS 这种收集器的话, 在大内存下由于需要处理的内存太大而导致 STW 的时间可能会很长. ​</strong></p> <h5 id="_8-zgc"><a href="#_8-zgc" class="header-anchor">#</a> 8.ZGC</h5> <p>ZGC 是一款 JDK 11 中新加入的具有实验性质的低延迟垃圾收集器.</p> <p>ZGC 的目标主要有:</p> <ul><li>支持 TB 量级的堆.</li> <li>GC 停顿时间极低, 可以低至 10ms 量级.</li> <li><strong>GC 停顿时间不会随内存空间增大而增大</strong>. 这个是很猛的特性.</li></ul> <p><strong>ZGC 没有分代</strong>. 之前的垃圾回收器之所以分代, 是源于 &quot;大部分对象朝生夕死&quot; 的假设, 事实上大部分系统的对象分配行为也确实符合这个假设. <strong>不同对象的生命周期是不一致的</strong>, 所以才有了分代的处理方式.</p> <p>为什么 ZGC 不分代? 因为分代实现起来麻烦, 作者就先实现出一个比较简单可用的单代版本, 后续会优化.</p> <h6 id="_1-zgc内存布局"><a href="#_1-zgc内存布局" class="header-anchor">#</a> (1)ZGC内存布局</h6> <p>ZGC 收集器是一款基于 Region 内存布局的, 暂时不设分代的, 使用了读屏障, 颜色指针等技术来实现可并发的标记-整理算法的, 以低延迟为首要目标的一款垃圾收集器.</p> <p>ZGC 的 Region 可以具有下图所示的大, 中, 小三类容量:</p> <ul><li>小型 Region(Small Region): 容量固定为 2MB,  用于放置小于 256KB 的小对象.</li> <li>中型 Region(Medium Region): 容量固定为 32MB,  用于放置大于等于 256KB 但小于 4MB 的对象.</li> <li>大型 Region(Large Region): 容量不固定, 可以动态变化, 但必须为 2MB 的整数倍, 用于放置 4MB 或以上的大对象. 每个大型 Region 中只会存放一个大对象, 这也预示着虽然名字叫作 &quot;大型Region&quot;, 但它的实际容量完全有可能小于中型 Region, 最小容量可低至 4MB. 大型 Region 在 ZGC 的实现中是不会被重分配(重分配是 ZGC 的一种处理动作, 用于复制对象的收集器阶段)的, 因为复制一个大对象的代价非常高昂.</li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230401144145-pz9ey01.png" alt="image"></p> <h6 id="_2-zgc运作过程"><a href="#_2-zgc运作过程" class="header-anchor">#</a> (2)ZGC运作过程</h6> <p>ZGC 的运作过程大致可划分为以下四个大的阶段:</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230401144700-nm0r1n2.png" alt="image"></p> <ul><li><strong>并发标记(Concurrent Mark)</strong>: 与 G1 一样, 并发标记是遍历对象图做可达性分析的阶段, 它的初始标记(Mark Start)和最终标记(Mark End)也会出现短暂的停顿, 与 G1 不同的是, ZGC 的标记是在指针上而不是在对象上进行的, 标记阶段会更新颜色指针(见下面详解)中的 Marked 0, Marked 1 标志位.</li> <li><strong>并发预备重分配(Concurrent Prepare for Relocate)</strong>: 这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些 Region, 将这些 Region 组成重分配集(Relocation Set). ZGC 每次回收都会扫描所有的 Region, 用范围更大的扫描成本换取省去 G1 中记忆集的维护成本.</li> <li><strong>并发重分配(Concurrent Relocate)</strong>: 重分配是 ZGC 执行过程中的<strong>核心阶段</strong>, 这个过程要把重分配集中的<strong>存活对象复制到新的 Region 上</strong>, 并为重分配集中的每个 Region 维护一个<strong>转发表</strong>(Forward Table), 记录从旧对象到新对象的转向关系. ZGC 收集器能仅从引用上就明确得知一个对象是否处于重分配集之中, 如果用户线程此时并发访问了位于重分配集中的对象, 这次访问将会被预置的内存屏障(读屏障(见下面详解))所截获, 然后立即根据 Region上的转发表记录将访问转发到新复制的对象上, 并同时修正更新该引用的值, 使其直接指向新对象, ZGC 将这种行为称为指针的&quot;自愈&quot;(Self-Healing)能力. ZGC 的颜色指针因为&quot;自愈&quot;能力, 所以只有第一次访问旧对象会变慢, 一旦重分配集中某个 Region 的存活对象都复制完毕后, 这个 Region 就可以立即释放用于新对象的分配, 但是转发表还得留着不能释放掉, 因为可能还有访问在使用这个转发表.</li> <li><strong>并发重映射(Concurrent Remap)</strong>: 重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用, 但是 ZGC 中对象引用存在&quot;自愈&quot;功能, 所以这个重映射操作并不是很迫切. ZGC 很巧妙地把并发重映射阶段要做的工作, <strong>合并到了下一次垃圾收集循环中的并发标记阶段里去完成</strong>, 反正它们都是要遍历所有对象的, 这样合并就节省了一次遍历对象图的开销. 一旦所有指针都被修正之后, 原来记录新旧对象关系的转发表就可以释放掉了.</li></ul> <h6 id="_3-颜色指针"><a href="#_3-颜色指针" class="header-anchor">#</a> (3)颜色指针</h6> <p>Colored Pointers, 即颜色指针, ZGC 的核心设计之一. 以前的垃圾回收器的 GC 信息都保存在对象头中, 而 ZGC 的 GC 信息保存在指针中.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230401144421-3vmomk0.png" alt="image"></p> <p>每个对象有一个 64 位指针, 这 64 位被分为:</p> <ul><li>18 位: 预留给以后使用;</li> <li>1 位: Finalizable 标识, 此位与并发引用处理有关, 它表示这个对象只能通过 finalizer 才能访问;</li> <li>1 位: Remapped 标识, 设置此位的值后, 对象未指向 relocation set 中(relocation set表示需要GC的Region集合);</li> <li>1 位: Marked1 标识;</li> <li>1 位: Marked0 标识, 和上面的 Marked1 都是标记对象用于辅助 GC;</li> <li>42 位: 对象的地址(所以它可以支持2^42=4T内存):</li></ul> <p>为什么有 2 个 mark 标记?</p> <p>每一个 GC 周期开始时, 会交换使用的标记位, 使上次 GC 周期中修正的已标记状态失效, 所有引用都变成未标记.</p> <p>GC 周期 1: 使用 mark0, 则周期结束所有引用 mark 标记都会成为 01.</p> <p>GC 周期 2: 使用 mark1, 则期待的 mark 标记 10, 所有引用都能被重新标记.</p> <p>通过对配置 ZGC 后对象指针分析可知, 对象指针必须是 64 位, 那么 ZGC 就无法支持 32 位操作系统, 同样的也就无法支持压缩指针了(CompressedOops, 压缩指针也是 32 位).</p> <p>颜色指针的三大优势:</p> <ol><li>一旦某个 Region 的存活对象被移走之后, 这个 Region 立即就能够被释放和重用掉, 而不必等待整个堆中所有指向该 Region 的引用都被修正后才能清理, 这使得理论上只要还有一个空闲 Region, ZGC 就能完成收集.</li> <li>颜色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量, ZGC 只使用了读屏障.</li> <li>颜色指针具备强大的扩展性, 它可以作为一种可扩展的存储结构用来记录更多与对象标记, 重定位过程相关的数据, 以便日后进一步提高性能.</li></ol> <h6 id="_4-读屏障"><a href="#_4-读屏障" class="header-anchor">#</a> (4)读屏障</h6> <p>之前的 GC 都是采用 Write Barrier, ZGC 采用了完全不同的方案: 读屏障. 假如尝试读取堆中的一个对象引用并赋值给另一个对象, 如果这时候对象在 GC 时被移动了, 接下来 JVM 就会加上一个读屏障, 这个读屏障会把读出的指针更新到对象的新地址上, 并把堆里的之歌指针“修正”到元吧的字段里. 这样就算 GC 把对象移动了, 读屏障也会发现并修正指针, 于是应用程序持有的就是更新后的有效指针, 而且不需要 STW.</p> <h6 id="_5-zgc存在的问题"><a href="#_5-zgc存在的问题" class="header-anchor">#</a> (5)ZGC存在的问题</h6> <p>ZGC 最大的问题是浮动垃圾. ZGC 的停顿时间是在 10ms 以下, 但是 ZGC 的执行时间还是远远大于这个时间的. 假如 ZGC 全过程需要执行 10 分钟, 在这个期间由于对象分配速率很高, 将创建大量的新对象, 这些对象很难进入当次 GC, 所以只能在下次 GC 的时候进行回收, 这些只能等到下次 GC 才能回收的对象就是浮动垃圾.</p> <blockquote><p>ZGC 没有分代概念, 每次都需要进行全堆扫描, 导致一些&quot;朝生夕死&quot;的对象没能及时的被回收.</p></blockquote> <p><strong>解决方案</strong></p> <p>目前唯一的办法是<strong>增大堆的容量</strong>, 使得程序得到更多的喘息时间, 但是这个也是一个治标不治本的方案. 如果需要从根本上解决这个问题, 还是需要引入分代收集, 让新生对象都在一个专门的区域中创建, 然后专门针对这个区域进行更频繁, 更快的收集.</p> <h6 id="_6-zgc参数设置"><a href="#_6-zgc参数设置" class="header-anchor">#</a> (6)ZGC参数设置</h6> <p>启用 ZGC 比较简单, 设置 JVM 参数即可: -XX:+UnlockExperimentalVMOptions, -XX:+UseZGC. 调优也并不难, 因为 ZGC 调优参数并不多, 远不像 CMS 那么复杂. 它和 G1 一样, 可以调优的参数都比较少, 大部分工作 JVM 能很好的自动完成.</p> <h5 id="_9-比较与选择"><a href="#_9-比较与选择" class="header-anchor">#</a> 9.比较与选择</h5> <table><thead><tr><th style="text-align:center;">收集器</th> <th style="text-align:center;">单线程/并行</th> <th style="text-align:center;">串行/并发</th> <th style="text-align:center;">新生代/老年代</th> <th style="text-align:center;">收集算法</th> <th style="text-align:center;">目标</th> <th style="text-align:center;">适用场景</th></tr></thead> <tbody><tr><td style="text-align:center;"><strong>Serial</strong></td> <td style="text-align:center;">单线程</td> <td style="text-align:center;">串行</td> <td style="text-align:center;">新生代</td> <td style="text-align:center;">复制</td> <td style="text-align:center;">响应速度优先</td> <td style="text-align:center;">单 CPU 环境下的 Client 模式</td></tr> <tr><td style="text-align:center;"><strong>ParNew</strong></td> <td style="text-align:center;">并行</td> <td style="text-align:center;">串行</td> <td style="text-align:center;">新生代</td> <td style="text-align:center;">复制算法</td> <td style="text-align:center;">响应速度优先</td> <td style="text-align:center;">多 CPU 环境时在 Server 模式下与 CMS 配合</td></tr> <tr><td style="text-align:center;"><strong>Parallel Scavenge</strong></td> <td style="text-align:center;">并行</td> <td style="text-align:center;">串行</td> <td style="text-align:center;">新生代</td> <td style="text-align:center;">复制算法</td> <td style="text-align:center;">吞吐量优先</td> <td style="text-align:center;">在后台运算而不需要太多交互的任务</td></tr> <tr><td style="text-align:center;"><strong>Serial Old</strong></td> <td style="text-align:center;">单线程</td> <td style="text-align:center;">串行</td> <td style="text-align:center;">老年代</td> <td style="text-align:center;">标记-整理</td> <td style="text-align:center;">响应速度优先</td> <td style="text-align:center;">单 CPU 环境下的 Client 模式, CMS 的后备预案</td></tr> <tr><td style="text-align:center;"><strong>Parallel Old</strong></td> <td style="text-align:center;">并行</td> <td style="text-align:center;">串行</td> <td style="text-align:center;">老年代</td> <td style="text-align:center;">标记-整理</td> <td style="text-align:center;">吞吐量优先</td> <td style="text-align:center;">在后台运算而不需要太多交互的任务</td></tr> <tr><td style="text-align:center;"><strong>CMS</strong></td> <td style="text-align:center;"><strong>并行</strong></td> <td style="text-align:center;"><strong>并发</strong></td> <td style="text-align:center;">老年代</td> <td style="text-align:center;">标记-清除</td> <td style="text-align:center;">响应速度优先</td> <td style="text-align:center;">集中在互联网站或 B/S 系统服务端上的 Java 应用</td></tr> <tr><td style="text-align:center;"><strong>G1</strong></td> <td style="text-align:center;"><strong>并行</strong></td> <td style="text-align:center;"><strong>并发</strong></td> <td style="text-align:center;">新生代 + 老年代</td> <td style="text-align:center;">标记-整理 + 复制算法</td> <td style="text-align:center;">响应速度优先</td> <td style="text-align:center;"><strong>面向服务端应用, 替换 CMS</strong></td></tr></tbody></table> <p><strong>内存较小推荐使用 ParNew + CMS. 内存较大使用 G1.</strong></p> <p>一些选用的策略:</p> <ol><li>优先调整堆的大小让服务器自己来选择.</li> <li>如果内存小于 100M, 使用串行收集器.</li> <li>如果是<strong>单核</strong>, 并且没有停顿时间的要求, 串行或 JVM 自己选择.</li> <li>如果允许停顿时间超过 1 秒, 选择并行或者 JVM 自己选.</li> <li>如果响应时间最重要, 并且不能超过 1 秒, 使用并发收集器.</li></ol> <p>Jdk1.7 默认垃圾收集器 Parallel Scavenge(新生代) + Parallel Old(老年代).</p> <p><strong>Jdk1.8</strong> 默认垃圾收集器 <strong>Parallel Scavenge(新生代) + Parallel Old(老年代)</strong>.</p> <p><strong>Jdk1.9</strong> 默认垃圾收集器 <strong>G1</strong>.</p> <h4 id="三色标记"><a href="#三色标记" class="header-anchor">#</a> 三色标记</h4> <h5 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h5> <p>在 CMS 并发标记的过程中, 需要从 GC Root 对对象进行标记. 由于<strong>标记期间不是 STW 的, 应用线程还在继续跑, 对象间的引用可能发生变化, 多标和漏标的情况就有可能发生</strong>.</p> <p><strong>漏标的问题主要引入了三色标记算法</strong>来解决.</p> <p>三色标记算法是把 GC roots 可达性分析遍历对象过程中遇到的对象, 按照 &quot;<strong>是否访问过</strong>&quot; 这个条件标记成以下三种颜色:</p> <ul><li><strong>==黑色==</strong>: 表示对象已经被垃圾收集器访问过, 且<strong>这个对象的所有引用都已经扫描过</strong>. 黑色的对象代表已经扫描过, <strong>它是安全存活的</strong>, 如果有其他对象引用指向了黑色对象, 无须重新扫描一遍. 黑色对象不可能直接(不经过灰色对象)指向某个白色对象.</li> <li><strong>==灰色==</strong>: 表示对象已经被垃圾收集器访问过, 但这个<strong>对象上至少存在一个引用还没有被扫描过</strong>. 灰色对象在重新标记阶段会重新扫描, 这里对象不会有状态变化了, 因为重新标记阶段会 STW.</li> <li><strong>==白色==</strong>: 表示对象<strong>尚未被垃圾收集器访问过</strong>. 显然在可达性分析刚刚开始的阶段, 所有的对象都是白色的; 若在分析结束的阶段, 仍然是白色的对象, 即代表不可达.</li></ul> <p>看一个例子:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * 垃圾收集算法细节之三色标记(为简化例子, 代码是伪代码)
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreeColorRemark</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 开始做并发标记</span>
        <span class="token class-name">D</span> d <span class="token operator">=</span> a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>d<span class="token punctuation">;</span>   <span class="token comment">// 1.读</span>
        a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>d <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// 2.写</span>
        a<span class="token punctuation">.</span>d <span class="token operator">=</span> d<span class="token punctuation">;</span>       <span class="token comment">// 3.写</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">D</span> d <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token class-name">C</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">D</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>这里染色示例如下:</p> <p><img src="assets/image-20230326155210-h9m0v1n.png" alt="https://www.processon.com/diagraming/641ff8acb13bd654f02a20cd"></p> <p>标记染色过程可能产生<strong>多标与漏标</strong>问题.</p> <h5 id="多标问题与浮动垃圾"><a href="#多标问题与浮动垃圾" class="header-anchor">#</a> 多标问题与浮动垃圾</h5> <p>在并发标记过程中, 如果由于用户线程运行结束导致部分局部变量(gcroot)被销毁, 这个 gcroot 引用的对象<strong>之前又被扫描过</strong>(被标记为非垃圾对象), 那么本轮 GC 不会回收这部分内存. 这部分本应该回收但是没有回收到的内存, 被称之为&quot;浮动垃圾&quot;. 浮动垃圾并不会影响垃圾回收的正确性, 只是需要等到下一轮垃圾回收中才被清除.</p> <p>另外, 针对并发标记(还有并发清理)<strong>开始后产生的新对象, 通常的做法是直接全部当成黑色</strong>, 本轮不会进行清除. 这部分对象期间可能也会变为垃圾, 这也算是浮动垃圾的一部分.</p> <h5 id="漏标问题与读写屏障"><a href="#漏标问题与读写屏障" class="header-anchor">#</a> 漏标问题与读写屏障</h5> <p><strong>漏标会导致被引用的对象被当成垃圾误删除. ​</strong>比如刚开始某对象没有引用, 但是随着业务线程执行被引用了. 漏标问题必须解决, 有两种解决方案: <strong>增量更新(Incremental Update)和原始快照(Snapshot At The Beginning, SATB)</strong>.</p> <p><strong>增量更新</strong>就是当黑色对象插入新的指向白色对象的引用关系时, 就将这个新插入的引用记录下来, 等并发扫描结束之后, 再将这些记录过的引用关系中的黑色对象为根, <strong>重新扫描一次</strong>. 这可以简化理解为,  黑色对象一旦新插入了指向白色对象的引用之后, 它就<strong>变回灰色对象</strong>了.</p> <p><strong>原始快照</strong>就是当灰色对象要删除指向白色对象的引用关系时, 就将这个要删除的引用记录下来, 在并发扫描结束之后, 再将这些记录过的引用关系中的灰色对象为根, <strong>重新扫描一次</strong>, 这样就能扫描到白色的对象, 将白色对象直接标记为黑色(目的就是让这种对象在本轮 GC 清理中能存活下来, 待下一轮 GC 的时候重新扫描, 这个对象也有可能是浮动垃圾).</p> <p>以上无论是对引用关系记录的插入还是删除, 虚拟机的记录操作都是通过<strong>写屏障</strong>实现的, 写屏障是<strong>代码级别实现</strong>的, 与 JMM 中的写屏障不一样, 这里更类似于 AOP 操作.</p> <h6 id="_1-写屏障"><a href="#_1-写屏障" class="header-anchor">#</a> (1)写屏障</h6> <p>给某个对象的成员变量赋值时, 其底层代码大概如下, 下面都是<strong>伪代码</strong>.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/**
 * @param field 某对象的成员变量, 如 a.b.d 
 * @param new_value 新值, 如 null
 */</span>
<span class="token keyword">void</span> <span class="token function">oop_field_store</span><span class="token punctuation">(</span>oop<span class="token operator">*</span> field<span class="token punctuation">,</span> oop new_value<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token operator">*</span>field <span class="token operator">=</span> new_value<span class="token punctuation">;</span> <span class="token comment">// 赋值操作</span>
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>所谓写屏障其实就是指在赋值操作前后, 加入一些处理(可以参考 AOP 的概念):</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">oop_field_store</span><span class="token punctuation">(</span>oop<span class="token operator">*</span> field<span class="token punctuation">,</span> oop new_value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token function">pre_write_barrier</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 写屏障-写前操作</span>
    <span class="token operator">*</span>field <span class="token operator">=</span> new_value<span class="token punctuation">;</span>               <span class="token comment">// 赋值操</span>
    <span class="token function">post_write_barrier</span><span class="token punctuation">(</span>field<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 写屏障-写后操作</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>写屏障实现SATB</p></blockquote> <p>当对象 B 的成员变量的引用发生变化时, 比如引用消失(a.b.d = null), 可以利用写屏障, 将 B 原来成员变量的引用对象 D 记录下来. SATB 是记录删掉的引用, 因此需要在删之前进行记录.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">pre_write_barrier</span><span class="token punctuation">(</span>oop<span class="token operator">*</span> field<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    oop old_value <span class="token operator">=</span> <span class="token operator">*</span>field<span class="token punctuation">;</span>    <span class="token comment">// 获取旧值</span>
    remark_set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>old_value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录原来的引用对象(加入到一个set中)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>写屏障实现增量更新</p></blockquote> <p>当对象 A 的成员变量的引用发生变化时, 比如新增引用(a.d = d), 可以利用写屏障, 将 A 新的成员变量引用对象 D 记录下来. 增量更新是记录新增的引用, 因此要在新增之后进行记录.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">post_write_barrier</span><span class="token punctuation">(</span>oop<span class="token operator">*</span> field<span class="token punctuation">,</span> oop new_value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    remark_set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 记录新引用的对象(加入到一个set中)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h6 id="_2-读屏障"><a href="#_2-读屏障" class="header-anchor">#</a> (2)读屏障</h6> <p>读屏障实现伪代码如下.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>oop <span class="token function">oop_field_load</span><span class="token punctuation">(</span>oop<span class="token operator">*</span> field<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">pre_load_barrier</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读屏障-读取前操作</span>
    <span class="token keyword">return</span> <span class="token operator">*</span>field<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>读屏障是当<strong>读取成员变量</strong>时, 一律记录下来:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">pre_load_barrier</span><span class="token punctuation">(</span>oop<span class="token operator">*</span> field<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    oop old_value <span class="token operator">=</span> <span class="token operator">*</span>field<span class="token punctuation">;</span>
    remark_set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>old_value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录读取到的对象</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h6 id="_3-总结"><a href="#_3-总结" class="header-anchor">#</a> (3)总结</h6> <p>现代<strong>追踪式(可达性分析)的垃圾回收器几乎都借鉴了三色标记的算法思想</strong>, 尽管实现的方式不尽相同: 比如白色/黑色集合一般都不会出现(但是有其他体现颜色的地方), 灰色集合可以通过栈/队列/缓存日志等方式进行实现, 遍历方式可以是广度/深度遍历等等.</p> <p>对于读写屏障, 以 Java HotSpot VM 为例, 其并发标记时对<strong>漏标</strong>的处理方案如下:</p> <ul><li>CMS: 写屏障 + 增量更新</li> <li>G1, Shenandoah: 写屏障 + SATB</li> <li>ZGC: 读屏障</li></ul> <p>工程实现中, 读写屏障还有其他功能, 比如写屏障可以用于记录跨代/区引用的变化, 读屏障可以用于支持移动对象的并发执行等. 功能之外, 还有性能的考虑, 所以对于选择哪种, 每款垃圾回收器都有自己的想法.</p> <h4 id="内存泄漏与内存溢出"><a href="#内存泄漏与内存溢出" class="header-anchor">#</a> 内存泄漏与内存溢出</h4> <h5 id="_1-内存泄漏"><a href="#_1-内存泄漏" class="header-anchor">#</a> 1.内存泄漏</h5> <p>指<strong>无用对象</strong>(不再使用的对象)<strong>持续占有内存</strong>或无用对象的内存得不到及时释放, 从而造成的内存空间的浪费称为内存泄露. 某些对象可以关联到 GC Roots 对象, 但是在业务上已经不需要再使用了, 这些对象不会被 GC 所回收, 然而它却占用内存, 这就会导致内存泄漏.</p> <h5 id="_2-内存泄漏原因"><a href="#_2-内存泄漏原因" class="header-anchor">#</a> 2.内存泄漏原因</h5> <p><strong>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露</strong>, 尽管短生命周期对象已经不再需要, 但是<strong>因为长生命周期对象持有它的引用而导致不能被回收</strong>. 具体主要有如下几大类场景:</p> <h6 id="_1-静态集合类"><a href="#_1-静态集合类" class="header-anchor">#</a> (1)静态集合类</h6> <p>使用静态集合类, 比如 Set, Vector, HashMap 等集合类的时候需要特别注意. 当这些类被定义成静态时, 其生命周期跟应用程序一样长, 这时候就有可能发生内存泄漏.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 例子 </span>
<span class="token keyword">class</span> <span class="token class-name">StaticTest</span> <span class="token punctuation">{</span> 
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Vector</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token class-name">Object</span> object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            v<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            object <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上面的代码中, 循环申请 object 对象, 并添加到 Vector 中, 然后设置 object = null(就是清除栈中引用变量 object), 但是这些对象被 vector 引用着, 必然不能被 GC 回收, 造成内存泄露. 因此要释放这些对象, 还需要将它们从 vector 中删除, 最简单的方法就是将 <strong>vector=null</strong>, 清空集合类中的引用.</p> <h6 id="_2-监听器"><a href="#_2-监听器" class="header-anchor">#</a> (2)监听器</h6> <p>许多场景都需要和监听器打交道, 通常一个应用中会用到很多监听器, 但往往在释放的时候却没有去删除这些监听器, 从而增加了内存泄漏的可能.</p> <h6 id="_3-各种连接"><a href="#_3-各种连接" class="header-anchor">#</a> (3)各种连接</h6> <p>比如<strong>数据库连接</strong>, 网络连接和 IO 连接等, 除非其显式的调用了其 <strong>close</strong>() 方法将其连接关闭, <strong>否则是不会自动被 GC 回收的</strong>.</p> <h6 id="_4-内部类和外部模块等的引用"><a href="#_4-内部类和外部模块等的引用" class="header-anchor">#</a> (4)内部类和外部模块等的引用</h6> <p><strong>内部类</strong>的引用是比较容易遗忘的一种, 而且一旦没释放可能导致一系列的后继类对象没有释放. 在调用外部模块的时候, 也应该注意防止内存泄漏, 如果模块 A 调用了外部模块 B 的一个方法, 如 register(Object o), 这个方法有可能就使得 A 模块持有传入对象的引用, 这时候需要查看 B 模块是否提供了出去引用的方法, 这种情况容易忽略, 而且发生内存泄漏的话, 还比较难察觉.</p> <h6 id="_5-单例模式"><a href="#_5-单例模式" class="header-anchor">#</a> (5)单例模式</h6> <p>因为单利对象初始化后将在 JVM 的<strong>整个生命周期内存在</strong>, 如果它持有一个生命周期比较短的外部对象的引用, 那么这个外部对象就不能被回收, 从而导致内存泄漏. 如果这个外部对象还持有其他对象的引用, 那么内存泄漏更严重.</p> <h5 id="_3-内存泄露查询工具"><a href="#_3-内存泄露查询工具" class="header-anchor">#</a> 3.内存泄露查询工具</h5> <ul><li><strong>MemoryAnalyzer</strong>: 一个功能丰富的 JAVA <strong>堆转储</strong>文件分析工具, 可以发现内存漏洞和减少内存消耗.</li> <li><strong>EclipseMAT</strong>: 是一款开源的 JAVA 内存分析软件, 查找内存泄漏, 能容易找到大块内存并验证谁在一直占用它. .</li></ul> <h5 id="_4-内存溢出"><a href="#_4-内存溢出" class="header-anchor">#</a> 4.内存溢出</h5> <p><strong>内存溢出</strong>: 指程序运行过程中<strong>无法申请到足够的内存</strong>而导致的一种错误, 当内存较小的时候可能正常的业务也会导致内存溢出. <strong>内存泄露是内存溢出的一种诱因</strong>, 不是唯一因素.</p> <p>说白了就是内存不够用了.</p> <h4 id="溢出异常"><a href="#溢出异常" class="header-anchor">#</a> 溢出异常</h4> <h5 id="_1-堆溢出异常"><a href="#_1-堆溢出异常" class="header-anchor">#</a> 1.堆溢出异常</h5> <p>堆用于存储对象实例, 只要不断地创建对象, 并且保证 GC Roots 到对象之间有可达路径来避免垃圾回收机制清除这些对象, 那么在<strong>对象数量到达最大堆的容量限制</strong>后就会产生内存溢出异常.</p> <p>将堆的大小限制为 20MB, 不可扩展(将堆的最小值 -Xms 参数与最大值 -Xmx 参数设置为一样即可避免堆自动扩展), 通过参数 <strong>-XX:+HeapDumpOnOutOfMemoryError</strong> 可以让虚拟机在出现内存溢出异常时 Dump 出当前的内存堆转储快照以便后续分析.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapOOM</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OOMObject</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OOMObject</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HeapOOM<span class="token punctuation">.</span>OOMObject</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OOMObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>当出现堆内存溢出时, 异常堆栈信息 &quot;java.lang.OutOfMemoryError&quot; 会跟着进一步提示 &quot;<strong>Java heap space</strong>&quot;.</p> <p>要解决堆内存溢出异常, 一般的手段是先通过<strong>内存映像分析工具</strong>(如 Eclipse Memory Analyzer) 对 Dump 出来的<strong>堆转储快照进行分析</strong>, 重点是确认内存中的对象是否是必要的, 也就是要先分清除到底是出现了<strong>内存泄漏(Memory Leak) 还是内存溢出(Memory Overflow)</strong>.</p> <p>如果是<strong>内存泄漏</strong>, 可进一步通过工具查看泄漏对象到 GC Roots 的引用链. 于是就能找到泄露对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的. 掌握了泄漏对象的类型信息及 GC Roots 引用链的信息, 就可以比较准确的定位出泄漏代码的位置.</p> <p>如果<strong>不存在泄漏</strong>, 换句话说就是内存中的对象确实还必须存活着, 那就应当检查虚拟机的<strong>堆参数</strong>(-Xmx 与 -Xms), 与机器物理内存对比看是否还可以调大, 从代码上检查是否存在某些对象生命周期过长, 持有状态时间过长的情况, 尝试减少的程序运行期的内存消耗.</p> <h5 id="_2-虚拟机栈和本地方法栈溢出"><a href="#_2-虚拟机栈和本地方法栈溢出" class="header-anchor">#</a> 2.虚拟机栈和本地方法栈溢出</h5> <p>由于在 Hotspot 虚拟机中<strong>不区分虚拟机栈和本地方法栈</strong>, 可以通过修改 <strong>-Xss</strong> 设定.</p> <ul><li>如果线程请求的栈深度大于虚拟机允许的<strong>最大深度</strong>, 将抛出 <strong>StackOverflowError</strong> 异常.</li> <li>如果虚拟机在扩展栈时无法申请到足够的<strong>内存空间</strong>, 将抛出 <strong>OutOfMemoryError</strong> 异常.</li></ul> <p>这两种异常有一些重叠的部分: 当栈空间无法继续分配时, 到底是内存太小, 还是已经使用的栈空间过大, 其本质只是对同一件事情的两种不同描述.</p> <p>可以通过递归调用的方式进行测试:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h5 id="_3-方法区溢出"><a href="#_3-方法区溢出" class="header-anchor">#</a> 3.方法区溢出</h5> <p><strong>动态代理</strong>可能在运行时产生大量的<strong>类导致方法区溢出</strong>, 所以 Spring 等实用 CGLIB 可以配置较大的<strong>方法区</strong>.</p> <h5 id="_4-本机直接内存溢出"><a href="#_4-本机直接内存溢出" class="header-anchor">#</a> 4.本机直接内存溢出</h5> <p><strong>DirectoryMemory</strong> 可以通过 -<strong>XX: MaxDirectMemorySize</strong> 指定, 如果不指定则默认与 Java 堆大小一样. 其明显特征是 Heap Dump 文件中不会看见明显的异常, 如果 Dump 文件很小, 程序中又直接或者间接<strong>使用了 NIO</strong>, 可以检查一下是否是这方面原因.</p> <p>‍</p> <h4 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h4> <ul><li>如何阅读GC日志: <a href="https://www.jianshu.com/p/4e508ed55155" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/4e508ed55155<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>《深入理解 Java 虚拟机: JVM 高级特性与最佳实践(第二版》</li> <li><a href="https://my.oschina.net/hosee/blog/644618" target="_blank" rel="noopener noreferrer">https://my.oschina.net/hosee/blog/644618<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://cloud.tencent.com/developer/article/1958285" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1958285<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/20.开发/2200.JVM/2.内存分配与垃圾收集.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/943c23/" class="prev">JVM内存区域与对象解析</a></span> <span class="next"><a href="/pages/d09a16/">JVM监控与故障处理工具</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/f90282/"><div>
            基础
            <!----></div></a> <span class="date">06-08</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/0f75ac/"><div>
            搜索二叉树BST
            <!----></div></a> <span class="date">06-08</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/39721f/"><div>
            平衡二叉树AVL
            <!----></div></a> <span class="date">06-08</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2023
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.5bc2c979.js" defer></script><script src="/assets/js/2.eccd4273.js" defer></script><script src="/assets/js/166.995d24ad.js" defer></script>
  </body>
</html>
