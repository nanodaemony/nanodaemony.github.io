<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>后端编译与优化🌼 | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/87.281da75d.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/4f30b9/" class="sidebar-link">Java基础</a></li><li><a href="/pages/795eca/" class="sidebar-link">类与继承</a></li><li><a href="/pages/c69152/" class="sidebar-link">抽象类与接口</a></li><li><a href="/pages/d71abb/" class="sidebar-link">内部类</a></li><li><a href="/pages/f06dca/" class="sidebar-link">枚举类</a></li><li><a href="/pages/259f57/" class="sidebar-link">常用类</a></li><li><a href="/pages/84b03b/" class="sidebar-link">关键字</a></li><li><a href="/pages/31b87b/" class="sidebar-link">注解</a></li><li><a href="/pages/f81c0d/" class="sidebar-link">异常</a></li><li><a href="/pages/ae7746/" class="sidebar-link">泛型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>容器类</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/0c88ac/" class="sidebar-link">集合容器类基础</a></li><li><a href="/pages/f805ed/" class="sidebar-link">List与Queue类</a></li><li><a href="/pages/d24b60/" class="sidebar-link">Map与Set类</a></li><li><a href="/pages/54e5d3/" class="sidebar-link">并发容器类</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/67d70f/" class="sidebar-link">多线程基础</a></li><li><a href="/pages/ffc8f7/" class="sidebar-link">Java内置锁</a></li><li><a href="/pages/c43494/" class="sidebar-link">AQS</a></li><li><a href="/pages/eb5b61/" class="sidebar-link">显式锁ReentrantLock</a></li><li><a href="/pages/eb8cbc/" class="sidebar-link">线程协作与JUC组件</a></li><li><a href="/pages/23c79a/" class="sidebar-link">Atomic原子变量与Unsafe类与CAS</a></li><li><a href="/pages/9d6ed4/" class="sidebar-link">线程池与定时任务</a></li><li><a href="/pages/5b787a/" class="sidebar-link">ThreadLocal</a></li><li><a href="/pages/db53d1/" class="sidebar-link">Java并发编程实战(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>IO</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b4d461/" class="sidebar-link">文件操作</a></li><li><a href="/pages/1b9d6c/" class="sidebar-link">IO流操作</a></li><li><a href="/pages/076a47/" class="sidebar-link">Java网络IO模型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>高级特性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d76905/" class="sidebar-link">Lambda表达式</a></li><li><a href="/pages/f7f0e6/" class="sidebar-link">流Stream</a></li><li><a href="/pages/7cc40a/" class="sidebar-link">反射</a></li><li><a href="/pages/945326/" class="sidebar-link">代理</a></li><li><a href="/pages/7fd9b4/" class="sidebar-link">Javaagent</a></li><li><a href="/pages/a3cee0/" class="sidebar-link">Guava</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>JVM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d308f6/" class="sidebar-link">走进JVM🌼</a></li><li><a href="/pages/be0269/" class="sidebar-link">JVM内存区域与对象解析🌼</a></li><li><a href="/pages/48d1be/" class="sidebar-link">垃圾收集器与内存分配策略🌼</a></li><li><a href="/pages/3a4c8a/" class="sidebar-link">JVM性能监控与故障处理工具🌼</a></li><li><a href="/pages/106680/" class="sidebar-link">调优案例分析与实战🌼</a></li><li><a href="/pages/16a914/" class="sidebar-link">类文件结构🌼</a></li><li><a href="/pages/ea287c/" class="sidebar-link">虚拟机类加载机制🌼</a></li><li><a href="/pages/6367b0/" class="sidebar-link">虚拟机字节码执行引擎🌼</a></li><li><a href="/pages/c6c210/" class="sidebar-link">类加载及执行子系统的案例与实战🌼</a></li><li><a href="/pages/deb8b7/" class="sidebar-link">前端编译与优化🌼</a></li><li><a href="/pages/1f8f72/" aria-current="page" class="active sidebar-link">后端编译与优化🌼</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/3d72db/" class="sidebar-link">Java内存模型与线程实现🌼</a></li><li><a href="/pages/ed086e/" class="sidebar-link">线程安全与内置锁优化🌼</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/56b9dd/" class="sidebar-link">Java性能问题定位分析</a></li><li><a href="/pages/939bf8/" class="sidebar-link">杂记</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>开发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>软件设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/a5f6fe/" class="sidebar-link">设计基础理论</a></li><li><a href="/pages/3b245c/" class="sidebar-link">设计模式之美(极客时间)🌟</a></li><li><a href="/pages/661fa4/" class="sidebar-link">领域驱动设计(DDD)</a></li><li><a href="/pages/856368/" class="sidebar-link">DDD实战课(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d3fbd2/" class="sidebar-link">数据库基础</a></li><li><a href="/pages/691fc3/" class="sidebar-link">数据库系统原理</a></li><li><a href="/pages/50f6b7/" class="sidebar-link">MySQL基础必知必会</a></li><li><a href="/pages/fe297e/" class="sidebar-link">MySQL特性</a></li><li><a href="/pages/07bdb6/" class="sidebar-link">MySQL索引🌟</a></li><li><a href="/pages/984715/" class="sidebar-link">MySQL锁🌟</a></li><li><a href="/pages/53b588/" class="sidebar-link">MySQL事务🌟</a></li><li><a href="/pages/becc59/" class="sidebar-link">MySQL高级特性</a></li><li><a href="/pages/056463/" class="sidebar-link">MySQL基础架构与存储引擎🌟</a></li><li><a href="/pages/63b46e/" class="sidebar-link">MySQL架构优化与运维</a></li><li><a href="/pages/9995e5/" class="sidebar-link">MySQL优化</a></li><li><a href="/pages/c1c2f6/" class="sidebar-link">MySQL架构</a></li><li><a href="/pages/8e8e0a/" class="sidebar-link">MySQL设计规范</a></li><li><a href="/pages/0219aa/" class="sidebar-link">MySQL运维</a></li><li><a href="/pages/e288c0/" class="sidebar-link">MySQL中间件</a></li><li><a href="/pages/c6cafa/" class="sidebar-link">MySQL实战45讲(极客时间)🌟</a></li><li><a href="/pages/4a6106/" class="sidebar-link">数据库LeetCode题目</a></li><li><a href="/pages/2827f1/" class="sidebar-link">数据库综合问题</a></li><li><a href="/pages/c616d5/" class="sidebar-link">MongoDB</a></li><li><a href="/pages/075e71/" class="sidebar-link">ClickHouse</a></li><li><a href="/pages/d74f6d/" class="sidebar-link">Doris</a></li><li><a href="/pages/b6bad9/" class="sidebar-link">HBase</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Spring</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bd8eb8/" class="sidebar-link">Spring Boot基础</a></li><li><a href="/pages/d0d797/" class="sidebar-link">Spring Boot应用整合</a></li><li><a href="/pages/314cdc/" class="sidebar-link">Spring MVC基础</a></li><li><a href="/pages/80de47/" class="sidebar-link">Spring AOP基础</a></li><li><a href="/pages/f0d4d6/" class="sidebar-link">Spring事务基础</a></li><li><a href="/pages/db6afe/" class="sidebar-link">Spring IOC源码分析-概览</a></li><li><a href="/pages/672e98/" class="sidebar-link">Spring IOC源码分析-getBean()</a></li><li><a href="/pages/695b90/" class="sidebar-link">Spring IOC源码分析-createBean()</a></li><li><a href="/pages/f89bcf/" class="sidebar-link">Spring AOP源码分析</a></li><li><a href="/pages/3b52f4/" class="sidebar-link">Spring事务源码分析</a></li><li><a href="/pages/186902/" class="sidebar-link">Spring Boot源码分析</a></li><li><a href="/pages/16bd1c/" class="sidebar-link">Spring MVC源码分析</a></li><li><a href="/pages/3d0c1f/" class="sidebar-link">Spring Cloud</a></li><li><a href="/pages/d56156/" class="sidebar-link">Spring编程常见错误50例(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>MyBatis</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bb032d/" class="sidebar-link">基础</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>工具与环境</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c9cb6e/" class="sidebar-link">Arthas</a></li><li><a href="/pages/3172bb/" class="sidebar-link">Maven</a></li><li><a href="/pages/37f79a/" class="sidebar-link">Git</a></li><li><a href="/pages/db9f99/" class="sidebar-link">环境搭建与部署</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c725f5/" class="sidebar-link">测试基础</a></li><li><a href="/pages/7893a4/" class="sidebar-link">单元测试</a></li><li><a href="/pages/af9f25/" class="sidebar-link">压力测试</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>代码质量</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ec2b81/" class="sidebar-link">代码整洁之道</a></li><li><a href="/pages/474cdf/" class="sidebar-link">阿里巴巴编程规范</a></li><li><a href="/pages/c47e15/" class="sidebar-link">代码之丑(极客时间)🌸</a></li><li><a href="/pages/4d4606/" class="sidebar-link">Java业务开发常见错误100例(极客时间)🌸</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/develop/#开发" data-v-06970110>开发</a></li><li data-v-06970110><a href="/develop/#Java" data-v-06970110>Java</a></li><li data-v-06970110><a href="/develop/#JVM" data-v-06970110>JVM</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">后端编译与优化🌼<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_41-后端编译与优化🌼"><a href="#_41-后端编译与优化🌼" class="header-anchor">#</a> 41.后端编译与优化🌼</h1> <p>本节对应《深入理解 Java 虚拟机》的第十一章</p> <p>从计算机程序出现的第一天起, 对效率的追逐就是程序员天生的坚定信仰, 这个过程犹如一场没有终点, 永不停歇的  F1 方程式竞赛, 程序员是车手, 技术平台则是在赛道上飞驰的赛车.</p> <h4 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h4> <p>如果把字节码看作是程序语言的一种<strong>中间表示形式</strong>(Intermediate Representation, IR)的话, 那编译器无论在何时, 在何种状态下<mark><strong>把 Class 文件转换成与本地基础设施(硬件指令集, 操作系统)相关的二进制机器码, 它都可以视为整个编译过程的后端</strong></mark>. 如果读者阅读过本书的第 2 版, 可能会发现本章的标题已经从 &quot;运行期编译与优化&quot; 悄然改成了 &quot;后端编译与优化&quot;, 这是因为在 2012 年的 Java 世界里, 虽然提前编译(Ahead Of Time, AOT)早已有所应用, 但相对而言, <strong>即时编译</strong>(Just In Time, JIT)才是占绝对主流的编译形式. 不过, 最近几年编译技术发展出现了一些微妙的变化, 提前编译不仅逐渐被主流 JDK 所支持, 而且在 Java 编译技术的前沿研究中又重新成了一个热门的话题, 所以再继续只提 &quot;<strong>运行期</strong>&quot; 和 &quot;<strong>即时编译</strong>&quot; 就显得不够全面了, 在本章中它们两者都是主角.</p> <p>无论是提前编译器抑或即时编译器, 都不是 Java 虚拟机必需的组成部分, 《Java 虚拟机规范》中从来没有规定过虚拟机内部必须要包含这些编译器, 更没有限定或指导这些编译器应该如何去实现. 但是, <strong>后端编译器编译性能的好坏, 代码优化质量的高低却是衡量一款商用虚拟机优秀与否的关键指标之一</strong>, 它们也是商业 Java 虚拟机中的核心, 是最能体现技术水平与价值的功能. 本章将走进 Java 虚拟机的内部, <strong>探索后端编译器的运作过程和原理</strong>.</p> <p>既然《Java 虚拟机规范》没有具体的约束规则去限制后端编译器应该如何实现, 那这部分功能就完全是与虚拟机具体实现相关的内容, 如无特殊说明, 本章中所提及的即时编译器都是特指 <mark><strong>HotSpot 虚拟机内置的即时编译器</strong></mark>, 虚拟机也是特指 HotSpot 虚拟机. 不过, 本章虽然有大量的内容涉及了特定的虚拟机和编译器的实现层面, 但主流 Java 虚拟机中后端编译器的行为会有很多相似相通之处, 因此对其他虚拟机来说也具备一定的类比参考价值.</p> <h4 id="代码执行模式"><a href="#代码执行模式" class="header-anchor">#</a> 代码执行模式</h4> <p>虚拟机执行代码的几种模式:</p> <ul><li><strong>解释模式</strong>(Interpreted Mode): <strong>只使用解释器</strong>(-Xint 强制 JVM 使用<strong>解释模式</strong>), 执行一行 JVM <strong>字节码</strong>就编译一行为机器码.</li> <li><strong>编译模式</strong>(Compiled Mode): <strong>只使用编译器</strong>(-Xcomp JVM 使用编译模式), 先将所有 JVM 字节码<strong>一次编译</strong>为机器码, 然后一次性执行所有机器码.</li> <li><strong>混合模式</strong>(Mixed Mode): 依然使用<strong>解释模式</strong>执行代码, 但是对于一些 &quot;<strong>热点</strong>&quot; 代码采用<strong>编译模式</strong>执行. JVM 一般采用<strong>混合模式</strong>执行代码.</li></ul> <p><strong>解释模式启动快</strong>, 对于只需要执行部分代码, 并且大多数代码<strong>只会执行一次</strong>的情况比较适合; <strong>编译模式启动慢</strong>, 但是后期<strong>执行速度快</strong>, 而且比较占用内存, 因为机器码的数量至少是 JVM 字节码的十倍以上, 这种模式适合代码可能会被反复执行的场景; <strong>混合模式是 JVM 默认采用的执行代码方式, 一开始还是解释执行, 但是对于少部分 &quot;热点&quot; 代码会采用编译模式执行, 这些热点代码对应的机器码会被缓存起来, 下次再执行无需再编译, 这就是常见的 JIT</strong>(Just In Time Compiler)<strong>即时编译技术</strong>. 在<strong>即时编译过程</strong>中 JVM 可能会对的代码最一些<strong>优化</strong>, 比如<strong>对象逃逸分析</strong>等.</p> <p>Java 程序在运行的时候, 主要就是执行字节码指令, 一般这些指令会按照顺序解释执行, 这种就是解释执行. 但是那些被频繁调用的代码, 比如调用次数很高或者在 for 循环里的那些代码,如果按照解释执行, 效率是非常低的. 这些代码称为热点代码. 为了提高热点代码的执行效率, 在运行时, 虚拟机将会把这些代码编译成与本地平台相关的机器码, 并进行各种层次的优化. 完成这个任务的编译器, 就称为即时编译器(Just In Time Compiler), 简称 JIT 编译器.</p> <h4 id="即时编译器"><a href="#即时编译器" class="header-anchor">#</a> 即时编译器</h4> <blockquote><p>即时编译器定义</p></blockquote> <p>目前主流的两款商用 Java 虚拟机(HotSpot, OpenJ9)里, Java 程序<mark><strong>最初都是通过解释器(Interpreter)进行解释执行的, 当虚拟机发现某个方法或代码块的运行特别频繁, 就会把这些代码认定为 &quot;热点代码&quot;(Hot Spot Code), 为了提高热点代码的执行效率, 在运行时, 虚拟机将会把这些代码编译成本地机器码, 并以各种手段尽可能地进行代码优化, 运行时完成这个任务的后端编译器被称为即时编译器(JIT, Just In Time)</strong></mark> .</p> <p>本节将会了解 HotSpot 虚拟机内的<strong>即时编译器</strong>的运作过程, 此外还将解决以下几个问题:</p> <ul><li><strong>为何 HotSpot 虚拟机要使用</strong>​<mark><strong>解释器与即时编译器并存</strong></mark>​<strong>的架构?</strong></li> <li><strong>为何 HotSpot 虚拟机要实现两个(或三个)不同的即时编译器?</strong></li> <li><strong>程序何时使用解释器执行? 何时使用编译器执行?</strong></li> <li><strong>哪些程序代码会被编译为本地代码? 如何编译本地代码?</strong></li> <li><strong>如何从外部观察到即时编译器的编译过程和编译结果?</strong></li></ul> <h5 id="_2-即时编译器实现"><a href="#_2-即时编译器实现" class="header-anchor">#</a> 2.即时编译器实现</h5> <p>在 JDK1.8 的 HotSpot 虚拟机中, 内置了两个 JIT, 分别为 C1 编译器和 C2 编译器.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96-%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8.png" alt="https://www.processon.com/diagraming/642d0c4a6dd8285b4b706e70"></p> <blockquote><p>C1编译器</p></blockquote> <p>C1 编译器是一个简单快速的编译器, 主要的关注点在于局部性的优化, 适用于执行时间较短或对启动性能有要求的程序, 例如, GUI 应用对界面启动速度就有一定要求, C1 也被称为 <strong>Client Compiler</strong>.</p> <p>C1 编译器几乎不会对代码进行优化.</p> <blockquote><p>C2编译器</p></blockquote> <p>C2 编译器是为<strong>长期运行的服务器端应用程序做性能调优的编译器</strong>, 适用于执行时间较长或对峰值性能有要求的程序. 根据各自的适配性, 这种即时编译也被称为 <strong>Server Compiler</strong>.</p> <blockquote><p>Graal编译器</p></blockquote> <p>C2 编译器代码已超级复杂, 无人能维护! 所以才会开发 Graal 编译器用以取代 C2(从 JDK 10开始). 参考: 实战:深入理解Graal编译器.</p> <h5 id="_2-解释器与编译器"><a href="#_2-解释器与编译器" class="header-anchor">#</a> 2.解释器与编译器</h5> <p>尽管并不是所有的 Java 虚拟机都采用解释器与编译器并存的运行架构, 但目前主流的商用 Java 虚拟机, 譬如 HotSpot, OpenJ9 等, 内部都<mark><strong>同时包含解释器与编译器</strong></mark>, 解释器与编译器两者各有优势: <mark><strong>当程序需要迅速启动和执行的时候, 解释器可以首先发挥作用, 省去编译的时间, 立即运行. 当程序启动后, 随着时间的推移, 编译器逐渐发挥作用, 把越来越多的代码编译成本地代码, 这样可以减少解释器的中间损耗, 获得更高的执行效率. 当程序运行环境中内存资源限制较大, 可以使用解释执行节约内存, 反之可以使用编译执行来提升效率</strong></mark>. 同时, 解释器还可以作为编译器激进优化时后备的 &quot;逃生门&quot;(如果情况允许, HotSpot 虚拟机中也会采用不进行激进优化的客户端编译器充当 &quot;逃生门&quot; 的角色), 让编译器根据概率选择一些不能保证所有情况都正确, 但大多数时候都能提升运行速度的优化手段, 当激进优化的假设不成立, 如加载了新类以后, 类型继承结构出现变化, 出现 &quot;罕见陷阱&quot;(Uncommon Trap)时可以通过逆优化(Deoptimization)<strong>退回到解释状态继续执行</strong>, 因此在整个 Java 虚拟机执行架构里, <strong>解释器与编译器经常是相辅相成地配合工作</strong>, 其交互关系如图 11-1 所示.</p> <p><img src="/img/image-20240720103441-8itz7vj.png" alt="image" title="图11-1 释器与编译器的交互"></p> <p>**HotSpot 虚拟机中内置了两个(或三个)**​<mark><strong>即时编译器</strong></mark>​ **, 其中有两个编译器存在已久, 分别被称为 &quot;**​<mark><strong>客户端编译器</strong></mark>​ **&quot;(Client Compiler)和 &quot;**​<mark><strong>服务端编译器</strong></mark>​ <strong>&quot;(Server Compiler), 或者简称为</strong> <mark><strong>C1 编译器和 C2 编译器</strong></mark>​ <strong>, 第三个是在 JDK 10 时才出现的, 长期目标是代替 C2 的</strong> <mark><strong>Graal 编译器</strong></mark>​ <strong>. Graal 编译器目前还处于实验状态, 本章将安排出专门的小节对它讲解与实战, 在本节里将重点关注传统的 C1, C2 编译器的工作过程</strong>.</p> <p>在分层编译(Tiered Compilation)的工作模式出现以前, HotSpot 虚拟机通常是<strong>采用解释器与其中一个编译器直接搭配的方式工作</strong>, 程序使用哪个编译器, 只取决于虚拟机运行的模式, HotSpot 虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式, 用户也可以使用 &quot;<code>-client</code>​&quot; 或 &quot;<code>-server</code>​&quot; 参数去强制指定虚拟机运行在客户端模式还是服务端模式.</p> <p>无论采用的编译器是客户端编译器还是服务端编译器, <strong>解释器与编译器搭配使用的方式在虚拟机中被称为 &quot;混合模式&quot;(Mixed Mode)</strong> , 用户也可以使用参数 &quot;<code>-Xint</code>​&quot; 强制虚拟机运行于 &quot;解释模式&quot;(Interpreted Mode), 这时候编译器完全不介入工作, 全部代码都使用解释方式执行. 另外, 也可以使用参数 &quot;<code>-Xcomp</code>​&quot; 强制虚拟机运行于 &quot;编译模式&quot;(Compiled Mode), 这时候将<strong>优先采用编译方式</strong>执行程序, 但是解释器仍然要在编译无法进行的情况下介入执行过程. 可以通过虚拟机的 &quot;<code>-version</code>​&quot; 命令的输出结果显示出这三种模式, 内容如代码清单 11-1 所示, 请读者注意黑体字部分.</p> <blockquote><p>代码清单11-1 虚拟机执行模式</p></blockquote> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token variable">$java</span> <span class="token parameter variable">-version</span>
<span class="token function">java</span> version <span class="token string">&quot;11.0.3&quot;</span> <span class="token number">2019</span>-04-16 LTS
Java<span class="token punctuation">(</span>TM<span class="token punctuation">)</span> SE Runtime Environment <span class="token number">18.9</span> <span class="token punctuation">(</span>build <span class="token number">11.0</span>.3+12-LTS<span class="token punctuation">)</span>
Java HotSpot<span class="token punctuation">(</span>TM<span class="token punctuation">)</span> <span class="token number">64</span>-Bit Server VM <span class="token number">18.9</span> <span class="token punctuation">(</span>build <span class="token number">11.0</span>.3+12-LTS, mixed mode<span class="token punctuation">)</span>

<span class="token variable">$java</span> <span class="token parameter variable">-Xint</span> <span class="token parameter variable">-version</span>
<span class="token function">java</span> version <span class="token string">&quot;11.0.3&quot;</span> <span class="token number">2019</span>-04-16 LTS
Java<span class="token punctuation">(</span>TM<span class="token punctuation">)</span> SE Runtime Environment <span class="token number">18.9</span> <span class="token punctuation">(</span>build <span class="token number">11.0</span>.3+12-LTS<span class="token punctuation">)</span>
Java HotSpot<span class="token punctuation">(</span>TM<span class="token punctuation">)</span> <span class="token number">64</span>-Bit Server VM <span class="token number">18.9</span> <span class="token punctuation">(</span>build <span class="token number">11.0</span>.3+12-LTS, interpreted mode<span class="token punctuation">)</span>

<span class="token variable">$java</span> <span class="token parameter variable">-Xcomp</span> <span class="token parameter variable">-version</span>
<span class="token function">java</span> version <span class="token string">&quot;11.0.3&quot;</span> <span class="token number">2019</span>-04-16 LTS
Java<span class="token punctuation">(</span>TM<span class="token punctuation">)</span> SE Runtime Environment <span class="token number">18.9</span> <span class="token punctuation">(</span>build <span class="token number">11.0</span>.3+12-LTS<span class="token punctuation">)</span>
Java HotSpot<span class="token punctuation">(</span>TM<span class="token punctuation">)</span> <span class="token number">64</span>-Bit Server VM <span class="token number">18.9</span> <span class="token punctuation">(</span>build <span class="token number">11.0</span>.3+12-LTS, compiled mode<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>由于即时编译器编译本地代码需要占用程序运行时间, 通常要编译出优化程度越高的代码, 所花费的时间便会越长</strong>; 而且想要编译出优化程度更高的代码, 解释器可能还要替编译器收集性能监控信息, 这对解释执行阶段的速度也有所影响. 为了在<strong>程序启动响应速度与运行效率之间达到最佳平衡</strong>, HotSpot 虚拟机在编译子系统中加入了<strong>分层编译</strong>的功能, 分层编译的概念其实很早就已经提出, 但直到 JDK 6 时期才被初步实现, 后来一直处于改进阶段, 最终在 JDK 7 的服务端模式虚拟机中作为默认编译策略被开启. <mark><strong>分层编译根据编译器编译, 优化的规模与耗时, 划分出不同的编译层次</strong></mark>, 其中包括:</p> <ul><li>第 0 层. <strong>程序纯解释执行</strong>, 并且解释器不开启性能监控功能(Profiling).</li> <li>第 1 层. <strong>使用客户端编译器将字节码编译为本地代码来运行</strong>, 进行简单可靠的稳定优化, 不开启性能监控功能.</li> <li>第 2 层. 仍然使用客户端编译器执行, 仅开启方法及回边次数统计等有限的性能监控功能.</li> <li>第 3 层. 仍然使用客户端编译器执行, 开启全部性能监控, 除了第 2 层的统计信息外, 还会收集如分支跳转, 虚方法调用版本等全部的统计信息.</li> <li>第 4 层. <strong>使用服务端编译器将字节码编译为本地代码, 相比起客户端编译器, 服务端编译器会启用更多编译耗时更长的优化, 还会根据性能监控信息进行一些不可靠的激进优化</strong>.</li></ul> <p>以上层次并不是固定不变的, 根据不同的运行参数和版本, 虚拟机可以调整分层的数量. 各层次编译之间的交互, 转换关系如图 11-2 所示.</p> <p><img src="/img/Image00197-20240302133505-wp87tce.jpg" alt="" title="图11-2　分层编译的交互关系"></p> <p><strong>实施分层编译后, 解释器, 客户端编译器和服务端编译器就会同时工作, 热点代码都可能会被多次编译, 用客户端编译器获取更高的编译速度, 用服务端编译器来获取更好的编译质量, 在解释执行的时候也无须额外承担收集性能监控信息的任务, 而在服务端编译器采用高复杂度的优化算法时, 客户端编译器可先采用简单优化来为它争取更多的编译时间</strong>.</p> <h5 id="_3-编译对象与触发条件"><a href="#_3-编译对象与触发条件" class="header-anchor">#</a> 3.编译对象与触发条件</h5> <h6 id="_1-热点代码"><a href="#_1-热点代码" class="header-anchor">#</a> (1)热点代码</h6> <p>在本章概述中提到了在运行过程中会被即时编译器编译的目标是 &quot;<strong>热点代码</strong>&quot;, 这里所指的热点代码主要有两类, 包括:</p> <ul><li><strong>被多次调用的方法</strong>.</li> <li><strong>被多次执行的循环体</strong>.</li></ul> <p>前者很好理解, 一个方法被调用得多了, 方法体内代码执行的次数自然就多, 它成为 &quot;热点代码&quot; 是理所当然的. 而后者则是为了解决当一个方法只被调用过一次或少量的几次, 但是方法体内部存在循环次数较多的循环体, 这样循环体的代码也被重复执行多次, 因此这些代码也应该认为是 &quot;热点代码&quot;.</p> <p><strong>对于这两种情况, 编译的目标对象都是整个方法体</strong>, 而不会是单独的循环体. 第一种情况, 由于是依靠方法调用触发的编译, 那编译器理所当然地会以整个方法作为编译对象, 这种编译也是虚拟机中标准的即时编译方式. 而对于后一种情况, 尽管编译动作是由循环体所触发的, 热点只是方法的一部分, 但编译器依然必须以<strong>整个方法作为编译对象</strong>, 只是执行入口(从方法第几条字节码指令开始执行)会稍有不同, 编译时会传入执行入口点字节码序号(Byte Code Index, BCI). 这种编译方式因为编译发生在方法执行的过程中, 因此被很形象地称为 &quot;<strong>栈上替换</strong>&quot;(On Stack Replacement, OSR), 即方法的栈帧还在栈上, 方法就被替换了.</p> <p>读者可能还会有疑问, 在上面的描述里, 无论是 &quot;多次执行的方法&quot;, 还是 &quot;多次执行的代码块&quot;, 所谓 &quot;多次&quot; 只定性不定量, 并不是一个具体严谨的用语, <strong>那到底多少次才算 &quot;多次&quot; 呢</strong>? 还有一个问题, 就是 Java 虚拟机是如何统计某个方法或某段代码被执行过多少次的呢? 解决了这两个问题, 也就解答了<strong>即时编译被触发的条件</strong>.</p> <h6 id="_2-热点探测"><a href="#_2-热点探测" class="header-anchor">#</a> (2)热点探测</h6> <blockquote><p>热点探测-如何进行热点代码判断? 啥时候触发?</p></blockquote> <p><strong>要知道某段代码是不是热点代码, 是不是需要触发即时编译</strong>, 这个行为称为 &quot;<mark><strong>热点探测</strong></mark>&quot;(Hot Spot Code Detection), 其实<strong>进行热点探测并不一定要知道方法具体被调用了多少次</strong>, 目前主流的热点探测判定方式有两种, 分别是:</p> <ul><li><strong>基于采样的热点探测</strong>. 采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶, 如果发现某个(或某些)方法<strong>经常出现在栈顶</strong>, 那这个方法就是 &quot;热点方法&quot;. 基于采样的热点探测的好处是实现简单高效, 还可以很容易地获取方法调用关系(将调用堆栈展开即可), 缺点是很难精确地确认一个方法的热度, 容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测.</li> <li><strong>基于计数器的热点探测</strong>. 采用这种方法的虚拟机会<strong>为每个方法(甚至是代码块)建立计数器</strong>, 统计方法的执行次数, 如果执行次数超过一定的阈值就认为它是 &quot;热点方法&quot;. 这种统计方法实现起来要麻烦一些, 需要为每个方法建立并维护计数器, 而且不能直接获取到方法的调用关系. 但是它的统计结果相对来说更加精确严谨.</li></ul> <p>这两种探测手段在商用 Java 虚拟机中都有使用到, 譬如 J9 用过第一种采样热点探测, 而<strong>在 HotSpot 虚拟机中使用的是第二种基于计数器的热点探测方法</strong>, 为了实现热点计数, HotSpot 为每个方法准备了两类计数器: <mark><strong>方法调用计数器</strong></mark>(Invocation Counter)和<mark><strong>回边计数器</strong></mark>(Back Edge Counter, &quot;回边&quot; 的意思就是指在循环边界往回跳转). 当虚拟机运行参数确定的前提下, <strong>这两个计数器都有一个明确的阈值, 计数器阈值一旦溢出, 就会触发即时编译</strong>.</p> <h6 id="_3-方法调用计数器"><a href="#_3-方法调用计数器" class="header-anchor">#</a> (3)方法调用计数器</h6> <p>首先来看看<mark><strong>方法调用计数器</strong></mark>. 顾名思义, <strong>这个计数器就是用于统计方法被调用的次数</strong>, 它的默认阈值在客户端模式下是 1500 次, 在<strong>服务端模式下是 10000 次</strong>, 这个阈值可以通过虚拟机参数 <code>-XX: CompileThreshold</code>​ 来人为设定. <strong>当一个方法被调用时, 虚拟机会先检查该方法是否存在被即时编译过的版本, 如果存在, 则优先使用编译后的本地代码来执行</strong>. 如果不存在已被编译过的版本, 则将该方法的调用计数器值加一, 然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值. <strong>一旦已超过阈值的话, 将会向即时编译器提交一个该方法的代码编译请求</strong>.</p> <p>如果没有做过任何设置, 执行引擎默认不会同步等待编译请求完成, 而是继续进入解释器按照解释方式执行字节码, 直到提交的请求被即时编译器编译完成. <strong>当编译工作完成后, 这个方法的调用入口地址就会被系统自动改写成新值, 下一次调用该方法时就会使用已编译的版本了</strong>, 整个即时编译的交互过程如图 11-3 所示.</p> <p>在默认设置下, 方法调用计数器统计的并不是方法被调用的绝对次数, 而是一个相对的<strong>执行频率</strong>, 即一段时间之内方法被调用的次数. 当超过一定的时间限度, 如果方法的调用次数仍然不足以让它提交给即时编译器编译, 那该方法的调用计数器就会被<strong>减少一半</strong>, 这个过程被称为<strong>方法调用计数器热度的衰减</strong>(Counter Decay), 而这段时间就称为此方法统计的<strong>半衰周期</strong>(Counter Half Life Time), 进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的, 可以使用虚拟机参数 <code>-XX: -UseCounterDecay</code>​ 来关闭热度衰减, <strong>让方法计数器统计方法调用的绝对次数, 这样只要系统运行时间足够长, 程序中绝大部分方法都会被编译成本地代码</strong>. 另外还可以使用 <code>-XX: CounterHalfLifeTime</code>​ 参数设置半衰周期的时间, 单位是秒.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522155456984.png" alt="" title="图11-3 方法调用计数器触发即时编译"></p> <p>‍</p> <h6 id="_4-回边计数器"><a href="#_4-回边计数器" class="header-anchor">#</a> (4)回边计数器</h6> <p>再来看看另外一个计数器——<mark><strong>回边计数器</strong></mark>, 它的作用是<mark><strong>统计一个方法中循环体代码执行的次数</strong></mark>, 在字节码中<strong>遇到控制流向后跳转的指令就称为 &quot;回边(Back Edge)&quot;</strong> , 很显然建立回边计数器统计的目的是为了触发栈上的替换编译.</p> <p>关于回边计数器的阈值, 虽然 HotSpot 虚拟机也提供了一个类似于方法调用计数器阈值 <code>-XX: CompileThreshold</code>​ 的参数 <code>-XX: BackEdgeThreshold</code>​ 供用户设置, 但是当前的 HotSpot 虚拟机实际上并未使用此参数, 而必须设置另外一个参数 <code>-XX: OnStackReplacePercentage</code>​ 来间接调整回边计数器的阈值, 其计算公式有如下两种.</p> <ul><li>虚拟机运行在客户端模式下, 回边计数器阈值计算公式为: 方法调用计数器阈值(<code>-XX: CompileThreshold</code>​)乘以 OSR 比率(<code>-XX: OnStackReplacePercentage</code>​)除以 100. 其中 <code>-XX: OnStackReplacePercentage</code>​ 默认值为 933, 如果都取默认值, 那客户端模式虚拟机的回边计数器的阈值为13995.</li> <li>虚拟机运行在服务端模式下, 回边计数器阈值的计算公式为: 方法调用计数器阈值(<code>-XX: CompileThreshold</code>​)乘以(OSR 比率(<code>-XX: OnStackReplacePercentage</code>​)减去解释器监控比率(<code>-XX: InterpreterProfilePercentage</code>​)的差值)除以 100. 其中 <code>-XX: OnStack ReplacePercentage</code>​ 默认值为 140, <code>-XX: InterpreterProfilePercentage</code>​ 默认值为 33, 如果都取默认值, 那服务端模式虚拟机回边计数器的阈值为 10700.</li></ul> <p><strong>当解释器遇到一条回边指令时, 会先查找将要执行的代码片段是否有已经编译好的版本, 如果有的话, 它将会优先执行已编译的代码, 否则就把回边计数器的值加一, 然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值</strong>. 当超过阈值的时候, 将会提交一个栈上替换编译请求, 并且把回边计数器的值稍微降低一些, 以便继续在解释器中执行循环, 等待编译器输出编译结果, 整个执行过程如图 11-4 所示.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522155952582.png" alt="" title="图11-4 回边计数器触发即时编译"></p> <p>与方法计数器不同, <strong>回边计数器没有计数热度衰减的过程, 因此这个计数器统计的就是该方法循环执行的绝对次数</strong>. 当计数器溢出的时候, 它还会把方法计数器的值也调整到溢出状态, 这样下次再进入该方法的时候就会执行标准编译过程.</p> <p>最后还要提醒一点, 图 11-2 和图 11-3 都仅仅是<strong>描述了客户端模式虚拟机的即时编译方式, 对于服务端模式虚拟机来说, 执行情况会比上面描述还要复杂一些</strong>. 从理论上了解过编译对象和编译触发条件后, 还可以从 HotSpot 虚拟机的源码中简单观察一下这两个计数器, 在 MehtodOop.hpp(一个 methodOop 对象代表了一个 Java 方法)中, 定义了 Java 方法在虚拟机中的内存布局, 如下所示:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// |------------------------------------------------------|</span>
<span class="token comment">// | header                                               |</span>
<span class="token comment">// | klass                                                |</span>
<span class="token comment">// |------------------------------------------------------|</span>
<span class="token comment">// | constMethodOop                 (oop)                 |</span>
<span class="token comment">// | constants                      (oop)                 |</span>
<span class="token comment">// |------------------------------------------------------|</span>
<span class="token comment">// | methodData                     (oop)                 |</span>
<span class="token comment">// | interp_invocation_count                              |</span>
<span class="token comment">// |------------------------------------------------------|</span>
<span class="token comment">// | access_flags                                         |</span>
<span class="token comment">// | vtable_index                                         |</span>
<span class="token comment">// |------------------------------------------------------|</span>
<span class="token comment">// | result_index (C++ interpreter only)                  |</span>
<span class="token comment">// |------------------------------------------------------|</span>
<span class="token comment">// | method_size             | max_stack                  |</span>
<span class="token comment">// | max_locals              | size_of_parameters         |</span>
<span class="token comment">// |------------------------------------------------------|</span>
<span class="token comment">// |intrinsic_id|   flags    |  throwout_count            |</span>
<span class="token comment">// |------------------------------------------------------|</span>
<span class="token comment">// | num_breakpoints         |  (unused)                  |</span>
<span class="token comment">// |------------------------------------------------------|</span>
<span class="token comment">// | invocation_counter                                   |</span>
<span class="token comment">// | backedge_counter                                     |</span>
<span class="token comment">// |------------------------------------------------------|</span>
<span class="token comment">// |           prev_time (tiered only, 64 bit wide)       |</span>
<span class="token comment">// |                                                      |</span>
<span class="token comment">// |------------------------------------------------------|</span>
<span class="token comment">// |                  rate (tiered)                       |</span>
<span class="token comment">// |------------------------------------------------------|</span>
<span class="token comment">// | code                           (pointer)             |</span>
<span class="token comment">// | i2i                            (pointer)             |</span>
<span class="token comment">// | adapter                        (pointer)             |</span>
<span class="token comment">// | from_compiled_entry            (pointer)             |</span>
<span class="token comment">// | from_interpreted_entry         (pointer)             |</span>
<span class="token comment">// |------------------------------------------------------|</span>
<span class="token comment">// | native_function       (present only if native)       |</span>
<span class="token comment">// | signature_handler     (present only if native)       |</span>
<span class="token comment">// |------------------------------------------------------|</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><p>在这段注释所描述的<strong>方法内存布局</strong>里, 每一行表示占用 32 个比特, 从中可以清楚看到<strong>方法调用计数器和回边计数器所在的位置和数据宽度</strong>, 另外还有 from_compiled_entry 和 from_interpreted_entry 两个方法入口所处的位置.</p> <h5 id="_4-编译过程"><a href="#_4-编译过程" class="header-anchor">#</a> 4.编译过程</h5> <p>在默认条件下, 无论是方法调用产生的标准编译请求, 还是栈上替换编译请求, 虚拟机在编译器还未完成编译之前, 都仍然将<strong>按照解释方式继续执行代码, 而编译动作则在后台的编译线程中进行</strong>. 用户可以通过参数 <code>-XX: -BackgroundCompilation</code>​ 来禁止后台编译, 后台编译被禁止后, 当达到触发即时编译的条件时, 执行线程向虚拟机提交编译请求以后将会一直阻塞等待, 直到编译过程完成再开始执行编译器输出的本地代码.</p> <p>那在后台执行编译的过程中, 编译器具体会做什么事情呢? 服务端编译器和客户端编译器的编译过程是有所差别的. 对于客户端编译器来说, 它是一个相对简单快速的三段式编译器, 主要的关注点在于局部性的优化, 而放弃了许多耗时较长的全局优化手段.</p> <p>在第一个阶段, <strong>一个平台独立的前端将字节码构造成一种高级中间代码表示</strong>(High-Level Intermediate Representation, HIR, 即与目标机器指令集无关的中间表示). HIR 使用静态单分配(Static Single Assignment, SSA)的形式来代表代码值, 这可以使得一些在 HIR 的构造过程之中和之后进行的优化动作更容易实现. 在此之前编译器已经会在字节码上完成一部分基础优化, 如方法内联, 常量传播等优化将会在字节码被构造成 HIR 之前完成.</p> <p>在第二个阶段, <strong>一个平台相关的后端从 HIR 中产生低级中间代码表示</strong>(Low-Level Intermediate Representation, LIR, 即与目标机器指令集相关的中间表示), 而在此之前会在 HIR 上完成另外一些优化, 如空值检查消除, 范围检查消除等, 以便让 HIR 达到更高效的代码表示形式.</p> <p>最后的阶段是<strong>在平台相关的后端使用线性扫描算法</strong>在 LIR 上分配寄存器, 并在 LIR 上做窥孔(Peephole)优化, <strong>然后产生机器代码</strong>. 客户端编译器大致的执行过程如图 11-5 所示.</p> <p><img src="/img/Image00200-20240302133505-sg70m74.jpg" alt="" title="图11-5 Client Compiler 架构"></p> <p>而<strong>服务端编译器则是专门面向服务端的典型应用场景, 并为服务端的性能配置针对性调整过的编译器, 也是一个能容忍很高优化复杂度的高级编译器</strong>, 几乎能达到 GNU C++ 编译器使用 <code>-O2</code>​ 参数时的优化强度. 它会执行大部分经典的优化动作, 如: <mark><strong>无用代码消除(Dead Code Elimination), 循环展开(Loop Unrolling), 循环表达式外提(Loop Expression Hoisting), 消除公共子表达式(Common Subexpression Elimination), 常量传播(Constant Propagation), 基本块重排序(Basic Block Reordering)</strong></mark> 等, 还会实施一些与 Java 语言特性密切相关的优化技术, 如范围检查消除(Range Check Elimination), 空值检查消除(Null Check Elimination, 不过并非所有的空值检查消除都是依赖编译器优化的, 有一些是代码运行过程中自动优化了)等. 另外, 还可能根据解释器或客户端编译器提供的性能监控信息, 进行一些不稳定的预测性激进优化, 如守护内联(Guarded Inlining), 分支频率预测(Branch Frequency Prediction)等, 本章的下半部分将会挑选上述的一部分优化手段进行分析讲解, 在此就先不做展开.</p> <p><strong>服务端编译采用的寄存器分配器是一个全局图着色分配器, 它可以充分利用某些处理器架构(如 RISC)上的大寄存器集合</strong>. 以即时编译的标准来看, 服务端编译器无疑是比较缓慢的, 但它的编译速度依然远远超过传统的静态优化编译器, 而且它相对于客户端编译器编译输出的代码质量有很大提高, 可以大幅减少本地代码的执行时间, 从而抵消掉额外的编译时间开销, 所以也有很多非服务端的应用选择使用服务端模式的 HotSpot 虚拟机来运行.</p> <p>在本节中出现了许多编译原理和代码优化中的概念名词, 没有这方面基础的读者, 可能阅读起来会感觉到很抽象, 很理论化. 有这种感觉并不奇怪, 一方面, 即时编译过程本来就是一个虚拟机中最能体现技术水平也是最复杂的部分, 很难在几页纸的篇幅中介绍得面面俱到; 另一方面, 这个过程对 Java 开发者来说是完全透明的, 程序员平时无法感知它的存在.</p> <h4 id="提前编译器"><a href="#提前编译器" class="header-anchor">#</a> 提前编译器</h4> <p>提前编译在 Java 技术体系中并不是新事物. 1996 年 JDK 1.0 发布, Java 有了正式的运行环境, 第一个可以使用外挂即时编译器的 Java 版本是 JDK 1.0.2, 而 Java 提前编译器的诞生并没有比这晚多少. 仅几个月后, IBM 公司就推出了第一款用于 Java 语言的提前编译器(IBM High Performance Compiler for Java). 在1998年, GNU 组织公布了著名的 GCC 家族(GNU Compiler Collection)的新成员 GNU Compiler for Java(GCJ, 2018 年从 GCC 家族中除名), 这也是一款 Java 的提前编译器, 而且曾经被广泛应用. 在 OpenJDK 流行起来之前, 各种 Linux 发行版带的 Java 实现通常就是 GCJ.</p> <p>但是提前编译很快又在 Java 世界里沉寂了下来, 因为当时 Java 的一个核心优势是平台中立性, 其宣传口号是 &quot;一次编译, 到处运行&quot;, 这与平台相关的提前编译在理念上就是直接冲突的. GCJ 出现之后在长达 15 年的时间里, 提前编译这条故事线上基本就再没有什么大的新闻和进展了. 类似的状况一直持续至 2013 年, 直到在 Android 的世界里, 剑走偏锋使用提前编译的 ART(Android Runtime)横空出世. ART 一诞生马上就把使用即时编译的 Dalvik 虚拟机按在地上使劲蹂躏, 仅经过 Android 4.4 一个版本的短暂交锋之后, ART 就迅速终结了 Dalvik 的性命, 把它从 Android 系统里扫地出门.</p> <p>尽管 Android 并不能直接等同于 Java, 但两者毕竟有着深厚渊源, 提前编译在 Android 上的革命与崛起也震撼到了 Java 世界. 在某些领域, 某些人眼里, 只要能获得更好的执行性能, 什么平台中立性, 字节膨胀, 一切皆可舍弃, 唯一的问题就只有 &quot;<strong>提前编译真的会是获得更高性能的银弹吗</strong>?&quot;</p> <h5 id="_1-提前编译的优劣得失"><a href="#_1-提前编译的优劣得失" class="header-anchor">#</a> 1.提前编译的优劣得失</h5> <p>本节希望同时向读者展示出一枚硬币的两面, 解释清楚<strong>提前编译相对于即时编译有什么优势, 又有什么不足</strong>, 还有即时编译器有没有办法得到这些优势, 需要付出哪些努力等.</p> <p>现在提前编译产品和对其的研究有着两条明显的分支, 一条分支是做与传统 C, C++ 编译器类似的, 在程序运行之前<strong>把程序代码编译成机器码的静态翻译工作</strong>; 另外一条分支是<strong>把原本即时编译器在运行时要做的编译工作提前做好并保存下来, 下次运行到这些代码(譬如公共库代码在被同一台机器其他 Java 进程使用)时直接把它加载进来使用</strong>.</p> <p>先来说第一条, 这是传统的提前编译应用形式, 它在 Java 中存在的价值直指即时编译的最大弱点: <strong>即时编译要占用程序运行时间和运算资源</strong>. 即使现在先进的即时编译器已经足够快, 以至于能够容忍相当高的优化复杂度了; 即使现在先进的即时编译器架构有了分层编译的支持, 可以先用快速但低质量的即时编译器为高质量的即时编译器争取出更多编译时间, 但无论如何, 即时编译消耗的时间都是原本可用于程序运行的时间, 消耗的运算资源都是原本可用于程序运行的资源, 这个约束从未减弱, 更不会消失, 始终是悬在即时编译头顶的达摩克利斯之剑.</p> <p>这里举个更具体的例子来帮助理解这种约束: 在编译过程中最耗时的优化措施之一是通过 &quot;<strong>过程间分析</strong>&quot;(Inter-Procedural Analysis, IPA, 也经常被称为全程序分析, 即 Whole Program Analysis)来获得诸如某个程序点上某个变量的值是否一定为常量, 某段代码块是否永远不可能被使用, 在某个点调用的某个虚方法是否只能有单一版本等的分析结论. 这些信息对生成高质量的优化代码有着极为巨大的价值, 但是要精确(譬如对流敏感, 对路径敏感, 对上下文敏感, 对字段敏感)得到这些信息, 必须在全程序范围内做大量极耗时的计算工作, 目前所有常见的 Java 虚拟机对过程间分析的支持都相当有限, 要么借助大规模的方法内联来打通方法间的隔阂, 以过程内分析(Intra-Procedural Analysis, 只考虑过程内部语句, 不考虑过程调用的分析)来模拟过程间分析的部分效果; 要么借助可假设的激进优化, 不求得到精确的结果, 只求按照最可能的状况来优化, 有问题再退回来解析执行. 但如果是在程序运行之前进行的静态编译, 这些耗时的优化就可以放心大胆地进行了, 譬如 Graal VM 中的 Substrate VM, 在创建本地镜像的时候, 就会采取许多原本在 HotSpot 即时编译中并不会做的全程序优化措施以获得更好的运行时性能, 反正做镜像阶段慢一点并没有什么大影响. 同理, 这也是 ART 打败 Dalvik 的主要武器之一, 连副作用也是相似的. 在 Android 5.0 和 6.0 版本, 安装一个稍微大一点的 Android 应用都是按分钟来计时的, 以至于从 Android 7.0 版本起重新启用了解释执行和即时编译(但这已与 Dalvik 无关, 它彻底凉透了), 等空闲时系统再在后台自动进行提前编译.</p> <p><strong>关于提前编译的第二条路径, 本质是给即时编译器做缓存加速, 去改善 Java 程序的启动时间, 以及需要一段时间预热后才能到达最高性能的问题</strong>. 这种提前编译被称为动态提前编译(Dynamic AOT)或者索性就大大方方地直接叫即时编译缓存(JIT Caching). 在目前的 Java 技术体系里, 这条路径的提前编译已经完全被主流的商用 JDK 支持. 在商业应用中, 这条路径最早出现在 JDK 6 版本的 IBM J9 虚拟机上, 那时候在它的 CDS(Class Data Sharing)功能的缓存中就有一块是即时编译缓存. 不过这个缓存和 CDS 缓存一样是虚拟机运行时自动生成的, 直接来源于 J9 的即时编译器, 而且为了进程兼容性, 很多激进优化都不能肆意运用, 所以编译输出的代码质量反而要低于即时编译器. 真正引起业界普遍关注的是 OpenJDK/OracleJDK 9 中所带的 Jaotc 提前编译器, 这是一个基于 Graal 编译器实现的新工具, 目的是让用户可以针对目标机器, 为应用程序进行提前编译. HotSpot 运行时可以直接加载这些编译的结果, 实现加快程序启动速度, 减少程序达到全速运行状态所需时间的目的. 这里面确实有比较大的优化价值, 试想一下, 各种 Java 应用最起码会用到 Java 的标准类库, 如 java.base 等模块, 如果能够将这个类库提前编译好, 并进行比较高质量的优化, 显然能够节约不少应用运行时的编译成本. 关于这点, 将在下一节做一个简单的实战练习, 而在此要说明的是, 这的确是很好的想法, 但实际应用起来并不是那么容易, 原因是这种提前编译方式不仅要和目标机器相关, 甚至还必须与 HotSpot 虚拟机的运行时参数绑定. 譬如虚拟机运行时采用了不同的垃圾收集器, 这原本就需要即时编译子系统的配合(典型的如生成内存屏障代码)才能正确工作, 要做提前编译的话, 自然也要把这些配合的工作平移过去. 至于前面提到过的提前编译破坏平台中立性, 字节膨胀等缺点当然还存在, 这里就不重复了. 尽管还有许多困难, 但提前编译无疑已经成为一种极限榨取性能(启动, 响应速度)的手段, 且被官方 JDK 关注, 相信日后会更加灵活, 更加容易使用, 就如已经相当成熟的 CDS(AppCDS 需要用户参与)功能那样, 几乎不需要用户介入, 可自动完成.</p> <p>最后还要思考一个问题: <strong>提前编译的代码输出质量, 一定会比即时编译更高吗</strong>? 提前编译因为没有执行时间和资源限制的压力, 能够毫无顾忌地使用<strong>重负载</strong>的优化手段, 这当然是一个极大的优势, 但即时编译难道就没有能与其竞争的强项了吗? 当然是有的, 尽管即时编译在时间和运算资源方面的劣势是无法忽视的, 但其依然有自己的优势. 接下来便要开始即时编译器的绝地反击了, 笔者将简要<strong>介绍三种即时编译器相对于提前编译器的天然优势</strong>.</p> <blockquote><p>即时编译器相对于提前编译器的天然优势</p></blockquote> <p>首先, 是<strong>性能分析制导优化</strong>. 上一节介绍 HotSpot 的即时编译器时就多次提及在解释器或者客户端编译器运行过程中, 会不断收集性能监控信息, 譬如某个程序点抽象类通常会是什么实际类型, 条件判断通常会走哪条分支, 方法调用通常会选择哪个版本, 循环通常会进行多少次等, 这些数据一般在<strong>静态分析时是无法得到</strong>的, 或者不可能存在确定且唯一的解, 最多只能依照一些启发性的条件去进行猜测. 但在动态运行时却能看出它们具有非常明显的偏好性. 如果一个条件分支的某一条路径执行特别频繁, 而其他路径鲜有问津, 那就可以把热的代码集中放到一起, 集中优化和分配更好的资源(分支预测, 寄存器, 缓存等)给它.</p> <p>其次, 是<strong>激进预测性优化</strong>, 这也已经成为很多即时编译优化措施的基础. 静态优化无论如何都必须保证优化后所有的程序外部可见影响(不仅仅是执行结果)与优化前是等效的, 不然优化之后会导致程序报错或者结果不对, 若出现这种情况, 则速度再快也是没有价值的. 然而, 相对于提前编译来说, 即时编译的策略就可以不必这样保守, 如果性能监控信息能够支持它做出一些正确的可能性很大但无法保证绝对正确的预测判断, 就已经可以大胆地按照高概率的假设进行优化, 万一真的走到罕见分支上, 大不了退回到低级编译器甚至解释器上去执行, 并不会出现无法挽救的后果. 只要出错概率足够低, 这样的优化往往能够大幅度降低目标程序的复杂度, 输出运行速度非常高的代码. 譬如在 Java 语言中, 默认方法都是虚方法调用, 部分 C, C++ 程序员(甚至一些老旧教材)会说虚方法是不能内联的, 但如果 Java 虚拟机真的遇到虚方法就去查虚表而不做内联的话, Java 技术可能就已经因性能问题而被淘汰很多年了. 实际上虚拟机会通过类继承关系分析等一系列激进的猜测去做去虚拟化(Devitalization), 以保证绝大部分有内联价值的虚方法都可以顺利内联. 内联是最基础的一项优化措施, 本章稍后还会对专门的 Java 虚拟机具体如何做虚方法内联进行详细讲解.</p> <p>最后, 是<strong>链接时优化</strong>, Java 语言天生就是动态链接的, 一个个 Class 文件在运行期被加载到虚拟机内存当中, 然后在即时编译器里产生优化后的本地代码, 这类事情在 Java 程序员眼里看起来毫无违和之处. 但如果类似的场景出现在使用提前编译的语言和程序上, 譬如 C, C++的程序要调用某个动态链接库的某个方法, 就会出现很明显的边界隔阂, 还难以优化. 这是因为主程序与动态链接库的代码在它们编译时是完全独立的, 两者各自编译, 优化自己的代码. 这些代码的作者, 编译的时间, 以及编译器甚至很可能都是不同的, 当出现跨链接库边界的调用时, 那些理论上应该要做的优化--譬如做对调用方法的内联, 就会执行起来相当的困难. 如果刚才说的虚方法内联让 C, C++ 程序员理解还算比较能够接受的话(其实 C++ 编译器也可以通过一些技巧来做到虚方法内联), 那这种跨越动态链接库的方法内联在他们眼里可能就近乎于离经叛道了(但实际上依然是可行的).</p> <p>经过以上的讨论, 读者应该能够理解提前编译器的价值与优势所在了, 但忽略具体的应用场景就说它是万能的银弹, 那肯定是有失偏颇的, 提前编译有它的应用场景, 也有它的弱项与不足, 相信未来很长一段时间内, <strong>即时编译和提前编译都会是 Java 后端编译技术的共同主角</strong>.</p> <h5 id="_2-实战-jaotc的提前编译"><a href="#_2-实战-jaotc的提前编译" class="header-anchor">#</a> 2.实战:Jaotc的提前编译</h5> <p>JDK 9 引入了用于<strong>支持对 Class 文件和模块进行提前编译的工具 Jaotc, 以减少程序的启动时间和到达全速性能的预热时间</strong>, 但由于这项功能必须针对特定物理机器和目标虚拟机的运行参数来使用, 加之限制太多, Java 开发人员对此了解, 使用普遍比较少, 本节<strong>将用 Jaotc 来编译 Java SE 的基础库</strong>(java.base 模块), 以改善本机 Java 环境的执行效率.</p> <p>首先通过一段测试代码(什么代码都可以, 最简单的 HelloWorld 都可以, 内容就不贴了)来演示 Jaotc 的基本使用过程, 操作如下:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ javac HelloWorld.java
$ <span class="token function">java</span> HelloWorld
Hello World<span class="token operator">!</span>
$ jaotc <span class="token parameter variable">--output</span> libHelloWorld.so HelloWorld.class
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>通过以上命令, 就生成了一个<strong>名为 libHelloWorld.so 的库</strong>, 可以使用 Linux 的 ldd 命令来确认这是否是一个静态链接库, 使用 mn 命令来确认其中是否包含了 HelloWorld 的构造函数和 main() 方法的入口信息, 操作如下:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>$ ldd libHelloWorld.so
statically linked

$ nm libHelloWorld.so
……
0000000000002a20 t HelloWorld.()V
0000000000002b20 t HelloWorld.main([Ljava/lang/String;)V
……
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>现在就可以<strong>使用这个静态链接库而不是 Class 文件来输出 HelloWorld 了</strong>:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>java -XX:AOTLibrary=./libHelloWorld.so HelloWorld
Hello World!
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>提前编译一个 HelloWorld 只具备演示价值, 下一步来做更有实用意义的事情: <strong>把 java.base 模块编译成类似的静态链接库</strong>. java.base 包含的代码数量庞大, 虽然其中绝大部分内容现在都能被 Jaotc 的提前编译所支持了, 但总还有那么几个 &quot;刺头&quot; 会导致编译异常. 因此要建立一个编译命令文件来<strong>排除</strong>这些目前还不支持提前编译的方法, 下面将此文件取名为 java.base-list.txt, 其具体内容如下:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># jaotc: java.lang.StackOverflowError</span>
exclude sun.util.resources.LocaleNames.getContents<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Ljava/lang/Object<span class="token punctuation">;</span>
exclude sun.util.resources.TimeZoneNames.getContents<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Ljava/lang/Object<span class="token punctuation">;</span>
exclude sun.util.resources.cldr.LocaleNames.getContents<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Ljava/lang/Object<span class="token punctuation">;</span>
exclude sun.util.resources<span class="token punctuation">..</span>*.LocaleNames_.*.getContents<span class="token punctuation">\</span><span class="token punctuation">(</span><span class="token punctuation">\</span><span class="token punctuation">)</span><span class="token punctuation">\</span><span class="token punctuation">[</span><span class="token punctuation">\</span><span class="token punctuation">[</span>Ljava/lang/Object<span class="token punctuation">;</span>
exclude sun.util.resources<span class="token punctuation">..</span>*.LocaleNames_.*_.*.getContents<span class="token punctuation">\</span><span class="token punctuation">(</span><span class="token punctuation">\</span><span class="token punctuation">)</span><span class="token punctuation">\</span><span class="token punctuation">[</span><span class="token punctuation">\</span><span class="token punctuation">[</span>Ljava/lang/Object<span class="token punctuation">;</span>
exclude sun.util.resources<span class="token punctuation">..</span>*.TimeZoneNames_.*.getContents<span class="token punctuation">\</span><span class="token punctuation">(</span><span class="token punctuation">\</span><span class="token punctuation">)</span><span class="token punctuation">\</span><span class="token punctuation">[</span><span class="token punctuation">\</span><span class="token punctuation">[</span>Ljava/lang/Object<span class="token punctuation">;</span>
exclude sun.util.resources<span class="token punctuation">..</span>*.TimeZoneNames_.*_.*.getContents<span class="token punctuation">\</span><span class="token punctuation">(</span><span class="token punctuation">\</span><span class="token punctuation">)</span><span class="token punctuation">\</span><span class="token punctuation">[</span><span class="token punctuation">\</span><span class="token punctuation">[</span>Ljava/lang/Object<span class="token punctuation">;</span>
<span class="token comment"># java.lang.Error: Trampoline must not be defined by the bootstrap classloader</span>
exclude sun.reflect.misc.Trampoline.<span class="token operator">&lt;</span>clinit<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>V
exclude sun.reflect.misc.Trampoline.invoke<span class="token punctuation">(</span>Ljava/lang/reflect/Method<span class="token punctuation">;</span>Ljava/lang/Object<span class="token punctuation">;</span><span class="token punctuation">[</span>Ljava/lang/Object<span class="token punctuation">;</span><span class="token punctuation">)</span>Ljava/lang/Object<span class="token punctuation">;</span>
<span class="token comment"># JVM asserts</span>
exclude com.sun.crypto.provider.AESWrapCipher.engineUnwrap<span class="token punctuation">(</span><span class="token punctuation">[</span>BLjava/lang/String<span class="token punctuation">;</span>I<span class="token punctuation">)</span>Ljava/security/Key<span class="token punctuation">;</span>
exclude sun.security.ssl.*
exclude sun.net.RegisteredDomain.<span class="token operator">&lt;</span>clinit<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>V
<span class="token comment"># Huge methods</span>
exclude jdk.internal.module.SystemModules.descriptors<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>Ljava/lang/module/ModuleDescriptor<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>然后就可以开始进行提前编译了, 使用的命令如下所示:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>jaotc <span class="token operator">-</span><span class="token class-name">J</span><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UseCompressedOops</span> <span class="token operator">-</span><span class="token class-name">J</span><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UseG1GC</span> <span class="token operator">-</span><span class="token class-name">J</span><span class="token operator">-</span><span class="token class-name">Xmx4g</span>
<span class="token operator">--</span>compile<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">-</span>tiered <span class="token operator">--</span>info <span class="token operator">--</span>compile<span class="token operator">-</span>commands java<span class="token punctuation">.</span>base<span class="token operator">-</span>list<span class="token punctuation">.</span>txt
<span class="token operator">--</span>output libjava<span class="token punctuation">.</span>base<span class="token operator">-</span>coop<span class="token punctuation">.</span>so <span class="token operator">--</span><span class="token keyword">module</span> <span class="token namespace">java<span class="token punctuation">.</span>base</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面 Jaotc 用了 -J 参数传递与目标虚拟机相关的运行时参数, 这些运行时信息与编译的结果是直接相关的, 编译后的静态链接库只能支持运行在相同参数的虚拟机之上, 如果需要支持多种虚拟机运行参数(譬如采用不同垃圾收集器, 是否开启压缩指针等)的话, 可以花点时间为每一种可能用到的参数组合编译出对应的静态链接库. 此外, 由于 Jaotc 是基于 Graal 编译器开发的, 所以现在 ZGC 和 Shenandoah 收集器还不支持 Graal 编译器, 自然它们在 Jaotc 上也是无法使用的. 事实上, <strong>目前 Jaotc 只支持 G1 和 Parallel(PS+PS Old)两种垃圾收集器</strong>. 使用 Jaotc 编译 java.base 模块的输出结果如下所示:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ jaotc -J-XX:+UseCompressedOops -J-XX:+UseG1GC -J-Xmx4g --compile-for-tiered <span class="token parameter variable">--info</span> --compile-commands java.base-list.txt <span class="token parameter variable">--output</span> libjava.base-coop.so <span class="token parameter variable">--module</span> java.base
Compiling libjava.base-coop.so<span class="token punctuation">..</span>.
<span class="token number">6177</span> classes found <span class="token punctuation">(</span><span class="token number">335</span> ms<span class="token punctuation">)</span>
<span class="token number">55845</span> methods total, <span class="token number">49575</span> methods to compile <span class="token punctuation">(</span><span class="token number">1037</span> ms<span class="token punctuation">)</span>
Compiling with <span class="token number">4</span> threads
<span class="token punctuation">..</span><span class="token punctuation">..</span>
<span class="token number">49575</span> methods compiled, <span class="token number">0</span> methods failed <span class="token punctuation">(</span><span class="token number">138821</span> ms<span class="token punctuation">)</span>
Parsing compiled code <span class="token punctuation">(</span><span class="token number">906</span> ms<span class="token punctuation">)</span>
Processing metadata <span class="token punctuation">(</span><span class="token number">10867</span> ms<span class="token punctuation">)</span>
Preparing stubs binary <span class="token punctuation">(</span><span class="token number">0</span> ms<span class="token punctuation">)</span>
Preparing compiled binary <span class="token punctuation">(</span><span class="token number">103</span> ms<span class="token punctuation">)</span>
Creating binary: libjava.base-coop.o <span class="token punctuation">(</span><span class="token number">2719</span> ms<span class="token punctuation">)</span>
Creating shared library: libjava.base-coop.so <span class="token punctuation">(</span><span class="token number">5812</span> ms<span class="token punctuation">)</span>
Total time: <span class="token number">163609</span> ms
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>在测试的 i7-8750H, 32GB 内存的笔记本上, 编译 JDK 11 的 java.base 大约花了三分钟的时间, 生成的 libjava.base-coop.o 库大小为 366MB. JDK 9 刚刚发布时, 笔者做过相同的编译, 当时耗时高达十分钟. 编译完成后, 就可以使用提前编译版本的 java.base 模块来运行 Java 程序了, 方法与前面运行 HelloWorld 是一样的, 用 <code>-XX: AOTLibrary</code>​ 来指定链接库位置即可, 譬如:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>java -XX:AOTLibrary=java_base/libjava.base-coop.so,./libHelloWorld.so HelloWorld
Hello World!
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>还可以使用 <code>-XX: +PrintAOT</code>​ 参数来确认哪些方法使用了提前编译的版本, 从输出信息中可以看到, 如果不使用提前编译版本的 java.base 模块, 就只有 HelloWord 的构造函数和 main() 方法是提前编译版本的:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">java</span> <span class="token parameter variable">-XX:+PrintAOT</span> <span class="token parameter variable">-XX:AOTLibrary</span><span class="token operator">=</span>./libHelloWorld.so HelloWorld
     <span class="token number">11</span>    <span class="token number">1</span>     loaded    ./libHelloWorld.so  aot library
    <span class="token number">105</span>    <span class="token number">1</span>     aot<span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">]</span>   HelloWorld.<span class="token punctuation">(</span><span class="token punctuation">)</span>V
    <span class="token number">105</span>    <span class="token number">2</span>     aot<span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">]</span>   HelloWorld.main<span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava/lang/String<span class="token punctuation">;</span><span class="token punctuation">)</span>V
Hello World<span class="token operator">!</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>但如果加入 libjava.base-coop.so, 那使用到的几乎所有的标准 Java SE API 都是被提前编译好的, 输出如下:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token function">java</span> <span class="token parameter variable">-XX:AOTLibrary</span><span class="token operator">=</span>java_base/libjava.base-coop.so,./libHelloWorld.so HelloWorld
Hello World<span class="token operator">!</span>
    <span class="token number">13</span>    <span class="token number">1</span>     loaded    java_base/libjava.base-coop.so  aot library
    <span class="token number">13</span>    <span class="token number">2</span>     loaded    ./libHelloWorld.so  aot library
<span class="token punctuation">[</span>Found  <span class="token punctuation">[</span>Z  <span class="token keyword">in</span>  java_base/libjava.base-coop.so<span class="token punctuation">]</span>
<span class="token punctuation">..</span>. // 省略其他输出
<span class="token punctuation">[</span>Found  <span class="token punctuation">[</span>J  <span class="token keyword">in</span>  java_base/libjava.base-coop.so<span class="token punctuation">]</span>
    <span class="token number">31</span>    <span class="token number">1</span>     aot<span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">]</span>   java.lang.Object.<span class="token punctuation">(</span><span class="token punctuation">)</span>V
    <span class="token number">31</span>    <span class="token number">2</span>     aot<span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">]</span>   java.lang.Object.finalize<span class="token punctuation">(</span><span class="token punctuation">)</span>V
<span class="token punctuation">..</span>. // 省略其他输出
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>目前状态的 Jaotc 还有许多需要完善的地方, 仍<strong>难以直接编译 SpringBoot, MyBatis 这些常见的第三方工具库</strong>, 甚至在众多 Java 标准模块中, 能比较顺利编译的也只有 java.base 模块而已. 不过随着 Graal 编译器的逐渐成熟, 相信 Jaotc 前途还是可期的.</p> <p>此外, 本书虽然选择 Jaotc 来进行实战, 但同样有发展潜力的 Substrate VM 也不应被忽视. Jaotc 做的提前编译属于本节开头所说的 &quot;第二条分支&quot;, 即做即时编译的缓存; 而 Substrate VM 则是选择的 &quot;第一条分支&quot;, 做的是传统的静态提前编译.</p> <h4 id="编译器优化技术"><a href="#编译器优化技术" class="header-anchor">#</a> 编译器优化技术</h4> <p>经过前面对即时编译, 提前编译的讲解, 读者应该已经建立起一个认知: <strong>编译器的目标虽然是做由程序代码翻译为本地机器码的工作, 但其实难点并不在于能不能成功翻译出机器码,</strong> <mark><strong>输出代码优化质量的高低才是决定编译器优秀与否的关键</strong></mark>. 在本章之前的内容里出现过许多优化措施的专业名词, 有一些是编译原理中的基础知识, 譬如方法内联, 只要是计算机专业毕业的读者至少都有初步的概念; 但也有一些专业性比较强的名词, 譬如逃逸分析, 可能不少读者只听名字很难想象出来这个优化会做什么事情. 本节将介绍几种 HotSpot 虚拟机的<strong>即时编译器在生成代码时采用的代码优化技术</strong>, 以小见大, 见微知著, 让读者对编译器代码优化有整体理解.</p> <h5 id="_1-优化技术概览"><a href="#_1-优化技术概览" class="header-anchor">#</a> 1.优化技术概览</h5> <p>OpenJDK 的官方 Wiki 上, HotSpot 虚拟机设计团队列出了一个相对比较全面的, <strong>即时编译器中采用的优化技术</strong>列表, 如表 11-1 所示, 其中有不少经典编译器的优化手段, 也有许多针对 Java 语言, 或者说针对运行在 Java 虚拟机上的所有语言进行的优化. 本节先对这些技术进行概览, 在后面几节中, 将挑选若干最重要或最典型的优化, 与读者一起看看优化前后的代码发生了怎样的变化.</p> <blockquote><p>表11-1 即时编译器优化技术一览</p></blockquote> <p><img src="/img/Image00205-20240302133505-6fkyul3.jpg" alt=""></p> <p><img src="/img/Image00206-20240302133505-ynn2tj9.jpg" alt=""></p> <p>上述的优化技术看起来很多, 而且名字看起来大多显得有点 &quot;高深莫测&quot;, 实际上要实现这些优化确实有不小的难度, 但大部分优化技术理解起来都并不困难, 为了消除读者对这些优化技术的陌生感, 笔者举一个最简单的例子: 通过大家熟悉的 Java 代码变化来展示其中几种优化技术是如何发挥作用的. 不过首先需要明确一点, <strong>即时编译器对这些代码优化变换是建立在代码的中间表示或者是机器码之上的, 绝不是直接在 Java 源码上去做的</strong>, 这里只是为了方便讲解, 使用了 Java 语言的语法来表示这些优化技术所发挥的作用.</p> <p>第一步, 从原始代码开始, 如代码清单 11-6 所示.</p> <blockquote><p>代码清单11-6 优化前的原始代码</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...do stuff...</span>
    z <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>代码清单 11-6 所示的内容已经非常简化了, 但是仍有不少优化的空间. 首先, 第一个要进行的优化是<mark><strong>方法内联</strong></mark>, 它的主要目的有两个: <strong>一是去除方法调用的成本(如查找方法版本, 建立栈帧等); 二是为其他优化建立良好的基础</strong>. 方法内联膨胀之后可以便于在更大范围上进行后续的优化手段, 可以获取更好的优化效果. 因此各种编译器<strong>一般都会把内联优化放在优化序列最靠前的位置</strong>. 内联后的代码如代码清单 11-7 所示.</p> <blockquote><p>代码清单11-7 内联后的代码</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token comment">// ...do stuff...</span>
    z <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token comment">// 这里再访问b是冗余的</span>
    sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>第二步进行<mark><strong>冗余访问消除</strong></mark>(Redundant Loads Elimination), 假设代码中间注释掉的 &quot;...do stuff...&quot; 所代表的操作不会改变 b.value 的值, 那么就可以把 &quot;<code>z = b.value</code>​&quot; 替换为 &quot;<code>z = y</code>​&quot;, 因为上一句 &quot;<code>y = b.value</code>​&quot; 已经保证了变量 y 与 b.value 是一致的, 这样就可以不再去访问对象 b 的局部变量了. 如果把 <code>b.value</code>​ 看作一个表达式, 那么也可以把这项优化看作一种<strong>公共子表达式消除</strong>(Common Subexpression Elimination), 优化后的代码如代码清单 11-8 所示.</p> <blockquote><p>代码清单11-8 冗余存储消除后的代码</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token comment">// ...do stuff...</span>
    z <span class="token operator">=</span> y<span class="token punctuation">;</span>
    sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>第三步进行<mark><strong>复写传播</strong></mark>(Copy Propagation), 因为这段程序的逻辑之中没有必要使用一个额外的变量 z, 它与变量 y 是完全相等的, 因此可以<strong>使用 y 来代替 z</strong>. 复写传播之后的程序如代码清单 11-9 所示.</p> <blockquote><p>代码清单11-9 复写传播的代码</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token comment">// ...do stuff...</span>
    y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    sum <span class="token operator">=</span> y <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>第四步进行<mark><strong>无用代码消除</strong></mark>(Dead Code Elimination), 无用代码可能是<strong>永远不会被执行的代码</strong>, 也可能是完全没有意义的代码. 因此它又被很形象地称为 &quot;Dead Code&quot;, 在代码清单 11-9 中, &quot;<code>y = y</code>​&quot; 是没有意义的, 把它消除后的程序如代码清单 11-10 所示.</p> <blockquote><p>代码清单11-10 进行无用代码消除的代码</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token comment">// ...do stuff...</span>
    sum <span class="token operator">=</span> y <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>经过四次优化之后, 代码清单 11-10 所示代码与代码清单 11-6 所示代码所达到的<strong>效果是一致</strong>的, 但是前者比后者省略了许多语句, 体现在字节码和机器码指令上的差距会更大, 执行效率的差距也会更高. 编译器的这些优化技术实现起来也许确实复杂, 但完全不需要有任何的恐惧心理.</p> <p>接下来挑选了四项有代表性的优化技术, 与大家一起观察它们是如何运作的. 它们分别是:</p> <ul><li>最重要的优化技术之一: <strong>方法内联</strong>.</li> <li>最前沿的优化技术之一: <strong>逃逸分析</strong>.</li> <li>语言无关的经典优化技术之一: <strong>公共子表达式消除</strong>.</li> <li>语言相关的经典优化技术之一: <strong>数组边界检查消除</strong>.</li></ul> <h5 id="_2-方法内联"><a href="#_2-方法内联" class="header-anchor">#</a> 2.方法内联</h5> <p>在前面的讲解中, 多次提到方法内联, 说它是编译器最重要的优化手段, 甚至都可以不加上 &quot;之一&quot;. <strong>内联被业内戏称为优化之母, 因为除了消除方法调用的成本之外, 它更重要的意义是为其他优化手段建立良好的基础</strong>, 代码清单 11-11 所示的简单例子就揭示了内联对其他优化手段的巨大价值: <mark><strong>没有内联, 多数其他优化都无法有效进行</strong></mark>. 例子里 testInline() 方法的内部全部是无用的代码, 但如果不做内联, 后续即使进行了无用代码消除的优化, 也无法发现任何 &quot;Dead Code&quot; 的存在. 如果分开来看, foo() 和 testInline() 两个方法里面的操作都有可能是有意义的.</p> <blockquote><p>代码清单11-11 未作任何优化的字节码</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;do something&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testInline</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><mark><strong>方法内联的优化行为理解起来是没有任何困难的, 不过就是把目标方法的代码原封不动地 &quot;复制&quot; 到发起调用的方法之中, 避免发生真实的方法调用而已. 但实际上 Java 虚拟机中的内联过程却远没有想象中容易, 甚至如果不是即时编译器做了一些特殊的努力, 按照经典编译原理的优化理论, 大多数的 Java 方法都无法进行内联.</strong></mark></p> <p>无法内联的原因其实在第 8 章中讲解 Java 方法解析和分派调用的时候就已经解释过: <strong>只有使用 invokespecial 指令调用的私有方法, 实例构造器, 父类方法和使用 invokestatic 指令调用的静态方法才会在编译期进行解析</strong>. 除了上述四种方法之外(最多再除去被 final 修饰的方法这种特殊情况, 尽管它使用 invokevirtual 指令调用, 但也是非虚方法, 《Java 语言规范》中明确说明了这点), 其他的 Java 方法调用都必须在运行时进行方法接收者的多态选择, 它们都有可能存在多于一个版本的方法接收者, 简而言之, Java 语言中默认的实例方法是<strong>虚方法</strong>.</p> <p><mark><strong>对于一个虚方法, 编译器静态地去做内联的时候很难确定应该使用哪个方法版本</strong></mark>, 以将代码清单 11-7 中所示 b.get() 直接内联为 b.value 为例, <strong>如果不依赖上下文, 是无法确定 b 的实际类型是什么的</strong>. 假如有 ParentB 和 SubB 是两个具有继承关系的父子类型, 并且子类重写了父类的 get() 方法, 那么 b.get() 是执行父类的 get() 方法还是子类的 get() 方法, <strong>这应该是根据实际类型动态分派的, 而实际类型必须在实际运行到这一行代码时才能确定, 编译器很难在编译时得出绝对准确的结论</strong>. 更糟糕的情况是, <strong>由于 Java 提倡使用面向对象的方式进行编程, 而 Java 对象的方法默认就是虚方法, 可以说 Java 间接鼓励了程序员使用大量的虚方法来实现程序逻辑. 根据上面的分析可知,</strong> <mark><strong>内联与虚方法之间会产生 &quot;矛盾&quot;</strong></mark> , 那是不是为了提高执行性能, 就应该默认给每个方法都使用 final 关键字去修饰呢? C 和 C++ 语言的确是这样做的, 默认的方法是非虚方法, 如果需要用到多态, 就用 virtual 关键字来修饰, <strong>但 Java 选择了在虚拟机中解决这个问题</strong>.</p> <p><strong>为了解决虚方法的内联问题, Java 虚拟机首先引入了一种名为类型继承关系分析(Class Hierarchy Analysis,</strong> <mark><strong>CHA</strong></mark>​ <strong>)的技术, 这是整个应用程序范围内的类型分析技术, 用于确定在目前已加载的类中, 某个接口是否有多于一种的实现, 某个类是否存在子类, 某个子类是否覆盖了父类的某个虚方法等信息</strong>. 这样编译器在进行内联时就会分不同情况采取不同的处理: <mark><strong>如果是非虚方法, 那么直接进行内联就可以了, 这种的内联是有百分百安全保障的; 如果遇到虚方法, 则会向 CHA 查询此方法在当前程序状态下是否真的有多个目标版本可供选择, 如果查询到只有一个版本, 那就可以假设 &quot;应用程序的全貌就是现在运行的这个样子&quot; 来进行内联, 这种内联被称为守护内联</strong></mark>. 不过由于 Java 程序是动态连接的, 说不准什么时候就会加载到新的类型从而改变 CHA 结论, 因此这种内联属于激进预测性优化, 必须预留好 &quot;逃生门&quot;, 即当假设条件不成立时的 &quot;退路&quot;(Slow Path). 假如在程序的后续执行过程中, 虚拟机一直没有加载到会令这个方法的接收者的继承关系发生变化的类, 那这个内联优化的代码就可以一直使用下去. 如果加载了导致继承关系发生变化的新类, 那么就必须抛弃已经编译的代码, 退回到解释状态进行执行, 或者重新进行编译.</p> <p>假如向 CHA 查询出来的结果是该方法确实<strong>有多个版本的目标方法可供选择</strong>, 那即时编译器还将进行最后一次努力, 使用内联缓存(Inline Cache)的方式来缩减方法调用的开销. 这种状态下方法调用是真正发生了的, 但是比起直接查虚方法表还是要快一些. 内联缓存是一个建立在目标方法正常入口之前的缓存, 它的工作原理大致为: <strong>在未发生方法调用之前, 内联缓存状态为空, 当第一次调用发生后, 缓存记录下方法接收者的版本信息, 并且每次进行方法调用时都比较接收者的版本</strong>. 如果以后进来的每次调用的方法接收者版本都是一样的, 那么这时它就是一种单态内联缓存(Monomorphic Inline Cache). 通过该缓存来调用, 比用不内联的非虚方法调用, 仅多了一次类型判断的开销而已. 但如果真的出现方法接收者不一致的情况, 就说明程序用到了虚方法的多态特性, 这时候会退化成超多态内联缓存(Megamorphic Inline Cache), 其开销相当于真正查找虚方法表来进行方法分派.</p> <p>所以说, <strong>在多数情况下 Java 虚拟机进行的方法内联都是一种激进优化</strong>. 事实上, 激进优化的应用在高性能的 Java 虚拟机中比比皆是, 极为常见. 除了方法内联之外, 对于出现概率很小(通过经验数据或解释器收集到的性能监控信息确定概率大小)的隐式异常, 使用概率很小的分支等都可以被激进优化 &quot;移除&quot;, 如果真的出现了小概率事件, 这时才会从 &quot;逃生门&quot; 回到解释状态重新执行.</p> <h5 id="_3-逃逸分析"><a href="#_3-逃逸分析" class="header-anchor">#</a> 3.逃逸分析</h5> <p><strong>逃逸分析(Escape Analysis)是目前 Java 虚拟机中比较前沿的优化技术</strong>, 它与类型继承关系分析一样, 并不是直接优化代码的手段, 而是为其他优化措施提供依据的分析技术.</p> <p>逃逸分析的基本原理是: <strong>分析对象动态作用域, 当一个对象在方法里面被定义后, 它可能被外部方法所引用, 例如作为调用参数传递到其他方法中, 这种称为</strong>​<mark><strong>方法逃逸</strong></mark>​ <strong>; 甚至还有可能被外部线程访问到, 譬如赋值给可以在其他线程中访问的实例变量, 这种称为</strong>​<mark><strong>线程逃逸</strong></mark>​ <strong>; 从不逃逸, 方法逃逸到线程逃逸, 称为对象由低到高的不同逃逸程度</strong>.</p> <p><mark><strong>如果能证明一个对象不会逃逸到方法或线程之外(换句话说是别的方法或线程无法通过任何途径访问到这个对象), 或者逃逸程度比较低(只逃逸出方法而不会逃逸出线程), 则可能为这个对象实例采取不同程度的优化</strong></mark>, 如:</p> <ul><li><mark><strong>栈上分配</strong></mark>: 在 Java 虚拟机中, Java 堆上分配创建对象的内存空间几乎是 Java 程序员都知道的常识, Java 堆中的对象对于各个线程都是共享和可见的, 只要持有这个对象的引用, 就可以访问到堆中存储的对象数据. 虚拟机的垃圾收集子系统会回收堆中不再使用的对象, 但回收动作无论是标记筛选出可回收对象, 还是回收和整理内存, 都需要耗费大量资源. <strong>如果确定一个对象不会逃逸出线程之外, 那让这个对象在栈上分配内存将会是一个很不错的主意, 对象所占用的内存空间就可以随栈帧出栈而销毁</strong>. 在一般应用中, 完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的, 如果能使用栈上分配, 那大量的对象就会随着方法的结束而自动销毁了, 垃圾收集子系统的压力将会下降很多. <strong>栈上分配可以支持方法逃逸, 但不能支持线程逃逸</strong>.</li> <li><mark><strong>标量替换</strong></mark>: 若一个数据已经无法再分解成更小的数据来表示了, Java 虚拟机中的原始数据类型(int, long 等数值类型及 reference 类型等)都不能再进一步分解了, 那么这些数据就可以被称为<strong>标量</strong>. 相对的, 如果一个数据可以继续分解, 那它就被称为<strong>聚合量</strong>(Aggregate), Java 中的对象就是典型的聚合量. <strong>如果把一个对象拆散, 根据程序访问的情况, 将其用到的成员变量恢复为原始类型来访问, 这个过程就称为标量替换. 假如逃逸分析能够证明一个对象不会被方法外部访问, 并且这个对象可以被拆散, 那么程序真正执行的时候将可能不去创建这个对象, 而改为直接创建它的若干个被这个方法使用的成员变量来代替</strong>. 将对象拆分后, 除了可以让对象的成员变量在栈上(栈上存储的数据, 很大机会被虚拟机分配至物理机器的高速寄存器中存储)分配和读写之外, 还可以为后续进一步的优化手段创建条件. 标量替换可以视作栈上分配的一种特例, 实现更简单(不用考虑整个对象完整结构的分配), 但对逃逸程度的要求更高, 它不允许对象逃逸出方法范围内.</li> <li><mark><strong>同步消除</strong></mark>: <strong>线程同步本身是一个相对耗时的过程, 如果逃逸分析能够确定一个变量不会逃逸出线程, 无法被其他线程访问, 那么这个变量的读写肯定就不会有竞争, 对这个变量实施的同步措施也就可以安全地消除掉</strong>.</li></ul> <p>直到 JDK 6, HotSpot 才开始支持初步的逃逸分析, 而且这项优化技术尚未足够成熟, 仍有很大的改进余地. 不成熟的原因主要是<strong>逃逸分析的计算成本非常高, 甚至不能保证逃逸分析带来的性能收益会高于它的消耗</strong>. 如果要百分之百准确地判断一个对象是否会逃逸, 需要进行一系列复杂的数据流敏感的过程间分析, 才能确定程序各个分支执行时对此对象的影响. 前面介绍即时编译, 提前编译优劣势时提到了过程间分析这种大压力的分析算法正是即时编译的弱项. 可以试想一下, 如果逃逸分析完毕后发现几乎找不到几个不逃逸的对象, 那这些运行期耗用的时间就白白浪费了, 所以目前虚拟机只能采用不那么准确, 但时间压力相对较小的算法来完成分析.</p> <p>C 和 C++ 语言里面原生就支持了栈上分配(不使用 new 操作符即可), 而 <code>C#</code>​ 也支持值类型, 可以很自然地做到标量替换(但并不会对引用类型做这种优化). 在灵活运用栈内存方面, 确实是 Java 的一个弱项. 在现在仍处于实验阶段的 Valhalla 项目里, 设计了新的 inline 关键字用于定义 Java 的内联类型, 目的是实现与 <code>C#</code>​ 中值类型相对标的功能. 有了这个标识与约束, 以后逃逸分析做起来就会简单很多.</p> <blockquote><p>栈内分配示例</p></blockquote> <p>当一个对象在方法中被定义后, 它可能被<strong>外部方法所引用</strong>, 例如作为调用参数<strong>传递</strong>到其他地方中.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;Lucy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// TODO保存到数据库</span>
    <span class="token keyword">return</span> user<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;Lucy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// TODO保存到数据库</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>test1 方法中的 user 对象<strong>被返回</strong>了, 这个对象的<strong>作用域范围不确定</strong>, 而 Test2 中 User 对象仅在这个方法内有效而不会逃逸, 方法结束也就可以认为是<strong>无效</strong>对象了, 所以这里 JVM <strong>可能</strong>直接把 User 这个<strong>对象分配到栈内存中(方法对应的栈帧)<strong>​<strong><strong>上, 而</strong></strong>​</strong>不是分配到堆</strong>中, 栈帧可以随着方法的调用而被<strong>销毁</strong>, 这个对象也被随之销毁了; 如果分配到堆上, 无用的对象还要等着 GC 去清理, 这样就可以节省一部分堆空间. 当然如果对象比较大, 或者栈空间不够, 即使对象不会逃逸可能也会放到堆中去.</p> <p>所以这里也统一能看出: <strong>新对象可能分配到堆中, 也可能分配到栈中.</strong></p> <blockquote><p>逃逸分析与优化综合示例</p></blockquote> <p>下面将通过一系列 Java 伪代码的变化过程来<strong>模拟逃逸分析是如何工作</strong>的, 向读者展示逃逸分析能够实现的效果. 初始代码如下所示:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 完全未优化的代码</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> xx <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>xx<span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>此处省略了 Point 类的代码, 这就是一个包含 x 和 y 坐标的 POJO 类型, 应该很容易想象它的样子.</p> <p>第一步, 将 Point 的构造函数和 getX() 方法进行<strong>内联优化</strong>:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 步骤1: 构造函数内联后的样子</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> xx <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token function">point_memory_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 在堆中分配 P 对象的示意方法</span>
    p<span class="token punctuation">.</span>x <span class="token operator">=</span> xx<span class="token punctuation">;</span>                         <span class="token comment">// Point 构造函数被内联后的样子</span>
    p<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">42</span>
    <span class="token keyword">return</span> p<span class="token punctuation">.</span>x<span class="token punctuation">;</span>                       <span class="token comment">// Point::getX()被内联后的样子</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>第二步, 经过<strong>逃逸分析</strong>, 发现在整个 test() 方法的范围内 Point 对象实例不会发生任何程度的逃逸, 这样可以对它进行<strong>标量替换优化</strong>, 把其内部的 x 和 y <strong>直接置换</strong>出来, 分解为 test() 方法内的<strong>局部变量</strong>, 从而<strong>避免 Point 对象实例被实际创建</strong>, 优化后的结果如下所示:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 步骤2: 标量替换后的样子</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> xx <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token comment">// 标量替换就后不会创建Point对象了</span>
    <span class="token keyword">int</span> px <span class="token operator">=</span> xx<span class="token punctuation">;</span>
    <span class="token keyword">int</span> py <span class="token operator">=</span> <span class="token number">42</span>
    <span class="token keyword">return</span> px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>第三步, 通过<strong>数据流分析</strong>, 发现 py 的值其实对方法不会造成任何影响, 那就可以放心地<strong>去做无效代码消除</strong>得到最终优化结果, 如下所示:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 步骤3: 做无效代码消除后的样子</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>从测试结果来看, 实施逃逸分析后的程序在 MicroBenchmarks 中往往能得到不错的成绩, 但是在实际的应用程序中, 尤其是大型程序中反而发现实施逃逸分析可能出现效果不稳定的情况, 或分析过程耗时但却无法有效判别出非逃逸对象而导致性能(即时编译的收益)下降, 所以曾经在很长的一段时间里, 即使是服务端编译器, 也默认不开启逃逸分析, 甚至在某些版本(如 JDK 6 Update 18)中还曾经完全禁止了这项优化, 一直到 JDK 7 时这项优化<strong>才成为服务端编译器默认开启的选项</strong>. 如果有需要, 或者确认对程序运行有益, 用户也可以使用参数 <code>-XX: +DoEscapeAnalysis</code>​ 来手动开启逃逸分析, 开启之后可以通过参数 <code>-XX: +PrintEscapeAnalysis</code>​ 来查看分析结果. 有了逃逸分析支持之后, 用户可以使用参数 <code>-XX: +EliminateAllocations</code>​ 来<strong>开启标量替换</strong>, 使用 <code>+XX: +EliminateLocks</code>​ 来<strong>开启同步消除</strong>, 使用参数 <code>-XX: +PrintEliminateAllocations</code>​ <strong>查看标量的替换情况</strong>.</p> <p>尽管目前逃逸分析技术仍在发展之中, 未完全成熟, 但它是即时编译器优化技术的一个重要前进方向, 在日后的 Java 虚拟机中, 逃逸分析技术肯定会支撑起一系列更实用, 有效的优化技术.</p> <h5 id="_4-公共子表达式消除"><a href="#_4-公共子表达式消除" class="header-anchor">#</a> 4.公共子表达式消除</h5> <p>公共子表达式消除是一项非常经典的, 普遍应用于各种编译器的优化技术, 它的含义是: <strong>如果一个表达式 E 之前已经被计算过了, 并且从先前的计算到现在 E 中所有变量的值都没有发生变化, 那么 E 的这次出现就称为公共子表达式</strong>. 对于这种表达式, 没有必要花时间再对它重新进行计算, 只需要直接用前面计算过的表达式结果代替 E. 如果这种优化仅限于<strong>程序基本块</strong>内, 便可称为<strong>局部公共子表达式消除</strong>, 如果这种优化的范围涵盖了多个基本块, 那就称为<strong>全局公共子表达式消除</strong>. 下面举个简单的例子来说明它的优化过程, 假设存在如下代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token punctuation">(</span>c <span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">12</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b <span class="token operator">*</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果这段代码交给 Javac 编译器则不会进行任何优化, 那生成的代码将如代码清单 11-12 所示, 是完全遵照 Java 源码的写法<strong>直译</strong>而成的.</p> <blockquote><p>代码清单11-12 Javac编译的未作任何优化的字节码</p></blockquote> <div class="language-c line-numbers-mode"><pre class="language-c"><code>iload_2       <span class="token comment">// b</span>
imul          <span class="token comment">// 计算 b*c</span>
bipush <span class="token number">12</span>     <span class="token comment">// 推入12</span>
imul          <span class="token comment">// 计算(c * b) * 12</span>
iload_1       <span class="token comment">// a</span>
iadd          <span class="token comment">// 计算(c * b) * 12 + a</span>
iload_1       <span class="token comment">// a</span>
iload_2       <span class="token comment">// b</span>
iload_3       <span class="token comment">// c</span>
imul          <span class="token comment">// 计算 b * c</span>
iadd          <span class="token comment">// 计算 a + b * c</span>
iadd          <span class="token comment">// 计算(c * b) * 12 + a + a + b * c</span>
istore <span class="token number">4</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>当这段代码<strong>进入虚拟机即时编译器后</strong>, 它将进行如下优化: 编译器检测到 <code>c * b</code>​ 与 <code>b * c</code>​ 是一样的表达式, 而且在计算期间 b 与 c 的值是<strong>不变</strong>的.</p> <p>因此这条表达式就可能被视为:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token class-name">E</span> <span class="token operator">*</span> <span class="token number">12</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token class-name">E</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这时候编译器还可能(取决于哪种虚拟机的编译器以及具体的上下文而定)进行另外一种优化--<strong>代数化简</strong>(Algebraic Simplification), 在 E 本来就有乘法运算的前提下, 把表达式变为:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token class-name">E</span> <span class="token operator">*</span> <span class="token number">13</span> <span class="token operator">+</span> a <span class="token operator">+</span> a<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>表达式进行变换之后, 再计算起来就可以节省一些时间了.</p> <h5 id="_5-数组边界检查消除"><a href="#_5-数组边界检查消除" class="header-anchor">#</a> 5.数组边界检查消除</h5> <p><strong>数组边界检查消除</strong>是即时编译器中的一项语言相关的经典优化技术. Java 是一门动态安全的语言, 对数组的读写访问也不像 C, C++ 那样实质上就是裸指针操作. 如果有一个数组 <code>foo[]</code>​, 在 Java 语言中访问数组元素 <code>foo[i]</code>​ 的时候系统将会<strong>自动进行上下界的范围检查</strong>, 即 i 必须满足 &quot;<code>i &gt;= 0 &amp;&amp; i &lt; foo.length</code>​&quot; 的访问条件, 否则将抛出一个运行时异常: java.lang.ArrayIndexOutOfBoundsException. 这对软件开发者来说是一件很友好的事情, 即使程序员没有专门编写防御代码, 也能够避免大多数的溢出攻击. <strong>但是对于虚拟机的执行子系统来说, 每次数组元素的读写都带有一次隐含的条件判定操作, 对于拥有大量数组访问的程序代码, 这必定是一种性能负担</strong>.</p> <p>无论如何, 为了安全, 数组边界检查肯定是要做的, 但数组边界检查是不是必须在运行期间一次不漏地进行则是可以 &quot;商量&quot; 的事情. 例如下面这个简单的情况: 数组下标是一个常量, 如 <code>foo[3]</code>​, 只要在编译期根据数据流分析来确定 foo.length 的值, 并判断下标 &quot;3&quot; 没有越界, 执行的时候就无须判断了. 更加常见的情况是, 数组访问发生在循环之中, 并且使用循环变量来进行数组的访问. 如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间 <code>[0, foo.length)</code>​ 之内, 那么在循环中就可以把整个数组的上下界检查消除掉, 这可以节省很多次的条件判断操作.</p> <p>把这个数组边界检查的例子放在更高的视角来看, 大量的安全检查使编写 Java 程序比编写 C 和 C++ 程序容易了很多, 比如: 数组越界会得到 ArrayIndexOutOfBoundsException 异常; 空指针访问会得到 NullPointException 异常; 除数为零会得到 ArithmeticException 异常... 但这些安全检查也导致出现相同的程序, 从而使 Java 比 C 和 C++ 要做更多的事情(各种检查判断), 这些事情就会导致一些隐式开销, 如果不处理好它们, 就很可能成为一项 &quot;Java 语言天生就比较慢&quot; 的原罪. 为了消除这些<strong>隐式开销</strong>, 除了如数组边界检查优化这种尽可能把运行期检查提前到编译期完成的思路之外, 还有一种避开的处理思路---隐式异常处理, Java 中空指针检查和算术运算中除数为零的检查都采用了这种方案. 举个例子, 程序中访问一个对象(假设对象叫 foo)的某个属性(假设属性叫 value), 那以 Java 伪代码来表示虚拟机访问 foo.value 的过程为:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>foo <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> foo<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在使用隐式异常优化之后, 虚拟机会把上面的伪代码所表示的访问过程变为如下伪代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> foo<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>segment_fault<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">uncommon_trap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>虚拟机会注册一个 Segment Fault 信号的<strong>异常处理器</strong>(伪代码中的 uncommon_trap(), 务必注意这里是指进程层面的异常处理器, 并非真的 Java 的 try-catch 语句的异常处理器), 这样当 foo 不为空的时候, 对 value 的访问是不会有任何额外对 foo 判空的开销的, 而代价就是当 foo 真的为空时, 必须转到异常处理器中恢复中断并抛出 NullPointException 异常. 进入异常处理器的过程涉及进程从<strong>用户态转到内核态</strong>中处理的过程, 结束后会再回到用户态, 速度远比一次判空检查要慢得多. 当 foo 极少为空的时候, 隐式异常优化是值得的, 但假如 foo 经常为空, 这样的优化反而会让程序更慢. 幸好 HotSpot 虚拟机足够聪明, 它会根据运行期收集到的性能监控信息自动选择最合适的方案.</p> <p>与语言相关的其他消除操作还有不少, 如自动装箱消除(Autobox Elimination), 安全点消除(Safepoint Elimination), 消除反射(Dereflection)等, 这里就不再一一介绍了.</p> <h4 id="实战-深入理解graal编译器"><a href="#实战-深入理解graal编译器" class="header-anchor">#</a> 实战:深入理解Graal编译器</h4> <p>从 JDK 10 起, HotSpot 就同时拥有三款不同的即时编译器. 此前已经介绍了经典的客户端编译器和服务端编译器, 本节将把目光聚焦到 HotSpot 即时编译器以及提前编译器共同的最新成果--<strong>Graal 编译器</strong>身上.</p> <h5 id="_1-历史背景"><a href="#_1-历史背景" class="header-anchor">#</a> 1.历史背景</h5> <p>前面说过 Graal 虚拟机以及 Graal 编译器仍在实验室中尚未商用, 但未来其有望代替或成为 HotSpot 下一代技术基础. Oracle Labs 希望它最终能够成为一款高编译效率, 高输出质量, <strong>支持提前编译和即时编译, 同时支持应用于包括 HotSpot 在内的不同虚拟机的编译器</strong>. 由于这个编译器使用 Java 编写, 代码清晰, 又继承了许多来自 HotSpot 的服务端编译器的高质量优化技术, 所以无论是科技企业还是高校研究院, 都愿意在它上面研究和开发新编译技术. HotSpot 服务端编译器的创造者 Cliff Click 自己就对 Graal 编译器十分推崇, 并且公开表示再也不会用 C, C++ 去编写虚拟机和编译器了.</p> <p>Graal 编译器在 JDK 9 时以 Jaotc 提前编译工具的形式首次加入到官方的 JDK 中, 从 JDK 10 起, <mark><strong>Graal 编译器可以替换服务端编译器, 成为 HotSpot 分层编译中最顶层的即时编译器</strong></mark>. 这种可替换的即时编译器架构的实现, 得益于 HotSpot <strong>编译器接口</strong>的出现.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96-%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8.png" alt="https://www.processon.com/diagraming/642d0c4a6dd8285b4b706e70"></p> <p>早期的 Graal 曾经同 C1 及 C2 一样, 与 HotSpot 的协作是紧耦合的, 这意味着每次编译 Graal 均需重新编译整个 HotSpot. JDK 9 时发布的 JEP 243: <strong>Java 虚拟机编译器接口</strong>(Java-Level JVM Compiler Interface, JVMCI)使得 Graal 可以从 HotSpot 的代码中分离出来. JVMCI 主要提供如下三种功能:</p> <ul><li><strong>响应 HotSpot 的编译请求</strong>, 并将该请求分发给 Java 实现的即时编译器.</li> <li>允许编译器访问 HotSpot 中与即时编译相关的数据结构, 包括类, 字段, 方法及其性能监控数据等, 并提供了一组这些数据结构在 Java 语言层面的抽象表示.</li> <li>提供 HotSpot 代码缓存(Code Cache)的 Java 端抽象表示, 允许编译器部署编译完成的二进制机器码.</li></ul> <p>综合利用上述三项功能, <strong>就可以把一个在 HotSpot 虚拟机外部的, 用 Java 语言实现的即时编译器(不局限于 Graal)集成到 HotSpot 中, 响应 HotSpot 发出的最顶层的编译请求, 并将编译后的二进制代码部署到 HotSpot 的代码缓存中</strong>. 此外, 单独使用上述第三项功能, 又可以绕开 HotSpot 的即时编译系统, 让该编译器直接为应用的类库编译出二进制机器码, 将该编译器当作一个提前编译器去使用(如 Jaotc).</p> <p>Graal 和 JVMCI 的出现, 为不直接从事 Java 虚拟机和编译器开发, 但对 Java 虚拟机技术充满好奇心的读者们提供一条窥探和尝试编译器技术的良好途径, 现在就将开始<strong>基于 Graal 来实战 HotSpot 虚拟机的即时编译与代码优化过程</strong>.</p> <h5 id="_2-构建编译调试环境"><a href="#_2-构建编译调试环境" class="header-anchor">#</a> 2.构建编译调试环境</h5> <p>由于 Graal 编译器要同时支持 Graal VM 下的各种子项目, 如 Truffle, Substrate VM 等, 还要支持作为 HotSpot 和 Maxine 虚拟机的即时编译器, 所以只用 Maven 或 Gradle 的话, 配置管理过程会相当复杂. 为了降低代码管理, 依赖项管理, 编译和测试等环节的复杂度, Graal 团队专门用 Python 写了一个名为 mx 的小工具来自动化做好这些事情. 要构建 Graal 的调试环境, 第一步要先把<strong>构建工具 mx</strong> 安装好, 这非常简单, 进行如下操作即可:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>$ git clone https://github.com/graalvm/mx.git
$ export PATH=`pwd`/mx:$PATH
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>既然 Graal 编译器是以 Java 代码编写的, 那第二步自然是<strong>要找一个合适的 JDK 来编译</strong>. 考虑到 Graal VM 项目是基于 OpenJDK 8 开发的, 而 JVMCI 接口又在 JDK 9 以后才会提供, 所以 Graal 团队提供了一个带有 JVMCI 功能的 OpenJDK 8 版本, 可以选择这个版本的 JDK 8 来进行编译. 当读者只关注 Graal 编译器在 HotSpot 上的应用而不想涉及 Graal VM 其他方面时, 可直接采用 JDK 9 及之后的标准 Open/OracleJDK. 在本次实战中, 笔者机器上使用的是带 JVMCI 的 OpenJDK 8, 对于与其他 JDK 版本有差别的步骤, 会特别说明. 选择好 JDK 版本后, 设置 JAVA_HOME 环境变量即可, 这是编译过程中唯一需要手工处理的依赖:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>export JAVA_HOME=/usr/lib/jvm/oraclejdk1.8.0_212-jvmci-20-b01
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>第三步是<strong>获取 Graal 编译器代码</strong>, 编译器部分的代码是与整个 Graal VM 放在一块的, 把 Graal VM 复制下来, 大约有 700MB, 操作如下:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>$ git clone https://github.com/graalvm/graal.git
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其他目录中存放着 Truffle, Substrate VM 等其他项目, 这些在本次实战中不会涉及. 进入 compiler 子目录, <strong>使用 mx 构建 Graal 编译器</strong>, 操作如下:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>$ cd graal/compiler
$ mx build
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>由于整个构建过程需要的依赖项都可以自动处理, 需要手动处理的只有 OpenJDK 一个, 所以编译一般不会出现什么问题, 大概两三分钟编译即可完成. 此时其实已经可以<strong>修改, 调试 Graal 编译器</strong>了, 但写 Java 代码不同于 C, C++, 应该没有人会直接用 VIM 去做 Java 开发调试, 还是需要一个 IDE 来支持本次实战的. mx 工具能够支持 Eclipse, Intellij IDEA 和 NetBeans 三种主流的 Java IDE 项目的创建, 由于 Graal 团队中使用 Eclipse 占多数, 支持也最好, 所以也选择 Eclipse 来进行本次实战, 创建 Eclipse 项目的操作如下:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>$ cd graal/compiler
$ mx eclipseinit
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>无论使用哪种 IDE, 都需要把 IDE 配置中使用的 Java 堆修改到 2GB 或以上, 才能保证 Graal 在 IDE 中的编译构建能够顺利进行. 设置完成后, 在 Eclipse 中选择 File-&gt;Open Projects from File System, 再选择 Graal 项目的根目录, 将会导入整个 Graal VM, 导入的工程如图 11-10 所示.</p> <p><img src="/img/Image00207-20240302133505-jn5qmxj.jpg" alt="" title="图11-10　Graal VM 项目(部分工程)"></p> <p>如果采用的是 JDK 8, 那么要记得在 Eclipse 中也必须将那个带有 JVMCI 功能的特殊 JDK 8 用作 Eclipse 里面 &quot;Java SE-1.8&quot; 的环境配置(Windows-&gt;Preferences-&gt;Java-&gt;Install JREs-&gt;Execution Environments-&gt;Java SE-1.8), 此外, 还需要手工将以其他版本号结尾的工程关闭, 譬如图 11-11 所示. 这对于采用其他版本 JDK 来编译的读者也是一样的.</p> <p>到此为止, 整个编译, 调试环境就已经构建完毕, 下面可以开始探索 <strong>Graal 工作原理</strong>的内容了.</p> <h5 id="_3-jvmci编译器接口"><a href="#_3-jvmci编译器接口" class="header-anchor">#</a> 3.JVMCI编译器接口</h5> <p><img src="/img/Image00208-20240302133505-72jxneh.jpg" alt="" title="图11-11　手动关闭其他版本的工程"></p> <p>现在请思考一下, 如果让您来设计 JVMCI 编译器接口, 它应该是怎样的? 既然 JVMCI 面向的是 Java 语言的编译器接口, 那它至少在形式上是与我们已经见过无数次的 Java 接口是一样的. 来考虑<strong>即时编译器的输入是什么</strong>. 答案当然是<strong>要编译的方法的字节码</strong>. 既然叫字节码, 顾名思义它就应该是 &quot;<strong>用一个字节数组表示的代码</strong>&quot;. 那接下来它输出什么? 这也很简单, <strong>即时编译器应该输出与方法对应的二进制机器码, 二进制机器码也应该是 &quot;用一个字节数组表示的代码&quot;</strong> . 这样的话, JVMCI 接口就应该看起来类似于下面这种样子:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">JVMCICompiler</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">compileMethod</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytecode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>事实上 JVMCI 接口只比上面这个稍微复杂一点点, 因为其输入除了字节码外, HotSpot 还会向编译器提供各种该方法的相关信息, 譬如局部变量表中变量槽的个数, 操作数栈的最大深度, 还有分层编译在底层收集到的统计信息等. 因此 JVMCI 接口的核心内容实际就是代码清单 11-13 总所示的这些.</p> <blockquote><p>代码清单11-13 JVMCI 接口</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">JVMCICompiler</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">compileMethod</span><span class="token punctuation">(</span><span class="token class-name">CompilationRequest</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">CompilationRequest</span> <span class="token punctuation">{</span>
    <span class="token class-name">JavaMethod</span> <span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">JavaMethod</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token function">getMaxLocals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token function">getMaxStackSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ProfilingInfo</span> <span class="token function">getProfilingInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">// 省略其他方法</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>我们在 Eclipse 中找到 JVMCICompiler 接口, 通过继承关系分析, 可以清楚地看到有一个实现类 <strong>HotSpotGraalCompiler</strong> 实现了 JVMCI, 如图 11-12 所示, 这个就是要分析的代码的入口.</p> <p><img src="/img/Image00209-20240302133505-4cmhikx.jpg" alt="" title="图11-12　JVMCI 接口的继承关系"></p> <p>为了后续调试方便, 先准备一段简单的代码, 并让它<strong>触发 HotSpot 的即时编译</strong>, 以便跟踪观察编译器是如何工作对的. 具体代码如清单 11-14 所示.</p> <blockquote><p>代码清单11-14 触发即时编译的示例代码</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">workload</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workload</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>由于存在无限循环, workload() 方法肯定很快就会被虚拟机发现<strong>是热点代码因而进行编译</strong>. 实际上除了 workload() 方法以外, 这段简单的代码还会导致相当多的其他方法的编译, 因为一个最简单的 Java 类的加载和运行也会触发数百个类的加载. 为了避免干扰信息太多, 笔者加入了参数 <code>-XX: CompileOnly</code>​ 来限制只允许 workload() 方法被编译. 先采用以下命令, 用标准的服务端编译器来运行清单 11-14 中所示的程序.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ javac Demo.java
$ <span class="token function">java</span> <span class="token punctuation">\</span>
  <span class="token parameter variable">-XX:+PrintCompilation</span> <span class="token punctuation">\</span>
  <span class="token parameter variable">-XX:CompileOnly</span><span class="token operator">=</span>Demo::workload <span class="token punctuation">\</span>
  Demo
<span class="token punctuation">..</span>.
    <span class="token number">193</span>    <span class="token number">1</span>       <span class="token number">3</span>       Demo::workload <span class="token punctuation">(</span><span class="token number">4</span> bytes<span class="token punctuation">)</span>
    <span class="token number">199</span>    <span class="token number">2</span>       <span class="token number">1</span>       Demo::workload <span class="token punctuation">(</span><span class="token number">4</span> bytes<span class="token punctuation">)</span>
    <span class="token number">199</span>    <span class="token number">1</span>       <span class="token number">3</span>       Demo::workload <span class="token punctuation">(</span><span class="token number">4</span> bytes<span class="token punctuation">)</span>   made not entrant
<span class="token punctuation">..</span>.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>上面显示 wordload() 方法确实被分层编译了多次, &quot;made not entrant&quot; 的输出就表示了方法的某个已编译版本被丢弃过. 从这段信息中清楚看到, 分层编译机制及最顶层的服务端编译都已经正常工作了, 下一步就是用在 Eclipse 中的 <strong>Graal 编译器代替 HotSpot 的服务端编译器</strong>.</p> <p>为简单起见, 笔者加上 <code>-XX: -TieredCompilation</code>​ 关闭分层编译, 让虚拟机只采用有一个 JVMCI 编译器而不是由客户端编译器和 JVMCI 混合分层. 然后使用参数 <code>-XX: +EnableJVMCI</code>​, <code>-XX: +UseJVMCICompiler</code>​ 来启用 JVMCI 接口和 JVMCI 编译器. 由于这些目前尚属实验阶段的功能, 需要再使用 <code>-XX: +UnlockExperimentalVMOptions</code>​ 参数进行解锁. 最后也是最关键的一个问题, <strong>如何让 HotSpot 找到 Graal 编译器的位置</strong>呢?</p> <p>如果采用特殊版的 JDK 8, 那虚拟机将会自动去查找 <code>JAVA_HOME/jre/lib/jvmci</code>​ 目录. 假如这个目录不存在, 那就会从 <code>-Djvmci.class.path.append</code>​ 参数中搜索. 它查找的目标, 即 Graal 编译器的 JAR 包, 刚才已经通过 mx build 命令成功编译出来, 所以在 JDK 8 下使用的启动参数如代码清单 11-15 所示.</p> <blockquote><p>代码清单11-15 JDK8的运行配置</p></blockquote> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>-Djvmci.class.path.append=~/graal/compiler/mxbuild/dists/jdk1.8/graal.jar:~/graal/sdk/mxbuild/dists/jdk1.8/graal-sdk.jar
-XX:+UnlockExperimentalVMOptions
-XX:+EnableJVMCI
-XX:+UseJVMCICompiler
-XX:-TieredCompilation
-XX:+PrintCompilation
-XX:CompileOnly=Demo::workload
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>如果采用 JDK 9 或以上版本, 那原本的 Graal 编译器是实现在 jdk.internal.vm.compiler 模块中的, 只要用 <code>--upgrade-module-path</code>​ 参数指定这个模块的升级包即可, 具体如代码清单 11-16 所示.</p> <blockquote><p>代码清单11-16 JDK 9或以上版本的运行配置</p></blockquote> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>--module-path<span class="token operator">=~</span>/graal/sdk/mxbuild/dists/jdk11/graal.jar
--upgrade-module-path<span class="token operator">=~</span>graal/compiler/mxbuild/dists/jdk11/jdk.internal.vm.compiler.jar
<span class="token parameter variable">-XX:+UnlockExperimentalVMOptions</span>
<span class="token parameter variable">-XX:+EnableJVMCI</span>
<span class="token parameter variable">-XX:+UseJVMCICompiler</span>
<span class="token parameter variable">-XX:-TieredCompilation</span>
<span class="token parameter variable">-XX:+PrintCompilation</span>
<span class="token parameter variable">-XX:CompileOnly</span><span class="token operator">=</span>Demo::workload
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>通过上述参数, HotSpot 就能顺利找到并应用编译的 Graal 编译器了. 为了确认效果, 对 HotSpotGraalCompiler 类的 compileMethod() 方法做一个简单改动, <strong>输出编译的方法名称和编译耗时</strong>, 具体如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">CompilationRequestResult</span> <span class="token function">compileMethod</span><span class="token punctuation">(</span><span class="token class-name">CompilationRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> time <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">CompilationRequestResult</span> result <span class="token operator">=</span> <span class="token function">compileMethod</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> graalRuntime<span class="token punctuation">.</span><span class="token function">getOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;compile method:&quot;</span> <span class="token operator">+</span> request<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;time used:&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> time<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在 Eclipse 里面运行这段代码, 不需要重新运行 mx build, 马上就可以看到类似如下所示的输出结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>97    1             Demo::workload (4 bytes)
......
compile method:workload
time used:4081
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h5 id="_4-代码中间表示"><a href="#_4-代码中间表示" class="header-anchor">#</a> 4.代码中间表示</h5> <p>Graal 编译器在设计之初就刻意采用了与 HotSpot 服务端编译器一致(略有差异但已经非常接近)的中间表示形式, 也即是被称为 <strong>Sea-of-Nodes 的中间表示</strong>, 或者与其等价的被称为<strong>理想图</strong>(Ideal Graph, 在代码中称为 Structured Graph)的程序依赖图(Program Dependence Graph, PDG)形式. 在 11.2 节即时编译器的实战中, 已经通过可视化工具 Ideal Graph Visualizer 看到过在理想图上翻译和优化输入代码的整体过程, 从编译器内部来看即: <strong>字节码 → 理想图 → 优化 → 机器码</strong>(以 Mach Node Graph 表示)的转变过程. 在那个实战里面, 着重分析的是理想图转换优化的整体过程, 对于多数读者, 尤其是不熟悉编译原理与编译器设计的读者, 可能会不太容易读懂每个阶段所要做的工作. 在本节里面, 以例子和对照 Graal 源码的形式, 详细讲解输入代码与理想图的转化对应关系, 以便读者理解 Graal 是如何基于理想图去优化代码的.</p> <p><strong>理想图是一种有向图, 用节点来表示程序中的元素, 譬如变量, 操作符, 方法, 字段等, 而用边来表示数据或者控制流</strong>. 先从最简单的例子出发. 譬如有一个表达式: <code>x + y</code>​, 在理想图中可以表示为 x, y 两个节点的数据流流入加法操作符, 表示相加操作读取了 x, y 的值, 流出的便则表示数据流的流向, 即相加的结果会在哪里被使用, 如图 11-13 所示.</p> <p><img src="/img/Image00210-20240302133505-2xhxgdb.jpg" alt="" title="图11-13　构造理想图(1)"></p> <p>这很容易接受吧? 那把例子稍微复杂化一些, 把表达式 <code>x + y</code>​ 变为 <code>getX() + getY()</code>​, 仍是用理想图表达其计算过程, 这时候除了数据流向之外, 还必须要考虑<strong>方法调用的顺序</strong>. 在理想图中用另外一条边来表示方法的调用(为了便于区分, 数据流笔者使用蓝色线(以虚线表示), 控制流使用红色线(以实线表示)), 说明代码的执行顺序是先调用 getX() 方法, 再调用 getY() 方法, 如图 11-14 所示.</p> <p><img src="/img/Image00211-20240302133505-qif47hf.jpg" alt="" title="图11-14　构造理想图(2)"></p> <p>以上这些简单的前置知识就已经足以支撑本次实战的进行了, <strong>理想图本质上就是这种将数据流图和控制流图以某种方式合并到一起, 用一种边来表示数据流向, 另一种边来表示控制流向的图形表示</strong>.</p> <p>现在在代码清单 11-15 或者代码清单 11-16 所示的基础上再增加一个参数 <code>-Dgraal.Dump</code>​, 要求 Graal 编译器把构造的理想图输出出来, 加入后编译时将会产生类似如下的输出, 提示了生成的理想图的存储位置:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>[Use -Dgraal.LogFile=&lt;path&gt; to redirect Graal log output to a file.]
Dumping IGV graphs in /home/icyfenix/develop/eclipse-workspace/A_GraalTest/graal_dumps/2019.08.18.16.51.23.073
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可以使用 mx igv 命令来获得能够支持 Graal 编译器生成的理想图格式的新版本的 Ideal Graph Visualizer 工具, 以下面这段简单代码的理想图的表示为例子:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在 Ideal Graph Visualizer 工具中, 将显示图 11-15 所示的样式的理想图.</p> <p><img src="/img/Image00212-20240302133505-hxuawd5.jpg" alt="" title="图11-15　构造理想图(3)"></p> <p>与图 11-11 和图 11-12 所示相比, 虽然没有了箭头, 但是节点上列明了代表执行顺序的序号, 仍然是蓝色线表示数据流, 红色线表示控制流. 从图中可以看到参数 0(记作 P(0))和参数 1(记作 P(1))是如何送入加法操作的, 然后结果是如何和常量 2(记作 C(2))一起送入除法操作的.</p> <p>再下一步就会开始接触真实的代码编译和优化了. 前面介绍编译器优化技术时提到过公共子表达式消除, 那就来设计代码清单 11-17 所示的两段代码.</p> <blockquote><p>代码清单11-17 公共子表达式被消除的应用范围</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 以下代码的公共子表达式能够被消除</span>
<span class="token keyword">int</span> <span class="token function">workload</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 以下代码的公共子表达式是不可以被消除的</span>
<span class="token keyword">int</span> <span class="token function">workload</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">getB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">getB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>对于第一段代码, <code>a + b</code>​ 是公共子表达式, 可以通过优化使其只计算一次而不会有任何的副作用. 但是对于第二段代码, 由于 getA() 和 getB() 方法内部所蕴含的操作是不确定的, 它是否被调用, 调用次数的不同都可能会产生不同返回值或者其他影响程序状态的副作用(譬如改变某个全局的状态变量), 这种代码只能内联了 getA() 和 getB() 方法之后才能考虑更进一步的优化措施, 仍然保持函数调用的情况下是无法做公共子表达式消除的. 可以从 Graal 生成的理想图中清晰地看到这一点, 对于第一段代码, 生成的理想图如图 11-16 所示.</p> <p><img src="/img/Image00213-20240302133505-xjiq330.jpg" alt="" title="图11-16　构造理想图(4)"></p> <p>从图 11-16 所示中可以看到, 参数 1, 2 的加法操作只进行了一次, 然后同时流出了两条数据流指向乘法操作的输入中. 而如果是第二段代码, 则生成的理想图如图 11-17 所示.</p> <p><img src="/img/Image00214-20240302133505-2jr8j52.jpg" alt="" title="图11-17　构造理想图(5)"></p> <p>从图中代表控制流的红色边(以实线表示)可以看出, 四次方法调用全部执行了, 代表数据流的蓝色边(以虚线表示)也明确看到了两个独立加法操作节点, 由此看出这个版本是不会把它当作公共子表达式来消除的.</p> <h5 id="_5-代码优化与生成"><a href="#_5-代码优化与生成" class="header-anchor">#</a> 5.代码优化与生成</h5> <p>相信读者现在已经能够基本看明白 Graal 理想图的中间表示了, 那对应到代码上, <strong>Graal 编译器是如何从字节码生成理想图</strong>? 又如何在理想图基础上进行代码优化的呢? 这时候就充分体现出了 Graal 编译器在使用 Java 编写时对普通 Java 程序员来说具有的便捷性了, 在 Outline 视图中找到创建理想图的方法是 greateGraph(), 可以从 Call Hierarchy 视图中轻易地找到从 JVMCI 的入口方法 compileMethod() 到 greateGraph() 之间的调用关系, 如图 11-18 所示.</p> <p>greateGraph() 方法的代码也很清晰, 里面调用了 <code>StructuredGraph::Builder()</code>​ 构造器来创建理想图. 这里要关注的关键点有两个:</p> <p><img src="/img/Image00215-20240302133505-hlsjrht.jpg" alt="" title="图11-18　构造理想图的方法"></p> <p>第一是理想图本身的数据结构. 它是一组不为空的节点的集合, 它的节点都是用 ValueNode 的不同类型的子类节点来表示的. 仍然以 x+y 表达式为例, 譬如其中的加法操作, 就由 AddNode 节点来表示, 从图 11-19 所示的 Type Hierarchy 视图中可以清楚地看到加法操作是二元算术操作节点(<code>BinaryArithmeticNode&lt;OP&gt;</code>​)的一种, 而二元算术操作节点又是二元操作符(BinaryNode)的一种, 以此类推直到所有操作符的共同父类 ValueNode(表示可以返回数据的节点).</p> <p>第二就是如何从字节码转换到理想图. 该过程被封装在 BytecodeParser 类中, 这个解析器可以按照字节码解释器的思路去理解它. 如果这真的是一个字节码解释器, 执行一个整数加法操作, 按照《Java 虚拟机规范》所定义的 iadd 操作码的规则, 应该从栈帧中出栈两个操作数, 然后相加, 再将结果入栈. 而从 <code>BytecodeParser::genArithmeticOp()</code>​ 方法上可以看到, 其实现与规则描述没有什么差异, 如图 11-20 所示.</p> <p><img src="/img/Image00216-20240302133505-0bcqd61.jpg" alt="" title="图11-19　节点继承关系"></p> <p><img src="/img/Image00217-20240302133505-fe36g0c.jpg" alt="" title="图11-20　字节码解析器实现的 iadd 操作码"></p> <p>其中, genIntegerAdd() 方法中就只有一行代码, 即调用 AddNode 节点的 create() 方法, 将两个操作数作为参数传入, 创建出 AddNode 节点, 如下所示:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">ValueNode</span> <span class="token function">genIntegerAdd</span><span class="token punctuation">(</span><span class="token class-name">ValueNode</span> x<span class="token punctuation">,</span> <span class="token class-name">ValueNode</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token class-name">AddNode</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token class-name">NodeView</span><span class="token punctuation">.</span><span class="token constant">DEFAULT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>每一个理想图的节点都有两个共同的主要操作, 一个是规范化(Canonicalisation), 另一个是生成机器码(Generation). 生成机器码顾名思义, 就不必解释了, 规范化则是指如何缩减理想图的规模, 也即在理想图的基础上优化代码所要采取的措施. 这两个操作对应了编译器两项最根本的任务: <strong>代码优化与代码翻译</strong>.</p> <p>AddNode 节点的规范化是实现在 canonical() 方法中的, 机器码生成则是实现在 generate() 方法中的, 从 AddNode 的创建方法上可以看到, 在节点创建时会调用 canonical() 方法尝试进行规范化缩减图的规模, 如下所示:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ValueNode</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">ValueNode</span> x<span class="token punctuation">,</span> <span class="token class-name">ValueNode</span> y<span class="token punctuation">,</span> <span class="token class-name">NodeView</span> view<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">BinaryOp</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Add</span><span class="token punctuation">&gt;</span></span> op <span class="token operator">=</span> <span class="token class-name">ArithmeticOpTable</span><span class="token punctuation">.</span><span class="token function">forStamp</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">stamp</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Stamp</span> stamp <span class="token operator">=</span> op<span class="token punctuation">.</span><span class="token function">foldStamp</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">stamp</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span><span class="token function">stamp</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ConstantNode</span> tryConstantFold <span class="token operator">=</span> <span class="token function">tryConstantFold</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> stamp<span class="token punctuation">,</span> view<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tryConstantFold <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> tryConstantFold<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">isConstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>y<span class="token punctuation">.</span><span class="token function">isConstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">canonical</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> op<span class="token punctuation">,</span> y<span class="token punctuation">,</span> x<span class="token punctuation">,</span> view<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">canonical</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> op<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> view<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>从 AddNode 的 canonical() 方法中可以看到为了缩减理想图的规模而做的相当多的努力, 即使只是两个整数相加那么简单的操作, 也尝试过了常量折叠(如果两个操作数都为常量, 则直接返回一个常量节点), 算术聚合(聚合树的常量子节点, 譬如将 <code>(a + 1) + 2</code>​ 聚合为 <code>a + 3</code>​), 符号合并(聚合树的相反符号子节点, 譬如将 <code>(a - b) + b</code>​ 或者 <code>b + (a - b)</code>​ 直接合并为 a)等多种优化, canonical() 方法的内容较多, 请读者自行参考源码, 为节省版面这里就不贴出了.</p> <p>对理想图的规范化并不局限于单个操作码的局部范围之内, 很多的优化都是要立足于全局来进行的, 这类操作在 CanonicalizerPhase 类中完成. 仍然以上一节的公共子表达式消除为例, 这就是一个全局性的优化, 实现在 <code>CanonicalizerPhase::tryGlobalValueNumbering()</code>​ 方法中, 其逻辑看起来已经非常清晰了: 如果理想图中发现了可以进行消除的算术子表达式, 那就找出重复的节点, 然后替换, 删除. 具体代码如下所示:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryGlobalValueNumbering</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token class-name">NodeClass</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> nodeClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeClass<span class="token punctuation">.</span><span class="token function">valueNumberable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> newNode <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findDuplicate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newNode <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">assert</span> <span class="token operator">!</span><span class="token punctuation">(</span>node <span class="token keyword">instanceof</span> <span class="token class-name">FixedNode</span> <span class="token operator">||</span> newNode <span class="token keyword">instanceof</span> <span class="token class-name">FixedNode</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            node<span class="token punctuation">.</span><span class="token function">replaceAtUsagesAndDelete</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token constant">COUNTER_GLOBAL_VALUE_NUMBERING_HITS</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span>debug<span class="token punctuation">)</span><span class="token punctuation">;</span>
            debug<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;GVN applied and new node is %1s&quot;</span><span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>至于代码生成, Graal 并不是直接由理想图转换到机器码, 而是和其他编译器一样, 会先生成低级中间表示(LIR, 与具体机器指令集相关的中间表示), 然后再由 HotSpot 统一后端来产生机器码. 譬如涉及算术运算加法的操作, 就在 ArithmeticLIRGeneratorTool 接口的 emitAdd() 方法里完成. 从低级中间表示的实现类上, 可以看到 Graal 编译器能够支持的目标平台, 目前它只提供了三种目标平台的指令集(SPARC, x86-AMD64, ARMv8-AArch64)的低级中间表示, 所以现在 Graal 编译器也就只能支持这几种目标平台, 如图 11-21 所示.</p> <p><img src="/img/Image00218-20240302133505-2dkeawe.jpg" alt="" title="图11-21　Graal 支持的目标平台生成器"></p> <p>为了验证代码阅读的成果, 现在来对 AddNode 的代码生成做一些小改动, 将原本生成加法汇编指令修改为生成减法汇编指令, 即按如下方式修改 <code>AddNode::generate()</code>​ 方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">AddNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> gen<span class="token punctuation">.</span><span class="token function">emitSub</span><span class="token punctuation">(</span>op1<span class="token punctuation">,</span> op2<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">// 原来这个方法是 emitAdd()</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>然后在虚拟机运行参数中加上 <code>-XX: +PrintAssembly</code>​ 参数, 因为从低级中间表示到真正机器码的转换是由 HotSpot 统一负责的, 所以 11.2 节中用到的 HSDIS 插件仍然能发挥作用, 帮助输出汇编代码. 从输出的汇编中可以看到, 在没有修改之前, AddNode 节点输出的汇编代码如下所示:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>0x000000010f71cda0: nopl   0x0(%rax,%rax,1)
0x000000010f71cda5: add    %edx,%esi     ;*iadd {reexecute=0 rethrow=0 return_oop=0}
                                         ; - Demo::workload@2 (line 10)

0x000000010f71cda7: mov    %esi,%eax     ;*ireturn {reexecute=0 rethrow=0 return_oop=0}
                                         ; - Demo::workload@3 (line 10)

0x000000010f71cda9: test   %eax,-0xcba8da9(%rip)        # 0x0000000102b74006
                                         ;   {poll_return}
0x000000010f71cdaf: vzeroupper
0x000000010f71cdb2: retq
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>而被修改后, 编译的结果已经变为:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>0x0000000107f451a0: nopl   0x0(%rax,%rax,1)
0x0000000107f451a5: sub    %edx,%esi          ;*iadd {reexecute=0 rethrow=0 return_oop=0}
                                              ; - Demo::workload@2 (line 10)

0x0000000107f451a7: mov    %esi,%eax          ;*ireturn {reexecute=0 rethrow=0 return_oop=0}
                                              ; - Demo::workload@3 (line 10)

0x0000000107f451a9: test   %eax,-0x1db81a9(%rip)        # 0x000000010618d006
                                              ;   {poll_return}
0x0000000107f451af: vzeroupper
0x0000000107f451b2: retq
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>这里的修改确实促使 Graal 编译器产生了不同的汇编代码, 这也印证了代码分析的思路是正确的. 写到这里, 笔者忍不住感慨, Graal 编译器的出现对学习和研究虚拟机代码编译技术实在有着不可估量的价值. 在本书第 2 版编写时, 只有 C++ 编写的复杂无比的服务端编译器, 要进行类似的实战是非常困难的, 即使勉强写出来, 也会因为过度烦琐而失去阅读价值.</p> <p>‍</p> <h4 id="本章小结"><a href="#本章小结" class="header-anchor">#</a> 本章小结</h4> <p>本章学习了与提前编译和即时编译器两大后端编译器相关的知识, 了解了提前编译器重新兴起的原因及其优劣势; 还有与即时编译器相关的热点探测方法, 编译触发条件及如何从虚拟机外部观察和分析即时编译的数据和结果; 还选择了几种常见的编译器优化技术进行讲解, 对 Java 编译器的深入了解, 有助于在工作中分辨哪些代码是编译器可以帮我们处理的, 哪些代码需要自己调节以便更适合编译器的优化.</p> <p>‍</p> <h4 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h4> <ul><li><a href="https://www.cnblogs.com/baronzhang/p/11108322.html" target="_blank" rel="noopener noreferrer">深入理解Java虚拟机(程序编译与代码优化)https://www.cnblogs.com/baronzhang/p/11108322.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>‍</p> <p>‍</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/20.开发/2000.Java/600.JVM/41.后端编译与优化🌼.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/deb8b7/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">前端编译与优化🌼</div></a> <a href="/pages/3d72db/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Java内存模型与线程实现🌼</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/deb8b7/" class="prev">前端编译与优化🌼</a></span> <span class="next"><a href="/pages/3d72db/">Java内存模型与线程实现🌼</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/87.281da75d.js" defer></script>
  </body>
</html>
