<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>显式锁ReentrantLock | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/62.1213823d.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/4f30b9/" class="sidebar-link">Java基础</a></li><li><a href="/pages/795eca/" class="sidebar-link">类与继承</a></li><li><a href="/pages/c69152/" class="sidebar-link">抽象类与接口</a></li><li><a href="/pages/d71abb/" class="sidebar-link">内部类</a></li><li><a href="/pages/f06dca/" class="sidebar-link">枚举类</a></li><li><a href="/pages/259f57/" class="sidebar-link">常用类</a></li><li><a href="/pages/84b03b/" class="sidebar-link">关键字</a></li><li><a href="/pages/31b87b/" class="sidebar-link">注解</a></li><li><a href="/pages/f81c0d/" class="sidebar-link">异常</a></li><li><a href="/pages/ae7746/" class="sidebar-link">泛型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>容器类</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/0c88ac/" class="sidebar-link">集合容器类基础</a></li><li><a href="/pages/f805ed/" class="sidebar-link">List与Queue类</a></li><li><a href="/pages/d24b60/" class="sidebar-link">Map与Set类</a></li><li><a href="/pages/54e5d3/" class="sidebar-link">并发容器类</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/67d70f/" class="sidebar-link">多线程基础</a></li><li><a href="/pages/ffc8f7/" class="sidebar-link">Java内置锁</a></li><li><a href="/pages/c43494/" class="sidebar-link">AQS</a></li><li><a href="/pages/eb5b61/" aria-current="page" class="active sidebar-link">显式锁ReentrantLock</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/eb8cbc/" class="sidebar-link">线程协作与JUC组件</a></li><li><a href="/pages/23c79a/" class="sidebar-link">Atomic原子变量与Unsafe类与CAS</a></li><li><a href="/pages/9d6ed4/" class="sidebar-link">线程池与定时任务</a></li><li><a href="/pages/5b787a/" class="sidebar-link">ThreadLocal</a></li><li><a href="/pages/db53d1/" class="sidebar-link">Java并发编程实战(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>IO</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b4d461/" class="sidebar-link">文件操作</a></li><li><a href="/pages/1b9d6c/" class="sidebar-link">IO流操作</a></li><li><a href="/pages/076a47/" class="sidebar-link">Java网络IO模型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>高级特性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d76905/" class="sidebar-link">Lambda表达式</a></li><li><a href="/pages/f7f0e6/" class="sidebar-link">流Stream</a></li><li><a href="/pages/7cc40a/" class="sidebar-link">反射</a></li><li><a href="/pages/945326/" class="sidebar-link">代理</a></li><li><a href="/pages/7fd9b4/" class="sidebar-link">Javaagent</a></li><li><a href="/pages/a3cee0/" class="sidebar-link">Guava</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>JVM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d308f6/" class="sidebar-link">走进JVM🌼</a></li><li><a href="/pages/be0269/" class="sidebar-link">JVM内存区域与对象解析🌼</a></li><li><a href="/pages/48d1be/" class="sidebar-link">垃圾收集器与内存分配策略🌼</a></li><li><a href="/pages/3a4c8a/" class="sidebar-link">JVM性能监控与故障处理工具🌼</a></li><li><a href="/pages/106680/" class="sidebar-link">调优案例分析与实战🌼</a></li><li><a href="/pages/16a914/" class="sidebar-link">类文件结构🌼</a></li><li><a href="/pages/ea287c/" class="sidebar-link">虚拟机类加载机制🌼</a></li><li><a href="/pages/6367b0/" class="sidebar-link">虚拟机字节码执行引擎🌼</a></li><li><a href="/pages/c6c210/" class="sidebar-link">类加载及执行子系统的案例与实战🌼</a></li><li><a href="/pages/deb8b7/" class="sidebar-link">前端编译与优化🌼</a></li><li><a href="/pages/1f8f72/" class="sidebar-link">后端编译与优化🌼</a></li><li><a href="/pages/3d72db/" class="sidebar-link">Java内存模型与线程实现🌼</a></li><li><a href="/pages/ed086e/" class="sidebar-link">线程安全与内置锁优化🌼</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/56b9dd/" class="sidebar-link">Java性能问题定位分析</a></li><li><a href="/pages/939bf8/" class="sidebar-link">杂记</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>开发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>软件设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/a5f6fe/" class="sidebar-link">设计基础理论</a></li><li><a href="/pages/3b245c/" class="sidebar-link">设计模式之美(极客时间)🌟</a></li><li><a href="/pages/661fa4/" class="sidebar-link">领域驱动设计(DDD)</a></li><li><a href="/pages/856368/" class="sidebar-link">DDD实战课(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d3fbd2/" class="sidebar-link">数据库基础</a></li><li><a href="/pages/691fc3/" class="sidebar-link">数据库系统原理</a></li><li><a href="/pages/50f6b7/" class="sidebar-link">MySQL基础必知必会</a></li><li><a href="/pages/fe297e/" class="sidebar-link">MySQL特性</a></li><li><a href="/pages/07bdb6/" class="sidebar-link">MySQL索引🌟</a></li><li><a href="/pages/984715/" class="sidebar-link">MySQL锁🌟</a></li><li><a href="/pages/53b588/" class="sidebar-link">MySQL事务🌟</a></li><li><a href="/pages/becc59/" class="sidebar-link">MySQL高级特性</a></li><li><a href="/pages/056463/" class="sidebar-link">MySQL基础架构与存储引擎🌟</a></li><li><a href="/pages/63b46e/" class="sidebar-link">MySQL架构优化与运维</a></li><li><a href="/pages/9995e5/" class="sidebar-link">MySQL优化</a></li><li><a href="/pages/c1c2f6/" class="sidebar-link">MySQL架构</a></li><li><a href="/pages/8e8e0a/" class="sidebar-link">MySQL设计规范</a></li><li><a href="/pages/0219aa/" class="sidebar-link">MySQL运维</a></li><li><a href="/pages/e288c0/" class="sidebar-link">MySQL中间件</a></li><li><a href="/pages/c6cafa/" class="sidebar-link">MySQL实战45讲(极客时间)🌟</a></li><li><a href="/pages/4a6106/" class="sidebar-link">数据库LeetCode题目</a></li><li><a href="/pages/2827f1/" class="sidebar-link">数据库综合问题</a></li><li><a href="/pages/c616d5/" class="sidebar-link">MongoDB</a></li><li><a href="/pages/075e71/" class="sidebar-link">ClickHouse</a></li><li><a href="/pages/d74f6d/" class="sidebar-link">Doris</a></li><li><a href="/pages/b6bad9/" class="sidebar-link">HBase</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Spring</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bd8eb8/" class="sidebar-link">Spring Boot基础</a></li><li><a href="/pages/d0d797/" class="sidebar-link">Spring Boot应用整合</a></li><li><a href="/pages/314cdc/" class="sidebar-link">Spring MVC基础</a></li><li><a href="/pages/80de47/" class="sidebar-link">Spring AOP基础</a></li><li><a href="/pages/f0d4d6/" class="sidebar-link">Spring事务基础</a></li><li><a href="/pages/db6afe/" class="sidebar-link">Spring IOC源码分析-概览</a></li><li><a href="/pages/672e98/" class="sidebar-link">Spring IOC源码分析-getBean()</a></li><li><a href="/pages/695b90/" class="sidebar-link">Spring IOC源码分析-createBean()</a></li><li><a href="/pages/f89bcf/" class="sidebar-link">Spring AOP源码分析</a></li><li><a href="/pages/3b52f4/" class="sidebar-link">Spring事务源码分析</a></li><li><a href="/pages/186902/" class="sidebar-link">Spring Boot源码分析</a></li><li><a href="/pages/16bd1c/" class="sidebar-link">Spring MVC源码分析</a></li><li><a href="/pages/3d0c1f/" class="sidebar-link">Spring Cloud</a></li><li><a href="/pages/d56156/" class="sidebar-link">Spring编程常见错误50例(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>MyBatis</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bb032d/" class="sidebar-link">基础</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>工具与环境</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c9cb6e/" class="sidebar-link">Arthas</a></li><li><a href="/pages/3172bb/" class="sidebar-link">Maven</a></li><li><a href="/pages/37f79a/" class="sidebar-link">Git</a></li><li><a href="/pages/db9f99/" class="sidebar-link">环境搭建与部署</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c725f5/" class="sidebar-link">测试基础</a></li><li><a href="/pages/7893a4/" class="sidebar-link">单元测试</a></li><li><a href="/pages/af9f25/" class="sidebar-link">压力测试</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>代码质量</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ec2b81/" class="sidebar-link">代码整洁之道</a></li><li><a href="/pages/474cdf/" class="sidebar-link">阿里巴巴编程规范</a></li><li><a href="/pages/c47e15/" class="sidebar-link">代码之丑(极客时间)🌸</a></li><li><a href="/pages/4d4606/" class="sidebar-link">Java业务开发常见错误100例(极客时间)🌸</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/develop/#开发" data-v-06970110>开发</a></li><li data-v-06970110><a href="/develop/#Java" data-v-06970110>Java</a></li><li data-v-06970110><a href="/develop/#并发" data-v-06970110>并发</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">显式锁ReentrantLock<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_305-显式锁reentrantlock"><a href="#_305-显式锁reentrantlock" class="header-anchor">#</a> 305.显式锁ReentrantLock</h1> <p>显式锁是基于 <strong>API</strong> 实现的锁.</p> <h4 id="lock接口"><a href="#lock接口" class="header-anchor">#</a> Lock接口</h4> <h5 id="_1-基础"><a href="#_1-基础" class="header-anchor">#</a> 1.基础</h5> <p><strong>synchronized</strong> 方法或语句的使用提供了对与每个<strong>对象</strong>相关的隐式监视器锁的访问, 但却强制所有锁获取和释放均要出现在<strong>一个块结构</strong>中: 当获取了<strong>多个锁</strong>时, 它们必须以<strong>相反的顺序释放</strong>, 且必须在与所有锁被获取时相同的词法范围内释放所有锁.</p> <p>这个时候出现了 Lock 接口. 它是 java.util.concurrent.<strong>locks</strong> 包中的一个<strong>接口</strong>. Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作, 更灵活的操作, 可以具有差别很大的属性, 可以支持多个相关的 Condition 对象. 当然更高的自由度也带来更多的责任.</p> <blockquote><p>加锁规范示例</p></blockquote> <p>在 <strong>try...catch 模块</strong>之前使用 <strong>lock</strong> 加锁(阿里规范), 在 <strong>finally</strong> 模块中<strong>释放锁</strong>(保证锁必须释放). 下面是示范代码.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Lock</span> myLock <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
myLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// access the resource protected by this lock</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    myLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>锁的锁定和释放如果在<strong>不同的模块</strong>时, 需要谨慎编码, 确保最后锁一定能够得到<strong>释放</strong>.</p> <h5 id="_2-源码分析"><a href="#_2-源码分析" class="header-anchor">#</a> 2.源码分析</h5> <p>Lock 接口源码如下.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 获取锁. 如果锁不可用, 出于线程调度目的, 将禁用当前线程, 并且在获得锁之前, 该线程将一直处于休眠状态</span>
<span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 如果当前线程未被中断, 则获取锁</span>
<span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 返回绑定到此Lock实例的新Condition实例</span>
<span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 仅在调用时锁为空闲状态才获取该锁. 如果锁可用, 则获取锁, 并立即返回值true. </span>
<span class="token comment">// 如果锁不可用, 则此方法将立即返回值false</span>
<span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 如果锁在给定的等待时间内空闲, 并且当前线程未被中断, 则获取锁</span>
<span class="token keyword">boolean</span>	<span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token comment">// 释放锁. 在等待条件前, 锁必须由当前线程保持. 调用Condition.await()将在等待前以原子方式释放锁, </span>
<span class="token comment">// 并在等待返回前重新获取锁</span>
<span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>Lock 接口有三个<strong>实现类</strong>分别是 <strong>ReentrantLock</strong>, <strong>ReentrantReadWriteLock.ReadLock, ReentrantReadWriteLock.WriteLock</strong>. 后面两个是<strong>内部类</strong>. <strong>ReentrantReadWriteLock</strong> 实现了 <strong>ReadWriteLock</strong> 接口, 同时其内部有两个内部类实现了 Lock 接口. 如下图所示.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220601232316188.png" alt=""></p> <h4 id="reentrantlock"><a href="#reentrantlock" class="header-anchor">#</a> ReentrantLock</h4> <h5 id="_1-基础-2"><a href="#_1-基础-2" class="header-anchor">#</a> 1.基础</h5> <p>Java 中可以使用关键字 synchronized 实现独占锁, 使得资源仅允许被一个线程使用. 此外还可以使用 <strong>ReentrantLock 实现独占锁</strong>. 虽然在性能上 ReentrantLock 和 synchronized 区别已经不大了, 但 ReentrantLock 相比 synchronized 而言功能更加<strong>丰富</strong>, 使用起来更为灵活, 也更适合复杂的并发场景.</p> <p><strong>ReentrantLock</strong> 是 JUC 包中的基于 AQS 实现的一个<strong>可重入的互斥锁</strong>. <strong>ReentrantLock</strong> <strong><strong>和</strong></strong> <strong><strong><strong>synchronized</strong></strong></strong> <strong><strong>在基本用法, 行为语义上都是类似的, 同样都具有可重入性. 不过相比原生的 Synchronized, ReentrantLock 增加了一些</strong></strong>​<strong>高级的扩展功能</strong>, 比如它可以实现<strong>公平锁,</strong> <strong><strong>同时可以绑定</strong></strong>​<strong>多个 Conditon</strong>.</p> <p>使用 <strong>tryLock()</strong>  可以<strong>避免死锁</strong>. 它会在持有一个锁 A 获取另一个锁 B 而获取不到 B 的时候, 可以释放已持有的锁 A, 给其他线程获取锁 A 的机会, 然后<strong>重试</strong>获取所有锁.</p> <blockquote><p>ReentrantLock使用示例</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LockExample</span> <span class="token punctuation">{</span>
	<span class="token comment">// 定义锁</span>
    <span class="token keyword">private</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 加锁</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保释放锁, 从而避免发生死锁</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">LockExample</span> lockExample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LockExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 加锁效果与synchronized类似</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> lockExample<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> lockExample<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language-html line-numbers-mode"><pre class="language-html"><code>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h5 id="_2-基本特性"><a href="#_2-基本特性" class="header-anchor">#</a> 2.基本特性</h5> <h6 id="_1-可重入性"><a href="#_1-可重入性" class="header-anchor">#</a> (1)可重入性</h6> <p>所谓的<strong>可重入性</strong>, 就是<strong>可以支持一个线程对锁的重复获取</strong>, synchronized 就具有可重入性, 一个用 synchronized 修饰的递归方法, 当线程在执行期间, 它是可以<strong>反复</strong>获取到锁的, 而不会出现自己把自己锁死的情况. ReentrantLock 也是如此, 在调用 lock() 方法时, 已经获取到锁的线程, 能够<strong>再次调用</strong> lock() 方法获取到锁而不被阻塞. 那么有可重入锁, 就有不可重入锁, 之前自定义的一个 Mutex 锁就是个不可重入锁, 不过使用场景极少而已.</p> <h6 id="_2-公平锁-非公平锁"><a href="#_2-公平锁-非公平锁" class="header-anchor">#</a> (2)公平锁/非公平锁</h6> <p>synchronized 是<strong>非公平锁</strong>, ReentrantLock <strong>默认也是非公平</strong>的, 但是可以通过带 boolean 参数(<strong>fair</strong> 参数)的构造方法<strong>指定使用公平锁</strong>, 但<strong>非公平锁的性能一般要优于公平锁</strong>. ReentrantLock 默认使用非公平锁是基于性能考虑, 公平锁为了保证线程规规矩矩地排队, 需要增加阻塞和唤醒的时间开销. 如果直接插队获取非公平锁, 跳过了对队列的处理, 速度会更快.</p> <p>从线程获取锁的顺序和调用 lock 的顺序来说, 两者区别如下:</p> <ul><li>公平锁: 线程获取锁的顺序和调用 lock 的顺序一样, <strong>FIFO</strong>.</li> <li>非公平锁: 线程获取锁的顺序和调用 lock 的<strong>顺序无关</strong>.</li></ul> <h6 id="_3-相比synchronized的拓展功能"><a href="#_3-相比synchronized的拓展功能" class="header-anchor">#</a> (3)相比synchronized的拓展功能</h6> <p>ReentrantLock 比 synchronized 增加了一些<strong>高级功能</strong>. 主要来说主要有三点: <mark><strong>1.等待可中断; 2.可实现公平锁; 3.可实现选择性通知(可以绑定多个条件)</strong></mark> .</p> <ul><li><mark><strong>等待可中断</strong></mark>: 是指<strong>当持有锁的线程长期不释放锁的时候, 正在等待的线程可以选择放弃等待, 改为处理其他事情</strong>. 可中断特性对处理执行时间非常长的同步块很有帮助. ReentrantLock 提供了一种能够中断等待锁的线程的机制, 通过 lock.lockInterruptibly() 来实现这个机制.</li> <li><mark><strong>可实现公平锁</strong></mark>: <strong>ReentrantLock 可以指定是公平锁还是非公平锁</strong>. 而 <strong>synchronized 只能是非公平锁</strong>. ReentrantLock 默认情况是非公平的, 可以通过 ReentrantLock 类的 ReentrantLock(boolean fair) <strong>构造方法</strong>来制定是否是公平的. <strong>不过一旦使用了公平锁, 将会导致 ReentrantLock 的性能急剧下降, 会明显影响吞吐量</strong>.</li> <li><mark><strong>锁绑定多个条件</strong></mark>: 指一个 ReentrantLock 对象可以<strong>同时绑定多个 Condition 对象</strong>. 在 synchronized 中, 锁对象的 wait() 跟它的 notify() 或者 notifyAll() 方法配合可以实现一个隐含的条件, 如果要和<strong>多于一个的条件关联的时候, 就不得不额外添加一个锁</strong>. 而 ReentrantLock 与 <strong>Condition</strong> 接口搭配使用时, <strong>线程对象可以注册在指定的 Condition 中, 从而可以有选择性的进行线程通知, 在调度线程上更加灵活</strong>. (参考: Condition)</li></ul> <h5 id="_2-源码分析-2"><a href="#_2-源码分析-2" class="header-anchor">#</a> 2.源码分析</h5> <p>接下来从源码角度来看看 ReentrantLock 的实现原理, 它是<strong>如何保证可重入性, 又是如何实现公平锁的</strong>.</p> <p>ReentrantLock 是基于 <strong>AQS</strong> 实现的, 它也是覆写了 AQS 的模板方法, 先参考: AQS与模板方法模式.</p> <h6 id="_1-继承体系"><a href="#_1-继承体系" class="header-anchor">#</a> (1)继承体系</h6> <p>ReentrantLock 的构造方法如下.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 内部实例</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync<span class="token punctuation">;</span>

<span class="token comment">// 无参构造器默认为非公平锁</span>
<span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// fair为true, 公平锁; 反之, 非公平锁</span>
<span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 根据fair参数决定初始化哪个同步组件</span>
    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>由此可见, ReentrantLock 的抽象<strong>静态内部类 Sync 继承了 AQS, 分为公平锁 FairSync 和非公平锁 NonfairSync</strong>. 此处可以指定是否采用公平锁, <strong>FailSync 和 NonFailSync 都是 Reentrantlock 的静态内部类, 都继承于 Sync</strong>.</p> <p>几个静态内部类的关系如下图所示.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220603113728115.png" alt=""></p> <p>下面的分析基本都是围绕 <strong>FailSync 和 NonFailSync</strong> 展开的.</p> <h6 id="_2-基本方法"><a href="#_2-基本方法" class="header-anchor">#</a> (2)基本方法</h6> <blockquote><p>lock()</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 代理到Sync的lock方法上</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Sync 的 lock 方法是<strong>抽象</strong>的, 实际的 lock 会<strong>代理到 FairSync 或是 NonFairSync 上</strong>, 也就是会根据用户的选择来决定, 公平锁还是非公平锁.</p> <blockquote><p>lockInterruptibly()</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 代理到sync的相应方法上, 同lock方法的区别是此方法响应中断</span>
    sync<span class="token punctuation">.</span><span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>此方法<strong>响应中断</strong>, 当线程在阻塞中的时候, 若被中断, 会抛出 InterruptedException 异常 .</p> <blockquote><p>tryLock()</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 尝试加非公平锁</span>
    <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>tryLock 会尝试获取锁, 成功则直接返回 true, 不成功也不耽搁时间, 立即返回 false.</p> <blockquote><p>unlock()</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 释放锁</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>释放锁, 指定释放 1 个资源.</p> <blockquote><p>newCondition()</p></blockquote> <p>获取一个 <strong>conditon</strong>, ReentrantLock 支持多个 Condition.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>从上面这写方法的能大概梳理出 ReentrantLock 的处理逻辑, 其内部定义了三个重要的静态内部类: <strong>Sync, NonFairSync, FairSync</strong>. Sync 作为 ReentrantLock 中公用的同步组件, 继承了 AQS; <strong>NonFairSync 和 FairSync 则都继承 Sync, 调用 Sync 的公用逻辑, 然后再在各自内部完成自己特定的逻辑(公平或非公平)</strong> .</p> <p>所以接下来关于如何实现重入性, 如何实现公平性, 就得去看这几个静态内部类了.</p> <p>下面分为三部分分析:</p> <ul><li><strong>NonFairSync 非公平可重入锁申请锁资源的实现</strong></li> <li><strong>FairSync 公平锁申请锁资源的实现</strong></li> <li><strong>NonFairSync 与 FairSync 释放锁的实现(两者是一致的)</strong></li></ul> <p>对于公平锁与非公平锁, 两者申请锁资源的方式有区别, 所以下面单独介绍, 释放锁资源是一样的操作, 所以会整体介绍.</p> <h6 id="_3-nonfairsync非公平可重入锁的实现"><a href="#_3-nonfairsync非公平可重入锁的实现" class="header-anchor">#</a> (3)NonFairSync非公平可重入锁的实现</h6> <p>首先看看静态内部类 <strong>NonFairSync(非公平可重入锁)</strong> 的实现.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span>  <span class="token comment">// 继承Sync</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">7316153563782823691L</span><span class="token punctuation">;</span>
    <span class="token comment">/** 获取锁 */</span>
    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// CAS设置state状态, 若原值是0, 将其置为1</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  
            <span class="token comment">// 将当前线程标记为已持有锁</span>
            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token comment">// 若设置失败, 调用AQS的acquire方法, acquire又会调用下面重写的tryAcquire方法. </span>
            <span class="token comment">// 这里说的调用失败有两种情况: 1当前没有线程获取到资源, state为0, 但是将state由0设置为1的时候,</span>
            <span class="token comment">// 其他线程抢占资源, 将state修改了, 导致了CAS失败; 2 state原本就不为0, </span>
            <span class="token comment">// 也就是已经有线程获取到资源了, 有可能是别的线程获取到资源, 也有可能是当前线程获取的, </span>
            <span class="token comment">// 这时线程又重复去获取, 所以去tryAcquire中的nonfairTryAcquire应该就能看到可重入的实现逻辑了. </span>
            <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 调用Sync中的方法,可以参考前面的</span>
        <span class="token keyword">return</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p><strong>nonfairTryAcquire()</strong>  尝试加<strong>非公平锁</strong>, 其方法如下. 这个方法是在 Sync 中的, 由于 NonfairSync 继承了 Sync, 所以可以直接使用.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取当前线程</span>
    <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取当前state值</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 若state为0, 意味着没有线程获取到资源</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用CAS将state设置为1, 并将当前线程标记我获取到排他锁的线程, 返回true</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 若state不为0, 但是持有锁的线程是当前线程</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 重新根据传入的acquires计算state值</span>
        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>
        <span class="token comment">// int类型溢出了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> 
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 设置state, 此时state大于1, 代表着一个线程多次获锁, state的值即是线程重入的次数</span>
        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 返回true, 获取锁成功</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 获取锁失败</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>这里的获取锁时会先获取 state 的值(参考: state状态量), 如果为 0 则尝试用 CAS 的方式去获取锁, 获取成功后会更新 state 的值; 释放锁时也是类似的操作, 只不过会从 state 中减去对应的资源值.</p> <p>整个流程中还会有是否是<strong>独占线程</strong>的判断, 如果某个线程获取到资源, 则会将资源标记为此线程独占, 这样这个线程就可以通过<strong>重入锁</strong>的方式继续获取锁资源, 并且其他线程也不能释放对应的资源.</p> <p>总结下非公平锁的加锁流程:</p> <ol><li><strong>先获取 state 资源状态值, 若为 0, 意味着此时没有线程获取到资源, CAS 将其设置为 1, 设置成功则代表获取到排他锁了</strong>.</li> <li><strong>若 state 大于 0, 肯定有线程已经抢占到资源了, 此时再去判断是否就是自己抢占的, 是的话就 state 累加, 返回 true, 重入成功, state 的值即是线程重入的次数</strong>.</li> <li><strong>其他情况, 则获取锁失败</strong>.</li></ol> <h6 id="_4-fairsync公平锁的实现"><a href="#_4-fairsync公平锁的实现" class="header-anchor">#</a> (4)FairSync公平锁的实现</h6> <p><strong>FairSync</strong> 就是公平锁的实现. 获取锁的 <strong>lock</strong> 方法就一句话调用 AQS 的 <strong>acquire</strong> 方法. 这里如果获取锁失败, 就需要<strong>将当前线程加入到等待队列中</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">EXCLUSIVE</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>AQS 的 tryAcquire <strong>未做具体实现</strong>, 因为是否获取锁成功是由<strong>子类决定</strong>的, 这里直接来看 ReentrantLock 中 <strong>tryAcquire</strong> 的实现.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">FairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3000897897090466540L</span><span class="token punctuation">;</span>

    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 直接调用AQS的模板方法acquire, acquire会调用下面重写的这个tryAcquire方法</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取当前线程</span>
        <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取state值</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 若state为0, 意味着当前没有线程获取到资源, 那就可以直接获取资源了吗? </span>
        <span class="token comment">// NO!这不就跟之前的非公平锁的逻辑一样了嘛. 看下面的逻辑注意区别! ! ! </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 判断在时间顺序上, 是否有申请锁排在自己之前的线程, </span>
            <span class="token comment">// 若没有, 才能去获取, CAS设置state, 并标记当前线程为持有排他锁的线程; </span>
            <span class="token comment">// 反之, 不能获取! 这即是公平的处理方式. </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 获取锁成功 设置为当前线程独占</span>
                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 重入的处理逻辑, 与上文一致, 不再赘述</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p><strong>获取锁成功</strong>分为两种情况, 第一种情况是 if 判断 AQS 的 state 是否等于 0, 为 0 则表示锁<strong>没有人占有</strong>. 接着, hasQueuedPredecessors 判断等待队列中是否有排在前面的线程<strong>在等待锁</strong>, 没有的话调用 compareAndSetState 使用 <strong>CAS</strong> 的方式修改 state, 传入的 acquires 写死是 1. 最后线程获取锁成功, setExclusiveOwnerThread 将线程记录为独占锁的线程. 第二种情况是 state 不为 0, 也就是可重入的逻辑, 与非公平锁是一样的.</p> <p><strong>可以看到, 公平锁的大致逻辑与非公平锁是一致的, 不同的地方在于有了</strong> <mark><strong>!hasQueuedPredecessors()</strong></mark>  **这个判断逻辑, 其思想是即便 state 为 0, 也不能贸然直接去获取锁, 而是要先去看有没有比当前线程排在队列更前面的线程, 如果有, 则说明当前线程比其他线程后申请锁资源, 也就后加入到等待队列中. 为了公平, 只能让前面的线程先获取锁. **</p> <p>看看这个判断是否有排队中线程的逻辑.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span> <span class="token comment">// 尾结点</span>
    <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 头结点</span>
    <span class="token class-name">Node</span> s<span class="token punctuation">;</span>
    <span class="token comment">// 判断是否有排在自己之前的线程</span>
    <span class="token keyword">return</span> h <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h6 id="_5-释放锁"><a href="#_5-释放锁" class="header-anchor">#</a> (5)释放锁</h6> <p>前面分别介绍了公平锁与非公平锁的加锁的实现, 两者在加锁过程是有不同的. 对于释放锁资源, <strong>两者都是用的同一个方法, 即 tryRelease()</strong> . 这个方法定义在 <strong>Sync</strong> 中:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 减去指定数量的资源(当然由于传入的是1所以这里其实是减去1个资源)</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>

    <span class="token comment">// 当前线程是否是独占资源的线程 不是则报错</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 若state值为0, 表示当前线程已完全释放干净, 返回true, 上层的AQS会意识到资源已空出. </span>
    <span class="token comment">// 若不为0, 则表示线程还占有资源, 只不过将此次重入的资源的释放了而已, 返回false. </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> free<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>释放资源的流程就是减少 state 状态变量的值, 直到为 0 就算彻底释放锁.</p> <h6 id="_6-总结"><a href="#_6-总结" class="header-anchor">#</a> (6)总结</h6> <p>ReentrantLock 是一种可重入的, 可实现公平性的互斥锁, 它的设计基于 AQS 框架, 可重入和公平性的实现逻辑都不难理解. <strong>如果 state = 0 则表示锁资源没有被占用, state &gt; 0 表示锁被占用, 每重入一次, state 就加 1, 当然在释放的时候, 也得一层一层释放. 直到 state = 0 时彻底释放锁资源</strong>.</p> <p>至于公平性, 在尝试获取锁的时候多了一个判断: <strong>是否有比自己申请早的线程在同步队列中等待, 若有, 去等待; 若没有, 才允许去抢占</strong>. <strong>公平锁会关注队列里排队的情况, 老老实实按照 FIFO 的次序; 非公平锁只要有机会就抢占, 不管排队的事.</strong></p> <h4 id="condition"><a href="#condition" class="header-anchor">#</a> Condition</h4> <h5 id="_1-基础-3"><a href="#_1-基础-3" class="header-anchor">#</a> 1.基础</h5> <p>对于<strong>等待/通知</strong>机制, 简化而言, 就是等待一个条件, 当条件不满足时, 就进入<strong>等待</strong>, 等条件满足时, 就通知等待的线程开始执行. 为了实现这种功能, 需要进行 wait 的代码部分与需要进行通知的代码部分必须放在<strong>同一个对象监视器</strong>里面. 执行才能实现多个阻塞的线程同步执行代码, 等待与通知的线程也是同步进行. 对于 <strong>Object 类</strong>的 wait/notify 而言, 对象监视器与等待条件结合在一起, 即 &quot;synchronized(对象)&quot; 利用该对象去调用 wait 以及 notify. synchronized 就相当于整个锁对象中只有一个<strong>单一的</strong> Condition 对象, 所有的线程都注册在这个对象上. 当线程开始 notifyAll 时, 需要<strong>通知所有处于</strong> WAITING 状态的线程, 并不能定制选择需要唤醒的线程.</p> <p>Condition 是在 Java5 才出现的, 它用来<strong>替代</strong>传统的 <strong>Object 类</strong> 的 wait(), notify() 方法实现线程间的<strong>协作</strong>, 相比之下, 使用 Condition 的 <strong>await(), signal()</strong>  这种方式实现<strong>线程间协作更加安全和高效</strong>. 对于 Condition 类, 是对象监视器与条件分开, Lock 类来实现<strong>对象监视器</strong>, condition 对象来<strong>负责条件</strong>, 去调用 await 以及 signal. 相比于 synchronized 和 wait, notify 搭配进行线程协作, Condition 更灵活, 可以实现<strong>多路通知</strong>功能, 也就是在<strong>一个 Lock 对象</strong>里可以创建<strong>多个 Condition</strong>(即对象监视器)<strong>实例</strong>, 线程对象可以<strong>注册在指定的 Condition</strong> 中, 从而<strong>可以有选择的进行线程通知, 在调度线程上更加灵活</strong>.</p> <p><strong>Conditon 接口中的 await() 对应 Object 的 wait(), signal() 对应 Object 的 notify(), signalAll() 对应 Object 的 notifyAll().</strong></p> <p><mark><strong>线程对象可以注册在指定的 Condition 中, 从而可以有选择性的进行线程通知, 在调度线程上更加灵活. 在使用 Object 类的 notify()/notifyAll() 方法进行通知时, 被通知的线程是由 JVM 选择的, 用 ReentrantLock 类结合 Condition 实例可以实现 &quot;选择性通知&quot;</strong></mark> .</p> <h5 id="_2-使用示例"><a href="#_2-使用示例" class="header-anchor">#</a> 2.使用示例</h5> <p>Condition 对象是由 <strong>lock 对象</strong>所创建的, 且同一个锁可以<strong>创建多个 Condition</strong> 的对象, 即创建<strong>多个对象监视器</strong>, 这样的好处就是可以<strong>指定唤醒线程</strong>, 而 notify 唤醒的线程是随机唤醒一个. 生成一个 Condition 的基本代码是 <strong>lock.newCondition()</strong> .</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 获取锁对象</span>
<span class="token keyword">private</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 通过锁对象获取多个Condition对象</span>
<span class="token keyword">public</span> <span class="token class-name">Condition</span> conditionA <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">Condition</span> conditionB <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>调用 Condition 的 <strong>await()</strong>  和 <strong>signal()</strong>  方法, 都必须在 <strong>lock 保护范围之内使用</strong>, 也就是说<strong>必须</strong>在 <strong>lock.lock()</strong>  和 <strong>lock.unlock() 之间</strong>才可以使用.</p> <blockquote><p>官方demo</p></blockquote> <p>下面的代码出自 Condition 接口源码.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BoundedBuffer</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获得锁</span>
    <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 使用锁获得两个Condition</span>
    <span class="token keyword">final</span> <span class="token class-name">Condition</span> notFull  <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">final</span> <span class="token class-name">Condition</span> notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

    <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> putptr<span class="token punctuation">,</span> takeptr<span class="token punctuation">,</span> count<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Object</span> x<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 加锁</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 当计数器为100时wait</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// notFull等待</span>
                notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 将数据放入数组中</span>
            items<span class="token punctuation">[</span>putptr<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>putptr <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> putptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token comment">// 直到计数器为100</span>
            <span class="token operator">++</span>count<span class="token punctuation">;</span>
            <span class="token comment">// 唤醒notEmpty条件</span>
            notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 消费数据</span>
            <span class="token class-name">Object</span> x <span class="token operator">=</span> items<span class="token punctuation">[</span>takeptr<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>takeptr <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> takeptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token comment">// 直到计数器为0</span>
            count<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token comment">// 唤醒notFull条件</span>
            notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> x<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br></div></div><blockquote><p>两个Condition</p></blockquote> <p><strong>接下来使用 Condition 来实现等待/唤醒, 并且能够唤醒制定线程</strong>.</p> <p>先写业务代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">Condition</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">ReentrantLock</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span>
    <span class="token comment">// 实例化一个ReentrantLock对象</span>
    <span class="token keyword">private</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 为线程A注册一个ConditionA</span>
    <span class="token keyword">public</span> <span class="token class-name">Condition</span> conditionA <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 为线程B注册一个ConditionB</span>
    <span class="token keyword">public</span> <span class="token class-name">Condition</span> conditionB <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">awaitA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 加锁</span>
            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;进入了awaitA方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">long</span> timeBefore <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 执行conditionA等待</span>
            conditionA<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">long</span> timeAfter <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">&quot;被唤醒&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;等待了: &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>timeAfter <span class="token operator">-</span> timeBefore<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000</span><span class="token operator">+</span><span class="token string">&quot;s&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">awaitB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;进入了awaitB方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">long</span> timeBefore <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 执行conditionB等待</span>
            conditionB<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">long</span> timeAfter <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;被唤醒&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;等待了: &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>timeAfter <span class="token operator">-</span> timeBefore<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000</span> <span class="token operator">+</span> <span class="token string">&quot;s&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">signallA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;启动唤醒程序&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 唤醒所有注册conditionA的线程</span>
            conditionA<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">signallB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;启动唤醒程序&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 唤醒所有注册conditionB的线程</span>
            conditionB<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br></div></div><p>这里使用一个 lock 对象创建了两个 Condition 对象. <strong>注意 conditionA 对象的等待和唤醒只对使用了 conditionA 的线程有用, 同理 conditionB 对象的等待和唤醒只对使用了 conditionB 的线程有用</strong>. 对比 Object 的 notifyAll 方法则是<strong>全部唤醒</strong>. 这里 Condition 还是有优势的.</p> <p>继续写两个线程的代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyServiceThread1</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">MyService</span> service<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MyServiceThread1</span><span class="token punctuation">(</span><span class="token class-name">MyService</span> service<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>service <span class="token operator">=</span> service<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        service<span class="token punctuation">.</span><span class="token function">awaitA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>注意: MyServiceThread1 使用了 <strong>awaitA()</strong>  方法, <strong>注册</strong>的是 <strong>conditionA</strong>!</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyServiceThread2</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">MyService</span> service<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MyServiceThread2</span><span class="token punctuation">(</span><span class="token class-name">MyService</span> service<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>service <span class="token operator">=</span> service<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        service<span class="token punctuation">.</span><span class="token function">awaitB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>注意: MyServiceThread2 使用了 <strong>awaitB()</strong>  方法, <strong>注册</strong>的是 <strong>conditionB</strong>!</p> <p>最后看测试方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token class-name">MyService</span> service <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Runnable</span> runnable1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyServiceThread1</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Runnable</span> runnable2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyServiceThread2</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable1<span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable2<span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 线程sleep2秒钟</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 唤醒所有持有conditionA的线程</span>
    service<span class="token punctuation">.</span><span class="token function">signallA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 唤醒所有持有conditionB的线程</span>
    service<span class="token punctuation">.</span><span class="token function">sgnallB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>执行 ApplicationCondition, 来看控制台输出结果:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>a进入了awaitA方法
b进入了awaitB方法
启动唤醒程序
a被唤醒
a等待了: 2s
启动唤醒程序
b被唤醒
b等待了: 4s
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>a 和 b 都进入<strong>各自的 await() 方法</strong>. 首先执行的是</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 唤醒所有持有conditionA的线程</span>
service<span class="token punctuation">.</span><span class="token function">signallA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>使用 conditionA 的线程被<strong>唤醒</strong>, 而后再唤醒使用 conditionB 的线程.</p> <h5 id="_3-源码分析"><a href="#_3-源码分析" class="header-anchor">#</a> 3.源码分析</h5> <p>Condition 接口源码如下.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Condition</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">awaitUninterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token function">awaitNanos</span><span class="token punctuation">(</span><span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> <span class="token function">awaitUntil</span><span class="token punctuation">(</span><span class="token class-name">Date</span> deadline<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>主要就是 <strong>await 和 signal</strong> 方法. 下面看看源码, 先获取锁再获取 Condition.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ReentrantLock</span> reentrantLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Condition</span> a <span class="token operator">=</span> reentrantLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>ReentrantLock 的 newCondition() 方法如下.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可见调用的是内部静态类 <strong>Sync 的 newCondition</strong> 方法. 可见是直接返回了一个 <strong>ConditionObject</strong> 对象. <strong>ConditionObject</strong> <strong>实现了 Condition 接口</strong>, 是 AbstractQueuedSynchronizer 的内部类(具体接口方法参考 AQS 源码). Reentrantlock 的 newCondition 方法返回与某个 lock 锁对象相关联的 Condition 对象.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">ConditionObject</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConditionObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="synchronized与reentrantlock比较"><a href="#synchronized与reentrantlock比较" class="header-anchor">#</a> Synchronized与ReentrantLock比较</h4> <h5 id="_1-性能测试与使用选择"><a href="#_1-性能测试与使用选择" class="header-anchor">#</a> 1.性能测试与使用选择</h5> <p>以 synchronized 和 ReentrantLock 的性能对比为例, Brian Goetz 对这两种锁在 JDK 5, 单核处理器及双 Xeon 处理器环境下做了一组吞吐量对比的实验, 实验结果如图 13-1 和图 13-2 所示.</p> <p><img src="/img/Image00229-20240302133505-07iknxv.jpg" alt="" title="图13-1　JDK 5, 单核处理器下两种锁的吞吐量对比"></p> <p><img src="/img/Image00230-20240302133505-61j36aj.jpg" alt="" title="图13-2　JDK 5, 双 Xeon 处理器下两种锁的吞吐量对比"></p> <p>从图 13-1 和图 13-2 中可以看出, <strong>多线程环境下 synchronized 的吞吐量下降得非常严重</strong>, 而 ReentrantLock 则能基本保持在同一个相对稳定的水平上. 但与其说 ReentrantLock 性能好, 倒不如说当时的 synchronized 有非常大的优化余地, 后续的技术发展也证明了这一点. 当 JDK 6 中加入了大量针对 synchronized 锁的优化措施(下一节就会讲解这些优化措施)之后, 相同的测试中就发现 synchronized 与 ReentrantLock 的<strong>性能基本上能够持平</strong>. 相信现在阅读本书的读者所开发的程序应该都是使用 JDK 6 或以上版本来部署的, 所以<mark><strong>性能已经不再是选择 synchronized 或者 ReentrantLock 的决定因素</strong></mark>.</p> <p>根据上面的讨论, ReentrantLock 在功能上是 synchronized 的超集, 在性能上又至少不会弱于 synchronized, 那 synchronized 修饰符是否应该被直接抛弃, 不再使用了呢? 当然不是, 基于以下理由, 笔者仍然推荐在 synchronized 与 ReentrantLock 都可满足需要时优先使用 synchronized:</p> <ul><li><strong>synchronized 是在 Java 语法层面的同步, 足够清晰, 也足够简单</strong>. 每个 Java 程序员都熟悉 synchronized, 但 J.U.C 中的 Lock 接口则并非如此. 因此在只需要基础的同步功能时, 更推荐 synchronized.</li> <li><strong>Lock 应该确保在 finally 块中释放锁, 否则一旦受同步保护的代码块中抛出异常, 则有可能永远不会释放持有的锁</strong>. 这一点必须由程序员自己来保证, 而<strong>使用 synchronized 的话则可以由 Java 虚拟机来确保即使出现异常, 锁也能被自动释放</strong>.</li> <li>尽管在 JDK 5 时代 ReentrantLock 曾经在性能上领先过 synchronized, 但这已经是十多年之前的胜利了. 从长远来看, <strong>Java 虚拟机更容易针对 synchronized 来进行优化</strong>, 因为 Java 虚拟机可以在线程和对象的元数据中记录 synchronized 中锁的相关信息, 而使用 J.U.C 中的 Lock 的话, Java 虚拟机是很难得知具体哪些锁对象是由特定线程锁持有的.</li></ul> <p>因此, 除非需要使用 ReentrantLock 的高级功能, 否则<strong>优先使用 synchronized</strong>. 这是因为 synchronized 是 JVM 实现的一种锁机制, JVM 原生地支持它. 并且使用 synchronized 不用担心没有释放锁而导致死锁问题, 因为 JVM 会<strong>确保锁的释放.</strong></p> <p>如果需要用到 ReentrantLock 才具有的<strong>拓展功能</strong>(参考: 相比synchronized的拓展功能), 就可以考虑使用 ReentrantLock.</p> <h5 id="_2-特点对比"><a href="#_2-特点对比" class="header-anchor">#</a> 2.特点对比</h5> <blockquote><p>锁的实现</p></blockquote> <p>synchronized 是 <strong>JVM</strong> 实现的, 而 ReentrantLock 是 <strong>JDK</strong> 实现的, 两者都是可重入锁.</p> <p>synchronized 是 Java 原生的<strong>互斥同步锁</strong>, 使用方便, 对于 synchronized 修饰的方法或同步块, 无需再显式释放锁. synchronized 底层是通过 <strong>monitorenter 和 monitorexit</strong> 两个字节码指令来实现加锁解锁操作的(参考: synchronized原理解析).</p> <p>而 ReentrantLock 做为 <strong>API</strong> 层面的互斥锁, 需要<strong>显式地去加锁解锁</strong>, 在使用时需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成加锁. ReentrantLock 是基于 AQS 实现的.</p> <blockquote><p>性能</p></blockquote> <p>Java 对 synchronized 进行了很多<strong>优化</strong>(这些优化都是在虚拟机层面实现的), 例如自旋锁等. <strong>能用 synchronized 尽量用</strong>.</p> <h4 id="reentrantreadwritelock"><a href="#reentrantreadwritelock" class="header-anchor">#</a> ReentrantReadWriteLock</h4> <h5 id="_1-基础-4"><a href="#_1-基础-4" class="header-anchor">#</a> 1.基础</h5> <p>synchronized 和显式锁 ReentrantLock, 对于<strong>同一受保护对象</strong>的访问, 无论是<strong>读还是写</strong>, 都要求获得<strong>同样的锁</strong>. 这在一些场景中是不需要的, 多个线程的<strong>读</strong>操作完全可以并行, 在<strong>读多写少</strong>的场景中, 让读操作并行可以明显提高性能.</p> <p>使用读写锁 ReentrantReadWriteLock 可以让<strong>读操作并行</strong>, 又不影响一致性.</p> <p>ReentrantReadWriteLock 是 JCU 包中读写锁接口(<strong>ReadWriteLock</strong>) 的重要实现类, 主要实现<strong>读共享, 写互斥</strong>功能, 对比单纯的互斥锁在共享资源使用场景为<strong>频繁读取及少量修改</strong>的情况下可以较好的提高性能.</p> <p><strong>ReentrantReadWriteLock 表示两个锁, 一个是读操作相关的锁, 称为</strong>​<mark><strong>共享锁</strong></mark>​ <strong>; 一个是写相关的锁, 称为</strong>​<mark><strong>排他锁</strong></mark>. <strong>只有 &quot;读-读&quot; 操作是可以并行的, &quot;读-写&quot; 和 &quot;写-写&quot; 都不可以</strong>. 只有一个线程可以进行写操作, 在<strong>获取写锁</strong>时, 只有没有任何线程持有任何锁才可以获取到, 在持有<strong>写锁</strong>时, 其他任何线程都<strong>获取不到任何锁</strong>. 在没有其他线程持有写锁的情况下, <strong>多个</strong>线程可以获取和持有<strong>读锁</strong>.</p> <p><strong>读写锁</strong>有以下特性:</p> <p>(1)<strong>公平选择性</strong>: 支持非公平(默认)和公平的锁获取方式, 性能也是非公平优于公平.</p> <p>(2)<strong>可重入</strong>: ReentrantReadWriteLock 的读锁和写锁都是<strong>可重入</strong>的.</p> <p>(3)<strong>锁降级</strong>: 遵循获取写锁, 获取读锁再释放写锁的次序, <strong>写锁能够降级成为读锁</strong>.</p> <p>AQS 支持两种资源共享方式: <strong>独占式和共享式</strong>, 这样方便使用者实现不同类型的<strong>同步组件</strong>, <strong>独占式</strong>如 ReentrantLock, <strong>共享式</strong>如 Semaphore, CountDownLatch, <strong>组合式</strong>的如 ReentrantReadWriteLock. 这里的 ReentrantReadWriteLock 就是<strong>同时</strong>实现了独占式和共享式的锁.</p> <h5 id="_2-使用示例-2"><a href="#_2-使用示例-2" class="header-anchor">#</a> 2.使用示例</h5> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">RWDictionary</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Data</span><span class="token punctuation">&gt;</span></span> dataMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Data</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 定义读写锁</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantReadWriteLock</span> rwl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 从读写锁获取读锁与写锁</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> readLock <span class="token operator">=</span> rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> writeLock <span class="token operator">=</span> rwl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 读方法加读锁</span>
    <span class="token keyword">public</span> <span class="token class-name">Data</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        readLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> dataMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            readLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">allKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        readLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> dataMap<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            readLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 写方法加写锁</span>
    <span class="token keyword">public</span> <span class="token class-name">Data</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Data</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        writeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> dataMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            writeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 清空加写锁</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        writeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            dataMap<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            writeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><p>与普通重入锁使用的主要区别在于需要<strong>使用不同的锁对象引用读写锁, 并且在读写时分别调用对应的锁</strong>.</p> <h5 id="_3-readwritelock接口"><a href="#_3-readwritelock接口" class="header-anchor">#</a> 3.ReadWriteLock接口</h5> <p><strong>ReadWriteLock</strong> 接口只定义了两个方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ReadWriteLock</span> <span class="token punctuation">{</span>
    <span class="token comment">// 读锁</span>
    <span class="token class-name">Lock</span> <span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 写锁</span>
    <span class="token class-name">Lock</span> <span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>通过调用相应方法获取<strong>读锁或写锁</strong>, 获取的读锁及写锁都是 <strong>Lock 接口</strong>的实现, 可以如同使用 Lock 接口一样使用(其实也有一些特性是不支持的).</p> <h5 id="_4-源码分析"><a href="#_4-源码分析" class="header-anchor">#</a> 4.源码分析</h5> <p>读写锁算是一种组合形式的锁, 同时实现了 AQS 中的<strong>独占式和共享式</strong>的资源操作方式, 因此, AQS与模板方法模式 中涉及的目标方法基本都实现了. <strong>其写锁实现了 tryAcquire 和 tryRelease 方法, 读锁实现了 tryAcquireShared 和 tryReleaseShared 方法</strong>.</p> <h6 id="_1-基本结构"><a href="#_1-基本结构" class="header-anchor">#</a> (1)基本结构</h6> <p>ReentrantReadWriteLock 实现了 <strong>ReadWriteLock</strong> 接口, ReadWriteLock 接口定义了获取<strong>读锁和写锁的规范</strong>, 具体需要实现类去实现.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantReadWriteLock</span> <span class="token keyword">implements</span> <span class="token class-name">ReadWriteLock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span>
    <span class="token comment">/** 读锁 */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantReadWriteLock<span class="token punctuation">.</span>ReadLock</span> readerLock<span class="token punctuation">;</span>

    <span class="token comment">/** 写锁 */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantReadWriteLock<span class="token punctuation">.</span>WriteLock</span> writerLock<span class="token punctuation">;</span>

    <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync<span class="token punctuation">;</span>

    <span class="token comment">/** 使用默认(非公平)的排序属性创建一个新的 ReentrantReadWriteLock */</span>
    <span class="token keyword">public</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/** 使用给定的公平策略创建一个新的 ReentrantReadWriteLock */</span>
    <span class="token keyword">public</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 根据参数选择sync的公平与非公平实现</span>
        sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        readerLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReadLock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        writerLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WriteLock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/** 返回用于写入操作的锁 */</span>
    <span class="token keyword">public</span> <span class="token class-name">ReentrantReadWriteLock<span class="token punctuation">.</span>WriteLock</span> <span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> writerLock<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token comment">/** 返回用于读取操作的锁 */</span>
    <span class="token keyword">public</span> <span class="token class-name">ReentrantReadWriteLock<span class="token punctuation">.</span>ReadLock</span> <span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> readerLock<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token comment">// 这三个静态内部类在ReentrantLock中也有</span>
    <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">FairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 读写锁静态内部类</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ReadLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">WriteLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><h6 id="_2-内部类"><a href="#_2-内部类" class="header-anchor">#</a> (2)内部类</h6> <p>ReentrantReadWriteLock 有<strong>五个内部类</strong>, 五个内部类之间也是相互关联的. 内部类的关系如下图所示.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220603120131476.png" alt=""></p> <p>如上图所示, Sync 继承自 AQS, <strong>NonfairSync(非公平锁) 和 FairSync(公平锁) 都继承自 Sync 类</strong>, 可以通过构造函数传入的布尔值决定要<strong>构造哪一种 Sync 实例</strong>.</p> <p>ReadLock 和 WriteLock 都实现了 <strong>Lock</strong> 接口.</p> <blockquote><p>Sync类</p></blockquote> <p>类的继承关系:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>说明: Sync 抽象类继承自 <strong>AQS</strong>, Sync 类提供了对 ReentrantReadWriteLock 的支持. 注意这里的 Sync 类是 ReentrantReadWriteLock 自己实现的, 与 ReentrantLock 中 Sync 类是不一样的.</p> <p>Sync 类的属性如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>
    <span class="token comment">// 版本序列号</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">6317671515068378041L</span><span class="token punctuation">;</span>  
    <span class="token comment">// 高16位为读锁, 低16位为写锁</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SHARED_SHIFT</span>   <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>
    <span class="token comment">// 读锁单位</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SHARED_UNIT</span>    <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">SHARED_SHIFT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 读锁最大数量</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_COUNT</span>      <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">SHARED_SHIFT</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 写锁最大数量</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">EXCLUSIVE_MASK</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">SHARED_SHIFT</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 本地线程计数器!!!</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">ThreadLocalHoldCounter</span> readHolds<span class="token punctuation">;</span>
    <span class="token comment">// 缓存的计数器!!!</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HoldCounter</span> cachedHoldCounter<span class="token punctuation">;</span>
    <span class="token comment">// 第一个读线程</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Thread</span> firstReader <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 第一个读线程的计数</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> firstReaderHoldCount<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>其中包括了读锁, 写锁线程的<strong>最大量</strong>. <strong>本地线程计数器</strong>等.</p> <p>Sync 类的构造方法如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 构造函数</span>
<span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 初始化本地线程计数器</span>
    readHolds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalHoldCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置AQS的状态</span>
    <span class="token function">setState</span><span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ensures visibility of readHolds</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在构造方法中<strong>设置了本地线程计数器和 AQS 的状态 state</strong>.</p> <blockquote><p>HoldCounter源码</p></blockquote> <p>Sync 类内部存在两个内部类, 分别为 HoldCounter 和 <strong>ThreadLocalHoldCounter</strong>, 其中 HoldCounter 主要与<strong>读锁配套</strong>使用.</p> <p><strong>HoldCounter 源码如下</strong>. HoldCounter 的作用就是<strong>保存当前线程持有共享锁的数量</strong>, 这个数量必须要与线程绑定在一起, 否则操作其他线程锁就会抛出异常.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 计数器</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HoldCounter</span> <span class="token punctuation">{</span>
    <span class="token comment">// 计数</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// Use id, not reference, to avoid garbage retention</span>
    <span class="token comment">// 获取当前线程的TID属性的值</span>
    <span class="token keyword">final</span> <span class="token keyword">long</span> tid <span class="token operator">=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>说明: HoldCounter 主要有两个属性, count 和 tid, 其中 count 表示某个<strong>读线程重入的次数</strong>, tid 表示该线程的 tid 字段的值, 该字段可以用来<strong>唯一标识一个线程</strong>.</p> <blockquote><p>ThreadLocalHoldCounter源码</p></blockquote> <p>ThreadLocalHoldCounter 的源码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 本地线程计数器</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalHoldCounter</span>
    <span class="token keyword">extends</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HoldCounter</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 重写初始化方法, 在没有进行set的情况下, 获取的都是该HoldCounter值</span>
    <span class="token keyword">public</span> <span class="token class-name">HoldCounter</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HoldCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>ThreadLocalHoldCounter 重写了 <strong>ThreadLocal</strong> 的 <strong>initialValue</strong> 方法, ThreadLocal 类可以将<strong>线程与对象</strong>相关联. 在没有进行 set 的情况下, get 到的均是 initialValue 方法里面生成的那个 <strong>HolderCounter</strong> 对象.</p> <p>由于读锁是可以多个线程共享的, 每个线程拥有自己的副本, 用来保存自己的<strong>重入数</strong>.</p> <h6 id="_3-读写状态设计"><a href="#_3-读写状态设计" class="header-anchor">#</a> (3)读写状态设计</h6> <p>ReentrantReadWriteLock 继承了 AQS, 所以也使用 state 变量来同时表示读写锁资源, 参考: AQS state状态量.</p> <p>假设当前同步状态值为 S, 对于读写状态的操作如下:</p> <ul><li>获取写状态: <code>S &amp; 0x0000FFFF</code>​: 将高 16 位全部抹去.</li> <li>获取读状态: <code>S&gt;&gt;&gt;16</code>​: 无符号补 0, 右移 16 位.</li> <li>写状态加 1: <code>S+1</code>​.</li> <li>读状态加 1: <code>S+(1&lt;&lt;16)</code>​ 即 <code>S + 0x00010000</code>​.</li></ul> <p>在代码层的判断中, 如果 S 不等于 0, 当写状态 (<code>S &amp; 0x0000FFFF</code>​), 而读状态(<code>S &gt;&gt;&gt; 16</code>​)大于 0 时, 则表示该读写锁的读锁已被获取.</p> <h6 id="_4-写锁的获取与释放"><a href="#_4-写锁的获取与释放" class="header-anchor">#</a> (4)写锁的获取与释放</h6> <p>看下 <strong>WriteLock</strong> 类中的 lock 和 unlock 方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>可以看到写锁的获取与释放就是<strong>调用的独占式锁的获取与释放</strong>, 因此真实的实现就是 Sync 的 <strong>tryAcquire</strong> 和 <strong>tryRelease</strong>.</p> <p><strong>写锁的获取, 看下 tryAcquire</strong>:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当前线程</span>
    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取状态变量值</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 写线程数量(即获取独占锁的重入数)</span>
    <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 当前同步状态state != 0, 说明已经有其他线程获取了读锁或者写锁</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当前state不为0, 此时: 如果写锁状态为0说明读锁此时被占用返回false; </span>
        <span class="token comment">// 如果写锁状态不为0且写锁没有被当前线程持有返回false</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> current <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token comment">// 判断同一线程获取写锁是否超过最大次数(65535), 支持可重入</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">+</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token constant">MAX_COUNT</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 更新状态</span>
        <span class="token comment">// 此时当前线程已持有写锁, 现在是重入, 所以只需要修改锁的数量即可. </span>
        <span class="token function">setState</span><span class="token punctuation">(</span>c <span class="token operator">+</span> acquires<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 到这里说明此时c=0,读锁和写锁都没有被获取</span>
    <span class="token comment">// writerShouldBlock表示是否阻塞</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 设置锁为当前线程所有</span>
    <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>其中 <strong>exclusiveCount</strong> 方法表示<strong>占有写锁的线程数量</strong>, 源码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token constant">EXCLUSIVE_MASK</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>说明: 直接将状态 state 和 <code>(2^16 - 1)</code>​ 做<strong>与运算</strong>, 其等效于将 state 模上 2^16. 这是因为写锁数量由 state 的<strong>低十六位</strong>表示.</p> <p>从源代码可以看出, 获取写锁的步骤如下:</p> <p>(1)首先获取 c, w. c 表示<strong>当前锁</strong>状态; w 表示<strong>写线程数量</strong>. 然后判断同步状态 state 是否为 0. 如果 <code>state != 0</code>​, 说明<strong>已经有其他线程获取</strong>了读锁或写锁.</p> <p>(2)如果锁状态不为零(<code>c != 0</code>​), 而写锁的状态为 0(<code>w = 0</code>​), 说明<strong>读锁此时被其他线程占用</strong>, 所以当前线程<strong>不能获取写锁</strong>, 自然返回 false. 或者锁状态不为零, 而写锁的状态也不为 0, 但是获取写锁的线程不是当前线程, 则当前线程也不能获取写锁.</p> <p>(3)判断当前线程获取写锁是否超过<strong>最大次数</strong>, 若超过, 抛异常, 反之更新同步状态(此时当前线程已获取写锁, 更新是线程安全的), 返回 true.</p> <p>(4)如果 state 为 0, 此时<strong>读锁或写锁都没有被获取</strong>, 判断是否需要阻塞(公平和非公平方式实现不同), 在非公平策略下总是不会被阻塞, 在公平策略下会进行判断(判断同步队列中是否有等待时间更长的线程, 若存在, 则需要被阻塞, 否则, 无需阻塞), 如果不需要阻塞, 则 CAS 更新同步状态, 若 CAS 成功则返回 true, 失败则说明锁被别的线程抢去了, 返回 false. 如果需要阻塞则也返回 false.</p> <p>(5)成功获取写锁后, 将当前线程设置为<strong>占有写锁</strong>的线程, 返回 true.</p> <p>方法流程图如下:</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200511100816783-4229382.png" alt=""></p> <p>**写锁的释放, tryRelease() 方法: **</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 若锁的持有者不是当前线程, 抛出异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 计算释放资源后的state值</span>
    <span class="token keyword">int</span> nextc <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>
    <span class="token comment">// 如果独占模式重入数为0了, 说明独占模式被释放</span>
    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>free<span class="token punctuation">)</span>
        <span class="token comment">// 若写锁的新线程数为0, 则将锁的持有者设置为null</span>
        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置写锁的新线程数</span>
    <span class="token comment">// 不管独占模式是否被释放, 更新独占重入数</span>
    <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> free<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>写锁释放过程比较简单: 首先查看当前线程<strong>是否为写锁的持有者</strong>, 如果不是抛出异常. 然后检查释放后写锁的线程数是否为 0, 如果为 0 则表示<strong>写锁空闲</strong>了, 释放锁资源将<strong>锁的持有线程</strong>设置为 null, 否则释放仅仅只是一次重入锁而已, 并不能将写锁的线程清空.<span data-type="text" style="font-family:var(--b3-font-family-protyle);background-color:var(--b3-theme-background);">方法流程图如下.</span></p> <h6 id="_5-读锁的获取与释放"><a href="#_5-读锁的获取与释放" class="header-anchor">#</a> (5)读锁的获取与释放</h6> <p>类似于写锁, 读锁的 lock 和 unlock 的实际实现对应 Sync 的 <strong>tryAcquireShared 和 tryReleaseShared</strong> 方法, 这两个都是 AQS 中需要子类实现的模板方法(参考: AQS与模板方法模式).</p> <p><strong>读锁的获取, 看下 tryAcquireShared() 方法</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取当前线程</span>
    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取状态值</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果写锁线程数 != 0 , 且独占锁不是当前线程则返回失败, 因为存在锁降级</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> current<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取读锁数量</span>
    <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">sharedCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/*
     * readerShouldBlock():读锁是否需要等待(公平锁原则)
     * r &lt; MAX_COUNT: 持有线程小于最大数(65535)
     * compareAndSetState(c, c + SHARED_UNIT): 设置读取锁状态
     */</span>
    <span class="token comment">// 读线程是否应该被阻塞, 并且小于最大值, 并且比较设置成功</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> r <span class="token operator">&lt;</span> <span class="token constant">MAX_COUNT</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> <span class="token constant">SHARED_UNIT</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// r &lt;mark&gt; 0, 表示第一个读锁线程, 第一个读锁firstRead是不会加入到readHolds中</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 读锁数量为0</span>
            <span class="token comment">// 设置第一个读线程</span>
            firstReader <span class="token operator">=</span> current<span class="token punctuation">;</span>
            <span class="token comment">// 读线程占用的资源数为1</span>
            firstReaderHoldCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 当前线程为第一个读线程, 表示第一个读锁线程重入</span>
            <span class="token comment">// 占用资源数加1</span>
            firstReaderHoldCount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 读锁数量不为0并且不为当前线程</span>
            <span class="token comment">// 获取计数器</span>
            <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>
            <span class="token comment">// 计数器为空或者计数器的tid不为当前正在运行的线程的tid</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> 
                <span class="token comment">// 获取当前线程对应的计数器</span>
                cachedHoldCounter <span class="token operator">=</span> rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 计数为0</span>
                <span class="token comment">// 加入到readHolds中</span>
                readHolds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 计数+1</span>
            rh<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">fullTryAcquireShared</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><p>其中 sharedCount 方法表示<strong>占有读锁的线程数量</strong>, 源码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sharedCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">return</span> c <span class="token operator">&gt;&gt;&gt;</span> <span class="token constant">SHARED_SHIFT</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>因为 state 的高 16 位表示读锁, 对应的<strong>低十六位表示写锁数量</strong>. 这里直接将 <strong>state 右移 16 位</strong>, 就可以得到读锁的<strong>线程数量</strong>.</p> <p>读锁获取锁的过程比写锁稍微复杂些, 首先判断<strong>写锁是否为 0</strong> 并且当前线程不占有独占锁, 直接返回; 否则, 判断读线程是否需要被阻塞并且读锁数量是否小于最大值并且比较设置状态成功, 若当前<strong>没有读锁</strong>, 则设置第一个读线程 firstReader 和 firstReaderHoldCount; 若当前线程线程为第一个读线程, 则增加 <strong>firstReaderHoldCount</strong>; 否则, 将设置当前线程对应的 <strong>HoldCounter</strong> 对象的值.</p> <p>注意: 更新成功后会在 firstReaderHoldCount 中或 readHolds (ThreadLocal类型的)的本线程副本中<strong>记录当前线程重入数</strong>, 这是为了实现 JDK6 中加入的 getReadHoldCount() 方法的, 这个方法能获取当前线程重入共享锁的次数(state 中记录的是多<strong>个线程的总重入次数</strong>), 加入了这个方法让代码复杂了不少, 但是其原理还是很简单的: 如果当前只有一个线程的话, 还不需要动用 ThreadLocal, 直接往 firstReaderHoldCount 这个成员变量里存重入数, 当有第二个线程来的时候, <strong>就要动用 ThreadLocal 变量 readHolds 了, 每个线程拥有自己的副本, 用来保存自己的重入数</strong>.</p> <p>fullTryAcquireShared() 方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">fullTryAcquireShared</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 无限循环</span>
        <span class="token comment">// 获取状态</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 写线程数量不为0</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> current<span class="token punctuation">)</span> <span class="token comment">// 不为当前线程</span>
                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 写线程数量为0并且读线程被阻塞</span>
            <span class="token comment">// Make sure we're not acquiring read lock reentrantly</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 当前线程为第一个读线程</span>
                <span class="token comment">// assert firstReaderHoldCount &gt; 0;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 当前线程不为第一个读线程</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 计数器不为空</span>
                    <span class="token comment">// </span>
                    rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 计数器为空或者计数器的tid不为当前正在运行的线程的tid</span>
                        rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token number">0</span><span class="token punctuation">)</span>
                            readHolds<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sharedCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token constant">MAX_COUNT</span><span class="token punctuation">)</span> <span class="token comment">// 读锁数量为最大值, 抛出异常</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> <span class="token constant">SHARED_UNIT</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 比较并且设置成功</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sharedCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 读线程数量为0</span>
                <span class="token comment">// 设置第一个读线程</span>
                firstReader <span class="token operator">=</span> current<span class="token punctuation">;</span>
                <span class="token comment">// </span>
                firstReaderHoldCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                firstReaderHoldCount<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    readHolds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span>
                rh<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
                cachedHoldCounter <span class="token operator">=</span> rh<span class="token punctuation">;</span> <span class="token comment">// cache for release</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br></div></div><p>在 tryAcquireShared 方法中, 如果下列三个条件不满足(读线程是否应该被阻塞, 小于最大值, 比较设置成功)则会进入 fullTryAcquireShared 方法, 它用来保证相关操作可以成功. 其逻辑与 tryAcquireShared 逻辑类似, 不再累赘.</p> <p><strong>读锁的释放, tryReleaseShared() 方法</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取当前线程</span>
    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 当前线程为第一个读线程</span>
        <span class="token comment">// assert firstReaderHoldCount &gt; 0;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReaderHoldCount <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 读线程占用的资源数为1</span>
            firstReader <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token comment">// 减少占用的资源</span>
            firstReaderHoldCount<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 当前线程不为第一个读线程</span>
        <span class="token comment">// 获取缓存的计数器</span>
        <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 计数器为空或者计数器的tid不为当前正在运行的线程的tid</span>
            <span class="token comment">// 获取当前线程对应的计数器</span>
            rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取计数</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> rh<span class="token punctuation">.</span>count<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 计数小于等于1</span>
            <span class="token comment">// 移除</span>
            readHolds<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 计数小于等于0, 抛出异常</span>
                <span class="token keyword">throw</span> <span class="token function">unmatchedUnlockException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 减少计数</span>
        <span class="token operator">--</span>rh<span class="token punctuation">.</span>count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 无限循环</span>
        <span class="token comment">// 获取状态</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取状态</span>
        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token constant">SHARED_UNIT</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 比较并进行设置</span>
            <span class="token comment">// Releasing the read lock has no effect on readers,</span>
            <span class="token comment">// but it may allow waiting writers to proceed if</span>
            <span class="token comment">// both read and write locks are now free.</span>
            <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p>此方法表示<strong>读锁线程释放锁</strong>. 首先判断当前线程是否为第一个读线程 firstReader, 若是则判断第一个读线程占有的资源数 firstReaderHoldCount 是否为 1(表示没有重入), 若是则设置第一个读线程 firstReader 为空, 否则, 将第一个读线程占有的资源数 firstReaderHoldCount 减 1; 若当前线程不是第一个读线程, 那么首先会获取缓存计数器(上一个读锁线程对应的计数器 ), 若计数器为空或者 tid 不等于当前线程的 tid 值, 则<strong>获取当前线程的计数器</strong>, 如果计数器的计数 count 小于等于 1, 则移除当前线程对应的计数器, 如果计数器的计数 count 小于等于0, 则抛出异常, 之后再减少计数即可. 无论何种情况, 都会进入无限循环, 该循环可以确保成功设置状态 state.</p> <p>在读锁的获取, 释放过程中, 总是会有一个对象存在着, 同时该对象在获取线程获取<strong>读锁是 +1, 释放读锁时 -1</strong>, 该对象就是 <strong>HoldCounter</strong>.</p> <p>要明白 HoldCounter 就要先明白读锁. 前面提<strong>过读锁的内在实现机制就是共享锁</strong>, 对于<strong>共享锁</strong>其实可以稍微的认为它不是一个锁的概念, 它更加像<strong>一个计数器</strong>的概念. 一次共享锁操作就相当于一次计数器的操作, <strong>获取共享锁计数器 +1, 释放共享锁计数器 -1</strong>. 只有当线程获取共享锁后才能对共享锁进行释放和重入操作. 所以 <strong>HoldCounter</strong> 的作用就是<strong>保存当前线程持有共享锁的数量</strong>, 这个数量必须要<strong>与线程绑定在一起</strong>, 否则操作其他线程锁就会抛出异常.</p> <p>先看读锁获取锁的部分:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// r &lt;/mark&gt; 0, 表示第一个读锁线程, 第一个读锁firstRead是不会加入到readHolds中</span>
    firstReader <span class="token operator">=</span> current<span class="token punctuation">;</span>
    firstReaderHoldCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 第一个读锁线程重入</span>
    firstReaderHoldCount<span class="token operator">++</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment">// 非firstReader计数</span>
    <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span><span class="token comment">// readHoldCounter缓存</span>
    <span class="token comment">// rh == null 或者 rh.tid != current.getId(), 需要获取rh</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> current<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  
        cachedHoldCounter <span class="token operator">=</span> rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        readHolds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 加入到readHolds中</span>
    rh<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 计数+1</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>这里为什么要搞一个 firstRead, firstReaderHoldCount 呢? 而不是直接使用 else 那段代码? 这是为了一个效率问题, firstReader 是不会放入到 readHolds 中的, 如果读锁仅有一个的情况下就会避免查找 readHolds. 可能就看这个代码还不是很理解 HoldCounter. 先看 firstReader, firstReaderHoldCount 的定义:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Thread</span> firstReader <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> firstReaderHoldCount<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这两个变量比较简单, 一个表示<strong>线程</strong>, 当然该线程是一个特殊的线程, 一个是 firstReader 的<strong>重入计数</strong>.</p> <p>HoldCounter 的定义:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HoldCounter</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">long</span> tid <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在 HoldCounter 中仅有 count 和 tid 两个变量, 其中 count 代表着<strong>计数器</strong>, tid 是线程的 id. 但是如果要将一个对象和线程绑定起来仅记录 tid 肯定不够的, 而且 HoldCounter 根本不能起到绑定对象的作用, 只是记录线程 tid 而已.</p> <p>如果要将<strong>一个线程和对象绑定在一起</strong>可以通过 <strong>ThreadLocal</strong> 实现. 所以如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalHoldCounter</span> <span class="token keyword">extends</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HoldCounter</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">HoldCounter</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HoldCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>ThreadLocalHoldCounter 继承了 <strong>ThreadLocal</strong>, 并且重写了 <strong>initialValue</strong> 方法.</p> <p>故而, HoldCounter 应该就是<strong>绑定线程上的一个计数器</strong>, 而 ThradLocalHoldCounter 则是线程绑定的 ThreadLocal. 从上面可以看到 ThreadLocal 将 HoldCounter 绑定到<strong>当前线程</strong>上, 同时 HoldCounter 也持有线程 Id, 这样在<strong>释放锁</strong>的时候才能知道 ReadWriteLock 里面缓存的<strong>上一个读取线程</strong>(cachedHoldCounter)<strong>是否是当前线程</strong>. 这样做的好处是可以减少 ThreadLocal.get() 的次数, 因为这也是一个耗时操作. 需要说明的是这样 HoldCounter 绑定线程 id 而不绑定线程对象的原因是避免 HoldCounter 和 ThreadLocal 互相绑定而 GC 难以释放它们(尽管 GC 能够智能的发现这种引用而回收它们, 但是这需要一定的代价), 所以其实这样做只是为了帮助 GC 快速回收对象而已.</p> <h6 id="_6-读写锁的升降级"><a href="#_6-读写锁的升降级" class="header-anchor">#</a> (6)读写锁的升降级</h6> <p>在线程持有<strong>读锁</strong>的情况下, 该线程<strong>不能取得写锁</strong>(因为获取写锁的时候, 如果发现当前的读锁被占用, 就马上获取失败, 不管读锁是不是被当前线程持有).</p> <p>在线程持有<strong>写锁</strong>的情况下, 该线程<strong>可以继续获取读锁</strong>(获取读锁时如果发现写锁被占用, 只有写锁没有被当前线程占用的情况才会获取失败).</p> <p>仔细想想, 这个设计是合理的: 因为当线程获取读锁的时候, 可能有其他线程<strong>同时也在持有读锁</strong>, 因此不能把获取读锁的线程 &quot;升级&quot; 为写锁; 而对于<strong>获得写锁</strong>的线程, 它<strong>一定独占了读写锁</strong>, 因此<strong>可以继续让它获取读锁</strong>, 当它同时获取了写锁和读锁后, 还可以先释放写锁继续持有读锁, 这样一个<strong>写锁就 &quot;降级&quot; 为了读锁</strong>.</p> <p>综上: <strong>一个线程要想同时持有写锁和读锁, 必须先获取写锁再获取读锁; 写锁可以 &quot;降级&quot; 为读锁; 读锁不能 &quot;升级&quot; 为写锁.</strong></p> <p>‍</p> <p>‍</p> <p>‍</p> <h4 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h4> <ul><li>[1] : <a href="https://www.cnblogs.com/xiaoxi/p/7651360.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/xiaoxi/p/7651360.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> Condition 详解</li> <li>[2] : <a href="https://www.cnblogs.com/xiaoxi/p/9140541.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/xiaoxi/p/9140541.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> &quot;ReentrantReadWriteLock 源码详解&quot;</li> <li></li> <li></li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/20.开发/2000.Java/300.并发/305.显式锁ReentrantLock.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/c43494/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">AQS</div></a> <a href="/pages/eb8cbc/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">线程协作与JUC组件</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/c43494/" class="prev">AQS</a></span> <span class="next"><a href="/pages/eb8cbc/">线程协作与JUC组件</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/62.1213823d.js" defer></script>
  </body>
</html>
