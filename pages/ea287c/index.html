<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>虚拟机类加载机制🌼 | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/83.771cced1.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/4f30b9/" class="sidebar-link">Java基础</a></li><li><a href="/pages/795eca/" class="sidebar-link">类与继承</a></li><li><a href="/pages/c69152/" class="sidebar-link">抽象类与接口</a></li><li><a href="/pages/d71abb/" class="sidebar-link">内部类</a></li><li><a href="/pages/f06dca/" class="sidebar-link">枚举类</a></li><li><a href="/pages/259f57/" class="sidebar-link">常用类</a></li><li><a href="/pages/84b03b/" class="sidebar-link">关键字</a></li><li><a href="/pages/31b87b/" class="sidebar-link">注解</a></li><li><a href="/pages/f81c0d/" class="sidebar-link">异常</a></li><li><a href="/pages/ae7746/" class="sidebar-link">泛型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>容器类</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/0c88ac/" class="sidebar-link">集合容器类基础</a></li><li><a href="/pages/f805ed/" class="sidebar-link">List与Queue类</a></li><li><a href="/pages/d24b60/" class="sidebar-link">Map与Set类</a></li><li><a href="/pages/54e5d3/" class="sidebar-link">并发容器类</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/67d70f/" class="sidebar-link">多线程基础</a></li><li><a href="/pages/ffc8f7/" class="sidebar-link">Java内置锁</a></li><li><a href="/pages/c43494/" class="sidebar-link">AQS</a></li><li><a href="/pages/eb5b61/" class="sidebar-link">显式锁ReentrantLock</a></li><li><a href="/pages/eb8cbc/" class="sidebar-link">线程协作与JUC组件</a></li><li><a href="/pages/23c79a/" class="sidebar-link">Atomic原子变量与Unsafe类与CAS</a></li><li><a href="/pages/9d6ed4/" class="sidebar-link">线程池与定时任务</a></li><li><a href="/pages/5b787a/" class="sidebar-link">ThreadLocal</a></li><li><a href="/pages/db53d1/" class="sidebar-link">Java并发编程实战(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>IO</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b4d461/" class="sidebar-link">文件操作</a></li><li><a href="/pages/1b9d6c/" class="sidebar-link">IO流操作</a></li><li><a href="/pages/076a47/" class="sidebar-link">Java网络IO模型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>高级特性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d76905/" class="sidebar-link">Lambda表达式</a></li><li><a href="/pages/f7f0e6/" class="sidebar-link">流Stream</a></li><li><a href="/pages/7cc40a/" class="sidebar-link">反射</a></li><li><a href="/pages/945326/" class="sidebar-link">代理</a></li><li><a href="/pages/7fd9b4/" class="sidebar-link">Javaagent</a></li><li><a href="/pages/a3cee0/" class="sidebar-link">Guava</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>JVM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d308f6/" class="sidebar-link">走进JVM🌼</a></li><li><a href="/pages/be0269/" class="sidebar-link">JVM内存区域与对象解析🌼</a></li><li><a href="/pages/48d1be/" class="sidebar-link">垃圾收集器与内存分配策略🌼</a></li><li><a href="/pages/3a4c8a/" class="sidebar-link">JVM性能监控与故障处理工具🌼</a></li><li><a href="/pages/106680/" class="sidebar-link">调优案例分析与实战🌼</a></li><li><a href="/pages/16a914/" class="sidebar-link">类文件结构🌼</a></li><li><a href="/pages/ea287c/" aria-current="page" class="active sidebar-link">虚拟机类加载机制🌼</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/6367b0/" class="sidebar-link">虚拟机字节码执行引擎🌼</a></li><li><a href="/pages/c6c210/" class="sidebar-link">类加载及执行子系统的案例与实战🌼</a></li><li><a href="/pages/deb8b7/" class="sidebar-link">前端编译与优化🌼</a></li><li><a href="/pages/1f8f72/" class="sidebar-link">后端编译与优化🌼</a></li><li><a href="/pages/3d72db/" class="sidebar-link">Java内存模型与线程实现🌼</a></li><li><a href="/pages/ed086e/" class="sidebar-link">线程安全与内置锁优化🌼</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/56b9dd/" class="sidebar-link">Java性能问题定位分析</a></li><li><a href="/pages/939bf8/" class="sidebar-link">杂记</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>开发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>软件设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/a5f6fe/" class="sidebar-link">设计基础理论</a></li><li><a href="/pages/3b245c/" class="sidebar-link">设计模式之美(极客时间)🌟</a></li><li><a href="/pages/661fa4/" class="sidebar-link">领域驱动设计(DDD)</a></li><li><a href="/pages/856368/" class="sidebar-link">DDD实战课(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d3fbd2/" class="sidebar-link">数据库基础</a></li><li><a href="/pages/691fc3/" class="sidebar-link">数据库系统原理</a></li><li><a href="/pages/50f6b7/" class="sidebar-link">MySQL基础必知必会</a></li><li><a href="/pages/fe297e/" class="sidebar-link">MySQL特性</a></li><li><a href="/pages/07bdb6/" class="sidebar-link">MySQL索引🌟</a></li><li><a href="/pages/984715/" class="sidebar-link">MySQL锁🌟</a></li><li><a href="/pages/53b588/" class="sidebar-link">MySQL事务🌟</a></li><li><a href="/pages/becc59/" class="sidebar-link">MySQL高级特性</a></li><li><a href="/pages/056463/" class="sidebar-link">MySQL基础架构与存储引擎🌟</a></li><li><a href="/pages/63b46e/" class="sidebar-link">MySQL架构优化与运维</a></li><li><a href="/pages/9995e5/" class="sidebar-link">MySQL优化</a></li><li><a href="/pages/c1c2f6/" class="sidebar-link">MySQL架构</a></li><li><a href="/pages/8e8e0a/" class="sidebar-link">MySQL设计规范</a></li><li><a href="/pages/0219aa/" class="sidebar-link">MySQL运维</a></li><li><a href="/pages/e288c0/" class="sidebar-link">MySQL中间件</a></li><li><a href="/pages/c6cafa/" class="sidebar-link">MySQL实战45讲(极客时间)🌟</a></li><li><a href="/pages/4a6106/" class="sidebar-link">数据库LeetCode题目</a></li><li><a href="/pages/2827f1/" class="sidebar-link">数据库综合问题</a></li><li><a href="/pages/c616d5/" class="sidebar-link">MongoDB</a></li><li><a href="/pages/075e71/" class="sidebar-link">ClickHouse</a></li><li><a href="/pages/d74f6d/" class="sidebar-link">Doris</a></li><li><a href="/pages/b6bad9/" class="sidebar-link">HBase</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Spring</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bd8eb8/" class="sidebar-link">Spring Boot基础</a></li><li><a href="/pages/d0d797/" class="sidebar-link">Spring Boot应用整合</a></li><li><a href="/pages/314cdc/" class="sidebar-link">Spring MVC基础</a></li><li><a href="/pages/80de47/" class="sidebar-link">Spring AOP基础</a></li><li><a href="/pages/f0d4d6/" class="sidebar-link">Spring事务基础</a></li><li><a href="/pages/db6afe/" class="sidebar-link">Spring IOC源码分析-概览</a></li><li><a href="/pages/672e98/" class="sidebar-link">Spring IOC源码分析-getBean()</a></li><li><a href="/pages/695b90/" class="sidebar-link">Spring IOC源码分析-createBean()</a></li><li><a href="/pages/f89bcf/" class="sidebar-link">Spring AOP源码分析</a></li><li><a href="/pages/3b52f4/" class="sidebar-link">Spring事务源码分析</a></li><li><a href="/pages/186902/" class="sidebar-link">Spring Boot源码分析</a></li><li><a href="/pages/16bd1c/" class="sidebar-link">Spring MVC源码分析</a></li><li><a href="/pages/3d0c1f/" class="sidebar-link">Spring Cloud</a></li><li><a href="/pages/d56156/" class="sidebar-link">Spring编程常见错误50例(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>MyBatis</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bb032d/" class="sidebar-link">基础</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>工具与环境</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c9cb6e/" class="sidebar-link">Arthas</a></li><li><a href="/pages/3172bb/" class="sidebar-link">Maven</a></li><li><a href="/pages/37f79a/" class="sidebar-link">Git</a></li><li><a href="/pages/db9f99/" class="sidebar-link">环境搭建与部署</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c725f5/" class="sidebar-link">测试基础</a></li><li><a href="/pages/7893a4/" class="sidebar-link">单元测试</a></li><li><a href="/pages/af9f25/" class="sidebar-link">压力测试</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>代码质量</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ec2b81/" class="sidebar-link">代码整洁之道</a></li><li><a href="/pages/474cdf/" class="sidebar-link">阿里巴巴编程规范</a></li><li><a href="/pages/c47e15/" class="sidebar-link">代码之丑(极客时间)🌸</a></li><li><a href="/pages/4d4606/" class="sidebar-link">Java业务开发常见错误100例(极客时间)🌸</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/develop/#开发" data-v-06970110>开发</a></li><li data-v-06970110><a href="/develop/#Java" data-v-06970110>Java</a></li><li data-v-06970110><a href="/develop/#JVM" data-v-06970110>JVM</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">虚拟机类加载机制🌼<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_31-虚拟机类加载机制🌼"><a href="#_31-虚拟机类加载机制🌼" class="header-anchor">#</a> 31.虚拟机类加载机制🌼</h1> <p>本节对应《深入理解 Java 虚拟机》的第七章</p> <p>代码编译的结果从本地机器码转变为字节码, 是存储格式发展的一小步, 却是编程语言发展的一大步.</p> <h4 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h4> <p>上一章学习了 Class 文件存储格式的具体细节, 在 Class 文件中描述的各类信息, 最终都需要<strong>加载到虚拟机中之后才能被运行和使用</strong>. 而虚拟机如何加载这些 Class 文件, Class 文件中的信息进入到虚拟机后会发生什么变化, 这些都是本章将要讲解的内容.</p> <p><mark><strong>Java 虚拟机把描述类的数据从 Class 文件加载到内存, 并对数据进行校验, 转换解析和初始化, 最终形成可以被虚拟机直接使用的 Java 类型, 这个过程被称作虚拟机的类加载机制</strong></mark>. 与那些在编译时需要进行连接的语言不同, 在 Java 语言里面, 类型的加载, 连接和初始化过程都是在<strong>程序运行期间</strong>完成的, 这种策略让 Java 语言进行提前编译会面临额外的困难, 也会让类加载时稍微增加一些性能开销, 但是却为 Java 应用提供了极高的扩展性和灵活性, <strong>Java 天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的</strong>. 例如, 编写一个面向接口的应用程序, 可以等到运行时再指定其实际的实现类, 用户可以通过 Java 预置的或自定义类加载器, 让某个本地的应用程序在运行时从网络或其他地方上加载一个二进制流作为其程序代码的一部分. 这种动态组装应用的方式目前已广泛应用于 Java 程序之中, 从最基础的 Applet, JSP 到相对复杂的 OSGi 技术, 都依赖着 Java 语言运行期类加载才得以诞生.</p> <p>为了避免语言表达中可能产生的偏差, 在正式开始本章以前, 笔者先设立两个语言上的约定:</p> <ul><li>第一, 在实际情况中, 每个 Class 文件都有代表着 Java 语言中的一个类或接口的可能, 后文中直接对 &quot;类型&quot; 的描述都同时蕴含着类和接口的可能性, 而需要对类和接口分开描述的场景, 笔者会特别指明;</li> <li>第二, 与前面介绍 Class 文件格式时的约定一致, 本章所提到的 &quot;Class 文件&quot; 也并非特指某个存在于具体磁盘中的文件, 而应当是<strong>一串二进制字节流</strong>, 无论其以何种形式存在, 包括但不限于磁盘文件, 网络, 数据库, 内存或者动态产生等.</li></ul> <h4 id="类加载的时机"><a href="#类加载的时机" class="header-anchor">#</a> 类加载的时机</h4> <h6 id="_1-类的生命周期"><a href="#_1-类的生命周期" class="header-anchor">#</a> (1)类的生命周期</h6> <p>一个类型从被加载到虚拟机内存中开始, 到卸载出内存为止, 它的<mark><strong>整个生命周期将会经历加载(Loading), 验证(Verification), 准备(Preparation), 解析(Resolution), 初始化(Initialization), 使用(Using)和卸载(Unloading)七个阶段, 其中验证, 准备, 解析三个部分统称为连接(Linking)</strong></mark> . 这七个阶段的发生顺序如图 7-1 所示.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521194824543.png" alt="" title="图7-1　类的生命周期"></p> <p>图 7-1 中, <strong>加载, 验证, 准备, 初始化和卸载</strong>这五个阶段的顺序是<strong>确定</strong>的, 类型的加载过程必须按照这种顺序按部就班地开始, 而解析阶段则不一定: 它在某些情况下可以在初始化阶段之后再开始, 这是为了<strong>支持 Java 语言的运行时绑定特性(也称为动态绑定或晚期绑定)</strong> . 请注意, 这里写的是按部就班地 &quot;<strong>开始</strong>&quot;, 而不是按部就班地 &quot;进行&quot; 或按部就班地 &quot;完成&quot;, 强调这点是因为这些阶段通常都是<strong>互相交叉地混合进行</strong>的, 会在一个阶段执行的过程中调用, 激活另一个阶段.</p> <h6 id="_2-类加载的时机与主动引用"><a href="#_2-类加载的时机与主动引用" class="header-anchor">#</a> (2)类加载的时机与主动引用</h6> <p>类是在<strong>运行期</strong>间第一次使用时<strong>动态加载</strong>的, 而不是一次性加载所有类. 如果一次性加载会占用很多的内存.</p> <p>关于在什么情况下需要开始类加载过程的第一个阶段 &quot;加载&quot;, 《Java 虚拟机规范》中并没有进行强制约束, 这点可以交给虚拟机的具体实现来自由把握. 但是对于初始化阶段, 《Java 虚拟机规范》则是严格规定了<mark><strong>有且只有六种情况必须立即对类进行 &quot;初始化&quot;</strong></mark>  (而加载, 验证, 准备自然需要在此之前开始):</p> <p>(1) <strong>遇到 new, getstatic, putstatic 或 invokestatic 这四条字节码指令时, 如果类型没有进行过初始化, 则需要先触发其初始化阶段</strong>. 能够生成这四条指令的典型 Java 代码场景有:</p> <ul><li><strong>使用 new 关键字实例化对象</strong>的时候.</li> <li><strong>读取或设置一个类型的静态字段(被 final 修饰, 已在编译期把结果放入常量池的静态字段除外)的时候</strong>.</li> <li><strong>调用一个类型的静态方法的时候</strong>.</li></ul> <p>(2) 使用 java.lang.reflect 包的方法对类型进行<strong>反射调用</strong>的时候, 如果类型没有进行过初始化, 则需要先触发其初始化.</p> <p>(3) 当初始化类的时候, <strong>如果发现其父类还没有进行过初始化, 则需要先触发其父类的初始化</strong>.</p> <p>(4) 当虚拟机启动时, 用户需要<strong>指定一个要执行的主类</strong>(包含 main()方法的那个类), 虚拟机会先初始化这个主类.</p> <p>(5) 当使用 JDK 7 新加入的动态语言支持时, 如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic, REF_newInvokeSpecial 四种类型的方法句柄, 并且这个方法句柄对应的类没有进行过初始化, 则需要先触发其初始化.</p> <p>(6) 当一个<strong>接口中定义了 JDK 8 新加入的默认方法</strong>(被 default 关键字修饰的接口方法)时, 如果有这个接口的实现类发生了初始化, 那该接口要在其之前被初始化.</p> <p>对于这六种会触发类型进行初始化的场景, 《Java 虚拟机规范》中使用了一个非常强烈的限定语--&quot;<strong>有且只有</strong>&quot;, 这六种场景中的行为称为对一个类型进行<mark><strong>主动引用</strong></mark>. 除此之外, 其他引用类型的方式都不会触发初始化, 称为<mark><strong>被动引用</strong></mark>.</p> <h6 id="_3-被动引用的示例"><a href="#_3-被动引用的示例" class="header-anchor">#</a> (3)被动引用的示例</h6> <p>下面举三个例子来说明何为被动引用, 分别见代码清单 7-1, 代码清单 7-2 和代码清单 7-3.</p> <p><strong>(1) 通过子类引用父类静态字段, 不会导致子类初始化</strong>.</p> <blockquote><p>代码清单7-1 被动引用的例子之一</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>classloading</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 被动使用类字段演示一: 
 * 通过子类引用父类的静态字段, 不会导致子类初始化
 **/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;SuperClass init!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;SubClass init!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 非主动使用类字段演示
 **/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">SubClass</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>上述代码运行之后, 只会输出 &quot;SuperClass init!&quot;, 而不会输出 &quot;SubClass init!&quot;. <strong>对于静态字段, 只有直接定义这个字段的类才会被初始化, 因此通过其子类来引用父类中定义的静态字段, 只会触发父类的初始化而不会触发子类的初始化</strong>. 至于是否要触发子类的加载和验证阶段, 在《Java 虚拟机规范》中并未明确规定, 所以这点取决于虚拟机的具体实现. 对于 HotSpot 虚拟机来说, 可通过 <code>-XX: +TraceClassLoading</code>​ 参数观察到此操作是会导致子类加载的.</p> <p><strong>(2) 通过数组定义引用类, 不会触发此类的初始化; 该过程会对数组类进行初始化, 数组类是一个由虚拟机自动生成的, 直接继承自 Object 的子类, 其中包含了数组的属性和方法</strong>.</p> <blockquote><p>代码清单7-2 被动引用的例子之二</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>classloading</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 被动使用类字段演示二: 
 * 通过数组定义来引用类, 不会触发此类的初始化
 **/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SuperClass</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperClass</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>为了节省版面, 这段代码复用了代码清单 7-1 中的 SuperClass, 运行之后发现没有输出 &quot;SuperClass init!&quot;, 说明并没有触发类 org.fenixsoft.classloading.SuperClass 的初始化阶段. 但是这段代码里面<strong>触发</strong>了另一个名为 &quot;<code>[Lorg.fenixsoft.classloading.SuperClass</code>​&quot; 的类的初始化阶段, 对于用户代码来说, 这并不是一个合法的类型名称, 它是一个<strong>由虚拟机自动生成的, 直接继承于 java.lang.Object 的子类</strong>, 创建动作由字节码指令 newarray 触发.</p> <p>这个类代表了一个元素类型为 org.fenixsoft.classloading.SuperClass 的<strong>一维数组</strong>, 数组中应有的属性和方法(用户可直接使用的只有被修饰为 public 的 length 属性和 clone() 方法)都实现在这个类里. Java 语言中对数组的访问要比 C/C++ 相对安全, 很大程度上就是因为这个类包装了数组元素的访问, 而 C/C++ 中则是直接翻译为对数组指针的移动. 在 Java 语言里, 当检查到发生数组越界时会抛出 java.lang.ArrayIndexOutOfBoundsException 异常, 避免了直接造成非法内存访问.</p> <p><strong>(3) 常量在编译阶段会存入调用类的常量池中, 本质上并没有直接引用定义常量的类, 因此不会触发定义常量的类的初始化</strong>.</p> <blockquote><p>代码清单7-3 被动引用的例子之三</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>classloading</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 被动使用类字段演示三: 
 * 常量在编译阶段会存入调用类的常量池中, 本质上没有直接引用到定义常量的类, 
 * 因此不会触发定义常量的 类的初始化
 **/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConstClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;ConstClass init!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">HELLOWORLD</span> <span class="token operator">=</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 非主动使用类字段演示
 **/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ConstClass</span><span class="token punctuation">.</span><span class="token constant">HELLOWORLD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>上述代码运行之后, 也没有输出 &quot;ConstClass init!&quot;, 这是因为虽然在 Java 源码中确实引用了 ConstClass 类的常量 HELLOWORLD, 但<strong>其实在编译阶段通过常量传播优化, 已经将此常量的值 &quot;hello world&quot; 直接存储在 NotInitialization 类的常量池中</strong>, 以后 NotInitialization 对常量 ConstClass.HELLOWORLD 的引用, 实际都被转化为 NotInitialization 类对<strong>自身常量池</strong>的引用了. 也就是说, 实际上 NotInitialization 的 Class 文件之中并没有 ConstClass 类的符号引用入口, 这两个类在编译成 Class 文件后就已不存在任何联系了.</p> <p><strong>接口的加载过程与类加载过程稍有不同</strong>, 针对接口需要做一些特殊说明: 接口也有初始化过程, 这点与类是一致的, 上面的代码都是用静态语句块 &quot;<code>static{}</code>​&quot; 来输出初始化信息的, 而接口中不能使用 &quot;<code>static{}</code>​&quot; 语句块, 但编译器仍然会为接口生成 &quot;<code>&lt;clinit&gt;()</code>​&quot; 类构造器, 用于初始化接口中所定义的成员变量. <strong>接口与类真正有所区别的是前面讲述的六种 &quot;有且仅有&quot; 需要触发初始化场景中的第三种: 当一个类在初始化时, 要求其父类全部都已经初始化过了, 但是一个接口在初始化时, 并不要求其父接口全部都完成了初始化, 只有在真正使用到父接口的时候(如引用接口中定义的常量)才会初始化</strong>.</p> <h4 id="类加载的过程"><a href="#类加载的过程" class="header-anchor">#</a> 类加载的过程</h4> <p>接下来详细了解 Java 虚拟机中<strong>类加载的全过程</strong>, 即<mark><strong>加载, 验证, 准备, 解析和初始化</strong></mark>这五个阶段所执行的具体动作. 注意对比之前 <strong>new 一个关键字会发生什么</strong>部分的内容, 之前只是讲了对象<strong>创建过程</strong>(参考: 对象创建完整过程).</p> <h5 id="_1-加载"><a href="#_1-加载" class="header-anchor">#</a> 1.加载</h5> <p>&quot;加载&quot; (Loading)阶段是整个 &quot;类加载&quot;(Class Loading)过程中的一个阶段, 希望读者没有混淆这两个看起来很相似的名词. <strong>在加载阶段, Java 虚拟机需要完成以下三件事情</strong>:</p> <ol><li>通过一个类的<strong>全限定名</strong>来获取定义此类的二进制字节流. 也就是将 class 文件加载到<strong>内存</strong>.</li> <li>将这个<strong>字节流所代表的静态存储结构转化为方法区的运行时数据结构</strong>.</li> <li><strong>在内存中生成一个代表这个类的 java.lang.Class 对象, 作为方法区这个类的各种数据的访问入口</strong>.</li></ol> <p>《Java 虚拟机规范》对这三点要求其实并不是特别具体, 留给虚拟机实现与 Java 应用的灵活度都是相当大的. 例如 &quot;通过一个类的全限定名来获取定义此类的二进制字节流&quot; 这条规则, 它<strong>并没有指明二进制字节流必须得从某个 Class 文件中获取, 确切地说是根本没有指明要从哪里获取, 如何获取</strong>. 仅仅这一点空隙, Java 虚拟机的使用者们就可以在加载阶段搭构建出一个相当开放广阔的舞台, Java 发展历程中, 充满创造力的开发人员则在这个舞台上玩出了各种花样, 许多举足轻重的 Java 技术都建立在这一基础之上, 例如:</p> <ul><li><strong>文件</strong>: 从 ZIP 压缩包中读取, 这很常见, 最终成为日后 JAR, EAR, WAR 格式的基础.</li> <li><strong>网络</strong>: 从网络中获取, 这种场景最典型的应用就是 Web Applet.</li> <li><strong>运行时计算生成</strong>: 这种场景使用得最多的就是<strong>动态代理技术</strong>, 在 java.lang.reflect.Proxy 中, 就是用了 ProxyGenerator.generateProxyClass() 来为特定接口生成形式为 &quot;<code>*$Proxy</code>​&quot; 的代理类的二进制字节流.</li> <li><strong>由其他文件生成</strong>: 典型场景是 JSP 应用, 由 JSP 文件生成对应的 Class 文件.</li> <li><strong>从数据库中读取</strong>: 这种场景相对少见些, 例如有些中间件服务器(如 SAP Netweaver)可以选择把程序安装到数据库中来完成程序代码在集群间的分发.</li> <li><strong>可以从加密文件中获取</strong>: 这是典型的防 Class 文件被反编译的保护措施, 通过加载时解密 Class 文件来保障程序运行逻辑不被窥探.</li></ul> <blockquote><p>数组类型与非数组类型的加载</p></blockquote> <p>相对于类加载过程的其他阶段, <strong>非数组类型的加载阶段</strong>​(准确地说, 是加载阶段中获取类的二进制字节流的动作)是开发人员可控性最强的阶段. 加载阶段既可以使用 Java 虚拟机里内置的引导类加载器来完成, 也可以由<strong>用户自定义的类加载器</strong>去完成, 开发人员通过定义自己的类加载器去控制字节流的获取方式(重写一个类加载器的 findClass() 或 loadClass() 方法), 实现根据自己的想法来赋予应用程序<strong>获取运行代码的动态性</strong>.</p> <p>对于<strong>数组类</strong>而言, 情况就有所不同, <strong>数组类本身不通过类加载器创建, 它是由 Java 虚拟机直接在内存中动态构造出来的</strong>. 但数组类与类加载器仍然有很密切的关系, 因为数组类的元素类型(Element Type, 指的是数组去掉所有维度的类型)最终还是要靠类加载器来完成加载, 一个数组类(下面简称为 C)创建过程遵循以下规则:</p> <ul><li>如果数组的组件类型(Component Type, 指的是数组去掉一个维度的类型, 注意和前面的元素类型区分开来)是引用类型, 那就递归采用本节中定义的加载过程去加载这个组件类型, 数组 C 将被标识在加载该组件类型的类加载器的类名称空间上(这点很重要, 在 7.4 节会介绍, 一个类型必须与类加载器一起确定唯一性).</li> <li>如果数组的组件类型不是引用类型(例如 <code>int[]</code>​ 数组的组件类型为 int), Java 虚拟机将会把数组 C 标记为与引导类加载器关联.</li> <li>数组类的可访问性与它的组件类型的可访问性一致, 如果组件类型不是引用类型, 它的数组类的可访问性将默认为 public, 可被所有的类和接口访问到.</li></ul> <p><mark><strong>加载阶段结束后, Java 虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了, 方法区中的数据存储格式完全由虚拟机实现自行定义</strong></mark>, 《Java 虚拟机规范》未规定此区域的具体数据结构. <mark><strong>类型数据妥善安置在方法区之后, 会在 Java 堆内存中实例化一个 java.lang.Class 类的对象, 这个对象将作为程序访问方法区中的类型数据的外部接口</strong></mark>.</p> <p>加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是<strong>交叉进行</strong>的, 加载阶段尚未完成, 连接阶段可能已经开始, 但这些夹在加载阶段之中进行的动作, 仍然属于连接阶段的一部分, 这两个阶段的开始时间仍然保持着固定的先后顺序.</p> <h5 id="_2-验证"><a href="#_2-验证" class="header-anchor">#</a> 2.验证</h5> <p>验证是连接阶段的第一步, <mark><strong>这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求</strong></mark>, 保证这些信息被当作代码运行后不会危害虚拟机自身的安全. 虚拟机如果不检查输入的字节流, 对其完全信任的话, 很可能会因为载入了有错误或有恶意企图的字节码流而导致整个系统受攻击甚至崩溃, 所以验证字节码是虚拟机保护自身的一项必要措施.</p> <p>验证阶段是非常重要的, <strong>这个阶段是否严谨, 直接决定了 Java 虚拟机是否能承受恶意代码的攻击</strong>, 从代码量和耗费的执行性能的角度上讲, 验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重. 从整体上看, 验证阶段大致上会完成下面四个阶段的检验动作: <strong>文件格式验证, 元数据验证, 字节码验证和符号引用验证</strong>.</p> <blockquote><p>1.文件格式验证</p></blockquote> <p>第一阶段要<strong>验证字节流是否符合 Class 文件格式的规范</strong>, 并且能被当前版本的虚拟机处理(参考: Class类文件结构). 如<strong>魔数以及版本号</strong>是否合理, Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息等.</p> <p>该验证阶段的主要目的是<strong>保证输入的字节流能正确地解析并存储于方法区之内, 格式上符合描述一个 Java 类型信息的要求</strong>. 这阶段的验证是基于二进制字节流进行的, 只有通过了这个阶段的验证之后, 这段字节流才被允许进入 Java 虚拟机内存的方法区中进行存储, 所以后面的三个验证阶段全部是基于方法区的存储结构上进行的, 不会再直接读取, 操作字节流了.</p> <blockquote><p>2.元数据验证</p></blockquote> <p>第二阶段是对字节码描述的信息进行<strong>语义分析</strong>, 以保证其描述的信息符合《Java 语言规范》的要求, 这个阶段可能包括的验证点比如是否有父类? 继承了 final 类? 非抽象类实现了所有的抽象方法?</p> <p>第二阶段的主要目的是<strong>对类的元数据信息进行语义校验</strong>, 保证不存在与《Java 语言规范》定义相悖的元数据信息.</p> <blockquote><p>3.字节码验证</p></blockquote> <p>第三阶段是整个验证过程中<strong>最复杂</strong>的一个阶段, 主要目的是<strong>通过数据流分析和控制流分析, 确定程序语义是合法的, 符合逻辑</strong>的. 在第二阶段对元数据信息中的数据类型校验完毕以后, 这阶段就要对类的方法体(Class 文件中的 Code 属性)进行校验分析, 保证被校验类的方法在运行时不会做出危害虚拟机安全的行为, 例如:</p> <ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作, 例如不会出现类似于 &quot;在操作栈放置了一个 int 类型的数据, 使用时却按 long 类型来加载入本地变量表中&quot; 这样的情况.</li> <li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上.</li> <li>保证方法体中的类型转换总是有效的, 例如可以把一个子类对象赋值给父类数据类型, 这是安全的, 但是把父类对象赋值给子类数据类型, 甚至把对象赋值给与它毫无继承关系, 完全不相干的一个数据类型, 则是危险和不合法的.</li> <li>...</li></ul> <p>如果一个类型中有方法体的字节码没有通过字节码验证, 那它肯定是有问题的; 但如果一个方法体通过了字节码验证, 也仍然不能保证它一定就是安全的. 即使字节码验证阶段中进行了再大量, 再严密的检查, 也依然不能保证这一点. 这里涉及了离散数学中一个很著名的问题---&quot;停机问题&quot;(Halting Problem), 即不能通过程序准确地检查出程序是否能在有限的时间之内结束运行. 在讨论字节码校验的上下文语境里, 通俗一点的解释是通过程序去校验程序逻辑是无法做到绝对准确的, <strong>不可能用程序来准确判定一段程序是否存在 Bug</strong>.</p> <p>由于数据流分析和控制流分析的高度复杂性, Java 虚拟机的设计团队为了避免过多的执行时间消耗在字节码验证阶段中, 在 JDK 6 之后的 Javac 编译器和 Java 虚拟机里进行了一项联合优化, 把尽可能多的校验辅助措施挪到 Javac 编译器里进行. 具体做法是给方法体 Code 属性的属性表中新增加了一项名为 &quot;StackMapTable&quot; 的新属性, 这项属性描述了方法体所有的基本块(Basic Block, 指按照控制流拆分的代码块)开始时本地变量表和操作栈应有的状态, 在字节码验证期间, Java 虚拟机就不需要根据程序推导这些状态的合法性, 只需要检查 StackMapTable 属性中的记录是否合法即可. 这样就将字节码验证的类型推导转变为类型检查, 从而节省了大量校验时间. 理论上 StackMapTable 属性也存在错误或被篡改的可能, 所以是否有可能在恶意篡改了 Code 属性的同时, 也生成相应的 StackMapTable 属性来骗过虚拟机的类型校验, 则是虚拟机设计者们需要仔细思考的问题.</p> <blockquote><p>4.符号引用验证</p></blockquote> <p>最后一个阶段的校验行为发生在虚拟机<strong>将符号引用转化为直接引用</strong>的时候, 这个转化动作将在连接的第三阶段, 即解析阶段中发生. 符号引用验证可以看作是对类自身以外(常量池中的各种符号引用)的各类信息进行匹配性校验, 通俗来说就是, <strong>该类是否缺少或者被禁止访问它依赖的某些外部类, 方法, 字段等资源</strong>. 本阶段通常需要校验下列内容:</p> <ul><li>符号引用中通过<strong>字符串描述的全限定名是否能找到对应的类</strong>.</li> <li>在指定类中是否存在符合方法的<strong>字段描述符及简单名称所描述的方法和字段</strong>.</li> <li>符号引用中的类, 字段, 方法的可访问性(<code>private, protected, public, &lt;package&gt;</code>​)是否可被当前类访问.</li> <li>...</li></ul> <p>符号引用验证的主要目的是<strong>确保解析行为能正常执行</strong>, 如果无法通过符号引用验证, Java 虚拟机将会抛出一个 java.lang.IncompatibleClassChangeError 的子类异常, 典型的如: <code>java.lang.IllegalAccessError, java.lang.NoSuchFieldError, java.lang.NoSuchMethodError</code>​ 等.</p> <p>验证阶段对于虚拟机的类加载机制来说, 是一个非常重要的, 但却不是必须要执行的阶段, 因为验证阶段只有通过或者不通过的差别, 只要通过了验证, 其后就对程序运行期没有任何影响了. 如果程序运行的全部代码(包括自己编写的, 第三方包中的, 从外部加载的, 动态生成的等所有代码)都已经被<strong>反复使用和验证过</strong>, 在生产环境的实施阶段就可以考虑使用 <code>-Xverify: none</code>​ 参数来关闭大部分的类验证措施, 以缩短虚拟机类加载的时间.</p> <h5 id="_3-准备"><a href="#_3-准备" class="header-anchor">#</a> 3.准备</h5> <p><mark><strong>准备阶段是正式为类中定义的变量(即静态变量, 被 static 修饰的变量)分配内存并设置类变量初始值的阶段</strong></mark>.</p> <p>从概念上讲, 这些类(静态)变量所使用的内存都应当在<strong>方法区</strong>中进行分配, 但必须注意到方法区本身是一个逻辑上的区域, 在 JDK 7 及之前, HotSpot 使用永久代来实现方法区时, 实现是完全符合这种逻辑概念的; 而在 JDK 8 及之后, <strong>类变量则会随着 Class 对象一起存放在 Java 堆中</strong>, 这时候 &quot;类变量在方法区&quot; 就完全是一种对逻辑概念的表述了.</p> <p>关于准备阶段, 还有两个容易产生混淆的概念笔者需要着重强调:</p> <ul><li>首先是<strong>这时候进行内存分配的仅包括类变量, 而不包括实例变量, 实例变量将会在对象实例化时随着对象一起分配在 Java 堆中</strong>. 实例化不是类加载的一个过程, 类加载发生在所有实例化操作之前, 并且<strong>类加载只进行一次, 实例化可以进行多次</strong>.</li> <li>其次是这里所说的初始值 &quot;通常情况&quot; 下是数据类型的零值, 假设一个类变量的定义为:</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>那<strong>静态变量 value 在准备阶段过后的初始值为 0 而不是 123</strong>, 因为这时尚未开始执行任何 Java 方法, 而把 value 赋值为 123 的 putstatic 指令是程序被编译后, 存放于类构造器 <code>&lt;clinit&gt;()</code>​ 方法之中, 所以把 value 赋值为 123 的动作要到<strong>类的初始化阶段</strong>才会被执行. 表 7-1 列出了 Java 中所有基本数据类型的零值.</p> <blockquote><p>表7-1 基本数据类型的零值</p></blockquote> <table><thead><tr><th style="text-align:center;">数据类型</th> <th style="text-align:center;">零值</th> <th style="text-align:center;">数据类型</th> <th style="text-align:center;">零值</th></tr></thead> <tbody><tr><td style="text-align:center;">int</td> <td style="text-align:center;">0</td> <td style="text-align:center;">boolean</td> <td style="text-align:center;"><strong>false</strong></td></tr> <tr><td style="text-align:center;">long</td> <td style="text-align:center;">0L</td> <td style="text-align:center;">float</td> <td style="text-align:center;"><strong>0.0f</strong></td></tr> <tr><td style="text-align:center;">short</td> <td style="text-align:center;">(short) 0</td> <td style="text-align:center;">double</td> <td style="text-align:center;">0.0d</td></tr> <tr><td style="text-align:center;">char</td> <td style="text-align:center;"><strong>'\u0000'</strong></td> <td style="text-align:center;">reference</td> <td style="text-align:center;"><strong>null</strong></td></tr> <tr><td style="text-align:center;">byte</td> <td style="text-align:center;">(byte) 0</td> <td style="text-align:center;"></td> <td style="text-align:center;"></td></tr></tbody></table> <p>上面提到在 &quot;通常情况&quot; 下初始值是零值, 那言外之意是相对的会有某些 &quot;特殊情况&quot;: 如果类字段的字段属性表中存在 <strong>ConstantValue</strong> 属性, 那在准备阶段变量值就会被初始化为 ConstantValue 属性所指定的初始值, 假设上面类变量 value 的定义修改为:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 注意这里加了final修饰</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>编译时 Javac 将会为 value 生成 ConstantValue 属性, <strong>在准备阶段虚拟机就会根据 Con-stantValue 的设置将 value 赋值为 123</strong>.</p> <p>注意: 方法内部的<strong>局部变量</strong>不像静态变量具有 &quot;准备阶段&quot;, 所以在<strong>程序中必须初始化</strong>才能使用, 因此<strong>局部变量</strong>没有赋初始值是不能使用的.</p> <h5 id="_4-解析"><a href="#_4-解析" class="header-anchor">#</a> 4.解析</h5> <p><mark><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程</strong></mark>.</p> <p>解析阶段会把一些静态方法(符号引用, 比如 main() 方法)替换为指向数据所在内存的指针或句柄等(直接引用), 这是所谓的静态链接过程(类加载期间完成), 动态链接是在程序运行期间完成的将符号引用替换为直接引用, 也就是得到类或者字段, 方法在内存中的指针或者偏移量.</p> <p>符号引用在讲解 Class 文件格式的时候已经出现过多次, 在 Class 文件中它以 CONSTANT_Class_info, CONSTANT_Fieldref_info, CONSTANT_Methodref_info 等类型的<strong>常量</strong>出现, 那解析阶段中所说的<strong>直接引用与符号引用</strong>又有什么关联呢?</p> <blockquote><p>符号引用与直接引用</p></blockquote> <ul><li><mark><strong>符号引用(Symbolic References)</strong></mark> : 符号引用<strong>以一组符号来描述所引用的目标, 符号可以是任何形式的字面量, 只要使用时能无歧义地定位到目标即可</strong>. 符号引用与虚拟机实现的内存布局无关, <strong>引用的目标并不一定是已经加载到虚拟机内存当中的内容</strong>. 各种虚拟机实现的内存布局可以各不相同, 但是它们能接受的符号引用必须都是一致的, 因为符号引用的字面量形式明确定义在《Java 虚拟机规范》的 Class 文件格式中.</li> <li><mark><strong>直接引用(Direct References)</strong></mark> : 直接引用是<strong>可以直接指向目标的指针, 相对偏移量或者是一个能间接定位到目标的句柄</strong>. 直接引用是和虚拟机实现的<strong>内存布局</strong>直接相关的, 同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同. <strong>如果有了直接引用, 那引用的目标必定已经在虚拟机的内存中存在</strong>. 直接应用可以通俗的理解为一个代码片段的<strong>入口地址</strong>.</li></ul> <p>《Java 虚拟机规范》之中并未规定解析阶段发生的具体时间, 只要求了<strong>在执行 ane-warray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invoke-special, invokestatic, invokevirtual, ldc, ldc_w, ldc2_w, multianewarray, new, putfield 和 putstatic 这 17 个用于操作符号引用的字节码指令之前, 先对它们所使用的符号引用进行解析</strong>. 所以虚拟机实现可以根据需要来自行判断, 到底是在类被加载器加载时就对常量池中的符号引用进行解析, 还是等到一个符号引用将要被使用前才去解析它.</p> <p>类似地, 对方法或者字段的访问, 也会在解析阶段中对它们的可访问性(<code>public, protected, private, &lt;package&gt;</code>​)进行检查, 至于其中的约束规则已经是 Java 语言的基本常识, 笔者就不再赘述了.</p> <p>对同一个符号引用进行<strong>多次解析</strong>请求是很常见的事情, 除 invokedynamic 指令以外, <strong>虚拟机实现可以对第一次解析的结果进行缓存</strong>, 譬如在运行时直接引用常量池中的记录, 并把常量标识为已解析状态, 从而避免解析动作重复进行. 无论是否真正执行了多次解析动作, Java 虚拟机都需要保证的是在同一个实体中, 如果一个符号引用之前已经被成功解析过, 那么后续的引用解析请求就应当一直能够成功; 同样地, 如果第一次解析失败了, 其他指令对这个符号的解析请求也应该收到相同的异常, 哪怕这个请求的符号在后来已成功加载进 Java 虚拟机内存之中.</p> <p>不过对于 <strong>invokedynamic</strong> 指令(参考: 方法调用和返回指令), 上面的规则就不成立了. 当碰到某个前面已经由 invokedynamic 指令触发过解析的符号引用时, 并不意味着这个解析结果对于其他 invokedynamic 指令也同样生效. <strong>因为 invokedynamic 指令的目的本来就是用于动态语言支持, 它对应的引用称为 &quot;动态调用点限定符&quot;, 这里 &quot;动态&quot; 的含义是指必须等到程序实际运行到这条指令时, 解析动作才能进行. 相对地, 其余可触发解析的指令都是 &quot;静态&quot; 的, 可以在刚刚完成加载阶段, 还没有开始执行代码时就提前进行解析</strong>.</p> <p><mark><strong>解析动作主要针对类或接口, 字段, 类方法, 接口方法, 方法类型, 方法句柄和调用点限定符这 7 类符号引用进行</strong></mark>, 分别对应于常量池的 CONSTANT_Class_info, CON-STANT_Fieldref_info, CONSTANT_Methodref_info, CONSTANT_InterfaceMethodref_info, CONSTANT_MethodType_info, CONSTANT_MethodHandle_info, CONSTANT_Dyna-mic_info 和 CONSTANT_InvokeDynamic_info 8 种常量类型. 下面将讲解前 4 种引用的解析过程, 对于后 4 种, 它们都和动态语言支持密切相关, 由于 Java 语言本身是一门静态类型语言, 在没有讲解清楚 invokedynamic 指令的语意之前, 很难将它们直观地和现在的 Java 语言语法对应上, 因此将延后到后面介绍动态语言调用时一起分析讲解.</p> <blockquote><p>1.类或接口的解析</p></blockquote> <p>假设当前代码所处的类为 D, 如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的直接引用, 那虚拟机完成整个解析的过程需要包括以下 3 个步骤:</p> <ul><li>(1) 如果 C 不是一个数组类型, 那虚拟机将会把代表 N 的全限定名传递给 D 的类加载器去加载这个类 C. 在加载过程中, 由于元数据验证, 字节码验证的需要, 又可能触发其他相关类的加载动作, 例如加载这个类的父类或实现的接口. 一旦这个加载过程出现了任何异常, 解析过程就将宣告失败.</li> <li>(2) 如果 C 是一个数组类型, 并且数组的元素类型为对象, 也就是 N 的描述符会是类似 &quot;<code>[Ljava/lang/Integer</code>​&quot; 的形式, 那将会按照第一点的规则加载数组元素类型. 如果 N 的描述符如前面所假设的形式, 需要加载的元素类型就是 &quot;java.lang.Integer&quot;, 接着由虚拟机生成一个代表该数组维度和元素的数组对象.</li> <li>(3) 如果上面两步没有出现任何异常, 那么 C 在虚拟机中实际上已经成为一个<strong>有效的类或接口</strong>了, 但在解析完成前还要进行符号引用验证, 确认 D 是否具备对 C 的访问权限. 如果发现不具备访问权限, 将抛出 java.lang.IllegalAccessError 异常.</li></ul> <p>针对上面第 3 点访问权限验证, 在 JDK 9 引入了模块化以后, 一个 public 类型也不再意味着程序任何位置都有它的访问权限, 还必须检查模块间的访问权限.</p> <p>如果说<strong>一个 D 拥有 C 的访问权限</strong>, 那就意味着以下 3 条规则中至少有其中一条成立:</p> <ul><li>被访问类 C 是 public 的, 并且与访问类 D 处于同一个模块.</li> <li>被访问类 C 是 public 的, 不与访问类 D 处于同一个模块, 但是被访问类 C 的模块允许被访问类 D 的模块进行访问.</li> <li>被访问类 C 不是 public 的, 但是它与访问类 D 处于同一个包中.</li></ul> <p>在后续涉及可访问性时, 都必须考虑模块间访问权限隔离的约束, 即以上列举的 3 条规则, 这些内容在后面就不再复述了.</p> <blockquote><p>2.字段解析</p></blockquote> <p>要<strong>解析一个未被解析过的字段符号引用</strong>, 首先将会对字段表内 class_index 项中索引的 CONSTANT_Class_info 符号引用进行解析, 也就是<strong>字段所属的类或接口的符号引用</strong>. 如果在解析这个类或接口符号引用的过程中出现了任何异常, 都会导致字段符号引用解析的失败. 如果解析成功完成, 那<strong>把这个字段所属的类或接口用 C 表示</strong>, 《Java 虚拟机规范》要求按照如下步骤对 C 进行后续字段的搜索:</p> <ul><li>(1) 如果 C 本身就包含了简单名称和字段描述符都与目标相匹配的字段, 则返回这个字段的直接引用, 查找结束.</li> <li>(2) 否则, 如果在 C 中实现了接口, 将会按照继承关系<strong>从下往上递归搜索各个接口和它的父接口</strong>, 如果接口中包含了简单名称和字段描述符都与目标相匹配的字段, 则返回这个字段的直接引用, 查找结束.</li> <li>(3) 否则, 如果 C 不是 java.lang.Object 的话, 将会按照继承关系从下往上递归搜索其父类, 如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段, 则返回这个字段的直接引用, 查找结束.</li> <li>(4) 否则, 查找失败, 抛出 <strong>java.lang.NoSuchFieldError</strong> 异常.</li></ul> <p>如果查找过程成功返回了引用, 将会对这个字段进行权限验证, 如果发现不具备对字段的访问权限, 将抛出 java.lang.IllegalAccessError 异常.</p> <p>以上解析规则能够<strong>确保 Java 虚拟机获得字段唯一的解析结果</strong>, 但在实际情况中, Javac 编译器往往会采取比上述规范更加严格一些的约束, 譬如有一个同名字段同时出现在某个类的接口和父类当中, 或者同时在自己或父类的多个接口中出现, 按照解析规则仍是可以确定唯一的访问字段, 但 Javac 编译器就可能直接拒绝其编译为 Class 文件. 在代码清单 7-4 中演示了这种情况, 如果注释了 Sub 类中的 &quot;<code>public static int A=4;</code>​&quot;, 接口与父类同时存在字段 A, 那 Oracle 公司实现的 Javac 编译器将提示 &quot;The field Sub.A is ambiguous&quot;, 并且会拒绝编译这段代码.</p> <blockquote><p>代码清单7-4 字段解析</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>classloading</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FieldResolution</span> <span class="token punctuation">{</span>
    <span class="token keyword">interface</span> <span class="token class-name">Interface0</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token keyword">extends</span> <span class="token class-name">Interface0</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">interface</span> <span class="token class-name">Interface2</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">implements</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token keyword">implements</span> <span class="token class-name">Interface2</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Sub<span class="token punctuation">.</span>A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><blockquote><p>3.方法解析</p></blockquote> <p>方法解析的第一个步骤与字段解析一样, 也是需要<strong>先解析出方法表的 class_index 项中索引的方法所属的类或接口的符号引用</strong>, 如果解析成功, 那么依然用 C 表示这个类, 接下来虚拟机将会按照如下步骤进行后续的方法搜索:</p> <ul><li>(1) 由于 Class 文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的, 如果在类的方法表中发现 class_index 中索引的 C 是个接口的话, 那就直接抛出 java.lang.IncompatibleClassChangeError 异常.</li> <li>(2) 如果通过了第一步, 在类 C 中查找是否有简单名称和描述符都与目标相匹配的方法, 如果有则返回这个方法的直接引用, 查找结束.</li> <li>(3) 否则, 在类 C 的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法, 如果有则返回这个方法的直接引用, 查找结束.</li> <li>(4) 否则, 在类 C 实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法, 如果存在匹配的方法, 说明类 C 是一个抽象类, 这时候查找结束, 抛出 java.lang.AbstractMethodError 异常.</li> <li>(5) 否则, 宣告方法查找失败, 抛出 <code>java.lang.NoSuchMethodError</code>​.</li></ul> <p>最后, 如果查找过程成功返回了直接引用, 将会对这个方法进行权限验证, 如果发现不具备对此方法的访问权限, 将抛出 java.lang.IllegalAccessError 异常.</p> <blockquote><p>4.接口方法解析</p></blockquote> <p>接口方法也是需要先<strong>解析出接口方法表的 class_index 项中索引的方法所属的类或接口的符号引用</strong>, 如果解析成功, 依然用 C 表示这个接口, 接下来虚拟机将会按照如下步骤进行后续的接口方法搜索:</p> <ul><li>(1) 与类的方法解析相反, 如果在接口方法表中发现 class_index 中的索引 C 是个类而不是接口, 那么就直接抛出 java.lang.IncompatibleClassChangeError 异常.</li> <li>(2) 否则, 在接口 C 中查找是否有简单名称和描述符都与目标相匹配的方法, 如果有则返回这个方法的直接引用, 查找结束.</li> <li>(3) 否则, 在接口 C 的父接口中递归查找, 直到 java.lang.Object 类(接口方法的查找范围也会包括 Object 类中的方法)为止, 看是否有简单名称和描述符都与目标相匹配的方法, 如果有则返回这个方法的直接引用, 查找结束.</li> <li>(4) 对于规则3, 由于 Java 的接口允许多重继承, 如果 C 的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法, 那将会从这多个方法中返回其中一个并结束查找, 《Java 虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法. 但与之前字段查找类似地, 不同发行商实现的 Javac 编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性.</li> <li>(5) 否则, 宣告方法查找失败, 抛出 <code>java.lang.NoSuchMethodError</code>​ 异常.</li></ul> <h5 id="_5-初始化"><a href="#_5-初始化" class="header-anchor">#</a> 5.初始化</h5> <p>类的初始化阶段是类加载过程的最后一个步骤, 之前介绍的几个类加载的动作里, 除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外, 其余动作都完全由 Java 虚拟机来主导控制. 直到初始化阶段, 虚拟机才真正开始<strong>执行类中编写的 Java 程序代码</strong>, 将主导权移交给应用程序.</p> <p><strong>进行准备阶段时, 变量已经赋过一次系统要求的初始零值, 而在初始化阶段, 则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源</strong>. 也可以从另外一种更直接的形式来表达: <mark><strong>初始化阶段就是执行类构造器</strong></mark> <code>&lt;clinit&gt;()</code>​ 方法的过程. <code>&lt;clinit&gt;()</code>​ 并不是程序员在 Java 代码中直接编写的方法, 它<strong>是 Javac 编译器的自动生成物</strong>, 但非常有必要了解这个方法具体是如何产生的, 以及 <code>&lt;clinit&gt;()</code>​ 方法执行过程中各种可能会影响程序运行行为的细节, 这部分比起其他类加载过程更贴近于普通的程序开发人员的实际工作.</p> <ul><li>​<code>&lt;clinit&gt;()</code>​ 方法是<strong>由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{} 块)中的语句合并产生的, 编译器收集的顺序是由语句在源文件中出现的顺序决定的, 静态语句块中只能访问到定义在静态语句块之前的变量, 定义在它之后的变量, 在前面的静态语句块可以赋值, 但是不能访问</strong>, 如代码清单 7-5 所示.</li></ul> <blockquote><p>代码清单7-5 非法前向引用变量</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//  给变量复制可以正常编译通过</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 这句编译器会提示&quot;非法向前引用&quot;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>​<code>&lt;clinit&gt;()</code>​ 方法与类的构造函数(即在虚拟机视角中的实例构造器 <code>&lt;init&gt;()</code>​ 方法)不同, 它不需要显式地调用父类构造器, Java 虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code>​ 方法执行前, 父类的 <code>&lt;clinit&gt;()</code>​ 方法已经执行完毕. 因此在 Java 虚拟机中第一个被执行的 <code>&lt;clinit&gt;()</code>​ 方法的类型肯定是 <strong>java.lang.Object</strong>.</li> <li>由于父类的 <code>&lt;clinit&gt;()</code>​ 方法<strong>先执行</strong>, 也就意味着<strong>父类中定义的静态语句块要优先于子类的变量赋值操作</strong>, 如代码清单 7-6 中, 字段 B 的值将会是 2 而不是 1.</li></ul> <blockquote><p>代码清单7-6 <code>&lt;clinit&gt;()</code>​ 方法执行顺序</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Sub<span class="token punctuation">.</span>B</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ul><li>​<code>&lt;clinit&gt;()</code>​ 方法对于类或接口来说并不是必需的, 如果一个<strong>类中没有静态语句块, 也没有对变量的赋值操作</strong>, 那么编译器可以不为这个类生成 <code>&lt;clinit&gt;()</code>​ 方法.</li> <li>接口中不能使用静态语句块, 但仍然有变量初始化的赋值操作, 因此接口与类一样都会生成 <code>&lt;clinit&gt;()</code>​ 方法. 但接口与类不同的是, 执行接口的 <code>&lt;clinit&gt;()</code>​ 方法不需要先执行父接口的 <code>&lt;clinit&gt;()</code>​ 方法, 因为只有当父接口中定义的变量被使用时, 父接口才会被初始化. 此外, 接口的实现类在初始化时也一样不会执行接口的 <code>&lt;clinit&gt;()</code>​ 方法.</li> <li>Java 虚拟机必须保证一个类的 <code>&lt;clinit&gt;()</code>​ 方法在多线程环境中被正确地<strong>加锁同步</strong>, 如果多个线程同时去初始化一个类, 那么只会有其中一个线程去执行这个类的 <code>&lt;clinit&gt;()</code>​ 方法, 其他线程都需要阻塞等待, 直到活动线程执行完毕 <code>&lt;clinit&gt;()</code>​ 方法. 如果在一个类的 <code>&lt;clinit&gt;()</code>​ 方法中有耗时很长的操作, 那就可能造成多个进程<strong>阻塞</strong>, 在实际应用中这种阻塞往往是很隐蔽的. 代码清单 7-7 演示了这种场景.</li></ul> <blockquote><p>代码清单7-7 多线程加载类导致阻塞的示例</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DeadLoopClass</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里static方法会在类加载的初始化阶段进行调用</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果不加上这个 if 语句, 编译器将提示&quot;Initializer does not complete normally&quot;并拒绝编译</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;init DeadLoopClass&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Runnable</span> script <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;start&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">DeadLoopClass</span> dlc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeadLoopClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; run over&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
    <span class="token class-name">Thread</span> thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>运行结果如下, 这里有两个线程都会尝试去进行类加载, 但是由于 static 中的方法是死循环, 导致初始化一直没有结束, 另外一条线程在<strong>阻塞等待</strong>:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>Thread[Thread-0,5,main]start
Thread[Thread-1,5,main]start
Thread[Thread-0,5,main]init DeadLoopClass
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="类加载器"><a href="#类加载器" class="header-anchor">#</a> 类加载器</h4> <p>类加载器是负责加载  <strong>.class 文件</strong>的, 它们在文件开头会有特定的文件标示, 将 class 文件字节码内容加载到内存中, 并将这些内容<strong>转换成方法区中的运行时数据结构</strong>, 并且 ClassLoader 只负责 class 的加载, 而是否能够运行则由 Execution Engine 来决定.</p> <p>Java 虚拟机设计团队有意把类加载阶段中的 &quot;<mark><strong>通过一个类的全限定名来获取描述该类的二进制字节流</strong></mark>&quot; 这个动作放到<strong>虚拟机外部</strong>去实现, 以便<mark><strong>让应用程序自己决定如何去获取所需的类. 实现这个动作的代码被称为 &quot;类加载器&quot;(Class Loader)</strong></mark> .</p> <p>类加载器可以说是 Java 语言的一项创新, 它是早期 Java 语言能够快速流行的重要原因之一. 类加载器最初是为了满足 Java Applet 的需求而设计出来的, 在今天用在浏览器上的 Java Applet 技术基本上已经被淘汰, 但类加载器却在<strong>类层次划分, OSGi, 程序热部署, 代码加密</strong>等领域大放异彩, 成为 Java 技术体系中一块重要的基石, 可谓是失之桑榆, 收之东隅.</p> <h5 id="_1-类与类加载器"><a href="#_1-类与类加载器" class="header-anchor">#</a> 1.类与类加载器</h5> <blockquote><p>类的相等</p></blockquote> <p>类加载器虽然只用于实现类的加载动作, 但它在 Java 程序中起到的作用却远超类加载阶段. <mark><strong>对于任意一个类, 都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性, 每一个类加载器, 都拥有一个独立的类名称空间</strong></mark>. 这句话可以表达得更通俗一些: <strong>比较两个类是否 &quot;相等&quot;, 只有在这两个类是由同一个类加载器加载的前提下才有意义, 否则, 即使这两个类来源于同一个 Class 文件, 被同一个 Java 虚拟机加载, 只要加载它们的类加载器不同, 那这两个类就必定不相等</strong>.</p> <p>这里所指的 &quot;相等&quot;, 包括代表类的 Class 对象的 equals() 方法, isAssignableFrom() 方法, isInstance() 方法的返回结果, 也包括了使用 instanceof 关键字做对象所属关系判定等各种情况. 如果没有注意到类加载器的影响, 在某些情况下可能会产生具有迷惑性的结果, 代码清单 7-8 中演示了不同的类加载器对 instanceof 关键字运算的结果的影响.</p> <blockquote><p>代码清单7-8 不同的类加载器对 instanceof 关键字运算的结果的影响</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * 类加载器与 instanceof 关键字演示
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoaderTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>

        <span class="token class-name">ClassLoader</span> myLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token class-name">String</span> fileName <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">&quot;.&quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">&quot;.class&quot;</span><span class="token punctuation">;</span>
                    <span class="token class-name">InputStream</span> is <span class="token operator">=</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>is <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>is<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    is<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token class-name">Object</span> obj <span class="token operator">=</span> myLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">&quot;org.fenixsoft.classloading.ClassLoaderTest&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>classloading<span class="token punctuation">.</span></span>ClassLoaderTest</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>运行结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>class org.fenixsoft.classloading.ClassLoaderTest
false
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>代码清单 7-8 中构造了一个<strong>简单的类加载器</strong>, 尽管它极为简陋, 但是对于这个演示来说已经足够. 它可以加载与自己在同一路径下的 Class 文件, 这里使用这个类加载器去<strong>加载了一个名为 &quot;org.fenixsoft.classloading.ClassLoaderTest&quot; 的类</strong>, 并实例化了这个类的对象.</p> <p>两行输出结果中, 从第一行可以看到这个对象确实是类 org.fenixsoft.classloading.ClassLoaderTest 实例化出来的, 但在第二行的输出中却发现这个对象与类 org.fenixsoft.classloading.ClassLoaderTest 做所属类型检查的时候返回了 false. 这是<strong>因为 Java 虚拟机中同时存在了两个 ClassLoaderTest 类, 一个是由虚拟机的应用程序类加载器所加载的, 另外一个是由自定义的类加载器加载的</strong>, 虽然它们都来自同一个 Class 文件, 但在 Java 虚拟机中仍然是两个互相独立的类, 做对象所属类型检查时的结果自然为 false.</p> <h5 id="_2-类加载器分类"><a href="#_2-类加载器分类" class="header-anchor">#</a> 2.类加载器分类</h5> <p>站在虚拟机的角度来看, 只存在两种不同的类加载器:</p> <ul><li>一种是<mark><strong>启动类加载器</strong></mark>(Bootstrap ClassLoader), 这个类加载器使用 C++ 语言实现, 是虚拟机自身的一部分.</li> <li>另外一种就是<mark><strong>其他所有的类加载器</strong></mark>, 这些类加载器都由 Java 语言实现, 独立存在于虚拟机外部, 并且<strong>全都继承自抽象类 java.lang.ClassLoader</strong>.</li></ul> <p>站在 Java 开发人员的角度来看, 类加载器就应当划分得更细致一些. 本节内容将针对 JDK 8 及之前版本的 Java 来介绍什么是三层类加载器, 以及什么是双亲委派模型. 对于这个时期的 Java 应用, <strong>绝大多数 Java 程序都会使用到以下 3 个系统提供的类加载器来进行加载</strong>.</p> <ul><li><mark><strong>启动类加载器(Bootstrap Class Loader)</strong></mark> : 前面已经介绍过, 这个类加载器负责加载存放在<code>&lt;JAVA_HOME&gt;\lib</code>​ 目录, 或者被 <code>-Xbootclasspath</code>​ 参数所指定的路径中存放的, 而且是 Java 虚拟机能够识别的(按照文件名识别, 如 rt.jar, tools.jar, 名字不符合的类库即使放在 lib 目录中也不会被加载)类库加载到虚拟机的内存中. <strong>启动类加载器无法被 Java 程序直接引用, 在自定义类加载器时, 如果需要把加载请求委派给启动类加载器, 直接使用 null 代替即可</strong>. 代码清单 7-9 展示的就是 java.lang.ClassLoader.getClassLoader() 方法的代码片段, 其中的注释和代码实现都明确地说明了以 null 值来代表引导类加载器的约定规则.</li> <li><mark><strong>扩展类加载器(Extension Class Loader)</strong></mark> : 这个类加载器是在类 <code>sun.misc.Launcher$ExtClassLoader</code>​ 中以 Java 代码的形式实现的. 它负责加载支撑 JVM 运行的位于 JRE 的 lib 目录下的 ext 扩展目录中的 JAR 类包. 根据 &quot;扩展类加载器&quot; 这个名称, 就可以推断出这是一种 Java <strong>系统类库的扩展机制</strong>, JDK 的开发团队允许用户将具有通用性的类库放置在 ext 目录里以扩展 Java SE 的功能, 在 JDK 9 之后, 这种扩展机制被<strong>模块化</strong>带来的天然的扩展能力所取代. 由于扩展类加载器是由 Java 代码实现的, 开发者可以直接在程序中使用扩展类加载器来加载 Class 文件.</li> <li><mark><strong>应用程序类加载器(Application Class Loader)</strong></mark> : 这个类加载器由 <code>sun.misc.Launcher$AppClassLoader</code>​ 来实现. 由于应用程序类加载器是 ClassLoader 类中的 <code>getSystemClassLoader()</code>​ 方法的返回值, 所以有些场合中也称它为 &quot;系统类加载器&quot;. 它<strong>负责加载用户类路径(ClassPath)上所有的类库, 开发者同样可以直接在代码中使用这个类加载器</strong>. 如果<strong>应用程序中没有自定义过自己的类加载器, 一般情况下这个就是程序中默认的类加载器</strong>.</li></ul> <p>下面是 jre/lib 包下面的一些类库, 可以看看 <strong>Bootstrap ClassLoader</strong> 都加载了什么内容.</p> <p><img src="/img/202303212337895-20230327230316-s4ce3pj.png" alt="202303212337895"></p> <h5 id="_3-双亲委派模型"><a href="#_3-双亲委派模型" class="header-anchor">#</a> 3.双亲委派模型</h5> <h6 id="_1-概述"><a href="#_1-概述" class="header-anchor">#</a> (1)概述</h6> <blockquote><p>双亲委派模型概述</p></blockquote> <p>自 JDK 1.2 以来, Java 一直保持着<strong>三层类加载器, 双亲委派的类加载架构</strong>, 尽管这套架构在 Java 模块化系统出现后有了一些调整变动, 但依然未改变其主体结构, 后面将专门讨论模块化系统下的类加载器.</p> <p>JDK 9 之前的 Java 应用都是由这<strong>三种类加载器互相配合来完成加载</strong>的, 如果用户认为有必要, 还可以加入自定义的类加载器来进行拓展, 典型的如增加除了磁盘位置之外的 Class 文件来源, 或者<strong>通过类加载器实现类的隔离, 重载等功能</strong>. 这些类加载器之间的协作关系 &quot;通常&quot; 会如图 7-2 所示.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522130632761.png" alt="" title="图7-2 双亲委派模型"></p> <p>图 7-2 中展示的各种类加载器之间的层次关系被称为类加载器的 &quot;<mark><strong>双亲委派模型</strong></mark>(Parents Delegation Model)&quot;. <strong>双亲委派模型要求除了顶层的启动类加载器外, 其余的类加载器都应有自己的父类加载器. 不过这里类加载器之间的父子关系一般不是以继承(Inheritance)的关系来实现的, 而是通常使用</strong>​<mark><strong>组合(Composition)关系</strong></mark>​<strong>来复用父加载器的代码</strong>. 比如 AppClassLoader 并不是继承自 ExtClassLoader 类, 只是 AppClassLoader 类中的 <strong>parent 属性</strong>指向的是 ExtClassLoader. 各种类加载器都是继承自抽象类 <code>ClassLoader</code>​.</p> <p>双亲委派模型的工作过程是: <mark><strong>如果一个类加载器收到了类加载的请求, 它首先不会自己去尝试加载这个类, 而是把这个请求委派给父类加载器去完成, 每一个层次的类加载器都是如此, 因此所有的加载请求最终都应该传送到最顶层的启动类加载器中, 只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时, 子加载器才会尝试自己去完成加载</strong></mark>.</p> <p>比如自定义的 Math 类, 最先会找应用程序类加载器加载, 应用程序类加载器会先委托扩展类加载器加载, 扩展类加载器再委托引导类加载器, 顶层引导类加载器在自己的类加载路径里没有找到 Math 类, 则向下退回加载 Math 类的请求, 扩展类加载器收到回复就自己加载, 在自己的类加载路径里也没找到 Math 类, 又向下退回 Math 类的加载请求给应用程序类加载器, 应用程序类加载器于是在自己的类加载路径里找 Math 类, 结果找到了就自己加载了.</p> <p><strong>AppClassLoader 的父类加载器为 ExtClassLoader, ExtClassLoader 的父类加载器为 null, null 并不代表 ExtClassLoader 没有父类加载器, 而是 BootstrapClassLoader, 由于是 C++ 实现, 所以是 null.</strong></p> <p>每一个<strong>类</strong>都有一个对应它的<strong>类加载器</strong>. 系统中的 ClassLoder 在协同工作的时候会默认使用 <strong>双亲委派模型</strong>. 即在类加载的时候, 系统会首先判断当前类是否被加载过. 已经被加载的类会直接返回, 否则才会<strong>尝试加载</strong>.</p> <p>加载的时候, 首先会把该请求<strong>委派该父类加载器</strong>的 <strong>loadClass() 处理</strong>, 因此所有的类加载请求最终都从顶层的启动类加载器 <strong>BootstrapClassLoader</strong> 开始进行. 当父类加载器无法处理时, <strong>子加载器才会尝试自己去加载</strong>. 当父类加载器参数传入为 null 时, 会使用启动类加载器 BootstrapClassLoader 作为父类加载器.</p> <p>读者可能注意到前面描述这种类加载器协作关系时, 专门用双引号强调这是 &quot;<strong>通常</strong>&quot; 的协作关系. 类加载器的双亲委派模型在 JDK 1.2 时期被引入, 并被广泛应用于此后几乎所有的 Java 程序中, 但它并不是一个具有强制性约束力的模型, 而是 Java 设计者们推荐给开发者的一种类加载器实现的最佳实践.</p> <blockquote><p>父类加载器测试示例</p></blockquote> <p>每个类加载都有一个父类加载器, 测试一下.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoaderTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Current ClassLoader is: &quot;</span> <span class="token operator">+</span> <span class="token class-name">ClassLoaderTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;The Parent ClassLoader is: &quot;</span> <span class="token operator">+</span> <span class="token class-name">ClassLoaderTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;The GrandParent ClassLoader is: &quot;</span> <span class="token operator">+</span> <span class="token class-name">ClassLoaderTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Current</span> <span class="token class-name">ClassLoader</span> is<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">jdk<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>loader<span class="token punctuation">.</span></span>ClassLoaders</span>$<span class="token class-name">AppClassLoader</span><span class="token annotation punctuation">@1f89ab83</span>
<span class="token class-name">The</span> <span class="token class-name">Parent</span> <span class="token class-name">ClassLoader</span> is<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">jdk<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>loader<span class="token punctuation">.</span></span>ClassLoaders</span>$<span class="token class-name">PlatformClassLoader</span><span class="token annotation punctuation">@340f438e</span>
<span class="token class-name">The</span> <span class="token class-name">GrandParent</span> <span class="token class-name">ClassLoader</span> is<span class="token operator">:</span> <span class="token keyword">null</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><p>为什么要有双亲委派模型?</p></blockquote> <p>使用双亲委派模型来组织类加载器之间的关系, 一个显而易见的<strong>好处</strong>就是 Java 中的<strong>类随着它的类加载器一起具备了一种带有优先级的层次关系, 从而使得基础类得到统一</strong>. 双亲委派模型可以<strong>避免类的重复加载</strong>, 也保证了 Java 的<strong>核心 API 优先加载不被篡改</strong>. 例如类 java.lang.Object, 它存放在 rt.jar 之中, 无论哪一个类加载器要加载这个类, 最终都是委派给处于模型最顶端的启动类加载器进行加载, 因此 Object 类在程序的各种类加载器环境中都能够保证是同一个类. 反之, 如果没有使用双亲委派模型, 都由各个类加载器自行去加载的话, 如果用户自己也编写了一个名为 java.lang.Object 的类, 并放在程序的 ClassPath 中, 那系统中就会出现多个不同的 Object 类, Java 类型体系中最基础的行为也就无从保证, 应用程序将会变得一片混乱. 如果读者有兴趣的话, 可以尝试去写一个与 rt.jar 类库中已有类重名的 Java 类, 将会发现它可以正常编译, 但永远无法被加载运行.</p> <p><strong>总结为什么要设计双亲委派机制? 为了核心类安全与防止类的重复加载</strong>.</p> <ul><li><strong>沙箱安全机制</strong>: 自己写的 java.lang.String.class 类不会被加载, 这样便可以防止核心 API 库被随意篡改.</li> <li><strong>避免类的重复加载</strong>: 当父亲已经加载了该类时, 就没有必要被子 ClassLoader 再加载一次, 保证<strong>被加载类的唯一性</strong>.</li></ul> <p>看一个类加载示例:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 这里包名与JDK的String类一样</span>
<span class="token keyword">package</span> <span class="token namespace">java<span class="token punctuation">.</span>lang</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;My String Class.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>运行结果:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>错误<span class="token operator">:</span> 在类 <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span> 中找不到 main 方法<span class="token punctuation">,</span> 请将 main 方法定义为<span class="token operator">:</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
否则 <span class="token class-name">JavaFX</span> 应用程序类必须扩展<span class="token class-name"><span class="token namespace">javafx<span class="token punctuation">.</span>application<span class="token punctuation">.</span></span>Application</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>注意这里需要加载的是 java.lang.String.class, 由于这个类已经被父加载器加载了, 所以直接就认为已经加载过这个类了, 也就是 JDK 中的 String 类, 也就不会再加载自己写的这个 String 类了; 但是 JDK 的 String 类中没有 main 方法, 因此会报错. 这样就保证了核心类库无法被修改.</p> <blockquote><p>全盘负责委托机制</p></blockquote> <p>&quot;<strong>全盘负责</strong>&quot; 是指当一个 ClassLoder 装载一个<strong>类</strong>时, 除非显示的使用另外一个 ClassLoder, 否则<strong>该类所依赖及引用的类也由这个 ClassLoder 载入</strong>.</p> <p>注: 双亲委派模型是 Java 设计者们推荐给开发者们的一种类加载器实现方式, 并不是一个强制性的约束模型. 在 Java 的世界中大部分的类加载器都遵循这个模型, 但也有例外.</p> <h6 id="_2-双亲委派机制源码分析"><a href="#_2-双亲委派机制源码分析" class="header-anchor">#</a> (2)双亲委派机制源码分析</h6> <p>双亲委派模型对于保证 Java 程序的稳定运作极为重要, 但它的实现却异常简单. AppClassLoader 也是 <code>ClassLoader</code>​ 的子类. 看下应用程序类加载器 AppClassLoader 加载类的双亲委派机制源码, AppClassLoader 的 loadClass() 方法最终会调用其父类 <strong>ClassLoader</strong> 的 <strong>loadClass()</strong>  方法, 该方法的大体逻辑如下, 这段逻辑就解释了双亲委派模型的整体实现:</p> <blockquote><p>代码清单7-10 双亲委派模型的实现</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">;</span>

<span class="token comment">// ClassLoader类的loadClass()方法, 里面实现了双亲委派机制</span>
<span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 检查当前类加载器是否已经加载了该类</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">long</span> t0 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果当前加载器的父加载器不为空则委托父加载器进行类加载</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 如果当前加载器的父加载器为空则委托Bootstrap类加载器进行类加载</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  
                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// ClassNotFoundException thrown if class not found</span>
                <span class="token comment">// from the non-null parent class loader</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">long</span> t1 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 都会调用URLClassLoader的findClass方法在加载器的类路径里查找并加载该类</span>
                c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
                <span class="token comment">// this is the defining class loader; record the stats</span>
                <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 不会执行</span>
            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><p>这段代码的逻辑清晰易懂: <strong>先检查请求加载的类型是否已经被加载过, 若没有加载过则调用父加载器的 loadClass() 方法, 若父加载器为空则默认使用启动类加载器作为父加载器. 假如父类加载器加载失败, 抛出 ClassNotFoundException 异常的话, 才调用自己的 findClass() 方法尝试进行加载</strong>.</p> <h5 id="_4-自定义类加载器"><a href="#_4-自定义类加载器" class="header-anchor">#</a> 4.自定义类加载器</h5> <p>自定义类加载器的优势: 高度的灵活性, 通过自定义类加载器可以实现热部署, 代码加密等. 自定义类加载器应用实例: <strong>Tomcat, OSGi</strong> 等.</p> <p><strong>ClassLoader 类</strong>的 loadClass() 方法实现了双亲委派模型. 在 loadClass() 中会使用到 findClass() 方法, 这个方法默认实现是抛异常, 如果子类覆写了这个方法就可以走子类的逻辑. <mark><strong>自定义类加载器只需要继承 java.lang.ClassLoader 抽象类, 并覆写 findClass() 方法</strong></mark>.</p> <blockquote><p>自定义类加载器示例1: MyClassLoader</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> classPath<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MyClassLoader</span><span class="token punctuation">(</span><span class="token class-name">String</span> classPath<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>classPath <span class="token operator">=</span> classPath<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/** 覆写findClass方法 */</span>
    <span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token function">loadByte</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// defineClass()方法将一个字节数组转为Class对象, 这个字节数组是class文件读取后最终的字节数组</span>
            <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">loadByte</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">&quot;\\.&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">FileInputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>classPath <span class="token operator">+</span> <span class="token string">&quot;/&quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot;.class&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
        fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>以下代码中的 FileSystemClassLoader 是<strong>自定义</strong>类加载器, 用于加载<strong>文件系统</strong>上的类. 它首先根据类的全名在文件系统上查找类的字节代码文件(.class 文件), 然后<strong>读取</strong>该文件内容, 最后通过 <strong>defineClass()</strong>  方法来把这些字节代码转换成 <strong>java.lang.Class 类</strong>的实例.</p> <blockquote><p>自定义类加载器示例2: FileSystemClassLoader</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 自定义文件系统类加载器</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileSystemClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> rootDir<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">FileSystemClassLoader</span><span class="token punctuation">(</span><span class="token class-name">String</span> rootDir<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>rootDir <span class="token operator">=</span> rootDir<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 覆写findClass方法</span>
    <span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classData <span class="token operator">=</span> <span class="token function">getClassData</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>classData <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> classData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> classData<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getClassData</span><span class="token punctuation">(</span><span class="token class-name">String</span> className<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> path <span class="token operator">=</span> <span class="token function">classNameToPath</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">InputStream</span> ins <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">ByteArrayOutputStream</span> baos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> bufferSize <span class="token operator">=</span> <span class="token number">4096</span><span class="token punctuation">;</span>
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>bufferSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> bytesNumRead<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytesNumRead <span class="token operator">=</span> ins<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                baos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bytesNumRead<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> baos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">classNameToPath</span><span class="token punctuation">(</span><span class="token class-name">String</span> className<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> rootDir <span class="token operator">+</span> <span class="token class-name">File</span><span class="token punctuation">.</span>separatorChar
                <span class="token operator">+</span> className<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">,</span> <span class="token class-name">File</span><span class="token punctuation">.</span>separatorChar<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;.class&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><p>由于 AppClassLoader 在初始化的时候会初始化 ClassLoader 类, 然后其构造方法会通过 getSystemClassLoader() 获取到 AppClassLoader, 并将其幅值给自定义类加载器的 parent 属性, 因此<strong>自定义的类加载器的父加载器默认是 AppClassLoader, 这也与上图中自定义类加载器指向 AppClassLoader 是一致的</strong>.</p> <blockquote><p>ClassLoader构造器源码</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token function">checkCreateClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">(</span><span class="token class-name">Void</span> unused<span class="token punctuation">,</span> <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// getSystemClassLoader()获取的AppClassLoader幅值给自定义类加载器的parent属性</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ParallelLoaders</span><span class="token punctuation">.</span><span class="token function">isRegistered</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        parallelLockMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        package2certs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        domains <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedSet</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProtectionDomain</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        assertionLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// no finer-grained lock; lock on the classloader instance</span>
        parallelLockMap <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        package2certs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hashtable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        domains <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        assertionLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h5 id="_5-破坏双亲委派模型"><a href="#_5-破坏双亲委派模型" class="header-anchor">#</a> 5.破坏双亲委派模型</h5> <h6 id="_1-打破方式"><a href="#_1-打破方式" class="header-anchor">#</a> (1)打破方式</h6> <p><strong>双亲委派机制是在 loadClass() 方法中实现的, 要打破这个机制就可以从修改这个方法入手. 其实就是直接覆写 loadClass() 方法, 使得 loadClass() 方法不再委托父加载器加载类</strong>, 而是实现自己的<strong>加载逻辑</strong>, 不委派给双亲加载, <strong>由此打破了双亲委派机制</strong>.</p> <blockquote><p>使用自定义类加载器打破双亲委派机制实例</p></blockquote> <p>由于存在安全沙箱机制, 系统核心的类一般是不让自定义类加载器进行加载的, 因此下面的自定义类加载器是对需要加载的类进行了判断, 如果是自己的业务包则直接用自定义类加载器加载, 否则依然走双亲委派机制加载.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClassLoaderV2</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> classPath<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MyClassLoaderV2</span><span class="token punctuation">(</span><span class="token class-name">String</span> classPath<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>classPath <span class="token operator">=</span> classPath<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 重写类加载方法, 实现自己的加载逻辑, 不委派给双亲加载</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// First, check if the class has already been loaded</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// If still not found, then invoke findClass in order</span>
                <span class="token comment">// to find the class.</span>
                <span class="token keyword">long</span> t1 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
                <span class="token comment">// 自己的业务包直接用本加载器加载</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&quot;com.nano&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
                    <span class="token comment">// 其余类依然走双亲委派机制加载</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    c <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
  
                <span class="token comment">// this is the defining class loader; record the stats</span>
                <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> c<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/** 覆写方法 */</span>
    <span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token function">loadByte</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// defineClass()方法将一个字节数组转为Class对象, 这个字节数组是class文件读取后最终的字节数组</span>
            <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">loadByte</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">&quot;\\.&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">FileInputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>classPath <span class="token operator">+</span> <span class="token string">&quot;/&quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot;.class&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
        fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br></div></div><h6 id="_2-被破坏实例"><a href="#_2-被破坏实例" class="header-anchor">#</a> (2)被破坏实例</h6> <p>上文提到过双亲委派模型<strong>并不是一个具有强制性约束的模型</strong>, 而是 Java 设计者推荐给开发者们的类加载器实现方式. 在 Java 的世界中大部分的类加载器都遵循这个模型, 但也有例外的情况, 直到 Java 模块化出现为止, 双亲委派模型主要<strong>出现过 3 次较大规模 &quot;被破坏&quot; 的情况</strong>.</p> <blockquote><p>第一次破坏</p></blockquote> <p>双亲委派模型的第一次 &quot;被破坏&quot; 其实发生在双亲委派模型出现之前--即 JDK 1.2 面世以前的 &quot;远古&quot; 时代. 由于双亲委派模型在 JDK 1.2 之后才被引入, 但是类加载器的概念和抽象类 java.lang.ClassLoader 则在 Java 的第一个版本中就已经存在, 面对已经存在的用户自定义类加载器的代码, Java 设计者们引入双亲委派模型时不得不做出一些妥协, 为了兼容这些已有代码, 无法再以技术手段避免 loadClass() 被子类覆盖的可能性, 只能在 JDK 1.2 之后的 java.lang.ClassLoader 中添加一个新的 protected 方法 findClass(), 并引导用户编写的类加载逻辑时尽可能去重写这个方法, 而不是在 loadClass() 中编写代码. 上节已经分析过 loadClass() 方法, 双亲委派的具体逻辑就实现在这里面, 按照 loadClass() 方法的逻辑, 如果父类加载失败, 会自动调用自己的 findClass() 方法来完成加载, 这样既不影响用户按照自己的意愿去加载类, 又可以保证新写出来的类加载器是符合双亲委派规则的.</p> <blockquote><p>第二次破坏</p></blockquote> <p>双亲委派模型的第二次 &quot;被破坏&quot; 是由这个模型自身的缺陷导致的, 双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题(越基础的类由越上层的加载器进行加载), 基础类型之所以被称为 &quot;基础&quot;, 是因为它们总是作为被用户代码继承, 调用的 API 存在, 但程序设计往往没有绝对不变的完美规则, <strong>如果有基础类型又要调用回用户的代码, 那该怎么办呢</strong>?</p> <p>这并非是不可能出现的事情, 一个典型的例子便是 JNDI 服务, JNDI 现在已经是 Java 的标准服务, 它的代码由启动类加载器来完成加载(在 JDK 1.3 时加入到 rt.jar 的), 肯定属于 Java 中很基础的类型了. 但 JNDI 存在的目的就是对资源进行查找和集中管理, 它需要调用由其他厂商实现并部署在应用程序的 ClassPath 下的 JNDI 服务提供者接口(Service Provider Interface, SPI)的代码, 现在问题来了, 启动类加载器是绝不可能认识, 加载这些代码的, 那该怎么办?</p> <p>为了解决这个困境, Java 的设计团队只好引入了一个不太优雅的设计: <strong>线程上下文类加载器(Thread Context ClassLoader)</strong> . 这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader() 方法进行设置, 如果创建线程时还未设置, 它将会从父线程中继承一个, 如果在应用程序的全局范围内都没有设置过的话, 那这个类加载器默认就是应用程序类加载器.</p> <p>有了线程上下文类加载器, 程序就可以做一些 &quot;舞弊&quot; 的事情了. JNDI 服务使用这个线程上下文类加载器去加载所需的 SPI 服务代码, 这是<strong>一种父类加载器去请求子类加载器完成类加载的行为</strong>, 这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器, 已经违背了双亲委派模型的一般性原则, 但也是无可奈何的事情. <strong>Java 中涉及 SPI 的加载基本上都采用这种方式来完成, 例如 JNDI, JDBC, JCE, JAXB 和 JBI 等</strong>. 不过, 当 SPI 的服务提供者多于一个的时候, 代码就只能根据具体提供者的类型来硬编码判断, 为了消除这种极不优雅的实现方式, 在 JDK 6 时, JDK 提供了 java.util.ServiceLoader 类, 以 <code>META-INF/services</code>​ 中的配置信息, 辅以责任链模式, 这才算是给 SPI 的加载提供了一种相对合理的解决方案.</p> <blockquote><p>第三次破坏</p></blockquote> <p>双亲委派模型的第三次 &quot;被破坏&quot; 是由于<strong>用户对</strong>​<mark><strong>程序动态性</strong></mark>​<strong>的追求而导致的</strong>, 这里所说的 &quot;动态性&quot; 指的是一些非常 &quot;热&quot; 门的名词: <strong>代码热替换(Hot Swap), 模块热部署(Hot Deployment)</strong> 等. 说白了就是希望 Java 应用程序能像电脑外设那样, 接上鼠标, U 盘, 不用重启机器就能立即使用, 鼠标有问题或要升级就换个鼠标, 不用关机也不用重启. 对于个人电脑来说, 重启一次其实没有什么大不了的, 但对于一些生产系统来说, 关机重启一次可能就要被列为生产事故, 这种情况下热部署就对软件开发者, 尤其是大型系统或企业级软件开发者具有很大的吸引力.</p> <p>先来简单看一看 OSGi 是如何通过类加载器实现热部署的. <strong>OSGi 实现模块化热部署的关键是它自定义的类加载器机制的实现, 每一个程序模块(OSGi 中称为 Bundle)都有一个自己的类加载器, 当需要更换一个 Bundle 时, 就把 Bundle 连同类加载器一起换掉以实现代码的热替换</strong>. 在 OSGi 环境下, 类加载器不再双亲委派模型推荐的树状结构, 而是进一步发展为更加复杂的<strong>网状结构</strong>, 当收到类加载请求时, OSGi 将按照下面的顺序进行类搜索:</p> <ol><li>将以 java.* 开头的类, 委派给父类加载器加载.</li> <li>否则, 将委派列表名单内的类, 委派给父类加载器加载.</li> <li>否则, 将 Import 列表中的类, 委派给 Export 这个类的 Bundle 的类加载器加载.</li> <li>否则, 查找当前 Bundle 的 ClassPath, 使用自己的类加载器加载.</li> <li>否则, 查找类是否在自己的 Fragment Bundle 中, 如果在, 则委派给 Fragment Bundle 的类加载器加载.</li> <li>否则, 查找 Dynamic Import 列表的 Bundle, 委派给对应 Bundle 的类加载器加载.</li> <li>否则, 类查找失败.</li></ol> <p>上面的查找顺序中<strong>只有开头两点仍然符合双亲委派模型的原则</strong>, 其余的类查找都是在<strong>平级的类加载器</strong>中进行的, 关于 OSGi 的其他内容, 就不再展开了.</p> <p>本节中虽然使用了 &quot;被破坏&quot; 这个词来形容上述不符合双亲委派模型原则的行为, 但这里 &quot;被破坏&quot; 并不一定是带有贬义的. 只要有明确的目的和充分的理由, 突破旧有原则无疑是一种创新. 正如 OSGi 中的类加载器的设计不符合传统的双亲委派的类加载器架构, 且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议, 但对这方面有了解的技术人员基本还是能达成一个共识, 认为 OSGi 中对类加载器的运用是值得学习的, 完全弄懂了 OSGi 的实现, 就算是掌握了类加载器的精粹.</p> <h4 id="java模块化系统"><a href="#java模块化系统" class="header-anchor">#</a> Java模块化系统</h4> <p>在 JDK 9 中引入的 Java <strong>模块化系统</strong>(Java Platform Module System, <strong>JPMS</strong>)是对 Java 技术的一次重要升级, 为了能够实现模块化的关键目标---<mark><strong>可配置的封装隔离机制</strong></mark>, Java 虚拟机<strong>对类加载架构也做出了相应的变动调整</strong>, 才使模块化系统得以顺利地运作. JDK 9 的模块不仅仅像之前的 JAR 包那样只是简单地充当代码的容器, 除了代码外, Java 的模块定义还包含以下内容:</p> <ul><li>依赖其他模块的列表.</li> <li>导出的包列表, 即其他模块可以使用的列表.</li> <li>开放的包列表, 即其他模块可反射访问模块的列表.</li> <li>使用的服务列表.</li> <li>提供服务的实现列表.</li></ul> <p>可配置的封装隔离机制首先<strong>要解决 JDK 9 之前基于类路径(ClassPath)来查找依赖的可靠性问题</strong>. 此前, 如果类路径中缺失了运行时依赖的类型, 那就只能等程序运行到发生该类型的加载, 链接时才会报出运行的异常. 而在 JDK 9 以后, 如果启用了模块化进行封装, 模块就可以声明对其他模块的显式依赖, 这样 Java 虚拟机就能够<strong>在启动时验证应用程序开发阶段设定好的依赖关系在运行期是否完备</strong>, 如有缺失那就直接启动失败, 从而避免了很大一部分由于类型依赖而引发的运行时异常.</p> <p>可配置的封装隔离机制还<strong>解决了原来类路径上跨 JAR 文件的 public 类型的可访问性问题</strong>. JDK 9 中的 public 类型不再意味着程序的所有地方的代码都可以随意访问到它们, 模块提供了更精细的可访问性控制, 必须明确声明其中哪一些 public 的类型可以被其他哪一些模块访问, 这种访问控制也主要是在类加载过程中完成的, 具体内容在前文对解析阶段的讲解中已经介绍过.</p> <h5 id="_1-模块的兼容性"><a href="#_1-模块的兼容性" class="header-anchor">#</a> 1.模块的兼容性</h5> <p>为了使可配置的封装隔离机制能够兼容传统的类路径查找机制, JDK 9 提出了与 &quot;类路径&quot;(ClassPath)相对应的 &quot;<strong>模块路径</strong>&quot;(ModulePath)的概念. 简单来说, 就是某个类库到底是模块还是传统的 JAR 包, 只取决于它存放在哪种路径上. 只要是放在类路径上的 JAR 文件, 无论其中是否包含模块化信息(是否包含了 module-info.class 文件), 它都会被当作传统的 JAR 包来对待; 相应地, 只要放在模块路径上的 JAR 文件, 即使没有使用 JMOD 后缀, 甚至说其中并不包含 module-info.class 文件, 它也仍然会被当作一个模块来对待.</p> <p>模块化系统将按照以下规则来保证使用传统类路径依赖的 Java 程序可以不经修改地直接运行在 JDK 9 及以后的 Java 版本上, 即使这些版本的 JDK 已经使用模块来封装了 Java SE 的标准类库, 模块化系统的这套规则也仍然保证了传统程序可以访问到所有标准类库模块中导出的包.</p> <ul><li>JAR 文件在类路径的访问规则: 所有类路径下的 JAR 文件及其他资源文件, 都被视为自动打包在一个匿名模块(Unnamed Module)里, 这个匿名模块几乎是没有任何隔离的, 它可以看到和使用类路径上所有的包, JDK 系统模块中所有的导出包, 以及模块路径上所有模块中导出的包.</li> <li>模块在模块路径的访问规则: 模块路径下的具名模块(Named Module)只能访问到它依赖定义中列明依赖的模块和包, 匿名模块里所有的内容对具名模块来说都是不可见的, 即具名模块看不见传统 JAR 包的内容.</li> <li>JAR 文件在模块路径的访问规则: 如果把一个传统的, 不包含模块定义的 JAR 文件放置到模块路径中, 它就会变成一个自动模块(Automatic Module). 尽管不包含 module-info.class, 但自动模块将默认依赖于整个模块路径中的所有模块, 因此可以访问到所有模块导出的包, 自动模块也默认导出自己所有的包.</li></ul> <p>以上 3 条规则保证了即使 Java 应用依然使用传统的类路径, 升级到 JDK 9 对应用来说几乎(类加载器上的变动还是可能会导致少许可见的影响, 将在下节介绍)不会有任何感觉, 项目也不需要专门为了升级 JDK 版本而去把传统 JAR 包升级成模块.</p> <p>除了向后兼容性外, 随着 JDK 9 模块化系统的引入, 更值得关注的是它本身面临的模块间的管理和兼容性问题: 如果同一个模块发行了多个不同的版本, 那只能由开发者在编译打包时人工选择好正确版本的模块来保证依赖的正确性. Java 模块化系统目前不支持在模块定义中加入版本号来管理和约束依赖, 本身也不支持多版本号的概念和版本选择功能. 前面这句话引来过很多的非议, 但它确实是 Oracle 官方对模块化系统的明确的目标说明. 不论是在 Java 命令, Java 类库的 API 抑或是《Java 虚拟机规范》定义的 Class 文件格式里都能轻易地找到证据, 表明模块版本应是编译, 加载, 运行期间都可以使用的. 譬如输入 &quot;java--list-modules&quot;, 会得到明确带着版本号的模块列表:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>java<span class="token punctuation">.</span>base@<span class="token number">12.0</span><span class="token number">.1</span>
java<span class="token punctuation">.</span>compiler@<span class="token number">12.0</span><span class="token number">.1</span>
java<span class="token punctuation">.</span>datatransfer@<span class="token number">12.0</span><span class="token number">.1</span>
java<span class="token punctuation">.</span>desktop@<span class="token number">12.0</span><span class="token number">.1</span>
java<span class="token punctuation">.</span>instrument@<span class="token number">12.0</span><span class="token number">.1</span>
java<span class="token punctuation">.</span>logging@<span class="token number">12.0</span><span class="token number">.1</span>
java<span class="token punctuation">.</span>management@<span class="token number">12.0</span><span class="token number">.1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在 JDK 9 时加入 Class 文件格式的 Module 属性, 里面有 module_version_index 这样的字段, 用户可以在编译时使用 &quot;javac --module-version&quot; 来指定模块版本, 在 Java 类库 API 中也存在 java.lang.module.ModuleDescriptor.Version 这样的接口可以在运行时获取到模块的版本号. 这一切迹象都证明了 Java 模块化系统对版本号的支持本可以不局限在编译期. 而官方却在 Jigsaw 的规范文件, JavaOne 大会的宣讲和与专家的讨论列表中, 都反复强调 &quot;JPMS 的目的不是代替 OSGi&quot;, &quot;JPMS 不支持模块版本&quot; 这样的话语.</p> <p>Oracle 给出的理由是希望维持一个足够简单的模块化系统, 避免技术过于复杂. 但结合 JCP 执行委员会关于的 Jigsaw 投票中 Oracle 与 IBM, RedHat 的激烈冲突, 实在很难让人信服这种设计只是单纯地基于技术原因, 而不是厂家之间互相博弈妥协的结果. Jigsaw 仿佛在刻意地给 OSGi 让出一块生存空间, 以换取 IBM 支持或者说不去反对 Jigsaw, 其代价就是几乎宣告 Java 模块化系统不可能拥有像 OSGi 那样支持多版本模块并存, 支持运行时热替换, 热部署模块的能力, 可这却往往是一个应用进行模块化的最大驱动力所在. 如果要在 JDK 9 之后实现这种目的, 就只能将 OSGi 和 JPMS 混合使用, 如图 7-4 所示, 这无疑带来了更高的复杂度. 模块的运行时部署, 替换能力没有内置在 Java 模块化系统和 Java 虚拟机之中, 仍然必须通过类加载器去实现, 实在不得不说是一个缺憾.</p> <p>其实 Java <strong>虚拟机内置的 JVMTI 接口(java.lang.instrument.Instrumentation)提供了一定程度的运行时修改类的能力(RedefineClass, RetransformClass)</strong> , 但这种修改能力会受到很多限制, 不可能直接用来实现 OSGi 那样的热替换和多版本并存, 用在 IntelliJ IDE, Eclipse 这些 IDE 上做 HotSwap(是指 IDE 编辑方法的代码后不需要重启即可生效)倒是非常的合适.</p> <p><img src="/img/Image00170-20240302133505-aui8ju6.jpg" alt="" title="图7-4　OSGi 与 JPMS 交互"></p> <h5 id="_2-模块化下的类加载器模型"><a href="#_2-模块化下的类加载器模型" class="header-anchor">#</a> 2.模块化下的类加载器模型</h5> <blockquote><p>JDK9后模块化系统下的类加载器模型</p></blockquote> <p>为了保证兼容性, JDK 9 并没有从根本上动摇从 JDK 1.2 以来运行了二十年之久的三层类加载器架构以及双亲委派模型. 但是为了模块化系统的顺利施行, 模块化下的类加载器仍然发生了一些应该被注意到变动, 主要包括以下几个方面.</p> <p>首先, 是<mark><strong>扩展类加载器(Extension Class Loader)被平台类加载器(Platform Class Loader)取代</strong></mark>. 这其实是一个很顺理成章的变动, 既然<strong>整个 JDK 都基于模块化进行构建</strong>(原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件), 其中的 Java 类库就已天然地满足了可扩展的需求, 那自然无须再保留 <code>&lt;JAVA_HOME&gt;\lib\ext</code>​ 目录, 此前使用这个目录或者 <code>java.ext.dirs</code>​ 系统变量来扩展 JDK 功能的机制已经没有继续存在的价值了, 用来加载这部分类库的扩展类加载器也完成了它的历史使命. 类似地, 在新版的 JDK 中也取消了 <code>&lt;JAVA_HOME&gt;\jre</code>​ 目录, 因为随时可以组合构建出程序运行所需的 JRE 来, 譬如假设只使用 java.base 模块中的类型, 那么随时可以通过以下命令打包出一个 &quot;JRE&quot;:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>jlink -p $JAVA_HOME/jmods --add-modules java.base --output jre
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其次, <strong>平台类加载器和应用程序类加载器都不再派生自 java.net.URLClassLoader, 如果有程序直接依赖了这种继承关系, 或依赖了 URLClassLoader 类的特定方法, 那代码很可能会在 JDK9 及更高版本的 JDK 中崩溃</strong>. 现在<mark><strong>启动类加载器, 平台类加载器, 应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader, 在 BuiltinClassLoader 中实现了新的模块化架构下类如何从模块中加载的逻辑, 以及模块中资源可访问性的处理</strong></mark>. 两者的前后变化如图 7-5 和 7-6 所示.</p> <p><img src="/img/Image00171-20240302133505-enj5z67.jpg" alt="" title="图7-5　JDK 9之前的类加载器继承架构"></p> <p><img src="/img/Image00172-20240302133505-v2yrqly.jpg" alt="" title="图7-6　JDK 9及以后的类加载器继承架构"></p> <p>另外, 读者可能已经注意到图 7-6 中有 &quot;BootClassLoader&quot; 存在, <strong>启动类加载器现在是在 Java 虚拟机内部和 Java 类库共同协作实现的类加载器</strong>, 尽管有了 BootClassLoader 这样的 Java 类, 但为了与之前的代码保持兼容, 所有在获取启动类加载器的场景(譬如 Object.class.getClassLoader()) 中仍然会返回 null 来代替, 而不会得到 BootClassLoader 的实例.</p> <p><img src="/img/image-20240717230834-3kej5qy.png" alt="image" title="图7-7　JDK 9后的类加载器委派关系"></p> <p>最后, JDK 9 中虽然仍然维持着三层类加载器和双亲委派的架构, <mark><strong>但类加载的委派关系也发生了变动</strong></mark>. 当<strong>平台及应用程序类加载器收到类加载请求, 在委派给父加载器加载前, 要先判断该类是否能够归属到某一个系统模块中, 如果可以找到这样的归属关系, 就要优先委派给负责那个模块的加载器完成加载, 也许这可以算是对双亲委派的第四次破坏</strong>. 在 JDK 9 以后的三层类加载器的架构如图 7-7 所示, 请对照图进行比较.</p> <p>​<img src="/img/image-20240717231014-ojof1by.png" alt="image">​</p> <blockquote><p>各个类加载器加载的模块</p></blockquote> <p>在 Java 模块化系统明确规定了<strong>三个类加载器负责各自加载的模块</strong>, 即前面所说的归属关系, 如下所示.</p> <ul><li><strong>启动类加载器负责加载的模块:</strong></li></ul> <div class="language-c line-numbers-mode"><pre class="language-c"><code>java<span class="token punctuation">.</span>base                        java<span class="token punctuation">.</span>security<span class="token punctuation">.</span>sasl
java<span class="token punctuation">.</span>datatransfer                java<span class="token punctuation">.</span>xml
java<span class="token punctuation">.</span>desktop                     jdk<span class="token punctuation">.</span>httpserver
java<span class="token punctuation">.</span>instrument                  jdk<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>vm<span class="token punctuation">.</span>ci
java<span class="token punctuation">.</span>logging                     jdk<span class="token punctuation">.</span>management
java<span class="token punctuation">.</span>management                  jdk<span class="token punctuation">.</span>management<span class="token punctuation">.</span>agent
java<span class="token punctuation">.</span>management<span class="token punctuation">.</span>rmi              jdk<span class="token punctuation">.</span>naming<span class="token punctuation">.</span>rmi
java<span class="token punctuation">.</span>naming                      jdk<span class="token punctuation">.</span>net
java<span class="token punctuation">.</span>prefs                       jdk<span class="token punctuation">.</span>sctp
java<span class="token punctuation">.</span>rmi                         jdk<span class="token punctuation">.</span>unsupported
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ul><li><strong>平台类加载器负责加载的模块:</strong></li></ul> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>java.activation*                jdk.accessibility
java.compiler*                  jdk.charsets
java.corba*                     jdk.crypto.cryptoki
java.scripting                  jdk.crypto.ec
java.se                         jdk.dynalink
java.se.ee                      jdk.incubator.httpclient
java.security.jgss              jdk.internal.vm.compiler*
java.smartcardio                jdk.jsobject
java.sql                        jdk.localedata
java.sql.rowset                 jdk.naming.dns
java.transaction*               jdk.scripting.nashorn
java.xml.bind*                  jdk.security.auth
java.xml.crypto                 jdk.security.jgss
java.xml.ws*                    jdk.xml.dom
java.xml.ws.annotation*         jdk.zipfs
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ul><li><strong>应用程序类加载器负责加载的模块:</strong></li></ul> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>jdk.aot                         jdk.jdeps
jdk.attach                      jdk.jdi
jdk.compiler                    jdk.jdwp.agent
jdk.editpad                     jdk.jlink
jdk.hotspot.agent               jdk.jshell
jdk.internal.ed                 jdk.jstatd
jdk.internal.jvmstat            jdk.pack
jdk.internal.le                 jdk.policytool
jdk.internal.opt                jdk.rmic
jdk.jartool                     jdk.scripting.nashorn.shell
jdk.javadoc                     jdk.xml.bind*
jdk.jcmd                        jdk.xml.ws*
jdk.jconsole
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="本章小结"><a href="#本章小结" class="header-anchor">#</a> 本章小结</h4> <p>本章介绍了类加载过程的 &quot;加载&quot;, &quot;验证&quot;, &quot;准备&quot;, &quot;解析&quot; 和 &quot;初始化&quot; 这 5 个阶段中虚拟机进行了哪些动作, 还介绍了类加载器的工作原理及其对虚拟机的意义.</p> <p>经过第 6, 7 章的讲解, 相信读者已经对如何在 Class 文件中定义类, 以及如何将类加载到虚拟机之中这两个问题有了一个比较系统的了解, 第 8 章将探索 Java 虚拟机的执行引擎, 一起来<strong>看看虚拟机如何执行定义在 Class 文件里的字节码</strong>.</p> <p>‍</p> <p>‍</p> <p>‍</p> <h4 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h4> <ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://coolshell.cn/articles/9229.html" target="_blank" rel="noopener noreferrer">https://coolshell.cn/articles/9229.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/luanlouis/article/details/39960815" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/luanlouis/article/details/39960815<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>《实战 Java 虚拟机》</li> <li><a href="https://blog.csdn.net/xiaobao5214/article/details/81674215" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/xiaobao5214/article/details/81674215<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/xyang81/article/details/7292380" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/xyang81/article/details/7292380<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.im/post/5c04892351882516e70dcc9b" target="_blank" rel="noopener noreferrer">https://juejin.im/post/5c04892351882516e70dcc9b<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://gityuan.com/2016/01/24/java-classloader/" target="_blank" rel="noopener noreferrer">http://gityuan.com/2016/01/24/java-classloader/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/qq_31777123/article/details/80036682" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_31777123/article/details/80036682<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/20.开发/2000.Java/600.JVM/31.虚拟机类加载机制🌼.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/16a914/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">类文件结构🌼</div></a> <a href="/pages/6367b0/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">虚拟机字节码执行引擎🌼</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/16a914/" class="prev">类文件结构🌼</a></span> <span class="next"><a href="/pages/6367b0/">虚拟机字节码执行引擎🌼</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/83.771cced1.js" defer></script>
  </body>
</html>
