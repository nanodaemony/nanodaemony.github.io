<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>传输层 | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/40.1509d08b.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>计算机基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b49252/" class="sidebar-link">深入浅出计算机组成原理(极客)</a></li><li><a href="/pages/c470a4/" class="sidebar-link">CSAPP🌟</a></li><li><a href="/pages/8b1d1a/" class="sidebar-link">密码学🐳</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>操作系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/9f0749/" class="sidebar-link">操作系统基础</a></li><li><a href="/pages/455709/" class="sidebar-link">进程管理</a></li><li><a href="/pages/0e463b/" class="sidebar-link">内存管理</a></li><li><a href="/pages/2617e7/" class="sidebar-link">外设管理🌼</a></li><li><a href="/pages/c00f84/" class="sidebar-link">IO模型🌼</a></li><li><a href="/pages/d913bf/" class="sidebar-link">Linux基础🌼</a></li><li><a href="/pages/4af92e/" class="sidebar-link">Linux文件系统与文件🌼</a></li><li><a href="/pages/713f76/" class="sidebar-link">Linux系统管理</a></li><li><a href="/pages/0694b2/" class="sidebar-link">Shell编程基础</a></li><li><a href="/pages/3205c5/" class="sidebar-link">Shell常见命令</a></li><li><a href="/pages/2dbdb3/" class="sidebar-link">Linux性能优化实战(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/0fc243/" class="sidebar-link">网络基础</a></li><li><a href="/pages/ca91df/" class="sidebar-link">数据链路层</a></li><li><a href="/pages/b1e177/" class="sidebar-link">网络层</a></li><li><a href="/pages/0a1ee7/" aria-current="page" class="active sidebar-link">传输层</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/25ec79/" class="sidebar-link">应用层</a></li><li><a href="/pages/08f912/" class="sidebar-link">HTTP基础</a></li><li><a href="/pages/f22543/" class="sidebar-link">HTTP应用与新特性</a></li><li><a href="/pages/2b073d/" class="sidebar-link">HTTPS</a></li><li><a href="/pages/4d1267/" class="sidebar-link">网络安全</a></li><li><a href="/pages/723841/" class="sidebar-link">网络综合问题</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/basic/#基础" data-v-06970110>基础</a></li><li data-v-06970110><a href="/basic/#基础" data-v-06970110>基础</a></li><li data-v-06970110><a href="/basic/#网络" data-v-06970110>网络</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">传输层<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_4-传输层"><a href="#_4-传输层" class="header-anchor">#</a> 4.传输层</h1> <h4 id="传输层概述"><a href="#传输层概述" class="header-anchor">#</a> 传输层概述</h4> <h5 id="_1-进程间通信"><a href="#_1-进程间通信" class="header-anchor">#</a> 1.进程间通信</h5> <p>传输层<strong>为</strong>​<mark><strong>进程</strong></mark>​<strong>提供通用数据传输服务</strong>. <strong>网络层</strong>只把<strong>分组</strong>发送到<strong>目的主机</strong>, 但是真正通信的并不是主机而是主机中的<strong>进程</strong>. 传输层提供了进程间的通信, 它向高层用户屏蔽了网络层的细节, 使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道.</p> <p><strong>传输层</strong>向它上面的<strong>应用层</strong>提供<strong>通信服务</strong>. 当网络边缘部分中的<strong>两个主机</strong>使用网络的核心部分的功能进行端到端通信时, 只有位于网络边缘部分<strong>主机的协议栈才有传输层, 而网络核心部分中的路由器在转发分组时都只用到下三层的功能</strong>.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/1574661864808.png" alt="" title="传输层与进程通信"></p> <p><strong>网络层和传输层的区别</strong>: <strong>网络层</strong>是为<strong>主机之间</strong>提供逻辑通信, 而<strong>传输层</strong>为<strong>应用进程</strong>之间提供端到端的逻辑通信.</p> <h5 id="_2-传输层协议"><a href="#_2-传输层协议" class="header-anchor">#</a> 2.传输层协议</h5> <p>传输层有两种不同的协议, 即<strong>面向连接的 TCP</strong> 和<strong>无连接的 UDP</strong>.</p> <ul><li><strong>用户数据报协议 UDP 协议</strong>(User Datagram Protocol) 是<strong>无连接</strong>的, 使用不可靠信道. 尽最大可能交付, 没有拥塞控制, 面向报文(对于应用程序传下来的报文不合并也不拆分, 只是添加 UDP 首部), 支持一对一, 一对多, 多对一和多对多的交互通信. 传输的是 <strong>UDP 用户数据报</strong>.</li> <li><strong>传输控制协议 TCP 协议</strong>(Transmission Control Protocol) 是<strong>面向连接</strong>的, 提供可靠交付, 有流量控制, 拥塞控制, 提供全双工通信, 面向字节流(把应用层传下来的报文看成字节流, 把字节流组织成大小不等的数据块), 每一条 TCP 连接只能是<strong>点对点</strong>的(一对一). 传输的是 <strong>TCP 报文段</strong>.</li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220424203007418.png" alt="" title="TCP与UDP协议所处位置"></p> <h5 id="_3-传输层端口"><a href="#_3-传输层端口" class="header-anchor">#</a> 3.传输层端口</h5> <p>端口用一个 16 位<strong>端口号</strong>进行标志, 允许 <strong>65535</strong> 个不同端口. 端口号只具有本地意义, 即<strong>端口号只是为了标识本计算机应用层中的各进程</strong>, 不同计算机的相同端口号是<strong>没有联系</strong>的. 两个计算机中的<strong>进程</strong>要互相通信, 必须知道对方的 IP 地址以找到对方的计算机, 且还要知道对方的端口号以找到对方计算机中的<strong>应用进程</strong>.</p> <p>端口用处及区间划分如下.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220424230630968.png" alt="" title="传输层端口分配"></p> <h4 id="用户数据报协议udp🌟"><a href="#用户数据报协议udp🌟" class="header-anchor">#</a> 用户数据报协议UDP🌟</h4> <h5 id="_1-概述"><a href="#_1-概述" class="header-anchor">#</a> 1.概述</h5> <p><strong>用户数据报协议 UDP <strong>​<strong><strong>是</strong></strong>​</strong>无连接</strong>的, 它在 IP 层的数据报服务上只增加了: 复用和分用功能, 差错检测功能.</p> <p>当运输层从 IP 层收到 UDP 数据报时, 就根据<strong>首部</strong>中的<strong>目的端口</strong>, 把 UDP 数据报通过相应的端口上交至相应的应用进程. 如果接收方 UDP 发现收到的报文中的目的端口<strong>不正确</strong>, 即不存在对应端口的进程, 就丢弃该报文, 并由<mark><strong>网际控制报文协议 ICMP</strong></mark> 发送 &quot;端口不可达&quot; 差错报文给发送方.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220424232011660.png" alt=""></p> <p><strong>注意</strong>, 虽然在 UDP 协议要用到端口号, 但**由于 UDP 通信是无连接的, **​<mark><strong>因此不需要使用套接字</strong></mark>.</p> <h5 id="_2-udp协议首部格式"><a href="#_2-udp协议首部格式" class="header-anchor">#</a> 2.UDP协议首部格式</h5> <p>用户数据报 UDP 有两个字段: <strong>首部字段和数据字段</strong>. 首部只有<strong>四个字段共 8 个字节</strong>.</p> <ul><li><strong>源端口</strong>: 需要对方回信时使用, 不需要时可用全 0.</li> <li><strong>目的端口</strong></li> <li><strong>长度</strong>: UDP 数据报长度, 最小值是仅有首部时的 8 字节.</li> <li><strong>校验和</strong>: 检验传输是否出错, 出错丢弃. UDP 的校验和是把<strong>首部和数据部分一起校验</strong>. 12 字节的伪首部是为了计算检验和临时添加的.</li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220424232443877.png" alt="" title="UDP协议首部格式"></p> <p>注意首部字段<strong>不含 IP 地址</strong>.</p> <h5 id="_3-udp协议特点"><a href="#_3-udp协议特点" class="header-anchor">#</a> 3.UDP协议特点</h5> <p>(1) <strong>UDP 是无连接的</strong>, 发送数据之前不需要建立连接, 减少了开销和发送数据之前的时延.</p> <p>(2) <strong>UDP 使用尽最大努力交付, 即不保证可靠交付</strong>, 主机不需要维持复杂的连接状态表.</p> <p>(3) <strong>UDP 是面向报文的</strong>. UDP 对应用层交下来的报文, 既不合并也不拆分, 而是保留这些报文的边界. UDP 一次交付一个完整报文, 如下图.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220424232919242.png" alt="" title="UDP报文封装"></p> <p>(4) <strong>UDP <strong>​<mark><strong>没有拥塞控制</strong></mark>, 因此网络出现的拥塞</strong>不会</strong>使源主机的发送速率降低. 这对某些<strong>实时应用</strong>是很重要的, 如多媒体通信.</p> <p>(5) <strong>UDP 支持一对一, 一对多, 多对一和多对多的交互通信</strong>.</p> <p>(6) <strong>UDP 的首部开销小</strong>, 只有 8 个字节, 比 TCP 的 20 个字节的首部要短.</p> <h5 id="_4-udp可靠传输"><a href="#_4-udp可靠传输" class="header-anchor">#</a> 4.UDP可靠传输</h5> <p>如何使用 UDP 也能可靠传输? 当使用 UDP 的传输层无法保证数据可靠传输时, 只能<strong>通过应用层</strong>来实现. 可以参照 TCP 可靠性传输的方式, 只是实现不在传输层, 而是转移到了应用层. 主要方式:</p> <ul><li>添加 <strong>seq/ack 机制</strong>, 确保数据发送到对端.</li> <li>添加发送和<strong>接收缓冲区</strong>, 配合<strong>超时重传机制</strong>进行丢失数据的重传.</li></ul> <p>相关的协议:</p> <ul><li><strong>RUDP</strong>: 提供一组数据服务质量增强机制, 如拥塞控制的改进, 重发机制及淡化服务器算法等, 从而在包丢失和网络拥塞的情况下, RTP 客户机面前呈现的就是一个高质量的 RTP 流.</li> <li><strong>RTP</strong>: 为数据提供了具有实时特征的端对端传送服务, 如在组播或单播网络服务下的交互式视频音频或模拟数据.</li> <li><strong>UDT</strong>: UDT 是<strong>面向连接的双向应用层协议</strong>, UDT 建于 UDP 之上, 并引入新的拥塞控制和数据可靠性控制机制. 它同时支持可靠的数据流传输和部分可靠的数据报传输.</li></ul> <h4 id="传输控制协议tcp🌟"><a href="#传输控制协议tcp🌟" class="header-anchor">#</a> 传输控制协议TCP🌟</h4> <h5 id="_1-概述-2"><a href="#_1-概述-2" class="header-anchor">#</a> 1.概述</h5> <p><strong>传输控制协议(TCP)<strong>​<strong><strong>是</strong></strong>​</strong>面向连接的传输层协议</strong>. TCP 提供<strong>全双工通信</strong>, <strong>面向字节流的可靠交付的服务</strong>.</p> <p>TCP 中的 &quot;流&quot; 指的是流入或流出进程的<strong>字节序列</strong>. &quot;面向字节流&quot; 的含义是: 虽然应用程序和 TCP 的交互是一次一个<strong>数据块</strong>, 但 TCP 把进程交下来的数据看成是一连串无结构的<strong>字节流</strong>, 如下图.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220425215210699.png" alt="" title="基于TCP的通信方式"></p> <p><strong>TCP 连接是一条虚连接而不是一条真正的物理连接</strong>. 每一条 TCP 连接有且仅有 2 个端点(endpoint), 所以<strong>每一条 TCP 连接只能是点对点</strong>(一对一)的. <mark><strong>TCP 连接的端点叫做套接字(socket), 端口号拼接到 IP 地址即构成了套接字</strong></mark>.</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code>套接字 socket = (IP地址 : 端口号)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>每一条 TCP 连接被通信两端的两个套接字所确定</strong>. 即:</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code>TCP连接 ::= {socket1, socket2} = {(IP1:port1), (IP2:port2)}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>同一个 <strong>IP 地址</strong>可以有多个<strong>不同的 TCP 连接</strong>, 而<strong>同一个端口号</strong>也可以出现在<strong>多个不同的 TCP 连接</strong>中.</p> <h5 id="_2-tcp报文格式"><a href="#_2-tcp报文格式" class="header-anchor">#</a> 2.TCP报文格式</h5> <p>TCP 虽然是面向<strong>字节流</strong>的, 但传送的数据单元却是<strong>报文段</strong>. 一个 TCP 报文段分为<strong>首部和数据</strong>两部分, TCP 的全部功能都体现在它首部中的各字段上. TCP 报文作为 <strong>IP 数据报</strong>的数据部分.</p> <p>TCP 报文段首部的<strong>前 20</strong> 个字节是<strong>固定</strong>的, 后面有 4N 字节是根据需要而增加的选项(N 是整数). 因此 TCP 首部的最小长度是 <strong>20 字节</strong>.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220425215654667.png" alt="" title="TCP报文格式"></p> <ul><li><p><strong>源端口和目的端口</strong>: 各占 <strong>2 字节</strong>. 端口是运输层与应用层的服务接口, 传输层的<strong>复用和分用</strong>功能都要通过端口才能实现.</p></li> <li><p><strong>序号 seq</strong>: 占 <strong>4 字节</strong>. TCP 连接中传送的数据流中的<strong>每一个字节</strong>都有一个<strong>序号</strong>. 序号字段的值则指的是<strong>本报文段</strong>所<strong>发送的</strong>数据的<strong>第一个字节</strong>的序号.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220425215929563.png" alt=""></p></li></ul> <ul><li><strong>确认号 ack</strong>: 占 4 字节, 是<strong>期望</strong>收到<strong>对方</strong>的<strong>下一个报文段</strong>的数据的<strong>第一个字节</strong>序号. 若确认号 <strong>ack = N</strong>, 则表明到序号 <strong>N - 1</strong> 为止的所有数据都<strong>已正确收到</strong>.</li> <li><strong>数据偏移</strong>: 即<strong>首部长度</strong>. 占 4 位, 它指出当前 TCP 报文段的<strong>数据起始处</strong>距离 TCP 报文段的起始处有多远. &quot;数据偏移&quot; 的单位是 32 位字(以 4 字节为计算单位).</li> <li><strong>保留</strong>: 占 6 位, 保留为今后使用, 但目前应置为 0.</li> <li><strong>紧急 URG</strong>: 当 URG = 1 时, 表明紧急指针字段<strong>有效</strong>. 它告诉系统此报文段中有紧急数据, 应尽快传送(相当于高优先级的数据).</li> <li><strong>确认 ACK 标志位</strong>: 只有当 <strong>ACK = 1</strong> 时<strong>确认号字段才有效</strong>. 当 ACK = 0 时, 确认号无效.</li> <li><strong>推送 PSH</strong>: 接收 TCP 收到 PSH = 1 的报文段, 就尽快地交付接收应用进程, 而不再等到整个缓存都填满了后再向上交付.</li> <li><strong>复位 RST</strong>: 当 RST = 1 时, 表明 TCP 连接中如由于主机崩溃或其他原因出现严重差错而必须释放连接, 然后再重新建立运输连接.</li> <li><strong>同步 SYN 标志位</strong>(Synchronize Sequence Numbers): 同步 SYN = 1 表示这是一个连接请求或连接接受报文, 在连接时用来同步序号.</li> <li><strong>终止 FIN 标志位</strong>: 用来<strong>释放</strong>一个连接. <strong>FIN = 1</strong> 表明此报文段的<strong>发送端</strong>的数据已<strong>发送完毕</strong>, 并<strong>要求释放连接</strong>.</li> <li><strong>窗口</strong>: 占 2 字节, 是用来<strong>对方设置</strong>发送窗口大小的依据, 单位为字节. 窗口字段明确指出了现在<strong>允许对方发送</strong>的数据量, 窗口值常在<strong>动态</strong>变化着. TCP 根据对方给出<strong>的窗口值</strong>和当前<strong>网络拥塞的程度</strong>来决定一个报文段应<strong>包含多少个字节</strong>(UDP 发送的报文<strong>长度是应用进程给出</strong>的). TCP 并不关心应用进程一次把多长的报文发送到 TCP 的缓存中, 而是根据<strong>对方给出的窗口值</strong>和当前网络拥塞的程序来决定一个报文段应该包含多少个字节. 如果缓存的数据块太长可以划分短一些再传送.</li> <li><strong>校验和</strong>: 占 2 字节. 检验和字段检验的范围包括<strong>首部和数据</strong>这两部分. 在计算检验和时, 临时在 TCP 报文段的前面加上 12 字节的伪首部.</li> <li><strong>紧急指针字段</strong>: 占 16 位, 指出在本报文段中紧急数据共有多少个字节.</li> <li><strong>选项</strong>: 长度可变. TCP 最初只规定了一种选项, 即<strong>最大报文段长度 MSS</strong>. MSS 告诉对方 TCP: 我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节.</li> <li><strong>填充</strong>: 使整个首部长度是 <strong>4 字节</strong>的<strong>整数倍</strong>.</li></ul> <h4 id="arq协议🌟"><a href="#arq协议🌟" class="header-anchor">#</a> ARQ协议🌟</h4> <p>ARQ 协议的核心就是<strong>自动请求重传</strong>. <strong>自动重传请求</strong>(Automatic Repeat-reQuest, ARQ) 是数据链路层和传输层的错误纠正协议之一. 它通过<strong>确认和超时</strong>机制, 在不可靠服务的基础上实现可靠信息传输. 如果发送方在发送后一段时间之内没有收到确认, 它通常会重新发送. <strong>ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议</strong>.</p> <h5 id="_1-停止等待arq协议"><a href="#_1-停止等待arq协议" class="header-anchor">#</a> 1.停止等待ARQ协议</h5> <p><strong>停止等待协议的要点就是对每个分组都进行编号, 且每发送完一个分组就停止发送, 等待对方的确认. 在收到确认后再发送下一个分组</strong>. 发送方为<strong>每个发送的分组</strong>设置一个<strong>超时计时器</strong>. 若超时计时器超时, 发送方会<strong>自动重传</strong>分组. 该协议很简单但信道利用率太低.</p> <p>该协议工作时可能会遇到几种情况.</p> <h6 id="_1-无差错情况"><a href="#_1-无差错情况" class="header-anchor">#</a> (1)无差错情况</h6> <p>发送方发送分组, 接收方在规定时间内收到, 并且回复确认. 发送方可再次发送分组, 这就是无差错的<strong>正常情况</strong>.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220425230531168.png" alt="" title="ARQ协议无差错情况"></p> <h6 id="_2-出现差错"><a href="#_2-出现差错" class="header-anchor">#</a> (2)出现差错</h6> <p>如果 B 接收 M1 分组后进行<strong>校验</strong>出了差错, 就会直接<strong>丢弃 M1</strong>, 其他什么也不做, <strong>不通知</strong> A 收到有差错的分组. 且如果分组 M1 在<strong>传输过程中丢失</strong>了, 接收方 B 什么都不能做. 在这两种情况下, B 都<strong>不会回复</strong>任何信息. 但 A 都必须<strong>重发分组</strong>, 直到 <strong>B 正确接收</strong>为止, 这样才能实现可靠通信.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220425230746327.png" alt="" title="ARQ协议出现差错情况"></p> <blockquote><p>A 如何知道 B 是否正确收到了 M1 分组?</p></blockquote> <p><strong>解决方法: 超时重传</strong></p> <p>A 为<strong>每一个已发送的分组</strong>都设置了一个<strong>超时计时器</strong>. A 只要在超时计时器<strong>到期</strong>之前收到了相应的<strong>确认</strong>, 就<strong>撤销</strong>该超时计时器, 继续发送下一个分组 M2. 若 A 在超时计时器规定时间内没有收到 B 的确认, 就认为分组错误或丢失, 就<strong>重发该分组</strong>.</p> <blockquote><p>若分组正确到达 B, 但 B 回送的确认丢失或延迟了, A 未收到 B 的确认, 会超时重发. B 可能会收到重复的 M1 . B 如何知道收到了重复的分组, 需要丢弃呢?</p></blockquote> <p><strong>解决方法: 编号</strong></p> <p>A 为<strong>每一个发送的分组</strong>都进行<strong>编号</strong>. 若 B 收到了编号<strong>相同的分组</strong>, 则认为收到了重复分组, <strong>丢弃重复的分组</strong>, 并<strong>回送确认</strong>. B 为发送的确认也进行<strong>编号</strong>, 指示该确认是对<strong>哪一个分组的确认</strong>. A 根据确认及其编号, 可以确定它是对哪一个分组的确认, 避免重发发送. 若为重复的确认, 则将其<strong>丢弃</strong>.</p> <h6 id="_3-确认丢失"><a href="#_3-确认丢失" class="header-anchor">#</a> (3)确认丢失</h6> <p>若 B 所发送的对 M1 的<strong>确认信息丢失</strong>了, 那么 A 在设定的超时重传时间内不能收到确认, 但 A 并<strong>无法知道</strong>: 是自己发送的分组出错, 丢失了, 还是 B 发送的确认丢失了. 因此 A 在超时计时器到期后就要<strong>重传</strong> M1.</p> <p>假定此时 B 又收到了重传的分组 M1. 这时 B 应采取<strong>两个行动</strong>: 第一, <strong>丢弃这个重复</strong>的分组 M1, 不向上层交付. 第二, 向 A <strong>发送确认</strong>. <strong>不能认为已经发送过确认就不再发送</strong>, 因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认.</p> <h6 id="_4-确认迟到"><a href="#_4-确认迟到" class="header-anchor">#</a> (4)确认迟到</h6> <p>如果传输过程中没有出现差错, 但 B 对分组 M1 的<strong>确认因网络阻塞等原因迟到</strong>了. B 仍然会收到<strong>重复的 M1</strong>, 并且同样要<strong>丢弃</strong>重复的 M1, 并<strong>重传确认分组</strong>. 此时 A 会收到<strong>重复的确认</strong>. A 也会丢弃掉收到的重复确认.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220425231030893.png" alt="" title="ARQ确认迟到情况"></p> <p>注意:</p> <ul><li><strong>分组和确认分组都必须进行编号</strong>.</li> <li>在发送完一个分组后, 必须<strong>暂时保留</strong>已发送的分组的<strong>副本</strong>, 以备<strong>重发</strong>.</li> <li>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些.</li></ul> <h6 id="_5-信道利用率"><a href="#_5-信道利用率" class="header-anchor">#</a> (5)信道利用率</h6> <p>当往返时间 RTT 远大于分组发送时间 TD 时, 信道的利用率就会<strong>非常低</strong>. 若出现超时重传, 则对传送有用的数据信息来说, 信道的利用率就还要降低.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220425231207149.png" alt="" title="信道利用率"></p> <h5 id="_2-自动请求重传协议"><a href="#_2-自动请求重传协议" class="header-anchor">#</a> 2.自动请求重传协议</h5> <p>通常发送方<strong>最终</strong>总是可以收到对所有发出分组的确认. 如果发送方不断重传分组但总是收不到确认, 就说明通信线路太差, 不能进行通信. 使用上述的确认和重传机制, 就可以在不可靠的传输网络上实现可靠的通信. 像上述的这种可靠传输协议常称为自动重传请求 ARQ(Automatic Repeat Request). 意思是重传的请求是自动进行的, 接收方不需要请求发送方重传某个出错的分组.</p> <p>上面的停止等待 ARQ 协议就是自动请求重传协议的一种.</p> <h5 id="_3-流水线传输"><a href="#_3-流水线传输" class="header-anchor">#</a> 3.流水线传输</h5> <p>为提高传输效率, 发送方可以采用<strong>流水线传输</strong>. 流水线传输就是<strong>发送方可连续发送多个分组</strong>, 不必每发完一个分组就停顿下来等待对方的确认. 这样可使信道上一直有数据不间断地传送, 这种传输方式可获得很高的<strong>信道利用率</strong>.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220425231350029.png" alt="" title="流水线传输"></p> <p>这就<strong>演变</strong>出来<strong>连续 ARQ 协议</strong>.</p> <h5 id="_4-连续arq协议"><a href="#_4-连续arq协议" class="header-anchor">#</a> 4.连续ARQ协议</h5> <p>要点: <strong>自动请求重传(ARQ) + 流水线</strong>.</p> <p>连续 ARQ 协议就是在停止等待 ARQ 协议的基础上, 发送方一次可以发出<strong>多个分组</strong>. 同时使用<strong>滑动窗口协议</strong>控制发送方和接收方所能发送和接收的分组的<strong>数量和编号</strong>. 发送方每收到一个确认, 就把发送窗口向前滑动. <strong>接收方</strong>一般采用<strong>累积确认</strong>的方式. 不必对分组逐个确认, 而可以对按序到达的<strong>最后一个分组</strong>进行确认表示到这个分组为止的所有分组<strong>都已正确</strong>收到了. <strong>超时重传</strong>则采用<strong>回退 N</strong>(Go-Back-N) 方法进行. 如果发送方发送了前 5 个分组, 而中间的第 3 个分组丢失了. 这时接收方只能对<strong>前两个</strong>分组发出确认. 发送方无法知道后面三个分组的下落, 而只好把后面的三个分组<strong>都再重传</strong>一次. 这就叫做回退 N, 表示需要<strong>再退回来重传已发送过的 N 个分组</strong>.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220425231552162.png" alt="" title="连续ARQ协议工作原理"></p> <p>连续 ARQ 协议是<strong>基于滑动窗口协议</strong>的. 下面看看滑动窗口协议.</p> <h4 id="tcp可靠传输实现原理🌟"><a href="#tcp可靠传输实现原理🌟" class="header-anchor">#</a> TCP可靠传输实现原理🌟</h4> <p><strong>IP</strong> <strong>网络</strong>所提供的是<strong>不可靠</strong>的传输, TCP 为了实现可靠传输需要一些特定功能, 主要有<strong>停止等待协议</strong>, <strong>连续 ARQ 协议, 滑动窗口协议(TCP 协议的精髓)</strong> .</p> <p><strong>注意关系</strong>: ARQ 协议是<strong>自动重传请求</strong>(Automatic Repeat-reQuest). 包含<strong>停止等待 ARQ</strong>(信道利用率低) 和<strong>连续 ARQ</strong>(信道利用率高), <strong>ARQ</strong> 协议实现连续发送基于滑动窗口协议. 除此之外滑动窗口还可以用于<strong>流量控制</strong>.</p> <p>上一节讲的是实现可靠传输的<strong>基本原理</strong>, 这一节具体讲 TCP 如何实现可靠传输, 分为三个部分.</p> <h5 id="_1-滑动窗口协议"><a href="#_1-滑动窗口协议" class="header-anchor">#</a> 1.滑动窗口协议</h5> <p><strong>滑动窗口协议</strong>在发送方和接收方之间各自维持一个<strong>滑动窗口</strong>, 发送方是<strong>发送窗口</strong>, 接收方是<strong>接收窗口</strong>, 这个窗口是可以随着时间变化向前<strong>滑动</strong>的. 它允许发送方<strong>发送多个分组</strong>而不需等待确认, 提高了信道利用率.</p> <h6 id="_1-基本流程"><a href="#_1-基本流程" class="header-anchor">#</a> (1)基本流程</h6> <p>窗口是<strong>缓存</strong>的一部分, 用来暂时存放<strong>字节流</strong>. 发送方和接收方各有一个窗口, <strong>接收方</strong>通过 TCP 报文段中的<strong>窗口字段</strong>告诉发送方自己的窗口大小, 发送方根据这个值和其它信息<strong>设置自己的窗口大小</strong>. 滑动窗口以<strong>字节</strong>为单位.</p> <p><strong>发送窗口</strong>内的字节都<strong>允许被发送</strong>, <strong>接收窗口</strong>内的字节都<strong>允许被接收</strong>. 如果发送窗口左边的字节已经发送并且<strong>收到了确认</strong>, 那么就将发送窗口向<strong>右滑动</strong>一定距离, 直到左部第一个字节不是已发送<strong>并且已确认</strong>的状态; 接收窗口的滑动类似, 接收窗口左部字节已经发送<strong>确认</strong>并交付主机, 就向<strong>右滑动</strong>接收窗口.</p> <ul><li><strong>发送窗口</strong>表示: 即使在<strong>没有收到确认</strong>的情况下, 也可以<strong>连续把窗口内的数据</strong>全部发送出去.</li> <li><strong>接收窗口</strong>表示: <strong>只允许</strong>接收<strong>落入窗口内</strong>的数据.</li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220425232219587.png" alt=""></p> <p>发送窗口里面的序号 <strong>31 - 50</strong> 表示是<strong>允许发送</strong>的序号. 发送窗口后沿的后面部分表示已经收到<strong>并且确认</strong>, 这部分数据<strong>不需要</strong>继续保存. 描述一个发送窗口需要维护<strong>三个指针</strong>, 如下图所示. 下图中如果 <strong>B 收到了 32, 33</strong> 序号的数据, 但并<strong>没有收到 31</strong> 的数据, 说明数据<strong>没有按序到达</strong>, 所以 B 发送的确认报文段中的<strong>确认号</strong>仍然是 <strong>31</strong>, 即<strong>期望收到</strong>的序号.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220425233842105.png" alt=""></p> <p>下图所示为 B <strong>收到</strong> 31-33 的数据并交付主机, 同时给 A 确认, 其中<strong>窗口值为 20</strong> , <strong>确认值</strong>变为 <strong>34</strong>, 即<strong>下一个期望</strong>收到序号为 34 的数据. 同时下图还收到了 37, 38, 40 序号的数据, 但是<strong>未按序到达</strong>, 所以只是<strong>暂存</strong>到接收窗口. 此时 B 的<strong>接收窗口向前滑动</strong>到下一个期待接收的位置依然是 34.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220425234214256.png" alt=""></p> <p>此时 A 收到确认号, <strong>发送窗口向前滑动</strong>.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220425234542900.png" alt=""></p> <p>如果 A 的发送窗口内的<strong>序号都已用完</strong>, 但还<strong>没有</strong>再收到确认, 必须<strong>停止发送</strong>. 如下图.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220425234837080.png" alt=""></p> <p>而如果 A 收到确认落在发送窗口内, 那就可以使发送窗口继续<strong>向前滑动</strong>.</p> <p>注意:</p> <ul><li>发送端的发送窗口<strong>并不总是</strong>和 B 的接收窗口一样大, 因为可能有一定的<strong>时间滞后</strong>.</li> <li>TCP 标准没有规定对不按序到达的数据应如何处理. 通常是先<strong>临时存放在接收窗口</strong>中, 等到字节流中所<strong>缺少的字节收到</strong>后, 再按序交付上层的应用进程.</li> <li>TCP 要求接收方必须有<strong>累积确认</strong>的功能, 这样可以减小传输<strong>开销</strong>.</li> <li>真正的发送窗口值的大小还取决于网络的<strong>拥塞情况</strong>, <strong>发送窗口的上限值 = Min (接收方窗口值, 拥塞窗口值)</strong> .</li></ul> <h6 id="_2-滑动窗口与缓存"><a href="#_2-滑动窗口与缓存" class="header-anchor">#</a> (2)滑动窗口与缓存</h6> <p><strong>发送缓存</strong>用来暂时发送方<strong>准备发送</strong>的数据, 以及已发送但<strong>尚未收到</strong>确认的数据.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220426001840347.png" alt="" title="发送缓存"></p> <p><strong>接收缓存</strong>用来暂时存放<strong>按序到达</strong>的, 但尚未被接收进程读取的数据, 以及<strong>未按序</strong>到达的数据.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220426001812944.png" alt="" title="接收缓存"></p> <h5 id="_2-超时重传时间"><a href="#_2-超时重传时间" class="header-anchor">#</a> 2.超时重传时间</h5> <p>TCP 每发送一个报文段, 就对这个报文段设置一次<strong>计时器</strong>. 只要<strong>计时器</strong>设置的重传时间到但还没有收到确认, 就要重传这一报文段. 这里重传<strong>时间的选择</strong>很关键. 如果把超时重传时间设置得<strong>太短</strong>, 就会引起很多报文段的不必要的重传, 使网络负荷增大; 若设置得<strong>过长</strong>, 则又使网络的空闲时间增大, 降低了传输效率.</p> <blockquote><p>如何设置超时重传时间?</p></blockquote> <p>TCP 采用了一种<strong>自适应算法</strong>, 它记录一个报文段发出的时间, 以及收到相应的确认的时间. 这两个时间之差就是报文段的往返时间 <strong>RTT</strong>. 计算<strong>加权平均往返时间 RTTs</strong>. 超时重传时间 <strong>RTO</strong>(Retransmission Time-Out) 应<strong>略大于</strong>上面得出的加权平均往返时间 RTTs.</p> <blockquote><p>如何准确计算RTTs?</p></blockquote> <p>在计算平均往返时间 RTT 时, 只要发生了报文段<strong>重传</strong>事件, 就<strong>不采用</strong>其往返时间样本. 这样得出的加权平均 RTTs 和 RTO 就比较准确.</p> <h5 id="_3-选择确认sack"><a href="#_3-选择确认sack" class="header-anchor">#</a> 3.选择确认SACK</h5> <p>若收到的报文段无差错, 只是<strong>未按序号</strong>, 中间还<strong>缺少</strong>一些序号的数据, 也可以采用选择确认 SACK(Selective ACK) 的方式只传送缺少的数据而不重传已经正确到达接收方的数据. 但其实<strong>大多数的实现</strong>还是<strong>重传所有</strong>未被确认的数据块.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220426230925001.png" alt="" title="选择确认SACK"></p> <h4 id="tcp流量控制"><a href="#tcp流量控制" class="header-anchor">#</a> TCP流量控制</h4> <p><strong>流量控制</strong>就是<strong>控制发送方发送速率</strong>, 保证<strong>接收方</strong>来得及接收. <strong>接收方</strong>发送的<strong>确认</strong>报文中的<strong>窗口字段</strong>可以用来<strong>控制发送方窗口值</strong>大小(<strong>利用滑动窗口实现流量控制</strong>), 从而影响发送方的发送速率. 将窗口字段设置为 <strong>0</strong>, 则发送方<strong>不能</strong>发送数据.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220426231149028.png" alt="" title="TCP流量控制"></p> <h4 id="tcp拥塞控制🌟"><a href="#tcp拥塞控制🌟" class="header-anchor">#</a> TCP拥塞控制🌟</h4> <h5 id="_1-概述-3"><a href="#_1-概述-3" class="header-anchor">#</a> 1.概述</h5> <p>在某段时间, 若对网络中某资源的需求超过了该资源所能提供的可用部分, 网络的<strong>性能</strong>就要变坏, 这种现象称为<strong>拥塞</strong>(congestion). 最坏可能导致系统崩溃.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220426231355599.png" alt="" title="拥塞"></p> <p>增加资源能解决拥塞吗? <strong>不能</strong>. 网络拥塞往往是由<strong>许多因素</strong>引起的, 简单地增加资源在许多情况下不但不能解决拥塞问题, 而且还可能使网络的性能更坏.</p> <p><strong>拥塞控制</strong>的作用:</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220426231518474.png" alt="" title="拥塞控制的作用"></p> <blockquote><p>流量控制与拥塞控制的对比</p></blockquote> <table><thead><tr><th style="text-align:center;">流量控制</th> <th style="text-align:center;">拥塞控制</th></tr></thead> <tbody><tr><td style="text-align:center;">抑制<strong>发送端发</strong>送数据的速率, 以使接收端<strong>来得及接收</strong></td> <td style="text-align:center;"><strong>防止</strong>过多的数据<strong>注入到网络</strong>中, 使网络中的路由器或链路<strong>不致过载</strong></td></tr> <tr><td style="text-align:center;">是<strong>点对点</strong>通信量的控制, 是<strong>端到端</strong>的问题</td> <td style="text-align:center;">是一个<strong>全局性</strong>的过程, 涉及到与降低网络传输性能有关的所有因素</td></tr> <tr><td style="text-align:center;">使用<strong>滑动窗口</strong>实现</td> <td style="text-align:center;">使用<strong>拥塞窗口</strong>变量 + <strong>拥塞控制算法</strong>实现, 还要<strong>配合滑动窗口</strong></td></tr></tbody></table> <ul><li><strong>拥塞控制</strong>是一个<strong>全局性的过程</strong>, 涉及到所有主机与路由器的通信链路全局, 以及与降低网络传输性能有关的所有因素.</li> <li><strong>流量控制</strong>往往指在给定的发送端和接收端之间的<strong>点对点</strong>通信量的控制, 只要通信双方进行协商即可. 流量控制所要做的就是抑制发送端发送数据的速率, 使接收端来得及接收.</li> <li>流量控制需要通信双方各维护一个发送窗, 一个接收窗, 对任意一方, 接收窗大小由自身决定, 发送窗大小由接收方响应的 TCP 报文段中窗口值确定; 拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整.</li> <li><strong>发送方实际最终发送窗口 = min{流控发送窗口, 拥塞窗口}.</strong></li></ul> <blockquote><p>滑动窗口与拥塞窗口的区别</p></blockquote> <p><strong>滑动窗口</strong>是接收窗口, 就是 TCP 头的那个<strong>窗口</strong>, 可以理解为一块<strong>内存</strong>, 不仅要接收数据, 还要向应用层交付数据. 而拥塞窗口是一个<strong>变量</strong>.</p> <h5 id="_2-tcp拥塞控制方法"><a href="#_2-tcp拥塞控制方法" class="header-anchor">#</a> 2.TCP拥塞控制方法</h5> <p><strong>拥塞控制</strong>: 基于<strong>拥塞窗口变量 + 几种拥塞控制算法</strong>实现.</p> <ul><li>TCP 采用<strong>基于拥塞窗口</strong>的方法进行拥塞控制, 该方法属于闭环控制方法. TCP<strong>发送方</strong>维持一个<strong>拥塞窗口 cwnd</strong>(Congestion Window) 的变量. <strong>发送端</strong>利用<strong>拥塞窗口</strong>根据网络的拥塞情况<strong>调整发送的数据量</strong>.</li> <li><strong>发送窗口大小</strong>不仅取决于<strong>接收方窗口</strong>(就是 TCP 头部中的窗口值), 还取决于网络的<strong>拥塞状况</strong>, 所以真正的<strong>发送窗口值</strong>为:</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>发送窗口的上限值 = Min (接收方窗口值, 拥塞窗口值) = Min(rwnd, cwnd)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>当 rwnd &lt; cwnd 时, 是<strong>接收方</strong>的接收能力限制发送窗口的<strong>最大值</strong>.</li> <li>当 cwnd &lt; rwnd 时, 则是网络的<strong>拥塞限制</strong>发送窗口的<strong>最大值</strong>.</li></ul> <p>即发送方让自己的<strong>发送窗口</strong>取为<strong>拥塞窗口和接收方的接受窗口</strong>中<strong>较小的一个</strong>.</p> <p><strong>控制拥塞窗口的原则</strong>: 只要网络<strong>没有</strong>出现拥塞, 拥塞窗口就可以再<strong>增大</strong>一些, 以便把更多的分组发送出去, 这样就可以提高网络的利用率. 但只要网络<strong>出现</strong>拥塞或有可能出现拥塞, 就必须把拥塞窗口<strong>减小</strong>一些, 以减少注入到网络中的分组数, 以便缓解网络出现的拥塞.</p> <p><strong>拥塞的判断</strong>:</p> <ul><li><strong>收到三个重复的</strong> <strong>ACK</strong>: 预示网络可能会出现拥塞, 实际可能还未发生拥塞.</li> <li><strong>重传定时器超时</strong>: 网络已经发生了拥塞.</li></ul> <h5 id="_3-tcp拥塞控制算法"><a href="#_3-tcp拥塞控制算法" class="header-anchor">#</a> 3.TCP拥塞控制算法</h5> <p>四种拥塞控制算法:</p> <ul><li><strong>慢开始</strong>(slow-start)</li> <li><strong>拥塞避免</strong>(congestion avoidance)</li> <li><strong>快重传</strong>(fast retransmit)</li> <li><strong>快恢复</strong>(fast recovery)</li></ul> <p>TCP 拥塞控制流程图.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220426232125296.png" alt="" title="TCP拥塞控制流程图"></p> <h6 id="_1-慢开始算法"><a href="#_1-慢开始算法" class="header-anchor">#</a> (1)慢开始算法</h6> <p><strong>目的</strong>: 用来确定网络的<strong>负载能力</strong>或拥塞程度.</p> <p><strong>算法思路</strong>: 由小到大<strong>逐渐</strong>增大拥塞窗口数值.</p> <p>两个变量:</p> <p>(1)<strong>拥塞窗口</strong>: <strong>初始</strong>拥塞窗口值. <strong>2 - 4</strong> 个最大报文段, 窗口值逐渐增大.</p> <p>(2)<strong>慢开始门限</strong>(<strong>ssthresh</strong>): 防止拥塞窗口增长过大引起网络拥塞.</p> <p><strong>拥塞窗口 cwnd 控制方法</strong>: 在每收到一个对<strong>新的报文段的确认</strong>后, 可以把拥塞窗口<strong>增加最多一个</strong> <strong>SMSS</strong> 的数值.</p> <p>发送方<strong>每收到</strong>一个对新<strong>报文段</strong>的确认(重传的不算在内)就使 cwnd 加 1, 如果一个轮次传了 4 个报文段, 那么等这 4 个都收到确认之后, 窗口值就会多出 4 个, 整体表现就是<strong>一个轮次后变成了原来的两倍</strong>.</p> <p>每经过一个<strong>传输轮次</strong>, 拥塞窗口值就<strong>加倍</strong>, 即 <strong>cwnd = cwnd * 2</strong>. 一个传输轮次所经历的时间其实就是<strong>往返时间 RTT</strong>.  <strong>&quot;传输轮次&quot;</strong>  强调的是把拥塞窗口 cwnd 所允许发送的报文段<strong>都连续发送</strong>出去, 并收到了对<strong>已发送</strong>的<strong>最后一个字节</strong>的确认. 例如拥塞窗口 cwnd = 4, 这时的往返时间 RTT 就是发送方<strong>连续发送 4 个报文段</strong>, 并收到这全部 <strong>4 个报文段</strong>的确认, 总共经历的时间.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220430195938412.png" alt="" title="慢开始算法"></p> <p><strong>设置慢开始门限状态变量 ssthresh</strong>. <strong>慢开始门限 ssthresh</strong> 的用法如下:</p> <ul><li>当 <strong>cwnd &lt; ssthresh</strong> 时, 使用<strong>慢开始</strong>算法.</li> <li>当 <strong>cwnd &gt; ssthresh</strong> 时, 停止使用慢开始算法而改用<strong>拥塞避免算法</strong>.</li> <li>当 <strong>cwnd = ssthresh</strong> 时, 既可使用慢开始算法, 也可使用拥塞避免算法.</li></ul> <h6 id="_2-拥塞避免算法"><a href="#_2-拥塞避免算法" class="header-anchor">#</a> (2)拥塞避免算法</h6> <p>当 <strong>cwnd &gt; ssthresh</strong> 时, 停止使用慢开始算法而改用<strong>拥塞避免算法</strong>.</p> <p><strong>思路</strong>: 让拥塞窗口 cwnd <strong>缓慢地增大</strong>, 避免出现拥塞. <strong>超时之前</strong>, 每经过一个<strong>传输轮次</strong>(注意慢开始算法是每收到一个<strong>报文段</strong>就加 1), 拥塞窗口 <strong>cwnd = cwnd + 1</strong>. 这就使拥塞窗口 cwnd 按<strong>线性规律缓慢增长</strong>. 在拥塞避免阶段, 具有 &quot;<strong>加法增大</strong>&quot; 的特点.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220429230001214.png" alt="" title="拥塞避免算法"></p> <p>当网络<strong>出现拥塞</strong>时: 无论在慢开始阶段还是在拥塞避免阶段, 只要发送方判断网络出现拥塞(重传定时器超时), 就执行如下操作:</p> <p><strong>(1) ssthresh = max(cwnd / 2, 2)</strong> : <strong>降低门限值(取一半)</strong> .</p> <p><strong>(2) cwnd = 1</strong>: 拥塞窗口<strong>重新变为 1</strong>.</p> <p><strong>(3) 执行慢开始算法</strong>: 重新执行<strong>慢开始</strong>.</p> <p>目的: <strong>迅速</strong>减少主机发送到网络中的分组数, 使得发生拥塞的路由器有足够时间把队列中积压的分组<strong>处理完毕</strong>. &quot;拥塞避免&quot; <strong>并非指完全</strong>能够避免了拥塞, 利用以上的措施要完全避免网络拥塞还是不可能的. &quot;<strong>拥塞避免</strong>&quot; 是说在拥塞避免阶段把拥塞窗口<strong>控制为按线性规律增长</strong>, 使网络比较<strong>不容易</strong>出现拥塞.</p> <p><strong>慢开始与拥塞避免算法的过程举例:</strong></p> <ul><li>当 TCP 连接进行初始化时, 将拥塞窗口置为 1. 图中的窗口单位不使用字节而使用<strong>报文段</strong>. 慢开始门限的初始值设置为 16 个报文段, 即 ssthresh = 16.</li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220429230711266.png" alt=""></p> <ul><li>在执行慢开始算法时, 拥塞窗口 <strong>cwnd = 1</strong>, 发送第一个报文段.</li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220429230748014.png" alt=""></p> <ul><li>发送方<strong>每收到一个</strong>对新<strong>报文段</strong>的确认 ACK, 就把拥塞窗口值加 1, 然后开始下一轮的传输, 注意横坐标是<strong>传输轮次</strong>, 不是时间. 因此拥塞窗口 cwnd 随着传输轮次按<strong>指数规律增长</strong>.</li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220429230828903.png" alt=""></p> <ul><li>当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时, 即图中的点 ①. 此时拥塞窗口 cwnd = 16, 就改为执行<strong>拥塞避免算法</strong>, 拥塞窗口按<strong>线性规律增长</strong>.</li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220429231016147.png" alt=""></p> <ul><li>当拥塞窗口 cwnd = 24 时, 网络出现了超时(图中的点 ②), 发送方判断为网络拥塞. 于是调整门限值 ssthresh = cwnd / 2 = 12, 同时重新设置拥塞窗口 cwnd = 1, 进入<strong>慢开始</strong>阶段.</li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220429231306423.png" alt=""></p> <ul><li>按照慢开始算法, 发送方每收到一个对新<strong>报文段</strong>的确认 ACK, 就把拥塞窗口值加 1. 当拥塞窗口 cwnd = ssthresh = 12 时, 即图中的点 ③, 这是新的 ssthresh 值, 改为执行拥塞避免算法, 拥塞窗口按线性规律增大.</li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220429231425681.png" alt=""></p> <ul><li>当拥塞窗口 cwnd = 16 时(图中的点 ④), 出现了一个新的情况, 就是发送方一连收到 3 个对<strong>同一个报文段的重复确认</strong>, 图中记为 3-ACK. 发送方改为执行快重传和快恢复算法.</li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220429231702236.png" alt=""></p> <h6 id="_3-快重传算法"><a href="#_3-快重传算法" class="header-anchor">#</a> (3)快重传算法</h6> <p><strong>发送方</strong>只要一连收到<strong>三个重复确认</strong>, 就知道接收方确实<strong>没有收到</strong>报文段, 因而应当<strong>立即进行重传</strong>, 即 &quot;<strong>快重传</strong>&quot;, 这样就<strong>不会出现超时</strong>, 发送方也不就会误认为出现了网络拥塞. 使用快重传可以使整个网络的<strong>吞吐量</strong>提高约 20%. 不难看出, 快重传并非取消重传计时器, 而是在某些情况下可以<strong>更早地(更快地)重传</strong>丢失的报文段.</p> <p>采用快重传算法可以让<strong>发送方</strong>尽早知道发生了个别报文段的丢失. 快重传算法首先要求接收方<strong>不要等待</strong>自己发送数据时才进行捎带确认, 而是要<strong>立即发送确认</strong>, 即使收到了<strong>失序</strong>的报文段也要<strong>立即</strong>发出对已收到的报文段的<strong>重复确认</strong>.</p> <p>下图中<strong>仅仅是丢失了 M3</strong>, 其实<strong>并没有发生拥塞</strong>. 此时<strong>连续收</strong>到其他三个<strong>重复确认</strong>, 就说明其实网络<strong>大概率没有拥塞</strong>, 而仅仅是发生了 M3 的丢失. 此时启用快重传立即重传 M3.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220429231919714.png" alt="" title="快重传算法"></p> <h6 id="_4-快恢复算法"><a href="#_4-快恢复算法" class="header-anchor">#</a> (4)快恢复算法</h6> <p>根据上图所示. 当发送端收到连续<strong>三个重复的确认</strong>时, 由于发送方现在认为网络<strong>很可能没有发生拥塞</strong>, 因此现在<strong>不需要</strong>执行慢开始算法, 而是执行<strong>快恢复算法</strong>:</p> <p><strong>(1) 慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2;</strong></p> <p><strong>(2) 新拥塞窗口 cwnd = 慢开始门限 ssthresh;</strong></p> <p><strong>(3) 开始执行拥塞避免算法, 使拥塞窗口缓慢地线性增大.</strong></p> <p>因此在图的点 ④, 发送方知道现在只是丢失了个别的报文段. 于是不启动慢开始, 而是执行<strong>快恢复</strong>算法. 这时发送方调整门限值 ssthresh = cwnd / 2 = 8, 同时设置拥塞窗口 cwnd = ssthresh = 8(见图中的点 ⑤), 并开始执行拥塞避免算法.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220429232057542.png" alt="" title="快恢复算法"></p> <h5 id="_4-aimd"><a href="#_4-aimd" class="header-anchor">#</a> 4.AIMD</h5> <p><strong>拥塞避免算法</strong>中, <strong>拥塞窗口</strong>是按照<strong>线性规律</strong>增大的. 这常称为 &quot;<strong>加法增大</strong>&quot; AI(Additive Increase). 当出现超时或 3 个<strong>重复的确认</strong>时, 就要把<strong>门限值</strong>设置为当前拥塞窗口值的<strong>一半</strong>, 并大大减小拥塞窗口的数值这常称为 &quot;<strong>乘法减小</strong>&quot; MD(Multiplicative Decrease). 二者合在一起就是所谓的 <strong>AIMD</strong> 算法.</p> <h4 id="tcp建立连接🌟"><a href="#tcp建立连接🌟" class="header-anchor">#</a> TCP建立连接🌟</h4> <p>TCP 是<strong>面向连接</strong>的协议. TCP 传输数据有三个阶段: <strong>连接建立</strong>, <strong>数据传送</strong>, <strong>连接释放</strong>. TCP 连接的管理就是使 TCP 连接的<strong>建立和释放</strong>都能正常地进行.</p> <h5 id="_1-连接过程"><a href="#_1-连接过程" class="header-anchor">#</a> 1.连接过程</h5> <p>TCP 连接建立过程中要解决三个问题:</p> <ul><li>要使每一方能够确知<strong>对方的存在</strong>.</li> <li>要允许双方<strong>协商一些参数</strong>, 如最大窗口值, 是否使用窗口扩大选项和时间戳选项以及服务质量等.</li> <li>能够对运输实体<strong>资源</strong>如缓存大小, 连接表中的项目等进行<strong>分配</strong>.</li></ul> <p>TCP 建立连接的过程叫做<strong>握手</strong>. 握手需要在客户和服务器之间<strong>交换三个 TCP 报文段</strong>, 称之为<strong>三报文握手/三次握手</strong>. 流程如下:</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220429232609774.png" alt="" title="TCP链接建立过程"></p> <p><strong>第一次握手</strong>: 客户端发送连接请求, <strong>SYN</strong> 是<strong>同步号</strong>, <strong>seq</strong> 是数据的第一个<strong>字节序号</strong>, 连接请求也有<strong>数据</strong>, 只不过数据字节数<strong>为 1</strong>. TCP 连接是只有<strong>客户端才能发起</strong>.</p> <p><strong>第二次握手</strong>: 服务器<strong>收到</strong>连接请求, <strong>SYN 也为 1</strong>. 并使 <strong>ACK = 1</strong>, 表示收到客户端的连接请求. 只有当 <strong>ACK = 1</strong> 时<strong>确认号 ack 字段才有效</strong>. 所以必须设置 ACK = 1. 由于服务器收到客户端发送的序号 <strong>seq = x</strong>, 说明服务器收到这一个字节的数据, 因此期待客户端下一个发送的数据的第一个字节是 seq = <strong>x + 1</strong>. 所以确认号 <strong>ack = x + 1</strong>. 同时服务器也设置一个自己的序号 <strong>seq = y</strong>.</p> <p>这里要注意<strong>区分 ACK</strong>(<strong>标志位</strong>, <strong>为 1 时 ack 才有效</strong>,  ACK 表示回复对方<strong>已经收到</strong>对方的消息) 与 <strong>ack</strong>(<strong>确认号</strong>, 用于确认已经收到数据, 并且回复下一个期待收到的数据).</p> <p><strong>第三次握手</strong>: 客户端收到服务器的第二次握手, 需要对服务器进行第三次握手, 此时客户端回复 <strong>ACK = 1</strong>, 表示收到服务端的第二次握手信息. 由于之前客户端发送的是序列号 <strong>seq = x</strong>. 而且服务端也发回来的确认号也是 x + 1. 因此如果是正常的握手报文则客户端第三次握手的数据报文就是 <strong>seq = x + 1</strong>. 同时客户端也收到服务器的 <strong>seq = y</strong>, 需要确认收到了这个, 因此回复给服务器的确认中确认号变为 <strong>ack = y + 1</strong>.</p> <p>此时完成三次握手. 之后进行数据传输.</p> <p>简化流程, 相当于客户端和服务端<strong>都给</strong>对方发送了 <strong>SYN 和 ACK</strong> 信号.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220430204109602.png" alt="" title="TCP链接建立简化流程"></p> <h5 id="_2-三次握手的原因"><a href="#_2-三次握手的原因" class="header-anchor">#</a> 2.三次握手的原因</h5> <blockquote><p>为什么要进行第三次? 只握手两次不行?</p></blockquote> <p><strong>原因 1: 三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的.</strong></p> <ul><li>第一次握手: Client 什么都不能确认; Server 确认了对方发送正常, 自己接收正常.</li> <li>第二次握手: Client 确认了: 自己发送, 接收正常, 对方发送, 接收正常; Server 确认了: 对方发送正常, 自己接收正常.</li> <li>第三次握手: Client 确认了: 自己发送, 接收正常, 对方发送, 接收正常; Server 确认了: 自己发送, 接收正常, 对方发送, 接收正常.</li></ul> <p><strong>原因 2: 进行第三次握手是为了防止失效的连接请求到达服务器, 让服务器错误再次打开连接, 占用服务器资源.</strong></p> <p>客户端发送的连接请求如果在网络中<strong>滞留</strong>, 那么就会隔很长一段时间才能收到服务器端发回的<strong>连接确认</strong>. 客户端等待一个<strong>超时重传</strong>时间之后, 就会<strong>重新请求连接</strong>. 但是这个滞留的连接请求最后还是会到达服务器, 如果不进行三次握手, 那么服务器就会<strong>打开两个连接</strong>. 如果有第三次握手, 客户端会<strong>忽略服务</strong>器之后发送的对滞留连接请求的连接确认(因为序号这些对应不上), 不进行第三次握手, 因此就不会再次打开连接.</p> <blockquote><p>为什么要传回SYN</p></blockquote> <p>服务端传回发送端所发送的 <strong>SYN 是为了告诉发送端</strong>它接收到的信息确实就是客户端所发送的信号. SYN 是 TCP/IP 建立<strong>连接时</strong>使用的<strong>握手信号</strong>. 在客户机和服务器之间建立正常的 TCP 网络连接时, 客户机首先发出一个 <strong>SYN 消息</strong>, 服务器使用 <strong>SYN-ACK 应答</strong>表示<strong>接收到了这个消息</strong>, 最后客户机<strong>再以 ACK</strong> 消息响应. 这样在客户机和服务器之间才能建立起可靠的 TCP 连接, 数据才可以在客户机和服务器之间传递.</p> <h5 id="_3-其他"><a href="#_3-其他" class="header-anchor">#</a> 3.其他</h5> <blockquote><p>TCP连接中如果断电怎么办?</p></blockquote> <p>当 TCP 两端 A, B 建立了连接后, 如果一端拔掉网线或者直接断电, 另一端<strong>不能收到通知</strong>.</p> <p>TCP 两端保存了一种<strong>数据的状态</strong>, 就代表这种连接, TCP 两端之间的路由设备只是将数据转发到目的地, 并不知道这些数据实际代表了什么含义, 也并没有在其中保存任何的状态信息.</p> <p>正常情况下当 TCP 的一端 A 调用了 SOCKET 的 close() 或者进程结束, 操作系统就会按照 TCP 协议发送 FIN 数据报文. B 端收到后就会<strong>断开连接</strong>. 如果遇到拔掉网线或者直接断电等异常情况, 就<strong>没有机会发出断开的 FIN 数据报文</strong>, 而 B 端没有收到断开的数据报文就会<strong>依然保持连接状态</strong>.</p> <p>如果这种异常断开的连接有很多, 那么势必会耗费大量资源, 需要通过<strong>心跳机制</strong>检测出这种异常连接. TCP 协议有一个 KEEP_LIVE 开关, 只要打开这个开关就会定时发送一些数据<strong>长度为零</strong>的探测心跳包, 发送的频率和次数都可以设置. 由于两端都有可能发生异常断开的情况, 所以 TCP 连接的<strong>两端必须都向对端发送心跳</strong>.</p> <h4 id="tcp释放连接🌟"><a href="#tcp释放连接🌟" class="header-anchor">#</a> TCP释放连接🌟</h4> <p>TCP 连接释放过程比较复杂, 与连接不同的是, 数据传输结束后通信的双方<strong>都可</strong>释放连接. TCP 连接释放过程是<strong>四报文挥手/四次挥手</strong>.</p> <h5 id="_1-释放过程"><a href="#_1-释放过程" class="header-anchor">#</a> 1.释放过程</h5> <p>通俗的例子: A 和 B 打电话, 通话即将结束后, A 说 &quot;我没啥要说的了&quot;(第一次), B 回答 &quot;我知道了&quot;(第二次), 但是 B 可能还会有要说的话, A 不能要求 B 跟着自己的节奏结束通话, 于是 B 可能又补充说了一些, 最后 B 说 &quot;我说完了&quot;(第三次), A 回答 &quot;知道了&quot;(第四次), 这样通话才算结束.</p> <p>这里假设客户端<strong>主动</strong>释放连接, 释放过程如下:</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220429233237700.png" alt="" title="TCP链接释放过程"></p> <p><strong>第一次挥手</strong>: 客户端发送 <strong>FIN = 1</strong>, 并且其数据部分序号为 <strong>seq = u</strong>(仅一个字节数据).</p> <p><strong>第二次挥手</strong>: 服务器收到<strong>释放连接</strong>的请求, 那么<strong>直接</strong>回复 <strong>ACK = 1</strong>, 表示<strong>确认收到</strong>客户端的释放请求. 同时回复其确认号 <strong>ack = u + 1 <strong>​ <strong><strong>(即服务端期望客户端发送的下一个字节). 同时如果服务端还有未发送完成的数据, 此时服务端可以</strong></strong>​</strong>继续</strong>发送给客户端, 直到数据发送完成. 注意此时只能服务端给客户端发送数据, 也就是主动发起释放连接的一方只能接受<strong>不能再发送</strong>了.</p> <p><strong>第三次挥手</strong>: 服务器数据发送完成之后发送另一个<strong>释放消息</strong>, 即 <strong>FIN = 1</strong>, 同时 <strong>ACK = 1</strong>, 表示收到客户端的消息, 此时 ack 有效, 且 ack = <strong>u + 1</strong>. 同时服务端设置自己的序列号 seq = w.</p> <p><strong>第四次挥手</strong>: 客户端收到服务器的释放报文后, 需要<strong>再次确认</strong>. 此时 <strong>ACK = 1</strong>(确认信息有效), 同时 <strong>seq = u + 1</strong>(客户端前一次发送 u 的基础上加 1), ack = <strong>w + 1</strong>(表明收到服务器的 seq = w 的信息). <strong>四次挥手完成</strong>.</p> <p>四次挥手流程简化版如下. 相当于客户端和服务端<strong>都给</strong>对方发送了 <strong>FIN 和 ACK</strong> 信息, 只不过服务端的分成了两次, 所以变成了四次挥手.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220430211742063.png" alt="" title="TCP链接释放简化过程"></p> <blockquote><p>四次挥手的原因</p></blockquote> <p>客户端发送了 FIN 连接释放报文之后, 服务器收到了这个报文, 就进入了 <strong>CLOSE-WAIT</strong> 状态. 这个状态是为了<strong>让服务器端发送还未传送完毕的数据</strong>, 传送完毕之后, 服务器<strong>会发送 FIN 连接释放</strong>报文.</p> <h5 id="_2-time-wait与close-wait"><a href="#_2-time-wait与close-wait" class="header-anchor">#</a> 2.TIME_WAIT与CLOSE_WAIT</h5> <p><strong>TIME_WAIT</strong> 和 <strong>CLOSE_WAIT</strong> 分别表示主动关闭方与被动关闭方产生的<strong>阶段性状态</strong>, 如果在线服务器大量出现这两种状态则会加重机器负载, 影响有效的连接.</p> <p><strong>TIME_WAIT</strong>: 四次挥手之后之后主动关闭方<strong>并不是直接进入 CLOSED</strong> 状态, 而是进入 <strong>TIME_WAIT 状态</strong>, 等待 <mark><strong>2MSL</strong></mark> 的时间. <strong>MSL</strong> 中文可以译为 &quot;<strong>报文最大生存时间</strong>&quot;, 它是任何报文在网络上<strong>存在的最长时间</strong>, 超过这个时间报文将被<strong>丢弃</strong>. 一般时间长度是 30 秒. 等待 2MSL 时间主要<strong>目的</strong>是<strong>怕最后一个 ACK</strong> 包对方<strong>没收到</strong>, 那么对方在<strong>超时后将重发第三次握手的 FIN 包</strong>, 主动关闭端接到<strong>重发的 FIN 包后可以再发一个 ACK 应答包</strong>, 从而确保四次挥手完成. 在 TIME_WAIT 状态时<strong>两端的端口不能使用</strong>, 要等到 2MSL 时间结束<strong>才可继续使用</strong>. 当连接处于 2MSL 等待阶段时任何迟到的报文段都将被<strong>丢弃</strong>.</p> <p>等待 2MSL 的两个理由:</p> <ul><li><strong>确认被动关闭方能够顺利进入 CLOSED 状态</strong>. 也就是确保<strong>最后一个确认报文</strong>能够到达. 如果 <strong>B 没收到</strong> A 发送来的<strong>确认报文</strong>, 那么就会<strong>重新发送连接释放</strong>请求报文, A 等待一段时间就是为了处理这种情况的发生.</li> <li><strong>防止失效请求</strong>. 等待一段时间是为了让本连接持续时间内所产生的<strong>所有报文都从网络中消失</strong>, 使得下一个新的连接<strong>不会出现旧的连接</strong>请求报文.</li></ul> <p><strong>CLOSE_WAIT: 被动要求关闭的机器收到对方请求关闭连接的 FIN 报文, 在第一次 ACK 应答后进入马上进入</strong>. 这种状态其实是在<strong>等待关闭</strong>, 并且通知应用程序<strong>发送剩余数据</strong>, 处理现场信息, 关闭相应资源.</p> <p><strong>注意</strong>: 由于 TIME_WAIT 状态无法真正释放句柄资源, 此期间 Socket 中使用的<strong>本地端口</strong>在默认情况下不能再被使用, 对于高并发服务器来说, 这会限制有效连接的创建数量, 成为性能瓶颈. 所以建议将<strong>高并发服务器的 TIME_WAIT 超时时间调小</strong>.</p> <h5 id="_3-tcp连接状态总结"><a href="#_3-tcp连接状态总结" class="header-anchor">#</a> 3.TCP连接状态总结</h5> <ul><li><strong>CLOSED</strong>: 初始状态.</li> <li><strong>LISTEN</strong>: 服务器处于监听状态.</li> <li><strong>SYN_SEND</strong>: 客户端 socket 执行 CONNECT 连接, 发送 SYN 包, 进入此状态.</li> <li><strong>SYN_RECV</strong>: 服务端收到 SYN 包并发送服务端 SYN 包, 进入此状态.</li> <li><strong>ESTABLISH</strong>: 表示<strong>连接建立</strong>. 客户端发送了最后一个 ACK 包后进入此状态, 服务端接收到 ACK 包后进入此状态.</li> <li><strong>FIN_WAIT_1</strong>: 终止连接的一方(如客户端)发送了 FIN 报文后进入. <strong>等待对方 FIN</strong>.</li> <li><strong>CLOSE_WAIT</strong>: (假设服务端)接收到客户端 FIN 包之后等待关闭的阶段. 在接收到对方的 FIN 包之后, 自然是需要立即回复 ACK 包的, 表示已经知道断开请求. 但是本方是否立即断开连接(发送 FIN 包)取决于是否还有数据需要发送给客户端, 若有则在发送 FIN 包之前均为此状态.</li> <li><strong>FIN_WAIT_2</strong>: 此时是半连接状态, 即有一方要求关闭连接, 等待另一方关闭. 客户端接收到服务器的 ACK 包, 但并没有立即接收到服务端的 FIN 包, 进入 FIN_WAIT_2 状态.</li> <li><strong>LAST_ACK</strong>: 服务端发动最后的 FIN 包, 等待最后的客户端 ACK 响应, 进入此状态.</li> <li><strong>TIME_WAIT</strong>: 客户端收到服务端的 FIN 包, 并立即发出 ACK 包做最后的确认, 在此之后的 2MSL 时间称为 TIME_WAIT 状态.</li></ul> <h5 id="_4-其他"><a href="#_4-其他" class="header-anchor">#</a> 4.其他</h5> <h6 id="_1-保活计时器"><a href="#_1-保活计时器" class="header-anchor">#</a> (1)保活计时器</h6> <p>保活计时器用来防止在 TCP 连接出现<strong>长时期的空闲</strong>. 比如客户端<strong>直接断电</strong>, 来不及发送释放的报文. <strong>保活计时器</strong>通常设置为 2 小时. 若服务器过了 2 小时<strong>还没有收到</strong>客户端的信息, 它就发送探测报文段. 若发送了 10 个探测报文段还没有响应, 就认为客户出了故障并主动<strong>终止该连接</strong>.</p> <h6 id="_2-tcp有限状态机"><a href="#_2-tcp有限状态机" class="header-anchor">#</a> (2)TCP有限状态机</h6> <p>箭头旁边的字, 表明引起这种变迁的原因, 或表明发生状态变迁后又出现什么动作.</p> <p>图中有三种不同的箭头.</p> <ul><li>粗实线箭头表示对<strong>客户端</strong>进程的正常变迁.</li> <li>粗虚线箭头表示对<strong>服务器</strong>进程的正常变迁.</li> <li>细线箭头表示异常变迁.</li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220429233611612.png" alt="" title="TCP连接状态机"></p> <h6 id="_3-tcp连接限制"><a href="#_3-tcp连接限制" class="header-anchor">#</a> (3)TCP连接限制</h6> <p>TCP 连接的建立是通过<strong>文件描述符(fd)</strong>  完成的, 通过创建套接字获取一个 fd, 然后服务端和客户端需要基于获得的 fd 调用不同的函数分别进入监听状态和发起连接请求. <strong>fd 的数量</strong>决定了服务端进程能创建连接的数量. 所以需要注意调整服务端进程和操作系统所支持的<strong>最大文件句柄数</strong>.</p> <h4 id="tcp协议保证可靠传输总结"><a href="#tcp协议保证可靠传输总结" class="header-anchor">#</a> TCP协议保证可靠传输总结</h4> <p>总结一下 TCP 协议是如何保证传输可靠的, 总结就是: <strong>ARQ 协议 + 滑动窗口协议</strong>.</p> <ol><li><strong>数据编号</strong>: 应用数据被分割成 TCP 认为最适合发送的<strong>数据块</strong>. TCP 给发送的每一个<strong>数据包进行编号</strong>, 接收方对数据包进行排序, 把有序数据传送给应用层.</li> <li><strong>校验和</strong>: TCP 将保持它首部和数据的<strong>检验和</strong>. 这是一个端到端的检验和, 目的是检测数据在传输过程中的任何变化. 如果收到段的检验和有差错, TCP 将丢弃这个报文段和不确认收到此报文段.</li> <li><strong>ARQ 协议</strong>: 每发完一个分组就停止发送, 等待收到对方确认后再发下一个分组. 为提高传输效率可以采用连续 ARQ 协议.</li> <li><strong>超时重传</strong>: 当 TCP 发出一个<strong>报文</strong>后就启动一个<strong>定时器</strong>, 如果超过定时器还没收到接收方的确认, 就会重传报文.</li> <li>**流量控制: ** TCP 连接的每一方都有固定大小的缓冲空间, TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据. 当接收方来不及处理发送方的数据, 能提示发送方降低发送的速率, 防止包丢失. TCP 利用滑动窗口实现流量控制.</li> <li>**拥塞控制: ** 当网络拥塞时, 减少数据的发送. 包含慢开始, 拥塞避免, 快重传, 快恢复等拥塞控制算法.</li></ol> <p>‍</p> <p>‍</p> <h4 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h4> <ul><li>《计算机网络 第七版 谢希仁》</li> <li><a href="https://blog.csdn.net/bjrxyz/article/details/71076442" target="_blank" rel="noopener noreferrer">TCP新手误区--心跳的意义<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/10.基础/1000.基础/300.网络/4.传输层.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/b1e177/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">网络层</div></a> <a href="/pages/25ec79/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">应用层</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/b1e177/" class="prev">网络层</a></span> <span class="next"><a href="/pages/25ec79/">应用层</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/40.1509d08b.js" defer></script>
  </body>
</html>
