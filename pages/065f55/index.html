<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>线程池与定时任务 | Pangolin</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.76d9f797.css" as="style"><link rel="preload" href="/assets/js/app.5bc2c979.js" as="script"><link rel="preload" href="/assets/js/2.eccd4273.js" as="script"><link rel="preload" href="/assets/js/136.5e57454a.js" as="script"><link rel="prefetch" href="/assets/js/10.8a8038d8.js"><link rel="prefetch" href="/assets/js/100.db890b43.js"><link rel="prefetch" href="/assets/js/101.9b9a913e.js"><link rel="prefetch" href="/assets/js/102.b98098b4.js"><link rel="prefetch" href="/assets/js/103.20eafae5.js"><link rel="prefetch" href="/assets/js/104.5f942f86.js"><link rel="prefetch" href="/assets/js/105.a443c173.js"><link rel="prefetch" href="/assets/js/106.6530e112.js"><link rel="prefetch" href="/assets/js/107.7b05a1d1.js"><link rel="prefetch" href="/assets/js/108.8c45adc4.js"><link rel="prefetch" href="/assets/js/109.ea29e43c.js"><link rel="prefetch" href="/assets/js/11.8d2b228f.js"><link rel="prefetch" href="/assets/js/110.0765054b.js"><link rel="prefetch" href="/assets/js/111.ae06b85d.js"><link rel="prefetch" href="/assets/js/112.b27bb80e.js"><link rel="prefetch" href="/assets/js/113.592e5b3f.js"><link rel="prefetch" href="/assets/js/114.677c3c60.js"><link rel="prefetch" href="/assets/js/115.fb35062d.js"><link rel="prefetch" href="/assets/js/116.19de2d57.js"><link rel="prefetch" href="/assets/js/117.ac783334.js"><link rel="prefetch" href="/assets/js/118.06b27dd3.js"><link rel="prefetch" href="/assets/js/119.cf6bb932.js"><link rel="prefetch" href="/assets/js/12.8764d408.js"><link rel="prefetch" href="/assets/js/120.ba8e09a5.js"><link rel="prefetch" href="/assets/js/121.bc501a72.js"><link rel="prefetch" href="/assets/js/122.c9a3dd47.js"><link rel="prefetch" href="/assets/js/123.b474c20b.js"><link rel="prefetch" href="/assets/js/124.f405a8c5.js"><link rel="prefetch" href="/assets/js/125.24083f67.js"><link rel="prefetch" href="/assets/js/126.3c5c6c33.js"><link rel="prefetch" href="/assets/js/127.b561056f.js"><link rel="prefetch" href="/assets/js/128.58891fb1.js"><link rel="prefetch" href="/assets/js/129.5073fbfd.js"><link rel="prefetch" href="/assets/js/13.1034e1a1.js"><link rel="prefetch" href="/assets/js/130.ca12ca1d.js"><link rel="prefetch" href="/assets/js/131.8e520e7f.js"><link rel="prefetch" href="/assets/js/132.0f186ee2.js"><link rel="prefetch" href="/assets/js/133.1d8479f7.js"><link rel="prefetch" href="/assets/js/134.9c30d69b.js"><link rel="prefetch" href="/assets/js/135.91463dab.js"><link rel="prefetch" href="/assets/js/137.1d4e51f0.js"><link rel="prefetch" href="/assets/js/138.6cd3ac7f.js"><link rel="prefetch" href="/assets/js/139.7bd789a6.js"><link rel="prefetch" href="/assets/js/14.ead46968.js"><link rel="prefetch" href="/assets/js/140.e1d92390.js"><link rel="prefetch" href="/assets/js/141.23e11057.js"><link rel="prefetch" href="/assets/js/142.c8cc0f38.js"><link rel="prefetch" href="/assets/js/143.fc738cb7.js"><link rel="prefetch" href="/assets/js/144.67c64203.js"><link rel="prefetch" href="/assets/js/145.cc73ed45.js"><link rel="prefetch" href="/assets/js/146.adaac4c0.js"><link rel="prefetch" href="/assets/js/147.0e83b5c1.js"><link rel="prefetch" href="/assets/js/148.1f253a46.js"><link rel="prefetch" href="/assets/js/149.ab428593.js"><link rel="prefetch" href="/assets/js/15.198f32e1.js"><link rel="prefetch" href="/assets/js/150.64cd514e.js"><link rel="prefetch" href="/assets/js/151.ca1ae55a.js"><link rel="prefetch" href="/assets/js/152.4119b23d.js"><link rel="prefetch" href="/assets/js/153.ed663263.js"><link rel="prefetch" href="/assets/js/154.71b836f6.js"><link rel="prefetch" href="/assets/js/155.c47e2e88.js"><link rel="prefetch" href="/assets/js/156.3e91e0f4.js"><link rel="prefetch" href="/assets/js/157.811b1421.js"><link rel="prefetch" href="/assets/js/158.71193c19.js"><link rel="prefetch" href="/assets/js/159.f09778fd.js"><link rel="prefetch" href="/assets/js/16.03096de2.js"><link rel="prefetch" href="/assets/js/160.15d99de4.js"><link rel="prefetch" href="/assets/js/161.813166a0.js"><link rel="prefetch" href="/assets/js/162.c52bbf77.js"><link rel="prefetch" href="/assets/js/163.ada6991a.js"><link rel="prefetch" href="/assets/js/164.d8ceba57.js"><link rel="prefetch" href="/assets/js/165.a645ef3a.js"><link rel="prefetch" href="/assets/js/166.995d24ad.js"><link rel="prefetch" href="/assets/js/167.d7278e80.js"><link rel="prefetch" href="/assets/js/168.e388905a.js"><link rel="prefetch" href="/assets/js/169.52edabbb.js"><link rel="prefetch" href="/assets/js/17.a49f9c19.js"><link rel="prefetch" href="/assets/js/170.0b62c5b4.js"><link rel="prefetch" href="/assets/js/171.017c8997.js"><link rel="prefetch" href="/assets/js/172.f0763c39.js"><link rel="prefetch" href="/assets/js/173.c961bf43.js"><link rel="prefetch" href="/assets/js/174.395224c0.js"><link rel="prefetch" href="/assets/js/175.52fbdc96.js"><link rel="prefetch" href="/assets/js/176.14e0a3b2.js"><link rel="prefetch" href="/assets/js/177.78f7d89f.js"><link rel="prefetch" href="/assets/js/178.c08bdd65.js"><link rel="prefetch" href="/assets/js/179.b634397c.js"><link rel="prefetch" href="/assets/js/18.9786a034.js"><link rel="prefetch" href="/assets/js/180.284b6c99.js"><link rel="prefetch" href="/assets/js/181.b4744ee7.js"><link rel="prefetch" href="/assets/js/182.8bfd08cd.js"><link rel="prefetch" href="/assets/js/183.59b0b92b.js"><link rel="prefetch" href="/assets/js/184.a5fae95c.js"><link rel="prefetch" href="/assets/js/185.dcf55c72.js"><link rel="prefetch" href="/assets/js/186.6b1cf319.js"><link rel="prefetch" href="/assets/js/187.312708d0.js"><link rel="prefetch" href="/assets/js/188.71de21d0.js"><link rel="prefetch" href="/assets/js/189.7d72c108.js"><link rel="prefetch" href="/assets/js/19.089d6618.js"><link rel="prefetch" href="/assets/js/190.85dce0bd.js"><link rel="prefetch" href="/assets/js/191.08f7136b.js"><link rel="prefetch" href="/assets/js/192.6a155217.js"><link rel="prefetch" href="/assets/js/193.64f71670.js"><link rel="prefetch" href="/assets/js/194.c4d60c72.js"><link rel="prefetch" href="/assets/js/195.748850e9.js"><link rel="prefetch" href="/assets/js/196.887ef31c.js"><link rel="prefetch" href="/assets/js/197.4473c177.js"><link rel="prefetch" href="/assets/js/198.ea53a990.js"><link rel="prefetch" href="/assets/js/199.886f6490.js"><link rel="prefetch" href="/assets/js/20.a52783e8.js"><link rel="prefetch" href="/assets/js/200.7619a798.js"><link rel="prefetch" href="/assets/js/201.d3f5de5f.js"><link rel="prefetch" href="/assets/js/202.ed4c18cc.js"><link rel="prefetch" href="/assets/js/203.7937068e.js"><link rel="prefetch" href="/assets/js/204.3dbdd61c.js"><link rel="prefetch" href="/assets/js/205.52bc6fdf.js"><link rel="prefetch" href="/assets/js/206.4393998f.js"><link rel="prefetch" href="/assets/js/207.ec8e121d.js"><link rel="prefetch" href="/assets/js/208.f54d4e42.js"><link rel="prefetch" href="/assets/js/209.1bc5d06d.js"><link rel="prefetch" href="/assets/js/21.2e3bed21.js"><link rel="prefetch" href="/assets/js/210.2a3dc088.js"><link rel="prefetch" href="/assets/js/211.7084c526.js"><link rel="prefetch" href="/assets/js/212.de742850.js"><link rel="prefetch" href="/assets/js/213.fc775028.js"><link rel="prefetch" href="/assets/js/214.e338168c.js"><link rel="prefetch" href="/assets/js/215.3e89c57e.js"><link rel="prefetch" href="/assets/js/216.ecfe7587.js"><link rel="prefetch" href="/assets/js/217.14dcd4a2.js"><link rel="prefetch" href="/assets/js/218.ee7d57f7.js"><link rel="prefetch" href="/assets/js/219.c263c1e8.js"><link rel="prefetch" href="/assets/js/22.3d09766f.js"><link rel="prefetch" href="/assets/js/220.33f2bfd2.js"><link rel="prefetch" href="/assets/js/221.cd55e739.js"><link rel="prefetch" href="/assets/js/222.63107647.js"><link rel="prefetch" href="/assets/js/223.768ef403.js"><link rel="prefetch" href="/assets/js/224.54357078.js"><link rel="prefetch" href="/assets/js/225.b8e46582.js"><link rel="prefetch" href="/assets/js/226.1d0dcae9.js"><link rel="prefetch" href="/assets/js/227.a351c0a1.js"><link rel="prefetch" href="/assets/js/228.f7b8c278.js"><link rel="prefetch" href="/assets/js/229.8e4aba4d.js"><link rel="prefetch" href="/assets/js/23.b87e3933.js"><link rel="prefetch" href="/assets/js/230.186bd7a5.js"><link rel="prefetch" href="/assets/js/231.dad483e1.js"><link rel="prefetch" href="/assets/js/232.26555358.js"><link rel="prefetch" href="/assets/js/233.658ba0e4.js"><link rel="prefetch" href="/assets/js/234.7994cee0.js"><link rel="prefetch" href="/assets/js/235.3934d057.js"><link rel="prefetch" href="/assets/js/236.59cb6eac.js"><link rel="prefetch" href="/assets/js/237.baa1c655.js"><link rel="prefetch" href="/assets/js/238.8ee9f8ae.js"><link rel="prefetch" href="/assets/js/239.b0fe3966.js"><link rel="prefetch" href="/assets/js/24.afe2a3c4.js"><link rel="prefetch" href="/assets/js/240.d06483fa.js"><link rel="prefetch" href="/assets/js/241.81a2223e.js"><link rel="prefetch" href="/assets/js/242.8f6eee74.js"><link rel="prefetch" href="/assets/js/243.874461fa.js"><link rel="prefetch" href="/assets/js/244.ec0bb622.js"><link rel="prefetch" href="/assets/js/245.2ecf61f8.js"><link rel="prefetch" href="/assets/js/246.e7f6e55c.js"><link rel="prefetch" href="/assets/js/247.f32a1a4b.js"><link rel="prefetch" href="/assets/js/248.4302c4d8.js"><link rel="prefetch" href="/assets/js/249.9b0a4d9f.js"><link rel="prefetch" href="/assets/js/25.a22777b8.js"><link rel="prefetch" href="/assets/js/250.1295326c.js"><link rel="prefetch" href="/assets/js/251.d1cdb160.js"><link rel="prefetch" href="/assets/js/252.4e9d56fe.js"><link rel="prefetch" href="/assets/js/253.5a23b42d.js"><link rel="prefetch" href="/assets/js/254.8777547c.js"><link rel="prefetch" href="/assets/js/255.b8825033.js"><link rel="prefetch" href="/assets/js/256.0ee3689d.js"><link rel="prefetch" href="/assets/js/257.4a684795.js"><link rel="prefetch" href="/assets/js/258.ca696e72.js"><link rel="prefetch" href="/assets/js/259.fdf867d0.js"><link rel="prefetch" href="/assets/js/26.c84357e5.js"><link rel="prefetch" href="/assets/js/260.d35d60d5.js"><link rel="prefetch" href="/assets/js/261.c162cef5.js"><link rel="prefetch" href="/assets/js/262.8cbc5289.js"><link rel="prefetch" href="/assets/js/263.c05bbe4c.js"><link rel="prefetch" href="/assets/js/264.2e7c8f69.js"><link rel="prefetch" href="/assets/js/265.372a0632.js"><link rel="prefetch" href="/assets/js/266.49c38b9d.js"><link rel="prefetch" href="/assets/js/267.f7406d35.js"><link rel="prefetch" href="/assets/js/268.c7846c3e.js"><link rel="prefetch" href="/assets/js/269.e30bdc7f.js"><link rel="prefetch" href="/assets/js/27.0b3da7b9.js"><link rel="prefetch" href="/assets/js/270.8a3786ce.js"><link rel="prefetch" href="/assets/js/271.4b771c95.js"><link rel="prefetch" href="/assets/js/272.c710d2d6.js"><link rel="prefetch" href="/assets/js/273.43fb2872.js"><link rel="prefetch" href="/assets/js/274.d8a9dff2.js"><link rel="prefetch" href="/assets/js/275.c2812b68.js"><link rel="prefetch" href="/assets/js/276.406503c4.js"><link rel="prefetch" href="/assets/js/277.10c29e54.js"><link rel="prefetch" href="/assets/js/278.5f4b657a.js"><link rel="prefetch" href="/assets/js/279.84b86ae8.js"><link rel="prefetch" href="/assets/js/28.1c1fd5a6.js"><link rel="prefetch" href="/assets/js/280.8a2ba3b2.js"><link rel="prefetch" href="/assets/js/281.4a7f2b91.js"><link rel="prefetch" href="/assets/js/282.7b2f2668.js"><link rel="prefetch" href="/assets/js/283.455f93df.js"><link rel="prefetch" href="/assets/js/284.1a448478.js"><link rel="prefetch" href="/assets/js/285.19eebc05.js"><link rel="prefetch" href="/assets/js/286.5423cfc6.js"><link rel="prefetch" href="/assets/js/287.afbe115e.js"><link rel="prefetch" href="/assets/js/288.d4f4f247.js"><link rel="prefetch" href="/assets/js/289.da477465.js"><link rel="prefetch" href="/assets/js/29.103209e9.js"><link rel="prefetch" href="/assets/js/290.abf99800.js"><link rel="prefetch" href="/assets/js/291.71fe3ae6.js"><link rel="prefetch" href="/assets/js/292.455169ca.js"><link rel="prefetch" href="/assets/js/293.d23ffed4.js"><link rel="prefetch" href="/assets/js/294.1a753204.js"><link rel="prefetch" href="/assets/js/295.badfa110.js"><link rel="prefetch" href="/assets/js/296.344206a1.js"><link rel="prefetch" href="/assets/js/297.29e4f914.js"><link rel="prefetch" href="/assets/js/298.f9db8940.js"><link rel="prefetch" href="/assets/js/299.2253c1e7.js"><link rel="prefetch" href="/assets/js/3.e5ca1c51.js"><link rel="prefetch" href="/assets/js/30.e76a827e.js"><link rel="prefetch" href="/assets/js/300.e5bfd607.js"><link rel="prefetch" href="/assets/js/301.cc3e786e.js"><link rel="prefetch" href="/assets/js/302.7fdc62b6.js"><link rel="prefetch" href="/assets/js/303.b1db491f.js"><link rel="prefetch" href="/assets/js/304.18917b0f.js"><link rel="prefetch" href="/assets/js/305.d352aeb5.js"><link rel="prefetch" href="/assets/js/306.8bc72324.js"><link rel="prefetch" href="/assets/js/307.854b4037.js"><link rel="prefetch" href="/assets/js/308.6a0e4a18.js"><link rel="prefetch" href="/assets/js/309.d184df6f.js"><link rel="prefetch" href="/assets/js/31.7e4b200d.js"><link rel="prefetch" href="/assets/js/310.8e0af1ab.js"><link rel="prefetch" href="/assets/js/311.00bae85e.js"><link rel="prefetch" href="/assets/js/312.bc92cba9.js"><link rel="prefetch" href="/assets/js/313.8f70a987.js"><link rel="prefetch" href="/assets/js/314.8f190f1f.js"><link rel="prefetch" href="/assets/js/315.4b8506c7.js"><link rel="prefetch" href="/assets/js/316.5911c1f9.js"><link rel="prefetch" href="/assets/js/317.58cca547.js"><link rel="prefetch" href="/assets/js/318.4f23c053.js"><link rel="prefetch" href="/assets/js/319.941f5d3e.js"><link rel="prefetch" href="/assets/js/32.9c188bac.js"><link rel="prefetch" href="/assets/js/320.a3f15adc.js"><link rel="prefetch" href="/assets/js/321.14c74686.js"><link rel="prefetch" href="/assets/js/322.5f7b1b87.js"><link rel="prefetch" href="/assets/js/323.ab05eccb.js"><link rel="prefetch" href="/assets/js/324.292806ba.js"><link rel="prefetch" href="/assets/js/325.b96314dd.js"><link rel="prefetch" href="/assets/js/326.3d8f6329.js"><link rel="prefetch" href="/assets/js/327.49cf9268.js"><link rel="prefetch" href="/assets/js/328.be56ec05.js"><link rel="prefetch" href="/assets/js/329.8c390111.js"><link rel="prefetch" href="/assets/js/33.2435d797.js"><link rel="prefetch" href="/assets/js/330.b961e5fd.js"><link rel="prefetch" href="/assets/js/331.24ce8c0b.js"><link rel="prefetch" href="/assets/js/332.115b7546.js"><link rel="prefetch" href="/assets/js/333.957e0728.js"><link rel="prefetch" href="/assets/js/334.68825ff7.js"><link rel="prefetch" href="/assets/js/335.b662f33d.js"><link rel="prefetch" href="/assets/js/336.d8818747.js"><link rel="prefetch" href="/assets/js/337.9d24e096.js"><link rel="prefetch" href="/assets/js/338.3b669645.js"><link rel="prefetch" href="/assets/js/339.51cc2773.js"><link rel="prefetch" href="/assets/js/34.d57f3bb9.js"><link rel="prefetch" href="/assets/js/340.28cfadfb.js"><link rel="prefetch" href="/assets/js/341.4e6b0bdd.js"><link rel="prefetch" href="/assets/js/342.310c1a3e.js"><link rel="prefetch" href="/assets/js/343.0e61677a.js"><link rel="prefetch" href="/assets/js/344.340a39bd.js"><link rel="prefetch" href="/assets/js/345.fff51053.js"><link rel="prefetch" href="/assets/js/346.93c709db.js"><link rel="prefetch" href="/assets/js/347.dc863ac9.js"><link rel="prefetch" href="/assets/js/348.13c191d7.js"><link rel="prefetch" href="/assets/js/349.8aea43f7.js"><link rel="prefetch" href="/assets/js/35.e20cb4ac.js"><link rel="prefetch" href="/assets/js/350.49b72b87.js"><link rel="prefetch" href="/assets/js/351.3e6e6379.js"><link rel="prefetch" href="/assets/js/352.e2524a53.js"><link rel="prefetch" href="/assets/js/353.b71b2a33.js"><link rel="prefetch" href="/assets/js/354.a4720902.js"><link rel="prefetch" href="/assets/js/355.5a8970e1.js"><link rel="prefetch" href="/assets/js/356.353f0a9c.js"><link rel="prefetch" href="/assets/js/357.648060ca.js"><link rel="prefetch" href="/assets/js/358.643b787c.js"><link rel="prefetch" href="/assets/js/359.b1bc0c81.js"><link rel="prefetch" href="/assets/js/36.6a79f8ad.js"><link rel="prefetch" href="/assets/js/360.748faf07.js"><link rel="prefetch" href="/assets/js/361.cddfbfab.js"><link rel="prefetch" href="/assets/js/362.46990756.js"><link rel="prefetch" href="/assets/js/363.f4846a88.js"><link rel="prefetch" href="/assets/js/364.e7fd6af2.js"><link rel="prefetch" href="/assets/js/365.41693194.js"><link rel="prefetch" href="/assets/js/366.60931b9e.js"><link rel="prefetch" href="/assets/js/367.c7a310db.js"><link rel="prefetch" href="/assets/js/368.cae4028a.js"><link rel="prefetch" href="/assets/js/369.e3bcd2c2.js"><link rel="prefetch" href="/assets/js/37.4ccc31d6.js"><link rel="prefetch" href="/assets/js/370.2ea3b181.js"><link rel="prefetch" href="/assets/js/371.978056e5.js"><link rel="prefetch" href="/assets/js/372.aa13db83.js"><link rel="prefetch" href="/assets/js/373.f3791afe.js"><link rel="prefetch" href="/assets/js/374.b108af2d.js"><link rel="prefetch" href="/assets/js/375.dc75d5b1.js"><link rel="prefetch" href="/assets/js/376.8a663da6.js"><link rel="prefetch" href="/assets/js/38.9816dff1.js"><link rel="prefetch" href="/assets/js/39.03d551c0.js"><link rel="prefetch" href="/assets/js/4.611d42c4.js"><link rel="prefetch" href="/assets/js/40.ce442bf2.js"><link rel="prefetch" href="/assets/js/41.d596832c.js"><link rel="prefetch" href="/assets/js/42.29309c56.js"><link rel="prefetch" href="/assets/js/43.d47b7a06.js"><link rel="prefetch" href="/assets/js/44.87716237.js"><link rel="prefetch" href="/assets/js/45.d5ef3d2b.js"><link rel="prefetch" href="/assets/js/46.21cef7ff.js"><link rel="prefetch" href="/assets/js/47.75c67941.js"><link rel="prefetch" href="/assets/js/48.b94040d3.js"><link rel="prefetch" href="/assets/js/49.507fb28d.js"><link rel="prefetch" href="/assets/js/5.e6d623f8.js"><link rel="prefetch" href="/assets/js/50.4013f17e.js"><link rel="prefetch" href="/assets/js/51.6e81cba9.js"><link rel="prefetch" href="/assets/js/52.07e4aadf.js"><link rel="prefetch" href="/assets/js/53.1d325b49.js"><link rel="prefetch" href="/assets/js/54.79ff5e8c.js"><link rel="prefetch" href="/assets/js/55.77160bdd.js"><link rel="prefetch" href="/assets/js/56.a3041056.js"><link rel="prefetch" href="/assets/js/57.b7c0602c.js"><link rel="prefetch" href="/assets/js/58.a4af9a23.js"><link rel="prefetch" href="/assets/js/59.61a80d59.js"><link rel="prefetch" href="/assets/js/6.dc644b59.js"><link rel="prefetch" href="/assets/js/60.4ae1e1f0.js"><link rel="prefetch" href="/assets/js/61.b733273a.js"><link rel="prefetch" href="/assets/js/62.63b8d77d.js"><link rel="prefetch" href="/assets/js/63.46a84bd8.js"><link rel="prefetch" href="/assets/js/64.ce8c5891.js"><link rel="prefetch" href="/assets/js/65.8abe6836.js"><link rel="prefetch" href="/assets/js/66.6f9a9cf9.js"><link rel="prefetch" href="/assets/js/67.6bc415b9.js"><link rel="prefetch" href="/assets/js/68.b100ab24.js"><link rel="prefetch" href="/assets/js/69.5d9ed0d7.js"><link rel="prefetch" href="/assets/js/7.7da3e776.js"><link rel="prefetch" href="/assets/js/70.f213eb63.js"><link rel="prefetch" href="/assets/js/71.9dbed333.js"><link rel="prefetch" href="/assets/js/72.1129fb4b.js"><link rel="prefetch" href="/assets/js/73.7459f6b0.js"><link rel="prefetch" href="/assets/js/74.2364da14.js"><link rel="prefetch" href="/assets/js/75.72e5d347.js"><link rel="prefetch" href="/assets/js/76.7f1bc93d.js"><link rel="prefetch" href="/assets/js/77.7f9bb46a.js"><link rel="prefetch" href="/assets/js/78.16497536.js"><link rel="prefetch" href="/assets/js/79.1598ba88.js"><link rel="prefetch" href="/assets/js/8.91ce867e.js"><link rel="prefetch" href="/assets/js/80.d7595902.js"><link rel="prefetch" href="/assets/js/81.c808c887.js"><link rel="prefetch" href="/assets/js/82.49dc6011.js"><link rel="prefetch" href="/assets/js/83.6e151bae.js"><link rel="prefetch" href="/assets/js/84.9d3d5086.js"><link rel="prefetch" href="/assets/js/85.2c4d111e.js"><link rel="prefetch" href="/assets/js/86.cff98baa.js"><link rel="prefetch" href="/assets/js/87.655584a0.js"><link rel="prefetch" href="/assets/js/88.109ad4f1.js"><link rel="prefetch" href="/assets/js/89.46f7ed5c.js"><link rel="prefetch" href="/assets/js/9.8a2e5f54.js"><link rel="prefetch" href="/assets/js/90.1a91e9ca.js"><link rel="prefetch" href="/assets/js/91.26a98055.js"><link rel="prefetch" href="/assets/js/92.6ed9cb6e.js"><link rel="prefetch" href="/assets/js/93.14253412.js"><link rel="prefetch" href="/assets/js/94.54415bcf.js"><link rel="prefetch" href="/assets/js/95.0e1c9d0a.js"><link rel="prefetch" href="/assets/js/96.8654188f.js"><link rel="prefetch" href="/assets/js/97.d338a1d8.js"><link rel="prefetch" href="/assets/js/98.efa1e5c5.js"><link rel="prefetch" href="/assets/js/99.83fa6575.js">
    <link rel="stylesheet" href="/assets/css/0.styles.76d9f797.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin" class="logo"> <span class="site-name can-hide">Pangolin</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">中间件</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">读书笔记</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">个人</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/operating_system/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》</a></li><li class="dropdown-subitem"><a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》</a></li><li class="dropdown-subitem"><a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><a href="/basic/" class="link-title">基础</a> <span class="title" style="display:none;">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》</a></li><li class="dropdown-subitem"><a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》</a></li><li class="dropdown-subitem"><a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="页面" class="dropdown-title"><a href="/ui/" class="link-title">页面</a> <span class="title" style="display:none;">页面</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/0a83b083bdf257cb/" class="nav-link">CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatar.jpeg"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">中间件</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">读书笔记</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">个人</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/operating_system/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》</a></li><li class="dropdown-subitem"><a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》</a></li><li class="dropdown-subitem"><a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><a href="/basic/" class="link-title">基础</a> <span class="title" style="display:none;">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》</a></li><li class="dropdown-subitem"><a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》</a></li><li class="dropdown-subitem"><a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="页面" class="dropdown-title"><a href="/ui/" class="link-title">页面</a> <span class="title" style="display:none;">页面</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/0a83b083bdf257cb/" class="nav-link">CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>ORM框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/4553db/" class="sidebar-link">MyBatis</a></li><li><a href="/pages/d426ff/" class="sidebar-link">Spring集成MyBatis</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/45687a/" class="sidebar-link">基础</a></li><li><a href="/pages/669da3/" class="sidebar-link">Java基础</a></li><li><a href="/pages/06424b/" class="sidebar-link">类与继承</a></li><li><a href="/pages/a29a57/" class="sidebar-link">抽象类与接口</a></li><li><a href="/pages/575ca7/" class="sidebar-link">内部类</a></li><li><a href="/pages/1d42f5/" class="sidebar-link">枚举类</a></li><li><a href="/pages/68df7d/" class="sidebar-link">常用类</a></li><li><a href="/pages/208d9a/" class="sidebar-link">关键字</a></li><li><a href="/pages/19431a/" class="sidebar-link">注解</a></li><li><a href="/pages/98c0c9/" class="sidebar-link">异常</a></li><li><a href="/pages/a08fb2/" class="sidebar-link">泛型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>集合类</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/e52b1c/" class="sidebar-link">集合类</a></li><li><a href="/pages/20a058/" class="sidebar-link">集合容器类概述</a></li><li><a href="/pages/71ab62/" class="sidebar-link">ArrayList与LinkedList</a></li><li><a href="/pages/dd747b/" class="sidebar-link">ArrayDeque</a></li><li><a href="/pages/f0ecf7/" class="sidebar-link">PriorityQueue</a></li><li><a href="/pages/a577c4/" class="sidebar-link">HashMap与HashSet</a></li><li><a href="/pages/b65f71/" class="sidebar-link">LinkedHashMap</a></li><li><a href="/pages/02deb8/" class="sidebar-link">TreeMap与TreeSet</a></li><li><a href="/pages/8b70b6/" class="sidebar-link">WeakHashMap</a></li><li><a href="/pages/098b2b/" class="sidebar-link">CopyOnWriteArrayList</a></li><li><a href="/pages/380128/" class="sidebar-link">ConcurrentHashMap</a></li><li><a href="/pages/b23642/" class="sidebar-link">BlockingQueue</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/5d5b55/" class="sidebar-link">并发</a></li><li><a href="/pages/ef591d/" class="sidebar-link">多线程基础</a></li><li><a href="/pages/870f46/" class="sidebar-link">JMM与Volatile</a></li><li><a href="/pages/70bfda/" class="sidebar-link">JUC与AQS</a></li><li><a href="/pages/60c2c3/" class="sidebar-link">锁与互斥同步</a></li><li><a href="/pages/6e4dfa/" class="sidebar-link">显式锁与ReetrantLock</a></li><li><a href="/pages/a0d56d/" class="sidebar-link">线程安全总结</a></li><li><a href="/pages/b92a49/" class="sidebar-link">JUC组件与线程协作</a></li><li><a href="/pages/103bb5/" class="sidebar-link">Atomic原子变量与Unsafe类与CAS</a></li><li><a href="/pages/065f55/" aria-current="page" class="active sidebar-link">线程池与定时任务</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/dd3660/" class="sidebar-link">ThreadLocal</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>IO</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/7db050/" class="sidebar-link">IO</a></li><li><a href="/pages/ccb0a7/" class="sidebar-link">文件操作</a></li><li><a href="/pages/45bc73/" class="sidebar-link">IO流操作</a></li><li><a href="/pages/404e82/" class="sidebar-link">网络IO操作</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Java高级特性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/396bd1/" class="sidebar-link">Java高级特性</a></li><li><a href="/pages/eaa98b/" class="sidebar-link">Lambda表达式</a></li><li><a href="/pages/40af88/" class="sidebar-link">流Stream</a></li><li><a href="/pages/402b10/" class="sidebar-link">反射</a></li><li><a href="/pages/a5ebcd/" class="sidebar-link">代理</a></li><li><a href="/pages/b48bfe/" class="sidebar-link">Java性能问题定位分析</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/20204f/" class="sidebar-link">其他</a></li><li><a href="/pages/e4cde0/" class="sidebar-link">杂记</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>规范&amp;amp;风格</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ee7259/" class="sidebar-link">规范&amp;amp;风格</a></li><li><a href="/pages/139e3f/" class="sidebar-link">代码整洁之道</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Spring</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ed8d11/" class="sidebar-link">Web基础</a></li><li><a href="/pages/a228d7/" class="sidebar-link">Spring(Boot)基础</a></li><li><a href="/pages/ecd8b6/" class="sidebar-link">Spring Boot应用整合</a></li><li><a href="/pages/76dc08/" class="sidebar-link">Spring MVC</a></li><li><a href="/pages/b9aa73/" class="sidebar-link">Spring AOP</a></li><li><a href="/pages/dc74be/" class="sidebar-link">Spring事务</a></li><li><a href="/pages/b43c8c/" class="sidebar-link">Spring IOC源码分析-概览</a></li><li><a href="/pages/d9b4a5/" class="sidebar-link">Spring IOC源码分析-getBean()</a></li><li><a href="/pages/59dd3e/" class="sidebar-link">Spring IOC源码分析-createBean()</a></li><li><a href="/pages/691b21/" class="sidebar-link">Spring AOP源码分析</a></li><li><a href="/pages/d31e18/" class="sidebar-link">Spring事务源码分析</a></li><li><a href="/pages/f16cdb/" class="sidebar-link">Spring Boot源码分析</a></li><li><a href="/pages/b13a90/" class="sidebar-link">Spring MVC源码分析</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JVM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/943c23/" class="sidebar-link">JVM内存区域与对象解析</a></li><li><a href="/pages/05acae/" class="sidebar-link">内存分配与垃圾收集</a></li><li><a href="/pages/d09a16/" class="sidebar-link">JVM监控与故障处理工具</a></li><li><a href="/pages/06e4ad/" class="sidebar-link">类文件结构与类加载机制</a></li><li><a href="/pages/3d00d5/" class="sidebar-link">虚拟机方法调用与指令执行引擎</a></li><li><a href="/pages/eba070/" class="sidebar-link">程序编译与代码优化</a></li><li><a href="/pages/83896f/" class="sidebar-link">虚拟机调优及参数总结</a></li><li><a href="/pages/8a0034/" class="sidebar-link">GraalVM</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/f6cd57/" class="sidebar-link">数据库系统原理</a></li><li><a href="/pages/410bf5/" class="sidebar-link">MySQL必知必会</a></li><li><a href="/pages/495264/" class="sidebar-link">MySQL开发与优化</a></li><li><a href="/pages/ec7e76/" class="sidebar-link">MySQL架构与日志</a></li><li><a href="/pages/4dbe1f/" class="sidebar-link">MySQL索引</a></li><li><a href="/pages/cbc7ab/" class="sidebar-link">MySQL优化</a></li><li><a href="/pages/4afd3a/" class="sidebar-link">MySQL锁机制与事务并发控制</a></li><li><a href="/pages/412461/" class="sidebar-link">MySQL高级特性</a></li><li><a href="/pages/41888c/" class="sidebar-link">MySQL设计规范</a></li><li><a href="/pages/087de5/" class="sidebar-link">MySQL架构篇</a></li><li><a href="/pages/b0952c/" class="sidebar-link">MySQL复制</a></li><li><a href="/pages/ee884d/" class="sidebar-link">MySQL高可用</a></li><li><a href="/pages/6d4f47/" class="sidebar-link">MySQL运维篇</a></li><li><a href="/pages/b8bad7/" class="sidebar-link">MySQL常用工具</a></li><li><a href="/pages/8bd691/" class="sidebar-link">MySQL日志</a></li><li><a href="/pages/5db7ef/" class="sidebar-link">MySQL备份与恢复</a></li><li><a href="/pages/3e3d3a/" class="sidebar-link">MySQL权限与安全</a></li><li><a href="/pages/5f2a5c/" class="sidebar-link">MySQL监控</a></li><li><a href="/pages/bf28eb/" class="sidebar-link">数据库LeetCode题目</a></li><li><a href="/pages/d4f878/" class="sidebar-link">数据库面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工具</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/2bed26/" class="sidebar-link">Arthas</a></li><li><a href="/pages/84ff17/" class="sidebar-link">CICD</a></li><li><a href="/pages/a7e6ff/" class="sidebar-link">Maven</a></li><li><a href="/pages/2a3f45/" class="sidebar-link">Typora主题</a></li><li><a href="/pages/f28f56/" class="sidebar-link">VuePress</a></li><li><a href="/pages/9d673a/" class="sidebar-link">思源笔记</a></li><li><a href="/pages/538b8a/" class="sidebar-link">环境搭建</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>ORM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c83270/" class="sidebar-link">MyBatis</a></li><li><a href="/pages/29ba44/" class="sidebar-link">Spring集成MyBatis</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/e55b6f/" class="sidebar-link">测试基础</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/develop/#开发" data-v-06225672>开发</a></li><li data-v-06225672><a href="/develop/#Java" data-v-06225672>Java</a></li><li data-v-06225672><a href="/develop/#并发" data-v-06225672>并发</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06225672>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-06-08</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><!---->线程池与定时任务<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_309-线程池与定时任务"><a href="#_309-线程池与定时任务" class="header-anchor">#</a> 309.线程池与定时任务</h1> <h4 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h4> <p><strong>池化技术</strong>非常常见, 线程池, 数据库连接池, HTTP 连接池等等都是对这个思想的应用. 池化技术的思想主要是为了减少每次获取资源的消耗, 提高对资源的利用率.</p> <p>线程池就是一个线程缓存池, 线程是稀缺资源, 如果被无限制的创建, 不仅会消耗系统资源, 还会降低系统的稳定性, 因此 Java 中提供线程池对线程进行统一分配, 调优和监控.</p> <p>在 Web 开发中, 服务器需要接受并处理请求, 所以会为一个请求来分配一个线程来进行处理. 如果每次请求都新创建一个线程的话实现起来非常简便, 但是存在一个问题: 如果并发的请求数量非常多, 但每个线程执行的时间很短, 这样就会频繁的创建和销毁线程, 如此一来会大大降低系统的效率. 可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多.</p> <p>那么有没有一种办法使执行完一个任务, 并不被销毁, 而是可以继续执行其他的任务呢? 这就是线程池的目的了. <strong>线程池为线程生命周期的开销和资源不足问题提供了解决方案. 通过对多个任务重用线程, 线程创建的开销被分摊到了多个任务上. ​</strong></p> <p><strong>什么时候使用线程池</strong>?</p> <ul><li><strong>单个任务处理时间比较短</strong>.</li> <li><strong>需要处理的任务数量很大</strong>.</li></ul> <p><strong>线程池优势</strong>:</p> <ul><li><strong>重用存在的线程, 减少线程创建, 消亡的开销, 提高性能</strong>.</li> <li>提高<strong>响应速度</strong>. 当任务到达时, 任务可以不需要的等到线程创建就能立即执行.</li> <li>提高线程的<strong>可管理性</strong>. 线程是稀缺资源, 如果无限制的创建, 不仅会消耗系统资源, 还会降低系统的稳定性, 使用线程池可以进行统一的分配, 调优和监控.</li></ul> <h4 id="executor框架"><a href="#executor框架" class="header-anchor">#</a> Executor框架</h4> <h5 id="_1-接口与类"><a href="#_1-接口与类" class="header-anchor">#</a> 1.接口与类</h5> <p><strong>Executor 框架</strong>包括: <strong>线程池</strong>, Executor, Executors, ExecutorService, CompletionService, Future, Callable 等.</p> <p>其框架大致如下:</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200615204726276.png" alt="image-20200615204726276"></p> <p><strong>ThreadPoolExecutor</strong> 继承了 <strong>AbstractExecutorService</strong>, AbstractExecutorService 是一个抽象类, 它基本实现了 ExecutorService 接口中的方法. 而 ExecutorService 接口又是<strong>继承</strong>了 Executor 接口.</p> <h6 id="_1-executor接口"><a href="#_1-executor接口" class="header-anchor">#</a> (1)Executor接口</h6> <p><strong>Executor 接口</strong>是线程池框架中最基础的部分(<strong>顶级接口</strong>), 定义了一个用于<strong>执行 Runnable 的 execute 方法</strong>.</p> <p>Executor 接口如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>
    <span class="token comment">// 提交任务的方法</span>
    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h6 id="_2-executorservice接口"><a href="#_2-executorservice接口" class="header-anchor">#</a> (2)ExecutorService接口</h6> <p>另一个接口 <strong>ExecutorService</strong> 继承自 Executor, 定义了更多的方法.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ExecutorService</span> <span class="token keyword">extends</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>
	<span class="token comment">// 在完成已提交的任务后封闭办事, 不再接管新任务</span>
    <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 停止所有正在履行的任务并封闭办事</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> <span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 测试是否该ExecutorService已被关闭</span>
    <span class="token keyword">boolean</span> <span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 测试是否所有任务都履行完毕了</span>
    <span class="token keyword">boolean</span> <span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 可用来提交Callable或Runnable任务, 并返回代表此任务的Future对象</span>
    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">T</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">boolean</span> <span class="token function">awaitTermination</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
    
    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Future</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">invokeAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> tasks<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>

    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Future</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">invokeAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> tasks<span class="token punctuation">,</span>
        <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>

    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">invokeAny</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> tasks<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">;</span>
    
    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">invokeAny</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> tasks<span class="token punctuation">,</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>ExecutorService 中定义了线程池的具体行为. 除了继承而来的 <strong>execute</strong> 方法(执行 <strong>Ruannable</strong> 类型的任务) 这里又增加了一个执行任务的方法: <strong>submit</strong> 方法, 可用来提交 <strong>Callable 或 Runnable 任务</strong>, 并返回代表此任务的 <strong>Future</strong> 对象.</p> <h6 id="_3-executors类"><a href="#_3-executors类" class="header-anchor">#</a> (3)Executors类</h6> <p><strong>Executors 是一个工具类</strong>, 可以用于创建各种线程池. Executors 提供了一系列<strong>工厂方法</strong>用于<strong>创建线程池</strong>, 返回的线程池都实现了 <strong>ExecutorService</strong> 接口.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 创建固定线程数量的线程池</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建不限制线程数量的线程池</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建单线程的线程池</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建一个支持定时及周期性的任务执行的线程池, 多数情况下可用来替代Timer类</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ScheduledExecutorService</span> <span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这四种方法都是用的 Executors 中的 <strong>ThreadFactory</strong> 建立的线程.</p> <h5 id="_2-线程池类别"><a href="#_2-线程池类别" class="header-anchor">#</a> 2.线程池类别</h5> <h6 id="_1-newfixedthreadpool"><a href="#_1-newfixedthreadpool" class="header-anchor">#</a> (1)newFixedThreadPool</h6> <p>创建<strong>固定线程数目</strong>的线程池, 使用固定数目 nThreads 个线程, 使用<strong>无界阻塞队列 LinkedBlockingQueue</strong> <strong>存放任务</strong>, 线程创建后不会超时终止, 由于是无界队列, 如果<strong>排队任务</strong>过多, 可能消耗过多<strong>内存</strong>.</p> <p>包括两个构造方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>
                                  <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span>
                                  <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>
                                  <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span>
                                  <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                  threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>各构造参数总结:</p> <ul><li><strong>核心线程数与最大线程数</strong> nThreads: 构建的 ThreadPoolExecutor 核心线程数与<strong>最大线程数</strong>相等且均为 nThreads, 这说明当前线程池<strong>不会存在非核心线程</strong>, 即不会存在线程的回收(allowCoreThreadTimeOut 默认为 false), 随着任务的提交, 线程数增加到 nThreads 个后就<strong>不会变化</strong>;</li> <li><strong>存活时间</strong>为 0: 线程存在<strong>非核心</strong>线程, 该时间没有特殊效果;</li> <li><strong>等待队列</strong> LinkedBlockingQueue: 该等待队列为 LinkedBlockingQueue类型, <strong>没有长度限制</strong>;</li> <li>ThreadFactory 参数: 默认为 DefaultThreadFactory, 也可通过构造函数设置.</li></ul> <h6 id="_2-newcachedthreadpool"><a href="#_2-newcachedthreadpool" class="header-anchor">#</a> (2)newCachedThreadPool</h6> <p>使用的队列是 <strong>SynchronousQueue</strong> 创建一个<strong>可缓存</strong>的线程池, 调用 execute 将重用以前构造的线程(如果线程空闲可用), 如果现有线程没有可用的, 则创建一个<strong>新线程</strong>并添加到池中. 终止并从缓存中移除那些已有 <strong>60 秒钟</strong>未被使用的线程. 其 <strong>corePoolSize</strong> 是 <strong>0</strong>, <strong>maximumPoolSize</strong> 是 Integer.MAX_VALUE, keepAliveTime 是 60 秒. 因此可以<strong>创建的线程数量是没有限制</strong>的.</p> <p>newCachedThreadPool 方法簇用于创建可缓存任务的 ThreadPoolExecutor 线程池. 包括两个重构方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">,</span>
                                  <span class="token number">60L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span>
                                  <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">,</span>
                                  <span class="token number">60L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span>
                                  <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                  threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>结合上文分析的 ThreadPoolExecutor 各构造参数, 可总结如下:</p> <ol><li><strong>核心线程数</strong>为 <strong>0</strong>: 没有核心线程, 即在<strong>没有任务运行时</strong>所有线程<strong>均会</strong>被回收;</li> <li><strong>最大线程数</strong>为 Integer.MAX_VALUE, 即线程池中最大可存在的线程为 Integer.MAX_VALUE, 由于此值在通常情况下远远大于系统可新建的线程数, 可简单理解为此线程池<strong>不限制最大可建的线程数</strong>, 此处可出现逻辑风险, 在提交任务时可能由于超过系统处理能力造成无法再新建线程时会出现 <strong>OOM</strong> 异常, 提示无法创建新的线程;</li> <li><strong>存活时间</strong> 60 秒: 线程数量超过核心线程后, <strong>空闲</strong> 60 秒的线程将会<strong>被回收</strong>, 根据第一条可知核心线程数为 0, 则本条表示<strong>所有线程空闲超过 60 秒均会被回收</strong>;</li> <li>等待队列 SynchronousQueue: 构建 CachedThreadPool 时, 使用的等待队列为 SynchronousQueue 类型, 此类型的等待队列较为<strong>特殊</strong>, 可认为这是一个<strong>容量为 0</strong> 的<strong>阻塞队列</strong>, 在调用其 offer 方法时, 如当前有消费者正在等待获取元素, 则返回 true, 否则返回 false. 使用此等待队列可做到快速提交任务到空闲线程, 没有空闲线程时触发<strong>新建线程</strong>;</li> <li>ThreadFactory 参数: 默认为 DefaultThreadFactory, 也可通过构造函数设置.</li></ol> <h6 id="_3-newsinglethreadexecutor"><a href="#_3-newsinglethreadexecutor" class="header-anchor">#</a> (3)newSingleThreadExecutor</h6> <p>创建一个只有<strong>一个</strong>线程的线程池, 使用<strong>无界队列 LinkedBlockingQueue</strong>, 线程创建后不会超时终止, 该线程<strong>顺序执行</strong>所有任务, 适用于<strong>需要确保所有任务被顺序执行</strong>的场景. 包括两个构造方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>
        <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>
                                <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span>
                                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>
        <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>
                                <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span>
                                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                threadFactory<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>各构造参数含义:</p> <ol><li><strong>核心线程数与最大线程数 1</strong>: 当前线程池中有且仅有<strong>一个</strong>核心线程;</li> <li>存活时间为 0: 当前线程池<strong>不存在非核心线程</strong>, 不会存在线程的超时回收;</li> <li>等待队列 LinkedBlockingQueue: 任务队列<strong>没有长度限制</strong>;</li> <li>ThreadFactory 参数: 默认为 DefaultThreadFactory, 也可通过构造函数设置.</li></ol> <h6 id="_4-比较"><a href="#_4-比较" class="header-anchor">#</a> (4)比较</h6> <p>当系统<strong>负载不太高</strong>时, 单个任务执行的时间也<strong>短</strong>的话, <strong>newCachedThreadPool</strong> 效率可能更高, 因为<strong>任务不需要排队</strong>, 直接交给一个<strong>空闲线程</strong>进行处理.</p> <p>系统<strong>负载很高</strong>时, newFixedThreadPool 可以通过<strong>队列对新任务</strong>排队, 保证有足够的资源处理实际的任务, 而newCachedThreadPool 则会为每个任务创建一个线程, 导致创建过多的线程竞争 CPU 和内存资源, 这时候使用 newFixedThreadPool 较为合理.</p> <p>系统负载<strong>极高</strong>时, newFixedThreadPool 和 newCachedThreadPool <strong>都不是</strong>很好的选择, newFixedThreadPool 的问题是任务==<strong>队列过长</strong>==, newCachedThreadPool 的问题是创建**==线程过多==<strong>. 这时候应该根据情况</strong>自定义** ThreadPoolExecutor, 传递合适的参数.</p> <p>Executors 工具类创建常见线程池的方法, 现对三种线程池区别进行比较.</p> <table><thead><tr><th style="text-align:center;">线程池类型</th> <th style="text-align:center;">CachedThreadPool</th> <th style="text-align:center;">FixedThreadPool</th> <th style="text-align:center;">SingleThreadExecutor</th></tr></thead> <tbody><tr><td style="text-align:center;"><strong>核心线程数</strong></td> <td style="text-align:center;"><strong>0</strong></td> <td style="text-align:center;">nThreads(用户设定)</td> <td style="text-align:center;"><strong>1</strong></td></tr> <tr><td style="text-align:center;"><strong>最大线程数</strong></td> <td style="text-align:center;"><strong>Integer.MAX_VALUE</strong></td> <td style="text-align:center;">nThreads(用户设定)</td> <td style="text-align:center;"><strong>1</strong></td></tr> <tr><td style="text-align:center;"><strong>非核心线程存活时间</strong></td> <td style="text-align:center;"><strong>60s</strong></td> <td style="text-align:center;"><strong>无非核心线程</strong></td> <td style="text-align:center;"><strong>无非核心线程</strong></td></tr> <tr><td style="text-align:center;"><strong>等待队列最大长度</strong></td> <td style="text-align:center;"><strong>1</strong></td> <td style="text-align:center;"><strong>无限制</strong></td> <td style="text-align:center;"><strong>无限制</strong></td></tr> <tr><td style="text-align:center;">特点</td> <td style="text-align:center;"><strong>提交任务优先复用空闲线程, 没有空闲线程则创建新线程</strong></td> <td style="text-align:center;">固定线程数, 等待运行的任务均放入等待队列</td> <td style="text-align:center;">有且仅有<strong>一个</strong>线程在运行, 等待运行任务放入等待队列, 可保证任务运行顺序与提交顺序一直</td></tr> <tr><td style="text-align:center;">内存溢出</td> <td style="text-align:center;">大量提交任务后, 可能出现<strong>无法创建线程的 OOM</strong></td> <td style="text-align:center;">大量提交任务后, 可能出现<strong>内存不足的 OOM</strong></td> <td style="text-align:center;">大量提交任务后, 可能出现<strong>内存不足的 OOM</strong></td></tr></tbody></table> <h6 id="_5-三种类型的线程池与gc关系"><a href="#_5-三种类型的线程池与gc关系" class="header-anchor">#</a> (5)三种类型的线程池与GC关系</h6> <p><strong>原理说明</strong></p> <p>一般情况下 JVM 中的 GC 根据可达性分析确认一个对象是否可被回收(eligible for GC), 而在运行的<strong>线程</strong>被视为 ‘<strong>GCRoot</strong>’. 因此被在运行的线程引用的对象是不会被 GC 回收的. 在 ThreadPoolExecutor 类中具有<strong>非静态</strong>内部类 <strong>Worker</strong>, 用于表示当前线程池中的线程. 非静态内部类对象具有外部包装类对象的<strong>引用</strong>(此处也可通过查看字节码来验证), 因此 Worker 类的对象即作为<strong>线程对象</strong>(‘GCRoot’)有<strong>持有外部类 ThreadPoolExecutor 对象的引用</strong>, 则在其运行结束之前, 外部内<strong>不会</strong>被 GC 回收.</p> <p>根据以上分析, 再次观察以上三个线程池:</p> <p>1, <strong>CachedThreadPool</strong>: 没有核心线程, 且线程具有超时时间, 可见在其引用消失后, 等待任务运行结束且所有线程空闲回收后, <strong>GC 开始回收此线程池对象</strong>;</p> <p>2, <strong>FixedThreadPool</strong>: 核心线程数及最大线程数均为 nThreads, 并且在默认 allowCoreThreadTimeOut 为 false 的情况下, 其引用消失后, 核心线程即使空闲<strong>也不会</strong>被回收, 故 GC <strong>不会回收该线程池</strong>;</p> <p>3, <strong>SingleThreadExecutor</strong>: 默认与 FixedThreadPool 情况一致, 但由于其语义为<strong>单线程</strong>线程池, JDK 开发人员为其提供了 FinalizableDelegatedExecutorService 包装类, 在创建 FixedThreadPool 对象时实际返回的是 FinalizableDelegatedExecutorService 对象, 该对象持有 FixedThreadPool 对象的引用, 但 FixedThreadPool 对象并不引用 FinalizableDelegatedExecutorService 对象, 这使得在 FinalizableDelegatedExecutorService 对象的外部引用消失后, <strong>GC 将会对其进行回收</strong>, 触发 finalize 函数, 而该函数仅仅简单的调用 shutdown 函数关闭线程, 是的所有当前的任务执行完成后, 回收线程池中线程, 则 GC 可回收线程池对象.</p> <p>因此可得出<strong>结论</strong>, <strong>CachedThreadPool</strong> 及 <strong>SingleThreadExecutor</strong> 的对象在<strong>不显式调用</strong> shutdown 函数(或 shutdownNow 函数), 且其对象引用消失的情况下, <strong>可以被 GC 回收</strong>; <strong>FixedThreadPool</strong> 对象在<strong>不显式调用</strong> shutdown 函数(或 shutdownNow 函数), 且其对象引用消失的情况下<strong>不会被 GC 回收, 会出现内存泄露</strong>.</p> <p><strong>实验验证</strong>: 以上结论可使用实验验证:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ExecutorService executorService = Executors.newFixedThreadPool(1);</span>
    <span class="token comment">// ExecutorService executorService = Executors.newSingleThreadExecutor();</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 线程引用置空</span>
    executorService <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addShutdownHook</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Shutdown.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 等待线程超时, 主要对CachedThreadPool有效</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 手动触发GC</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>使用以上代码, 分别创建三种不同的线程池, 可发现最终 FixedThreadPool 不会打印出 &quot;Shutdown.&quot;, JVM 没有退出. 另外两种线程池均能<strong>退出</strong> JVM. 因此无论使用什么线程池线程池使用完毕后均<strong>调用 shutdown()</strong> 以保证其最终会被 GC 回收是一个较为安全的编程习惯.</p> <h5 id="_3-线程池任务执行"><a href="#_3-线程池任务执行" class="header-anchor">#</a> 3.线程池任务执行</h5> <p>在 Java5 之后, 任务分两类: 一类是实现了 <strong>Runnable</strong> 接口的类, 一类是实现了 <strong>Callable</strong> 接口的类. 两者都可以被 <strong>ExecutorService</strong> 执行, 但是 Runnable 任务没有返回值, 而 Callable 任务有返回值.</p> <p><strong>Executor 接口提供 execute 方法(执行 Runnable), ExecutorService 接口继承自 Executor 接口并拓展了 submit 方法(执行 Runnable 与 Callable). ​</strong></p> <p>任务提交</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment">// 提交任务无返回值</span>
<span class="token keyword">public</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 任务执行完成后有返回值  </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h6 id="_1-执行runnable任务"><a href="#_1-执行runnable任务" class="header-anchor">#</a> (1)执行Runnable任务</h6> <p>通过 Executors 的以上四个静态工厂方法获得 <strong>ExecutorService</strong> 实例, 而后调用该实例的 <strong>execute</strong>(Runnable command)方法即可. 一旦 Runnable 任务传递到 <strong>execute</strong>() 方法, 该方法便会自动在<strong>一个线程</strong>上执行. 下面是 Executor 执行 Runnable 任务的示例代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestCachedThreadPool</span><span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">// 创建线程池</span>
		<span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//      ExecutorService executorService = Executors.newFixedThreadPool(5);</span>
<span class="token comment">//		ExecutorService executorService = Executors.newSingleThreadExecutor();</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;线程被调用了. &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;************* a&quot;</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">&quot; *************&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> a0 <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span>线程被调用了<span class="token punctuation">.</span> 
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> a1 <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span>线程被调用了<span class="token punctuation">.</span> 
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> a2 <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> a3 <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span>线程被调用了<span class="token punctuation">.</span> 
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span>线程被调用了<span class="token punctuation">.</span> 
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> a4 <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span>线程被调用了<span class="token punctuation">.</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>execute 会首先在线程池中选择一个<strong>已有空闲线程</strong>来执行任务, 如果线程池中没有空闲线程, 它便会<strong>创建一个新的线程</strong>来执行任务. 这个得根据创建的线程池类型.</p> <h6 id="_2-执行callable任务"><a href="#_2-执行callable任务" class="header-anchor">#</a> (2)执行Callable任务</h6> <p>Callable 的 <strong>call</strong>() 方法只能通过 ExecutorService 的 <strong>submit</strong> (Callable<T> task) 方法来执行, 并且返回一个 <T> Future<T>, 是表示任务<strong>等待完成的 Future</strong>.</T></T></T></p> <p>Callable 接口类似于 Runnable, 两者都是为那些其实例可能被另一个线程执行的类设计的. 但是 Runnable 不会返回结果, 并且无法抛出经过检查的异常而 Callable 又<strong>返回结果</strong>, 而且当获取返回结果时可能会<strong>抛出异常</strong>. Callable 中的 <strong>call</strong>() 方法类似 Runnable 的 <strong>run</strong>() 方法, 区别同样是有返回值, 后者没有.</p> <p>当将一个 Callable 的对象传递给 ExecutorService 的 <strong>submit</strong> 方法, 则该 call 方法自动在一个<strong>线程</strong>上执行, 并且会返回执行<strong>结果 Future</strong> 对象.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span> 
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span> 
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span> 

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CallableDemo</span><span class="token punctuation">{</span> 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token comment">// 创建线程池</span>
        <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token comment">// 创建结果存放列表</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Future</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> resultList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Future</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

        <span class="token comment">// 创建10个任务并执行 </span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
            <span class="token comment">// 使用ExecutorService执行Callable类型的任务, 并将结果保存在future变量中 </span>
            <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TaskWithResult</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token comment">// 将任务执行结果存储到List中 </span>
            resultList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span> 

        <span class="token comment">// 遍历任务的结果 </span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> fs <span class="token operator">:</span> resultList<span class="token punctuation">)</span><span class="token punctuation">{</span> 
            <span class="token keyword">try</span><span class="token punctuation">{</span> 
                <span class="token comment">// Future返回如果没有完成, 则会阻塞! 直到Future返回完成</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>fs<span class="token punctuation">.</span>isDone<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 打印各个线程(任务)执行的结果</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      
            <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span> 
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span> 
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span> 
                <span class="token comment">// 启动一次顺序关闭, 执行以前提交的任务, 但不接受新任务</span>
                executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token punctuation">}</span> 
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> 

<span class="token keyword">class</span> <span class="token class-name">TaskWithResult</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span> 
    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span> 

    <span class="token keyword">public</span> <span class="token class-name">TaskWithResult</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 

    <span class="token comment">/** 
	 * 任务的具体过程, 一旦任务传给ExecutorService的submit方法, 
	 * 则该方法自动在一个线程上执行
	 */</span> 
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;call()方法被自动调用! ! ! &quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token comment">// 该返回结果将被Future的get方法得到</span>
        <span class="token keyword">return</span> <span class="token string">&quot;call()方法被自动调用, 任务返回的结果是: &quot;</span> <span class="token operator">+</span> id <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br></div></div><p>需要注意: 如果 Future 的返回尚未完成, 则 get() 方法会<strong>阻塞等待</strong>, 直到 Future 完成返回, 可以通过调用 <strong>isDone</strong>() 方法判断 Future 是否完成了返回.</p> <p><strong>总结</strong>:</p> <ol><li><strong>execute() 方法用于提交不需要返回值的任务, 所以无法判断任务是否被线程池执行成功与否; ​</strong></li> <li><strong>submit() 方法用于提交需要返回值的任务. 线程池会返回一个 Future 类型的对象, 通过这个 Future 对象可以判断任务是否执行成功</strong>, 并且可以通过 Future 的 get() 方法来获取返回值, get() 方法会阻塞当前线程直到任务完成, 而使用 get(long timeout, TimeUnit unit) 方法则会阻塞当前线程一段时间后立即返回, 这时候有可能任务没有执行完.</li></ol> <p>以 <strong>AbstractExecutorService</strong> 接口中的一个 <strong>submit</strong>() 方法为例子来看看源代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>上面方法调用的 newTaskFor 方法返回了一个 FutureTask 对象.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> runnable<span class="token punctuation">,</span> <span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>runnable<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h6 id="_3-executor的中断任务"><a href="#_3-executor的中断任务" class="header-anchor">#</a> (3)Executor的中断任务</h6> <p>调用 Executor 的 <strong>shutdown</strong>() 方法会等待线程都<strong>执行完毕之后</strong>再关闭, 但是如果调用的是 <strong>shutdownNow</strong>() 方法, 则相当于调用<strong>每个线程的 interrupt()</strong> 方法.</p> <p>以下使用 Lambda 创建线程, 相当于创建了一个匿名内部线程.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Thread run&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 立马结束</span>
    executorService<span class="token punctuation">.</span><span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Main run&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><div class="language-html line-numbers-mode"><pre class="language-html"><code>Main run
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)
    at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>如果只想中断 Executor 中的一个线程, 可以通过使用 <strong>submit()</strong> 方法来提交一个线程, 它会返回一个 <strong>Future&lt;?&gt; 对象</strong>, 通过调用该对象的 <strong>cancel</strong>(true) 方法就可以单独<strong>中断线程</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 通过Future对象中断线程</span>
future<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="threadpoolexecutor源码分析"><a href="#threadpoolexecutor源码分析" class="header-anchor">#</a> ThreadPoolExecutor源码分析</h4> <h5 id="_1-概述"><a href="#_1-概述" class="header-anchor">#</a> 1.概述</h5> <p>上面的几个线程池都是通过 ThreadPoolExecutor 构造方法进行创建的. 这个<strong>十分重要</strong>, 阿里也建议自己这样构造.</p> <p>Doug Lea 在设计线程池 ThreadPoolExecutor 的提交任务的顶层接口 Executor 只有一个无状态的执行方法 execute, 而 ExecutorService 提供了很多扩展方法底层基本上是基于 Executor#execute() 方法进行扩展. 这里着重分析 execute 方法. 这里基于 JDK11.</p> <p>ThreadPoolExecutor 里面使用到 JUC 同步器框架 <strong>AbstractQueuedSynchronizer</strong>(俗称 AQS), 大量的位操作,  CAS 操作.</p> <blockquote><p><strong>JUC同步器框架</strong></p></blockquote> <p>ThreadPoolExecutor 里面使用到 JUC 同步器框架, 主要用于四个方面:</p> <ul><li>全局锁 mainLock 成员属性, 是可重入锁 ReentrantLock 类型, 主要是用于访问工作线程 Worker 集合和进行数据统计记录时候的加锁操作.</li> <li>条件变量 termination, Condition 类型, 主要用于线程进行等待终结 awaitTermination() 方法时的带期限阻塞.</li> <li>任务队列 workQueue, BlockingQueue<Runnable> 类型, 任务队列, 用于存放待执行的任务.</Runnable></li> <li>工作线程, 内部类 Worker 类型, 是线程池中<strong>真正的工作线程对象</strong>.</li></ul> <h5 id="_2-关键属性"><a href="#_2-关键属性" class="header-anchor">#</a> 2.关键属性</h5> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutor</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExecutorService</span> <span class="token punctuation">{</span>

    <span class="token comment">// 控制变量-存放状态和线程数</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token constant">RUNNING</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 任务队列, 必须是阻塞队列</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">;</span>

    <span class="token comment">// 工作线程集合, 存放线程池中所有的(活跃的)工作线程, 只有在持有全局锁mainLock的前提下才能访问此集合</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Worker</span><span class="token punctuation">&gt;</span></span> workers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 全局锁</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// awaitTermination方法使用的等待条件变量</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> termination <span class="token operator">=</span> mainLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 记录峰值线程数</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> largestPoolSize<span class="token punctuation">;</span>

    <span class="token comment">// 记录已经成功执行完毕的任务数</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> completedTaskCount<span class="token punctuation">;</span>

    <span class="token comment">// 线程工厂, 用于创建新的线程实例</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">;</span>

    <span class="token comment">// 拒绝执行处理器, 对应不同的拒绝策略</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">;</span>

    <span class="token comment">// 空闲线程等待任务的时间周期, 单位是纳秒</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">;</span>

    <span class="token comment">// 是否允许核心线程超时, 如果为true则keepAliveTime对核心线程也生效</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> allowCoreThreadTimeOut<span class="token punctuation">;</span>

    <span class="token comment">// 核心线程数</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> corePoolSize<span class="token punctuation">;</span>

    <span class="token comment">// 线程池容量</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">;</span>

    <span class="token comment">// 省略其他代码</span>
<span class="token punctuation">}</span>    
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><p>每个变量的作用都已经标明出来了, 这里要重点解释一下 <strong>corePoolSize, maximumPoolSize, largestPoolSize</strong> 三个变量. 后面也会详述.</p> <p>corePoolSize 在很多地方被翻译成<strong>核心池大小</strong>, 其实我的理解这个就是线程池的大小. 举个简单的例子:</p> <p>假如有一个工厂, 工厂里面有 10个 工人, 每个工人同时只能做一件任务. 因此只要当 10 个工人中有工人是空闲的, 来了任务就分配给空闲的工人做; 当 10 个工人都有任务在做时, 如果还来了任务, 就把任务进行排队等待; 如果说新任务数目增长的速度远远大于工人做任务的速度, 那么此时工厂主管可能会想补救措施, 比如重新招 4 个临时工人进来; 然后就将任务也分配给这 4 个临时工人做; 如果说着 14 个工人做任务的速度还是不够, 此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了. 当这 14 个工人当中有人空闲时, 而新任务增长的速度又比较缓慢, 工厂主管可能就考虑辞掉 4 个临时工了, 只保持原来的 10 个工人, 毕竟请额外的工人是要花钱的.</p> <p>这个例子中的 corePoolSize 就是 10, 而 maximumPoolSize 就是10 + 4 = 14. 也就是说 corePoolSize 就是线程池大小,  maximumPoolSize 在我看来是线程池的一种补救措施, 即任务量<strong>突然过大</strong>时的一种补救措施.</p> <p>largestPoolSize 只是一个用来起记录作用的变量, 用来记录线程池中曾经有过的最大线程数目, 跟线程池的容量<strong>没有</strong>任何关系.</p> <h5 id="_3-构造方法与核心参数"><a href="#_3-构造方法与核心参数" class="header-anchor">#</a> 3.构造方法与核心参数</h5> <p>ThreadPoolExecutor 类的构造方法如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
                          <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
                          <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>
        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>
        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>
        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> threadFactory <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> handler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>可以自定义核心线程数, 线程池容量(最大线程数), 空闲线程等待任务周期, 任务队列, 线程工厂, 拒绝策略.</p> <p>核心参数解释:</p> <h6 id="_1-核心线程数corepoolsize"><a href="#_1-核心线程数corepoolsize" class="header-anchor">#</a> (1)核心线程数corePoolSize</h6> <p>线程池中的<strong>核心线程数</strong>. 默认情况下, 当提交一个任务时, 线程池<strong>创建一个新线程执行任务</strong>, <strong>直到当前线程数等于 corePoolSize</strong>; 如果当前线程数为 corePoolSize, 继续提交的任务被保存到<strong>阻塞队列</strong>中, 等待被执行; 如果执行了线程池的 <strong>prestartAllCoreThreads</strong>() 方法, 线程池会<strong>提前预创建并启动所有核心线程</strong>. 核心线程是<strong>懒创建</strong>的, 没到 corePoolSize 之前是来一个任务创建一个.</p> <h6 id="_2-最大线程数maximumpoolsize"><a href="#_2-最大线程数maximumpoolsize" class="header-anchor">#</a> (2)最大线程数maximumPoolSize</h6> <p>线程池<strong>最大</strong>线程数, 表示在线程池中最多能创建多少个线程. 如果当前阻塞队列满了, 且继续提交任务, 则创建新的线程执行任务, 前提是当前线程数小于 maximumPoolSize. 注意: 多于的<strong>空闲</strong>非核心线程存活超过 <strong>keepAliveTime</strong> 后会被销毁. 当<strong>阻塞队列中存放的任务达到队列容量</strong>的时候, 会创建新的线程执行任务直到达到最大线程数.</p> <blockquote><p><strong>PS: 动态调整线程池容量</strong></p></blockquote> <p>ThreadPoolExecutor提供了动态调整线程池容量大小的方法: setCorePoolSize() 和 setMaximumPoolSize(),</p> <ul><li><strong>setCorePoolSize</strong>: 设置核心池大小.</li> <li><strong>setMaximumPoolSize</strong>: 设置线程池最大能创建的线程数目大小.</li></ul> <p>当上述参数从小变大时, ThreadPoolExecutor 进行线程赋值, 还可能立即创建新的线程来执行任务.</p> <h6 id="_3-非核心线程存活时间keepalivetime"><a href="#_3-非核心线程存活时间keepalivetime" class="header-anchor">#</a> (3)非核心线程存活时间keepAliveTime</h6> <p>当线程池中的线程数量<strong>大于 corePoolSize</strong> 的时候, 如果这时没有新的任务提交, 核心线程外的线程不会立即销毁, 而是会等待, 直到等待的时间超过了 <strong>keepAliveTime</strong>. 这时候会把<strong>非核心线程</strong>销毁. <strong>默认情况</strong>下, 只有当线程池中的线程数<strong>大于 corePoolSize</strong> 时, keepAliveTime 才会起作用, 直到线程池中的线程数不大于 corePoolSize, 即当线程池中的线程数大于 corePoolSize 时, 如果一个线程空闲的时间达到 keepAliveTime, 则会终止, 直到线程池中的线程数不超过 corePoolSize.</p> <p>但是如果调用了 <strong>allowCoreThreadTimeOut</strong>(boolean) 方法, 在线程池中的线程数<strong>不大于</strong> corePoolSize 时, keepAliveTime 参数<strong>也会</strong>起作用, 直到线程池中的线程数为 0, 也就是<strong>核心线程也可能被销毁</strong>. 所以说, <strong>核心线程</strong>可能也会被全部销毁到 0.</p> <h6 id="_4-时间单位unit"><a href="#_4-时间单位unit" class="header-anchor">#</a> (4)时间单位unit</h6> <p>keepAliveTime 的单位.</p> <h6 id="_5-阻塞任务队列workqueue"><a href="#_5-阻塞任务队列workqueue" class="header-anchor">#</a> (5)阻塞任务队列workQueue</h6> <p>用来<strong>保存等待被执行的任务的阻塞队列</strong>, 且任务必须实现 Runable 接口, 在 JDK 中提供了如下阻塞队列:</p> <ul><li><strong>LinkedBlockingQuene</strong>: 基于链表结构的阻塞队列, 按 FIFO 排序任务.</li> <li><strong>SynchronousQuene</strong>: 一个<strong>不存储元素</strong>的阻塞队列, 每个插入操作必须等到另一个线程调用<strong>移除操作</strong>, 否则插入操作一直处于阻塞状态, <strong>吞吐量</strong>通常要高于 LinkedBlockingQuene;</li> <li>ArrayBlockingQueue: 基于数组结构的有界阻塞队列, 按 FIFO 排序任务;</li> <li>PriorityBlockingQuene: 具有优先级的无界阻塞队列;</li></ul> <p>多用 LinkedBlockingQuene 和 SynchronousQuene.</p> <h6 id="_6-线程工厂threadfactory"><a href="#_6-线程工厂threadfactory" class="header-anchor">#</a> (6)线程工厂threadFactory</h6> <p>用来创建新线程. 默认使用 Executors.<strong>defaultThreadFactory</strong>() 来创建线程. 使用默认的 ThreadFactory 来创建线程
时, 会使新创建的线程<strong>具有相同的 NORM_PRIORITY 优先级并且是非守护线程, 同时也设置了线程的名称</strong>.   一般自定义线程工厂才能更好地跟踪工作线程.</p> <h6 id="_7-拒绝策略handler"><a href="#_7-拒绝策略handler" class="header-anchor">#</a> (7)拒绝策略handler</h6> <p>当线程池的<strong>任务缓存队列已满</strong>并且线程池中的<strong>线程数目达到 maximumPoolSize</strong>, 如果还有任务到来就会采取<strong>任务拒绝策略</strong>, 线程池提供了 4 种策略:</p> <ul><li>ThreadPoolExecutor.<strong>AbortPolicy</strong>: <strong>丢弃任务并直接抛出异常</strong>, <strong>默认策略; ​</strong>这代表你将丢失对这个任务的处理.</li> <li>ThreadPoolExecutor.CallerRunsPolicy: 用调用者所在的线程来执行任务; 对于可伸缩的应用程序, 建议使用此策略. 当最大池被填满时, 此策略为我们提供可伸缩队列. <strong>一般不希望任务丢失会选用这种策略, 但从实际角度来看, 原来的异步调用意图会退化为同步调用</strong>.</li> <li>ThreadPoolExecutor.DiscardOldestPolicy: 丢弃阻塞队列中靠<strong>最前</strong>的任务, 并执行当前任务;</li> <li>ThreadPoolExecutor.DiscardPolicy: 直接<strong>丢弃</strong>任务, 不抛异常;</li></ul> <p>上面的 4 种策略都是 ThreadPoolExecutor 的<strong>内部类</strong>. 当然也可以根据应用场景实现 <strong>RejectedExecutionHandler</strong> 接口, 自定义饱和策略, 如<strong>记录日志或持久化存储不能处理的任务</strong>.</p> <h5 id="_4-线程池状态"><a href="#_4-线程池状态" class="header-anchor">#</a> 4.线程池状态</h5> <h6 id="_1-ctl变量"><a href="#_1-ctl变量" class="header-anchor">#</a> (1)ctl变量</h6> <p><strong>状态控制主要围绕原子整型成员变量 ctl</strong>. ctl 贯穿在线程池的<strong>整个生命周期</strong>中.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token constant">RUNNING</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>它是一个<strong>原子变量</strong>, 主要作用是用来<strong>保存线程数量和线程池的状态</strong>. 分析一下这段代码, 用到了<strong>位运算</strong>.</p> <p>一个 int 数值是 32 个 bit 位, 这里采用<strong>高 3 位来保存运行状态 runState</strong>, <strong>低 29 位来保存有效线程数量 workCount</strong>.</p> <p>COUNT_BITS 就是 29, CAPACITY 就是 1 左移 29 位减 1(29 个 1), 这个常量表示 workerCount 的上限值, 大约最大线程数是 5 亿.   这个数量在短时间内不用考虑会超限.</p> <p><strong>ctl 相关方法: ​</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 获取运行状态</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token constant">CAPACITY</span>; <span class="token punctuation">}</span>
<span class="token comment">// 获取活动线程数</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token constant">CAPACITY</span>; <span class="token punctuation">}</span>
<span class="token comment">// 获取运行状态和活动线程数的值</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rs <span class="token operator">|</span> wc; <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>PS: 线程池源码中有很多中间变量用了简单的单字母表示, 例如 c 就是表示 ctl, wc 就是表示 worker count, rs 就是表示 running status.</p> <p>我们来分析默认情况下, 也就是 ctlOf(RUNNING)<strong>运行状态</strong>, 调用了 <strong>ctlOf</strong>(int rs, int wc)方法;</p> <p>其中</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token constant">RUNNING</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>即 -1 左移 29 位.  -1 的二进制是
32 个 1(1111 1111 1111 1111 1111 1111 1111 1111)</p> <p>那么-1 &lt;&lt; 左移 29 位,  也就是 【111】 表示:  rs | wc . 二进制的 111 | 000 . 得到的结果仍然是 111.</p> <p>那么同理可得其他的<strong>状态的 bit 位</strong>表示:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">COUNT_BITS</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">SIZE</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 32-3=29</span>
<span class="token comment">// 将 1 的二进制向右位移 29 位,再减 1 表示最大线程容量</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CAPACITY</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h6 id="_2-线程池的5种状态"><a href="#_2-线程池的5种状态" class="header-anchor">#</a> (2)线程池的5种状态</h6> <p>线程池的<strong>五种状态</strong>对应五种状态变量: <strong>运行状态</strong>保存在 <strong>ctl 值的高 3 位</strong> (所有数值左移 29 位).</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 接收新任务,并执行队列中的任务</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">RUNNING</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token comment">// 不接收新任务,但是执行队列中的任务</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token comment">// 不接收新任务,不执行队列中的任务,中断正在执行中的任务</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">STOP</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>    
<span class="token comment">// 所有的任务都已结束,线程数量为 0,处于该状态的线程池即将调用 terminated()方法</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TIDYING</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span> 
<span class="token comment">// terminated()方法执行完成</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TERMINATED</span> <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>状态转换过程如下:</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220603144659424.png" alt=""></p> <p><strong>RUNNING</strong></p> <p>状态说明: 线程池处在 RUNNING 状态时, 能够<strong>接收新任务</strong>, 以及对已添加的任务进行处理.</p> <p>状态切换: 线程池的初始化状态是 RUNNING. 换句话说, 线程池被一旦被创建, 就处于 RUNNING 状态, 并且线程池中的任务数为 <strong>0! ​</strong></p> <p><strong>SHUTDOWN</strong></p> <p>状态说明: 线程池处在 SHUTDOWN 状态时, <strong>不接收</strong>新任务, 但会把已添加的任务<strong>执行完</strong>.</p> <p>状态切换: 调用线程池的 <strong>shutdown</strong>() 接口时, 线程池由 RUNNING -&gt; SHUTDOWN.</p> <p><strong>STOP</strong></p> <p>状态说明: 线程池处在 STOP 状态时, <strong>不接收</strong>新任务, <strong>不处理</strong>已添加的任务, 并且会<strong>中断正在处理</strong>的任务.</p> <p>状态切换: 调用线程池的 <strong>shutdownNow</strong>() 接口时, 线程池由 (RUNNING or SHUTDOWN ) -&gt; STOP.</p> <p><strong>TIDYING</strong></p> <p>状态说明: 当所有的任务已<strong>终止</strong>, <strong>ctl 记录的”任务数量”为 0</strong>, 线程池会变为 <strong>TIDYING</strong> 状态. 当线程池变为 TIDYING 状态时, 会执行<strong>钩子函数 terminated()</strong>. terminated() 在 <strong>ThreadPoolExecutor</strong> 类中是空的, 若用户想在线程池变为 TIDYING 时, 进行相应的处理; 可以通过<strong>覆写 terminated() 函数</strong>来实现.</p> <p>状态切换: 当线程池在 SHUTDOWN 状态下, 阻塞队列为空并且线程池中执行的任务也为空时, 就会由 SHUTDOWN -&gt; TIDYING.  当线程池在 STOP 状态下, 线程池中执行的任务为空时, 就会由 STOP -&gt; TIDYING.</p> <p><strong>TERMINATED</strong></p> <p>状态说明: 线程池<strong>彻底终止</strong>, 就变成 TERMINATED 状态.</p> <p>状态切换: 线程池处在 TIDYING 状态时, 执行完 <strong>terminated</strong>() 之后, 就会由 TIDYING -&gt; TERMINATED.</p> <p>进入 TERMINATED 的<strong>条件</strong>如下:</p> <ul><li>线程池不是 RUNNING 状态;</li> <li>线程池状态不是 TIDYING 状态或 TERMINATED 状态;</li> <li>如果线程池状态是  SHUTDOWN 并且 workerQueue 为空;</li> <li>workerCount 为 0;</li> <li>设置 TIDYING 状态成功.</li></ul> <h5 id="_5-execute源码与线程池执行原理"><a href="#_5-execute源码与线程池执行原理" class="header-anchor">#</a> 5.execute源码与线程池执行原理</h5> <h6 id="_1-execute源码"><a href="#_1-execute源码" class="header-anchor">#</a> (1)execute源码</h6> <p>线程池异步执行任务的方法实现是 ThreadPoolExecutor#<strong>execute</strong>(), 源码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 执行命令, 其中命令(下面称任务)对象是Runnable的实例</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判断命令(任务)对象非空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取ctl状态的值</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 判断如果当前工作线程数小于核心线程数, 直接创建新的核心线程并且执行传入的任务</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果创建新的核心线程成功则直接返回, true表示是核心线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token comment">// 这里说明创建核心线程失败, 需要更新ctl的临时变量c</span>
        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 走到这里说明创建新的核心线程失败, 也就是当前工作线程数大于等于核心线程数corePoolSize</span>
    <span class="token comment">// 判断线程池是否处于运行中状态, 同时尝试用非阻塞方法向任务队列放入任务(放入任务失败返回false)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里是向任务队列投放任务成功, 对线程池的运行中状态做二次检查</span>
        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果线程池二次检查状态是非运行中状态, 则从任务队列移除当前的任务调用拒绝策略处理之(也就是移除前面成功入队的任务实例)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment">// 调用拒绝策略处理任务--返回</span>
            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 走到下面的else if分支, 说明有以下的前提: </span>
        <span class="token comment">// 0, 待执行的任务已经成功加入任务队列</span>
        <span class="token comment">// 1, 线程池可能是RUNNING状态</span>
        <span class="token comment">// 2, 传入的任务可能从任务队列中移除失败(移除失败的唯一可能就是任务已经被执行了)</span>
        <span class="token comment">// 如果当前工作线程数量为0, 则创建一个非核心线程并且传入的任务对象为null - 返回</span>
        <span class="token comment">// 也就是创建的非核心线程不会马上运行, 而是等待获取任务队列的任务去执行 </span>
        <span class="token comment">// 如果前工作线程数量不为0, 原来应该是最后的else分支, 但是可以什么也不做, 因为任务已经成功入队列, 总会有合适的时机分配其他空闲线程去执行它</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token comment">// false表示是非核心线程</span>
            <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 走到这里说明有以下的前提: </span>
    <span class="token comment">// 0, 线程池中的工作线程总数已经大于等于corePoolSize(简单来说就是核心线程已经全部懒创建完毕)</span>
    <span class="token comment">// 1, 线程池可能不是RUNNING状态</span>
    <span class="token comment">// 2, 线程池可能是RUNNING状态同时任务队列已经满了</span>
    <span class="token comment">// 如果向任务队列投放任务失败, 则会尝试创建非核心线程传入任务执行</span>
    <span class="token comment">// 创建非核心线程失败, 此时需要拒绝执行任务</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 调用拒绝策略处理任务 - 返回</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><p>这里简单分析一下整个流程:</p> <ul><li>如果当前工作线程总数<strong>小于 corePoolSize</strong>, 则直接创建<strong>核心线程执行任务</strong>(任务实例会传入直接用于构造工作线程实例).</li> <li>如果当前工作线程总数大于等于 corePoolSize, 判断线程池是否处于<strong>运行中</strong>状态, 同时尝试用<strong>非阻塞方法向任务队列</strong>放入任务, 这里会二次检查线程池运行状态, 如果当前工作线程数量为 0, 则创建一个<strong>非核心线程</strong>并且传入的任务对象为 null.</li> <li>如果向任务队列投放任务失败(任务队列已经满了), 则会尝试<strong>创建非核心线程</strong>传入任务实例执行.</li> <li>如果创建非核心线程失败, 此时需要<strong>拒绝执行任务</strong>, 调用<strong>拒绝策略</strong>处理任务.</li></ul> <h6 id="_2-线程池添加任务原理图解"><a href="#_2-线程池添加任务原理图解" class="header-anchor">#</a> (2)线程池添加任务原理图解</h6> <p>下图是线程池的工作原理图.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220603144731579.png" alt="image-20220603144731579"></p> <p>看上图中的执行顺序 1-4. 假如有 20 个任务, 假设每个任务都执行很长时间.</p> <p><strong>Step1</strong>: 假设<strong>核心线程数为 4</strong>. 那么前面 4 个提交的任务会直接<strong>创建线程</strong>并执行, 直到达到核心线程数 corePoolSize.</p> <p><strong>Step2</strong>: 当达到核心线程数后, 新的任务进入到<strong>任务队列中排队</strong>, 这个就是<strong>阻塞队列</strong>, 假设这里限制了阻塞队列长度为 4, 那么当前还剩下 12 个任务.</p> <p><strong>Step3</strong>: 此时还有任务, 这时候就到第三步创建非核心线程执行任务, 假设这里最大线程数 maximumPoolSize 为 6, 即还可以创建<strong>两个非核心线程</strong>. 这时候还剩下十个任务.</p> <p><strong>Step4</strong>: 此时多于的任务不能再加了, 则采用<strong>拒绝策略</strong>进行处理.</p> <p>实例代码: 这里的线程池参数就是按照上述的设置的.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestExecuteTask</span> <span class="token punctuation">{</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">ThreadPoolExecutor</span> executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span>
				<span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyTask</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程池中核心线程数目: &quot;</span> <span class="token operator">+</span> executor<span class="token punctuation">.</span><span class="token function">getCorePoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
					<span class="token string">&quot;线程池中总线程数目: &quot;</span> <span class="token operator">+</span> executor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;,队列中等待执行的任务数目: &quot;</span> <span class="token operator">+</span> executor<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;,已执行完别的任务数目: &quot;</span> <span class="token operator">+</span> executor<span class="token punctuation">.</span><span class="token function">getCompletedTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 这里注释掉关闭线程池的逻辑防止直接就运行完了</span>
        <span class="token comment">// executor.shutdown();</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 任务类</span>
	<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

		<span class="token keyword">private</span> <span class="token keyword">int</span> taskId<span class="token punctuation">;</span>

		<span class="token keyword">public</span> <span class="token class-name">MyTask</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>taskId <span class="token operator">=</span> id<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token annotation punctuation">@Override</span>
		<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;开始执行task:&quot;</span><span class="token operator">+</span> taskId<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 这里休眠十秒, 防止任务过快结束</span>
				<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;task &quot;</span><span class="token operator">+</span> taskId <span class="token operator">+</span><span class="token string">&quot;执行完毕&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>执行结果如下, 可以看到. 核心线程数为 4, 则前面 0-3 这四个任务都是直接创建新的线程执行任务. 之后的 4-7 四个任务被放入到任务队列等待执行, 然后 8, 9 两个任务通过创建两个非核心线程执行, 此时任务到底饱和(由于任务时间长, 没有任务执行), 所以默认拒绝策略抛出异常. 同时, 由于是 4-7 号任务在阻塞队列等待, 当其他任务执行完之后才开始从队列中获取任务并执行. 这个过程与上述分析是一致的.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>开始执行task<span class="token operator">:</span><span class="token number">0</span>
线程池中核心线程数目<span class="token operator">:</span> <span class="token number">4</span>线程池中总线程数目<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>队列中等待执行的任务数目<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>已执行完别的任务数目<span class="token operator">:</span> <span class="token number">0</span>
线程池中核心线程数目<span class="token operator">:</span> <span class="token number">4</span>线程池中总线程数目<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>队列中等待执行的任务数目<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>已执行完别的任务数目<span class="token operator">:</span> <span class="token number">0</span>
线程池中核心线程数目<span class="token operator">:</span> <span class="token number">4</span>线程池中总线程数目<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>队列中等待执行的任务数目<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>已执行完别的任务数目<span class="token operator">:</span> <span class="token number">0</span>
开始执行task<span class="token operator">:</span><span class="token number">1</span>
线程池中核心线程数目<span class="token operator">:</span> <span class="token number">4</span>线程池中总线程数目<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>队列中等待执行的任务数目<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>已执行完别的任务数目<span class="token operator">:</span> <span class="token number">0</span>
开始执行task<span class="token operator">:</span><span class="token number">2</span>
开始执行task<span class="token operator">:</span><span class="token number">3</span>
线程池中核心线程数目<span class="token operator">:</span> <span class="token number">4</span>线程池中总线程数目<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>队列中等待执行的任务数目<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>已执行完别的任务数目<span class="token operator">:</span> <span class="token number">0</span>
线程池中核心线程数目<span class="token operator">:</span> <span class="token number">4</span>线程池中总线程数目<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>队列中等待执行的任务数目<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>已执行完别的任务数目<span class="token operator">:</span> <span class="token number">0</span>
线程池中核心线程数目<span class="token operator">:</span> <span class="token number">4</span>线程池中总线程数目<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>队列中等待执行的任务数目<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>已执行完别的任务数目<span class="token operator">:</span> <span class="token number">0</span>
线程池中核心线程数目<span class="token operator">:</span> <span class="token number">4</span>线程池中总线程数目<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>队列中等待执行的任务数目<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>已执行完别的任务数目<span class="token operator">:</span> <span class="token number">0</span>
线程池中核心线程数目<span class="token operator">:</span> <span class="token number">4</span>线程池中总线程数目<span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>队列中等待执行的任务数目<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>已执行完别的任务数目<span class="token operator">:</span> <span class="token number">0</span>
线程池中核心线程数目<span class="token operator">:</span> <span class="token number">4</span>线程池中总线程数目<span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>队列中等待执行的任务数目<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>已执行完别的任务数目<span class="token operator">:</span> <span class="token number">0</span>
开始执行task<span class="token operator">:</span><span class="token number">8</span>
开始执行task<span class="token operator">:</span><span class="token number">9</span>
<span class="token class-name">Exception</span> in thread <span class="token string">&quot;main&quot;</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span>RejectedExecutionException</span><span class="token operator">:</span> <span class="token class-name">Task</span> <span class="token class-name"><span class="token namespace">javase<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>threadpool<span class="token punctuation">.</span></span>TestExecuteTask</span>$<span class="token class-name">MyTask</span><span class="token annotation punctuation">@12a3a380</span> rejected from <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span>ThreadPoolExecutor</span><span class="token annotation punctuation">@29453f44</span><span class="token punctuation">[</span><span class="token class-name">Running</span><span class="token punctuation">,</span> pool size <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> active threads <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> queued tasks <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> completed tasks <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">]</span>
	at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span>ThreadPoolExecutor</span>$<span class="token class-name">AbortPolicy</span><span class="token punctuation">.</span><span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">2063</span><span class="token punctuation">)</span>
	at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span>ThreadPoolExecutor</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">830</span><span class="token punctuation">)</span>
	at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span>ThreadPoolExecutor</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1379</span><span class="token punctuation">)</span>
	at <span class="token class-name"><span class="token namespace">javase<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>threadpool<span class="token punctuation">.</span></span>TestExecuteTask</span><span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">TestExecuteTask</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">)</span>
task <span class="token number">1</span>执行完毕
task <span class="token number">0</span>执行完毕
task <span class="token number">3</span>执行完毕
task <span class="token number">2</span>执行完毕
开始执行task<span class="token operator">:</span><span class="token number">5</span>
开始执行task<span class="token operator">:</span><span class="token number">6</span>
task <span class="token number">8</span>执行完毕
task <span class="token number">9</span>执行完毕
开始执行task<span class="token operator">:</span><span class="token number">7</span>
开始执行task<span class="token operator">:</span><span class="token number">4</span>
task <span class="token number">5</span>执行完毕
task <span class="token number">6</span>执行完毕
task <span class="token number">7</span>执行完毕
task <span class="token number">4</span>执行完毕
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>注意: 这里抛异常之后由于没有catch住, 所以后面的十个任务直接不会放入线程池执行了. 就算这里抛出了异常, 但是由于注释了关闭线程池的方法, 所以线程池把前面加入的10个任务执行完成后还是不会关闭. 而是等待新的任务.</p> <p>总结流程如下图.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220603144757771.png" alt="image-20220603144757771"></p> <h6 id="_3-addworker源码分析"><a href="#_3-addworker源码分析" class="header-anchor">#</a> (3)addWorker源码分析</h6> <p>addWorker 方法的主要工作是在线程池中<strong>创建一个新的线程并执行</strong>. 在 execute 方法中很多地方都调用了 <strong>addWorker</strong> 方法. boolean addWorker(Runnable firstTask, boolean core) 方法的第一的参数可以用于<strong>直接传入任务实例</strong>, 第二个参数用于<strong>标识将要创建的工作线程是否核心线程</strong>. core 参数为 true 表示在新增线程时会判断当前活动线程数是否少于 corePoolSize, false 表示新增线程前需要判断当前活动线程数是否少于 maximumPoolSize.</p> <p>方法源码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 添加工作线程, 如果返回false说明没有新创建工作线程, 如果返回true说明创建和启动工作线程成功</span>
<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    retry<span class="token operator">:</span>  
    <span class="token comment">// 注意这是一个死循环 - 最外层循环</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这个是十分复杂的条件, 这里先拆分多个与(&amp;&amp;)条件: </span>
        <span class="token comment">// 1. 线程池状态至少为SHUTDOWN状态, 也就是rs &gt;= SHUTDOWN(0)</span>
        <span class="token comment">// 2. 线程池状态至少为STOP状态, 也就是rs &gt;= STOP(1), 或者传入的任务实例firstTask不为null, 或者任务队列为空</span>
        <span class="token comment">// 其实这个判断的边界是线程池状态为shutdown状态下, 不会再接受新的任务, 在此前提下如果状态已经到了STOP, 或者传入任务不为空, 或者任务队列为空(已经没有积压任务)都不需要添加新的线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token constant">SHUTDOWN</span><span class="token punctuation">)</span>
            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span>
                <span class="token operator">||</span> firstTask <span class="token operator">!=</span> <span class="token keyword">null</span>
                <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token comment">// 注意这也是一个死循环:二层循环</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 这里每一轮循环都会重新获取工作线程数wc</span>
            <span class="token comment">// 1. 如果传入的core为true, 表示将要创建核心线程, 通过wc和corePoolSize判断, 如果wc &gt;= corePoolSize, 则返回false表示创建核心线程失败</span>
            <span class="token comment">// 1. 如果传入的core为false, 表示将要创非建核心线程, 通过wc和maximumPoolSize判断, 如果wc &gt;= maximumPoolSize, 则返回false表示创建非核心线程失败</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
                <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token constant">COUNT_MASK</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token comment">// 成功通过CAS更新工作线程数wc, 则break到最外层的循环</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span> retry<span class="token punctuation">;</span>
            <span class="token comment">// 走到这里说明了通过CAS更新工作线程数wc失败, 这个时候需要重新判断线程池的状态是否由RUNNING已经变为SHUTDOWN</span>
            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Re-read ctl</span>
            <span class="token comment">// 如果线程池状态已经由RUNNING已经变为SHUTDOWN, 则重新跳出到外层循环继续执行</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token constant">SHUTDOWN</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>
            <span class="token comment">// 如果线程池状态依然是RUNNING, CAS更新工作线程数wc失败说明有可能是并发更新导致的失败, 则在内层循环重试即可 </span>
            <span class="token comment">// else CAS failed due to workerCount change; retry inner loop </span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 标记工作线程是否启动成功</span>
    <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 标记工作线程是否创建成功</span>
    <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token class-name">Worker</span> w <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 传入任务实例firstTask创建Worker实例, Worker构造里面会通过线程工厂创建新的Thread对象, 所以下面可以直接操作Thread t = w.thread</span>
        <span class="token comment">// 这一步Worker实例已经创建, 但是没有加入工作线程集合或者启动它持有的线程Thread实例</span>
        w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">Thread</span> t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 这里需要全局加锁, 因为会改变一些指标值和非线程安全的集合</span>
            <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
            mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// Recheck while holding lock.</span>
                <span class="token comment">// Back out on ThreadFactory failure or if</span>
                <span class="token comment">// shut down before lock acquired.</span>
                <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 这里主要在加锁的前提下判断ThreadFactory创建的线程是否存活或者判断获取锁成功之后线程池状态是否已经更变为SHUTDOWN</span>
                <span class="token comment">// 1. 如果线程池状态依然为RUNNING, 则只需要判断线程实例是否存活, 需要添加到工作线程集合和启动新的Worker</span>
                <span class="token comment">// 2. 如果线程池状态小于STOP, 也就是RUNNING或者SHUTDOWN状态下, 同时传入的任务实例firstTask为null, 则需要添加到工作线程集合和启动新的Worker</span>
                <span class="token comment">// 对于2, 换言之, 如果线程池处于SHUTDOWN状态下, 同时传入的任务实例firstTask不为null, 则不会添加到工作线程集合和启动新的Worker</span>
                <span class="token comment">// 这一步其实有可能创建了新的Worker实例但是并不启动(临时对象, 没有任何强引用), 这种Worker有可能成功下一轮GC被收集的垃圾对象</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">||</span>
                    <span class="token punctuation">(</span><span class="token function">runStateLessThan</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// precheck that t is startable</span>
                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 把创建的工作线程实例添加到工作线程集合</span>
                    workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 尝试更新历史峰值工作线程数, 也就是线程池峰值容量</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;</span> largestPoolSize<span class="token punctuation">)</span>
                        largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>
                    <span class="token comment">// 这里更新工作线程是否启动成功标识为true, 后面才会调用Thread#start()方法启动真实的线程实例</span>
                    workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                <span class="token comment">// 解锁</span>
                mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 如果成功添加工作线程, 则调用Worker内部的线程实例t的Thread#start()方法启动真实的线程实例</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 标记线程启动成功</span>
                workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 线程启动失败, 需要从工作线程集合移除对应的Worker</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>
            <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 添加Worker失败</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 从工作线程集合移除之</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            workers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// wc数量减1    </span>
        <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 基于状态判断尝试终结线程池</span>
        <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br></div></div><p>上面的分析逻辑中需要注意一点, Worker 实例创建的同时, 在其构造函数中会通过 <strong>ThreadFactory</strong> 创建一个 Java 线程 <strong>Thread 实例</strong>, 后面会<strong>加锁</strong>后二次检查是否需要把 Worker 实例添加到工作线程集合 workers 中和是否需要启动 Worker 中持有的 Thread 实例, 只有启动了 Thread 实例, <strong>Worker 才真正开始运作</strong>, 否则只是一个无用的临时对象. Worker 本身也实现了 Runnable 接口, 它可以看成是一个 Runnable 的适配器.</p> <p><strong>线程池中的每一个线程被封装成一个 Worker 对象, ThreadPool 维护的其实就是一组 Worker 对象. ​</strong></p> <p>Worker 源码如下.</p> <p>一个 Worker 对应一个线程, 使用 <strong>thread</strong> 属性记录工作线程(一定会有), 使用 <strong>firstTask</strong> 记录执行的第一个任务. thread 是在调用构造方法时通过 ThreadFactory 来创建的线程, 是用来<strong>处理任务的线程</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>
    <span class="token comment">/**
     * This class will never be serialized, but we provide a
     * serialVersionUID to suppress a javac warning.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">6138294804551838833L</span><span class="token punctuation">;</span>

    <span class="token comment">// 保存ThreadFactory创建的线程实例, 如果ThreadFactory创建线程失败则为null</span>
    <span class="token keyword">final</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>
    <span class="token comment">// 保存传入的Runnable任务实例</span>
    <span class="token class-name">Runnable</span> firstTask<span class="token punctuation">;</span>
    <span class="token comment">// 记录每个线程完成的任务总数</span>
    <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>

    <span class="token comment">// 唯一的构造函数, 传入任务实例firstTask, 注意可以为null</span>
    <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 禁止线程中断, 直到runWorker()方法执行</span>
        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// inhibit interrupts until runWorker</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>
        <span class="token comment">// 通过ThreadFactory创建线程实例, 注意一下Worker实例自身作为Runnable用于创建新的线程实例</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 委托到外部的runWorker()方法, 注意runWorker()方法是线程池的方法, 而不是Worker的方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Lock methods</span>
    <span class="token comment">//</span>
    <span class="token comment">// The value 0 represents the unlocked state.</span>
    <span class="token comment">// The value 1 represents the locked state.</span>
    <span class="token comment">//  是否持有独占锁, state值为1的时候表示持有锁, state值为0的时候表示已经释放锁</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 独占模式下尝试获取资源, 这里没有判断传入的变量, 直接CAS判断0更新为1是否成功, 成功则设置独占线程为当前线程</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 独占模式下尝试是否资源, 这里没有判断传入的变量, 直接把state设置为0</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 加锁</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token comment">// 尝试加锁</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token comment">// 解锁</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token comment">// 是否锁定</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token comment">// 启动后进行线程中断, 注意这里会判断线程实例的中断标志位是否为false, 只有中断标志位为false才会中断</span>
    <span class="token keyword">void</span> <span class="token function">interruptIfStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> thread<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br></div></div><p>线程池中的每一个具体的<strong>工作线程</strong>被包装为<strong>内部类 Worker 实例</strong>, Worker 继承于 <strong>AQS</strong> , 并实现了 Runnable 接口.</p> <p>Worker 的构造函数里面的逻辑十分重要, <strong>通过 ThreadFactory 创建的 Thread 实例同时传入 Worker 实例</strong>, 因为 Worker 本身实现了 Runnable, 所以可以作为<strong>任务</strong>提交到线程中执行. 只要 <strong>Worker 持有的线程实例 w</strong> 调用 Thread#start() 方法就能在合适时机执行 Workerrun(). 简化一下逻辑如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// addWorker()方法中构造</span>
<span class="token class-name">Worker</span> worker <span class="token operator">=</span> <span class="token function">createWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 通过线程池构造时候传入</span>
<span class="token class-name">ThreadFactory</span> threadFactory <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Worker构造函数中</span>
<span class="token class-name">Thread</span> thread <span class="token operator">=</span> threadFactory<span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span>worker<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// addWorker()方法中启动</span>
thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Worker 继承自 AQS, 这里使用了 <strong>AQS 的独占模式</strong>, 有个技巧是构造 Worker 的时候, 把 AQS 的资源(状态)通过 <strong>setState(-1)</strong> 设置为 <strong>-1</strong>, 这是因为 Worker 实例刚创建时 AQS 中 <strong>state 的默认值为 0</strong>, 此时线程尚未启动, 不能在这个时候进行线程中断, 见 Worker#interruptIfStarted() 方法. Worker 中两个覆盖 AQS 的方法 <strong>tryAcquire</strong>() 和 <strong>tryRelease</strong>() 都没有判断外部传入的变量, 前者直接 CAS(0, 1), 后者直接 <strong>setState</strong>(0).</p> <p>为什么不使用 ReentrantLock 来实现呢? 可以看到 tryAcquire 方法, 它是不允许重入的, 而 ReentrantLock 是允许重入的:</p> <ul><li>lock 方法一旦获取了独占锁, 表示当前线程正在执行任务中;</li> <li>如果正在执行任务, 则不应该中断线程;</li> <li>如果该线程现在不是独占锁的状态, 也就是空闲的状态, 说明它没有在处理任务, 这时可以对该线程进行中断;</li> <li>线程池在执行 shutdown 方法或 tryTerminate 方法时会调用 interruptIdleWorkers 方法来中断空闲的线程, interruptIdleWorkers 方法会使用 tryLock 方法来判断线程池中的线程是否是空闲状态;</li> <li>之所以设置为<strong>不可重入</strong>, 是因为我们不希望任务在调用像 setCorePoolSize 这样的线程池控制方法时重新获取锁. 如果使用 ReentrantLock, 它是可重入的, 这样如果在任务中调用了如 setCorePoolSize 这类线程池控制的方法, 会中断正在运行的线程.</li></ul> <p>所以 Worker 继承自 AQS, 用于<strong>判断线程是否空闲以及是否可以被中断</strong>.</p> <p>tryAcquire 方法是根据 state 是否是 0 来判断的, 所以 setState(-1); 将 state <strong>设置为 -1 是为了禁止</strong>在执行任务前对线程进行中断. 正因为如此, 在 runWorker 方法中会先调用 Worker 对象的 unlock 方法将 state 设置为 0.</p> <p>接着看核心方法 ThreadPoolExecutor#<strong>runWorker</strong>():</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取当前线程, 实际上和Worker持有的线程实例是相同的</span>
    <span class="token class-name">Thread</span> wt <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取Worker中持有的初始化时传入的任务对象, 这里注意存放在临时变量task中</span>
    <span class="token class-name">Runnable</span> task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>
    <span class="token comment">// 设置Worker中持有的初始化时传入的任务对象为null</span>
    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 由于Worker初始化时AQS中state设置为-1, 这里要先做一次解锁把state更新为0, 允许线程中断</span>
    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// allow interrupts</span>
    <span class="token comment">// 记录线程是否因为用户异常终结, 默认是true</span>
    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 初始化任务对象不为null, 或者从任务队列获取任务不为空(从任务队列获取到的任务会更新到临时变量task中)</span>
        <span class="token comment">// getTask()由于使用了阻塞队列, 这个while循环如果命中后半段会处于阻塞或者超时阻塞状态, getTask()返回为null会导致线程跳出死循环使线程终结</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// Worker加锁, 本质是AQS获取资源并且尝试CAS更新state由0更变为1</span>
            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// If pool is stopping, ensure thread is interrupted;</span>
            <span class="token comment">// if not, ensure thread is not interrupted.  This</span>
            <span class="token comment">// requires a recheck in second case to deal with</span>
            <span class="token comment">// shutdownNow race while clearing interrupt</span>
            <span class="token comment">// 如果线程池正在停止(也就是由RUNNING或者SHUTDOWN状态向STOP状态变更), 那么要确保当前工作线程是中断状态</span>
            <span class="token comment">// 否则, 要保证当前线程不是中断状态</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span> <span class="token operator">||</span>
                 <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                  <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 钩子方法, 任务执行前</span>
                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 钩子方法, 任务执行后 - 正常情况</span>
                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 钩子方法, 任务执行后 - 异常情况</span>
                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                <span class="token comment">// 清空task临时变量, 这个很重要, 否则while会死循环执行同一个task</span>
                task <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token comment">// 累加Worker完成的任务数</span>
                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token comment">// Worker解锁, 本质是AQS释放资源, 设置state为0</span>
                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 走到这里说明某一次getTask()返回为null, 线程正常退出</span>
        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 处理线程退出, completedAbruptly为true说明由于用户异常导致线程非正常退出</span>
        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br></div></div><p>这里重点拆解分析一下判断当前工作线程中断状态的代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
      <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
    wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 先简化一下判断逻辑, 如下</span>
<span class="token comment">// 判断线程池状态是否至少为STOP, rs &gt;= STOP(1)</span>
<span class="token keyword">boolean</span> atLeastStop <span class="token operator">=</span> <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 判断线程池状态是否至少为STOP, 同时判断当前线程的中断状态并且清空当前线程的中断状态</span>
<span class="token keyword">boolean</span> interruptedAndAtLeastStop <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>atLeastStop <span class="token operator">||</span> interruptedAndAtLeastStop <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Thread.interrupted() 方法获取线程的中断状态同时会清空该中断状态, 这里之所以会调用这个方法是因为在执行上面这个if逻辑同时外部有可能调用 shutdownNow() 方法, shutdownNow() 方法中也存在中断所有 Worker 线程的逻辑, 但是由于 shutdownNow() 方法中会遍历所有 Worker 做线程中断, 有可能无法及时在任务提交到 Worker 执行之前进行中断, 所以这个中断逻辑会在 Worker 内部执行, 就是 if 代码块的逻辑. 这里还要注意的是: STOP 状态下会拒绝所有新提交的任务, 不会再执行任务队列中的任务, 同时会中断所有 Worker 线程. 也就是, 即使任务 Runnable 已经 runWorker() 中前半段逻辑取出, 只要还没走到调用其 Runnable#run(), 都有可能被<strong>中断</strong>. 假设刚好发生了进入 if 代码块的逻辑同时外部调用了 shutdownNow() 方法, 那么 if 逻辑内会判断线程中断状态并且重置, 那么 shutdownNow() 方法中调用的 interruptWorkers() 就不会因为中断状态判断出现问题导致二次中断线程(会导致异常).</p> <p><strong>小结一下上面 runWorker() 方法的核心流程: ​</strong></p> <ul><li>Worker 先执行一次解锁操作, 用于<strong>解除不可中断</strong>状态.</li> <li>通过 while 循环调用 <strong>getTask</strong>() 方法从<strong>任务队列中获取任务</strong>(当然, 首轮循环也有可能是外部传入的 <strong>firstTask</strong> 任务实例).</li> <li>如果线程池更变为 STOP 状态, 则需要确保工作线程是中断状态并且进行中断处理, 否则要保证工作线程必须不是中断状态.</li> <li>执行任务实例 Runnale#run() 方法, 任务实例执行之前和之后(包括正常执行完毕和异常执行情况)分别会调用<strong>钩子方法</strong> beforeExecute() 和 afterExecute().</li> <li>while 循环跳出意味着 runWorker() <strong>方法结束和工作线程生命周期结束</strong>(Worker#run()生命周期完结), 会调用 processWorkerExit() 处理工作线程退出的后续工作.</li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220603144849860.png" alt=""></p> <p>接下来分析一下从<strong>阻塞任务队列中获取任务的 getTask() 方法</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Runnable</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 记录上一次从队列中拉取的时候是否超时</span>
    <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// Did the last poll() time out?</span>
    <span class="token comment">// 注意这是死循环</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Check if queue empty only if necessary.</span>
        <span class="token comment">// 第一个if: 如果线程池状态至少为SHUTDOWN, 也就是rs &gt;= SHUTDOWN(0), 则需要判断两种情况(或逻辑): </span>
        <span class="token comment">// 1. 线程池状态至少为STOP(1), 也就是线程池正在停止, 一般是调用了shutdownNow()方法</span>
        <span class="token comment">// 2. 任务队列为空</span>
        <span class="token comment">// 如果在线程池至少为SHUTDOWN状态并且满足上面两个条件之一, 则工作线程数wc减去1, 然后直接返回null</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token constant">SHUTDOWN</span><span class="token punctuation">)</span>
            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 跑到这里说明线程池还处于RUNNING状态, 重新获取一次工作线程数</span>
        <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Are workers subject to culling?</span>
        <span class="token comment">// timed临时变量勇于线程超时控制, 决定是否需要通过poll()此带超时的非阻塞方法进行任务队列的任务拉取</span>
        <span class="token comment">// 1.allowCoreThreadTimeOut默认值为false, 如果设置为true, 则允许核心线程也能通过poll()方法从任务队列中拉取任务</span>
        <span class="token comment">// 2.工作线程数大于核心线程数的时候, 说明线程池中创建了额外的非核心线程, 这些非核心线程一定是通过poll()方法从任务队列中拉取任务</span>
        <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">&gt;</span> corePoolSize<span class="token punctuation">;</span>
        <span class="token comment">// 第二个if: </span>
        <span class="token comment">// 1.wc &gt; maximumPoolSize说明当前的工作线程总数大于maximumPoolSize, 说明了通过setMaximumPoolSize()方法减少了线程池容量</span>
        <span class="token comment">// 或者 2.timed &amp;&amp; timedOut说明了线程命中了超时控制并且上一轮循环通过poll()方法从任务队列中拉取任务为null</span>
        <span class="token comment">// 并且 3. 工作线程总数大于1或者任务队列为空, 则通过CAS把线程数减去1, 同时返回null, </span>
        <span class="token comment">// CAS把线程数减去1失败会进入下一轮循环做重试</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">&gt;</span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果timed为true, 通过poll()方法做超时拉取, keepAliveTime时间内没有等待到有效的任务, 则返回null</span>
            <span class="token comment">// 如果timed为false, 通过take()做阻塞拉取, 会阻塞到有下一个有效的任务时候再返回(一般不会是null)</span>
            <span class="token class-name">Runnable</span> r <span class="token operator">=</span> timed <span class="token operator">?</span>
                workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">NANOSECONDS</span><span class="token punctuation">)</span> <span class="token operator">:</span>
            workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 这里很重要, 只有非null时候才返回, null的情况下会进入下一轮循环</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> r<span class="token punctuation">;</span>
            <span class="token comment">// 跑到这里说明上一次从任务队列中获取到的任务为null, 一般是workQueue.poll()方法超时返回null</span>
            timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br></div></div><p>在 execute() 方法中, 当线程池总数已经超过了 corePoolSize 并且还小于 maximumPoolSize 时, 当任务队列已经满了的时候, 会通过 addWorker(task,false) 添加<strong>非核心线程</strong>. 而这里的逻辑恰好类似于 addWorker(task,false) 的反向操作, 用于<strong>减少非核心线程</strong>, 使得工作线程总数趋向于 corePoolSize. 如果对于非核心线程, 上一轮循环获取任务对象为null, 这一轮循环很容易满足 timed &amp;&amp; timedOut 为 true, 这个时候 getTask() <strong>返回 null</strong> 会导致 Worker#runWorker() 方法<strong>跳出死循环</strong>, 之后执行 <strong>processWorkerExit</strong>() 方法处理后续工作, 而该非核心线程对应的 Worker 则变成“游离对象”, 等待被 JVM 回收. 当 allowCoreThreadTimeOut 设置为 true 的时候, 这里分析的非核心线程的生命周期终结逻辑同时会<strong>适用于核心线程</strong>.</p> <p>那么可以总结出 keepAliveTime 的意义:</p> <ul><li>当允许核心线程超时, 也就是 allowCoreThreadTimeOut 设置为 true 的时候, 此时 keepAliveTime 表示空闲的工作线程的存活周期.</li> <li>默认情况下<strong>不允许核心线程超时</strong>, 此时 keepAliveTime 表示空闲的<strong>非核心线程的存活周期</strong>.</li></ul> <p>在一些特定的场景下, 配置合理的 keepAliveTime 能够更好地利用线程池的工作线程资源.</p> <p>processWorkerExit 执行完之后, 工作线程被销毁, 以上就是整个工作线程的生命周期, 从 execute 方法开始, Worker 使用 ThreadFactory 创建新的工作线程, runWorker 通过 getTask 获取任务, 然后执行任务, 如果 getTask 返回 null, 进入 processWorkerExit 方法, 整个线程结束. 如下图所示.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220603144922315.png" alt=""></p> <h5 id="_7-线程池补充"><a href="#_7-线程池补充" class="header-anchor">#</a> 7.线程池补充</h5> <h6 id="_1-线程池关闭"><a href="#_1-线程池关闭" class="header-anchor">#</a> (1)线程池关闭</h6> <p>ExecutorService 接口提供了两个关闭线程池的方法, ThreadPoolExecutor 实现了<strong>两个方法</strong>, 用于线程池的关闭, 分别是 <strong>shutdown</strong>() 和 <strong>shutdownNow</strong>(), 其中:</p> <ul><li><strong>shutdown</strong>(): 不会立即终止线程池, 而是要<strong>等所有任务缓存队列中的任务都执行完</strong>后才终止, 但再也不会接受新的任务.</li> <li><strong>shutdownNow</strong>(): <strong>立即终止线程池</strong>, 并尝试打断正在执行的任务, 并且清空任务缓存队列, 返回尚未执行的任务.</li></ul> <h6 id="_2-线程池死锁"><a href="#_2-线程池死锁" class="header-anchor">#</a> (2)线程池死锁</h6> <p>任务之间有<strong>依赖</strong>可能造成线程池死锁. 可以使用 <strong>newCachedThreadPool</strong> 创建线程池, 让线程数<strong>不受限制</strong>. 也可以使用 <strong>SynchronousQueue</strong> 来避免线程池死锁, 因为可以立马创建线程.</p> <h6 id="_3-如何合理设置线程池的大小"><a href="#_3-如何合理设置线程池的大小" class="header-anchor">#</a> (3)如何合理设置线程池的大小</h6> <p>一般需要根据任务的类型来配置线程池大小:</p> <ul><li>如果是 <strong>CPU 密集型</strong>任务, 就需要尽量压榨 CPU, 参考值可以设为 NCPU + 1.</li> <li>如果是 <strong>IO 密集型</strong>任务, 参考值可以设置为 2 * NCPU.</li></ul> <h6 id="_4-线程池钩子方法"><a href="#_4-线程池钩子方法" class="header-anchor">#</a> (4)线程池钩子方法</h6> <p>到 JDK11 为止, ThreadPoolExecutor 提供的钩子方法没有增加, 有以下几个:</p> <ul><li>beforeExecute(Thread t, Runnable r): 任务对象 Runnable#run() 执行之前触发回调.</li> <li>afterExecute(Runnable r, Throwable t): 任务对象 Runnable#run() 执行之后(包括异常完成情况和正常完成情况)触发回调.</li> <li>terminated(): 线程池关闭的时候, 状态更变为 TIDYING 成功之后会回调此方法, 执行此方法完毕后, 线程池状态会更新为 TERMINATED.</li> <li>onShutdown(): shutdown() 方法执行时候会回调此方法, API 注释中提到此方法主要提供给<strong>ScheduledThreadPoolExecutor</strong> 使用.</li></ul> <p>其中 onShutdown() 的方法修饰符为 default, 其他三个方法的修饰符为 protected, 必要时候可以自行扩展这些方法, 可以实现<strong>监控</strong>, 基于特定时机触发具体操作等等.</p> <h6 id="_5-线程池其他方法"><a href="#_5-线程池其他方法" class="header-anchor">#</a> (5)线程池其他方法</h6> <p>核心线程相关:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">getCorePoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取核心线程数. </span>
<span class="token function">setCorePoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重新设置线程池的核心线程数. </span>
<span class="token function">prestartCoreThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 预启动一个核心线程, 当且仅当工作线程数量小于核心线程数量. </span>
<span class="token function">prestartAllCoreThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// 预启动所有核心线程. </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>线程池容量相关:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">getMaximumPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 获取线程池容量. </span>
<span class="token function">setMaximumPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 重新设置线程池的最大容量. </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>线程存活周期相关:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">setKeepAliveTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 设置空闲工作线程的存活周期. </span>
<span class="token function">getKeepAliveTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 获取空闲工作线程的存活周期. </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>其他监控统计相关方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">getTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 获取所有已经被执行的任务总数的近似值. </span>
<span class="token function">getCompletedTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 获取所有已经执行完成的任务总数的近似值. </span>
<span class="token function">getLargestPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 获取线程池的峰值线程数(最大池容量). </span>
<span class="token function">getActiveCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 获取所有活跃线程总数(正在执行任务的工作线程)的近似值. </span>
<span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 获取工作线程集合的容量(当前线程池中的总工作线程数). </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>任务队列操作相关方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">purge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 移除任务队列中所有是Future类型并且已经处于Cancelled状态的任务. </span>
<span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 从任务队列中移除指定的任务. </span>
<span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> <span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 获取任务队列的引用. </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="定时任务调度"><a href="#定时任务调度" class="header-anchor">#</a> 定时任务调度</h4> <p>任务调度是指基于 <strong>给定时间点</strong>, <strong>给定时间间隔</strong> 或者 <strong>给定执行次数</strong> 自动执行任务.</p> <h5 id="_1-thread实现"><a href="#_1-thread实现" class="header-anchor">#</a> 1.Thread实现</h5> <p>自己用线程实现, 例如如下的代码, 可以每隔 1000 毫秒做一次打印操作.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Job_Schedule_Test1</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">JobThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">JobThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Test: &quot;</span> <span class="token operator">+</span> <span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h5 id="_2-timer实现"><a href="#_2-timer实现" class="header-anchor">#</a> 2.Timer实现</h5> <p>自定义一个任务, 继承于 <strong>TimerTask</strong>, 重写 run 方法. 利用 java.util.Timer 实现任务调度.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Job_Schedule_Test2</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 只定义了一个Timer对象</span>
        <span class="token class-name">Timer</span> timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> delay <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> interval <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>

        <span class="token comment">// 从现在开始 2 秒钟之后启动, 每隔 1 秒钟执行一次</span>
        timer<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JobTask1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> delay<span class="token punctuation">,</span> interval<span class="token punctuation">)</span><span class="token punctuation">;</span>
        timer<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JobTask2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> delay<span class="token punctuation">,</span> interval<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 任务1</span>
<span class="token keyword">class</span> <span class="token class-name">JobTask1</span> <span class="token keyword">extends</span> <span class="token class-name">TimerTask</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Test: &quot;</span> <span class="token operator">+</span> <span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 任务2</span>
<span class="token keyword">class</span> <span class="token class-name">JobTask2</span> <span class="token keyword">extends</span> <span class="token class-name">TimerTask</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span><span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>Timer 的<strong>设计核心</strong>是一个 <strong>TaskList</strong> 和一个 <strong>TaskThread</strong>.</p> <p>Timer 将接收到的任务丢到自己的 <strong>TaskList</strong> 中, TaskList 按照 Task 的<strong>最初执行时间进行排序</strong>. TimerThread 在创建 Timer 时会启动成为一个<strong>守护线程</strong>. 这个线程会轮询所有任务, 找到一个最近要执行的任务, 然后休眠, 当到达最近要执行任务的开始时间点, TimerThread 被唤醒并执行该任务. 之后 TimerThread 更新最近一个要执行的任务, 继续休眠.</p> <p>Timer 的优点在于简单易用, 但由于所有任务都是由<strong>同一个线程</strong>来调度, <strong>因此所有任务都是串行执行的</strong>, <strong>同一时间只能有一个任务</strong>在执行, 前一个任务的延迟, 阻塞或异常都将会影响到之后的任务.</p> <p>例如我们指定每隔 1000 毫秒执行一次任务, 但是可能某个任务执行花了 5000 毫秒, 因此导致后续的任务并不能按时启动执行.</p> <p>Timer 内部主要由<strong>任务队列</strong>和 <strong>Timer 线程</strong>两部分组成. 任务队列是一个基于<strong>堆实现的优先级队列</strong>, 按照下次执行的时间排优先级. Timer 线程则负责执行<strong>所有的定时任务</strong>, 需要强调的是, 一个 <strong>Timer 对象只有一个 Timer 线程</strong>, 所以如果一个任务是<strong>无限循环</strong>的话其他任务可能就执行不了. 同时, 一个任务<strong>内部抛出异常</strong>将导致 Timer 线程退出, <strong>导致所有的定时任务都被取消</strong>. 如果希望各个定时任务不互相干扰, 一定要注意在任务<strong>内部捕获异常</strong>.</p> <h5 id="_3-scheduledexecutorservice实现"><a href="#_3-scheduledexecutorservice实现" class="header-anchor">#</a> 3.ScheduledExecutorService实现</h5> <p>鉴于 Timer 的上述缺陷, Java5 推出了基于线程池设计的 <strong>ScheduledExecutorService</strong>. 其设计思想是, 每一个被调度的任务都会 <strong>由线程池中一个线程去执行, 因此任务是并发执行的, 相互之间不会受到干扰</strong>. 需要注意的是, 只有当任务的执行时间到来时, ScheduledExecutorService 才会真正启动一个线程, 其余时间 ScheduledExecutorService 都是在轮询任务的状态.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span>ScheduleExecutorService</span> <span class="token keyword">extends</span> <span class="token class-name">ExecutorService</span> <span class="token keyword">extends</span> <span class="token class-name">Executor</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其中 scheduleAtFixedRate 和 scheduleWithFixedDelay 在实现<strong>定时</strong>程序时比较方便.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// command: 执行线程</span>
<span class="token comment">// initialDelay: 初始化延时</span>
<span class="token comment">// period: 两次开始执行最小间隔时间</span>
<span class="token comment">// unit: 计时单位</span>
<span class="token keyword">public</span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">,</span> 
                                              <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span> 
                                              <span class="token keyword">long</span> period<span class="token punctuation">,</span> 
                                              <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// command: 执行线程</span>
<span class="token comment">// initialDelay: 初始化延时</span>
<span class="token comment">// period: 前一次执行结束到下一次执行开始的间隔时间(间隔执行延迟时间)</span>
<span class="token comment">// unit: 计时单位</span>
<span class="token keyword">public</span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">,</span> 
                                                 <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span> 
                                                 <span class="token keyword">long</span> delay<span class="token punctuation">,</span> 
                                                 <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>返回类型都是 <strong>ScheduledFuture</strong>, 是一个接口, 扩展了 Future 和 Delayed, 没有定义额外的方法.</p> <p>ScheduledExecutorService 的主要实现类是 <strong>ScheduledThreadPoolExecutor</strong>, 它是线程池 <strong>ThreadPoolExecutor</strong> 的子类, 是<strong>基于线程池</strong>实现的.</p> <p>它的任务队列是一个<strong>无界</strong>的<strong>优先级队列</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JobScheduleTest3</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 定时任务的线程池</span>
        <span class="token class-name">ScheduledExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> delay <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> interval <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token comment">// 从现在开始 2 秒钟之后启动, 每隔 1 秒钟执行一次</span>
        service<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JobTask1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> delay<span class="token punctuation">,</span> interval<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        service<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JobTask2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> delay<span class="token punctuation">,</span> interval<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">JobTask1</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Test: &quot;</span> <span class="token operator">+</span> <span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">JobTask2</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 无限循环</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>有<strong>多个线程执行任务</strong>, 所以一个任务内的<strong>无限循环不会</strong>影响其他的任务, 多个任务可以同时执行.</p> <p>一个<strong>任务抛出异常也不会影响</strong>其他任务, 但是应该尽量把异常捕获.</p> <p>用 <strong>ScheduledThreadPoolExecutor</strong> 和 Calendar 可以实现复杂任务调度.</p> <h5 id="_4-quartz实现"><a href="#_4-quartz实现" class="header-anchor">#</a> 4.Quartz实现</h5> <p>Quartz 是一个完全由 Java 编写的开源<strong>作业调度框架</strong>, 为在 Java 应用程序中进行作业调度提供了简单却强大的机制. Quartz 允许开发人员根据时间间隔来调度作业. 它实现了<strong>作业和触发器的多对多</strong>的关系, 还能把多个作业与不同的触发器关联. 简单地创建一个 org.quarz.<strong>Job</strong> 接口的 Java 类, Job 接口包含唯一的方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">JobExecutionContext</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">JobExecutionException</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>Job</strong>: 具体需要处理的<strong>业务逻辑</strong>.</p> <p><strong>JobDetail</strong>: 详细的任务描述, 包括名称, 关联的 Job, Job 运行时所需要的参数等.</p> <p><strong>Trigger</strong>: <strong>任务调度器</strong>, 描述什么时候执行 Job, 多久执行一次.</p> <ul><li>SimpleTrigger 设置重复次数, 重复执行间隔时长.</li> <li>CronTrigger 设置 Cron 表达式.</li></ul> <p><strong>Scheduler</strong>: 调度容器, Job 与 Trigger 都需要在容器中<strong>注册</strong>, 被容器统一管理.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuartzJob</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>quartz<span class="token punctuation">.</span></span>Job</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">QuartzJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">JobExecutionContext</span> arg0<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">JobExecutionException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Test: &quot;</span> <span class="token operator">+</span> <span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>quartz<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Job_Schedule_Test4</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SchedulerException</span> <span class="token punctuation">{</span>
        <span class="token comment">// Grab the Scheduler instance from the Factory</span>
        <span class="token class-name">Scheduler</span> scheduler <span class="token operator">=</span> <span class="token class-name">StdSchedulerFactory</span><span class="token punctuation">.</span><span class="token function">getDefaultScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// define the job and tie it to our MyJob class</span>
        <span class="token class-name">JobDetail</span> job <span class="token operator">=</span> <span class="token function">newJob</span><span class="token punctuation">(</span><span class="token class-name">QuartzJob</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">withIdentity</span><span class="token punctuation">(</span><span class="token string">&quot;job1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;group1&quot;</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Trigger the job to run now, and then repeat every 40 seconds</span>
        <span class="token class-name">Trigger</span> trigger <span class="token operator">=</span> <span class="token function">newTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">withIdentity</span><span class="token punctuation">(</span><span class="token string">&quot;trigger1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;group1&quot;</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">startNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">withSchedule</span><span class="token punctuation">(</span><span class="token function">simpleSchedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                        <span class="token punctuation">.</span><span class="token function">withIntervalInSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
                        <span class="token punctuation">.</span><span class="token function">repeatForever</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Tell quartz to schedule the job using our trigger</span>
        scheduler<span class="token punctuation">.</span><span class="token function">scheduleJob</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> trigger<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// and start it off</span>
        scheduler<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h4 id="定时任务工程实践"><a href="#定时任务工程实践" class="header-anchor">#</a> 定时任务工程实践</h4> <p>场景: 修改超时未支付订单的状态.</p> <p>定时任务通常仅适用于轻量级的小型项目, 定时任务的<strong>弊端</strong>:</p> <ul><li>单机通常没问题, 集群下不行, 这样会存在很多定时任务. 解决: 在集群中仅采用一台机器做定时任务, 单独完成所有定时任务.</li> <li>通常存在全表查询, 对数据库压力较大.</li></ul> <p>为解决上述问题, 可以采用<strong>消息队列</strong>.</p> <p>‍</p> <h4 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h4> <ul><li>ThreadPoolExecutor源码分析: <a href="http://www.throwable.club/2019/07/15/java-concurrency-thread-pool-executor/" target="_blank" rel="noopener noreferrer">http://www.throwable.club/2019/07/15/java-concurrency-thread-pool-executor/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/20.开发/2000.Java/300.并发/309.线程池与定时任务.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/103bb5/" class="prev">Atomic原子变量与Unsafe类与CAS</a></span> <span class="next"><a href="/pages/dd3660/">ThreadLocal</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/f90282/"><div>
            基础
            <!----></div></a> <span class="date">06-08</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/0f75ac/"><div>
            搜索二叉树BST
            <!----></div></a> <span class="date">06-08</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/39721f/"><div>
            平衡二叉树AVL
            <!----></div></a> <span class="date">06-08</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2023
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.5bc2c979.js" defer></script><script src="/assets/js/2.eccd4273.js" defer></script><script src="/assets/js/136.5e57454a.js" defer></script>
  </body>
</html>
