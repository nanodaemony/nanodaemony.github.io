<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>深入拆解Tomcat与Jetty(极客时间)🌸 | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/165.65444686.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>分布式系统理论</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/129626/" class="sidebar-link">分布式系统基础</a></li><li><a href="/pages/fb5d35/" class="sidebar-link">分布式共识算法</a></li><li><a href="/pages/12ac37/" class="sidebar-link">分布式系统组件</a></li><li><a href="/pages/d03ebf/" class="sidebar-link">分布式技术原理与算法解析(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>系统接入层</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/f1b6c4/" class="sidebar-link">Nginx基础</a></li><li><a href="/pages/d4123d/" aria-current="page" class="active sidebar-link">深入拆解Tomcat与Jetty(极客时间)🌸</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/baee2f/" class="sidebar-link">Netty</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>服务治理-注册发现与RPC</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/05077d/" class="sidebar-link">基础</a></li><li><a href="/pages/51b6aa/" class="sidebar-link">RPC实战与核心原理(极客时间)🌸</a></li><li><a href="/pages/0966ee/" class="sidebar-link">Zookeeper</a></li><li><a href="/pages/3b7e05/" class="sidebar-link">Nacos</a></li><li><a href="/pages/7f31f8/" class="sidebar-link">Dubbo</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>服务治理-流量控制</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/44bfa8/" class="sidebar-link">负载均衡</a></li><li><a href="/pages/4d5a6c/" class="sidebar-link">限流</a></li><li><a href="/pages/e0c561/" class="sidebar-link">熔断</a></li><li><a href="/pages/12ae40/" class="sidebar-link">网关路由</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>服务治理-系统监控与安全</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/8c9210/" class="sidebar-link">系统安全性</a></li><li><a href="/pages/c9bf40/" class="sidebar-link">系统监控组件</a></li><li><a href="/pages/3f3cf7/" class="sidebar-link">运维监控系统实战(极客时间)🌸</a></li><li><a href="/pages/e20e02/" class="sidebar-link">OAuth2.0实战课(极客时间)🌟</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>中间件-消息队列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/96d94c/" class="sidebar-link">消息队列基础</a></li><li><a href="/pages/abf16c/" class="sidebar-link">RabbitMQ</a></li><li><a href="/pages/4fc3f1/" class="sidebar-link">Kafka</a></li><li><a href="/pages/013cfe/" class="sidebar-link">RocketMQ</a></li><li><a href="/pages/ed8d92/" class="sidebar-link">Disruptor</a></li><li><a href="/pages/249149/" class="sidebar-link">消息队列高手课(极客时间)🌟</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>中间件-缓存</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/946847/" class="sidebar-link">缓存基础</a></li><li><a href="/pages/e46d56/" class="sidebar-link">本地缓存</a></li><li><a href="/pages/0abfb9/" class="sidebar-link">Redis基础</a></li><li><a href="/pages/09236a/" class="sidebar-link">Redis持久化</a></li><li><a href="/pages/867f9b/" class="sidebar-link">Redis主从复制</a></li><li><a href="/pages/50cae1/" class="sidebar-link">Redis哨兵</a></li><li><a href="/pages/43b45c/" class="sidebar-link">Redis集群</a></li><li><a href="/pages/a32379/" class="sidebar-link">Redis内存管理与运维</a></li><li><a href="/pages/386037/" class="sidebar-link">Redis核心技术与实战(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>中间件-其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/23044d/" class="sidebar-link">定时任务-XXLJob</a></li><li><a href="/pages/459117/" class="sidebar-link">ES与检索</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>系统设计与优化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/41a845/" class="sidebar-link">凤凰架构</a></li><li><a href="/pages/68cc0b/" class="sidebar-link">左耳听风(极客时间)🌟</a></li><li><a href="/pages/e3e99c/" class="sidebar-link">从0开始学微服务(极客时间)🌸</a></li><li><a href="/pages/1e5368/" class="sidebar-link">高并发系统设计40问(极客时间)🌸</a></li><li><a href="/pages/33599f/" class="sidebar-link">系统性能调优必知必会(极客时间)🌸</a></li><li><a href="/pages/c83472/" class="sidebar-link">后端技术面试38讲(极客时间)</a></li><li><a href="/pages/4404b6/" class="sidebar-link">架构实战案例解析(极客时间)🌸</a></li><li><a href="/pages/8f1c1d/" class="sidebar-link">如何设计一个秒杀系统(极客时间)</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>容器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>容器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/582acf/" class="sidebar-link">部署Minikube</a></li><li><a href="/pages/98e5e4/" class="sidebar-link">容器实战高手课(极客时间)🌸</a></li><li><a href="/pages/c6a42c/" class="sidebar-link">Kubernetes实战🌸</a></li><li><a href="/pages/f35c72/" class="sidebar-link">深入剖析Kubernetes(极客时间)🌸</a></li><li><a href="/pages/caa314/" class="sidebar-link">Istio</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>自动化运维</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/beb97f/" class="sidebar-link">持续集成(CICD)</a></li><li><a href="/pages/a0df2d/" class="sidebar-link">DevOps</a></li><li><a href="/pages/765815/" class="sidebar-link">SRE实战手册(极客时间)</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/middleware/#系统" data-v-06970110>系统</a></li><li data-v-06970110><a href="/middleware/#系统" data-v-06970110>系统</a></li><li data-v-06970110><a href="/middleware/#系统接入层" data-v-06970110>系统接入层</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">深入拆解Tomcat与Jetty(极客时间)🌸<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_200-深入拆解tomcat与jetty-极客时间-🌸"><a href="#_200-深入拆解tomcat与jetty-极客时间-🌸" class="header-anchor">#</a> 200.深入拆解Tomcat与Jetty(极客时间)🌸</h1> <h3 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h3> <h4 id="_0-为什么学习tomcat"><a href="#_0-为什么学习tomcat" class="header-anchor">#</a> 0.为什么学习Tomcat?</h4> <p>Servlet 技术是 Web 开发的原点, 几乎所有的 Java Web 框架(比如 Spring)都是基于 Servlet 的封装, Spring 应用本身就是一个 Servlet, 而 Tomcat 和 Jetty 这样的 Web 容器, 负责加载和运行 Servlet. 可以通过下面这张图来理解 Tomcat 和 Jetty 在 Web 开发中的位置.</p> <p>​<img src="/img/image-20230405155856-ubjww1f.jpg" alt="">​</p> <p>Tomcat 和 Jetty 中用到不少 Java 高级技术, 比如 Java 多线程并发编程, Socket 网络编程以及反射等等. 通过对 Tomcat 和 Jetty 源码的学习, 可以学会在什么样的场景下去用这些技术, 这一点至关重要.</p> <p>还有就是系统设计能力, Tomcat 和 Jetty 作为工业级的中间件, 它们的设计非常优秀, 比如面向接口编程, 组件化, 骨架抽象类, 一键式启停, 对象池技术以及各种设计模式, 比如模板方法, 观察者模式, 责任链模式等, 之后我也开始模仿它们并把这些设计思想运用到实际的工作中.</p> <p>独当一面的能力, 离不开<strong>技术的广度和深度</strong>.</p> <p>技术的广度体现在你的知识是成体系的, 从前端到后端, 从应用层面到操作系统, 从软件到硬件, 从开发, 测试, 部署到运维…有些领域虽然你不需要挖得很深, 但是你必须知道这其中的“门道”.</p> <p>而技术的深度体现在对于某种技术, 你不仅知道怎么用, 还知道这项技术如何产生的, 它背后的原理是什么, 以及它为什么被设计成这样, 甚至你还得知道如何去改进它.</p> <p>总之弄懂了 Tomcat 和 Jetty, 就能体会到大神们是如何设计 Tomcat 和 Jetty 的, 体会他们如何思考问题, 如何写代码. 比如怎样设计服务端程序的 I/O 和线程模型, 怎样写高性能高并发程序, Spring 的 IoC 容器为什么设计成这个样子, 设计一个中间件或者框架有哪些套路等...</p> <p>有了一定 Java 基础的人, 对于系统设计的体会可能还不够深刻, 编程的时候还停留在完成功能的层次. 这样不仅业务上难有突破, 对于个人成长也很不利. 为了打破这个瓶颈, 就需要在深度上多下功夫, 找准一个点, 深挖下去, 彻底理解它的原理和设计精髓.</p> <h4 id="_1-http与tomcat"><a href="#_1-http与tomcat" class="header-anchor">#</a> 1.HTTP与Tomcat</h4> <h5 id="http与tomcat"><a href="#http与tomcat" class="header-anchor">#</a> HTTP与Tomcat</h5> <p><strong>HTTP 协议的本质就是一种浏览器与服务器之间约定好的通信格式</strong>. 一次 HTTP 的请求过程如下.</p> <p><img src="/img/image-20230405160006-9o9saqk.jpg" alt=""></p> <p>Tomcat 和 Jetty 作为一个 HTTP 服务器, 在这个过程中都做了些什么事情呢? 主要是<strong>接受连接, 解析请求数据, 处理请求和发送响应</strong>这几个步骤. 注意, 可能有成千上万的浏览器同时请求同一个 HTTP 服务器, 因此 Tomcat 和 Jetty 为了提高服务的能力和并发度, 往往会将自己要做的几个事情<strong>并行化</strong>, 具体来说就是<strong>使用多线程技术</strong>.</p> <h5 id="tomcat与session"><a href="#tomcat与session" class="header-anchor">#</a> Tomcat与Session</h5> <p>HTTP 协议有个特点是无状态, 请求与请求之间是没有关系的. 这样会出现一个很尴尬的问题: Web 应用不知道你是谁. 比如你登陆淘宝后, 在购物车中添加了三件商品, 刷新一下网页, 这时系统提示你仍然处于未登录的状态, 购物车也空了, 很显然这种情况是不可接受的. 因此 HTTP 协议需要一种技术让请求与请求之间建立起联系, 并且服务器需要知道这个请求来自哪个用户, 于是 Cookie 技术出现了.</p> <p>由于 Cookie 以明文的方式存储在本地, 而 Cookie 中往往带有用户信息, 这样就造成了非常大的安全隐患. 而 Session 的出现解决了这个问题, <strong>Session 可以理解为</strong>​******服务器**<strong><strong>​</strong>端开辟的存储空间, 里面保存了用户的状态</strong>, 用户信息以 Session 的形式存储在服务端. 当用户请求到来时, 服务端可以把用户的请求和用户的 Session 对应起来. 那么 Session 是怎么和请求对应起来的呢? 答案是通过 Cookie, 浏览器在 Cookie 中填充了一个 Session ID 之类的字段用来标识请求.</p> <p>具体工作过程是这样的: <strong>服务器在创建 Session 的同时, 会为该 Session 生成唯一的 Session ID, 当浏览器再次发送请求的时候, 会将这个 Session ID 带上, 服务器接受到请求之后就会依据 Session ID 找到相应的 Session, 找到 Session 后, 就可以在 Session 中获取或者添加内容了</strong>. 而这些内容只会保存在服务器中, 发到客户端的只有 Session ID, 这样相对安全, 也节省了网络流量, 因为不需要在 Cookie 中存储大量用户信息.</p> <p>那么 Session 在何时何地创建呢? 当然还是在服务器端程序运行的过程中创建的, 不同语言实现的应用程序有不同的创建 Session 的方法. <strong>在 Java 中, 是 Web 应用程序在调用 HttpServletRequest 的 getSession 方法时, 由 Web 容器(比如 Tomcat)创建的</strong>.</p> <p>Tomcat 的 Session 管理器提供了<strong>多种持久化方案来存储 Session</strong>, 通常会采用高性能的存储方式, 比如 Redis, 并且通过集群部署的方式, 防止单点故障, 从而提升高可用. 同时, Session 有过期时间, <strong>因此 Tomcat 会开启后台线程定期的轮询, 如果 Session 过期了就将 Session 失效</strong>.</p> <h4 id="_2-servlet规范与servlet容器"><a href="#_2-servlet规范与servlet容器" class="header-anchor">#</a> 2.Servlet规范与Servlet容器</h4> <h5 id="servlet规范"><a href="#servlet规范" class="header-anchor">#</a> Servlet规范</h5> <p>浏览器发给服务端的是一个 HTTP 格式的请求, HTTP 服务器收到这个请求后, 需要调用服务端程序来处理, 所谓的服务端程序就是写的 Java 类, 一般来说不同的请求需要由不同的 Java 类来处理. 那么 HTTP 服务器怎么知道要调用哪个 Java 类的哪个方法呢. 最直接的做法是在 HTTP 服务器代码里写一大堆 if else 逻辑判断: 如果是 A 请求就调 X 类的 M1 方法, 如果是 B 请求就调 Y 类的 M2 方法. 但这样做明显有问题, 因为 HTTP 服务器的代码跟业务逻辑耦合在一起了, 如果新加一个业务方法还要改 HTTP 服务器的代码.</p> <p>那该怎么解决这个问题呢? 面向接口编程是解决耦合问题的法宝, 于是一伙人就定义了一个接口, 各种业务类都必须实现这个接口, 这个接口就叫 <strong>Servlet 接口</strong>, 有时也把实现了 Servlet 接口的业务类叫作 Servlet.</p> <p>还有一个问题, 对于特定的请求, HTTP 服务器如何知道由哪个 Servlet 来处理呢? Servlet 又是由谁来实例化呢? 显然 HTTP 服务器不适合做这个工作, 否则又和业务类耦合了.</p> <p>于是, 又发明了 <strong>Servlet 容器, Servlet 容器用来加载和管理业务类</strong>. <strong>HTTP 服务器不直接跟业务类打交道, 而是把请求交给 Servlet 容器去处理, Servlet 容器会将请求转发到具体的 Servlet, 如果这个 Servlet 还没创建, 就加载并实例化这个 Servlet, 然后调用这个 Servlet 的接口方法</strong>. 因此 Servlet 接口其实是 <strong>Servlet 容器跟具体业务类之间的接口</strong>. 下面通过一张图来加深理解.</p> <p><img src="/img/image-20230405160035-9i7e2ce.jpg" alt=""></p> <p>图的左边表示 HTTP 服务器直接调用具体业务类, 它们是紧耦合的. 再看图的右边, <strong>HTTP 服务器不直接调用业务类, 而是把请求交给容器来处理, 容器通过 Servlet 接口调用业务类</strong>. 因此 Servlet 接口和 Servlet 容器的出现, 达到了 <strong>HTTP 服务器与业务类解耦</strong>的目的.</p> <p>而 Servlet 接口和 Servlet 容器这一整套规范叫作 <strong>Servlet 规范</strong>. <strong>Tomcat 和 Jetty 都按照 Servlet 规范的要求实现了 Servlet 容器, 同时它们也具有 HTTP 服务器的功能</strong>. 如果要实现新的业务功能, 只需要实现一个 Servlet, 并把它注册到 Tomcat(Servlet 容器)中, 剩下的事情就由 Tomcat 处理了.</p> <p>Tomcat 和 Jetty 都是 Servlet 容器的具体实现, 虽然它们的实现方法各有特点, 但是都遵守了 Servlet 规范, 因此 Web 应用可以在这两个 Servlet 容器中方便的切换.</p> <h5 id="servlet接口"><a href="#servlet接口" class="header-anchor">#</a> Servlet接口</h5> <p>Servlet 接口定义了下面五个方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Servlet</span> <span class="token punctuation">{</span>  
    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">ServletConfig</span> config<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">;</span>  
    <span class="token class-name">ServletConfig</span> <span class="token function">getServletConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> res<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>  
    <span class="token class-name">String</span> <span class="token function">getServletInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>其中最重要是的 service() 方法, 具体业务类在这个方法里实现处理逻辑</strong>. 这个方法有两个参数: <strong>ServletRequest 和 ServletResponse. ServletRequest 用来封装请求信息, ServletResponse 用来封装响应信息</strong>, 因此**本质上这两个类是对通信协议的封装. **</p> <p>比如 <strong>HTTP 协议中的请求和响应</strong>就是对应了 <strong>HttpServletRequest</strong> 和 <strong>HttpServletResponse</strong> 这两个类. 可以通过 HttpServletRequest 来获取所有请求相关的信息, 包括请求路径, Cookie, HTTP 头, 请求参数等. 此外, 还可以通过 HttpServletRequest 来创建和获取 Session. 而 HttpServletResponse 是用来封装 HTTP 响应的.</p> <p>接口中还有两个跟<strong>生命周期有关的方法 init() 和 destroy()</strong> , 这是一个比较贴心的设计, <strong>Servlet 容器在加载 Servlet 类的时候会调用 init() 方法, 在卸载的时候会调用 destroy() 方法. 可能会在 init() 方法里初始化一些资源, 并在 destroy() 方法里释放这些资源, 比如 Spring MVC 中的 DispatcherServlet, 就是在 init() 方法里创建了自己的 Spring 容器</strong>.</p> <p>注意 ServletConfig 这个类, <strong>ServletConfig 的作用就是封装 Servlet 的初始化参数</strong>. 可以在 web.xml 给 Servlet 配置参数, 并在程序里通过 getServletConfig() 方法拿到这些参数.</p> <p>既然定义了 Servlet 接口, 有接口一般就有抽象类, 抽象类用来实现接口和封装通用的逻辑, 因此 Servlet 规范提供了 <strong>GenericServlet</strong> 抽象类, 可以通过扩展它来实现 Servlet. 虽然 Servlet 规范并不在乎通信协议是什么, 但是大多数的 Servlet 都是在 HTTP 环境中处理的, 因此 <strong>Servet 规范还提供了 HttpServlet 来继承 GenericServlet</strong>, 并且加入了 HTTP 特性. <strong>因此一般可以继承 HttpServlet 类来实现自己的 Servlet, 只需要重写两个方法: doGet() 和 doPost()</strong> .</p> <h5 id="servlet容器"><a href="#servlet容器" class="header-anchor">#</a> Servlet容器</h5> <p>前面提到, 为了解耦, HTTP 服务器不直接调用 Servlet, 而是<strong>把请求交给 Servlet 容器来处理</strong>, 那 Servlet 容器又是怎么工作的呢? 下面看看两个重要话题: <strong>Web 应用的目录格式是什么样的, 以及该怎样扩展和定制化 Servlet 容器的功能</strong>.</p> <h6 id="_1-工作流程"><a href="#_1-工作流程" class="header-anchor">#</a> 1.工作流程</h6> <p><strong>当客户请求某个资源时, HTTP 服务器会用一个 ServletRequest 对象把客户的请求信息封装起来, 然后调用 Servlet 容器的 service() 方法, Servlet 容器拿到请求后, 根据请求的 URL 和 Servlet 的映射关系, 找到相应的 Servlet, 如果 Servlet 还没有被加载, 就用反射机制创建这个 Servlet, 并调用 Servlet 的 init() 方法来完成初始化, 接着调用 Servlet 的 service() 方法来处理请求, 把 ServletResponse 对象返回给 HTTP 服务器, HTTP 服务器会把响应发送给客户端</strong>. 同样通过一张图来帮助理解.</p> <p><img src="/img/image-20230405160035-vakv9dj.jpg" alt=""></p> <h6 id="_2-web应用"><a href="#_2-web应用" class="header-anchor">#</a> 2.Web应用</h6> <p>Servlet 容器会实例化和调用 Servlet, 那 Servlet 是怎么注册到 Servlet 容器中的呢? 一般来说是以 Web 应用程序的方式来部署 Servlet 的, 而根据 Servlet 规范, <strong>Web 应用程序有一定的目录结构</strong>, 在这个目录下分别放置了 Servlet 的类文件, 配置文件以及静态资源, Servlet 容器通过读取配置文件, 就能找到并加载 Servlet. Web 应用的目录结构大概是下面这样的:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>| -  MyWebApp
      | -  WEB-INF/web.xml        -- 配置文件, 用来配置 Servlet 等
      | -  WEB-INF/lib/           -- 存放 Web 应用所需各种 JAR 包
      | -  WEB-INF/classes/       -- 存放应用类, 比如 Servlet 类
      | -  META-INF/              -- 目录存放工程的一些信息
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Servlet 规范里定义了 <strong>ServletContext ** 这个接口来对应一个 Web 应用. Web 应用部署好后, Servlet 容器在启动时会加载 Web 应用, 并</strong>为每个 Web 应用创建唯一的 ServletContext 对象**. 可以把 ServletContext 看成是一个全局对象, 一个 Web 应用可能有多个 Servlet, 这些 Servlet 可以通过全局的 ServletContext 来共享数据, 这些数据包括 Web 应用的初始化参数, Web 应用目录下的文件资源等. 由于 ServletContext 持有所有 Servlet 实例, 还可以通过它来实现 Servlet 请求的转发.</p> <h6 id="_3-扩展机制"><a href="#_3-扩展机制" class="header-anchor">#</a> 3.扩展机制</h6> <p>引入了 Servlet 规范后, 就不需要关心 Socket 网络通信, 不需要关心 HTTP 协议, 也不需要关心业务类是如何被实例化和调用的, 因为这些都被 <strong>Servlet 规范标准化</strong>了, 只要关心怎么实现业务逻辑. 这对于程序员来说是件好事, 但也有不方便的一面. 所谓规范就是说大家都要遵守, 就会千篇一律, 但是如果这个规范不能满足业务的个性化需求, 就有问题了, 因此<strong>设计一个规范或者一个中间件, 要充分考虑到可扩展性</strong>. Servlet 规范提供了两种扩展机制: **Filter ** 和 <strong>Listener</strong>.</p> <p><strong>Filter 是过滤器</strong>, 这个接口允许对请求和响应做一些统一的定制化处理, 比如可以根据请求的频率来限制访问, 或者根据国家地区的不同来修改响应内容. 过滤器的工作原理是这样的: Web 应用部署完成后, Servlet 容器<strong>需要实例化 Filter 并把 Filter 链接成一个 FilterChain. 当请求进来时, 获取第一个 Filter 并调用 doFilter() 方法, doFilter() 方法负责调用这个 FilterChain 中的下一个 Filter</strong>.</p> <p><strong>Listener 是监听器</strong>, 这是另一种扩展机制. 当 Web 应用在 Servlet 容器中运行时, Servlet 容器内部会不断的发生各种事件, 如 Web 应用的启动和停止, 用户请求到达等.  Servlet 容器提供了一些默认的监听器来监听这些事件, <strong>当事件发生时, Servlet 容器会负责调用监听器的方法</strong>. 当然, 可以定义自己的监听器去监听感兴趣的事件, 将监听器配置在 web.xml 中. 比如 Spring 就实现了自己的监听器, 来监听 ServletContext 的启动事件, 目的是当 Servlet 容器启动时, 创建并初始化全局的 Spring 容器.</p> <p>总结一下 Filter 和 Listener 的本质区别:</p> <ul><li><strong>Filter 是干预过程的</strong>, 它是过程的一部分, 是基于过程行为的.</li> <li><strong>Listener 是基于状态的</strong>, 任何行为改变同一个状态, 触发的事件是一致的.</li></ul> <h4 id="_3-实战-运行一个servlet"><a href="#_3-实战-运行一个servlet" class="header-anchor">#</a> 3.实战:运行一个Servlet</h4> <p>今天就抛弃 IDE, 拒绝框架, 自己纯手工编写一个 Servlet, 并在 Tomcat 中运行起来.</p> <p>主要的步骤有:</p> <ol><li>下载并安装 Tomcat.</li> <li>编写一个继承 HttpServlet 的 Java 类.</li> <li>将 Java 类文件编译成 Class 文件.</li> <li>建立 Web 应用的目录结构, 并配置 web.xml.</li> <li>部署 Web 应用.</li> <li>启动 Tomcat.</li> <li>浏览器访问验证结果.</li> <li>查看 Tomcat 日志.</li></ol> <p>Servlet 3.0 规范支持用注解的方式来部署 Servlet, 不需要在 web.xml 里配置, 最后会演示怎么用注解的方式来部署 Servlet.</p> <p><strong>1.下载并安装Tomcat</strong></p> <p>最新版本的 Tomcat 可以直接在<a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener noreferrer">官网<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>上下载, 根据你的操作系统下载相应的版本, 这里我使用的是 Mac 系统, 下载完成后直接解压, 解压后的目录结构如下.</p> <p><img src="/img/image-20230405160901-fs7d46p.png" alt=""></p> <p>下面简单介绍一下这些目录:</p> <ul><li><strong>/bin</strong>: 存放启动和关闭 Tomcat 的脚本文件.</li> <li><strong>/conf</strong>: 存放 Tomcat 的各种全局配置文件, 其中最重要的是 <strong>server.xml</strong>.</li> <li><strong>/lib</strong>: 存放 <strong>Tomcat 以及所有 Web 应用都可以访问的 JAR 文件</strong>.</li> <li><strong>/logs</strong>: 存放 Tomcat 执行时产生的日志文件.</li> <li><strong>/work</strong>: 存放 JSP 编译后产生的 Class 文件.</li> <li><strong>/webapps</strong>: Tomcat 的 <strong>Web 应用目录, 默认情况下把 Web 应用放在这个目录下</strong>.</li></ul> <p><strong>2.编写一个继承HttpServlet的Java类</strong></p> <p>之前提到, 可以通过继承 HttpServlet 类来实现自己的 Servlet 只需要重写两个方法: doGet() 和 doPost(). 因此这里创建一个 Java 类去继承 HttpServlet 类, 并重写 doGet() 和 doPost() 方法. 首先新建一个名为 MyServlet.java 的文件, 如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">PrintWriter</span></span><span class="token punctuation">;</span>
 
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token class-name">ServletException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServlet</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletRequest</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletResponse</span></span><span class="token punctuation">;</span>
 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>
 
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span>
            <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
 
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;MyServlet 在处理 get()请求...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">&quot;text/html;charset=utf-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;&lt;strong&gt;My Servlet!&lt;/strong&gt;&lt;br&gt;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span>
            <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
 
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;MyServlet 在处理 post()请求...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">&quot;text/html;charset=utf-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;&lt;strong&gt;My Servlet!&lt;/strong&gt;&lt;br&gt;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>这个 Servlet 完成的功能很简单, 分别在 doGet() 和 doPost() 方法体里返回一段简单的 HTML.</p> <p><strong>3.将Java文件编译成Class文件</strong></p> <p>下一步需要把 MyServlet.java 文件编译成 Class 文件. 接着需要把 Tomcat /lib 目录下的 servlet-api.jar 拷贝到当前目录下, 这是因为 <strong>servlet-api.jar 中定义了 Servlet 接口</strong>, 而自定义的 Servlet 类实现了 Servlet 接口, 因此编译 Servlet 类需要这个 JAR 包. 接着执行编译命令:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>javac -cp ./servlet-api.jar MyServlet.java
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>编译成功后, 你会在当前目录下找到一个叫 MyServlet.class 的文件.</p> <p><strong>4.建立Web应用的目录结构</strong></p> <p>Servlet 是放到 Web 应用部署到 Tomcat 的, 而 Web 应用具有一定的目录结构, 所有按照要求建立 Web 应用文件夹, 名字叫 MyWebApp, 然后在这个目录下建立子文件夹, 像下面这样:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>MyWebApp/WEB-INF/web.xml
MyWebApp/WEB-INF/classes/MyServlet.class
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>然后在 web.xml 中配置 Servlet, 内容如下:</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token prolog">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://xmlns.jcp.org/xml/ns/javaee<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://xmlns.jcp.org/xml/ns/javaee
  http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>4.0<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">metadata-complete</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>true<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">&gt;</span></span> Servlet Example. <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">&gt;</span></span> MyServlet Example <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>request-character-encoding</span><span class="token punctuation">&gt;</span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>request-character-encoding</span><span class="token punctuation">&gt;</span></span>
 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">&gt;</span></span>myServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">&gt;</span></span>MyServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">&gt;</span></span>
 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">&gt;</span></span>myServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/myservlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">&gt;</span></span>
 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>可以看到在 web.xml 配置了 Servlet 的名字和具体的类, 以及这个 Servlet 对应的 URL 路径. 注意 **servlet 和 servlet-mapping 这两个标签里的 servlet-name 要保持一致. **</p> <p><strong>5.部署Web应用</strong></p> <p>Tomcat 应用的部署非常简单, 将这个目录 MyWebApp 拷贝到 Tomcat 的安装目录下的 webapps 目录即可.</p> <p><strong>6.启动Tomcat</strong></p> <p>找到 Tomcat 安装目录下的 bin 目录, 根据操作系统的不同, 执行相应的启动脚本. Linux 系统则执行 <code>startup.sh</code>​.</p> <p><strong>7.浏览访问验证结果</strong></p> <p>在浏览器里访问这个 URL: <code>http://localhost:8080/MyWebApp/myservlet</code>​, 会得到:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>My Servlet!
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这里需要注意, 访问 URL 路径中的 MyWebApp 是 Web 应用的名字, myservlet 是在 web.xml 里配置的 Servlet 的路径.</p> <p><strong>8.查看Tomcat日志</strong></p> <p>打开 Tomcat 的日志目录, 也就是 Tomcat 安装目录下的 logs 目录. Tomcat 的日志信息分为两类: 一是运行日志, 它主要记录运行过程中的一些信息, 尤其是一些异常错误日志信息; 二是访问日志, 它记录访问的时间, IP 地址, 访问的路径等相关信息.</p> <p>这里简要介绍各个文件的含义.</p> <ul><li>​<code>catalina.***.log</code>​</li></ul> <p>主要是记录 Tomcat 启动过程的信息, 在这个文件可以看到启动的 JVM 参数以及操作系统等日志信息.</p> <ul><li>​<code>catalina.out</code>​</li></ul> <p>catalina.out 是 Tomcat 的标准输出(stdout)和标准错误(stderr), 这是在 Tomcat 的启动脚本里指定的, 如果没有修改的话 stdout 和 stderr 会重定向到这里. 所以在这个文件里可以看到在 MyServlet.java 程序里打印出来的信息: &quot;MyServlet 在处理 get() 请求...&quot;</p> <ul><li>​<code>localhost.**.log</code>​</li></ul> <p>主要记录 Web 应用在初始化过程中遇到的未处理的异常, 会被 Tomcat 捕获而输出这个日志文件.</p> <ul><li>​<code>localhost_access_log.**.txt</code>​</li></ul> <p>存放访问 Tomcat 的请求日志, 包括 IP 地址以及请求的路径, 时间, 请求协议以及状态码等信息.</p> <ul><li>​<code>manager.***.log/host-manager.***.log</code>​</li></ul> <p>存放 Tomcat 自带的 manager 项目的日志信息.</p> <p><strong>9.用注解的方式部署Servlet</strong></p> <p>为了演示用注解的方式来部署 Servlet, 首先修改 Java 代码, 给 Servlet 类加上  **@WebServlet ** 注解, 修改后的代码如下.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">PrintWriter</span></span><span class="token punctuation">;</span>
 
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token class-name">ServletException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">WebServlet</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServlet</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletRequest</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletResponse</span></span><span class="token punctuation">;</span>
 
<span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span><span class="token string">&quot;/myAnnotationServlet&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>
 
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span>
            <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
  
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;AnnotationServlet 在处理 get()请求...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">&quot;text/html; charset=utf-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;&lt;strong&gt;Annotation Servlet!&lt;/strong&gt;&lt;br&gt;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token punctuation">}</span>
 
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span>
            <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
 
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;AnnotationServlet 在处理 post()请求...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">&quot;text/html; charset=utf-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;&lt;strong&gt;Annotation Servlet!&lt;/strong&gt;&lt;br&gt;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token punctuation">}</span>
 
<span class="token punctuation">}</span>  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>这段代码里最关键的就是这个注解, 它表明两层意思: 第一层意思是 AnnotationServlet 这个 Java 类是一个 Servlet, 第二层意思是这个 Servlet 对应的 URL 路径是 myAnnotationServlet.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@WebServlet(&quot;/myAnnotationServlet&quot;)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>创建好 Java 类以后, 同样经过编译, 并放到 MyWebApp 的 class 目录下. 这里要注意的是, <strong>需要删除之前的 web.xml</strong>, 因为不需要 web.xml 来配置 Servlet 了. 然后重启 Tomcat, 接下来验证一下这个新的 AnnotationServlet 有没有部署成功. 在浏览器里输入: <code>http://localhost:8080/MyWebApp/myAnnotationServlet</code>​, 得到结果:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Annotation Servlet!
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这说明 AnnotationServlet 部署成功了. 可以通过注解完成 web.xml 所有的配置功能, 包括 Servlet 初始化参数以及配置 Filter 和 Listener 等.</p> <h3 id="整体架构"><a href="#整体架构" class="header-anchor">#</a> 整体架构</h3> <h4 id="_4-tomcat系统架构-连接器和容器"><a href="#_4-tomcat系统架构-连接器和容器" class="header-anchor">#</a> 4.Tomcat系统架构:连接器和容器</h4> <p>这里一步一步分析 Tomcat 的设计思路, 看看 Tomcat 的设计者们当时是怎么回答这个问题的. 一方面可以学到 Tomcat 的总体架构, 学会从宏观上怎么去设计一个复杂系统, 怎么设计顶层模块, 以及模块之间的关系; 另一方面也为深入学习 Tomcat 的工作原理打下基础.</p> <h5 id="tomcat总体架构"><a href="#tomcat总体架构" class="header-anchor">#</a> Tomcat总体架构</h5> <p>如果要设计一个系统, 首先是要了解需求. 前面已经了解了 Tomcat 要实现 2 个核心功能:</p> <ul><li>处理 Socket 连接, 负责网络字节流与 Request 和 Response 对象的转化.</li> <li>加载和管理 Servlet, 以及具体处理 Request 请求.</li></ul> <p><mark><strong>因此 Tomcat 设计了两个核心组件连接器(Connector)和容器(Container)来分别做这两件事情. 连接器负责对外交流, 容器负责内部处理</strong></mark>​ **. **</p> <p>在开始分析连接器前, 先铺垫一下 Tomcat 支持的多种 I/O 模型和应用层协议.</p> <p>Tomcat 支持的 I/O 模型有:</p> <ul><li>NIO: 非阻塞 I/O, 采用 Java NIO 类库实现.</li> <li>NIO2: 异步 I/O, 采用 JDK 7 最新的 NIO2 类库实现.</li> <li>APR: 采用 Apache 可移植运行库实现, 是 C/C++ 编写的本地库.</li></ul> <p>Tomcat 支持的应用层协议有:</p> <ul><li>HTTP/1.1: 这是大部分 Web 应用采用的访问协议.</li> <li>AJP: 用于和 Web 服务器集成(如 Apache).</li> <li>HTTP/2: HTTP 2.0 大幅度的提升了 Web 性能.</li></ul> <p>**Tomcat 为了实现支持多种 I/O 模型和应用层协议, 一个容器可能对接多个连接器, 就好比一个房间有多个门. 但是单独的连接器或者容器都不能对外提供服务, 需要把它们组装起来才能工作, 组装后这个整体叫作 Service 组件. 注意, Service 本身没有做什么重要的事情, 只是在连接器和容器外面多包了一层, 把它们组装在一起. Tomcat 内可能有多个 Service, 这样的设计也是出于灵活性的考虑. 通过在 Tomcat 中配置多个 Service, 可以实现通过不同的端口号来访问同一台机器上部署的不同应用. **</p> <p>到此得到这样一张关系图:</p> <p><img src="/img/image-20230405160950-u1ygbo1.jpg" alt=""></p> <p>**图中最顶层是 Server, 这里的 Server 指的就是一个 Tomcat 实例. 一个 Server 中有一个或者多个 Service, 一个 Service 中有多个连接器和一个容器. 连接器与容器之间通过标准的 ServletRequest 和 ServletResponse 通信. **</p> <p>下面分别详细解释一下连接器和容器.</p> <h5 id="连接器"><a href="#连接器" class="header-anchor">#</a> 连接器</h5> <p>**连接器对 Servlet 容器屏蔽了协议及 I/O 模型等的区别, 无论是 HTTP 还是 AJP, 在容器中获取到的都是一个标准的 ServletRequest 对象. **</p> <p>可以把连接器的功能需求进一步细化, 比如:</p> <ul><li>监听网络端口.</li> <li>接受网络连接请求.</li> <li>读取请求网络字节流.</li> <li>根据具体应用层协议(HTTP/AJP)解析字节流, 生成统一的 Tomcat Request 对象.</li> <li>将 Tomcat Request 对象转成标准的 ServletRequest.</li> <li>调用 Servlet 容器, 得到 ServletResponse.</li> <li>将 ServletResponse 转成 Tomcat Response 对象.</li> <li>将 Tomcat Response 转成网络字节流.</li> <li>将响应字节流写回给浏览器.</li></ul> <p>需求列清楚后要考虑的下一个问题是, 连接器应该有哪些子模块? 优秀的模块化设计应该考虑<strong>高内聚, 低耦合</strong>.</p> <ul><li><strong>高内聚</strong>是指相关度比较高的功能要尽可能集中, 不要分散.</li> <li><strong>低耦合</strong>是指两个相关的模块要尽可能减少依赖的部分和降低依赖的程度, 不要让两个模块产生强依赖.</li></ul> <p>通过分析连接器的详细功能列表, 可以发现连接器需要完成 3 个<strong>高内聚</strong>的功能:</p> <ul><li>网络通信.</li> <li>应用层协议解析.</li> <li>Tomcat Request/Response 与 ServletRequest/ServletResponse 的转化.</li></ul> <p>**因此 Tomcat 的设计者设计了 3 个组件来实现这 3 个功能, 分别是 EndPoint, Processor 和 Adapter. **</p> <p>组件之间通过抽象接口交互. 这样做还有一个好处是**封装变化. ** 这是面向对象设计的精髓, 将系统中经常变化的部分和稳定的部分隔离, 有助于增加复用性, 并降低系统耦合度.</p> <p>网络通信的 I/O 模型是变化的, 可能是非阻塞 I/O, 异步 I/O 或者 APR. 应用层协议也是变化的, 可能是 HTTP, HTTPS, AJP. 浏览器端发送的请求信息也是变化的.</p> <p>**但是整体的处理逻辑是不变的, EndPoint 负责提供字节流给 Processor, Processor 负责提供 Tomcat Request 对象给 Adapter, Adapter 负责提供 ServletRequest 对象给容器. **</p> <p>如果要支持新的 I/O 方案, 新的应用层协议, 只需要实现相关的具体子类, 上层通用的处理逻辑是不变的.</p> <p>由于 I/O 模型和应用层协议可以自由组合, 比如 NIO + HTTP 或者 NIO2 + AJP. Tomcat 的设计者将网络通信和应用层协议解析放在一起考虑, 设计了一个叫 <strong>ProtocolHandler 的接口来封装这两种变化点. 各种协议和通信模型的组合有相应的具体实现类. 比如: Http11NioProtocol 和 AjpNioProtocol</strong>.</p> <p>除了这些变化点, 系统也存在一些相对稳定的部分, 因此 Tomcat 设计了一系列抽象基类来<strong>封装这些稳定的部分</strong>, 抽象基类 <strong>AbstractProtocol</strong> 实现了 ProtocolHandler 接口. 每一种应用层协议有自己的抽象基类, 比如 AbstractAjpProtocol 和 AbstractHttp11Protocol, 具体协议的实现类扩展了协议层抽象基类. 下面整理一下它们的继承关系.</p> <p><img src="/img/image-20230405160950-36cmbgl.jpg" alt=""></p> <p>通过上面的图可以清晰地看到它们的继承和层次关系, 这样设计的目的是<strong>尽量将稳定的部分放到抽象基类</strong>, 同时每一种 I/O 模型和协议的组合都有相应的具体实现类, 在使用时就可以自由选择.</p> <p>小结一下, 连接器模块用三个核心组件: Endpoint, Processor 和 Adapter 来分别做三件事情, 其中 Endpoint 和 Processor 放在一起抽象成了 ProtocolHandler 组件, 它们的关系如下图所示.</p> <p><img src="/img/image-20230405160951-h8go2yh.jpg" alt=""></p> <p>下面详细介绍这两个顶层组件 ProtocolHandler 和 Adapter.</p> <h6 id="_1-protocolhandler组件"><a href="#_1-protocolhandler组件" class="header-anchor">#</a> 1.ProtocolHandler组件</h6> <p>从前面可知, <strong>连接器用 ProtocolHandler 来处理网络连接和应用层协议, 包含了 2 个重要部件: EndPoint 和 Processor</strong>.</p> <p><strong>(1)EndPoint</strong></p> <p>EndPoint 是通信端点, 即通信监听的接口, 是具体的 Socket 接收和发送处理器, 是对传输层的抽象, 因此 <strong>EndPoint 是用来实现 TCP/IP 协议</strong>的.</p> <p>EndPoint 是一个接口, 对应的抽象实现类是 AbstractEndpoint, 而 AbstractEndpoint 的具体子类, 比如在 NioEndpoint 和 Nio2Endpoint 中, 有两个重要的子组件: <strong>Acceptor 和 SocketProcessor</strong>.</p> <p>其中 Acceptor 用于监听 Socket 连接请求. SocketProcessor 用于处理接收到的 Socket 请求, 它实现 Runnable 接口, 在 Run 方法里调用协议处理组件 Processor 进行处理. 为了提高处理能力, SocketProcessor 被提交到线程池来执行. 而这个线程池叫作执行器(Executor), 后面会详细介绍 Tomcat 如何扩展原生的 Java 线程池.</p> <p><strong>(2)Processor</strong></p> <p>如果说 EndPoint 是用来实现 TCP/IP 协议的, 那么 <strong>Processor 用来实现 HTTP 协议</strong>, Processor 接收来自 EndPoint 的 Socket, 读取字节流解析成 Tomcat Request 和 Response 对象, 并通过 Adapter 将其提交到容器处理, Processor 是对应用层协议的抽象.</p> <p>Processor 是一个接口, 定义了请求的处理等方法. 它的抽象实现类 AbstractProcessor 对一些协议共有的属性进行封装, 没有对方法进行实现. 具体的实现有 AJPProcessor, HTTP11Processor 等, 这些具体实现类实现了特定协议的解析方法和请求处理方式.</p> <p>再来看看连接器的组件图:</p> <p><img src="/img/image-20230405160951-uuujwdk.jpg" alt=""></p> <p>从图中看到, <strong>EndPoint 接收到 Socket 连接后, 生成一个 SocketProcessor 任务提交到线程池去处理, SocketProcessor 的 Run 方法会调用 Processor 组件去解析应用层协议, Processor 通过解析生成 Request 对象后, 会调用 Adapter 的 Service 方法</strong>.</p> <h6 id="_2-adapter组件"><a href="#_2-adapter组件" class="header-anchor">#</a> 2.Adapter组件</h6> <p>由于协议不同, 客户端发过来的请求信息也不尽相同, Tomcat 定义了自己的 <strong>Request</strong> 类来“存放”这些请求信息. <strong>ProtocolHandler 接口负责解析请求并生成 Tomcat Request 类. ** 但是这个 Request 对象不是标准的 ServletRequest, 也就意味着, 不能用 Tomcat Request 作为参数来调用容器. Tomcat 设计者的解决方案是</strong>引入 CoyoteAdapter, 这是适配器模式的经典运用, 连接器调用 CoyoteAdapter 的 Sevice 方法, 传入的是 Tomcat Request 对象, CoyoteAdapter 负责将 Tomcat Request 转成 ServletRequest, 再调用容器的 Service 方法**.</p> <h5 id="容器"><a href="#容器" class="header-anchor">#</a> 容器</h5> <p>前面提到 Tomcat 有两个核心组件: <strong>连接器和容器</strong>, 其中连接器负责外部交流, 容器负责内部处理. 具体来说就是, 连接器处理 Socket 通信和应用层协议的解析, 得到 Servlet 请求; 而容器则负责处理 Servlet 请求.</p> <p><img src="/img/image-20230405161017-eu8rf7s.jpg" alt=""></p> <p>这里分析一下容器. 容器顾名思义就是用来装载东西的器具, <strong>在 Tomcat 里, 容器就是用来装载 Servlet 的</strong>. 那 Tomcat 的 Servlet 容器是如何设计的呢?</p> <h6 id="_1-容器的层次结构"><a href="#_1-容器的层次结构" class="header-anchor">#</a> 1.容器的层次结构</h6> <p>Tomcat 设计了 4 种容器, 分别是 <strong>Engine, Host, Context 和 Wrapper</strong>. 这 4 种容器不是平行关系, 而是<strong>父子关系</strong>. 下面它们的关系.</p> <p><img src="/img/image-20230405161017-jslu79o.jpg" alt=""></p> <p>为什么要设计成这么多层次的容器, 这不是增加了复杂度吗? 这样 **Tomcat 通过一种分层的架构, 使得 Servlet 容器具有很好的灵活性. **</p> <p><strong>Context 表示一个 Web 应用程序; Wrapper 表示一个 Servlet, 一个 Web 应用程序中可能会有多个 Servlet; Host 代表的是一个虚拟主机, 或者说一个站点, 可以给 Tomcat 配置多个虚拟主机地址, 而一个虚拟主机下可以部署多个 Web 应用程序; Engine 表示引擎, 用来管理多个虚拟站点, 一个 Service 最多只能有一个 Engine</strong>.</p> <p>可以再通过 Tomcat 的 server.xml 配置文件来加深对 Tomcat 容器的理解. Tomcat 采用了组件化的设计, 它的构成组件都是可配置的, 其中最外层的是 Server, 其他组件按照一定的格式要求配置在这个顶层容器中.</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Server</span><span class="token punctuation">&gt;</span></span>                       // 顶层组件, 可以包含多个Service
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Service</span><span class="token punctuation">&gt;</span></span>                  // 顶层组件, 可以包含一个Engine, 多个连接器 
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Connector</span><span class="token punctuation">&gt;</span></span>            // 连机器组件, 代表通信接口
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Connector</span><span class="token punctuation">&gt;</span></span>    
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Engine</span><span class="token punctuation">&gt;</span></span>               // 容器组件, 一个Engine组件处理Service中的所有请求, 包含多个Host
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Host</span><span class="token punctuation">&gt;</span></span>             // 容器组件, 处理特定的Host下的客户请求, 可包含多个Context
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Context</span><span class="token punctuation">&gt;</span></span>      // 容器组件, 为特定的Web应用处理所有的客户请求
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Context</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Host</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Engine</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Service</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Server</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>那么, Tomcat 是怎么管理这些容器的呢? 你会发现这些容器具有<strong>父子关系, 形成一个树形结构</strong>, 你可能马上就想到了设计模式中的<strong>组合模式</strong>. 没错, <strong>Tomcat 就是用组合模式来管理这些容器的</strong>. 具体实现方法是, <strong>所有容器组件都实现了 Container 接口, 因此组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性</strong>. 这里单容器对象指的是最底层的 Wrapper, 组合容器对象指的是上面的 Context, Host 或者 Engine.</p> <p><strong>Container 接口</strong>定义如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Container</span> <span class="token keyword">extends</span> <span class="token class-name">Lifecycle</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Container</span> <span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setParent</span><span class="token punctuation">(</span><span class="token class-name">Container</span> container<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addChild</span><span class="token punctuation">(</span><span class="token class-name">Container</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token class-name">Container</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Container</span> <span class="token function">findChild</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>为了实现父子关系, <strong>Container 接口有</strong> getParent, SetParent, addChild 和 removeChild 等方法. Container 接口还扩展了 LifeCycle 接口, LifeCycle 接口用来统一管理各组件的生命周期, 后面会详细介绍.</p> <h6 id="_2-请求定位servlet的过程"><a href="#_2-请求定位servlet的过程" class="header-anchor">#</a> 2.请求定位Servlet的过程</h6> <p>既然设计了这么多层次的容器, Tomcat 是怎么确定请求是由哪个 Wrapper 容器里的 Servlet 来处理的呢? 答案是, Tomcat 是用 <strong>Mapper 组件</strong>来完成这个任务的.</p> <p>Mapper 组件的功能就是将用户请求的 URL 定位到一个 Servlet, 它的工作原理是: Mapper 组件里保存了 Web 应用的配置信息, 其实就是<strong>容器组件与访问路径的映射关系</strong>, 比如 Host 容器里配置的域名, Context 容器里的 Web 应用路径, 以及 Wrapper 容器里 Servlet 映射的路径, 可以想象这些配置信息就是一个<strong>多层次的 Map</strong>.</p> <p>当一个请求到来时, Mapper 组件通过解析请求 URL 里的域名和路径, 再到自己保存的 Map 里去查找, 就能定位到一个 Servlet. 注意, <strong>一个请求 URL 最后只会定位到一个 Wrapper 容器, 也就是一个 Servlet</strong>.</p> <p>下面通过一个例子来解释这个定位的过程.</p> <p>假如有一个网购系统, 有面向网站管理人员的后台管理系统, 还有面向终端客户的在线购物系统. 这两个系统跑在同一个 Tomcat 上, 为了隔离它们的访问域名, 配置了两个虚拟域名: <code>manage.shopping.com</code>​ 和 <code>user.shopping.com</code>​, 网站管理人员通过 <code>manage.shopping.com</code>​ 域名访问 Tomcat 去管理用户和商品, 而用户管理和商品管理是两个单独的 Web 应用. 终端客户通过 <code>user.shopping.com</code>​ 域名去搜索商品和下订单, 搜索功能和订单管理也是<strong>两个独立的 Web 应用</strong>.</p> <p>针对这样的部署, Tomcat 会<strong>创建一个 Service 组件和一个 Engine 容器组件, 在 Engine 容器下创建两个 Host 子容器, 在每个 Host 容器下创建两个 Context 子容器. 由于一个 Web 应用通常有多个 Servlet, Tomcat 还会在每个 Context 容器里创建多个 Wrapper 子容器</strong>. 每个容器都有对应的访问路径, 如下图所示.</p> <p><img src="/img/image-20230405161017-4f2wapf.jpg" alt=""></p> <p>假如有用户访问一个 URL, 比如图中的 <code>http://user.shopping.com:8080/order/buy</code>​, Tomcat 将这个 URL 定位到一个 Servlet 的过程如下:</p> <p>**首先, 根据协议和端口号选定 Service 和 Engine. **</p> <p>Tomcat 的<strong>每个连接器都监听不同的端口</strong>, 比如 Tomcat 默认的 HTTP 连接器监听 8080 端口, 默认的 AJP 连接器监听 8009 端口. 上面例子中的 URL 访问的是 8080 端口, 因此<strong>这个请求会被 HTTP 连接器接收</strong>, 而一个连接器是属于一个 Service 组件的, 这样 <strong>Service 组件</strong>就确定了. 一个 Service 组件里除了有多个连接器, 还有一个容器组件, 具体来说就是一个 Engine 容器, 因此 Service 确定了也就意味着 Engine 也确定了.</p> <p>**然后, 根据域名选定 Host. **</p> <p>Service 和 Engine 确定后, Mapper 组件通过 URL 中的域名去查找相应的 Host 容器, 比如例子中的 URL 访问的域名是 <code>user.shopping.com</code>​, 因此 Mapper 会找到 Host2 这个容器.</p> <p>**之后, 根据 URL 路径找到 Context 组件. **</p> <p>Host 确定以后, Mapper 根据 URL 的路径来匹配相应的 Web 应用的路径, 比如例子中访问的是 /order, 因此找到了 <strong>Context4</strong> 这个 Context 容器.</p> <p>**最后, 根据 URL 路径找到 Wrapper(Servlet). **</p> <p>Context 确定后, Mapper 再根据 web.xml 中配置的 Servlet 映射路径来找到具体的 Wrapper 和 Servlet.</p> <p>到这里应该已经了解了什么是容器, 以及 Tomcat 如何通过一层一层的父子容器找到某个 Servlet 来处理请求. 需要注意的是, 并不是说只有 Servlet 才会去处理请求, 实际上这个查找路径上的父子容器都会对请求做一些处理. 前面说过, 连接器中的 Adapter 会调用容器的 Service 方法来执行 Servlet, 最先拿到请求的是 Engine 容器, Engine 容器对请求做一些处理后, 会把请求传给自己子容器 Host 继续处理, 依次类推, 最后这个请求会传给 Wrapper 容器, Wrapper 会调用最终的 Servlet 来处理. 那么这个调用过程具体是怎么实现的呢? 答案是使用 <strong>Pipeline-Valve 管道</strong>.</p> <p><strong>Pipeline-Valve 是责任链模式</strong>, 责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理, 每个处理者负责做自己相应的处理, 处理完之后将再调用下一个处理者继续处理.</p> <p><strong>Valve 表示一个处理点</strong>, 比如权限认证和记录日志. 可以来看看 <strong>Valve 和 Pipeline 接口</strong>中的关键方法.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Valve</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Valve</span> <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNext</span><span class="token punctuation">(</span><span class="token class-name">Valve</span> valve<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Request</span> request<span class="token punctuation">,</span> <span class="token class-name">Response</span> response<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>由于 Valve 是一个处理点, 因此 invoke 方法就是来<strong>处理请求</strong>的. 注意到 Valve 中有 getNext 和 setNext 方法, 因此大概可以猜到有一个链表将 Valve 链起来了.</p> <p>继续看 Pipeline 接口:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Pipeline</span> <span class="token keyword">extends</span> <span class="token class-name">Contained</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addValve</span><span class="token punctuation">(</span><span class="token class-name">Valve</span> valve<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Valve</span> <span class="token function">getBasic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBasic</span><span class="token punctuation">(</span><span class="token class-name">Valve</span> valve<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Valve</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>没错, Pipeline 中有 addValve() 方法. <strong>Pipeline 中维护了 Valve 链表</strong>, Valve 可以插入到 Pipeline 中, 对请求做某些处理. 还可以发现 Pipeline 中没有 invoke 方法, 因为<strong>整个调用链的触发是 Valve 来完成的, Valve 完成自己的处理后, 调用 getNext.invoke() 来触发下一个 Valve 调用</strong>.</p> <p><strong>每一个容器都有一个 Pipeline 对象, 只要触发这个 Pipeline 的第一个 Valve, 这个容器里 Pipeline 中的 Valve 就都会被调用到</strong>. 但是, 不同容器的 Pipeline 是怎么链式触发的呢, 比如 Engine 中 Pipeline 需要调用下层容器 Host 中的 Pipeline.</p> <p>这是因为 Pipeline 中还有个 getBasic() 方法. 这个 BasicValve 处于 Valve 链表的<strong>末端</strong>, 它是 Pipeline 中必不可少的一个 Valve, 负责调用下层容器的 Pipeline 里的第一个 Valve. 整个流程如下图所示.</p> <p><img src="/img/image-20230405161017-4comhnb.jpg" alt=""></p> <p>**整个调用过程由连接器中的 Adapter 触发的, 它会调用 Engine 的第一个 Valve: **</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Calling the container</span>
connector<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Wrapper 容器的最后一个 Valve 会创建一个 Filter 链, 并调用 doFilter() 方法, 最终会调到 Servlet 的 service() 方法.</p> <p>你可能会问, 前面不是讲到了 Filter, 似乎也有相似的功能, 那 Valve 和 Filter 有什么区别吗? 它们的区别是:</p> <ul><li>**Valve 是 Tomcat 的私有机制, 与 Tomcat 的基础架构 /API 是紧耦合的. Servlet API 是公有的标准, 所有的 Web 容器包括 Jetty 都支持 Filter 机制. **</li> <li>**另一个重要的区别是 Valve 工作在 Web 容器级别, 拦截所有应用的请求; 而 Servlet Filter 工作在应用级别, 只能拦截某个 Web 应用的所有请求. 如果想做整个 Web 容器的拦截器, 必须通过 Valve 来实现. **</li></ul> <p>请求的链式调用是基于 Pipeline-Valve 责任链来完成的, 这样的设计使得系统具有良好的可扩展性, 如果需要扩展容器本身的功能, 只需要增加相应的 Valve 即可.</p> <h4 id="_5-tomcat如何实现一键式启停"><a href="#_5-tomcat如何实现一键式启停" class="header-anchor">#</a> 5.Tomcat如何实现一键式启停?</h4> <p>下面通过一张简化的类图来回顾一下 Tomcat 的基本架构, 看到各种组件的层次关系, 图中的<strong>虚线表示一个请求在 Tomcat 中流转的过程</strong>.</p> <p><img src="/img/image-20230405161039-3vw9z54.png" alt=""></p> <p>上面这张图描述了组件之间的静态关系, 如果想让一个系统能够对外提供服务, 需要创建, 组装并启动这些组件; 在服务停止的时候, 我们还需要释放资源, 销毁这些组件, 因此这是一个动态的过程. 也就是说, <strong>Tomcat 需要动态地管理这些组件的生命周期</strong>.</p> <p>如果你需要设计一个比较大的系统或者框架时, 同样也需要考虑这几个问题: **如何统一管理组件的创建, 初始化, 启动, 停止和销毁? 如何做到代码逻辑清晰? 如何方便地添加或者删除组件? 如何做到组件启动和停止不遗漏, 不重复? **</p> <p>下面就来解决上面的问题. 先来看看组件之间的关系, 仔细观测可以发现这些组件具有两层关系.</p> <ul><li><strong>第一层关系是组件有大有小</strong>, 大组件管理小组件, 比如 Server 管理 Service, Service 又管理连接器和容器.</li> <li><strong>第二层关系是组件有外有内</strong>, 外层组件控制内层组件, 比如连接器是外层组件, 负责对外交流, 外层组件调用内层组件完成业务功能. 也就是说, **请求的处理过程是由外层组件来驱动的. **</li></ul> <p>这两层关系决定了系统在创建组件时应该遵循一定的顺序.</p> <ul><li>第一个原则是先创建子组件, 再创建父组件, 子组件需要被&quot;注入&quot;到父组件中.</li> <li>第二个原则是先创建内层组件, 再创建外层组件, 内层组建需要被&quot;注入&quot;到外层组件.</li></ul> <p>因此, 最直观的做法就是将图上所有的组件按照先小后大, 先内后外的顺序创建出来, 然后组装在一起. 不知道你注意到没有, 这个思路其实很有问题! 因为这样不仅会造成代码逻辑混乱和组件遗漏, 而且也不利于后期的功能扩展.</p> <p>为了解决这个问题, 希望找到一种通用的, 统一的方法来管理组件的生命周期, 就像汽车&quot;一键启动&quot;那样的效果.</p> <h5 id="一键式启停-lifecycle接口"><a href="#一键式启停-lifecycle接口" class="header-anchor">#</a> 一键式启停:LifeCycle接口</h5> <p><strong>设计就是要找到系统的变化点和不变点</strong>. 这里的<strong>不变点就是每个组件都要经历创建, 初始化, 启动这几个过程, 这些状态以及状态的转化是不变的</strong>. 而变化点是每个具体组件的初始化方法, 也就是启动方法是不一样的.</p> <p>因此可以把不变点抽象出来成为一个接口, 这个接口跟生命周期有关, 叫作 <strong>LifeCycle</strong>. LifeCycle 接口里应该定义这么几个方法: init(), start(), stop() 和 destroy(), 每个具体的组件去实现这些方法, 做到方法的不一样.</p> <p>理所当然, 在父组件的 init() 方法里需要创建子组件并调用子组件的 init() 方法. 同样, 在父组件的 start() 方法里也需要调用子组件的 start() 方法, 因此调用者可以无差别的调用各组件的 init() 方法和 start() 方法, 这就是<strong>组合模式</strong>的使用, 并且只要调用最顶层组件, 也就是 Server 组件的 init() 和 start() 方法, 整个 Tomcat 就被启动起来了. 下面是 LifeCycle 接口的定义.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Lifecycle</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h5 id="可扩展性-lifecycle事件"><a href="#可扩展性-lifecycle事件" class="header-anchor">#</a> 可扩展性:LifeCycle事件</h5> <p>再来考虑另一个问题, 那就是系统的<strong>可扩展性</strong>. 因为各个组件 init() 和 start() 方法的具体实现是复杂多变的, 比如在 Host 容器的启动方法里需要扫描 webapps 目录下的 Web 应用, 创建相应的 Context 容器, 如果将来需要增加新的逻辑, 直接修改 start() 方法? 这样会违反开闭原则, 那如何解决这个问题呢? 开闭原则说的是为了扩展系统的功能, 不能直接修改系统中已有的类, 但是可以定义新的类.</p> <p>我们注意到, 组件的 init() 和 start() 调用是由它的父组件的状态变化触发的, 上层组件的初始化会触发子组件的初始化, 上层组件的启动会触发子组件的启动, 因此可以把<strong>组件的生命周期定义成一个个状态, 把状态的转变看作是一个事件</strong>. 而事件是有监听器的, 在监听器里可以实现一些逻辑, 并且监听器也可以方便的添加和删除, 这就是典型的<strong>观察者模式</strong>.</p> <p>具体来说就是在 LifeCycle 接口里加入两个方法: <strong>添加监听器和删除监听器</strong>. 除此之外, 还需要定义一个 Enum 来表示<strong>组件有哪些状态</strong>, 以及处在什么状态会触发什么样的事件. 因此 <strong>LifeCycle 接口和 LifeCycleState 枚举</strong>就定义成了下面这样.</p> <p><img src="/img/image-20230405161039-r9xwme8.png" alt=""></p> <p>可以看到组件的生命周期有 NEW, INITIALIZING, INITIALIZED, STARTING_PREP, STARTING, STARTED 等, 而一旦组件到达相应的状态就<strong>触发相应的事件</strong>, 比如 NEW 状态表示组件刚刚被实例化; 而当 init() 方法被调用时, 状态就变成 INITIALIZING 状态, 这个时候就会触发 BEFORE_INIT_EVENT 事件, 如果有监听器在监听这个事件, 它的方法就会被调用.</p> <h5 id="重用性-lifecyclebase抽象基类"><a href="#重用性-lifecyclebase抽象基类" class="header-anchor">#</a> 重用性:LifeCycleBase抽象基类</h5> <p>有了接口就要用类去实现接口. 一般来说实现类不止一个, 不同的类在实现接口时往往会有一些相同的逻辑, 如果让各个子类都去实现一遍, 就会有重复代码. <strong>那子类如何重用这部分逻辑呢? 其实就是定义一个基类来实现共同的逻辑, 然后让各个子类去继承它, 就达到了重用的目的</strong>.</p> <p>**而基类中往往会定义一些抽象方法, 所谓的抽象方法就是说基类不会去实现这些方法, 而是调用这些方法来实现骨架逻辑. 抽象方法是留给各个子类去实现的, 并且子类必须实现, 否则无法实例化. **</p> <p>比如宝马和荣威的底盘和骨架其实是一样的, 只是发动机和内饰等配套是不一样的. 底盘和骨架就是基类, 宝马和荣威就是子类. 仅仅有底盘和骨架还不是一辆真正意义上的车, 只能算是半成品, 因此在底盘和骨架上会留出一些安装接口, 比如安装发动机的接口, 安装座椅的接口, 这些就是抽象方法. 宝马或者荣威上安装的发动机和座椅是不一样的, 也就是具体子类对抽象方法有不同的实现.</p> <p>回到 LifeCycle 接口, <strong>Tomcat 定义了一个基类 LifeCycleBase 来实现 LifeCycle 接口, 把一些公共的逻辑放到基类中去, 比如生命状态的转变与维护, 生命事件的触发以及监听器的添加和删除等, 而子类就负责实现自己的初始化, 启动和停止等方法</strong>. 为了避免跟基类中的方法同名, 这里把具体子类的实现方法改个名字, 在后面加上 Internal, 叫 initInternal(), startInternal() 等. 再来看引入了基类 LifeCycleBase 后的类图:</p> <p><img src="/img/image-20230405161039-vxv9018.png" alt=""></p> <p>从图上可以看到, LifeCycleBase 实现了 LifeCycle 接口中所有的方法, 还定义了相应的抽象方法交给具体子类去实现, 这是典型的<strong>模板设计模式</strong>.</p> <p>还是看一看代码, 下面是 LifeCycleBase 的 init() 方法实现.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">LifecycleException</span> <span class="token punctuation">{</span>
    <span class="token comment">//1. 状态检查</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>state<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">LifecycleState</span><span class="token punctuation">.</span><span class="token constant">NEW</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">invalidTransition</span><span class="token punctuation">(</span><span class="token class-name">Lifecycle</span><span class="token punctuation">.</span><span class="token constant">BEFORE_INIT_EVENT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">//2. 触发 INITIALIZING 事件的监听器</span>
        <span class="token function">setStateInternal</span><span class="token punctuation">(</span><span class="token class-name">LifecycleState</span><span class="token punctuation">.</span><span class="token constant">INITIALIZING</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
        <span class="token comment">//3. 调用具体子类的初始化方法</span>
        <span class="token function">initInternal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
        <span class="token comment">//4. 触发 INITIALIZED 事件的监听器</span>
        <span class="token function">setStateInternal</span><span class="token punctuation">(</span><span class="token class-name">LifecycleState</span><span class="token punctuation">.</span><span class="token constant">INITIALIZED</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>这个方法逻辑比较清楚, 主要完成了四步:</p> <p>第一步, 检查状态的合法性, 比如当前状态必须是 NEW 然后才能进行初始化.</p> <p>第二步, 触发 INITIALIZING 事件的监听器:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">setStateInternal</span><span class="token punctuation">(</span><span class="token class-name">LifecycleState</span><span class="token punctuation">.</span><span class="token constant">INITIALIZING</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在这个 setStateInternal() 方法里, 会调用监听器的业务方法.</p> <p>第三步, 调用具体子类实现的抽象方法 initInternal() 方法. 前面提到过, 为了实现一键式启动, 具体组件在实现 initInternal() 方法时, 又会<strong>调用它的子组件的 init() 方法</strong>.</p> <p>第四步, 子组件初始化后, 触发 INITIALIZED 事件的监听器, 相应监听器的业务方法就会被调用.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">setStateInternal</span><span class="token punctuation">(</span><span class="token class-name">LifecycleState</span><span class="token punctuation">.</span><span class="token constant">INITIALIZED</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>总之, <strong>LifeCycleBase 调用了抽象方法来实现骨架逻辑</strong>.</p> <p>既然 LifeCycleBase 负责触发事件, 并调用监听器的方法, 那是什么时候, 谁把监听器注册进来的呢?</p> <p>分为两种情况:</p> <ul><li><strong>Tomcat 自定义了一些监听器</strong>, 这些监听器是父组件在创建子组件的过程中注册到子组件的. 比如 MemoryLeakTrackingListener 监听器, 用来检测 Context 容器中的内存泄漏, 这个监听器是 Host 容器在创建 Context 容器时注册到 Context 中的.</li> <li>还可以在 server.xml 中定义自己的监听器, Tomcat 在启动时会解析 server.xml, 创建监听器并注册到容器组件.</li></ul> <h5 id="生周期管理总体类图"><a href="#生周期管理总体类图" class="header-anchor">#</a> 生周期管理总体类图</h5> <p>总结一下 Tomcat 组件的生命周期的管理, 再来看一张总体类图继续加深印象.</p> <p><img src="/img/image-20230405161039-ucf2yi3.png" alt=""></p> <p>注意, 图中的 <strong>StandardServer, StandardService</strong> 等是 Server 和 Service 组件的<strong>具体实现类</strong>, 它们都继承了 LifeCycleBase 类.</p> <p><strong>StandardEngine, StandardHost, StandardContext 和 StandardWrapper</strong> 是相应容器组件的具体实现类, 因为它们都是容器, 所以继承了 ContainerBase 抽象基类, 而 ContainerBase 实现了 Container 接口, 也继承了 LifeCycleBase 类, 它们的生命周期管理接口和功能接口是分开的, 这也符合设计中<strong>接口分离的原则</strong>.</p> <p>Tomcat 为了实现一键式启停以及优雅的生命周期管理, 并考虑到了可扩展性和可重用性, 将面向对象思想和设计模式发挥到了极致, 分别运用了<strong>组合模式, 观察者模式, 骨架抽象类和模板方法</strong>. 如果你需要维护一堆具有父子关系的实体, 可以考虑使用组合模式. 观察者模式听起来“高大上”, 其实就是当一个事件发生后, 需要执行一连串更新操作. 传统的实现方式是在事件响应代码里直接加更新逻辑, 当更新逻辑加多了之后, 代码会变得臃肿, 并且这种方式是紧耦合的, 侵入式的. 而观察者模式实现了低耦合, 非侵入式的通知与更新机制. 而模板方法在抽象基类中经常用到, 用来实现通用逻辑.</p> <h4 id="_8-tomcat的-高层们-都负责做什么"><a href="#_8-tomcat的-高层们-都负责做什么" class="header-anchor">#</a> 8.Tomcat的&quot;高层们&quot;都负责做什么?</h4> <p>通过 Tomcat 的 /bin 目录下的脚本 startup.sh 可以启动 Tomcat, 执行了这个脚本后发生了什么? 可以通过下面这张流程图来了解一下.</p> <p><img src="/img/image-20230405161100-ut6smnd.png" alt=""></p> <p>1.Tomcat 本质上是一个 Java 程序, 因此 startup.sh 脚本会<strong>启动一个 JVM 来运行 Tomcat 的启动类 Bootstrap</strong>.</p> <p>2.Bootstrap 的主要任务是<strong>初始化 Tomcat 的类加载器, 并且创建 Catalina</strong>. 关于 Tomcat 为什么需要自己的类加载器, 后面会详细介绍.</p> <p>3.<strong>Catalina 是一个启动类, 它通过解析 server.xml, 创建相应的组件, 并调用 Server 的 start() 方法</strong>.</p> <p>4.Server 组件的职责就是<strong>管理 Service 组件, 它会负责调用 Service 的 start() 方法</strong>.</p> <p>5.Service 组件的职责就是<strong>管理连接器和顶层容器 Engine, 因此它会调用连接器和 Engine 的 start() 方法</strong>.</p> <p>这样 Tomcat 的启动就算完成了. 下面详细介绍一下上面这个启动过程中提到的几个非常关键的启动类和组件.</p> <p>可以把 Bootstrap 看作是上帝, 它初始化了类加载器, 也就是创造万物的工具.</p> <p>如果把 Tomcat 比作是一家公司, 那么 Catalina 应该是公司创始人, 因为 Catalina 负责组建团队, 也就是创建 Server 以及它的子组件.</p> <p>Server 是公司的 CEO, 负责管理多个事业群, 每个事业群就是一个 Service.</p> <p>Service 是事业群总经理, 它管理两个职能部门: 一个是对外的市场部, 也就是连接器组件; 另一个是对内的研发部, 也就是容器组件.</p> <p>Engine 则是研发部经理, 因为 Engine 是最顶层的容器组件.</p> <p>可以看到<strong>这些启动类或者组件不处理具体请求</strong>, 它们的任务主要是&quot;管理&quot;, <strong>管理下层组件的生命周期, 并且给下层组件分配任务, 也就是把请求路由到负责&quot;干活儿&quot;的组件. 因此把它们比作 Tomcat 的&quot;高层&quot;</strong> .</p> <p>下面来看看这些 <strong>&quot;高层&quot;</strong> 的实现细节, 进而逐步理解 Tomcat 的工作原理. 另一方面, 软件系统中往往都有一些起管理作用的组件, 可以学习和借鉴 Tomcat 是如何实现这些组件的.</p> <h5 id="catalina"><a href="#catalina" class="header-anchor">#</a> Catalina</h5> <p>Catalina 的主要任务就是<strong>创建 Server</strong>, 它不是直接 new 一个 Server 实例就完事了, 而是需要解析 server.xml, 把在 server.xml 里配置的各种组件一一创建出来, 接着调用 Server 组件的 init() 方法和 start() 方法, 这样整个 Tomcat 就启动起来了. 作为&quot;管理者&quot;, Catalina 还需要处理各种&quot;异常&quot;情况, 比如当通过 &quot;Ctrl + C&quot; 关闭 Tomcat 时, Tomcat 将如何优雅的停止并且清理资源呢? 因此 Catalina 在 JVM 中注册一个 &quot;关闭钩子&quot;.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//1. 如果持有的 Server 实例为空, 就解析 server.xml 创建出来</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//2. 如果创建失败, 报错退出</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">fatal</span><span class="token punctuation">(</span>sm<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">&quot;catalina.noServer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">//3. 启动 Server</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">getServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">LifecycleException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">// 创建并注册关闭钩子</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>useShutdownHook<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>shutdownHook <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            shutdownHook <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CatalinaShutdownHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addShutdownHook</span><span class="token punctuation">(</span>shutdownHook<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">// 用 await 方法监听停止请求</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>await<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>什么是&quot;关闭钩子&quot;? 如果需要在 <strong>JVM 关闭时做一些清理工作</strong>, 比如将缓存数据刷到磁盘上, 或者清理一些临时文件, 可以向 JVM 注册一个&quot;关闭钩子&quot;. &quot;关闭钩子&quot; 其实就是一个线程, JVM 在停止之前会尝试执行这个线程的 run() 方法. 下面来看看 Tomcat 的 &quot;关闭钩子&quot; CatalinaShutdownHook 做了些什么.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">class</span> <span class="token class-name">CatalinaShutdownHook</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
 
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Catalina</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>可以看出 Tomcat 的  <strong>&quot;关闭钩子&quot; 实际上就执行了 Server 的 stop() 方法, Server 的 stop() 方法会释放和清理所有的资源</strong>.</p> <h5 id="server组件"><a href="#server组件" class="header-anchor">#</a> Server组件</h5> <p>Server 组件的具体实现类是 <strong>StandardServer</strong>, 来看下 StandardServer 具体实现了哪些功能. Server 继承了 <strong>LifeCycleBase</strong>, 它的生命周期被统一管理, 并且它的子组件是 Service, 因此它还需要管理 Service 的生命周期, 也就是说在启动时调用 Service 组件的启动方法, 在停止时调用它们的停止方法. <strong>Server 在内部维护了若干 Service 组件</strong>, 它是以数组来保存的, 那 Server 是如何添加一个 Service 到数组中的呢?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addService</span><span class="token punctuation">(</span><span class="token class-name">Service</span> service<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
    service<span class="token punctuation">.</span><span class="token function">setServer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>servicesLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个长度 +1 的新数组</span>
        <span class="token class-name">Service</span> results<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Service</span><span class="token punctuation">[</span>services<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  
        <span class="token comment">// 将老的数据复制过去</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>services<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> results<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> services<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        results<span class="token punctuation">[</span>services<span class="token punctuation">.</span>length<span class="token punctuation">]</span> <span class="token operator">=</span> service<span class="token punctuation">;</span>
        services <span class="token operator">=</span> results<span class="token punctuation">;</span>
 
        <span class="token comment">// 启动 Service 组件</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isAvailable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                service<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">LifecycleException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// Ignore</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
 
        <span class="token comment">// 触发监听事件</span>
        support<span class="token punctuation">.</span><span class="token function">firePropertyChange</span><span class="token punctuation">(</span><span class="token string">&quot;service&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> service<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>从上面的代码可以看出, 它并没有一开始就分配一个很长的数组, 而是<strong>在添加的过程中动态地扩展数组长度</strong>, 当添加一个新的 Service 实例时, 会<strong>创建一个新数组并把原来数组内容复制到新数组</strong>, 这样做的目的其实是为了节省内存空间.</p> <p>除此之外, Server 组件还有一个重要的任务是启动一个 Socket 来监听停止端口, 这就是为什么你能通过 shutdown 命令来关闭 Tomcat. 不知道你留意到没有, 上面 Caralina 的启动方法的最后一行代码就是调用了 Server 的 await() 方法. 在 await() 方法里会创建一个 Socket 监听 8005 端口, 并在一个死循环里<strong>接收 Socket 上的连接请求</strong>, 如果有新的连接到来就建立连接, 然后从 Socket 中读取数据; 如果读到的数据是停止命令 &quot;SHUTDOWN&quot;, 就退出循环, 进入 stop 流程.</p> <h5 id="service组件"><a href="#service组件" class="header-anchor">#</a> Service组件</h5> <p>Service 组件的具体实现类是 <strong>StandardService</strong>, 先来看看它的定义以及关键的成员变量.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StandardService</span> <span class="token keyword">extends</span> <span class="token class-name">LifecycleBase</span> <span class="token keyword">implements</span> <span class="token class-name">Service</span> <span class="token punctuation">{</span>
    <span class="token comment">// 名字</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  
    <span class="token comment">//Server 实例</span>
    <span class="token keyword">private</span> <span class="token class-name">Server</span> server <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
 
    <span class="token comment">// 连接器数组</span>
    <span class="token keyword">protected</span> <span class="token class-name">Connector</span> connectors<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Connector</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> connectorsLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment">// 对应的 Engine 容器</span>
    <span class="token keyword">private</span> <span class="token class-name">Engine</span> engine <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 映射器及其监听器</span>
    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">Mapper</span> mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">MapperListener</span> mapperListener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MapperListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>StandardService 继承了 LifecycleBase 抽象类, 此外 StandardService 中还有一些熟悉的组件, 比如 Server, Connector, Engine 和 Mapper.</p> <p>那为什么还有一个 <strong>MapperListener</strong>? 这是因为 Tomcat 支持热部署, 当 Web 应用的部署发生变化时, Mapper 中的映射信息也要跟着变化, <strong>MapperListener 就是一个监听器, 它监听容器的变化, 并把信息更新到 Mapper 中, 这是典型的观察者模式</strong>.</p> <p><strong>作为&quot;管理&quot;角色的组件, 最重要的是维护其他组件的生命周期</strong>. 此外在启动各种组件时, 要注意它们的依赖关系, 也就是说, 要注意启动的顺序. 来看看 Service 启动方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">startInternal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">LifecycleException</span> <span class="token punctuation">{</span>
 
    <span class="token comment">//1. 触发启动监听器</span>
    <span class="token function">setState</span><span class="token punctuation">(</span><span class="token class-name">LifecycleState</span><span class="token punctuation">.</span><span class="token constant">STARTING</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment">//2. 先启动 Engine, Engine 会启动它子容器</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>engine <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>engine<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            engine<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  
    <span class="token comment">//3. 再启动 Mapper 监听器</span>
    mapperListener<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment">//4. 最后启动连接器, 连接器会启动它子组件, 比如 Endpoint</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>connectorsLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Connector</span> connector<span class="token operator">:</span> connectors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>connector<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token class-name">LifecycleState</span><span class="token punctuation">.</span><span class="token constant">FAILED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                connector<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>从启动方法可以看到, Service 先启动了 Engine 组件, 再启动 Mapper 监听器, 最后才是启动连接器. 这很好理解, 因为<strong>内层组件启动好了才能对外提供服务, 才能启动外层的连接器组件</strong>. 而 Mapper 也依赖容器组件, 容器组件启动好了才能监听它们的变化, 因此 Mapper 和 MapperListener 在容器组件之后启动. 组件停止的顺序跟启动顺序正好相反的, 也是基于它们的依赖关系.</p> <h5 id="engine组件"><a href="#engine组件" class="header-anchor">#</a> Engine组件</h5> <p>最后再来看看顶层的容器组件 Engine 具体是如何实现的. Engine 本质是一个<strong>容器</strong>, 因此它继承了 ContainerBase 基类, 并且实现了 Engine 接口.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StandardEngine</span> <span class="token keyword">extends</span> <span class="token class-name">ContainerBase</span> <span class="token keyword">implements</span> <span class="token class-name">Engine</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Engine 的子容器是 Host, 所以<strong>它持有了一个 Host 容器的数组</strong>, 这些功能都被抽象到了 ContainerBase 中, ContainerBase 中有这样一个数据结构:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Container</span><span class="token punctuation">&gt;</span></span> children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>ContainerBase 用 HashMap 保存了它的子容器, 并且 ContainerBase 还实现了子容器的&quot;增删改查&quot;, 甚至连子组件的启动和停止都提供了默认实现, 比如 ContainerBase 会用专门的线程池来启动子容器.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   results<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>startStopExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StartChild</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>所以 Engine 在启动 Host 子容器时就直接重用了这个方法.</p> <p>那 Engine 自己做了什么呢? 由于容器组件最重要的功能是处理请求, 而 Engine 容器对请求的 &quot;处理&quot;, 其实就是把请求<strong>转发</strong>给某一个 Host 子容器来处理, 具体是<strong>通过 Valve 来实现</strong>的.</p> <p>每一个容器组件都有一个 <strong>Pipeline</strong>, 而 Pipeline 中有一个<strong>基础阀(Basic Valve)</strong> , 而 Engine 容器的基础阀定义如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">StandardEngineValve</span> <span class="token keyword">extends</span> <span class="token class-name">ValveBase</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Request</span> request<span class="token punctuation">,</span> <span class="token class-name">Response</span> response<span class="token punctuation">)</span>
      <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>
  
      <span class="token comment">// 拿到请求中的 Host 容器</span>
      <span class="token class-name">Host</span> host <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>host <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  
      <span class="token comment">// 调用 Host 容器中的 Pipeline 中的第一个 Valve</span>
      host<span class="token punctuation">.</span><span class="token function">getPipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><strong>这个基础阀实现非常简单, 就是把请求转发到 Host 容器</strong>. 从代码中可以看到, 处理请求的 Host 容器对象是从请求中拿到的, 请求对象中怎么会有 Host 容器呢? 这是因为<strong>请求到达 Engine 容器中之前, Mapper 组件已经对请求进行了路由处理, Mapper 组件通过请求的 URL 定位了相应的容器, 并且把容器对象保存到了请求对象中</strong>.</p> <p>总结 Tomcat 的设计, 当在设计组件时, 需要考虑两个方面:</p> <ul><li><p>首先要选用合适的数据结构来保存子组件, 比如 Server 用数组来保存 Service 组件, 并且采取动态扩容的方式, 这是因为数组结构简单, 占用内存小; 再比如 ContainerBase 用 HashMap 来保存子容器, 虽然 Map 占用内存会多一点, 但是可以通过 Map 来快速的查找子容器. 因此在实际的工作中, 也需要根据具体的场景和需求来选用合适的数据结构.</p></li> <li><p>其次还需要根据子组件依赖关系来决定它们的启动和停止顺序, 以及如何优雅的停止, 防止异常情况下的资源泄漏. 这正是 &quot;管理者&quot; 应该考虑的事情.</p></li></ul> <h4 id="_9-jetty基础架构分析"><a href="#_9-jetty基础架构分析" class="header-anchor">#</a> 9.Jetty基础架构分析</h4> <p>Servlet 容器并非只有 Tomcat 一家, 还有别的架构设计思路吗? 下面看看 Jetty 的设计特点.</p> <p>和 Tomcat 一样, Jetty 也是一个 &quot;HTTP 服务器 + Servlet 容器&quot;, 并且 Jetty 和 Tomcat 在架构设计上有不少相似的地方. 但同时 Jetty 也有自己的特点, 主要是更加小巧, 更易于定制化. Jetty 作为一名后起之秀, 应用范围也越来越广, 比如 Google App Engine 就采用了 Jetty 来作为 Web 容器. Jetty 和 Tomcat 各有特点, 这里重点看看 Jetty 在哪些地方跟 Tomcat 不同. 通过比较它们的差异, 可以继续加深对 Web 容器架构设计的理解, 另一方面也更清楚它们的设计区别, 并根据它们的特点来选用这两款 Web 容器.</p> <h5 id="jetty整体架构"><a href="#jetty整体架构" class="header-anchor">#</a> Jetty整体架构</h5> <p>简单来说, Jetty Server 就是由多个 <strong>Connector</strong>(连接器), 多个 <strong>Handler</strong>(处理器), 以及一个线程池组成. 整体结构如下图.</p> <p><img src="/img/image-20230405161119-s1sa5ui.jpg" alt=""></p> <p>跟 Tomcat 一样, <strong>Jetty 也有 HTTP 服务器和 Servlet 容器的功能, 因此 Jetty 中的 Connector 组件和 Handler 组件分别来实现这两个功能, 而这两个组件工作时所需要的线程资源都直接从一个全局线程池 ThreadPool 中获取</strong>.</p> <p><strong>Jetty Server 可以有多个 Connector 在不同的端口上监听客户请求, 而对于请求处理的 Handler 组件, 也可以根据具体场景使用不同的 Handler</strong>. 这样的设计提高了 Jetty 的灵活性, 需要支持 Servlet, 则可以使用 ServletHandler; 需要支持 Session, 则再增加一个 SessionHandler. 也就是说可以不使用 Servlet 或 Session, 只要不配置这个 Handler 就行了.</p> <p>为了启动和协调上面的核心组件工作, Jetty 提供了一个 <strong>Server</strong> 类来做这个事情, 它负责创建并初始化 Connector, Handler, ThreadPool 组件, 然后调用 start 方法启动它们.</p> <p>对比一下 Tomcat 的整体架构图, 可以发现 Tomcat 在整体上跟 Jetty 很相似, 但也有一些区别.</p> <p><strong>它们的第一个区别</strong>是 Jetty 中没有 Service 的概念, Tomcat 中的 Service 包装了多个连接器和一个容器组件, 一个 Tomcat 实例可以配置多个 Service, 不同的 Service 通过不同的连接器监听不同的端口; 而 Jetty 中 <strong>Connector 是被所有 Handler 共享的</strong>.</p> <p><img src="/img/image-20230405161119-ftahlji.jpg" alt=""></p> <p><strong>它们的第二个区别</strong>是, 在 Tomcat 中每个连接器都有自己的线程池, 而在 Jetty 中<strong>所有的 Connector 共享一个全局的线程池</strong>.</p> <h5 id="connector组件"><a href="#connector组件" class="header-anchor">#</a> Connector组件</h5> <p>跟 Tomcat 一样, Connector 的主要功能是对 I/O 模型和应用层协议的封装. I/O 模型方面, 最新的 Jetty 9 版本只支持 NIO, 因此 Jetty 的 Connector 设计有明显的 Java NIO 通信模型的痕迹. 至于应用层协议方面, 跟 Tomcat 的 Processor 一样, Jetty 抽象出了 Connection 组件来封装应用层协议的差异.</p> <p>Java NIO 早已成为程序员的必备技能, 接下来看看 Jetty 是如何实现 NIO 模型的, 以及它是怎么**用 ** Java NIO 的.</p> <p>Java NIO 的核心组件是 Channel, Buffer 和 Selector.</p> <ul><li><p>Channel 表示一个连接, 可以理解为一个 Socket, 通过它可以读取和写入数据, 但是并不能直接操作数据, 需要通过 Buffer 来中转.</p></li> <li><p>Selector 可以用来检测 Channel 上的 I/O 事件, 比如读就绪, 写就绪, 连接就绪, 一个 Selector 可以同时处理多个 Channel, 因此单个线程可以监听多个 Channel, 这样会大量减少线程上下文切换的开销.</p></li></ul> <p>下面通过一个典型的服务端 NIO 程序来回顾一下如何使用这些组件.</p> <p>首先, 创建服务端 Channel, 绑定监听端口并把 Channel 设置为非阻塞方式.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ServerSocketChannel</span> server <span class="token operator">=</span> <span class="token class-name">ServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>然后, 创建 Selector, 并在 Selector 中注册 Channel 感兴趣的事件 OP_ACCEPT, 告诉 Selector 如果客户端有新的连接请求到这个端口就通知我.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Selector</span> selector <span class="token operator">=</span> <span class="token class-name">Selector</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_ACCEPT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>接下来, Selector 会在一个<strong>死循环</strong>里不断地调用 select() 去查询 I/O 状态, select() 会返回一个 SelectionKey 列表, Selector 会遍历这个列表, 看看是否有 &quot;客户&quot; 感兴趣的事件, 如果有, 就采取相应的动作.</p> <p>比如下面这个例子, 如果有新的连接请求, 就会建立一个新的连接. 连接建立后, 再注册 Channel 的可读事件到 Selector 中, 告诉 Selector 我对这个 Channel 上是否有新的数据到达感兴趣.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 查询 I/O 事件</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">&gt;</span></span> i <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token class-name">SelectionKey</span> key <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        i<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token comment">// 建立一个新连接 </span>
            <span class="token class-name">SocketChannel</span> client <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            client<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
      
            <span class="token comment">// 连接建立后, 告诉 Selector, 我现在对 I/O 可读事件感兴趣</span>
            client<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_READ</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>简单回顾完服务端 NIO 编程之后, 你会发现服务端在 I/O 通信上主要完成了三件事情: <strong>监听连接, I/O 事件查询以及数据读写</strong>. 因此 Jetty 设计了 <strong>Acceptor, SelectorManager 和 Connection 来分别做这三件事情</strong>, 下面分别来说说这三个组件.</p> <h6 id="_1-acceptor"><a href="#_1-acceptor" class="header-anchor">#</a> 1.Acceptor</h6> <p>顾名思义, Acceptor 用于<strong>接受请求</strong>, 跟 Tomcat 一样, Jetty 也有独立的 Acceptor 线程组用于处理连接请求. 在 Connector 的实现类 ServerConnector 中, 有一个 <code>_acceptors</code>​ 的数组, 在 Connector 启动的时候, 会根据<code>_acceptors</code>​ 数组的长度创建对应数量的 Acceptor, 而 Acceptor 的个数可以配置.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _acceptors<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Acceptor</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Acceptor</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">getExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Acceptor 是 ServerConnector 中的一个内部类, 同时也是一个 Runnable, Acceptor 线程是通过 getExecutor() 得到的线程池来执行的, 前面提到这是一个全局的线程池.</p> <p>Acceptor 通过阻塞的方式来接受连接, 这一点跟 Tomcat 也是一样的.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">int</span> acceptorID<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
  <span class="token class-name">ServerSocketChannel</span> serverChannel <span class="token operator">=</span> _acceptChannel<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>serverChannel <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> serverChannel<span class="token punctuation">.</span><span class="token function">isOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里是阻塞的</span>
    <span class="token class-name">SocketChannel</span> channel <span class="token operator">=</span> serverChannel<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 执行到这里时说明有请求进来了</span>
    <span class="token function">accepted</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>接受连接成功后会调用 accepted() 函数, accepted() 函数中会将 SocketChannel 设置为非阻塞模式, 然后交给 Selector 去处理, 因此这也就到了 Selector 的地界了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">accepted</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> channel<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    channel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Socket</span> socket <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">configure</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// _manager 是 SelectorManager 实例, 里面管理了所有的 Selector 实例</span>
    _manager<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h6 id="_2-selectormanager"><a href="#_2-selectormanager" class="header-anchor">#</a> 2.SelectorManager</h6> <p>Jetty 的 Selector 由 SelectorManager 类管理, 而被管理的 Selector 叫作 ManagedSelector. SelectorManager 内部有一个 ManagedSelector 数组, <strong>真正干活的是 ManagedSelector</strong>. 咱们接着上面分析, 看看在 SelectorManager 在 accept 方法里做了什么.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token class-name">SelectableChannel</span> channel<span class="token punctuation">,</span> <span class="token class-name">Object</span> attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 选择一个 ManagedSelector 来处理 Channel</span>
  <span class="token keyword">final</span> <span class="token class-name">ManagedSelector</span> selector <span class="token operator">=</span> <span class="token function">chooseSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 提交一个任务 Accept 给 ManagedSelector</span>
  selector<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>selector<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Accept</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> attachment<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>SelectorManager 从本身的 Selector 数组中选择一个 Selector 来处理这个 Channel, 并创建一个任务 Accept 交给 ManagedSelector, ManagedSelector 在处理这个任务主要做了两步:</p> <p>第一步, 调用 Selector 的 register 方法把 Channel <strong>注册到 Selector</strong> 上, 拿到一个 SelectionKey.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code> _key <span class="token operator">=</span> _channel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_ACCEPT</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>第二步, 创建一个 EndPoint 和 Connection, 并跟这个 SelectionKey(Channel)绑在一起:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">createEndPoint</span><span class="token punctuation">(</span><span class="token class-name">SelectableChannel</span> channel<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span> selectionKey<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1. 创建 Endpoint</span>
    <span class="token class-name">EndPoint</span> endPoint <span class="token operator">=</span> _selectorManager<span class="token punctuation">.</span><span class="token function">newEndPoint</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> selectionKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 2. 创建 Connection</span>
    <span class="token class-name">Connection</span> connection <span class="token operator">=</span> _selectorManager<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> endPoint<span class="token punctuation">,</span> selectionKey<span class="token punctuation">.</span><span class="token function">attachment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 3. 把 Endpoint, Connection 和 SelectionKey 绑在一起</span>
    endPoint<span class="token punctuation">.</span><span class="token function">setConnection</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>
    selectionKey<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>endPoint<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>上面这两个过程是什么意思呢? 打个比方, 你到餐厅吃饭, 先点菜(注册 I/O 事件), 服务员(ManagedSelector)给你一个单子(SelectionKey), 等菜做好了(I/O 事件到了), 服务员根据单子就知道是哪桌点了这个菜, 于是喊一嗓子某某桌的菜做好了(调用了绑定在 SelectionKey 上的 EndPoint 的方法).</p> <p>这里需要你特别注意的是, ManagedSelector 并没有调用直接 EndPoint 的方法去处理数据, 而是通过调用 EndPoint 的方法<strong>返回一个 Runnable, 然后把这个 Runnable 扔给线程池执行</strong>, 所以你能猜到, 这个 Runnable 才会去真正读数据和处理请求.</p> <h6 id="_3-connection"><a href="#_3-connection" class="header-anchor">#</a> 3.Connection</h6> <p>这个 Runnable 是 EndPoint 的一个内部类, 它会调用 Connection 的<strong>回调方法来处理请求</strong>. Jetty 的 Connection 组件类比就是 Tomcat 的 Processor, 负责具体协议的解析, 得到 Request 对象, 并调用 Handler 容器进行处理. 下面简单介绍一下它的具体实现类 HttpConnection 对请求和响应的处理过程.</p> <p><strong>请求处理</strong>: HttpConnection 并不会主动向 EndPoint 读取数据, 而是向在 EndPoint 中注册一堆回调方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">getEndPoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fillInterested</span><span class="token punctuation">(</span>_readCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这段代码就是告诉 EndPoint, 数据到了就调这些回调方法 _readCallback() 吧, 有点异步 I/O 的感觉, 也就是说 Jetty 在<strong>应用层面模拟了异步 I/O 模型</strong>.</p> <p>而在回调方法 _readCallback() 里, 会调用 EndPoint 的接口去读数据, 读完后让 HTTP 解析器去解析字节流, HTTP 解析器会将解析后的数据, 包括请求行, 请求头相关信息存到 Request 对象里.</p> <p><strong>响应处理</strong>: Connection 调用 Handler 进行业务处理, Handler 会通过 Response 对象来操作响应流, 向流里面写入数据, HttpConnection 再通过 EndPoint 把数据写到 Channel, 这样一次响应就完成了.</p> <p>到此应该了解了 Connector 的工作原理, 下面画张图再来回顾一下 Connector 的工作流程.</p> <p><img src="/img/image-20230405161119-eg06rkc.jpg" alt=""></p> <p>1.Acceptor 监听连接请求, 当有连接请求到达时就接受连接, 一个连接对应一个 Channel, Acceptor 将 Channel 交给 ManagedSelector 来处理.</p> <p>2.ManagedSelector 把 Channel 注册到 Selector 上, 并创建一个 EndPoint 和 Connection 跟这个 Channel 绑定, 接着就不断地检测 I/O 事件.</p> <p>3.I/O 事件到了就调用 EndPoint 的方法拿到一个 Runnable, 并扔给线程池执行.</p> <p>4.线程池中调度某个线程执行 Runnable.</p> <p>5.Runnable 执行时, 调用回调函数, 这个回调函数是 Connection 注册到 EndPoint 中的.</p> <p>6.回调函数内部实现, 其实就是调用 EndPoint 的接口方法来读数据.</p> <p>7.Connection 解析读到的数据, 生成请求对象并交给 Handler 组件去处理.</p> <h6 id="_4-总结"><a href="#_4-总结" class="header-anchor">#</a> 4.总结</h6> <p>Jetty Server 就是由多个 Connector, 多个 Handler, 以及一个线程池组成, 在设计上简洁明了.</p> <p>Jetty 的 Connector 只支持 NIO 模型, 跟 Tomcat 的 NioEndpoint 组件一样, 它也是通过 Java 的 NIO API 实现的. 我们知道, Java NIO 编程有三个关键组件: Channel, Buffer 和 Selector, 而核心是 Selector. 为了方便使用, Jetty 在原生 Selector 组件的基础上做了一些封装, 实现了 ManagedSelector 组件.</p> <p>在线程模型设计上 Tomcat 的 NioEndpoint 跟 Jetty 的 Connector 是相似的, 都是用一个 Acceptor 数组监听连接, 用一个 Selector 数组侦测 I/O 事件, 用一个线程池执行请求. 它们的不同点在于, Jetty 使用了一个全局的线程池, 所有的线程资源都是从线程池来分配.</p> <p>Jetty Connector 设计中的一大特点是, 使用了回调函数来模拟异步 I/O, 比如 Connection 向 EndPoint 注册了一堆回调函数. 它的本质<strong>将函数当作一个参数来传递</strong>, 告诉对方, 你准备好了就调这个回调函数.</p> <h5 id="handler组件"><a href="#handler组件" class="header-anchor">#</a> Handler组件</h5> <p>前面了 Jetty 的整体架构. 先来回顾一下, Jetty 就是由多个 Connector(连接器), 多个 Handler(处理器), 以及一个线程池组成, 整体结构图如下.</p> <p><img src="/img/image-20230405161141-6ge7pa7.png" alt=""></p> <p>前面分析了 Jetty Connector 组件的设计, <strong>Connector 会将 Servlet 请求交给 Handler 去处理</strong>, 那 Handler 又是如何处理请求的呢?</p> <p><strong>Jetty 的 Handler 在设计上非常有意思, 可以说是 Jetty 的灵魂, Jetty 通过 Handler 实现了高度可定制化</strong>.</p> <h6 id="_1-handler是什么"><a href="#_1-handler是什么" class="header-anchor">#</a> 1.Handler是什么</h6> <p><strong>Handler 就是一个接口, 它有一堆实现类</strong>, Jetty 的 Connector 组件调用这些接口来处理 Servlet 请求, 先来看看这个接口的定义.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Handler</span> <span class="token keyword">extends</span> <span class="token class-name">LifeCycle</span><span class="token punctuation">,</span> <span class="token class-name">Destroyable</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理请求的方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">String</span> target<span class="token punctuation">,</span> <span class="token class-name">Request</span> baseRequest<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 每个 Handler 都关联一个 Server 组件, 被 Server 管理</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setServer</span><span class="token punctuation">(</span><span class="token class-name">Server</span> server<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Server</span> <span class="token function">getServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment">// 销毁方法相关的资源</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>可以看到 Handler 接口的定义非常简洁, 主要就是<strong>用 handle() 方法用来处理请求</strong>, 跟 Tomcat 容器组件的 service() 方法一样, 它有 ServletRequest 和 ServeletResponse 两个参数. 除此之外, 这个接口中还有 setServer() 和 getServer() 方法, 因为任何一个 Handler 都需要关联一个 Server 组件, 也就是说 Handler 需要被 Server 组件来管理. 一般来说 Handler 会加载一些资源到内存, 因此通过设置 destroy() 方法来销毁.</p> <blockquote><p>Handler继承关系</p></blockquote> <p>Handler 只是一个接口, 完成具体功能的还是它的子类. 那么 Handler 有哪些子类? 它们的继承关系又是怎样的? 这些子类是如何实现 Servlet 容器功能的?</p> <p>Jetty 中定义了一些<strong>默认 Handler 类</strong>, 并且这些 Handler 类之间的继承关系比较复杂, 先通过一个全景图来了解一下(已经简化).</p> <p><img src="/img/image-20230405161141-na7x260.png" alt=""></p> <p>从图上可以看到, Handler 的种类和层次关系还是比较复杂的:</p> <p>Handler 接口之下有抽象类 <strong>AbstractHandler</strong>, 这一点并不意外, 因为有接口一般就有抽象实现类.</p> <p>在 AbstractHandler 之下有 <strong>AbstractHandlerContainer</strong>, 为什么需要这个类呢? 这其实是个过渡, <strong>为了实现链式调用, 一个 Handler 内部必然要有其他 Handler 的引用, 所以这个类的名字里才有 Container, 意思就是这样的 Handler 里包含了其他 Handler 的引用</strong>.</p> <p>理解了上面的 AbstractHandlerContainer, 就能理解它的两个子类了: <strong>HandlerWrapper</strong> 和 <strong>HandlerCollection</strong>. 简单来说就是, HandlerWrapper 和 HandlerCollection 都是 Handler, 但是这些 Handler 里还包括其他 Handler 的引用. 不同的是, HandlerWrapper 只包含一个其他 Handler 的引用, 而 HandlerCollection 中有一个 Handler 数组的引用.</p> <p><img src="/img/image-20230405161141-j4aue1d.png" alt=""></p> <p>接着来看左边的 <strong>HandlerWrapper</strong>, 它有两个子类: <strong>Server 和 ScopedHandler</strong>.</p> <p>Server 比较好理解, 它本身是 Handler 模块的入口, 必然要将请求传递给其他 Handler 来处理, 为了触发其他 Handler 的调用, 所以它是一个 HandlerWrapper.</p> <p>再看 ScopedHandler, 它也是一个比较重要的 Handler, 实现了 &quot;具有上下文信息&quot; 的责任链调用. 为什么要强调 &quot;具有上下文信息&quot; 呢? 那是因为 Servlet 规范规定 Servlet 在执行过程中是有上下文的. 那么这些 Handler 在执行过程中如何访问这个上下文呢? 这个上下文又存在什么地方呢? 答案就是通过 <strong>ScopedHandler</strong> 来实现的.</p> <p><strong>而 ScopedHandler 有一堆的子类, 这些子类就是用来实现 Servlet 规范的</strong>, 比如 ServletHandler, ContextHandler, SessionHandler, ServletContextHandler 和 WebAppContext.</p> <p>再看类图的右边, 跟 HandlerWapper 对等的还有 <strong>HandlerCollection</strong>, HandlerCollection 其实维护了一个 Handler 数组. 你可能会问, 为什么要发明一个这样的 Handler? 这是因为 <strong>Jetty 可能需要同时支持多个 Web 应用</strong>, 如果每个 Web 应用有一个 Handler 入口, 那么多个 Web 应用的 Handler 就成了一个数组, 比如 Server 中就有一个 HandlerCollection, Server 会<strong>根据用户请求的 URL 从数组中选取相应的 Handler 来处理, 就是选择特定的 Web 应用来处理请求</strong>.</p> <blockquote><p>Handler的类型</p></blockquote> <p>虽然从类图上看 Handler 有很多, 但是本质上这些 Handler 分成三种类型:</p> <ul><li>第一种是<strong>协调 Handler</strong>, 这种 Handler 负责将<strong>请求路由</strong>到一组 Handler 中去, 比如上图中的 HandlerCollection, 它内部持有一个 Handler 数组, 当请求到来时, 它负责将请求转发到数组中的某一个 Handler.</li> <li>第二种是<strong>过滤器 Handler</strong>, 这种 Handler 自己会<strong>处理请求</strong>, 处理完了后再把请求转发到下一个 Handler, 比如图上的 HandlerWrapper, 它内部持有下一个 Handler 的引用. 需要注意的是, 所有继承了 HandlerWrapper 的 Handler 都具有了过滤器 Handler 的特征, 比如 ContextHandler, SessionHandler 和 WebAppContext 等.</li> <li>第三种是<strong>内容 Handler</strong>, 说白了就是这些 Handler 会<strong>真正调用 Servlet 来处理请求</strong>, 生成响应的内容, 比如 ServletHandler. 如果浏览器请求的是一个静态资源, 也有相应的 ResourceHandler 来处理这个请求, 返回静态页面.</li></ul> <h6 id="_2-如何实现servlet规范"><a href="#_2-如何实现servlet规范" class="header-anchor">#</a> 2.如何实现Servlet规范</h6> <p>上文提到 ServletHandler, ContextHandler 以及 WebAppContext 等实现了 Servlet 规范, 那具体是怎么实现的呢? 为帮助理解, 在这之前先看看如何使用 Jetty 来启动一个 Web 应用.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 新建一个 WebAppContext, WebAppContext 是一个 Handler</span>
<span class="token class-name">WebAppContext</span> webapp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebAppContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
webapp<span class="token punctuation">.</span><span class="token function">setContextPath</span><span class="token punctuation">(</span><span class="token string">&quot;/mywebapp&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
webapp<span class="token punctuation">.</span><span class="token function">setWar</span><span class="token punctuation">(</span><span class="token string">&quot;mywebapp.war&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// 将 Handler 添加到 Server 中去</span>
server<span class="token punctuation">.</span><span class="token function">setHandler</span><span class="token punctuation">(</span>webapp<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// 启动 Server</span>
server<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>上面的过程主要分为两步:</p> <p><strong>第一步创建一个 WebAppContext</strong>, 接着设置一些参数到这个 Handler 中, 就是告诉 WebAppContext 你的 WAR 包放在哪, Web 应用的访问路径是什么.</p> <p><strong>第二步就是把新创建的 WebAppContext 添加到 Server 中, 然后启动 Server</strong>.</p> <p>WebAppContext 对应一个 Web 应用. 回忆一下 Servlet 规范中有 Context, Servlet, Filter, Listener 和 Session 等, Jetty 要支持 Servlet 规范, 就需要有相应的 Handler 来分别实现这些功能. 因此, Jetty 设计了 3 个组件: <strong>ContextHandler, ServletHandler 和 SessionHandler</strong> 来实现 Servle 规范中规定的功能, 而 <strong>WebAppContext 本身就是一个 ContextHandler</strong>, 另外它还负责管理 ServletHandler 和 SessionHandler.</p> <p>再来看一下什么是 <mark><strong>ContextHandler</strong></mark>. ContextHandler 会<strong>创建并初始化 Servlet 规范里的 ServletContext 对象</strong>, 同时 ContextHandler 还包含了一组能够让你的 Web 应用运行起来的 Handler, 可以这样理解, Context 本身也是一种 Handler, 它里面包含了其他的 Handler, 这些 Handler 能处理某个特定 URL 下的请求. 比如, ContextHandler 包含了一个或者多个 ServletHandler.</p> <p>再来看 <mark><strong>ServletHandler</strong></mark>, 它<strong>实现了 Servlet 规范中的 Servlet, Filter 和 Listener 的功能</strong>. ServletHandler 依赖 FilterHolder, ServletHolder, ServletMapping, FilterMapping 这四大组件. FilterHolder 和 ServletHolder 分别是 Filter 和 Servlet 的包装类, 每一个 Servlet 与路径的映射会被封装成 ServletMapping, 而 Filter 与拦截 URL 的映射会被封装成 FilterMapping.</p> <p><mark><strong>SessionHandler</strong></mark> 从名字就知道它的功能, <strong>用来管理 Session</strong>. 除此之外 WebAppContext 还有一些通用功能的 Handler, 比如 SecurityHandler 和 GzipHandler, 同样从名字可以知道这些 Handler 的功能分别是安全控制和压缩 / 解压缩.</p> <p>WebAppContext 会将这些 Handler 构建成一个执行链, 通过这个链会最终调用到业务 Servlet. 下面通过一张图来理解一下.</p> <p><img src="/img/image-20230405161141-rb27mbx.jpg" alt=""></p> <p>通过对比 Tomcat 的架构图, 可以看到, Jetty 的 Handler 组件和 Tomcat 中的容器组件是大致是对等的概念, Jetty 中的 WebAppContext 相当于 Tomcat 的 Context 组件, 都是对应一个 Web 应用; 而 Jetty 中的 ServletHandler 对应 Tomcat 中的 Wrapper 组件, 它负责初始化和调用 Servlet, 并实现了 Filter 的功能.</p> <p>对于一些通用组件, 比如安全和解压缩, 在 Jetty 中<strong>都被做成了 Handler</strong>, 这是 Jetty Handler 架构的特点.</p> <p><strong>因此对于 Jetty 来说, 请求处理模块就被抽象成 Handler, 不管是实现了 Servlet 规范的 Handler, 还是实现通用功能的 Handler, 比如安全, 解压缩等, 我们可以任意添加或者裁剪这些 &quot;功能模块&quot;, 从而实现高度的可定制化.</strong></p> <h6 id="_3-总结"><a href="#_3-总结" class="header-anchor">#</a> 3.总结</h6> <p>Jetty Server 就是由多个 Connector, 多个 Handler, 以及一个线程池组成.</p> <p>Jetty 的 Handler 设计是它的一大特色, Jetty 本质就是一个 Handler 管理器, Jetty 本身就提供了一些默认 Handler 来实现 Servlet 容器的功能, 也可以定义自己的 Handler 来添加到 Jetty 中, 这体现了 &quot;<strong>微内核 + 插件</strong>&quot; 的设计思想.</p> <h4 id="_11-总结-从tomcat和jetty中提炼组件化设计规范"><a href="#_11-总结-从tomcat和jetty中提炼组件化设计规范" class="header-anchor">#</a> 11.总结:从Tomcat和Jetty中提炼组件化设计规范</h4> <p>我们经常谈敏捷, 快速迭代和重构, 这些都是为了应对需求的快速变化, 也因此在开始设计一个系统时就要考虑可扩展性. 那究竟该怎样设计才能适应变化呢? 或者要设计成什么样后面才能以最小的成本进行重构呢? 下面来总结一些 Tomcat 和 Jetty 组件化的设计思想, 或许从中可以得到一些启发.</p> <h5 id="组件化及可配置"><a href="#组件化及可配置" class="header-anchor">#</a> 组件化及可配置</h5> <p><strong>Tomcat 和 Jetty 的整体架构都是基于组件的</strong>, 可以通过 XML 文件或者代码的方式来配置这些组件, 比如可以在 server.xml 配置 Tomcat 的连接器以及容器组件. 相应的, 也可以在 Jetty.xml 文件里组装 Jetty 的 Connector 组件, 以及各种 Handler 组件. 也就是说, <mark><strong>Tomcat 和 Jetty 提供了一堆积木, 怎么搭建这些积木由你来决定</strong></mark>, 可以根据自己的需要灵活选择组件来搭建 Web 容器, 并且也可以自定义组件, 这样的设计为 Web 容器提供了深度可定制化.</p> <p>那 Web 容器如何实现这种组件化设计呢? 主要有两个要点:</p> <ul><li><strong>第一个是面向接口编程</strong>. 需要对系统的功能按照 &quot;高内聚, 低耦合&quot; 的原则进行拆分, 每个组件都有相应的接口, 组件之间通过接口通信, 这样就可以方便地替换组件了. 比如可以选择不同连接器类型, 只要这些连接器组件实现同一个接口就行.</li> <li><strong>第二个是 Web 容器提供一个载体把组件组装在一起工作</strong>. 组件的工作无非就是处理请求, 因此容器通过责任链模式把请求依次交给组件去处理. 对于用户来说, 只需要告诉 Web 容器由哪些组件来处理请求. 把组件组织起来需要一个&quot;管理者&quot;, 这就是为什么 Tomcat 和 Jetty 都有一个 Server 的概念, <strong>Server 就是组件的载体, Server 里包含了连接器组件和容器组件; 容器还需要把请求交给各个子容器组件去处理, Tomcat 和 Jetty 都是责任链模式来实现的</strong>.</li></ul> <p>用户通过配置来组装组件, 跟 Spring 中 Bean 的依赖注入相似. Spring 的用户可以通过配置文件或者注解的方式来组装 Bean, Bean 与 Bean 的依赖关系完全由用户自己来定义. 这一点与 Web 容器<strong>不同</strong>, Web 容器中组件与组件之间的关系是固定的, 比如 Tomcat 中 Engine 组件下有 Host 组件, Host 组件下有 Context 组件等, 但不能在 Host 组件里 &quot;注入&quot; 一个 Wrapper 组件, 这是由于 Web 容器本身的功能来决定的.</p> <h5 id="组件的创建"><a href="#组件的创建" class="header-anchor">#</a> 组件的创建</h5> <p>由于组件是可以配置的, Web 容器在启动之前并不知道要创建哪些组件, 也就是说, 不能通过硬编码的方式来实例化这些组件, 而是需要通过<strong>反射机制</strong>来动态地创建. 具体来说, Web 容器不是通过 new 方法来实例化组件对象的, 而是<strong>通过 Class.forName 来创建组件</strong>. 无论哪种方式, 在实例化一个类之前, Web 容器需要把组件类加载到 JVM, 这就涉及一个类加载的问题, Web 容器设计了自己类加载器, 后面会详细介绍 Tomcat 的类加载器.</p> <p>Spring 也是通过反射机制来动态地实例化 Bean, 那么它用到的类加载器是从哪里来的呢? Web 容器给每个 Web 应用创建了一个类加载器, Spring 用到的类加载器是 Web 容器传给它的.</p> <h5 id="组件的生命周期管理"><a href="#组件的生命周期管理" class="header-anchor">#</a> 组件的生命周期管理</h5> <p>不同类型的组件具有父子层次关系, 父组件处理请求后再把请求传递给某个子组件. 你可能会感到疑惑, Jetty 的中 Handler 不是一条链吗, 看上去像是平行关系? 其实不然, Jetty 中的 Handler 也是分层次的, 比如 WebAppContext 中包含 ServletHandler 和 SessionHandler. 因此也可以把 ContextHandler 和它所包含的 Handler 看作是父子关系.</p> <p>而 Tomcat 通过容器的概念, 把小容器放到大容器来实现父子关系, 其实它们的本质都是一样的. 这其实涉及如何统一管理这些组件, 如何做到一键式启停.</p> <p>Tomcat 和 Jetty 都采用了类似的办法来<strong>管理组件的生命周期</strong>, 主要有两个要点, <mark><strong>一是父组件负责子组件的创建, 启停和销毁</strong></mark>. 这样只要启动最上层组件, 整个 Web 容器就被启动起来了, 也就实现了一键式启停; <mark><strong>二是 Tomcat 和 Jetty 都定义了组件的生命周期状态, 并且把组件状态的转变定义成一个事件, 一个组件的状态变化会触发子组件的变化</strong></mark>, 比如 Host 容器的启动事件里会触发 Web 应用的扫描和加载, 最终会在 Host 容器下创建相应的 Context 容器, 而 Context 组件的启动事件又会触发 Servlet 的扫描, 进而创建 Wrapper 组件. 那么如何实现这种联动呢? 答案是<strong>观察者模式</strong>. 具体来说就是创建监听器去监听容器的状态变化, 在监听器的方法里去实现相应的动作, 这些监听器其实是组件生命周期过程中的 &quot;扩展点&quot;.</p> <p>Spring 也采用了类似的设计, Spring 给 Bean 生命周期状态提供了很多的 &quot;扩展点&quot;. 这些扩展点被定义成一个个接口, 只要 Bean 实现了这些接口, Spring 就会负责调用这些接口, 这样做的目的就是, 当 Bean 的创建, 初始化和销毁这些控制权交给 Spring 后, Spring 让你有机会在 Bean 的整个生命周期中执行你的逻辑. 下面通过一张图来理解 Spring Bean 的生命周期过程:</p> <p><img src="/img/image-20230405161159-cayup9b.png" alt=""></p> <h5 id="组件的骨架抽象类和模板模式"><a href="#组件的骨架抽象类和模板模式" class="header-anchor">#</a> 组件的骨架抽象类和模板模式</h5> <p>具体到组件的设计的与实现, Tomcat 和 Jetty 都大量采用了<strong>骨架抽象类和模板模式</strong>. 比如说 Tomcat 中 ProtocolHandler 接口, ProtocolHandler 有抽象基类 AbstractProtocol, 它实现了协议处理层的骨架和通用逻辑, 而具体协议也有抽象基类, 比如 HttpProtocol 和 AjpProtocol. 对于 Jetty 来说, Handler 接口之下有 AbstractHandler, Connector 接口之下有 AbstractorConnector, 这些抽象骨架类实现了一些通用逻辑, 并且会<strong>定义一些抽象方法</strong>, 这些抽象方法由子类实现, 抽象骨架类调用抽象方法来实现骨架逻辑.</p> <p>这是一个通用的设计规范, 不管是 Web 容器还是 Spring, 甚至 JDK 本身都到处使用这种设计, 比如 Java 集合中的 AbstractSet, AbstractMap 等. 值得一提的是, 从 Java 8 开始允许接口有 default 方法, 这样可以把抽象骨架类的通用逻辑放到接口中去.</p> <h5 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h5> <p>这里<mark><strong>总结了 Tomcat 和 Jetty 的组件化设计, 可以通过搭积木的方式来定制化自己的 Web 容器. Web 容器为了支持这种组件化设计, 遵循了一些规范, 比如面向接口编程, 用 &quot;管理者&quot; 去组装这些组件, 用反射的方式动态的创建组件, 统一管理组件的生命周期, 并且给组件生命状态的变化提供了扩展点, 组件的具体实现一般遵循骨架抽象类和模板模式</strong></mark>.</p> <h4 id="_12-实战-优化并提高tomcat启动速度"><a href="#_12-实战-优化并提高tomcat启动速度" class="header-anchor">#</a> 12.实战:优化并提高Tomcat启动速度</h4> <p>在使用 Tomcat 时可能会碰到启动比较慢的问题, 比如系统发布新版本上线时, 可能需要重启服务, 这个时候希望 Tomcat 能快速启动起来提供服务. 下面针对 Tomcat 8.5 和 9.0 版本, 给出几条非常明确的建议.</p> <p>如果是用嵌入式的方式运行 Tomcat, 比如 Spring Boot, 也可以通过 Spring Boot 的方式去修改 Tomcat 的参数, 调优的原理都是一样的.</p> <h5 id="清理你的tomcat"><a href="#清理你的tomcat" class="header-anchor">#</a> 清理你的Tomcat</h5> <p><strong>1. 清理不必要的 Web 应用</strong></p> <p>首先要做的是删除掉 webapps 文件夹下不需要的工程, 一般是 host-manager, example, doc 等这些默认的工程, 可能还有以前添加的但现在用不着的工程, 最好把这些全都删除掉. 如果你看过 Tomcat 的启动日志, 可以发现<strong>每次启动 Tomcat, 都会重新布署这些工程</strong>.</p> <p><strong>2. 清理 XML 配置文件</strong></p> <p>Tomcat 在启动的时候会<strong>解析所有的 XML 配置文件</strong>, 但 XML 解析的代价可不小, 因此要尽量保持配置文件的简洁, 需要解析的东西越少, 速度自然就会越快.</p> <p><strong>3. 清理 JAR 文件</strong></p> <p>还可以删除所有不需要的 JAR 文件. JVM 的类加载器在加载类时, 需要查找每一个 JAR 文件, 去找到所需要的类. 如果删除了不需要的 JAR 文件, 查找的速度就会快一些. 这里请注意: <strong>Web 应用中的 lib 目录下不应该出现 Servlet API 或者 Tomcat 自身的 JAR</strong>, 这些 JAR 由 Tomcat 负责提供. 如果是使用 Maven 来构建应用, 对 Servlet API 的依赖应该指定为<code>&lt;scope&gt;provided&lt;/scope&gt;</code>​.</p> <p><strong>4. 清理其他文件</strong></p> <p>及时清理日志, 删除 logs 文件夹下不需要的日志文件. 同样还有 work 文件夹下的 catalina 文件夹, 它其实是 Tomcat 把 JSP 转换为 Class 文件的工作目录. 有时候也许会遇到修改了代码, 重启了 Tomcat, 但是仍没效果, 这时候便可以删除掉这个文件夹, Tomcat 下次启动的时候会重新生成.</p> <h5 id="禁止tomcat-tld扫描"><a href="#禁止tomcat-tld扫描" class="header-anchor">#</a> 禁止Tomcat TLD扫描</h5> <p>Tomcat 为了支持 JSP, 在应用启动的时候会扫描 JAR 包里面的 TLD 文件, 加载里面定义的标签库.</p> <p>建议配置一下 Tomcat 不要去扫描这些 JAR 包, 这样可以提高 Tomcat 的启动速度, 并节省 JSP 编译时间.</p> <h5 id="关闭websocket支持"><a href="#关闭websocket支持" class="header-anchor">#</a> 关闭WebSocket支持</h5> <p>Tomcat 会扫描 WebSocket 注解的 API 实现, 比如 <code>@ServerEndpoint</code>​ 注解的类. 注解扫描一般是比较慢的, 如果不需要使用 WebSockets 就可以关闭它. 具体方法是, 找到 Tomcat 的 <code>conf/</code>​ 目录下的 <code>context.xml</code>​ 文件, 给 Context 标签加一个 **containerSciFilter ** 的属性.</p> <p>更进一步, 如果不需要 WebSockets 这个功能, 可以把 Tomcat lib 目录下的 <code>websocket-api.jar</code>​ 和 <code>tomcat-websocket.jar</code>​ 这两个 JAR 文件删除掉, 进一步提高性能.</p> <h5 id="并行启动多个web应用"><a href="#并行启动多个web应用" class="header-anchor">#</a> 并行启动多个Web应用</h5> <p>Tomcat 启动的时候, 默认情况下 Web 应用都是一个一个启动的, 等所有 Web 应用全部启动完成, Tomcat 才算启动完毕. 如果在一个 Tomcat 下有多个 Web 应用, 为了优化启动速度, 可以配置多个应用程序并行启动, 可以通过修改 <code>server.xml</code>​ 中 Host 元素的 startStopThreads 属性来完成. startStopThreads 的值表示想用多少个线程来启动 Web 应用, 如果设成 0 表示要并行启动 Web 应用.</p> <p>这里需要注意的是, Engine 元素里也配置了这个参数, 这意味着如果 Tomcat 配置了多个 Host(虚拟主机), Tomcat 会以并行的方式启动多个 Host.</p> <h3 id="连接器-2"><a href="#连接器-2" class="header-anchor">#</a> 连接器</h3> <h4 id="_14-nioendpoint组件-tomcat如何实现非阻塞io"><a href="#_14-nioendpoint组件-tomcat如何实现非阻塞io" class="header-anchor">#</a> 14.NioEndpoint组件:Tomcat如何实现非阻塞IO?</h4> <p>UNIX 系统下的 I/O 模型有 5 种: 同步阻塞 I/O, 同步非阻塞 I/O, I/O 多路复用, 信号驱动 I/O 和异步 I/O. 这些名词我们好像都似曾相识, 但这些 I/O 通信模型有什么区别? 同步和阻塞似乎是一回事, 到底有什么不同? 等一下, 在这之前问一个终极问题: 什么是 I/O? 为什么需要这些 I/O 模型?</p> <p>所谓的 <strong>I/O 就是计算机内存与外部设备之间拷贝数据的过程</strong>. 由于 CPU 访问内存的速度远远高于外部设备, 因此 CPU 是先把外部设备的数据读到内存里, 然后再进行处理. 请考虑一下这个场景, 当你的程序通过 CPU 向外部设备发出一个读指令时, 数据从外部设备拷贝到内存往往需要一段时间, 这个时候 CPU 没事干了, 你的程序是主动把 CPU 让给别人? 还是让 CPU 不停地查: 数据到了吗, 数据到了吗...</p> <p><strong>这就是 I/O 模型要解决的问题</strong>. 这里先说说各种 I/O 模型的区别, 然后重点分析 Tomcat 的 <strong>NioEndpoint 组件是如何实现非阻塞 I/O 模型</strong>的.</p> <h5 id="java-i-o模型"><a href="#java-i-o模型" class="header-anchor">#</a> Java I/O模型</h5> <p>对于一个网络 I/O 通信过程, 比如网络数据读取, 会涉及两个对象, <strong>一个是调用这个 I/O 操作的用户线程, 另外一个就是操作系统内核. 一个进程的地址空间分为用户空间和内核空间, 用户线程不能直接访问内核空间</strong>.</p> <p>当用户线程发起 I/O 操作后, 网络数据读取操作会经历两个步骤:</p> <ul><li><mark>**用户线程等待内核将数据从网卡拷贝到内核空间. **</mark></li> <li><mark>**内核将数据从内核空间拷贝到用户空间. **</mark></li></ul> <p>各种 I/O 模型的区别就是: 它们实现这两个步骤的方式是不一样的.</p> <p><strong>同步阻塞 I/O</strong>: 用户线程发起 read 调用后就阻塞了, 让出 CPU. 内核等待网卡数据到来, 把数据从网卡拷贝到内核空间, 接着把数据拷贝到用户空间, 再把用户线程叫醒.</p> <p><img src="/img/image-20230405161302-sz6gt2s.jpg" alt=""></p> <p><strong>同步非阻塞 I/O</strong>: 用户线程不断的发起 read 调用, 数据没到内核空间时, 每次都返回失败, 直到数据到了内核空间, 这一次 read 调用后, 在等待数据从内核空间拷贝到用户空间这段时间里, 线程还是阻塞的, 等数据到了用户空间再把线程叫醒.</p> <p><img src="/img/image-20230405161302-o6f8wgz.jpg" alt=""></p> <p><strong>I/O 多路复用</strong>: <strong>用户线程的读取操作分成两步</strong>了, 线程先发起 select 调用, 目的是问内核数据准备好了吗? 等内核把数据准备好了, 用户线程再发起 read 调用. 在等待数据从内核空间拷贝到用户空间这段时间里, 线程还是阻塞的. 那为什么叫 I/O 多路复用呢? <strong>因为一次 select 调用可以向内核查多个数据通道(Channel)的状态, 所以叫多路复用</strong>.</p> <p><img src="/img/image-20230405161302-nyy072b.jpg" alt=""></p> <p><strong>异步 I/O</strong>: 用户线程发起 read 调用的同时<strong>注册一个回调函数</strong>, read 立即返回, 等内核将数据准备好后, 再调用指定的回调函数完成处理. 在这个过程中, 用户线程一直没有阻塞.</p> <p><img src="/img/image-20230405161302-6jzsof7.jpg" alt=""></p> <h5 id="nioendpoint组件"><a href="#nioendpoint组件" class="header-anchor">#</a> NioEndpoint组件</h5> <p><strong>Tomcat 的 NioEndPoint 组件实现了 I/O 多路复用模型</strong>, 接下来介绍 NioEndpoint 的实现原理, 后面会介绍 Tomcat 如何实现异步 I/O 模型.</p> <p><strong>总体工作流程</strong></p> <p>对于 Java 的多路复用器的使用, 无非是两步:</p> <ol><li>**创建一个 Seletor, 在它身上注册各种感兴趣的事件, 然后调用 select 方法, 等待感兴趣的事情发生. **</li> <li>**感兴趣的事情发生了, 比如可以读了, 这时便创建一个新的线程从 Channel 中读数据. **</li></ol> <p>Tomcat 的 NioEndpoint 组件虽然实现比较复杂, 但基本原理就是上面两步. 先来看看它有哪些组件, 它<strong>一共包含 LimitLatch, Acceptor, Poller, SocketProcessor 和 Executor 共 5 个组件</strong>, 它们的工作过程如下图所示.</p> <p><img src="/img/image-20230405161302-b8n88nw.jpg" alt=""></p> <ul><li><p><strong>LimitLatch 是连接控制器</strong>, 它负责控制最大连接数, NIO 模式下默认是 10000, 达到这个阈值后, 连接请求被拒绝.</p></li> <li><p><strong>Acceptor</strong> 跑在一个单独的线程里, 它在一个死循环里调用 accept 方法来接收新连接, 一旦有新的连接请求到来, accept 方法返回一个 <strong>Channel</strong> 对象, 接着把 Channel 对象交给 Poller 去处理.</p></li> <li><p><strong>Poller 的本质是一个 Selector</strong>, 也跑在单独线程里. Poller 在内部维护一个 Channel 数组, 它在一个死循环里不断检测 Channel 的数据就绪状态, 一旦有 Channel 可读, 就生成一个 SocketProcessor 任务对象扔给 Executor 去处理.</p></li> <li><p><strong>Executor 就是线程池</strong>, 负责运行 SocketProcessor 任务类, SocketProcessor 的 run 方法会调用 Http11Processor 来读取和解析请求数据. 我们知道, Http11Processor 是应用层协议的封装, 它会调用容器获得响应, 再把响应通过 Channel 写出.</p></li></ul> <p>接下来详细介绍一下各组件的设计特点.</p> <h6 id="_1-limitlatch"><a href="#_1-limitlatch" class="header-anchor">#</a> 1.LimitLatch</h6> <p>LimitLatch 用来控制连接个数, 当连接数到达最大时阻塞线程, 直到后续组件处理完一个连接后将连接数减 1. 请你注意到达最大连接数后操作系统底层还是会接收客户端连接, 但用户层已经不再接收. LimitLatch 的核心代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LimitLatch</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>
   
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">long</span> newCount <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>newCount <span class="token operator">&gt;</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                count<span class="token punctuation">.</span><span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
 
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            count<span class="token punctuation">.</span><span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicLong</span> count<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> limit<span class="token punctuation">;</span>
  
    <span class="token comment">// 线程调用这个方法来获得接收新连接的许可, 线程可能被阻塞</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">countUpOrAwait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
      sync<span class="token punctuation">.</span><span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">// 调用这个方法来释放一个连接许可, 那么前面阻塞的线程可能被唤醒</span>
    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> result<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>从上面的代码可以看到, LimitLatch 内步定义了内部类 Sync, 而 Sync 扩展了 AQS, AQS 是 Java 并发包中的一个核心类, 它在内部维护一个状态和一个线程队列, 可以用来<strong>控制线程什么时候挂起, 什么时候唤醒</strong>. 可以扩展它来实现自己的同步器, 实际上 Java 并发包里的锁和条件变量等等都是通过 AQS 来实现的, 这里的 LimitLatch 也不例外.</p> <p>理解上面的代码时有两个要点:</p> <ol><li>用户线程通过调用 LimitLatch 的 countUpOrAwait() 方法来拿到锁, 如果暂时无法获取, 这个线程会被阻塞到 AQS 的队列中. 那 AQS 怎么知道是阻塞还是不阻塞用户线程呢? 其实这是由 AQS 的使用者来决定的, 也就是内部类 Sync 来决定的, 因为 Sync 类重写了 AQS 的 <strong>tryAcquireShared() 方法</strong>. 它的实现逻辑是如果当前连接数 count 小于 limit, 线程能获取锁, 返回 1, 否则返回 -1.</li> <li>如何用户线程被阻塞到了 AQS 的队列, 那什么时候唤醒呢? 同样是由 Sync 内部类决定, Sync 重写了 AQS 的<strong>releaseShared() 方法</strong>, 其实就是当一个连接请求处理完了, 这时又可以接收一个新连接了, 这样前面阻塞的线程将会被唤醒.</li></ol> <p>AQS 就是一个骨架抽象类, 它帮我们搭了个架子, 用来控制线程的阻塞和唤醒. 具体什么时候阻塞, 什么时候唤醒由你来决定. 还可以看到, 当前线程数被定义成原子变量 AtomicLong, 而 limit 变量用 volatile 关键字来修饰, 这些都是并发编程的实际运用.</p> <h6 id="_2-acceptor"><a href="#_2-acceptor" class="header-anchor">#</a> 2.Acceptor</h6> <p>Acceptor 实现了 Runnable 接口, 因此可以跑在<strong>单独线程</strong>里. <strong>一个端口号只能对应一个 ServerSocketChannel</strong>, 因此这个 <strong>ServerSocketChannel 是在多个 Acceptor 线程之间共享</strong>的, 它是 Endpoint 的属性, 由 Endpoint 完成初始化和端口绑定. 初始化过程如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>serverSock <span class="token operator">=</span> <span class="token class-name">ServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
serverSock<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span><span class="token function">getAcceptCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
serverSock<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>从上面的初始化代码可以看到两个关键信息:</p> <p>1.bind() 方法的第二个参数表示操作系统的等待队列长度. 上面提到过, 当应用层面的连接数到达最大值时, 操作系统可以继续接收连接, 那么操作系统能继续接收的最大连接数就是这个队列长度, 可以通过 acceptCount 参数配置, 默认是 100.</p> <p>2.ServerSocketChannel 被设置成<strong>阻塞模式</strong>, 也就是说它是以阻塞的方式接收连接的.</p> <p><strong>ServerSocketChannel 通过 accept() 接受新的连接, accept() 方法返回获得 SocketChannel 对象, 然后将 SocketChannel 对象封装在一个 PollerEvent 对象中, 并将 PollerEvent 对象压入 Poller 的 Queue 里, 这是个典型的生产者 - 消费者模式, Acceptor 与 Poller 线程之间通过 Queue 通信</strong>.</p> <h6 id="_3-poller"><a href="#_3-poller" class="header-anchor">#</a> 3.Poller</h6> <p>Poller 本质是一个 Selector, 它内部维护一个 Queue, 这个 Queue 定义如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">SynchronizedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PollerEvent</span><span class="token punctuation">&gt;</span></span> events <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>SynchronizedQueue 的方法比如 offer, poll, size 和 clear 方法, 都使用了 Synchronized 关键字进行修饰, 用来保证<strong>同一时刻只有一个 Acceptor 线程对 Queue 进行读写</strong>. 同时有多个 Poller 线程在运行, 每个 Poller 线程都有自己的 Queue. 每个 Poller 线程可能同时被多个 Acceptor 线程调用来注册 PollerEvent. 同样 Poller 的个数可以通过 pollers 参数配置.</p> <p>**Poller 不断的通过内部的 Selector 对象向内核查询 Channel 的状态, 一旦可读就生成任务类 SocketProcessor 交给 Executor 去处理. Poller 的另一个重要任务是循环遍历检查自己所管理的 SocketChannel 是否已经超时, 如果有超时就关闭这个 SocketChannel. **</p> <h6 id="_4-socketprocessor"><a href="#_4-socketprocessor" class="header-anchor">#</a> 4.SocketProcessor</h6> <p>Poller 会创建 SocketProcessor 任务类交给<strong>线程池</strong>处理, 而 SocketProcessor 实现了 Runnable 接口, 用来<strong>定义 Executor 中线程所执行的任务</strong>, 主要就是调用 Http11Processor 组件来处理请求. <strong>Http11Processor 读取 Channel 的数据来生成 ServletRequest 对象</strong>, 这里需要注意:</p> <p>Http11Processor 并不是直接读取 Channel 的. 这是因为 Tomcat 支持同步非阻塞 I/O 模型和异步 I/O 模型, 在 Java API 中, 相应的 Channel 类也是不一样的, 比如有 AsynchronousSocketChannel 和 SocketChannel, 为了对 Http11Processor 屏蔽这些差异, Tomcat 设计了一个<strong>包装类叫作 SocketWrapper, Http11Processor 只调用 SocketWrapper 的方法去读写数据</strong>.</p> <h6 id="_5-executor"><a href="#_5-executor" class="header-anchor">#</a> 5.Executor</h6> <p>Executor 是 Tomcat <strong>定制版的线程池</strong>, 它负责创建真正干活的工作线程, 干什么活呢? 就是执行 SocketProcessor 的 run() 方法, 也就是<strong>解析请求并通过容器来处理请求, 最终会调用到 Servlet</strong>. 后面会用专门介绍 Tomcat 怎么扩展和使用 Java 原生的线程池.</p> <h5 id="高并发思路"><a href="#高并发思路" class="header-anchor">#</a> 高并发思路</h5> <p>在弄清楚 NioEndpoint 的实现原理后, 来考虑一个重要的问题, 怎么把这个过程做到高并发呢?</p> <p>高并发就是能快速地处理大量的请求, 需要<strong>合理设计线程模型让 CPU 忙起来, 尽量不要让线程阻塞</strong>, 因为一阻塞, CPU 就闲下来了. 另外就是有多少任务, 就用相应规模的线程数去处理. 可以注意到 <strong>NioEndpoint 要完成三件事情: 接收连接, 检测 I/O 事件以及处理请求, 那么最核心的就是把这三件事情分开, 用不同规模的线程去处理, 比如用专门的线程组去跑 Acceptor, 并且 Acceptor 的个数可以配置; 用专门的线程组去跑 Poller, Poller 的个数也可以配置; 最后具体任务的执行也由专门的线程池来处理, 也可以配置线程池的大小</strong>.</p> <h5 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h5> <p>I/O 模型是为了解决内存和外部设备速度差异的问题. 平时说的<strong>阻塞或非阻塞</strong>是指应用程序在<strong>发起 I/O 操作时, 是立即返回还是等待</strong>. 而<strong>同步和异步</strong>, 是指应用程序在与内核通信时, **数据从内核空间到应用空间的拷贝, 是由内核主动发起还是由应用程序来触发. **</p> <p>在 Tomcat 中, <strong>EndPoint 组件的主要工作就是处理 I/O, 而 NioEndpoint 利用 Java NIO API 实现了多路复用 I/O 模型</strong>. 其中关键的一点是, 读写数据的线程自己不会阻塞在 I/O 等待上, 而是把这个工作交给 Selector. 同时 Tomcat 在这个过程中运用到了很多 Java 并发编程技术, 比如 AQS, 原子类, 并发容器, 线程池等, 都值得细细品味.</p> <h4 id="_15-nio2endpoint组件-tomcat如何实现异步io"><a href="#_15-nio2endpoint组件-tomcat如何实现异步io" class="header-anchor">#</a> 15.Nio2Endpoint组件:Tomcat如何实现异步IO?</h4> <p>前面提到了 5 种 I/O 模型, 相应的 Java 提供了 BIO, NIO 和 NIO.2 这些 API 来实现这些 I/O 模型. BIO 是同步阻塞, NIO 是同步非阻塞, 那 NIO.2 又是什么呢? NIO 已经足够好了, 为什么还要 NIO.2 呢?</p> <p><strong>NIO 和 NIO.2 最大的区别是, 一个是同步一个是异步</strong>. 异步最大的特点是, 应用程序不需要自己去<strong>触发</strong>数据从内核空间到用户空间的<strong>拷贝</strong>.</p> <p><strong>为什么是应用程序去 &quot;触发&quot; 数据的拷贝, 而不是直接从内核拷贝数据呢? 这是因为应用程序是不能访问内核空间的, 因此数据拷贝肯定是由内核来做, 关键是谁来触发这个动作</strong>.</p> <p>**是内核主动将数据拷贝到用户空间并通知应用程序. 还是等待应用程序通过 Selector 来查询, 当数据就绪后, 应用程序再发起一个 read 调用, 这时内核再把数据从内核空间拷贝到用户空间. **</p> <p>需要注意的是, 数据从内核空间拷贝到用户空间这段时间, 应用程序还是阻塞的. 所以可以看到异步的效率是高于同步的, 因为异步模式下应用程序始终不会被阻塞.</p> <p>下面以网络数据读取为例, 来说明异步模式的工作过程.</p> <p>**首先, 应用程序在调用 read API 的同时告诉内核两件事情: 数据准备好了以后拷贝到哪个 Buffer, 以及调用哪个回调函数去处理这些数据. 之后, 内核接到这个 read 指令后, 等待网卡数据到达, 数据到了后, 产生硬件中断, 内核在中断程序里把数据从网卡拷贝到内核空间, 接着做 TCP/IP 协议层面的数据解包和重组, 再把数据拷贝到应用程序指定的 Buffer, 最后调用应用程序指定的回调函数. **</p> <p>可以通过下面这张图来回顾一下同步与异步的区别:</p> <p><img src="/img/image-20230405161330-quo98wb.jpg" alt=""></p> <p>可以看到在异步模式下, 应用程序当了&quot;甩手掌柜&quot;, 内核则忙前忙后, 但最大限度提高了 I/O 通信的效率. Windows 的 IOCP 和 Linux 内核 2.6 的 AIO 都提供了异步 I/O 的支持, <strong>Java 的 NIO.2 API 就是对操作系统异步 I/O API 的封装</strong>.</p> <h5 id="java-nio-2回顾"><a href="#java-nio-2回顾" class="header-anchor">#</a> Java NIO.2回顾</h5> <p>本部分重点关注 Tomcat 是如何实现异步 I/O 模型的, 但在这之前, 先来简单回顾下如何用 Java 的 NIO.2 API 来编写一个服务端程序.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Nio2Server</span> <span class="token punctuation">{</span>
 
   <span class="token keyword">void</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">// 1. 创建一个线程池</span>
      <span class="token class-name">ExecutorService</span> es <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
      <span class="token comment">// 2. 创建异步通道群组</span>
      <span class="token class-name">AsynchronousChannelGroup</span> tg <span class="token operator">=</span> <span class="token class-name">AsynchronousChannelGroup</span><span class="token punctuation">.</span><span class="token function">withCachedThreadPool</span><span class="token punctuation">(</span>es<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
      <span class="token comment">// 3. 创建服务端异步通道</span>
      <span class="token class-name">AsynchronousServerSocketChannel</span> assc <span class="token operator">=</span> <span class="token class-name">AsynchronousServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span>tg<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
      <span class="token comment">// 4. 绑定监听端口</span>
      assc<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
      <span class="token comment">// 5. 监听连接, 传入回调类处理连接请求</span>
      assc<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">AcceptHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>上面的代码主要做了 5 件事情:</p> <ol><li>创建一个线程池, 这个线程池用来执行来自内核的回调请求.</li> <li>创建一个 AsynchronousChannelGroup, 并绑定一个线程池.</li> <li>创建 AsynchronousServerSocketChannel, 并绑定到 AsynchronousChannelGroup.</li> <li>绑定一个监听端口.</li> <li>调用 accept() 方法开始监听连接请求, 同时传入一个回调类去处理连接请求. 请注意, accept() 方法的第一个参数是 this 对象, 就是 Nio2Server 对象本身, 下文还会讲为什么要传入这个参数.</li></ol> <p>为什么需要创建一个线程池呢? 其实<strong>在异步 I/O 模型里, 应用程序不知道数据在什么时候到达, 因此向内核注册回调函数, 当数据到达时, 内核就会调用这个回调函数. 同时为了提高处理速度, 会提供一个线程池给内核使用, 这样不会耽误内核线程的工作, 内核只需要把工作交给线程池就立即返回了</strong>.</p> <p>再来看看处理连接的回调类 AcceptHandler 是什么样的.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// AcceptHandler 类实现了 CompletionHandler 接口的 completed 方法. 它还有两个模板参数, 第一个是异步通道, 第二个就是 Nio2Server 本身</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AcceptHandler</span> <span class="token keyword">implements</span> <span class="token class-name">CompletionHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">AsynchronousSocketChannel</span><span class="token punctuation">,</span> <span class="token class-name">Nio2Server</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
 
   <span class="token comment">// 具体处理连接请求的就是 completed() 方法, 它有两个参数: 第一个是异步通道, 第二个就是上面传入的 NioServer 对象</span>
   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">completed</span><span class="token punctuation">(</span><span class="token class-name">AsynchronousSocketChannel</span> asc<span class="token punctuation">,</span> <span class="token class-name">Nio2Server</span> attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      <span class="token comment">// 调用 accept 方法继续接收其他客户端的请求</span>
      attachment<span class="token punctuation">.</span>assc<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>attachment<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
      <span class="token comment">// 1. 先分配好 Buffer, 告诉内核, 数据拷贝到哪里去</span>
      <span class="token class-name">ByteBuffer</span> buf <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
      <span class="token comment">// 2. 调用 read 函数读取数据, 除了把 buf 作为参数传入, 还传入读回调类</span>
      channel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ReadHandler</span><span class="token punctuation">(</span>asc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>可以看到它实现了 CompletionHandler 接口, 下面先看看 CompletionHandler 接口的定义.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CompletionHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">,</span><span class="token class-name">A</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
 
    <span class="token keyword">void</span> <span class="token function">completed</span><span class="token punctuation">(</span><span class="token class-name">V</span> result<span class="token punctuation">,</span> <span class="token class-name">A</span> attachment<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">void</span> <span class="token function">failed</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> exc<span class="token punctuation">,</span> <span class="token class-name">A</span> attachment<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>CompletionHandler 接口有两个模板参数 V 和 A, 分别表示 I/O 调用的返回值和附件类</strong>. 比如 accept 的返回值就是 AsynchronousSocketChannel, 而附件类由用户自己决定, 在 accept 的调用中, 传入了一个 Nio2Server. 因此 AcceptHandler 带有了两个模板参数: AsynchronousSocketChannel 和 Nio2Server.</p> <p>CompletionHandler 有两个方法: <strong>completed() 和 failed()</strong> , 分别在 I/O 操作成功和失败时调用. completed() 方法有两个参数, 其实就是前面说的两个模板参数. 也就是说, Java 的 NIO.2 在<strong>调用回调方法时, 会把返回值和附件类当作参数传给 NIO.2 的使用者</strong>.</p> <p>下面再来看看处理读的回调类 ReadHandler 长什么样子.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReadHandler</span> <span class="token keyword">implements</span> <span class="token class-name">CompletionHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>   
    <span class="token comment">// 读取到消息后的处理  </span>
    <span class="token annotation punctuation">@Override</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">completed</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> result<span class="token punctuation">,</span> <span class="token class-name">ByteBuffer</span> attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token comment">// attachment 就是数据, 调用 flip 操作, 其实就是把读的位置移动最前面</span>
        attachment<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token comment">// 读取数据</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 
    <span class="token punctuation">}</span>  
 
    <span class="token keyword">void</span> <span class="token function">failed</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> exc<span class="token punctuation">,</span> <span class="token class-name">A</span> attachment<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>read() 调用的返回值是一个整型数, 所以回调方法里的<strong>第一个参数就是一个整型, 表示有多少数据</strong>被读取到了 Buffer 中. 第二个参数是一个 ByteBuffer, 这是因为在调用 read() 方法时, 把用来<strong>存放数据的 ByteBuffer 当作附件类</strong>传进去了, 所以在回调方法里, 有 ByteBuffer 类型的参数, <strong>可以直接从这个 ByteBuffer 里获取数据</strong>.</p> <h5 id="nio2endpoint"><a href="#nio2endpoint" class="header-anchor">#</a> Nio2Endpoint</h5> <p>掌握了 Java NIO.2 API 的使用以及服务端程序的工作原理之后, 再来理解 Tomcat 的异步 I/O 实现就不难了. 先通过一张图来看看 Nio2Endpoint 有哪些组件.</p> <p><img src="/img/image-20230405161330-ql4r11f.jpg" alt=""></p> <p>从图上看, 总体工作流程跟 NioEndpoint 是相似的.</p> <ul><li><p>LimitLatch 是连接控制器, 它负责控制最大连接数.</p></li> <li><p>Nio2Acceptor 扩展了 Acceptor, 用异步 I/O 的方式来接收连接, 跑在一个单独的线程里, 也是一个线程组. Nio2Acceptor 接收新的连接后, 得到一个 AsynchronousSocketChannel, Nio2Acceptor 把 AsynchronousSocketChannel 封装成一个 Nio2SocketWrapper, 并创建一个 SocketProcessor 任务类交给线程池处理, 并且 SocketProcessor 持有 Nio2SocketWrapper 对象.</p></li> <li><p>Executor 在执行 SocketProcessor 时, SocketProcessor 的 run() 方法会调用 <strong>Http11Processor</strong> 来处理请求, Http11Processor 会通过 Nio2SocketWrapper 读取和解析请求数据, 请求经过容器处理后, 再把响应通过 Nio2SocketWrapper 写出.</p></li></ul> <p>需要注意 Nio2Endpoint 跟 NioEndpoint 的一个明显不同点是, <mark><strong>Nio2Endpoint 中没有 Poller 组件, 也就是没有 Selector. 这是为什么呢? 因为在异步 I/O 模式下, Selector 的工作交给内核来做了</strong></mark>​ **. **</p> <p>接下来详细介绍一下 Nio2Endpoint 各组件的设计.</p> <h6 id="_1-nio2acceptor"><a href="#_1-nio2acceptor" class="header-anchor">#</a> 1.Nio2Acceptor</h6> <p>和 NioEndpint 一样, Nio2Endpoint 的基本思路是用 LimitLatch 组件来控制连接数, 但是 Nio2Acceptor 的监听连接的过程不是在一个死循环里不断的调 accept() 方法, 而是<strong>通过回调函数</strong>来完成的. 来看看它的连接监听方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>serverSock<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其实就是调用了 accept() 方法, 注意它的第二个参数是 this, 表明 Nio2Acceptor 自己就是处理连接的回调类, 因此 Nio2Acceptor 实现了 CompletionHandler() 接口. 那么它是如何实现 CompletionHandler 接口的呢?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">class</span> <span class="token class-name">Nio2Acceptor</span> <span class="token keyword">extends</span> <span class="token class-name">Acceptor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">AsynchronousSocketChannel</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">implements</span> <span class="token class-name">CompletionHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">AsynchronousSocketChannel</span><span class="token punctuation">,</span> <span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
  
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">completed</span><span class="token punctuation">(</span><span class="token class-name">AsynchronousSocketChannel</span> socket<span class="token punctuation">,</span> <span class="token class-name">Void</span> attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isPaused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getMaxConnections</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果没有连接限制, 继续接收新的连接</span>
            serverSock<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果有连接限制, 就在线程池里跑 Run 方法, Run 方法会检查连接数</span>
            <span class="token function">getExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 处理请求</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">setSocketOptions</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">closeSocket</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>可以看到 CompletionHandler 的两个模板参数分别是 AsynchronousServerSocketChannel 和 Void, 前面说过第一个参数就是 accept() 方法的返回值, 第二个参数是附件类, 由用户自己决定, 这里为 Void. completed() 方法的处理逻辑比较简单:</p> <ul><li>如果没有连接限制, 继续在本线程中调用 accept() 方法接收新的连接.</li> <li>如果有连接限制, 就在线程池里跑 run() 方法去接收新的连接. 那为什么要跑 run() 方法呢, 因为在 run() 方法里会检查连接数, 当连接达到最大数时, 线程可能会被 LimitLatch 阻塞. 为什么要放在线程池里跑呢? 这是因为如果放在当前线程里执行, completed() 方法可能被阻塞, 会导致这个回调方法一直不返回.</li></ul> <p>接着 completed() 方法会调用 setSocketOptions() 方法, 在这个方法里, 会创建 Nio2SocketWrapper 和 SocketProcessor, 并交给线程池处理.</p> <h6 id="_2-nio2socketwrapper"><a href="#_2-nio2socketwrapper" class="header-anchor">#</a> 2.Nio2SocketWrapper</h6> <p>Nio2SocketWrapper 的主要作用是<strong>封装 Channel</strong>, 并提供接口给 Http11Processor 读写数据. 讲到这里你是不是有个疑问: Http11Processor 是不能阻塞等待数据的, 按照异步 I/O 的套路, Http11Processor 在调用 Nio2SocketWrapper 的 read() 方法时需要注册回调类, read() 调用会立即返回, 问题是立即返回后 Http11Processor 还没有读到数据, 怎么办呢? 这个请求的处理不就失败了吗?</p> <p>为了解决这个问题, Http11Processor 是<strong>通过 2 次 read() 调用来完成数据读取操作</strong>的.</p> <ul><li>第一次 read 调用: 连接刚刚建立好后, Acceptor 创建 SocketProcessor 任务类交给线程池去处理, Http11Processor 在处理请求的过程中, 会调用 Nio2SocketWrapper 的 read() 方法发出第一次读请求, 同时注册了回调类 readCompletionHandler, 因为数据没读到, Http11Processor 把当前的 Nio2SocketWrapper 标记为数据不完整. <strong>接着 SocketProcessor 线程被回收, Http11Processor 并没有阻塞等待数据</strong>. 这里请注意, Http11Processor 维护了一个 Nio2SocketWrapper 列表, 也就是维护了连接的状态.</li> <li>第二次 read 调用: 当数据到达后, 内核已经把数据拷贝到 Http11Processor 指定的 Buffer 里, 同时回调类 readCompletionHandler 被调用, 在这个回调处理方法里会<strong>重新创建一个新的 SocketProcessor 任务来继续处理这个连接</strong>, 而这个新的 SocketProcessor 任务类持有原来那个 Nio2SocketWrapper, 这一次 Http11Processor 可以通过 Nio2SocketWrapper 读取数据了, 因为数据已经到了应用层的 Buffer.</li></ul> <p>这个回调类 readCompletionHandler 的源码如下, 最关键的一点是, <strong>Nio2SocketWrapper 是作为附件类来传递的</strong>, 这样在回调函数里能拿到所有的上下文.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">this</span><span class="token punctuation">.</span>readCompletionHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CompletionHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">SocketWrapperBase</span><span class="token punctuation">&lt;</span><span class="token class-name">Nio2Channel</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">completed</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> nBytes<span class="token punctuation">,</span> <span class="token class-name">SocketWrapperBase</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Nio2Channel</span><span class="token punctuation">&gt;</span></span> attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">// 通过附件类 SocketWrapper 拿到所有的上下文</span>
        <span class="token class-name">Nio2SocketWrapper</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEndpoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">processSocket</span><span class="token punctuation">(</span>attachment<span class="token punctuation">,</span> <span class="token class-name">SocketEvent</span><span class="token punctuation">.</span><span class="token constant">OPEN_READ</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">failed</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> exc<span class="token punctuation">,</span> <span class="token class-name">SocketWrapperBase</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Nio2Channel</span><span class="token punctuation">&gt;</span></span> attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h5 id="总结-3"><a href="#总结-3" class="header-anchor">#</a> 总结</h5> <p>在异步 I/O 模型里, 内核做了很多事情, 它把数据准备好, 并拷贝到用户空间, 再通知应用程序去处理, 也就是调用应用程序注册的回调函数. Java 在操作系统 异步 IO API 的基础上进行了封装, 提供了 Java NIO.2 API, 而 Tomcat 的异步 I/O 模型就是基于 Java NIO.2 实现的.</p> <p>由于 NIO 和 NIO.2 的 API 接口和使用方法完全不同, 可以想象一个系统中如果已经支持同步 I/O, 要再支持异步 I/O, 改动是比较大的, 很有可能不得不重新设计组件之间的接口. 但是 Tomcat 通过充分的抽象, 比如 SocketWrapper 对 Channel 的封装, 再加上 Http11Processor 的两次 read 调用, 巧妙地解决了这个问题, 使得协议处理器 Http11Processor 和 I/O 通信处理器 Endpoint 之间的接口保持不变.</p> <h4 id="_16-aprendpoint组件-tomcat-apr提高io性能的秘密"><a href="#_16-aprendpoint组件-tomcat-apr提高io性能的秘密" class="header-anchor">#</a> 16.AprEndpoint组件:Tomcat APR提高IO性能的秘密</h4> <p>在使用 Tomcat 时, 会在启动日志里看到这样的提示信息:</p> <blockquote><p>The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: ****</p></blockquote> <p>这句话的意思就是推荐你去安装 APR 库, 可以提高系统性能. 那什么是 APR 呢?</p> <p>APR(Apache Portable Runtime Libraries)是 Apache 可移植运行时库, 它是用 C 语言实现的, 其目的是向上层应用程序提供一个跨平台的操作系统接口库. Tomcat 可以用它来处理包括文件和网络 I/O, 从而提升性能. 前面提到过, Tomcat 支持的连接器有 NIO, NIO.2 和 APR. 跟 NioEndpoint 一样, AprEndpoint 也实现了非阻塞 I/O, 它们的区别是: NioEndpoint 通过调用 Java 的 NIO API 来实现非阻塞 I/O, 而 AprEndpoint 是通过 JNI 调用 APR 本地库而实现非阻塞 I/O 的.</p> <p>那同样是非阻塞 I/O, 为什么 Tomcat 会提示使用 APR 本地库的性能会更好呢? 这是因为在某些场景下, 比如需要频繁与操作系统进行交互, Socket 网络通信就是这样一个场景, 特别是如果 Web 应用使用了 TLS 来加密传输, 由于 TLS 协议在握手过程中有多次网络交互, 在这种情况下 Java 跟 C 语言程序相比还是有一定的差距, 而这正是 APR 的强项.</p> <p>Tomcat 本身是 Java 编写的, 为了调用 C 语言编写的 APR, 需要<strong>通过 JNI 方式</strong>来调用. JNI(Java Native Interface) 是 JDK 提供的一个编程接口, 它允许 Java 程序调用其他语言编写的程序或者代码库, 其实 JDK 本身的实现也大量用到 JNI 技术来调用本地 C 程序库.</p> <p>本部分首先会讲 AprEndpoint 组件的工作过程, 接着会在原理的基础上分析 APR 提升性能的一些秘密.</p> <h5 id="aprendpoint工作过程"><a href="#aprendpoint工作过程" class="header-anchor">#</a> AprEndpoint工作过程</h5> <p>下面通过一张图来理解 AprEndpoint 的工作过程.</p> <p><img src="/img/image-20230405161350-110183t.jpg" alt=""></p> <p>它跟 NioEndpoint 的图很像, 从左到右有 LimitLatch, Acceptor, Poller, SocketProcessor 和 Http11Processor, 只是 Acceptor 和 Poller 的实现和 NioEndpoint 不同. 接下来分别来讲讲这两个组件.</p> <h6 id="_1-acceptor-2"><a href="#_1-acceptor-2" class="header-anchor">#</a> 1.Acceptor</h6> <p>Accpetor 的功能就是监听连接, 接收并建立连接. 它的本质就是调用了四个操作系统 API: socket, bind, listen 和 accept. 那 Java 语言如何直接调用 C 语言 API 呢? 答案就是通过 <strong>JNI</strong>. 具体来说就是两步: 先封装一个 Java 类, 在里面定义一堆用 <strong>native 关键字</strong>修饰的方法, 像下面这样.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Socket</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// 用 native 修饰这个方法, 表明这个函数是 C 语言实现</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">int</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span> <span class="token keyword">long</span> cont<span class="token punctuation">)</span>
                        
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">long</span> sock<span class="token punctuation">,</span> <span class="token keyword">long</span> sa<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">long</span> sock<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">long</span> sock<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>接着用 C 代码实现这些方法, 比如 bind() 函数就是这样实现的:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// 注意函数的名字要符合 JNI 规范的要求</span>
JNIEXPORT jint JNICALL 
<span class="token function">Java_org_apache_tomcat_jni_Socket_bind</span><span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>e<span class="token punctuation">,</span> jlong sock<span class="token punctuation">,</span>jlong sa<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
	    jint rv <span class="token operator">=</span> APR_SUCCESS<span class="token punctuation">;</span>
	    <span class="token class-name">tcn_socket_t</span> <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">tcn_socket_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>sock<span class="token punctuation">;</span>
	    <span class="token class-name">apr_sockaddr_t</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">apr_sockaddr_t</span> <span class="token operator">*</span><span class="token punctuation">)</span> sa<span class="token punctuation">;</span>

        <span class="token comment">// 调用 APR 库自己实现的 bind 函数</span>
	    rv <span class="token operator">=</span> <span class="token punctuation">(</span>jint<span class="token punctuation">)</span><span class="token function">apr_socket_bind</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>sock<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token keyword">return</span> rv<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>要注意的是函数名字要符合 JNI 的规范, 以及 Java 和 C 语言如何互相传递参数, 比如在 C 语言有指针, Java 没有指针的概念, 所以在 Java 中用 long 类型来表示指针. <strong>AprEndpoint 的 Acceptor 组件就是调用了 APR 实现的四个 API</strong>.</p> <h6 id="_2-poller"><a href="#_2-poller" class="header-anchor">#</a> 2.Poller</h6> <p>Acceptor 接收到一个新的 Socket 连接后, 按照 NioEndpoint 的实现, 它会把这个 Socket 交给 Poller 去查询 I/O 事件. AprEndpoint 也是这样做的, 不过 AprEndpoint 的 Poller 并不是调用 Java NIO 里的 Selector 来查询 Socket 的状态, <strong>而是通过 JNI 调用 APR 中的 poll 方法, 而 APR 又是调用了操作系统的 epoll API 来实现的</strong>.</p> <p>这里有个特别的地方是在 AprEndpoint 中, 可以配置一个叫 <code>deferAccept</code>​ 的参数, 它对应的是 TCP 协议中的<code>TCP_DEFER_ACCEPT</code>​, 设置这个参数后, 当 TCP 客户端有新的连接请求到达时, <strong>TCP 服务端先不建立连接, 而是再等等, 直到客户端有请求数据发过来时再建立连接. 这样的好处是服务端不需要用 Selector 去反复查询请求数据是否就绪</strong>.</p> <p>这是一种 TCP 协议层的优化, 不是每个操作系统内核都支持, 因为 Java 作为一种跨平台语言, 需要屏蔽各种操作系统的差异, 因此并没有把这个参数提供给用户; 但是对于 APR 来说, 它的目的就是尽可能提升性能, 因此它向用户暴露了这个参数.</p> <h5 id="apr提升性能的秘密"><a href="#apr提升性能的秘密" class="header-anchor">#</a> APR提升性能的秘密</h5> <p>APR 连接器之所以能提高 Tomcat 的性能, 除了 APR 本身是 C 程序库之外, 还有哪些提速的秘密呢?</p> <h6 id="_1-jvm堆-vs-本地内存"><a href="#_1-jvm堆-vs-本地内存" class="header-anchor">#</a> 1.JVM堆 VS 本地内存</h6> <p>由于 Java 的类实例一般在 JVM 堆上分配, 而 Java 是通过 JNI 调用 C 代码来实现 Socket 通信的, 那么 C 代码在运行过程中需要的内存又是从哪里分配的呢? C 代码能否直接操作 Java 堆?</p> <p>为了回答这些问题, 先来说说 <strong>JVM 和用户进程</strong>的关系. 如果你想运行一个 Java 类文件, 可以用下面的 Java 命令来执行.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>java my.class
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这个命令行中的 <code>java</code>​ 其实是<strong>一个可执行程序, 这个程序会创建 JVM 来加载和运行 Java 类</strong>. 操作系统会<strong>创建一个进程</strong>来执行这个 <code>java</code>​ 可执行程序, 而每个进程都有自己的<strong>虚拟地址空间, JVM 用到的内存(包括堆, 栈和方法区)就是从进程的虚拟地址空间上分配的</strong>. 请注意, JVM 内存只是进程空间的一部分, 除此之外进程空间内还有代码段, 数据段, 内存映射区, 内核空间等. 从 JVM 的角度看, JVM 内存之外的部分叫作本地内存, C 程序代码在运行过程中用到的内存就是本地内存中分配的. 下面通过一张图来理解一下.</p> <p><img src="/img/image-20230405161350-v6dugwu.jpg" alt=""></p> <p>Tomcat 的 Endpoint 组件在接收网络数据时需要预先分配好一块 Buffer, 所谓的 Buffer 就是字节数组 <code>byte[]</code>​, Java <strong>通过 JNI 调用把这块 Buffer 的地址传给 C 代码, C 代码通过操作系统 API 读取 Socket 并把数据填充到这块 Buffer</strong>. Java NIO API 提供了两种 Buffer 来接收数据: HeapByteBuffer 和 DirectByteBuffer, 下面的代码演示了如何创建两种 Buffer.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 分配 HeapByteBuffer</span>
<span class="token class-name">ByteBuffer</span> buf <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// 分配 DirectByteBuffer</span>
<span class="token class-name">ByteBuffer</span> buf <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>创建好 Buffer 后直接传给 Channel 的 read 或者 write 函数, 最终这块 Buffer 会通过 JNI 调用传递给 C 程序.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 将 buf 作为 read 函数的参数</span>
<span class="token keyword">int</span> bytesRead <span class="token operator">=</span> socketChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>那 HeapByteBuffer 和 DirectByteBuffer 有什么区别呢? HeapByteBuffer 对象本身在 JVM 堆上分配, 并且它持有的字节数组 <code>byte[]</code>​ 也是在 JVM 堆上分配. 但是如果用 **HeapByteBuffer ** 来接收网络数据, <strong>需要把数据从内核先拷贝到一个临时的本地内存, 再从临时本地内存拷贝到 JVM 堆</strong>, 而不是直接从内核拷贝到 JVM 堆上. 这是为什么呢? 这是因为数据从内核拷贝到 JVM 堆的过程中, JVM 可能会发生 GC, GC 过程中对象可能会被移动, 也就是说 JVM 堆上的字节数组可能会被移动, 这样的话 Buffer 地址就失效了. 如果这中间经过本地内存中转, 从本地内存到 JVM 堆的拷贝过程中 JVM 可以保证不做 GC.</p> <p>如果使用 HeapByteBuffer, 那么 JVM 堆和内核之间多了一层中转, 而 DirectByteBuffer 可以用来解决这个问题, <strong>DirectByteBuffer 对象本身在 JVM 堆上, 但是它持有的字节数组不是从 JVM 堆上分配的, 而是从本地内存分配的</strong>. DirectByteBuffer 对象中有个 long 类型字段 address, 记录着本地内存的地址, 这样在接收数据的时候, 直接把这个本地内存地址传递给 C 程序, C 程序会将网络数据从内核拷贝到这个本地内存, JVM 可以直接读取这个本地内存, 这种方式比 HeapByteBuffer <strong>少了一次拷贝</strong>, 因此一般来说它的速度会比 HeapByteBuffer 快好几倍. 可以通过上面的图加深理解.</p> <p><strong>Tomcat 中的 AprEndpoint 就是通过 DirectByteBuffer 来接收数据的, 而 NioEndpoint 和 Nio2Endpoint 是通过 HeapByteBuffer 来接收数据的</strong>. 你可能会问, NioEndpoint 和 Nio2Endpoint 为什么不用 DirectByteBuffer 呢? 这是因为本地内存不好管理, 发生内存泄漏难以定位, 从稳定性考虑, NioEndpoint 和 Nio2Endpoint 没有去冒这个险.</p> <h6 id="_2-sendfile"><a href="#_2-sendfile" class="header-anchor">#</a> 2.sendfile</h6> <p>再来考虑另一个网络通信的场景, 也就是静态文件的处理. 浏览器通过 Tomcat 来获取一个 HTML 文件, 而 Tomcat 的处理逻辑无非是两步:</p> <ol><li>从磁盘读取 HTML 到内存.</li> <li>将这段内存的内容通过 Socket 发送出去.</li></ol> <p>但是在传统方式下, <strong>有很多次的内存拷贝</strong>:</p> <ul><li>读取文件时, 首先是内核把文件内容读取到内核缓冲区.</li> <li>如果使用 HeapByteBuffer, 文件数据从内核到 JVM 堆内存需要经过本地内存中转.</li> <li>同样在将文件内容推入网络时, 从 JVM 堆到内核缓冲区需要经过本地内存中转.</li> <li>最后还需要把文件从内核缓冲区拷贝到网卡缓冲区.</li></ul> <p>从下面的图可知这个过程有 6 次内存拷贝, 并且 read 和 write 等系统调用将导致进程从用户态到内核态的切换, 会耗费大量的 CPU 和内存资源.</p> <p><img src="/img/image-20230405161350-4yleyiz.jpg" alt=""></p> <p>而 Tomcat 的 AprEndpoint 通过<strong>操作系统层面的 sendfile 特性</strong>解决了这个问题, sendfile 系统调用方式非常简洁.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token function">sendfile</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> file<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>它带有两个关键参数: <strong>Socket 和文件句柄</strong>. 将文件从磁盘写入 Socket 的过程只有两步:</p> <p>第一步: 将文件内容读取到内核缓冲区.</p> <p>第二步: 数据并没有从内核缓冲区复制到 Socket 关联的缓冲区, 只有记录数据位置和长度的描述符被添加到 Socket 缓冲区中; 接着把数据直接从内核缓冲区传递给网卡. 这个过程可以看下面的图.</p> <p><img src="/img/image-20230405161350-6dxzoz5.jpg" alt=""></p> <h5 id="总结-4"><a href="#总结-4" class="header-anchor">#</a> 总结</h5> <p>对于一些需要频繁与操作系统进行交互的场景, 比如网络通信, Java 的效率没有 C 语言高, 特别是 TLS 协议握手过程中需要多次网络交互, 这种情况下使用 APR 本地库能够显著提升性能.</p> <p>除此之外, APR 提升性能的秘密还有: 通过 DirectByteBuffer 避免了 JVM 堆与本地内存之间的内存拷贝; 通过 sendfile 特性避免了内核与应用之间的内存拷贝以及用户态和内核态的切换. 其实很多高性能网络通信组件, 比如 Netty, 都是通过 DirectByteBuffer 来收发网络数据的. 由于本地内存难于管理, Netty 采用了本地内存池技术.</p> <h4 id="_17-executor组件-tomcat如何扩展java线程池"><a href="#_17-executor组件-tomcat如何扩展java线程池" class="header-anchor">#</a> 17.Executor组件:Tomcat如何扩展Java线程池?</h4> <p>在开发中经常会碰到&quot;池&quot;的概念, 比如数据库连接池, 内存池, 线程池, 常量池等. 为什么需要“池”呢? 程序运行的本质, 就是通过使用系统资源(CPU, 内存, 网络, 磁盘等)来完成信息的处理, 比如在 JVM 中创建一个对象实例需要消耗 CPU 和内存资源, 如果你的程序需要频繁创建大量的对象, 并且这些对象的存活时间短, 就意味着需要进行频繁销毁, 那么很有可能这部分代码会成为性能的瓶颈.</p> <p>而&quot;池&quot;就是用来解决这个问题的, 简单来说, 对象池就是把用过的对象保存起来, 等下一次需要这种对象的时候, 直接从对象池中拿出来重复使用, 避免频繁地创建和销毁. 在 Java 中万物皆对象, 线程也是一个对象, Java 线程是对操作系统线程的封装, 创建 Java 线程也需要消耗系统资源, 因此就有了线程池. JDK 中提供了线程池的默认实现, 也可以通过扩展 Java 原生线程池来实现自己的线程池.</p> <p>同样, 为了提高处理能力和并发度, Web 容器一般会把<strong>处理请求的工作放到线程池里</strong>来执行, Tomcat 扩展了原生的 Java 线程池, 来满足 Web 容器高并发的需求, 下面就来学习一下 Java 线程池的原理, 以及 Tomcat 是如何扩展 Java 线程池的.</p> <h5 id="java线程池"><a href="#java线程池" class="header-anchor">#</a> Java线程池</h5> <p>简单的说, Java 线程池里内部维护一个<strong>线程数组和一个任务队列</strong>, 当任务处理不过来的时, 就把任务放到队列里慢慢处理.</p> <h6 id="_1-threadpoolexecutor"><a href="#_1-threadpoolexecutor" class="header-anchor">#</a> 1.ThreadPoolExecutor</h6> <p>先来看看 Java 线程池核心类 ThreadPoolExecutor 的构造函数, 需要知道 ThreadPoolExecutor 是如何使用这些参数的, 这是理解 Java 线程工作原理的关键.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
                          <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
                          <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>每次提交任务时, 如果线程数还没达到核心线程数 <strong>corePoolSize</strong>, 线程池就创建新线程来执行. 当线程数达到 **corePoolSize ** 后, 新增的任务就放到工作队列 **workQueue ** 里, 而线程池中的线程则努力地从 **workQueue ** 里拉活来干, 也就是调用 poll 方法来获取任务.</p> <p>如果任务很多, 并且 <strong>workQueue ** 是个有界队列, 队列可能会满, 此时线程池就会</strong>紧急创建新的临时线程**来救场, 如果总的线程数达到了最大线程数 <strong>maximumPoolSize</strong>, 则不能再创建新的临时线程了, 转而执行拒绝策略 <strong>handler</strong>, 比如抛出异常或者由调用者线程来执行任务等.</p> <p>如果高峰过去了, 线程池比较闲了怎么办? 临时线程使用 poll(<strong>keepAliveTime, unit</strong>) 方法从工作队列中拉活干, 请注意 poll 方法设置了超时时间, 如果超时了仍然两手空空没拉到活, 表明它太闲了, 这个线程会被销毁回收.</p> <p>那还有一个参数 <strong>threadFactory ** 是用来做什么的呢? 通过它你可以</strong>扩展原生的线程工厂**, 比如给创建出来的线程取个有意义的名字.</p> <h6 id="_2-fixedthreadpool-cachedthreadpool"><a href="#_2-fixedthreadpool-cachedthreadpool" class="header-anchor">#</a> 2.FixedThreadPool/CachedThreadPool</h6> <p>Java 提供了一些默认的线程池实现, 比如 FixedThreadPool 和 CachedThreadPool, 它们的本质就是给 ThreadPoolExecutor 设置了不同的参数, 是定制版的 ThreadPoolExecutor.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>
                                  <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span>
                                 <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">,</span>
                                  <span class="token number">60L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span>
                                  <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>从上面的代码可以看到:</p> <ul><li><strong>FixedThreadPool 有固定长度(nThreads)的线程数组</strong>, 忙不过来时会把任务放到无限长的队列里, 这是因为<strong>LinkedBlockingQueue 默认是一个无界队列</strong>.</li> <li><strong>CachedThreadPool 的 maximumPoolSize 参数值是</strong>​<strong>​<code>Integer.MAX_VALUE</code>​</strong>​, 因此它对线程个数不做限制, 忙不过来时无限创建临时线程, 闲下来时再回收. 它的任务队列是 <strong>SynchronousQueue</strong>, 表明队列长度为 0.</li></ul> <h5 id="tomcat线程池"><a href="#tomcat线程池" class="header-anchor">#</a> Tomcat线程池</h5> <p>跟 FixedThreadPool/CachedThreadPool 一样, Tomcat 的线程池也是一个<strong>定制版的 ThreadPoolExecutor</strong>.</p> <h6 id="_1-定制版的threadpoolexecutor"><a href="#_1-定制版的threadpoolexecutor" class="header-anchor">#</a> 1.定制版的ThreadPoolExecutor</h6> <p>通过比较 FixedThreadPool 和 CachedThreadPool, 可以发现它们传给 ThreadPoolExecutor 的参数有两个关键点:</p> <ul><li><p>**是否限制线程个数. **</p></li> <li><p>**是否限制队列长度. **</p> <div class="language- line-numbers-mode"><pre class="language-text"><code></code></pre> <div class="line-numbers-wrapper"></div></div></li></ul> <p>对于 Tomcat 来说, 这两个资源都需要限制, 也就是说要对高并发进行控制, 否则 CPU 和内存有资源耗尽的风险. 因此 Tomcat 传入的参数是这样的:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 定制版的任务队列</span>
taskqueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TaskQueue</span><span class="token punctuation">(</span>maxQueueSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// 定制版的线程工厂</span>
<span class="token class-name">TaskThreadFactory</span> tf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TaskThreadFactory</span><span class="token punctuation">(</span>namePrefix<span class="token punctuation">,</span> daemon<span class="token punctuation">,</span> <span class="token function">getThreadPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// 定制版的线程池</span>
executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token function">getMinSpareThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
                                  <span class="token function">getMaxThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
                                  maxIdleTime<span class="token punctuation">,</span> 
                                  <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span>
                                  taskqueue<span class="token punctuation">,</span> 
                                  tf<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>可以看到其中的两个关键点:</p> <ul><li>Tomcat 有自己的定制版任务队列和线程工厂, 并且可以限制任务队列的长度, 它的<strong>最大长度是 maxQueueSize</strong>.</li> <li>Tomcat 对线程数也有限制, 设置了<strong>核心线程数(minSpareThreads)和最大线程池数(maxThreads)</strong> .</li></ul> <p>除了资源限制以外, Tomcat 线程池还定制自己的任务处理流程. Java 原生线程池的任务处理逻辑比较简单:</p> <ol><li>前 corePoolSize 个任务时, 来一个任务就创建一个新线程.</li> <li>后面再来任务, 就把任务添加到任务队列里让所有的线程去抢, 如果队列满了就创建临时线程.</li> <li>如果总线程数达到 maximumPoolSize, **执行拒绝策略. **</li></ol> <p>Tomcat 线程池扩展了原生的 ThreadPoolExecutor, 通过<strong>重写 execute() 方法实现了自己的任务处理逻辑</strong>:</p> <ol><li>前 corePoolSize 个任务时, 来一个任务就创建一个新线程.</li> <li>再来任务的话, 就把任务添加到任务队列里让所有的线程去抢, 如果队列满了就创建临时线程.</li> <li>如果总线程数达到 maximumPoolSize, **则继续尝试把任务添加到任务队列中去. **</li> <li>**如果缓冲队列也满了, 插入失败, 执行拒绝策略. **</li></ol> <p>观察 Tomcat 线程池和 Java 原生线程池的区别, 其实就是在第 3 步, Tomcat 在线程总数达到最大数时, 不是立即执行拒绝策略, 而是再尝试向任务队列添加任务, 添加失败后再执行拒绝策略. 那具体如何实现呢, 其实很简单, 来看一下 Tomcat 线程池的 execute() 方法的核心代码.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutor</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span>ThreadPoolExecutor</span> <span class="token punctuation">{</span>
  
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      submittedCount<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token comment">// 调用 Java 原生线程池的 execute 去执行任务</span>
          <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RejectedExecutionException</span> rx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 如果总线程数达到 maximumPoolSize, Java 原生线程池执行拒绝策略</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">TaskQueue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">final</span> <span class="token class-name">TaskQueue</span> queue <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TaskQueue</span><span class="token punctuation">)</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">try</span> <span class="token punctuation">{</span>
                  <span class="token comment">// 继续尝试把任务放到任务队列中去</span>
                  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">force</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                      submittedCount<span class="token punctuation">.</span><span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                      <span class="token comment">// 如果缓冲队列也满了, 插入失败, 执行拒绝策略. </span>
                      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionException</span><span class="token punctuation">(</span><span class="token string">&quot;...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token punctuation">}</span>
              <span class="token punctuation">}</span> 
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>从这个方法可以看到, Tomcat 线程池的 execute() 方法会调用 Java 原生线程池的 execute() 去执行任务, 如果总线程数达到 maximumPoolSize, Java 原生线程池的 execute() 方法会抛出 RejectedExecutionException 异常, 但是这个异常会被 Tomcat 线程池的 execute() 方法捕获到, 并继续尝试把这个任务放到任务队列中去; 如果任务队列也满了, 再执行拒绝策略.</p> <h6 id="_2-定制版的任务队列"><a href="#_2-定制版的任务队列" class="header-anchor">#</a> 2.定制版的任务队列</h6> <p>细心的你有没有发现, 在 Tomcat 线程池的 execute() 方法最开始有这么一行:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>submittedCount<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这行代码的意思把 submittedCount 这个原子变量加一, 并且在任务执行失败, 抛出拒绝异常时, 将这个原子变量减一:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>submittedCount<span class="token punctuation">.</span><span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其实 Tomcat 线程池是用这个<strong>变量 submittedCount 来维护已经提交到了线程池, 但是还没有执行完的任务个数</strong>. Tomcat 为什么要维护这个变量呢? 这跟 Tomcat 的定制版的任务队列有关. Tomcat 的任务队列 TaskQueue 扩展了 Java 中的 LinkedBlockingQueue, 由于 LinkedBlockingQueue 默认情况下长度是没有限制的, 除非给它一个 capacity. 因此 Tomcat 给了它一个 capacity, TaskQueue 的构造函数中有个整型的参数 capacity, TaskQueue 将 capacity 传给父类 LinkedBlockingQueue 的构造函数.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TaskQueue</span> <span class="token keyword">extends</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
 
  <span class="token keyword">public</span> <span class="token class-name">TaskQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这个 capacity 参数是通过 Tomcat 的 maxQueueSize 参数来设置的, 但问题是默认情况下 maxQueueSize 的值是<code>Integer.MAX_VALUE</code>​, 等于没有限制, 这样就带来一个问题: 当前线程数达到核心线程数之后, 再来任务的话线程池会把任务添加到任务队列, 并且总是会成功, 这样永远不会有机会创建新线程了.</p> <p>为了解决这个问题, TaskQueue 重写了 LinkedBlockingQueue 的 offer() 方法, 在合适的时机返回 false, 返回 false 表示任务添加失败, 这时线程池会创建新的线程. 那什么是合适的时机呢? 看下面 offer() 方法的核心源码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TaskQueue</span> <span class="token keyword">extends</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

   <span class="token annotation punctuation">@Override</span>
  <span class="token comment">// 线程池调用任务队列的方法时, 当前线程数肯定已经大于核心线程数了</span>
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
      <span class="token comment">// 如果线程数已经到了最大值, 不能创建新线程了, 只能把任务添加到任务队列. </span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> parent<span class="token punctuation">.</span><span class="token function">getMaximumPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
          <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
      <span class="token comment">// 执行到这里, 表明当前线程数大于核心线程数, 并且小于最大线程数. </span>
      <span class="token comment">// 表明是可以创建新线程的, 那到底要不要创建呢? 分两种情况: </span>
  
      <span class="token comment">// 1. 如果已提交的任务数小于当前线程数, 表示还有空闲线程, 无需创建新线程</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">getSubmittedCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
          <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
      <span class="token comment">// 2. 如果已提交的任务数大于当前线程数, 线程不够用了, 返回 false 去创建新线程</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>parent<span class="token punctuation">.</span><span class="token function">getMaximumPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  
      <span class="token comment">// 默认情况下总是把任务添加到任务队列</span>
      <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>从上面的代码可以看到, <strong>只有当前线程数大于核心线程数, 小于最大线程数, 并且已提交的任务个数大于当前线程数时, 也就是说线程不够用了, 但是线程数又没达到极限, 才会去创建新的线程</strong>. 这就是为什么 Tomcat 需要维护已提交任务数这个变量, 它的目的就是<strong>在任务队列的长度无限制的情况下, 让线程池有机会创建新的线程</strong>.</p> <p>当然默认情况下 Tomcat 的任务队列是没有限制的, 可以通过设置 maxQueueSize 参数来限制任务队列的长度.</p> <h5 id="总结-5"><a href="#总结-5" class="header-anchor">#</a> 总结</h5> <p>池化的目的是为了避免频繁地创建和销毁对象, 减少对系统资源的消耗. Java 提供了默认的线程池实现, 也可以扩展 Java 原生的线程池来实现定制自己的线程池, Tomcat 就是这么做的. <strong>Tomcat 扩展了 Java 线程池的核心类 ThreadPoolExecutor, 并重写了它的 execute() 方法, 定制了自己的任务处理流程. 同时 Tomcat 还实现了定制版的任务队列, 重写了 offer() 方法, 使得在任务队列长度无限制的情况下, 线程池仍然有机会创建新的线程</strong>.</p> <h4 id="_18-新特性-tomcat如何支持websocket"><a href="#_18-新特性-tomcat如何支持websocket" class="header-anchor">#</a> 18.新特性:Tomcat如何支持WebSocket?</h4> <p>HTTP 协议是 &quot;请求-响应&quot; 模式, 浏览器必须先发请求给服务器, 服务器才会响应这个请求. 也就是说服务器不会主动发送数据给浏览器.</p> <p>对于实时性要求比较的高的应用, 比如在线游戏, 股票基金实时报价和在线协同编辑等, 浏览器需要实时显示服务器上最新的数据, 因此出现了 Ajax 和 Comet 技术. Ajax 本质上还是轮询, 而 Comet 是在 HTTP 长连接的基础上做了一些 hack, 但是它们的实时性不高, 另外频繁的请求会给服务器带来压力, 也会浪费网络流量和带宽. 于是 HTML5 推出了 <strong>WebSocket 标准, 使得浏览器和服务器之间任何一方都可以主动发消息给对方, 这样服务器有新数据时可以主动推送给浏览器.</strong></p> <p>这里介绍 WebSocket 的工作原理, 以及作为服务器端的 Tomcat 是如何支持 WebSocket 的. 更重要的是, 希望你在学完之后可以灵活地选用 WebSocket 技术来解决实际工作中的问题.</p> <h5 id="websocket工作原理"><a href="#websocket工作原理" class="header-anchor">#</a> WebSocket工作原理</h5> <p>WebSocket 的名字里带有 Socket, 那 Socket 是什么呢? 网络上的两个程序通过一个双向链路进行通信, 这个双向链路的一端称为一个 Socket. 一个 Socket 对应一个 IP 地址和端口号, 应用程序通常通过 Socket 向网络发出请求或者应答网络请求. Socket 不是协议, 它其实是对 TCP/IP 协议层抽象出来的 API.</p> <p>但 WebSocket 不是一套 API, 跟 HTTP 协议一样, <strong>WebSocket 也是一个应用层协议</strong>. 为了跟现有的 HTTP 协议保持兼容, 它通过 HTTP 协议进行一次握手, 握手之后数据就直接从 TCP 层的 Socket 传输, 就与 HTTP 协议无关了. 浏览器发给服务端的请求会带上跟 WebSocket 有关的请求头, 比如 <code>Connection: Upgrade</code>​ 和 <code>Upgrade: websocket</code>​.</p> <p><img src="/img/image-20230405161452-10t1maz.png" alt="image"></p> <p>如果服务器支持 WebSocket, 同样会在 HTTP 响应里加上 WebSocket 相关的 HTTP 头部.</p> <p><img src="/img/image-20230405161521-r3e8u27.png" alt="image"></p> <p>这样 WebSocket 连接就建立好了, 接下来 WebSocket 的<strong>数据传输会以 frame 形式传输</strong>, 会将一条消息分为几个 frame, 按照先后顺序传输出去. 这样做的好处有:</p> <ul><li>大数据的传输可以分片传输, 不用考虑数据大小的问题.</li> <li>和 HTTP 的 chunk 一样, 可以边生成数据边传输, 提高传输效率.</li></ul> <h5 id="tomcat如何支持websocket"><a href="#tomcat如何支持websocket" class="header-anchor">#</a> Tomcat如何支持WebSocket</h5> <p>在讲 Tomcat 如何支持 WebSocket 之前, 先来开发一个简单的聊天室程序, 需求是: 用户可以通过浏览器加入聊天室, 发送消息, 聊天室的其他人都可以收到消息.</p> <h6 id="_1-websocket聊天室程序"><a href="#_1-websocket聊天室程序" class="header-anchor">#</a> 1.WebSocket聊天室程序</h6> <p>浏览器端 JavaScript 核心代码如下:</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> Chat <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Chat<span class="token punctuation">.</span>socket <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
Chat<span class="token punctuation">.</span>connect <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">host</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
    <span class="token comment">// 判断当前浏览器是否支持 WebSocket</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'WebSocket'</span> <span class="token keyword">in</span> window<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果支持则创建 WebSocket JS 类</span>
        Chat<span class="token punctuation">.</span>socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'MozWebSocket'</span> <span class="token keyword">in</span> window<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Chat<span class="token punctuation">.</span>socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MozWebSocket</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'WebSocket is not supported by this browser.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">// 回调函数, 当和服务器的 WebSocket 连接建立起来后, 浏览器会回调这个方法</span>
    Chat<span class="token punctuation">.</span>socket<span class="token punctuation">.</span><span class="token function-variable function">onopen</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Info: WebSocket connection opened.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'chat'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onkeydown</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>keyCode <span class="token operator">==</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                Chat<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
 
    <span class="token comment">// 回调函数, 当和服务器的 WebSocket 连接关闭后, 浏览器会回调这个方法</span>
    Chat<span class="token punctuation">.</span>socket<span class="token punctuation">.</span><span class="token function-variable function">onclose</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'chat'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>onkeydown <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Info: WebSocket closed.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
 
    <span class="token comment">// 回调函数, 当服务器有新消息发送到浏览器, 浏览器会回调这个方法</span>
    Chat<span class="token punctuation">.</span>socket<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p>上面的代码实现逻辑比较清晰, 就是创建一个 WebSocket JavaScript 对象, 然后实现了几个回调方法: onopen, onclose 和 onmessage. 当连接建立, 关闭和有新消息时, 浏览器会负责调用这些回调方法. 再来看服务器端 Tomcat 的实现代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Tomcat 端的实现类加上 @ServerEndpoint 注解, 里面的 value 是 URL 路径</span>
<span class="token annotation punctuation">@ServerEndpoint</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;/websocket/chat&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChatEndpoint</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">GUEST_PREFIX</span> <span class="token operator">=</span> <span class="token string">&quot;Guest&quot;</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 记录当前有多少个用户加入到了聊天室, 它是 static 全局变量. 为了多线程安全使用原子变量 AtomicInteger</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> connectionIds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 每个用户用一个 CharAnnotation 实例来维护, 请你注意它是一个全局的 static 变量, 所以用到了线程安全的 CopyOnWriteArraySet</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ChatEndpoint</span><span class="token punctuation">&gt;</span></span> connections <span class="token operator">=</span>
            <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArraySet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> nickname<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Session</span> session<span class="token punctuation">;</span>
 
    <span class="token keyword">public</span> <span class="token class-name">ChatEndpoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nickname <span class="token operator">=</span> <span class="token constant">GUEST_PREFIX</span> <span class="token operator">+</span> connectionIds<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">// 新连接到达时, Tomcat 会创建一个 Session, 并回调这个函数</span>
    <span class="token annotation punctuation">@OnOpen</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token class-name">Session</span> session<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>session <span class="token operator">=</span> session<span class="token punctuation">;</span>
        connections<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;* %s %s&quot;</span><span class="token punctuation">,</span> nickname<span class="token punctuation">,</span> <span class="token string">&quot;has joined.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">broadcast</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
   <span class="token comment">// 浏览器关闭连接时, Tomcat 会回调这个函数</span>
    <span class="token annotation punctuation">@OnClose</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        connections<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;* %s %s&quot;</span><span class="token punctuation">,</span>
                nickname<span class="token punctuation">,</span> <span class="token string">&quot;has disconnected.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">broadcast</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">// 浏览器发送消息到服务器时, Tomcat 会回调这个函数</span>
    <span class="token annotation punctuation">@OnMessage</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">incoming</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Never trust the client</span>
        <span class="token class-name">String</span> filteredMessage <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;%s: %s&quot;</span><span class="token punctuation">,</span>
                nickname<span class="token punctuation">,</span> <span class="token class-name">HTMLFilter</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">broadcast</span><span class="token punctuation">(</span>filteredMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">// Websocket 连接出错时, Tomcat 会回调这个函数</span>
    <span class="token annotation punctuation">@OnError</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onError</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;Chat Error: &quot;</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">// 向聊天室中的每个用户广播消息</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">broadcast</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ChatAnnotation</span> client <span class="token operator">:</span> connections<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>client<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    client<span class="token punctuation">.</span>session<span class="token punctuation">.</span><span class="token function">getBasicRemote</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sendText</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token comment">// ...</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br></div></div><p>根据 Java WebSocket 规范的规定, Java WebSocket 应用程序由一系列的 <strong>WebSocket Endpoint</strong> 组成. <strong>Endpoint 是一个 Java 对象, 代表 WebSocket 连接的一端, 就好像处理 HTTP 请求的 Servlet 一样, 可以把它看作是处理 WebSocket 消息的接口</strong>. 跟 Servlet 不同的地方在于, Tomcat 会给每一个 WebSocket 连接创建一个 Endpoint 实例. 可以通过两种方式定义和实现 Endpoint.</p> <p>第一种方法是<strong>编程式</strong>的, 就是编写一个 Java 类继承 <code>javax.websocket.Endpoint</code>​, 并实现它的 onOpen, onClose 和 onError 方法. 这些方法跟 Endpoint 的生命周期有关, Tomcat 负责管理 Endpoint 的生命周期并调用这些方法. 并且当浏览器连接到一个 Endpoint 时, Tomcat 会给这个连接创建一个唯一的 Session(<code>javax.websocket.Session</code>​). Session 在 WebSocket 连接握手成功之后创建, 并在连接关闭时销毁. 当触发 Endpoint 各个生命周期事件时, Tomcat 会将当前 Session 作为参数传给 Endpoint 的回调方法, 因此一个 Endpoint 实例对应一个 Session, 通过在 Session 中添加 MessageHandler 消息处理器来接收消息, MessageHandler 中定义了 onMessage 方法. **在这里 Session 的本质是对 Socket 的封装, Endpoint 通过它与浏览器通信. **</p> <p>第二种定义 Endpoint 的方法是<strong>注解式</strong>的, 也就是上面的聊天室程序例子中用到的方式, 即实现一个业务类并给它添加 WebSocket 相关的注解. 首先注意到 <code>@ServerEndpoint(value = &quot;/websocket/chat&quot;)</code>​ 注解, 它表明当前业务类 ChatEndpoint 是一个实现了 WebSocket 规范的 Endpoint, 并且注解的 value 值表明 ChatEndpoint 映射的 URL 是 <code>/websocket/chat</code>​. 还看到 ChatEndpoint 类中有 <code>@OnOpen</code>​, <code>@OnClose</code>​, <code>@OnError</code>​和在<code>@OnMessage</code>​ 注解的方法, 从名字就知道它们的功能是什么.</p> <p>对于程序员来说, 其实只需要专注具体的 Endpoint 的实现, 比如在上面聊天室的例子中, 为了方便向所有人群发消息, ChatEndpoint 在内部使用了一个全局静态的集合 CopyOnWriteArraySet 来维护所有的 ChatEndpoint 实例, 因为每一个 ChatEndpoint 实例对应一个 WebSocket 连接, 也就是代表了一个加入聊天室的用户. **当某个 ChatEndpoint 实例收到来自浏览器的消息时, 这个 ChatEndpoint 会向集合中其他 ChatEndpoint 实例背后的 WebSocket 连接推送消息. **</p> <p>那么这个过程中, Tomcat 主要做了哪些事情呢? 简单来说就是两件事情: <strong>Endpoint 加载和 WebSocket 请求处理</strong>. 下面分别来详细说说 Tomcat 是如何做这两件事情的.</p> <h6 id="_2-websocket加载"><a href="#_2-websocket加载" class="header-anchor">#</a> 2.WebSocket加载</h6> <p>Tomcat 的 WebSocket 加载是通过 SCI 机制完成的. SCI 全称 <strong>ServletContainerInitializer</strong>, 是 Servlet 3.0 规范中定义的用来<strong>接收 Web 应用启动事件的接口</strong>. 那为什么要监听 Servlet 容器的启动事件呢? 因为这样有机会在 Web 应用启动时做一些<strong>初始化工作</strong>, 比如 WebSocket 需要扫描和加载 Endpoint 类. SCI 的使用也比较简单, <strong>将实现 ServletContainerInitializer 接口的类增加 HandlesTypes 注解, 并且在注解内指定的一系列类和接口集合</strong>. 比如 Tomcat 为了扫描和加载 Endpoint 而定义的 SCI 类如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@HandlesTypes</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ServerEndpoint</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">ServerApplicationConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Endpoint</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WsSci</span> <span class="token keyword">implements</span> <span class="token class-name">ServletContainerInitializer</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStartup</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> clazzes<span class="token punctuation">,</span> <span class="token class-name">ServletContext</span> ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>一旦定义好了 SCI, Tomcat 在启动阶段扫描类时, 会将 HandlesTypes 注解中指定的类都扫描出来, 作为 SCI 的 onStartup() 方法的参数, 并调用 SCI 的 onStartup() 方法. 注意到 WsSci 的 HandlesTypes 注解中定义了<code>ServerEndpoint.class</code>​, <code>ServerApplicationConfig.class</code>​ 和 <code>Endpoint.class</code>​, 因此在 Tomcat 的启动阶段会将这些类的类实例(注意不是对象实例)传递给 WsSci 的 onStartup() 方法. 那么 WsSci 的 onStartup() 方法又做了什么事呢?</p> <p>它会构造一个 WebSocketContainer 实例, 可以把 WebSocketContainer 理解成一个专门处理 WebSocket 请求的 <strong>Endpoint 容器</strong>. 也就是说 Tomcat 会把扫描到的 Endpoint 子类和添加了注解 <code>@ServerEndpoint</code>​ 的类注册到这个容器中, 并且这个容器还维护了 URL 到 Endpoint 的映射关系, 这样通过请求 URL 就能找到具体的 Endpoint 来处理 WebSocket 请求.</p> <h6 id="_3-websocket请求处理"><a href="#_3-websocket请求处理" class="header-anchor">#</a> 3.WebSocket请求处理</h6> <p>在讲 WebSocket 请求处理之前, 先来回顾一下 Tomcat 连接器的组件图.</p> <p><img src="/img/image-20230405161429-w1czmc5.jpg" alt=""></p> <p>可以看到 Tomcat 用 ProtocolHandler 组件屏蔽应用层协议的差异, 其中 <strong>ProtocolHandler 中有两个关键组件: Endpoint 和 Processor</strong>. 需要注意, 这里的 Endpoint 跟上文提到的 WebSocket 中的 Endpoint 完全是<mark><strong>两回事</strong></mark>, <strong>连接器中的 Endpoint 组件用来处理 I/O 通信. WebSocket 本质就是一个应用层协议, 因此不能用 HttpProcessor 来处理 WebSocket 请求, 而要用专门 Processor 来处理, 而在 Tomcat 中这样的 Processor 叫作 UpgradeProcessor</strong>.</p> <p>为什么叫 Upgrade Processor 呢? 这是因为 <strong>Tomcat 是将 HTTP 协议升级成 WebSocket 协议的</strong>, 由于 WebSocket 是通过 HTTP 协议来进行握手的, 因此当 WebSocket 的握手请求到来时, HttpProtocolHandler 首先接收到这个请求, 在处理这个 HTTP 请求时, Tomcat 通过一个特殊的 Filter 判断该当前 HTTP <strong>请求是否是一个 WebSocket Upgrade 请求</strong>(即包含<code>Upgrade: websocket</code>​的 HTTP 头信息), 如果是, 则在 HTTP 响应里添加 WebSocket 相关的响应头信息, 并进行<strong>协议升级</strong>. 具体来说就是用 UpgradeProtocolHandler 替换当前的 HttpProtocolHandler, 相应的, 把当前 Socket 的 Processor 替换成 <strong>UpgradeProcessor</strong>, 同时 Tomcat 会创建 WebSocket Session 实例和 Endpoint 实例, 并跟当前的 WebSocket 连接一一对应起来. 这个 WebSocket 连接不会立即关闭, 并且在请求处理中, 不再使用原有的 HttpProcessor, 而是用专门的 UpgradeProcessor, UpgradeProcessor 最终会调用相应的 Endpoint 实例来处理请求. 下面通过一张图来理解一下.</p> <p><img src="/img/image-20230405161429-as6e7rp.jpg" alt=""></p> <p><strong>可以看到, Tomcat 对 WebSocket 请求的处理没有经过 Servlet 容器, 而是通过 UpgradeProcessor 组件直接把请求发到 ServerEndpoint 实例, 并且 Tomcat 的 WebSocket 实现不需要关注具体 I/O 模型的细节, 从而实现了与具体 I/O 方式的解耦.</strong></p> <h5 id="总结-6"><a href="#总结-6" class="header-anchor">#</a> 总结</h5> <p>WebSocket 技术实现了 Tomcat 与浏览器的双向通信, Tomcat 可以主动向浏览器推送数据, 可以用来实现对数据实时性要求比较高的应用. 这需要浏览器和 Web 服务器同时支持 WebSocket 标准, Tomcat 启动时通过 SCI 技术来扫描和加载 WebSocket 的处理类 ServerEndpoint, 并且建立起了 URL 到 ServerEndpoint 的映射关系.</p> <p><strong>当第一个 WebSocket 请求到达时, Tomcat 将 HTTP 协议升级成 WebSocket 协议, 并将该 Socket 连接的 Processor 替换成 UpgradeProcessor. 这个 Socket 不会立即关闭, 对接下来的请求, Tomcat 通过 UpgradeProcessor 直接调用相应的 ServerEndpoint 来处理.</strong></p> <h4 id="_19-比较-jetty的线程策略eatwhatyoukill"><a href="#_19-比较-jetty的线程策略eatwhatyoukill" class="header-anchor">#</a> 19.比较:Jetty的线程策略EatWhatYouKill</h4> <p>前面已经介绍了 Jetty 的总体架构设计, 回顾一下, Jetty 总体上是由一系列 Connector, 一系列 Handler 和一个 ThreadPool 组成, 它们的关系如下图所示:</p> <p><img src="/img/image-20230405161545-q6zeqaq.jpg" alt=""></p> <p>相比较 Tomcat 的连接器, Jetty 的 Connector 在设计上有自己的特点. Jetty 的 Connector 支持 NIO 通信模型, 由于 <strong>NIO 模型中的主角就是 Selector</strong>, Jetty 在 Java 原生 Selector 的基础上封装了自己的 Selector, 叫作 ManagedSelector. ManagedSelector 在线程策略方面做了大胆尝试, 将 I/O 事件的侦测和处理放到同一个线程来处理, 充分利用了 CPU 缓存并减少了线程上下文切换的开销.</p> <p>具体的数字是, 根据 Jetty 的官方测试, 这种<strong>名为 &quot;EatWhatYouKill&quot; 的线程策略将吞吐量提高了 8 倍</strong>. 这里来看一看这背后的原理是什么.</p> <h5 id="selector编程的一般思路"><a href="#selector编程的一般思路" class="header-anchor">#</a> Selector编程的一般思路</h5> <p>常规的 NIO 编程思路是, 将 I/O 事件的侦测和请求的处理分别用不同的线程处理. 具体过程是:</p> <p>**启动一个线程, 在一个死循环里不断地调用 select 方法, 检测 Channel 的 I/O 状态, 一旦 I/O 事件达到, 比如数据就绪, 就把该 I/O 事件以及一些数据包装成一个 Runnable, 将 Runnable 放到新线程中去处理. **</p> <p>在这个过程中按照职责划分, 有两个线程在干活, <strong>一个是 I/O 事件检测线程, 另一个是 I/O 事件处理线程</strong>. 仔细思考一下这两者的关系, 其实它们是生产者和消费者的关系. I/O 事件侦测线程作为生产者, 负责 &quot;生产&quot; I/O 事件, 也就是负责接活儿的老板; I/O 处理线程是消费者, 它 &quot;消费&quot; 并处理 I/O 事件, 就是干苦力的员工. 把这两个工作用不同的线程来处理, 好处是它们互不干扰和阻塞对方.</p> <h5 id="jetty中的selector编程"><a href="#jetty中的selector编程" class="header-anchor">#</a> Jetty中的Selector编程</h5> <p>然而世事无绝对, 将 I/O 事件检测和业务处理这两种工作分开的思路也有缺点. 当 Selector 检测读就绪事件时, <strong>数据已经被拷贝到内核中的缓存</strong>了, 同时 CPU 的缓存中也有这些数据了, 由于 CPU 本身的缓存比内存快多了, 这时当应用程序去读取这些数据时, 如果用另一个线程去读, 很有可能这个读线程使用另一个 CPU 核, 而不是之前那个检测数据就绪的 CPU 核, 这样 CPU 缓存中的数据就用不上了, 并且线程切换也需要开销.</p> <p>因此 Jetty 的 Connector 做了一个大胆尝试, 那就是用<strong>把 I/O 事件的生产和消费放到同一个线程来处理</strong>, 如果这两个任务由同一个线程来执行, 如果执行过程中<strong>线程不阻塞</strong>, 操作系统会用同一个 CPU 核来执行这两个任务, 这样就能<strong>利用 CPU 缓存</strong>了. 那具体是如何做的呢, 还是来详细分析一下 Connector 中的 ManagedSelector 组件.</p> <h6 id="_1-managedselector"><a href="#_1-managedselector" class="header-anchor">#</a> 1.ManagedSelector</h6> <p>ManagedSelector 的本质就是一个 Selector, 负责 I/O 事件的检测和分发. 为了方便使用, Jetty 在 Java 原生的 Selector 上做了一些扩展, 就变成了 <strong>ManagedSelector</strong>, 先来看看它有哪些成员变量:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ManagedSelector</span> <span class="token keyword">extends</span> <span class="token class-name">ContainerLifeCycle</span> <span class="token keyword">implements</span> <span class="token class-name">Dumpable</span> <span class="token punctuation">{</span>
    <span class="token comment">// 原子变量, 表明当前的 ManagedSelector 是否已经启动</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicBoolean</span> _started <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicBoolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 表明是否阻塞在 select 调用上</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> _selecting <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 管理器的引用, SelectorManager 管理若干 ManagedSelector 的生命周期</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">SelectorManager</span> _selectorManager<span class="token punctuation">;</span>
  
    <span class="token comment">//ManagedSelector 不止一个, 为它们每人分配一个 id</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _id<span class="token punctuation">;</span>
  
    <span class="token comment">// 关键的执行策略, 生产者和消费者是否在同一个线程处理由它决定</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ExecutionStrategy</span> _strategy<span class="token punctuation">;</span>
  
    <span class="token comment">//Java 原生的 Selector</span>
    <span class="token keyword">private</span> <span class="token class-name">Selector</span> _selector<span class="token punctuation">;</span>
  
    <span class="token comment">//&quot;Selector 更新任务 &quot; 队列</span>
    <span class="token keyword">private</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectorUpdate</span><span class="token punctuation">&gt;</span></span> _updates <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectorUpdate</span><span class="token punctuation">&gt;</span></span> _updateable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>这些成员变量中其他的都好理解, 就是 &quot;Selector 更新任务&quot; 队列 <code>_updates</code>​ 和执行策略 <code>_strategy</code>​ 可能不是很直观.</p> <h6 id="_1-selectorupdate接口"><a href="#_1-selectorupdate接口" class="header-anchor">#</a> 1.SelectorUpdate接口</h6> <p>为什么需要一个 &quot;Selector 更新任务&quot; 队列呢, 对于 Selector 的用户来说, 对 Selector 的操作无非是将 Channel 注册到 Selector 或者告诉 Selector 我对什么 I/O 事件感兴趣, 那么这些操作其实就是对 Selector 状态的更新, Jetty 把这些操作抽象成 <strong>SelectorUpdate 接口</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * A selector update to be done when the selector has been woken.
 */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SelectorUpdate</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">Selector</span> selector<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这意味着不能直接操作 ManageSelector 中的 Selector, 而是需要向 ManagedSelector 提交一个任务类, 这个类需要实现 SelectorUpdate 接口 update() 方法, 在 update() 方法里定义想要对 ManagedSelector 做的操作.</p> <p>比如 Connector 中 Endpoint 组件对读就绪事件感兴趣, 它就向 ManagedSelector 提交了一个内部任务类 ManagedSelector.SelectorUpdate():</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>_selector<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>_updateKeyAction<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这个 <code>_updateKeyAction</code>​ 就是一个 SelectorUpdate 实例, 它的 update() 方法实现如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ManagedSelector<span class="token punctuation">.</span>SelectorUpdate</span> _updateKeyAction <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ManagedSelector<span class="token punctuation">.</span>SelectorUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">Selector</span> selector<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里的 updateKey 其实就是调用了 SelectionKey.interestOps(OP_READ);</span>
        <span class="token function">updateKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>可以看到在 update() 方法里, 调用了 SelectionKey 类的 interestOps() 方法, 传入的参数是 <code>OP_READ</code>​, 意思是现在我对这个 Channel 上的读就绪事件感兴趣了.</p> <p>那谁来负责执行这些 update() 方法呢, 答案是 ManagedSelector 自己, 它在一个<strong>死循环里拉取这些 SelectorUpdate 任务类逐个执行</strong>.</p> <h6 id="_2-selectable接口"><a href="#_2-selectable接口" class="header-anchor">#</a> 2.Selectable接口</h6> <p>那 I/O 事件到达时, ManagedSelector 怎么知道应该调哪个函数来处理呢? 其实也是通过一个<strong>任务类接口, 这个接口就是 Selectable</strong>, 它返回一个 Runnable, <strong>这个 Runnable 其实就是 I/O 事件就绪时相应的处理逻辑</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Selectable</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当某一个 Channel 的 I/O 事件就绪后, ManagedSelector 会调用的回调函数</span>
    <span class="token class-name">Runnable</span> <span class="token function">onSelected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment">// 当所有事件处理完了之后 ManagedSelector 会调的回调函数, 先忽略. </span>
    <span class="token keyword">void</span> <span class="token function">updateKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>ManagedSelector 在检测到某个 Channel 上的 I/O 事件就绪时, 也就是说这个 Channel 被选中了, ManagedSelector 调用这个 Channel 所绑定的附件类的 <strong>onSelected() 方法来拿到一个 Runnable</strong>.</p> <p>这句话有点绕, 其实就是 ManagedSelector 的使用者, 比如 Endpoint 组件在向 ManagedSelector 注册读就绪事件时, 同时也要告诉 ManagedSelector 在事件就绪时执行什么任务, 具体来说就是传入一个附件类, 这个附件类需要实现 Selectable 接口. ManagedSelector <strong>通过调用这个 onSelected() 拿到一个 Runnable, 然后把 Runnable 扔给线程池去执行</strong>.</p> <p>那 Endpoint 的 onSelected() 是如何实现的呢?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">Runnable</span> <span class="token function">onSelected</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> readyOps <span class="token operator">=</span> _key<span class="token punctuation">.</span><span class="token function">readyOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">boolean</span> fillable <span class="token operator">=</span> <span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_READ</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> flushable <span class="token operator">=</span> <span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_WRITE</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 
    <span class="token comment">// return task to complete the job</span>
    <span class="token class-name">Runnable</span> task<span class="token operator">=</span> fillable 
            <span class="token operator">?</span> <span class="token punctuation">(</span>flushable 
                    <span class="token operator">?</span> _runCompleteWriteFillable 
                    <span class="token operator">:</span> _runFillable<span class="token punctuation">)</span>
            <span class="token operator">:</span> <span class="token punctuation">(</span>flushable 
                    <span class="token operator">?</span> _runCompleteWrite 
                    <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">return</span> task<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>上面的代码逻辑很简单, 就是读事件到了就读, 写事件到了就写.</p> <h6 id="_3-executionstrategy"><a href="#_3-executionstrategy" class="header-anchor">#</a> 3.ExecutionStrategy</h6> <p>铺垫了这么多, 终于要上主菜了. 前面主要介绍了 ManagedSelector 的使用者如何跟 ManagedSelector 交互, 也就是如何注册 Channel 以及 I/O 事件, 提供什么样的处理类来处理 I/O 事件, 接下来<strong>看看 ManagedSelector 是如何统一管理和维护用户注册的 Channel 集合</strong>. 再回到开始的讨论, ManagedSelector 将 I/O 事件的生产和消费看作是生产者消费者模式, 为了充分利用 CPU 缓存, 生产和消费尽量放到同一个线程处理, 那这是如何实现的呢? Jetty 定义了 ExecutionStrategy 接口:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ExecutionStrategy</span> <span class="token punctuation">{</span>
    <span class="token comment">// 只在 HTTP2 中用到, 简单起见, 先忽略这个方法. </span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment">// 实现具体执行策略, 任务生产出来后可能由当前线程执行, 也可能由新线程来执行</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 任务的生产委托给 Producer 内部接口</span>
    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Producer</span> <span class="token punctuation">{</span>
        <span class="token comment">// 生产一个 Runnable(任务)</span>
        <span class="token class-name">Runnable</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>可以看到 ExecutionStrategy 接口比较简单, 它将具体任务的生产委托内部接口 Producer, 而在自己的 produce() 方法里来实现具体执行逻辑, <strong>也就是生产出来的任务要么由当前线程执行, 要么放到新线程中执行</strong>. Jetty 提供了一些具体策略实现类: <strong>ProduceConsume, ProduceExecuteConsume, ExecuteProduceConsume 和 EatWhatYouKill</strong>. 它们的区别是:</p> <ul><li><strong>ProduceConsume</strong>: 任务生产者<strong>自己依次生产和执行任务</strong>, 对应到 NIO 通信模型就是用一个线程来侦测和处理一个 ManagedSelector 上所有的 I/O 事件, 后面的 I/O 事件要等待前面的 I/O 事件处理完, 效率明显不高. 通过图来理解, 图中绿色表示生产一个任务, 蓝色表示执行这个任务.</li></ul> <p><img src="/img/image-20230405161601-qvnftiu.png" alt="image"></p> <ul><li><strong>ProduceExecuteConsume</strong>: 任务生产者<strong>开启新线程来运行任务</strong>, 这是典型的 I/O 事件侦测和处理用不同的线程来处理, 缺点是不能利用 CPU 缓存, 并且线程切换成本高. 同样通过一张图来理解, 图中的棕色表示线程切换.</li></ul> <p><img src="/img/image-20230405161545-swc13gz.png" alt=""></p> <ul><li><strong>ExecuteProduceConsume</strong>: 任务生产者<strong>自己运行任务</strong>, 但是该策略可能会新建一个新线程以继续生产和执行任务. 这种策略也被称为 &quot;吃掉你杀的猎物&quot;, 它来自狩猎伦理, 认为一个人不应该杀死他不吃掉的东西, 对应线程来说, 不应该生成自己不打算运行的任务. 它的优点是能利用 CPU 缓存, 但是潜在的问题是如果处理 I/O 事件的业务代码执行时间过长, 会导致线程大量阻塞和线程饥饿.</li></ul> <p><img src="/img/image-20230405161545-cezjxrf.png" alt=""></p> <ul><li><strong>EatWhatYouKill</strong>: 这是 Jetty 对 ExecuteProduceConsume 策略的<strong>改良</strong>, <strong>在线程池线程充足的情况下等同于 ExecuteProduceConsume; 当系统比较忙线程不够时, 切换成 ProduceExecuteConsume 策略</strong>. 为什么要这么做呢, 原因是 ExecuteProduceConsume 是在同一线程执行 I/O 事件的生产和消费, 它使用的线程来自 Jetty 全局的线程池, 这些线程有可能被业务代码阻塞, 如果阻塞得多了, 全局线程池中的线程自然就不够用了, 最坏的情况是连 I/O 事件的侦测都没有线程可用了, 会导致 Connector 拒绝浏览器请求. 于是 Jetty 做了一个优化, <strong>在低线程情况下, 就执行 ProduceExecuteConsume 策略, I/O 侦测用专门的线程处理, I/O 事件的处理扔给线程池处理, 其实就是放到线程池的队列里慢慢处理</strong>.</li></ul> <p>分析了这几种线程策略, 再来看看 Jetty 是如何实现 ExecutionStrategy 接口的. 答案其实就是实现 produce 接口生产任务, 一旦任务生产出来, ExecutionStrategy 会负责执行这个任务.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">SelectorProducer</span> <span class="token keyword">implements</span> <span class="token class-name">ExecutionStrategy<span class="token punctuation">.</span>Producer</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">&gt;</span></span> _keys <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">emptySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">&gt;</span></span> _cursor <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">emptyIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Runnable</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如何 Channel 集合中有 I/O 事件就绪, 调用前面提到的 Selectable 接口获取 Runnable, 直接返回给 ExecutionStrategy 去处理</span>
            <span class="token class-name">Runnable</span> task <span class="token operator">=</span> <span class="token function">processSelected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> task<span class="token punctuation">;</span>
    
           <span class="token comment">// 如果没有 I/O 事件就绪, 就干点杂活, 看看有没有客户提交了更新 Selector 的任务, 就是上面提到的 SelectorUpdate 任务类. </span>
            <span class="token function">processUpdates</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">updateKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
           <span class="token comment">// 继续执行 select 方法, 侦测 I/O 就绪事件</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>SelectorProducer 是 ManagedSelector 的内部类, SelectorProducer 实现了 ExecutionStrategy 中的 Producer 接口中的 produce() 方法, 需要向 ExecutionStrategy 返回一个 Runnable. 在这个方法里 SelectorProducer 主要干了三件事情</p> <ol><li>如果 Channel 集合中有 I/O 事件就绪, 调用前面提到的 Selectable 接口获取 Runnable, 直接返回给 ExecutionStrategy 去处理.</li> <li>如果没有 I/O 事件就绪, 就干点杂活, 看看有没有客户提交了更新 Selector 上事件注册的任务, 也就是上面提到的 SelectorUpdate 任务类.</li> <li>干完杂活继续执行 select 方法, 侦测 I/O 就绪事件.</li></ol> <h5 id="总结-7"><a href="#总结-7" class="header-anchor">#</a> 总结</h5> <p>多线程虽然是提高并发的法宝, 但并不是说线程越多越好, CPU 缓存以及线程上下文切换的开销也是需要考虑的. <strong>Jetty 巧妙设计了 EatWhatYouKill 的线程策略, 尽量用同一个线程侦测 I/O 事件和处理 I/O 事件, 充分利用了 CPU 缓存, 并减少了线程切换的开销</strong>.</p> <h4 id="_20-总结-tomcat和jetty中的对象池技术"><a href="#_20-总结-tomcat和jetty中的对象池技术" class="header-anchor">#</a> 20.总结:Tomcat和Jetty中的对象池技术</h4> <p>Java 对象, 特别是一个比较大, 比较复杂的 Java 对象, 它们的创建, 初始化和 GC 都需要耗费 CPU 和内存资源, 为了减少这些开销, Tomcat 和 Jetty 都使用了<strong>对象池技术</strong>. 所谓的<strong>对象池技术, 就是说一个 Java 对象用完之后把它保存起来, 之后再拿出来重复使用, 省去了对象创建, 初始化和 GC 的过程</strong>. 对象池技术是典型的以<strong>空间换时间</strong>的思路.</p> <p>由于维护对象池本身也需要资源的开销, 不是所有场景都适合用对象池. <strong>如果你的 Java 对象数量很多并且存在的时间比较短, 对象本身又比较大比较复杂, 对象初始化的成本比较高, 这样的场景就适合用对象池技术</strong>. 比如 Tomcat 和 Jetty 处理 HTTP 请求的场景就符合这个特征, 请求的数量很多, 为了处理单个请求需要创建不少的复杂对象(比如 Tomcat 连接器中 SocketWrapper 和 SocketProcessor), 而且一般来说请求处理的时间比较短, 一旦请求处理完毕, 这些对象就需要被销毁, 因此这个场景适合对象池技术.</p> <h5 id="tomcat的synchronizedstack"><a href="#tomcat的synchronizedstack" class="header-anchor">#</a> Tomcat的SynchronizedStack</h5> <p>Tomcat 用 <strong>SynchronizedStack 类</strong>来实现对象池, 下面是它的关键代码.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedStack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
 
    <span class="token comment">// 内部维护一个对象数组, 用数组实现栈的功能</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> stack<span class="token punctuation">;</span>
 
    <span class="token comment">// 这个方法用来归还对象, 用 synchronized 进行线程同步</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">T</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        index<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>limit <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> size <span class="token operator">&lt;</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">expand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 对象不够用了, 扩展对象数组</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                index<span class="token operator">--</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        stack<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
    <span class="token comment">// 这个方法用来获取对象</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">T</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">T</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> stack<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
        stack<span class="token punctuation">[</span>index<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
    <span class="token comment">// 扩展对象数组长度, 以 2 倍大小扩展</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">expand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">int</span> newSize <span class="token operator">=</span> size <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>limit <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> newSize <span class="token operator">&gt;</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          newSize <span class="token operator">=</span> limit<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 扩展策略是创建一个数组长度为原来两倍的新数组</span>
      <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>newSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token comment">// 将老数组对象引用复制到新数组</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newStack<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 将 stack 指向新数组, 老数组可以被 GC 掉了</span>
      stack <span class="token operator">=</span> newStack<span class="token punctuation">;</span>
      size <span class="token operator">=</span> newSize<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><p>这个代码逻辑比较清晰, 主要是 SynchronizedStack 内部维护了一个<strong>对象数组</strong>, 并且用数组来实现栈的接口: <strong>push() 和 pop() 方法, 这两个方法分别用来归还对象和获取对象</strong>. 你可能好奇为什么 Tomcat 使用一个看起来比较简单的 SynchronizedStack 来做对象容器, 为什么不使用高级一点的并发容器比如 ConcurrentLinkedQueue 呢?</p> <p>这是<strong>因为 SynchronizedStack 用数组而不是链表来维护对象, 可以减少结点维护的内存开销, 并且它本身只支持扩容不支持缩容, 也就是说数组对象在使用过程中不会被重新赋值, 也就不会被 GC</strong>. 这样设计的目的是用最低的内存和 GC 的代价来实现无界容器, 同时 Tomcat 的最大同时请求数是有限制的, 因此不需要担心对象的数量会无限膨胀.</p> <h5 id="jetty的bytebufferpool"><a href="#jetty的bytebufferpool" class="header-anchor">#</a> Jetty的ByteBufferPool</h5> <p>再来看 Jetty 中的<strong>对象池 ByteBufferPool</strong>, 它本质是一个 <strong>ByteBuffer 对象池</strong>. 当 Jetty 在进行网络数据读写时, 不需要每次都在 JVM 堆上分配一块新的 Buffer, 只需在 ByteBuffer 对象池里拿到一块预先分配好的 Buffer, 这样就避免了频繁的分配内存和释放内存. 这种设计同样可以在高性能通信中间件比如 Mina 和 Netty 中看到. ByteBufferPool 是一个接口:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ByteBufferPool</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">ByteBuffer</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">boolean</span> direct<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token class-name">ByteBuffer</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>接口中的两个方法: acquire() 和 release() 分别用来分配和释放内存, 并且可以通过 acquire() 方法的 direct 参数来指定 buffer 是从 JVM 堆上分配还是从本地内存分配. ArrayByteBufferPool 是 ByteBufferPool 的实现类, 先来看看它的成员变量和构造函数:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayByteBufferPool</span> <span class="token keyword">implements</span> <span class="token class-name">ByteBufferPool</span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _min<span class="token punctuation">;</span><span class="token comment">// 最小 size 的 Buffer 长度</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _maxQueue<span class="token punctuation">;</span><span class="token comment">//Queue 最大长度</span>
  
    <span class="token comment">// 用不同的 Bucket(桶) 来持有不同 size 的 ByteBuffer 对象, 同一个桶中的 ByteBuffer size 是一样的</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ByteBufferPool<span class="token punctuation">.</span>Bucket</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _direct<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ByteBufferPool<span class="token punctuation">.</span>Bucket</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _indirect<span class="token punctuation">;</span>
  
    <span class="token comment">// ByteBuffer 的 size 增量</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _inc<span class="token punctuation">;</span>
  
    <span class="token keyword">public</span> <span class="token class-name">ArrayByteBufferPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> minSize<span class="token punctuation">,</span> <span class="token keyword">int</span> increment<span class="token punctuation">,</span> <span class="token keyword">int</span> maxSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maxQueue<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 检查参数值并设置默认值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>minSize<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//ByteBuffer 的最小长度</span>
            minSize<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>increment<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span>
            increment<span class="token operator">=</span><span class="token number">1024</span><span class="token punctuation">;</span><span class="token comment">// 默认以 1024 递增</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>maxSize<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span>
            maxSize<span class="token operator">=</span><span class="token number">64</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">;</span><span class="token comment">//ByteBuffer 的最大长度默认是 64K</span>
  
        <span class="token comment">// ByteBuffer 的最小长度必须小于增量</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>minSize<span class="token operator">&gt;=</span>increment<span class="token punctuation">)</span> 
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;minSize &gt;= increment&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
        <span class="token comment">// 最大长度必须是增量的整数倍</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>maxSize<span class="token operator">%</span>increment<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">||</span> increment<span class="token operator">&gt;=</span>maxSize<span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;increment must be a divisor of maxSize&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
        _min<span class="token operator">=</span>minSize<span class="token punctuation">;</span>
        _inc<span class="token operator">=</span>increment<span class="token punctuation">;</span>
  
        <span class="token comment">// 创建 maxSize/increment 个桶, 包含直接内存的与 heap 的</span>
        _direct<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ByteBufferPool<span class="token punctuation">.</span>Bucket</span><span class="token punctuation">[</span>maxSize<span class="token operator">/</span>increment<span class="token punctuation">]</span><span class="token punctuation">;</span>
        _indirect<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ByteBufferPool<span class="token punctuation">.</span>Bucket</span><span class="token punctuation">[</span>maxSize<span class="token operator">/</span>increment<span class="token punctuation">]</span><span class="token punctuation">;</span>
        _maxQueue<span class="token operator">=</span>maxQueue<span class="token punctuation">;</span>
        <span class="token keyword">int</span> size<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>_direct<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
          size<span class="token operator">+=</span>_inc<span class="token punctuation">;</span>
          _direct<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ByteBufferPool<span class="token punctuation">.</span>Bucket</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>size<span class="token punctuation">,</span>_maxQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
          _indirect<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ByteBufferPool<span class="token punctuation">.</span>Bucket</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>size<span class="token punctuation">,</span>_maxQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><p>从上面的代码可以看到, ByteBufferPool 是用不同的桶(Bucket)来管理不同长度的 ByteBuffer, 因为可能需要分配一块 1024 字节的 Buffer, 也可能需要一块 64K 字节的 Buffer. 而桶的内部用一个 ConcurrentLinkedDeque 来放置 ByteBuffer 对象的引用.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ByteBuffer</span><span class="token punctuation">&gt;</span></span> _queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentLinkedDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>可以通过下面的图再来理解一下:</p> <p><img src="/img/image-20230405161619-0j3p51e.png" alt=""></p> <p>而 Buffer 的分配和释放过程, 就是找到相应的桶, 并对桶中的 Deque 做出队和入队的操作, 而不是直接向 JVM 堆申请和释放内存.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 分配 Buffer</span>
<span class="token keyword">public</span> <span class="token class-name">ByteBuffer</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">boolean</span> direct<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 找到对应的桶, 没有的话创建一个桶</span>
    <span class="token class-name">ByteBufferPool<span class="token punctuation">.</span>Bucket</span> bucket <span class="token operator">=</span> <span class="token function">bucketFor</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>direct<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bucket<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">newByteBuffer</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>direct<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 这里其实调用了 Deque 的 poll 方法</span>
    <span class="token keyword">return</span> bucket<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span>direct<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
<span class="token punctuation">}</span>
 
<span class="token comment">// 释放 Buffer</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token class-name">ByteBuffer</span> buffer<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>buffer<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token comment">// 找到对应的桶</span>
      <span class="token class-name">ByteBufferPool<span class="token punctuation">.</span>Bucket</span> bucket <span class="token operator">=</span> <span class="token function">bucketFor</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>buffer<span class="token punctuation">.</span><span class="token function">isDirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
      <span class="token comment">// 这里调用了 Deque 的 offerFirst 方法</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>bucket<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span>
      bucket<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h5 id="对象池的思考"><a href="#对象池的思考" class="header-anchor">#</a> 对象池的思考</h5> <p><strong>对象池作为全局资源, 高并发环境中多个线程可能同时需要获取对象池中的对象, 因此多个线程在争抢对象时会因为锁竞争而阻塞, 因此使用对象池有线程同步的开销, 而不使用对象池则有创建和销毁对象的开销</strong>. 对于对象池本身的设计来说, 需要尽量做到<strong>无锁化</strong>, 比如 Jetty 就使用了 ConcurrentLinkedDeque. 如果内存足够大, 可以考虑用<strong>线程本地(ThreadLocal)对象池</strong>, 这样每个线程都有自己的对象池, 线程之间互不干扰.</p> <p><strong>为了防止对象池的无限膨胀, 必须要对池的大小做限制</strong>. 对象池太小发挥不了作用, 对象池太大的话可能有空闲对象, 这些空闲对象会一直占用内存, 造成内存浪费. 因此需要根据实际情况做一个平衡, 因此对象池本身除了应该有自动扩容的功能, 还需要考虑自动缩容.</p> <p><strong>所有的池化技术, 包括缓存, 都会面临内存泄露的问题</strong>, 原因是对象池或者缓存的本质是一个 Java 集合类, 比如 List 和 Stack, 这个集合类持有缓存对象的引用, 只要集合类不被 GC, 缓存对象也不会被 GC. 维持大量的对象也比较占用内存空间, 所以必要时需要主动清理这些对象. 以 Java 的线程池 ThreadPoolExecutor 为例, 它提供了 allowCoreThreadTimeOut 和 setKeepAliveTime 两种方法, 可以在超时后销毁线程, 在实际项目中也可以参考这个策略.</p> <p>另外在使用对象池时, 还有一些小贴士可以参考:</p> <ul><li><p>对象在用完后, 需要调用对象池的方法将对象归还给对象池.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code></code></pre> <div class="line-numbers-wrapper"></div></div></li> <li><p>对象池中的对象在再次使用时需要重置, 否则会产生脏对象, 脏对象可能持有上次使用的引用, 导致内存泄漏等问题, 并且如果脏对象下一次使用时没有被清理, 程序在运行过程中会发生意想不到的问题.</p></li> <li><p>对象一旦归还给对象池, 使用者就不能对它做任何操作了.</p></li> <li><p>向对象池请求对象时有可能出现的阻塞, 异常或者返回 null 值, 这些都需要做一些额外的处理, 来确保程序的正常运行.</p></li></ul> <h5 id="总结-8"><a href="#总结-8" class="header-anchor">#</a> 总结</h5> <p>Tomcat 和 Jetty 都用到了对象池技术, 这是因为处理一次 HTTP 请求的时间比较短, 但是这个过程中又需要创建大量复杂对象.</p> <p><strong>对象池技术可以减少频繁创建和销毁对象带来的成本, 实现对象的缓存和复用. 如果系统需要频繁的创建和销毁对象, 并且对象的创建代价比较大, 这种情况下, 一般来说你会观察到 GC 的压力比较大, 占用 CPU 率比较高, 这个时候就可以考虑使用对象池了.</strong></p> <p><strong>还有一种情况是需要对资源的使用做限制, 比如数据库连接, 不能无限制地创建数据库连接, 因此就有了数据库连接池, 也可以考虑把一些关键的资源池化, 对它们进行统一管理, 防止滥用.</strong></p> <h4 id="_21-总结-tomcat和jetty的高性能-高并发之道"><a href="#_21-总结-tomcat和jetty的高性能-高并发之道" class="header-anchor">#</a> 21.总结:Tomcat和Jetty的高性能, 高并发之道</h4> <p><strong>高性能程序就是高效的利用 CPU, 内存, 网络和磁盘等资源, 在短时间内处理大量的请求</strong>. 那如何衡量&quot;短时间和大量&quot;呢? 其实就是两个关键指标: <strong>响应时间和每秒事务处理量(TPS)</strong> .</p> <p>那什么是资源的高效利用呢? 有两个原则:</p> <ol><li><strong>减少资源浪费</strong>. 比如尽量避免线程阻塞, 因为一阻塞就会发生线程上下文切换, 就需要耗费 CPU 资源; 再比如网络通信时数据从内核空间拷贝到 Java 堆内存, 需要通过本地内存中转.</li> <li><strong>当某种资源成为瓶颈时, 用另一种资源来换取</strong>. 比如缓存和对象池技术就是用内存换 CPU; 数据压缩后再传输就是用 CPU 换网络.</li></ol> <p>Tomcat 和 Jetty 中用到了大量的高性能, 高并发的设计, 这里总结了几点: I/O 和线程模型, 减少系统调用, 池化, 零拷贝, 高效的并发编程. 下面详细介绍这些设计.</p> <h5 id="i-o和线程模型"><a href="#i-o和线程模型" class="header-anchor">#</a> I/O和线程模型</h5> <p><strong>I/O 模型的本质就是为了缓解 CPU 和外设之间的速度差</strong>. 当线程发起 I/O 请求时, 比如读写网络数据, 网卡数据还没准备好, 这个线程就会被阻塞, 让出 CPU, 也就是说发生了线程切换. 而线程切换是无用功, 并且线程被阻塞后, 它持有内存资源并没有释放, 阻塞的线程越多, 消耗的内存就越大, <strong>因此 I/O 模型的目标就是尽量减少线程阻塞</strong>. Tomcat 和 Jetty 都已经抛弃了传统的同步阻塞 I/O, 采用了非阻塞 I/O 或者异步 I/O, 目的是业务线程不需要阻塞在 I/O 等待上.</p> <p>除了 I/O 模型, <strong>线程模型也是影响性能和并发的关键点</strong>. Tomcat 和 Jetty 的总体处理原则是:</p> <ul><li>连接请求由专门的 Acceptor 线程组处理.</li> <li>I/O 事件侦测也由专门的 Selector 线程组来处理.</li> <li>具体的协议解析和业务处理可能交给线程池(Tomcat), 或者交给 Selector 线程来处理(Jetty).</li></ul> <p>将这些事情分开的好处是解耦, 并且可以根据实际情况合理设置各部分的线程数. 这里请注意, 线程数并不是越多越好, 因为 CPU 核的个数有限, 线程太多也处理不过来, 会导致大量的线程上下文切换.</p> <h5 id="减少系统调用"><a href="#减少系统调用" class="header-anchor">#</a> 减少系统调用</h5> <p>其实系统调用是非常耗资源的一个过程, 涉及 CPU 从用户态切换到内核态的过程, 因此在编写程序的时候要有意识尽量避免系统调用. 比如在 Tomcat 和 Jetty 中, 系统调用最多的就是网络通信操作了, 一个 Channel 上的 write 就是系统调用, <strong>为了降低系统调用的次数, 最直接的方法就是使用缓冲, 当输出数据达到一定的大小才 flush 缓冲区. Tomcat 和 Jetty 的 Channel 都带有输入输出缓冲区</strong>.</p> <p>还有值得一提的是, Tomcat 和 Jetty 在解析 HTTP 协议数据时,  都采取了<strong>延迟解析</strong>的策略, HTTP 的请求体(HTTP Body)直到用的时候才解析. 也就是说, 当 Tomcat 调用 Servlet 的 service() 方法时, 只是读取了和解析了 HTTP 请求头, 并没有读取 HTTP 请求体. <strong>直到 Web 应用程序调用了 ServletRequest 对象的 getInputStream() 方法或者 getParameter() 方法时, Tomcat 才会去读取和解析 HTTP 请求体中的数据</strong>; 这意味着如果应用程序没有调用上面那两个方法, HTTP 请求体的数据就不会被读取和解析, 这样就省掉了一次 I/O 系统调用.</p> <h5 id="池化-零拷贝"><a href="#池化-零拷贝" class="header-anchor">#</a> 池化,零拷贝</h5> <p>前面已经分析过池化和零拷贝. 其实池化的本质就是用内存换 CPU; 而零拷贝就是不做无用功, 减少资源浪费.</p> <h5 id="高效的并发编程"><a href="#高效的并发编程" class="header-anchor">#</a> 高效的并发编程</h5> <p>并发的过程中为了同步多个线程对共享变量的访问, 需要加锁来实现. 而锁的开销是比较大的, 拿锁的过程本身就是个系统调用, 如果锁没拿到线程会阻塞, 又会发生线程上下文切换, 尤其是大量线程同时竞争一把锁时, 会浪费大量的系统资源. 因此要有意识的尽量避免锁的使用, 比如可以使用原子类 CAS 或者并发集合来代替. 如果万不得已需要用到锁, 也要尽量缩小锁的范围和锁的强度. 接下来来看看 Tomcat 和 Jetty 如何做到高效的并发编程的.</p> <h6 id="_1-缩小锁的范围"><a href="#_1-缩小锁的范围" class="header-anchor">#</a> 1.缩小锁的范围</h6> <p>缩小锁的范围, 其实就是不直接在方法上加 synchronized, 而是使用<strong>细粒度的对象锁</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">startInternal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">LifecycleException</span> <span class="token punctuation">{</span>
 
    <span class="token function">setState</span><span class="token punctuation">(</span><span class="token class-name">LifecycleState</span><span class="token punctuation">.</span><span class="token constant">STARTING</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment">// 锁 engine 成员变量</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>engine <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>engine<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            engine<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 
   <span class="token comment">// 锁 executors 成员变量</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>executors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Executor</span> executor<span class="token operator">:</span> executors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            executor<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 
    mapperListener<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment">// 锁 connectors 成员变量</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>connectorsLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Connector</span> connector<span class="token operator">:</span> connectors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// If it has already failed, don't try and start it</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>connector<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token class-name">LifecycleState</span><span class="token punctuation">.</span><span class="token constant">FAILED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                connector<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>比如上面的代码是 Tomcat 的 StandardService 组件的启动方法, 这个启动方法要启动三种子组件: engine, executors 和 connectors. <strong>它没有直接在方法上加锁, 而是用了三把细粒度的锁, 来分别用来锁三个成员变量</strong>. 如果直接在方法上加 synchronized, 多个线程执行到这个方法时需要排队; 而在对象级别上加 synchronized, 多个线程可以并行执行这个方法, 只是在访问某个成员变量时才需要排队.</p> <h6 id="_2-用原子变量和cas取代锁"><a href="#_2-用原子变量和cas取代锁" class="header-anchor">#</a> 2.用原子变量和CAS取代锁</h6> <p>下面的代码是 Jetty 线程池的启动方法, 它的主要功能就是根据传入的参数启动相应个数的线程.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">startThreads</span><span class="token punctuation">(</span><span class="token keyword">int</span> threadsToStart<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>threadsToStart <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRunning</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 获取当前已经启动的线程数, 如果已经够了就不需要启动了</span>
        <span class="token keyword">int</span> threads <span class="token operator">=</span> _threadsStarted<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>threads <span class="token operator">&gt;=</span> _maxThreads<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
 
        <span class="token comment">// 用 CAS 方法将线程数加一, 请注意执行失败走 continue, 继续尝试</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_threadsStarted<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>threads<span class="token punctuation">,</span> threads <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
 
        <span class="token keyword">boolean</span> started <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span>
        <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token function">newThread</span><span class="token punctuation">(</span>_runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token function">getThreadsPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>_name <span class="token operator">+</span> <span class="token string">&quot;-&quot;</span> <span class="token operator">+</span> thread<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            _threads<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//_threads 并发集合</span>
            _lastShrink<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//_lastShrink 是原子变量</span>
            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            started <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token operator">--</span>threadsToStart<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">finally</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// 如果最终线程启动失败, 还需要把线程数减一</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>started<span class="token punctuation">)</span>
                _threadsStarted<span class="token punctuation">.</span><span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>可以看到整个函数的实现是一个 <strong>while 循环</strong>, 并且是<strong>无锁</strong>的. <code>_threadsStarted</code>​ 表示当前线程池已经启动了多少个线程, 它是一个原子变量 AtomicInteger, 首先通过它的 get() 方法拿到值, 如果线程数已经达到最大值, 直接返回. 否则尝试用 CAS 操作将 <code>_threadsStarted</code>​ 的值加一, 如果成功了意味着没有其他线程在改这个值, 当前线程可以继续往下执行; 否则走 continue 分支, 也就是继续重试, 直到成功为止. 在这里当然也可以使用锁来实现, 但是我们的目的是无锁化.</p> <h6 id="_3-并发容器的使用"><a href="#_3-并发容器的使用" class="header-anchor">#</a> 3.并发容器的使用</h6> <p>CopyOnWriteArrayList 适用于读多写少的场景, 比如 Tomcat 用它来 &quot;存放&quot; 事件监听器, 这是因为监听器一般在初始化过程中确定后就基本不会改变, 当事件触发时需要遍历这个监听器列表, 所以这个场景符合读多写少的特征.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">LifecycleBase</span> <span class="token keyword">implements</span> <span class="token class-name">Lifecycle</span> <span class="token punctuation">{</span>
 
    <span class="token comment">// 事件监听器集合</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LifecycleListener</span><span class="token punctuation">&gt;</span></span> lifecycleListeners <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h6 id="_4-volatile关键字的使用"><a href="#_4-volatile关键字的使用" class="header-anchor">#</a> 4.volatile关键字的使用</h6> <p>再拿 Tomcat 中的 LifecycleBase 作为例子, 它里面的生命状态就是用 volatile 关键字修饰的. volatile 的目的是为了保证一个线程修改了变量, 另一个线程能够读到这种变化. 对于生命状态来说, 需要在各个线程中保持是最新的值, 因此采用了 volatile 修饰.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">LifecycleBase</span> <span class="token keyword">implements</span> <span class="token class-name">Lifecycle</span> <span class="token punctuation">{</span>
 
    <span class="token comment">// 当前组件的生命状态, 用 volatile 修饰</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">LifecycleState</span> state <span class="token operator">=</span> <span class="token class-name">LifecycleState</span><span class="token punctuation">.</span><span class="token constant">NEW</span><span class="token punctuation">;</span>
 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h5 id="总结-9"><a href="#总结-9" class="header-anchor">#</a> 总结</h5> <p>高性能程序能够高效的利用系统资源, 首先就是减少资源浪费, 比如要减少线程的阻塞, 因为阻塞会导致资源闲置和线程上下文切换, Tomcat 和 Jetty 通过合理的 I/O 模型和线程模型减少了线程的阻塞. 另外系统调用会导致用户态和内核态切换的过程, Tomcat 和 Jetty 通过缓存和延迟解析尽量减少系统调用, 另外还通过零拷贝技术避免多余的数据拷贝.</p> <p>高效的利用资源还包括另一层含义, 那就是在系统设计的过程中, 经常会用一种资源换取另一种资源, 比如 Tomcat 和 Jetty 中使用的对象池技术, 就是用内存换取 CPU, 将数据压缩后再传输就是用 CPU 换网络.</p> <p>除此之外, 高效的并发编程也很重要, 多线程虽然可以提高并发度, 也带来了锁的开销, 因此在实际编程过程中要尽量避免使用锁, 比如可以用原子变量和 CAS 操作来代替锁. 如果实在避免不了用锁, 也要尽量减少锁的范围和强度, 比如可以用细粒度的对象锁或者低强度的读写锁. Tomcat 和 Jetty 的代码也很好的实践了这一理念.</p> <h4 id="_22-热点答疑-2-内核如何阻塞与唤醒进程"><a href="#_22-热点答疑-2-内核如何阻塞与唤醒进程" class="header-anchor">#</a> 22.热点答疑(2):内核如何阻塞与唤醒进程?</h4> <p>前面学习了 Tomcat 连接器组件的设计, <strong>其中最重要的是各种 I/O 模型及其实现</strong>. 而 I/O 模型跟操作系统密切相关, 要彻底理解这些原理, 首先需要弄清楚什么是进程和线程, 什么是虚拟内存和物理内存, 什么是用户空间和内核空间, 线程的阻塞到底意味着什么, 内核又是如何唤醒用户线程的等等这些问题. 掌握这些底层的知识, 对于学习 Tomcat 和 Jetty 的原理, 乃至其他各种后端架构都至关重要, 这些知识可以说是后端开发的基石.</p> <h5 id="进程和线程"><a href="#进程和线程" class="header-anchor">#</a> 进程和线程</h5> <p>先从 Linux 的进程谈起, 操作系统要运行一个可执行程序, 首先要将程序文件加载到内存, 然后 CPU 去读取和执行程序指令, 而一个进程就是 &quot;一次程序的运行过程&quot;, 内核会给每一个进程创建一个名为 <code>task_struct</code>​ 的数据结构, 而内核也是一段程序, 系统启动时就被加载到内存中了.</p> <p>进程在运行过程中要访问内存, 而物理内存是有限的, 比如 16GB, 那怎么把有限的内存分给不同的进程使用呢? 跟 CPU 的分时共享一样, 内存也是共享的, Linux 给每个进程<strong>虚拟出一块很大的地址空间</strong>, 比如 32 位机器上进程的虚拟内存地址空间是 4GB, 从 0x00000000 到 0xFFFFFFFF. 但这 4GB 并不是真实的物理内存, 而是进程访问到了某个虚拟地址, 如果这个地址还没有对应的物理内存页, 就会产生<strong>缺页中断</strong>, 分配物理内存, MMU(内存管理单元)会将虚拟地址与物理内存页的映射关系保存在页表中, 再次访问这个虚拟地址, 就能找到相应的物理内存页. 每个进程的这 4GB 虚拟地址空间分布如下图所示:</p> <p><img src="/img/image-20230405161709-b0l6abr.png" alt=""></p> <p><strong>进程的虚拟地址空间总体分为用户空间和内核空间</strong>, 低地址上的 3GB 属于用户空间, 高地址的 1GB 是内核空间, 这是基于安全上的考虑, 用户程序只能访问用户空间, 内核程序可以访问整个进程空间, 并且只有内核可以直接访问各种硬件资源, 比如磁盘和网卡. 那用户程序需要访问这些硬件资源该怎么办呢? 答案是通过<strong>系统调用</strong>, 系统调用可以理解为内核实现的函数, 比如应用程序要通过网卡接收数据, 会调用 Socket 的 read 函数:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token class-name">ssize_t</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span><span class="token class-name">size_t</span> nbyte<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>CPU 在执行系统调用的过程中会从用户态切换到内核态, CPU 在用户态下执行用户程序, 使用的是用户空间的栈, 访问用户空间的内存; 当 CPU 切换到内核态后, 执行内核代码, 使用的是内核空间上的栈.</p> <p>从上面这张图可以看到, 用户空间从低到高依次是代码区, 数据区, 堆, 共享库与 mmap 内存映射区, 栈, 环境变量. 其中堆向高地址增长, 栈向低地址增长.</p> <p>请注意用户空间上还有一个共享库和 mmap 映射区, Linux 提供了内存映射函数 mmap, 它可将文件内容映射到这个内存区域, 用户通过读写这段内存, 从而实现对文件的读取和修改, 无需通过 read/write 系统调用来读写文件, 省去了用户空间和内核空间之间的数据拷贝, Java 的 MappedByteBuffer 就是通过它来实现的; 用户程序用到的系统共享库也是通过 mmap 映射到了这个区域.</p> <p>开始提到的 <code>task_struct</code>​ 结构体本身是分配在内核空间, 它的 <code>vm_struct</code>​ 成员变量保存了各内存区域的起始和终止地址, 此外 <code>task_struct</code>​ 中还保存了进程的其他信息, 比如进程号, 打开的文件, 创建的 Socket 以及 CPU 运行上下文等.</p> <p>在 Linux 中, 线程是一个轻量级的进程, 轻量级说的是线程只是一个 CPU 调度单元, 因此线程有自己的 <code>task_struct</code>​ 结构体和运行栈区, 但是线程的其他资源都是跟父进程共用的, 比如虚拟地址空间, 打开的文件和 Socket 等.</p> <h5 id="阻塞与唤醒"><a href="#阻塞与唤醒" class="header-anchor">#</a> 阻塞与唤醒</h5> <p>当用户线程发起一个阻塞式的 read 调用, 数据未就绪时, 线程就会阻塞, 那阻塞具体是如何实现的呢?</p> <p>Linux 内核将线程当作一个进程进行 CPU 调度, 内核维护了一个可运行的进程队列, 所有处于 <code>TASK_RUNNING</code>​ 状态的进程都会被放入运行队列中, 本质是用双向链表将 <code>task_struct</code>​ 链接起来, 排队使用 CPU 时间片, 时间片用完重新调度 CPU. <strong>所谓调度就是在可运行进程列表中选择一个进程, 再从 CPU 列表中选择一个可用的 CPU, 将进程的上下文恢复到这个 CPU 的寄存器中, 然后执行进程上下文指定的下一条指令</strong>.</p> <p><img src="/img/image-20230405161709-ocws3zb.png" alt=""></p> <p>而阻塞的本质就是将进程的 <code>task_struct</code>​ 移出运行队列, 添加到等待队列, 并且将进程的状态的置为 <code>TASK_UNINTERRUPTIBLE</code>​ 或者 <code>TASK_INTERRUPTIBLE</code>​, 重新触发一次 CPU 调度让出 CPU.</p> <p>那线程怎么唤醒呢? 线程在加入到等待队列的同时向内核注册了一个<strong>回调函数</strong>, 告诉内核我在等待这个 Socket 上的数据, 如果数据到了就唤醒我. 这样<strong>当网卡接收到数据时, 产生硬件中断, 内核再通过调用回调函数唤醒进程</strong>. 唤醒的过程就是将进程的 <code>task_struct</code>​ 从等待队列移到运行队列, 并且将 <code>task_struct</code>​ 的状态置为 <code>TASK_RUNNING</code>​, 这样进程就有机会重新获得 CPU 时间片.</p> <p>这个过程中, 内核还会将数据从内核空间拷贝到用户空间的堆上.</p> <p><img src="/img/image-20230405161709-othexia.png" alt=""></p> <p>当 read 系统调用返回时, CPU 又从内核态切换到用户态, 继续执行 read 调用的下一行代码, 并且能从用户空间上的 Buffer 读到数据了.</p> <p>总结一次 Socket read 系统调用的过程: 首先 CPU 在用户态执行应用程序的代码, 访问进程虚拟地址空间的用户空间; read 系统调用时 CPU 从用户态切换到内核态, 执行内核代码, 内核检测到 Socket 上的数据未就绪时, 将进程的<code>task_struct</code>​结构体从运行队列中移到等待队列, 并触发一次 CPU 调度, 这时进程会让出 CPU; 当网卡数据到达时, 内核将数据从内核空间拷贝到用户空间的 Buffer, 接着将进程的<code>task_struct</code>​结构体重新移到运行队列, 这样进程就有机会重新获得 CPU 时间片, 系统调用返回, CPU 又从内核态切换到用户态, 访问用户空间的数据.</p> <h3 id="容器-2"><a href="#容器-2" class="header-anchor">#</a> 容器</h3> <h4 id="_23-host容器-tomcat如何实现热部署和热加载"><a href="#_23-host容器-tomcat如何实现热部署和热加载" class="header-anchor">#</a> 23.Host容器:Tomcat如何实现热部署和热加载?</h4> <p>接下来开始介绍 Tomcat 的容器模块, 来聊一聊各容器组件实现的功能, 主要有<strong>热部署热加载, 类加载机制以及 Servlet 规范</strong>的实现. 最后还会谈到 Spring Boot 是如何与 Web 容器进行交互的.</p> <p>首先来看热部署和热加载. 要在运行的过程中升级 Web 应用, 如果不想重启系统, 实现的方式有两种: <strong>热加载和热部署</strong>.</p> <p>那如何实现热部署和热加载呢? 它们跟<strong>类加载机制</strong>有关, 具体来说就是:</p> <ul><li><strong>热加载的实现方式是 Web 容器启动一个后台线程, 定期检测类文件的变化, 如果有变化, 就重新加载类, 在这个过程中不会清空 Session, 一般用在开发环境.</strong></li> <li>**热部署原理类似, 也是由后台线程定时检测 Web 应用的变化, 但它会重新加载整个 Web 应用. 这种方式会清空 Session, 比热加载更加干净, 彻底, 一般用在生产环境. **</li></ul> <p>Tomcat 通过开启后台线程, 使得各个层次的容器组件都有机会完成一些<strong>周期性任务</strong>. 在实际工作中, 往往也需要执行一些周期性的任务, 比如监控程序周期性拉取系统的健康状态, 就可以借鉴这种设计.</p> <h5 id="tomcat的后台线程"><a href="#tomcat的后台线程" class="header-anchor">#</a> Tomcat的后台线程</h5> <p>要说开启后台线程做周期性的任务, 有经验的同学马上会想到线程池中的 <strong>ScheduledThreadPoolExecutor</strong>, 它除了具有线程池的功能, 还能够执行周期性的任务. Tomcat 就是通过它来开启后台线程的:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>bgFuture <span class="token operator">=</span> exec<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span>
              <span class="token keyword">new</span> <span class="token class-name">ContainerBackgroundProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">// 要执行的 Runnable</span>
              backgroundProcessorDelay<span class="token punctuation">,</span> <span class="token comment">// 第一次执行延迟多久</span>
              backgroundProcessorDelay<span class="token punctuation">,</span> <span class="token comment">// 之后每次执行间隔多久</span>
              <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 时间单位</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上面的代码调用了 scheduleWithFixedDelay() 方法, 传入了四个参数, 第一个参数就是要周期性执行的任务类 ContainerBackgroundProcessor, 它是一个 Runnable, 同时也是 ContainerBase 的内部类, ContainerBase 是所有容器组件的基类, 来回忆一下容器组件有哪些, 有 Engine, Host, Context 和 Wrapper 等, 它们具有父子关系.</p> <h6 id="_1-containerbackgroundprocessor实现"><a href="#_1-containerbackgroundprocessor实现" class="header-anchor">#</a> 1.ContainerBackgroundProcessor实现</h6> <p>下面来看 ContainerBackgroundProcessor 具体是如何实现的.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">class</span> <span class="token class-name">ContainerBackgroundProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
 
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 请注意这里传入的参数是 &quot; 宿主类&quot; 的实例</span>
        <span class="token function">processChildren</span><span class="token punctuation">(</span><span class="token class-name">ContainerBase</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">processChildren</span><span class="token punctuation">(</span><span class="token class-name">Container</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 1. 调用当前容器的 backgroundProcess() 方法. </span>
            container<span class="token punctuation">.</span><span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
            <span class="token comment">// 2. 遍历所有的子容器, 递归调用 processChildren(), 这样当前容器的子孙都会被处理        </span>
            <span class="token class-name">Container</span><span class="token punctuation">[</span><span class="token punctuation">]</span> children <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">findChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 这里请注意, 容器基类有个变量叫做 backgroundProcessorDelay, 如果大于 0, 表明子容器有自己的后台线程, </span>
            <span class="token comment">// 无需父容器来调用它的 processChildren() 方法. </span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getBackgroundProcessorDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">processChildren</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token comment">// ... </span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>上面的代码逻辑也是比较清晰的, 首先 ContainerBackgroundProcessor 是一个 Runnable, 它需要实现 run() 方法, 它的 run() 很简单, 就是调用了 processChildren() 方法. 这里有个小技巧, 它把 &quot;宿主类&quot;, 也就是 <strong>ContainerBase 的类实例当成参数传给了 run() 方法</strong>.</p> <p>而在 processChildren() 方法里, 就做了两步: 调用当前容器的 backgroundProcess() 方法, 以及递归调用子孙的 backgroundProcess() 方法. 请注意 backgroundProcess() 是 Container 接口中的方法, 也就是说<strong>所有类型的容器</strong>都可以实现这个方法, <strong>在这个方法里完成需要周期性执行的任务</strong>.</p> <p>这样的设计意味着什么呢? 只需要在顶层容器, 也就是 Engine 容器中启动一个后台线程, 那么这个线程<strong>不但会执行 Engine 容器的周期性任务, 它还会执行所有子容器的周期性任务</strong>.</p> <h6 id="_2-backgroundprocess-方法"><a href="#_2-backgroundprocess-方法" class="header-anchor">#</a> 2.backgroundProcess()方法</h6> <p>上述代码都是在基类 ContainerBase 中实现的, 那具体容器类需要做什么呢? 其实很简单, 如果有周期性任务要执行, 就实现 backgroundProcess() 方法; 如果没有, 就重用基类 ContainerBase 的方法. ContainerBase 的 backgroundProcess() 方法实现如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
    <span class="token comment">// 1. 执行容器中 Cluster 组件的周期性任务</span>
    <span class="token class-name">Cluster</span> cluster <span class="token operator">=</span> <span class="token function">getClusterInternal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cluster <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cluster<span class="token punctuation">.</span><span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
    <span class="token comment">// 2. 执行容器中 Realm 组件的周期性任务</span>
    <span class="token class-name">Realm</span> realm <span class="token operator">=</span> <span class="token function">getRealmInternal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>realm <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        realm<span class="token punctuation">.</span><span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   
   <span class="token comment">// 3. 执行容器中 Valve 组件的周期性任务</span>
    <span class="token class-name">Valve</span> current <span class="token operator">=</span> pipeline<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       current<span class="token punctuation">.</span><span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       current <span class="token operator">=</span> current<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
    <span class="token comment">// 4. 触发容器的 &quot;周期事件&quot;, Host 容器的监听器 HostConfig 就靠它来调用</span>
    <span class="token function">fireLifecycleEvent</span><span class="token punctuation">(</span><span class="token class-name">Lifecycle</span><span class="token punctuation">.</span><span class="token constant">PERIODIC_EVENT</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>从上面的代码可以看到, 不仅每个容器可以有周期性任务, 每个容器中的其他通用组件, 比如跟集群管理有关的 Cluster 组件, 跟安全管理有关的 Realm 组件都可以有自己的周期性任务.</p> <p>前面提到过, <strong>容器之间的链式调用是通过 Pipeline-Valve 机制</strong>来实现的, 从上面的代码可以看到容器中的 Valve 也可以有周期性任务, 并且被 ContainerBase 统一处理.</p> <p>请特别注意, 在 backgroundProcess() 方法的最后, 还<strong>触发了容器的 &quot;周期事件&quot;</strong> . 我们知道容器的生命周期事件有初始化, 启动和停止等, 那 &quot;周期事件&quot; 又是什么呢? 它跟生命周期事件一样, 是一种扩展机制, 可以这样理解:</p> <p>又一段时间过去了, 容器还活着, 你想做点什么吗? 如果你想做点什么, 就创建一个监听器来监听这个 &quot;周期事件&quot;, 事件到了我负责调用你的方法.</p> <p>总之, 有了 ContainerBase 中的后台线程和 backgroundProcess() 方法, 各种子容器和通用组件不需要各自弄一个后台线程来处理周期性任务, 这样的设计显得优雅和整洁.</p> <h5 id="tomcat热加载"><a href="#tomcat热加载" class="header-anchor">#</a> Tomcat热加载</h5> <p>有了 ContainerBase 的周期性任务处理 &quot;框架&quot;, 作为<strong>具体容器子类, 只需要实现自己的周期性任务就行</strong>. 而 Tomcat 的热加载, 就是在 Context 容器中实现的. Context 容器的 backgroundProcess() 方法是这样实现的:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
    <span class="token comment">// WebappLoader 周期性的检查 WEB-INF/classes 和 WEB-INF/lib 目录下的类文件</span>
    <span class="token class-name">Loader</span> loader <span class="token operator">=</span> <span class="token function">getLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>loader <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        loader<span class="token punctuation">.</span><span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>
  
    <span class="token comment">// Session 管理器周期性的检查是否有过期的 Session</span>
    <span class="token class-name">Manager</span> manager <span class="token operator">=</span> <span class="token function">getManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>manager <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        manager<span class="token punctuation">.</span><span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
    <span class="token comment">// 周期性的检查静态资源是否有变化</span>
    <span class="token class-name">WebResourceRoot</span> resources <span class="token operator">=</span> <span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>resources <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resources<span class="token punctuation">.</span><span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
    <span class="token comment">// 调用父类 ContainerBase 的 backgroundProcess 方法</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p><strong>从上面的代码可以看到 Context 容器通过 WebappLoader 来检查类文件是否有更新, 通过 Session 管理器来检查是否有 Session 过期, 并且通过资源管理器来检查静态资源是否有更新, 最后还调用了父类 ContainerBase 的 backgroundProcess() 方法</strong>.</p> <p>这里要重点关注, WebappLoader 是如何实现热加载的, 它主要是调用了 Context 容器的 reload() 方法, 而 Context 的 reload() 方法比较复杂, 总结起来, 主要完成了下面这些任务:</p> <ol><li>停止和销毁 Context 容器及其所有子容器, 子容器其实就是 Wrapper, 也就是说 Wrapper 里面 Servlet 实例也被销毁了.</li> <li>停止和销毁 Context 容器关联的 Listener 和 Filter.</li> <li>停止和销毁 Context 下的 Pipeline 和各种 Valve.</li> <li>停止和销毁 Context 的类加载器, 以及类加载器加载的类文件资源.</li> <li>启动 Context 容器, 在这个过程中会重新创建前面四步被销毁的资源.</li></ol> <p>在这个过程中, <strong>类加载器</strong>发挥着关键作用. 一个 Context 容器对应一个类加载器, 类加载器在销毁的过程中会把它加载的所有类也全部销毁. Context 容器在启动过程中, 会创建一个新的类加载器来加载新的类文件.</p> <p>在 Context 的 reload() 方法里, 并没有调用 Session 管理器的 distroy() 方法, 也就是说这个 Context 关联的 Session 是没有销毁的. 还需要注意的是, Tomcat 的<strong>热加载默认是关闭</strong>的, 需要在 conf 目录下的 Context.xml 文件中设置 reloadable 参数来开启这个功能, 像下面这样:</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Context</span> <span class="token attr-name">reloadable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>true<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h5 id="tomcat热部署"><a href="#tomcat热部署" class="header-anchor">#</a> Tomcat热部署</h5> <p>再来看看热部署, 热部署跟热加载的本质区别是, <strong>热部署会重新部署 Web 应用, 原来的 Context 对象会整个被销毁掉, 因此这个 Context 所关联的一切资源都会被销毁, 包括 Session</strong>.</p> <p>那么 Tomcat 热部署又是由哪个容器来实现的呢? 应该不是由 Context, 因为热部署过程中 Context 容器被销毁了, 那么这个重担就落在 <strong>Host</strong> 身上了, 因为它是 Context 的父容器.</p> <p>跟 Context 不一样, Host 容器并没有在 backgroundProcess() 方法中实现周期性检测的任务, 而是<strong>通过监听器 HostConfig 来实现的, HostConfig 就是前面提到的 &quot;周期事件&quot; 的监听器</strong>, 那 &quot;周期事件&quot; 达到时, HostConfig 会做什么事呢?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lifecycleEvent</span><span class="token punctuation">(</span><span class="token class-name">LifecycleEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 执行 check 方法</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Lifecycle</span><span class="token punctuation">.</span><span class="token constant">PERIODIC_EVENT</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>它执行了 check() 方法, 接着来看 check() 方法里做了什么.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">if</span> <span class="token punctuation">(</span>host<span class="token punctuation">.</span><span class="token function">getAutoDeploy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 检查这个 Host 下所有已经部署的 Web 应用</span>
        <span class="token class-name">DeployedApplication</span><span class="token punctuation">[</span><span class="token punctuation">]</span> apps <span class="token operator">=</span>
            deployed<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DeployedApplication</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> apps<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 检查 Web 应用目录是否有变化</span>
            <span class="token function">checkResources</span><span class="token punctuation">(</span>apps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
 
        <span class="token comment">// 执行部署</span>
        <span class="token function">deployApps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>其实 HostConfig 会检查 webapps 目录下的所有 Web 应用:</p> <ul><li>**如果原来 Web 应用目录被删掉了, 就把相应 Context 容器整个销毁掉. **</li> <li>**是否有新的 Web 应用目录放进来了, 或者有新的 WAR 包放进来了, 就部署相应的 Web 应用. **</li></ul> <p>因此 HostConfig 做的事情都是比较 &quot;宏观&quot; 的, 它不会去检查具体类文件或者资源文件是否有变化, 而是检查 Web 应用目录级别的变化.</p> <h5 id="总结-10"><a href="#总结-10" class="header-anchor">#</a> 总结</h5> <p>这里介绍了 Tomcat 的热加载和热部署, 它们的目的都是在不重启 Tomcat 的情况下实现 Web 应用的更新.</p> <p>热加载的粒度比较小, 主要是针对类文件的更新, 通过创建新的类加载器来实现重新加载. 而热部署是针对整个 Web 应用的, Tomcat 会将原来的 Context 对象整个销毁掉, 再重新创建 Context 容器对象.</p> <p>热加载和热部署的实现都离不开后台线程的周期性检查, Tomcat 在基类 ContainerBase 中统一实现了后台线程的处理逻辑, 并在顶层容器 Engine 启动后台线程, 这样子容器组件甚至各种通用组件都不需要自己去创建后台线程, 这样的设计显得优雅整洁.</p> <p>‍</p> <h4 id="_24-context容器-上-tomcat如何打破双亲委托机制"><a href="#_24-context容器-上-tomcat如何打破双亲委托机制" class="header-anchor">#</a> 24.Context容器(上):Tomcat如何打破双亲委托机制?</h4> <p>ClassNotFound 异常表示 JVM 在尝试加载某个类的时候失败了. 想要解决这个问题, 首先需要知道什么是类加载, JVM 是如何加载类的, 以及为什么会出现 ClassNotFound 异常? 弄懂上面这些问题之后, 接着要思考 Tomcat 作为 Web 容器, 它是如何加载和管理 Web 应用下的 Servlet 呢?</p> <p>Tomcat 正是通过 Context 组件来加载管理 Web 应用的, 所以这里详细分析 Tomcat 的类加载机制. 但在这之前, 有必要预习一下 JVM 的类加载机制, 接着再谈谈 Tomcat 的类加载器如何打破 Java 的双亲委托机制.</p> <h5 id="jvm的类加载器"><a href="#jvm的类加载器" class="header-anchor">#</a> JVM的类加载器</h5> <p>Java 的类加载, 就是把字节码格式 &quot;.class&quot; 文件加载到 JVM 的<strong>方法区</strong>, 并在 JVM 的<strong>堆区</strong>建立一个 <code>java.lang.Class</code>​ 对象的实例, 用来封装 Java 类相关的数据和方法. 那 Class 对象又是什么呢? 你可以把它理解成业务类的模板, JVM 根据这个模板来创建具体业务类对象实例.</p> <p>JVM 并不是在启动时就把所有的 &quot;.class&quot; 文件都加载一遍, 而是程序在运行过程中<strong>用到了这个类才去加载</strong>. JVM 类加载是由类加载器来完成的, JDK 提供一个抽象类 <strong>ClassLoader</strong>, 这个抽象类中定义了三个关键方法, 理解清楚它们的作用和关系非常重要.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>
 
    <span class="token comment">// 每个类加载器都有个父加载器</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">;</span>
  
    <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  
        <span class="token comment">// 查找一下这个类是不是已经加载过了</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
        <span class="token comment">// 如果没有加载过</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> c <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token comment">// 先委托给父加载器去加载, 注意这是个递归调用</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
              <span class="token comment">// 如果父加载器为空, 查找 Bootstrap 加载器是不是加载过了</span>
              c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果父加载器没加载成功, 调用自己的 findClass 去加载</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
  
        <span class="token keyword">return</span> c<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
  
    <span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token comment">// 1. 根据传入的类名 name, 到在特定目录下去寻找类文件, 把.class 文件读入内存</span>
          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  
       <span class="token comment">// 2. 调用 defineClass 将字节数组转成 Class 对象</span>
       <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> off<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
  
    <span class="token comment">// 将字节码数组解析成一个 Class 对象, 用 native 方法实现</span>
    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">defineClass</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> off<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p>从上面的代码可以得到几个关键信息:</p> <ul><li>JVM 的类加载器是分层次的, 它们有父子关系, 每个类加载器都持有一个 parent 字段, 指向父加载器.</li> <li>defineClass() 是个工具方法, 它的职责是调用 native 方法把 Java 类的字节码解析成一个 Class 对象, 所谓的 native 方法就是由 C 语言实现的方法, Java 通过 JNI 机制调用.</li> <li>findClass() 方法的主要职责就是找到 &quot;.class&quot; 文件, 可能来自文件系统或者网络, 找到后把 &quot;.class&quot; 文件读到内存得到字节码数组, 然后调用 defineClass() 方法得到 Class 对象.</li> <li>loadClass() 是个 public 方法, 说明它才是对外提供服务的接口, 具体实现也比较清晰: 首先检查这个类是不是已经被加载过了, 如果加载过了直接返回, 否则交给父加载器去加载. 请注意, 这是一个<strong>递归调用</strong>, 也就是说子加载器持有父加载器的引用, 当一个类加载器需要加载一个 Java 类时, 会先委托父加载器去加载, 然后父加载器在自己的加载路径中搜索 Java 类, 当父加载器在自己的加载范围内找不到时, 才会交还给子加载器加载, 这就是<strong>双亲委托机制</strong>.</li></ul> <p>JDK 中有哪些默认的类加载器? 它们的本质区别是什么? 为什么需要双亲委托机制? JDK 中有 3 个类加载器, 另外也可以自定义类加载器, 它们的关系如下图所示.</p> <p><img src="/img/image-20230405161811-bd1zrn7.png" alt=""></p> <ul><li><strong>BootstrapClassLoader</strong> 是启动类加载器, 由 C 语言实现, 用来加载 JVM 启动时所需要的核心类, 比如 <code>rt.jar</code>​, <code>resources.jar</code>​ 等.</li> <li><strong>ExtClassLoader</strong> 是扩展类加载器, 用来加载 <code>\jre\lib\ext</code>​ 目录下 JAR 包.</li> <li><strong>AppClassLoader</strong> 是系统类加载器, 用来加载 classpath 下的类, 应用程序默认用它来加载类.</li> <li>自定义类加载器, 用来加载自定义路径下的类.</li></ul> <p>这些类加载器的工作原理是一样的, 区别是它们的<strong>加载路径不同</strong>, 也就是说 findClass() 这个方法查找的路径不同. 双亲委托机制是为了保证一个 Java 类在 JVM 中是唯一的, 假如你不小心写了一个与 JRE 核心类同名的类, 比如 Object 类, 双亲委托机制能保证加载的是 JRE 里的那个 Object 类, 而不是你写的 Object 类. 这是因为 AppClassLoader 在加载你的 Object 类时, 会委托给 ExtClassLoader 去加载, 而 ExtClassLoader 又会委托给 BootstrapClassLoader, BootstrapClassLoader 发现自己已经加载过了 Object 类, 会直接返回, 不会去加载你写的 Object 类.</p> <p>请注意, <strong>类加载器的父子关系不是通过继承来实现的, 比如 AppClassLoader 并不是 ExtClassLoader 的子类, 而是说 AppClassLoader 的 parent 成员变量指向 ExtClassLoader 对象</strong>. 同样的道理, 如果要自定义类加载器, 不去继承 AppClassLoader, 而是继承 ClassLoader 抽象类, 再重写 findClass() 和 loadClass() 方法即可, <strong>Tomcat 就是通过自定义类加载器来实现自己的类加载逻辑</strong>. 因此如果要打破双亲委托机制, 就需要重写 loadClass() 方法, 因为 loadClass() 的默认实现就是双亲委托机制.</p> <h5 id="tomcat的类加载器"><a href="#tomcat的类加载器" class="header-anchor">#</a> Tomcat的类加载器</h5> <p>Tomcat 的自定义类加载器 <strong>WebAppClassLoader</strong> 打破了双亲委托机制, 它<strong>首先自己尝试去加载某个类, 如果找不到再代理给父类加载器</strong>, 其目的是<strong>优先加载 Web 应用自己定义的类</strong>. 具体实现就是重写 ClassLoader 的两个方法: findClass() 和 loadClass().</p> <h6 id="_1-findclass-方法"><a href="#_1-findclass-方法" class="header-anchor">#</a> 1.findClass()方法</h6> <p>先来看看 findClass() 方法的实现, 为了方便理解和阅读, 下面去掉了一些细节:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 1. 先在 Web 应用目录下查找类 </span>
            clazz <span class="token operator">=</span> <span class="token function">findClassInternal</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 2. 如果在本地目录没有找到, 交给父加载器去查找</span>
            clazz <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
    <span class="token comment">// 3. 如果父类也没找到, 抛出 ClassNotFoundException</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 
    <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>在 findClass() 方法里, 主要有三个步骤:</p> <ol><li>**先在 Web 应用本地目录下查找要加载的类. **</li> <li>**如果没有找到, 交给父加载器去查找, 它的父加载器就是上面提到的系统类加载器 AppClassLoader. **</li> <li>**如何父加载器也没找到这个类, 抛出 ClassNotFound 异常. **</li></ol> <h6 id="_2-loadclass-方法"><a href="#_2-loadclass-方法" class="header-anchor">#</a> 2.loadClass()方法</h6> <p>接着再来看 Tomcat 类加载器的 loadClass() 方法的实现, 同样也去掉了一些细节:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
 
        <span class="token comment">// 1. 先在本地 cache 查找该类是否已经加载过</span>
        clazz <span class="token operator">=</span> <span class="token function">findLoadedClass0</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span>
                <span class="token function">resolveClass</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
 
        <span class="token comment">// 2. 从系统类加载器的 cache 中查找是否加载过</span>
        clazz <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span>
                <span class="token function">resolveClass</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
 
        <span class="token comment">// 3. 尝试用 ExtClassLoader 类加载器类加载, 为什么? </span>
        <span class="token class-name">ClassLoader</span> javaseLoader <span class="token operator">=</span> <span class="token function">getJavaseClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            clazz <span class="token operator">=</span> javaseLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span>
                    <span class="token function">resolveClass</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// Ignore</span>
        <span class="token punctuation">}</span>
 
        <span class="token comment">// 4. 尝试在本地目录搜索 class 并加载</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            clazz <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span>
                    <span class="token function">resolveClass</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// Ignore</span>
        <span class="token punctuation">}</span>
 
        <span class="token comment">// 5. 尝试用系统类加载器 (也就是 AppClassLoader) 来加载</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span>
                        <span class="token function">resolveClass</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// Ignore</span>
            <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
  
    <span class="token comment">// 6. 上述过程都加载失败, 抛出异常</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br></div></div><p>loadClass() 方法稍微复杂一点, 主要有六个步骤:</p> <ol><li>先在本地 Cache 查找该类是否已经加载过, 也就是说 Tomcat 的类加载器是否已经加载过这个类.</li> <li>如果 Tomcat 类加载器没有加载过这个类, 再看看系统类加载器是否加载过.</li> <li>如果都没有, 就让 <strong>ExtClassLoader ** 去加载, 这一步比较关键, 目的</strong>防止 Web 应用自己的类覆盖 JRE 的核心类**. 因为 Tomcat 需要打破双亲委托机制, 假如 Web 应用里自定义了一个叫 Object 的类, 如果先加载这个 Object 类, 就会覆盖 JRE 里面的那个 Object 类, 这就是为什么 Tomcat 的类加载器会<strong>优先尝试用 ExtClassLoader 去加载</strong>, 因为 ExtClassLoader 会委托给 BootstrapClassLoader 去加载, BootstrapClassLoader 发现自己已经加载了 Object 类, 直接返回给 Tomcat 的类加载器, 这样 Tomcat 的类加载器就不会去加载 Web 应用下的 Object 类了, 也就避免了覆盖 JRE 核心类的问题.</li> <li>如果 ExtClassLoader 加载器加载失败, 也就是说 JRE 核心类中没有这类, 那么就在本地 Web 应用目录下查找并加载.</li> <li>如果本地目录下没有这个类, 说明不是 Web 应用自己定义的类, 那么由<strong>系统类加载器去加载</strong>. 这里请注意, Web 应用是通过<code>Class.forName</code>​ 调用交给系统类加载器的, 因为 <code>Class.forName</code>​ 的默认加载器就是系统类加载器.</li> <li>如果上述加载过程全部失败, 抛出 ClassNotFound 异常.</li></ol> <p>从上面的过程可以看到, <strong>Tomcat 的类加载器打破了双亲委托机制, 没有一上来就直接委托给父加载器, 而是先在本地目录下加载, 为了避免本地目录下的类覆盖 JRE 的核心类, 先尝试用 JVM 扩展类加载器 ExtClassLoader 去加载. 那为什么不先用系统类加载器 AppClassLoader 去加载? 很显然, 如果是这样的话, 那就变成双亲委托机制了, 这就是 Tomcat 类加载器的巧妙之处</strong>.</p> <h5 id="总结-11"><a href="#总结-11" class="header-anchor">#</a> 总结</h5> <p>这里介绍了 JVM 的类加载器原理和源码剖析, 以及 Tomcat 的类加载器是如何打破双亲委托机制的, 目的是为了优先加载 Web 应用目录下的类, 然后再加载其他目录下的类, 这也是 Servlet 规范的推荐做法.</p> <p>要打破双亲委托机制, 需要继承 ClassLoader 抽象类, 并且需要重写它的 loadClass() 方法, 因为 ClassLoader 的默认实现就是双亲委托.</p> <h4 id="_25-context容器-中-tomcat如何隔离web应用"><a href="#_25-context容器-中-tomcat如何隔离web应用" class="header-anchor">#</a> 25.Context容器(中):Tomcat如何隔离Web应用?</h4> <p>前面提到, Tomcat 通过自定义类加载器 WebAppClassLoader 打破了双亲委托机制, 具体来说就是重写了 JVM 的类加载器 ClassLoader 的 findClass() 方法和 loadClass() 方法, 这样做的目的是<strong>优先加载 Web 应用目录下的类</strong>. 除此之外, 你觉得 Tomcat 的类加载器还需要完成哪些需求呢? 或者说在设计上还需要考虑哪些方面?</p> <p>Tomcat 作为 Servlet 容器, 它负责加载 Servlet 类, 此外它还负责加载 <strong>Servlet 所依赖的 JAR 包</strong>. 并且 Tomcat 本身也是也是一个 Java 程序, 因此它需要加载自己的类和依赖的 JAR 包. 首先思考这一下这几个问题:</p> <ol><li>假如在 Tomcat 中运行了两个 Web 应用程序, 两个 Web 应用中有<strong>同名的 Servlet</strong>, 但是功能不同, Tomcat 需要同时加载和管理这两个同名的 Servlet 类, 保证它们不会冲突, 因此 Web 应用之间的类需要隔离.</li> <li>假如两个 Web 应用都<strong>依赖同一个第三方的 JAR 包</strong>, 比如 Spring, 那 Spring 的 JAR 包被加载到内存后, Tomcat 要保证这两个 Web 应用能够共享, 也就是说 Spring 的 JAR 包只被加载一次, 否则随着依赖的第三方 JAR 包增多, JVM 的内存会膨胀.</li> <li>跟 JVM 一样, 需要隔离 Tomcat 本身的类和 Web 应用的类.</li></ol> <p>在了解了 Tomcat 的类加载器在设计时要考虑的这些问题以后, 这里主要来分析一下 Tomcat 是如何通过设计多层次的类加载器来解决这些问题的.</p> <h5 id="tomcat类加载器的层次结构"><a href="#tomcat类加载器的层次结构" class="header-anchor">#</a> Tomcat类加载器的层次结构</h5> <p>为了解决这些问题, Tomcat 设计了类加载器的层次结构, 它们的关系如下图所示. 下面详细解释为什么要设计这些类加载器, 以及它们如何解决上面这些问题.</p> <p><img src="/img/image-20230405161829-mcilwn8.png" alt=""></p> <p>先来看<strong>第 1 个问题</strong>, 假如使用 JVM 默认 AppClassLoader 来加载 Web 应用, AppClassLoader 只能加载一个 Servlet 类, 在加载第二个同名 Servlet 类时, AppClassLoader 会返回第一个 Servlet 类的 Class 实例, 这是因为在 AppClassLoader 看来, 同名的 Servlet 类<strong>只被加载一次</strong>.</p> <p>因此 Tomcat 的解决方案是<strong>自定义一个类加载器 WebAppClassLoader, 并且给每个 Web 应用创建一个类加载器实例</strong>. 由于 Context 容器组件对应一个 Web 应用, 因此, 每个 Context 容器负责创建和维护一个 WebAppClassLoader 加载器实例. 这背后的原理是, <strong>不同的加载器实例加载的类被认为是不同的类</strong>, 即使它们的类名相同. 这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间, <strong>每一个 Web 应用都有自己的类空间, Web 应用之间通过各自的类加载器互相隔离</strong>.</p> <h6 id="_1-sharedclassloader"><a href="#_1-sharedclassloader" class="header-anchor">#</a> 1.SharedClassLoader</h6> <p>再来看<strong>第 2 个问题</strong>, 本质需求是两个 Web 应用之间<strong>怎么共享库类</strong>, 并且不能重复加载相同的类. 在双亲委托机制里, 各个子加载器都可以通过父加载器去加载类, 那么把需要共享的类放到父加载器的加载路径下不就行了吗, 应用程序也正是通过这种方式共享 JRE 的核心类. 因此 Tomcat 的设计者<strong>又加了一个类加载器 SharedClassLoader, 作为 WebAppClassLoader 的父加载器, 专门来加载 Web 应用之间共享的类</strong>. 如果 WebAppClassLoader 自己没有加载到某个类, 就会委托父加载器 SharedClassLoader 去加载这个类, SharedClassLoader 会在指定目录下加载共享类, 之后返回给 WebAppClassLoader, 这样共享的问题就解决了.</p> <h6 id="_2-catalinaclassloader"><a href="#_2-catalinaclassloader" class="header-anchor">#</a> 2.CatalinaClassloader</h6> <p>来看<strong>第 3 个问题</strong>, 如何隔离 Tomcat 本身的类和 Web 应用的类? 如果<strong>要共享可以通过父子关系, 要隔离那就需要兄弟关系</strong>了. 兄弟关系就是指两个类加载器是平行的, 它们可能拥有同一个父加载器, 但是两个兄弟类加载器加载的类是隔离的. 基于此 Tomcat 又设计一个<strong>类加载器 CatalinaClassloader, 专门来加载 Tomcat 自身的类</strong>. 这样设计有个问题, 那 Tomcat 和各 Web 应用之间需要共享一些类时该怎么办呢?</p> <h6 id="_3-commonclassloader"><a href="#_3-commonclassloader" class="header-anchor">#</a> 3.CommonClassLoader</h6> <p>老办法, 还是<strong>再增加一个 CommonClassLoader, 作为 CatalinaClassloader 和 SharedClassLoader 的父加载器</strong>. CommonClassLoader 能加载的类都可以被 CatalinaClassLoader 和 SharedClassLoader 使用, 而 CatalinaClassLoader 和 SharedClassLoader 能加载的类则与对方相互隔离. WebAppClassLoader 可以使用 SharedClassLoader 加载到的类, 但各个 WebAppClassLoader 实例之间相互隔离.</p> <h5 id="spring的加载问题"><a href="#spring的加载问题" class="header-anchor">#</a> Spring的加载问题</h5> <p>在 JVM 的实现中有一条隐含的规则, 默认情况下, <strong>如果一个类由类加载器 A 加载, 那么这个类的依赖类也是由相同的类加载器加载</strong>. 比如 Spring 作为一个 Bean 工厂, 它需要创建业务类的实例, 并且在创建业务类实例之前需要加载这些类. Spring 是通过调用 <code>Class.forName</code>​ 来加载业务类的, 来看一下 forName() 的源码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">forName</span><span class="token punctuation">(</span><span class="token class-name">String</span> className<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> caller <span class="token operator">=</span> <span class="token class-name">Reflection</span><span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">forName0</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span>caller<span class="token punctuation">)</span><span class="token punctuation">,</span> caller<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>可以看到在 forName() 的函数里, 会用调用者也就是 <strong>Spring 的加载器去加载业务类</strong>.</p> <p>前面提到, Web 应用之间共享的 JAR 包可以交给 SharedClassLoader 来加载, 从而避免重复加载. <strong>Spring 作为共享的第三方 JAR 包, 它本身是由 SharedClassLoader 来加载的</strong>, Spring 又要去加载业务类, 按照前面那条规则, 加载 Spring 的类加载器也会用来加载业务类, 但是业务类在 Web 应用目录下, 不在 SharedClassLoader 的加载路径下, 这该怎么办呢?</p> <p><strong>于是线程上下文加载器登场了, 它其实是一种类加载器传递机制</strong>. 为什么叫作 &quot;线程上下文加载器&quot; 呢, 因为这个类加载器保存在线程私有数据里, 只要是同一个线程, 一旦设置了线程上下文加载器, 在线程后续执行过程中就能把这个类加载器取出来用. <strong>因此 Tomcat 为每个 Web 应用创建一个 WebAppClassLoarder 类加载器, 并在启动 Web 应用的线程里设置线程上下文加载器, 这样 Spring 在启动时就将线程上下文加载器取出来, 用来加载 Bean</strong>. Spring 取线程上下文加载的代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>cl <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h5 id="总结-12"><a href="#总结-12" class="header-anchor">#</a> 总结</h5> <p>本节介绍了 JVM 的类加载器原理并剖析了源码, 以及 Tomcat 的类加载器的设计. 重点需要理解的是, Tomcat 的 Context 组件为每个 Web 应用创建一个 WebAppClassLoarder 类加载器, 由于<strong>不同类加载器实例加载的类是互相隔离的</strong>, 因此达到了隔离 Web 应用的目的, 同时通过 CommonClassLoader 等父加载器来共享第三方 JAR 包. 而共享的第三方 JAR 包怎么加载特定 Web 应用的类呢? 可以通过设置线程上下文加载器来解决. 我们应该牢记的是:</p> <ul><li>每个 Web 应用自己的 Java 类文件和依赖的 JAR 包, 分别放在 <code>WEB-INF/classes</code>​ 和 <code>WEB-INF/lib</code>​ 目录下面.</li> <li>多个应用共享的 Java 类文件和 JAR 包, 分别放在 Web 容器指定的共享目录下.</li> <li>当出现 ClassNotFound 错误时, 应该检查类加载器是否正确.</li></ul> <p>线程上下文加载器不仅仅可以用在 Tomcat 和 Spring 类加载的场景里, 核心框架类需要加载具体实现类时都可以用到它, 比如 JDBC 就是通过上下文类加载器来加载不同的数据库驱动的, 感兴趣的话可以深入了解一下.</p> <h4 id="_26-context容器-下-tomcat如何实现servlet规范"><a href="#_26-context容器-下-tomcat如何实现servlet规范" class="header-anchor">#</a> 26.Context容器(下):Tomcat如何实现Servlet规范?</h4> <p>Servlet 容器最重要的任务就是创建 Servlet 的实例并且调用 Servlet, 前面分析了 Tomcat 如何定义自己的类加载器来加载 Servlet, 但加载 Servlet 的类不等于创建 Servlet 的实例, 类加载只是第一步, 类加载好了才能创建类的实例, 也就是说 <strong>Tomcat 先加载 Servlet 的类, 然后在 Java 堆上创建了一个 Servlet 实例</strong>.</p> <p>一个 Web 应用里往往有多个 Servlet, 而在 Tomcat 中一个 Web 应用对应一个 Context 容器, 也就是说一个 Context 容器需要管理多个 Servlet 实例. 但 Context 容器并不直接持有 Servlet 实例, 而是通过子容器 Wrapper 来管理 Servlet, 可以把 Wrapper 容器看作是 Servlet 的包装.</p> <p>那为什么需要 Wrapper 呢? Context 容器直接维护一个 Servlet 数组不就行了吗? 这是因为 Servlet 不仅仅是一个类实例, 它还有相关的配置信息, 比如它的 URL 映射, 它的初始化参数, 因此设计出了一个包装器, 把 Servlet 本身和它相关的数据包起来, 没错, 这就是面向对象的思想.</p> <p>那管理好 Servlet 就完事大吉了吗? 别忘了 <strong>Servlet 还有两个兄弟: Listener 和 Filter</strong>, 它们也是 Servlet 规范中的重要成员, 因此 Tomcat 也需要创建它们的实例, 也需要在合适的时机去调用它们的方法.</p> <p>下面就来聊一聊是 Tomcat 如何做到上面这些事的.</p> <h5 id="servlet管理"><a href="#servlet管理" class="header-anchor">#</a> Servlet管理</h5> <p>前面提到, Tomcat 是用 Wrapper 容器来管理 Servlet 的, 那 Wrapper 容器具体长什么样子呢? 先来看看它里面有哪些关键的成员变量:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">volatile</span> <span class="token class-name">Servlet</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>毫无悬念, 它拥有一个 Servlet 实例, 并且 Wrapper 通过 loadServlet() 方法来实例化 Servlet. 为了方便阅读, 下面简化了代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">Servlet</span> <span class="token function">loadServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>
    <span class="token class-name">Servlet</span> servlet<span class="token punctuation">;</span>
  
    <span class="token comment">// 1. 创建一个 Servlet 实例</span>
    servlet <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Servlet</span><span class="token punctuation">)</span> instanceManager<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>servletClass<span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
    <span class="token comment">// 2. 调用了 Servlet 的 init() 方法, 这是 Servlet 规范要求的</span>
    <span class="token function">initServlet</span><span class="token punctuation">(</span>servlet<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token keyword">return</span> servlet<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>其实 loadServlet() 主要做了两件事: 创建 Servlet 的实例, 并且调用 Servlet 的 init() 方法, 因为这是 Servlet 规范要求的.</p> <p>那接下来的问题是, 什么时候会调到这个 loadServlet() 方法呢? 为了加快系统的启动速度, 往往会采取<strong>资源延迟加载</strong>的策略, Tomcat 也不例外, 默认情况下 Tomcat 在启动时不会加载 Servlet, 除非把 Servlet 的 <code>loadOnStartup</code>​ 参数设置为 <code>true</code>​.</p> <p>这里还需要注意的是, 虽然 Tomcat 在启动时不会创建 Servlet 实例, 但是<strong>会创建 Wrapper 容器</strong>, 就好比尽管枪里面还没有子弹, 先把枪造出来. 那子弹什么时候造呢? 是真正需要开枪的时候, 也就是说<strong>有请求来访问某个 Servlet 时, 这个 Servlet 的实例才会被创建</strong>.</p> <p>那 Servlet 是被谁调用的呢? 回忆一下前面提到过 Tomcat 的 <strong>Pipeline-Valve 机制</strong>, 每个容器组件都有自己的 Pipeline, 每个 Pipeline 中有一个 Valve 链, 并且每个容器组件有一个 BasicValve(基础阀). Wrapper 作为一个容器组件, 它也有自己的 Pipeline 和 BasicValve, Wrapper 的 BasicValve 叫 <strong>StandardWrapperValve</strong>.</p> <p>可以想到, 当请求到来时, Context 容器的 BasicValve 会调用 Wrapper 容器中 Pipeline 中的第一个 Valve, 然后会调用到 <strong>StandardWrapperValve</strong>. 先来看看它的 invoke() 方法是如何实现的, 同样为了方便阅读, 下面也简化了代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Request</span> request<span class="token punctuation">,</span> <span class="token class-name">Response</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
    <span class="token comment">// 1. 实例化 Servlet</span>
    servlet <span class="token operator">=</span> wrapper<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
    <span class="token comment">// 2. 给当前请求创建一个 Filter 链</span>
    <span class="token class-name">ApplicationFilterChain</span> filterChain <span class="token operator">=</span>
        <span class="token class-name">ApplicationFilterFactory</span><span class="token punctuation">.</span><span class="token function">createFilterChain</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> wrapper<span class="token punctuation">,</span> servlet<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
   <span class="token comment">// 3. 调用这个 Filter 链, Filter 链中的最后一个 Filter 会调用 Servlet</span>
   filterChain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> response<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>StandardWrapperValve 的 invoke() 方法比较复杂, 去掉其他异常处理的一些细节, 本质上就是三步:</p> <ul><li>第一步, 创建 Servlet 实例;</li> <li>第二步, 给当前请求创建一个 Filter 链;</li> <li>第三步, 调用这个 Filter 链.</li></ul> <p>你可能会问, <strong>为什么需要给每个请求创建一个 Filter 链</strong>? 这是因为每个请求的请求路径都不一样, 而 Filter 都有相应的路径映射, 因此不是所有的 Filter 都需要来处理当前的请求, 需要根据请求的路径来选择特定的一些 Filter 来处理.</p> <p>第二个问题是, 为什么没有看到调到 Servlet 的 service() 方法? 这是因为 Filter 链的 doFilter() 方法会负责调用 Servlet, 具体来说就是 Filter 链中的最后一个 Filter 会负责调用 Servlet.</p> <p>接下来看 Filter 的实现原理.</p> <h5 id="filter管理"><a href="#filter管理" class="header-anchor">#</a> Filter管理</h5> <p>与 Servlet 一样, Filter 也可以在 <code>web.xml</code>​ 文件里进行配置, 不同的是, Filter 的作用域是<strong>整个 Web 应用</strong>, 因此 <strong>Filter 的实例是在 Context 容器中进行管理</strong>的, Context 容器用 Map 集合来保存 Filter.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">FilterDef</span><span class="token punctuation">&gt;</span></span> filterDefs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>那上面提到的 Filter 链又是什么呢? <strong>Filter 链的存活期很短, 它是跟每个请求对应的. 一个新的请求来了, 就动态创建一个 Filter 链, 请求处理完了, Filter 链也就被回收了</strong>. 理解它的原理也非常关键, 还是来看看源码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationFilterChain</span> <span class="token keyword">implements</span> <span class="token class-name">FilterChain</span> <span class="token punctuation">{</span>
  
  <span class="token comment">// Filter 链中有 Filter 数组, 这个好理解</span>
  <span class="token keyword">private</span> <span class="token class-name">ApplicationFilterConfig</span><span class="token punctuation">[</span><span class="token punctuation">]</span> filters <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ApplicationFilterConfig</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  
  <span class="token comment">// Filter 链中的当前的调用位置</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 总共有多少了 Filter</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 
  <span class="token comment">// 每个 Filter 链对应一个 Servlet, 也就是它要调用的 Servlet</span>
  <span class="token keyword">private</span> <span class="token class-name">Servlet</span> servlet <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">internalDoFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
   
  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">internalDoFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> req<span class="token punctuation">,</span>
                                <span class="token class-name">ServletResponse</span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>
 
    <span class="token comment">// 每个 Filter 链在内部维护了一个 Filter 数组</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ApplicationFilterConfig</span> filterConfig <span class="token operator">=</span> filters<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token class-name">Filter</span> filter <span class="token operator">=</span> filterConfig<span class="token punctuation">.</span><span class="token function">getFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        filter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   
    <span class="token comment">// 所有 Filter 都调到了, 就调用 Servlet 的 service() 方法</span>
    servlet<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>从 ApplicationFilterChain 的源码可以看到几个关键信息:</p> <ol><li>Filter 链中除了有 Filter 对象的数组, 还有一个整数变量 pos, 这个变量用来记录<strong>当前被调用的 Filter 在数组中的位置</strong>.</li> <li>Filter 链中有个 Servlet 实例, 这个好理解, 因为上面提到了, <strong>每个 Filter 链最后都会调到一个 Servlet</strong>.</li> <li>Filter 链本身也实现了 doFilter() 方法, 直接调用了一个内部方法 internalDoFilter().</li> <li>internalDoFilter() 方法的实现比较有意思, 它做了一个判断, 如果当前 Filter 的位置小于 Filter 数组的长度, 也就是说 Filter 还没调完, 就从 Filter 数组拿下一个 Filter, 调用它的 doFilter() 方法. 否则, 意味着所有 Filter 都调到了, 就调用 Servlet 的 service() 方法.</li></ol> <p>但问题是, 方法体里没看到循环, 谁在不停地调用 Filter 链的 doFilter() 方法呢? Filter 是怎么依次调到的呢?</p> <p>答案是 <strong>Filter 本身的 doFilter() 方法会调用 Filter 链的 doFilter() 方法</strong>, 还是来看代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span><span class="token punctuation">{</span>
  
      <span class="token comment">// ...</span>
  
      <span class="token comment">// 调用 Filter 的方法</span>
      chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>注意 Filter 的 doFilter() 方法有个关键参数 FilterChain, 就是 Filter 链. 并且每个 Filter 在实现 doFilter() 时, 必须要调用 Filter 链的 doFilter() 方法, 而 Filter 链中保存当前 Filter 的位置, 会调用下一个 Filter 的 doFilter() 方法, 这样链式调用就完成了.</p> <p>Filter 链跟 Tomcat 的 Pipeline-Valve 本质都是<strong>责任链模式</strong>, 但是在具体实现上稍有不同, 可以细细体会一下.</p> <h5 id="listener管理"><a href="#listener管理" class="header-anchor">#</a> Listener管理</h5> <p>接着看 Servlet 规范里 Listener. 跟 Filter 一样, Listener 也是一种扩展机制, 可以监听容器内部发生的<strong>事件</strong>, 主要有两类事件:</p> <ul><li>第一类是<strong>生命状态的变化</strong>, 比如 Context 容器启动和停止, Session 的创建和销毁.</li> <li>第二类是<strong>属性的变化</strong>, 比如 Context 容器某个属性值变了, Session 的某个属性值变了以及新的请求来了等.</li></ul> <p>可以在 <code>web.xml</code>​ 配置或者通过注解的方式来添加监听器, 在监听器里实现业务逻辑. 对于 Tomcat 来说, 它需要读取配置文件, 拿到监听器类的名字, 实例化这些类, 并且在合适的时机调用这些监听器的方法.</p> <p>Tomcat 是<strong>通过 Context 容器来管理这些监听器</strong>的. Context 容器将两类事件分开来管理, 分别用不同的集合来存放不同类型事件的监听器:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 监听属性值变化的监听器</span>
<span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> applicationEventListenersList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// 监听生命事件的监听器</span>
<span class="token keyword">private</span> <span class="token class-name">Object</span> applicationLifecycleListenersObjects<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>剩下的事情就是<strong>触发监听器</strong>了, 比如在 Context 容器的启动方法里, 就触发了所有的 ServletContextListener:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 1. 拿到所有的生命周期监听器</span>
<span class="token class-name">Object</span> instances<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getApplicationLifecycleListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> instances<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 2. 判断 Listener 的类型是不是 ServletContextListener</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>instances<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">ServletContextListener</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
 
   <span class="token comment">// 3. 触发 Listener 的方法</span>
   <span class="token class-name">ServletContextListener</span> lr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServletContextListener</span><span class="token punctuation">)</span> instances<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
   lr<span class="token punctuation">.</span><span class="token function">contextInitialized</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>需要注意的是, 这里的 ServletContextListener 接口是一种留给用户的扩展机制, 用户可以实现这个接口来定义自己的监听器, 监听 Context 容器的启停事件. Spring 就是这么做的. ServletContextListener 跟 Tomcat 自己的生命周期事件 LifecycleListener 是不同的. LifecycleListener 定义在生命周期管理组件中, 由基类 LifeCycleBase 统一管理.</p> <h5 id="总结-13"><a href="#总结-13" class="header-anchor">#</a> 总结</h5> <p>Servlet 规范中最重要的就是 Servlet, Filter 和 Listener &quot;三兄弟&quot;. Web 容器最重要的职能就是<strong>把它们创建出来, 并在适当的时候调用它们的方法</strong>.</p> <p>Tomcat 通过 Wrapper 容器来管理 Servlet, Wrapper 包装了 Servlet 本身以及相应的参数, 这体现了面向对象中 &quot;封装&quot; 的设计原则.</p> <p>Tomcat 会给<strong>每个请求生成一个 Filter 链</strong>, Filter 链中的最后一个 Filter 会负责调用 Servlet 的 service() 方法.</p> <p>对于 Listener 来说, 可以定制自己的监听器来监听 Tomcat 内部发生的各种事件: 包括 Web 应用级别的, Session 级别的和请求级别的. Tomcat 中的 Context 容器统一维护了这些监听器, 并负责触发.</p> <h4 id="_27-新特性-tomcat如何支持异步servlet"><a href="#_27-新特性-tomcat如何支持异步servlet" class="header-anchor">#</a> 27.新特性:Tomcat如何支持异步Servlet?</h4> <p>当一个新的请求到达时, Tomcat 和 Jetty 会从线程池里拿出一个线程来处理请求, 这个线程会调用你的 Web 应用, Web 应用在处理请求的过程中, <strong>Tomcat 线程会一直阻塞, 直到 Web 应用处理完毕才能再输出响应, 最后 Tomcat 才回收这个线程</strong>.</p> <p>来思考这样一个问题, 假如 Web 应用需要较长的时间来处理请求(比如数据库查询或者等待下游的服务调用返回), 那么 Tomcat 线程一直不回收, 会占用系统资源, 在极端情况下会导致&quot;线程饥饿&quot;, 也就是说 Tomcat 和 Jetty <strong>没有更多的线程来处理新的请求</strong>.</p> <p>那该如何解决这个问题呢? 方案是 Servlet 3.0 中引入的<strong>异步 Servlet</strong>. 主要<strong>是在 Web 应用里启动一个单独的线程来执行这些比较耗时的请求, 而 Tomcat 线程立即返回, 不再等待 Web 应用将请求处理完, 这样 Tomcat 线程可以立即被回收到线程池, 用来响应其他请求, 降低了系统的资源消耗, 同时还能提高系统的吞吐量</strong>.</p> <p>这里分析一下如何开发一个异步 Servlet, 以及异步 Servlet 的工作原理, 也就是 Tomcat 是如何支持异步 Servlet 的, 进而彻底理解它的来龙去脉.</p> <h5 id="异步servlet示例"><a href="#异步servlet示例" class="header-anchor">#</a> 异步Servlet示例</h5> <p>先通过一个简单的示例来了解一下异步 Servlet 的实现.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span>urlPatterns <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;/async&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> asyncSupported <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AsyncServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>
 
    <span class="token comment">// Web 应用线程池, 用来处理异步 Servlet</span>
    <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> resp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1. 调用 startAsync 或者异步上下文</span>
        <span class="token keyword">final</span> <span class="token class-name">AsyncContext</span> ctx <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">startAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
       <span class="token comment">// 用线程池来执行耗时操作</span>
        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
                <span class="token comment">// 在这里做耗时的操作</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    ctx<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Handling Async Servlet&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 
                <span class="token comment">// 3. 异步 Servlet 处理完了调用异步上下文的 complete() 方法</span>
                ctx<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>上面的代码有三个要点:</p> <ol><li>通过注解的方式来注册 Servlet, 除了 @WebServlet 注解, 还需要加上 asyncSupported=true 的属性, 表明<strong>当前的 Servlet 是一个异步 Servlet</strong>.</li> <li>Web 应用程序需要<strong>调用 Request 对象的 startAsync() 方法来拿到一个异步上下文 AsyncContext. 这个上下文保存了请求和响应对象</strong>.</li> <li>Web 应用需要<strong>开启一个新线程来处理耗时的操作, 处理完成后需要调用 AsyncContext 的 complete() 方法. 目的是告诉 Tomcat, 请求已经处理完成</strong>.</li></ol> <p>这里注意, 虽然异步 Servlet 允许用更长的时间来处理请求, 但是也有超时限制的, 默认是 30 秒, 如果 30 秒内请求还没处理完, Tomcat 会触发超时机制, 向浏览器返回超时错误, 如果这个时候 Web 应用再调用 <code>ctx.complete()</code>​ 方法, 会得到一个 IllegalStateException 异常.</p> <h5 id="异步servlet原理"><a href="#异步servlet原理" class="header-anchor">#</a> 异步Servlet原理</h5> <p>通过上面的例子可以对 Servlet 的异步实现有了基本的理解. 要理解 Tomcat 在这个过程都做了什么事情, 关键就是要弄清楚 <code>req.startAsync()</code>​ 方法和 <code>ctx.complete()</code>​ 方法都做了什么.</p> <h6 id="_1-startasync-方法"><a href="#_1-startasync-方法" class="header-anchor">#</a> 1.startAsync()方法</h6> <p>startAsync() 方法其实就是创建了一个异步上下文 AsyncContext 对象, <strong>AsyncContext 对象的作用是保存请求的中间信息, 比如 Request 和 Response 对象等上下文信息</strong>. 你来思考一下为什么需要保存这些信息呢?</p> <p>这是因为 Tomcat 的工作线程在 <code>Request.startAsync()</code>​ 调用之后, 就直接结束回到线程池中了, 线程本身不会保存任何信息. 也就是说一个请求到服务端, 执行到一半, 你的 Web 应用正在处理, 这个时候 Tomcat 的工作线程没了, 这就<strong>需要有个缓存能够保存原始的 Request 和 Response 对象, 而这个缓存就是 AsyncContext</strong>.</p> <p><strong>有了 AsyncContext, Web 应用通过它拿到 request 和 response 对象, 拿到 Request 对象后就可以读取请求信息, 请求处理完了还需要通过 Response 对象将 HTTP 响应发送给浏览器.</strong></p> <p>除了创建 AsyncContext 对象, startAsync() 还需要完成一个关键任务, 那就是告诉 Tomcat 当前的 Servlet 处理方法返回时, 不要把响应发到浏览器, 因为这个时候, 响应还没生成呢; 并且不能把 Request 对象和 Response 对象销毁, 因为后面 Web 应用还要用呢.</p> <p>在 Tomcat 中, 负责 flush 响应数据的是 CoyoteAdaptor, 它还会销毁 Request 对象和 Response 对象, 因此需要通过某种机制通知 CoyoteAdaptor, 具体来说是通过下面这行代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">this</span><span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">getCoyoteRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token class-name">ActionCode</span><span class="token punctuation">.</span><span class="token constant">ASYNC_START</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>可以把它理解为一个 Callback, 在这个 action() 方法里设置了 Request 对象的状态, 设置它为一个异步 Servlet 请求.</p> <p>连接器是调用 CoyoteAdapter 的 service() 方法来处理请求的, 而 CoyoteAdapter 会调用容器的 service() 方法, 当容器的 service() 方法返回时, <strong>CoyoteAdapter 判断当前的请求是不是异步 Servlet 请求, 如果是, 就不会销毁 Request 和 Response 对象, 也不会把响应信息发到浏览器</strong>. 可以通过下面的代码理解一下, 这是 CoyoteAdapter 的 service() 方法, 下面对它进行了简化:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>coyote<span class="token punctuation">.</span></span>Request</span> req<span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>coyote<span class="token punctuation">.</span></span>Response</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  
   <span class="token comment">// 调用容器的 service 方法处理请求</span>
    connector<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
           <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
   <span class="token comment">// 如果是异步 Servlet 请求, 仅仅设置一个标志, </span>
   <span class="token comment">// 否则说明是同步 Servlet 请求, 就将响应数据刷到浏览器</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">isAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        async <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        request<span class="token punctuation">.</span><span class="token function">finishRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        response<span class="token punctuation">.</span><span class="token function">finishResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   
   <span class="token comment">// 如果不是异步 Servlet 请求, 就销毁 Request 对象和 Response 对象</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>async<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        request<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        response<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>接下来, 当 CoyoteAdaptor 的 service() 方法返回到 ProtocolHandler 组件时, ProtocolHandler 判断返回值, 如果当前请求是一个异步 Servlet 请求, <strong>它会把当前 Socket 的协议处理者 Processor 缓存起来, 将 SocketWrapper 对象和相应的 Processor 存到一个 Map 数据结构里</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">,</span> <span class="token class-name">Processor</span><span class="token punctuation">&gt;</span></span> connections <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>**之所以要缓存是因为这个请求接下来还要接着处理, 还是由原来的 Processor 来处理, 通过 SocketWrapper 就能从 Map 里找到相应的 Processor. **</p> <h6 id="_2-complete-方法"><a href="#_2-complete-方法" class="header-anchor">#</a> 2.complete()方法</h6> <p>接着再来看关键的 <code>ctx.complete()</code>​ 方法, 当<strong>请求处理完成时, Web 应用调用这个方法</strong>. 那么这个方法做了些什么事情呢? <strong>最重要的就是把响应数据发送到浏览器</strong>.</p> <p>这件事情不能由 Web 应用线程来做, 也就是说 <code>ctx.complete()</code>​ 方法不能直接把响应数据发送到浏览器, 因为这件事情应该由 Tomcat 线程来做, 但具体怎么做呢?</p> <p><strong>由于连接器中的 Endpoint 组件检测到有请求数据达到时, 会创建一个 SocketProcessor 对象交给线程池去处理, 因此 Endpoint 的通信处理和具体请求处理在两个线程里运行.</strong></p> <p>在异步 Servlet 的场景里, Web 应用通过调用 <code>ctx.complete()</code>​ 方法时, 也可以生成一个新的 SocketProcessor 任务类, 交给线程池处理. 对于异步 Servlet 请求来说, 相应的 Socket 和协议处理组件 Processor 都被<strong>缓存</strong>起来了, 并且这些对象都可以通过 Request 对象拿到.</p> <p>​<code>ctx.complete()</code>​ 实现如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 检查状态合法性, 我们先忽略这句</span>
    <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 调用 Request 对象的 action 方法, 其实就是通知连接器, 这个异步请求处理完了</span>
    request<span class="token punctuation">.</span><span class="token function">getCoyoteRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token class-name">ActionCode</span><span class="token punctuation">.</span><span class="token constant">ASYNC_COMPLETE</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>可以看到 complete() 方法调用了 Request 对象的 action() 方法. 而在 action() 方法里, 则是调用了 Processor 的 processSocketEvent() 方法, 并且传入了操作码 OPEN_READ.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">case</span> <span class="token constant">ASYNC_COMPLETE</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">clearDispatches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>asyncStateMachine<span class="token punctuation">.</span><span class="token function">asyncComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">processSocketEvent</span><span class="token punctuation">(</span><span class="token class-name">SocketEvent</span><span class="token punctuation">.</span><span class="token constant">OPEN_READ</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>接着看 processSocketEvent() 方法, 它调用 SocketWrapper 的 processSocket() 方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">processSocketEvent</span><span class="token punctuation">(</span><span class="token class-name">SocketEvent</span> event<span class="token punctuation">,</span> <span class="token keyword">boolean</span> dispatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">SocketWrapperBase</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> socketWrapper <span class="token operator">=</span> <span class="token function">getSocketWrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>socketWrapper <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        socketWrapper<span class="token punctuation">.</span><span class="token function">processSocket</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> dispatch<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>而 SocketWrapper 的 processSocket() 方法会创建 SocketProcessor 任务类, 并通过 Tomcat 线程池来处理:</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">processSocket</span><span class="token punctuation">(</span><span class="token class-name">SocketWrapperBase</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">&gt;</span></span> socketWrapper<span class="token punctuation">,</span> <span class="token class-name">SocketEvent</span> event<span class="token punctuation">,</span> <span class="token keyword">boolean</span> dispatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  
      <span class="token keyword">if</span> <span class="token punctuation">(</span>socketWrapper <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  
      <span class="token class-name">SocketProcessorBase</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">&gt;</span></span> sc <span class="token operator">=</span> processorCache<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>sc <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          sc <span class="token operator">=</span> <span class="token function">createSocketProcessor</span><span class="token punctuation">(</span>socketWrapper<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          sc<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>socketWrapper<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 线程池运行</span>
      <span class="token class-name">Executor</span> executor <span class="token operator">=</span> <span class="token function">getExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>dispatch <span class="token operator">&amp;&amp;</span> executor <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>sc<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          sc<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>请注意 createSocketProcessor() 方法的第二个参数是 SocketEvent, 这里传入的是 OPEN_READ. 通过这个参数就能控制 SocketProcessor 的行为, 因为不需要再把请求发送到容器进行处理, 只需要向浏览器端发送数据, 并且重新在这个 Socket 上监听新的请求就行了.</p> <p>最后通过一张图理解一下整个过程:</p> <p><img src="/img/image-20230405161923-311rtzq.png" alt="image"></p> <h5 id="总结-14"><a href="#总结-14" class="header-anchor">#</a> 总结</h5> <p>非阻塞 I/O 模型可以利用很少的线程处理大量的连接, 提高了并发度, 本质就是通过一个 Selector 线程查询多个 Socket 的 I/O 事件, 减少了线程的阻塞等待.</p> <p>**同样, 异步 Servlet 机制也是减少了线程的阻塞等待, 将 Tomcat 线程和业务线程分开, Tomca 线程不再等待业务代码的执行. **</p> <p>那什么样的场景适合异步 Servlet 呢? 适合的场景有很多, 最主要的还是根据实际情况, 如果拿不准是否适合异步 Servlet, 就看一条: <strong>如果你发现 Tomcat 的线程不够了, 大量线程阻塞在等待 Web 应用的处理上, 而 Web 应用又没有优化的空间了, 确实需要长时间处理, 这个时候你不妨尝试一下异步 Servlet.</strong></p> <h4 id="_28-新特性-tomcat和jetty如何处理spring-boot应用"><a href="#_28-新特性-tomcat和jetty如何处理spring-boot应用" class="header-anchor">#</a> 28.新特性:Tomcat和Jetty如何处理Spring Boot应用?</h4> <p>为了方便开发和部署, Spring Boot 在<strong>内部启动了一个嵌入式的 Web 容器</strong>. 由于 Tomcat 和 Jetty 是组件化的设计, 要启动 Tomcat 或者 Jetty 其实就是启动这些组件. 在 Tomcat 独立部署的模式下, 可以通过 startup 脚本来启动 Tomcat, Tomcat 中的 Bootstrap 和 Catalina 会负责初始化类加载器, 并解析 <code>server.xml</code>​ 和启动这些组件.</p> <p>在<strong>内嵌式</strong>的模式下, Bootstrap 和 Catalina 的工作就由 Spring Boot 来做了, <strong>Spring Boot 调用了 Tomcat 和 Jetty 的 API 来启动这些组件</strong>. 那 Spring Boot 具体是怎么做的呢? 如何向 SpringBoot 中的 Tomcat 注册 Servlet 或者 Filter 呢? 又如何定制内嵌式的 Tomcat?</p> <h5 id="spring-boot中web容器相关的接口"><a href="#spring-boot中web容器相关的接口" class="header-anchor">#</a> Spring Boot中Web容器相关的接口</h5> <p>既然要支持多种 Web 容器, Spring Boot 对<strong>内嵌式 Web 容器</strong>进行了抽象, 定义了 **WebServer ** 接口:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">WebServer</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">WebServerException</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">WebServerException</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>各种 Web 容器比如 Tomcat 和 Jetty 需要去实现这个接口.</p> <p>Spring Boot 还定义了一个工厂 **ServletWebServerFactory ** 来创建 Web 容器, 返回的对象就是上面提到的 <strong>WebServer</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ServletWebServerFactory</span> <span class="token punctuation">{</span>
    <span class="token class-name">WebServer</span> <span class="token function">getWebServer</span><span class="token punctuation">(</span><span class="token class-name">ServletContextInitializer</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> initializers<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以看到 getWebServer() 有个参数, 类型是 <strong>ServletContextInitializer</strong>. 它表示 ServletContext 的初始化器, 用于 ServletContext 中的一些配置:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ServletContextInitializer</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">onStartup</span><span class="token punctuation">(</span><span class="token class-name">ServletContext</span> servletContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里注意, 上面提到的 getWebServer() 方法会调用 ServletContextInitializer 的 onStartup() 方法, 也就是说如果你想在 Servlet 容器启动时做一些事情, 比如注册自己的 Servlet, 可以实现一个 ServletContextInitializer, 在 Web 容器启动时, Spring Boot 会把所有实现了 <strong>ServletContextInitializer</strong> 接口的类收集起来, 统一调它们的 onStartup() 方法.</p> <p>为了支持对内嵌式 Web 容器的定制化, Spring Boot 还定义了 **WebServerFactoryCustomizerBeanPostProcessor ** 接口, 它是一个 <strong>BeanPostProcessor</strong>, 它在 postProcessBeforeInitialization 过程中去寻找 Spring 容器中 <strong>WebServerFactoryCustomizer</strong> 类型的 Bean, 并依次调用 WebServerFactoryCustomizer 接口的 customize() 方法做一些定制化.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">WebServerFactoryCustomizer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">WebServerFactory</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">customize</span><span class="token punctuation">(</span><span class="token class-name">T</span> factory<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h5 id="内嵌式web容器的创建和启动"><a href="#内嵌式web容器的创建和启动" class="header-anchor">#</a> 内嵌式Web容器的创建和启动</h5> <p><strong>铺垫了这些接口, 再来看看 Spring Boot 是如何实例化和启动一个 Web 容器的</strong>. 由于 Spring 的核心是一个 ApplicationContext, 它的抽象实现类 <strong>AbstractApplicationContext</strong> 实现了著名的 <strong>refresh() ** 方法, 它用来新建或者刷新一个 ApplicationContext, 在 refresh() 方法中会调用 <strong>onRefresh() 方法</strong>, AbstractApplicationContext 的子类可以</strong>重写这个方法 onRefresh() 方法, 来实现特定 Context 的刷新逻辑**, 因此 <mark><strong>ServletWebServerApplicationContext 就是通过重写 onRefresh() 方法来创建内嵌式的 Web 容器</strong></mark>, 具体创建过程是这样的:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 重写 onRefresh 方法, 调用 createWebServer 创建和启动 Tomcat</span>
        <span class="token function">createWebServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// createWebServer 的具体实现</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">createWebServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里 WebServer 是 Spring Boot 抽象出来的接口, 具体实现类就是不同的 Web 容器</span>
    <span class="token class-name">WebServer</span> webServer <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>webServer<span class="token punctuation">;</span>
    <span class="token class-name">ServletContext</span> servletContext <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 如果 Web 容器还没创建</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>webServer <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> servletContext <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 通过 Web 容器工厂来创建</span>
        <span class="token class-name">ServletWebServerFactory</span> factory <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getWebServerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 注意传入了一个 &quot;SelfInitializer&quot;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>webServer <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getWebServer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServletContextInitializer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSelfInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>servletContext <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSelfInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onStartup</span><span class="token punctuation">(</span>servletContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ServletException</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initPropertySources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>再来看看 getWebSever() 具体做了什么, 以 Tomcat 为例, 主要调用 Tomcat 的 API 去创建各种组件:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">WebServer</span> <span class="token function">getWebServer</span><span class="token punctuation">(</span><span class="token class-name">ServletContextInitializer</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> initializers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1. 实例化一个 Tomcat, 可以理解为 Server 组件. </span>
    <span class="token class-name">Tomcat</span> tomcat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tomcat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 2. 创建一个临时目录</span>
    <span class="token class-name">File</span> baseDir <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>baseDirectory <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>baseDirectory <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createTempDir</span><span class="token punctuation">(</span><span class="token string">&quot;tomcat&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    tomcat<span class="token punctuation">.</span><span class="token function">setBaseDir</span><span class="token punctuation">(</span>baseDir<span class="token punctuation">.</span><span class="token function">getAbsolutePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 3. 初始化各种组件</span>
    <span class="token class-name">Connector</span> connector <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Connector</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>protocol<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tomcat<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addConnector</span><span class="token punctuation">(</span>connector<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">customizeConnector</span><span class="token punctuation">(</span>connector<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tomcat<span class="token punctuation">.</span><span class="token function">setConnector</span><span class="token punctuation">(</span>connector<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tomcat<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAutoDeploy</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">configureEngine</span><span class="token punctuation">(</span>tomcat<span class="token punctuation">.</span><span class="token function">getEngine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 4. 创建定制版的 &quot;Context&quot; 组件. </span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareContext</span><span class="token punctuation">(</span>tomcat<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> initializers<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getTomcatWebServer</span><span class="token punctuation">(</span>tomcat<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>你可能好奇 prepareContext() 方法是做什么的呢? 这里的 Context 是指 <strong>Tomcat 中的 Context 组件</strong>, 为了方便控制 Context 组件的行为, Spring Boot 定义了自己的 <strong>TomcatEmbeddedContext</strong>, 它扩展了 Tomcat 的 StandardContext:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">TomcatEmbeddedContext</span> <span class="token keyword">extends</span> <span class="token class-name">StandardContext</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h5 id="注册servlet的三种方式"><a href="#注册servlet的三种方式" class="header-anchor">#</a> 注册Servlet的三种方式</h5> <h6 id="_1-servlet注解"><a href="#_1-servlet注解" class="header-anchor">#</a> 1.Servlet注解</h6> <p>在 Spring Boot 启动类上加上 @ServletComponentScan 注解后, <strong>使用 @WebServlet, @WebFilter, @WebListener 标记的 Servlet, Filter, Listener 就可以自动注册到 Servlet 容器中</strong>, 无需其他代码, 通过下面的代码示例来理解一下.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token annotation punctuation">@ServletComponentScan</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> xxxApplication<span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span><span class="token string">&quot;/hello&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在 Web 应用的入口类上加上 @ServletComponentScan,  并且在 Servlet 类上加上 @WebServlet, 这样 SpringBoot 会负责<strong>将 Servlet 注册到内嵌的 Tomcat 中</strong>.</p> <h6 id="_2-servletregistrationbean"><a href="#_2-servletregistrationbean" class="header-anchor">#</a> 2.ServletRegistrationBean</h6> <p>同时 Spring Boot 也提供了 <strong>ServletRegistrationBean, FilterRegistrationBean 和 ServletListenerRegistrationBean 这三个类分别用来注册 Servlet, Filter, Listener</strong>. 假如要注册一个 Servlet, 可以这样做:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">ServletRegistrationBean</span> <span class="token function">servletRegistrationBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ServletRegistrationBean</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HelloServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">&quot;/hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这段代码实现的方法返回一个 ServletRegistrationBean, 并将它当作 Bean 注册到 Spring 中, 因此需要把这段代码放到 Spring Boot 自动扫描的目录中, 或者放到 @Configuration 标识的类中.</p> <h6 id="_3-动态注册"><a href="#_3-动态注册" class="header-anchor">#</a> 3.动态注册</h6> <p>还可以创建一个类去实现前面提到的 <strong>ServletContextInitializer</strong> 接口, 并把它注册为一个 Bean, Spring Boot 会负责调用这个接口的 onStartup() 方法.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyServletRegister</span> <span class="token keyword">implements</span> <span class="token class-name">ServletContextInitializer</span> <span class="token punctuation">{</span>
 
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStartup</span><span class="token punctuation">(</span><span class="token class-name">ServletContext</span> servletContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  
        <span class="token comment">// Servlet 3.0 规范新的 API</span>
        <span class="token class-name">ServletRegistration</span> myServlet <span class="token operator">=</span> servletContext
                <span class="token punctuation">.</span><span class="token function">addServlet</span><span class="token punctuation">(</span><span class="token string">&quot;HelloServlet&quot;</span><span class="token punctuation">,</span> <span class="token class-name">HelloServlet</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        myServlet<span class="token punctuation">.</span><span class="token function">addMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
        myServlet<span class="token punctuation">.</span><span class="token function">setInitParameter</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello Servlet&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>这里注意两点:</p> <ul><li>ServletRegistrationBean 其实也是通过 ServletContextInitializer 来实现的, 它实现了 ServletContextInitializer 接口.</li> <li>注意到 onStartup() 方法的参数 ServletContext, 可以通过调用它的 <strong>addServlet()</strong>  方法来动态注册新的 Servlet, 这是 Servlet 3.0 以后才有的功能.</li></ul> <h5 id="web容器的定制"><a href="#web容器的定制" class="header-anchor">#</a> Web容器的定制</h5> <p>再来考虑一个问题, 那就是如何在 Spring Boot 中<strong>定制 Web 容器</strong>. 在 Spring Boot 2.0 中, 可以通过两种方式来定制 Web 容器.</p> <p><strong>第一种方式</strong>是通过通用的 Web 容器工厂 ConfigurableServletWebServerFactory, 来定制一些 Web 容器通用的参数:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyGeneralCustomizer</span> <span class="token keyword">implements</span>
  <span class="token class-name">WebServerFactoryCustomizer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ConfigurableServletWebServerFactory</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">customize</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableServletWebServerFactory</span> factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        factory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">8081</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        factory<span class="token punctuation">.</span><span class="token function">setContextPath</span><span class="token punctuation">(</span><span class="token string">&quot;/hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>第二种方式</strong>是通过特定 Web 容器的工厂比如 TomcatServletWebServerFactory 来进一步定制. 下面的例子给 Tomcat 增加一个 Valve, 这个 Valve 的功能是向请求头里添加 traceid, 用于分布式追踪. TraceValve 的定义如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">TraceValve</span> <span class="token keyword">extends</span> <span class="token class-name">ValveBase</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Request</span> request<span class="token punctuation">,</span> <span class="token class-name">Response</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>
 
        request<span class="token punctuation">.</span><span class="token function">getCoyoteRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMimeHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
        <span class="token function">addValue</span><span class="token punctuation">(</span><span class="token string">&quot;traceid&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token string">&quot;1234xxxxabcd&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token class-name">Valve</span> next <span class="token operator">=</span> <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
 
        next<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>跟第一种方式类似, 再添加一个定制器, 代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyTomcatCustomizer</span> <span class="token keyword">implements</span>
        <span class="token class-name">WebServerFactoryCustomizer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TomcatServletWebServerFactory</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
 
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">customize</span><span class="token punctuation">(</span><span class="token class-name">TomcatServletWebServerFactory</span> factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        factory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">8081</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        factory<span class="token punctuation">.</span><span class="token function">setContextPath</span><span class="token punctuation">(</span><span class="token string">&quot;/hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        factory<span class="token punctuation">.</span><span class="token function">addEngineValves</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TraceValve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="_30-热点答疑-3-spring框架中的设计模式"><a href="#_30-热点答疑-3-spring框架中的设计模式" class="header-anchor">#</a> 30.热点答疑(3):Spring框架中的设计模式</h4> <p>这里分析一下 Spring 框架里的设计模式. Spring 的核心功能是 IOC 容器以及 AOP 面向切面编程, 同样也是很多 Web 后端工程师每天都要打交道的框架.</p> <h5 id="简单工厂模式"><a href="#简单工厂模式" class="header-anchor">#</a> 简单工厂模式</h5> <p>我考虑这样一个场景: 当 A 对象需要调用 B 对象的方法时, 需要在 A 中 new 一个 B 的实例, 我们把这种方式叫作<strong>硬编码耦合</strong>, 它的缺点是一旦需求发生变化, 比如需要使用 C 类来代替 B 时, 就要改写 A 类的方法. 假如应用中有 1000 个类以硬编码的方式耦合了 B, 那改起来就费劲了. 于是简单工厂模式就登场了, 简单工厂模式又叫静态工厂方法, 其实质是由一个工厂类根据传入的参数, 动态决定应该创建哪一个产品类.</p> <p>Spring 中的 <strong>BeanFactory</strong> 就是简单工厂模式的体现, BeanFactory 是 Spring IOC 容器中的一个核心接口, 它的定义如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanFactory</span> <span class="token punctuation">{</span>
   <span class="token class-name">Object</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>
   <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> requiredType<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token class-name">Object</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> requiredType<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> requiredType<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">boolean</span> <span class="token function">containsBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
   boolea <span class="token function">isPrototype</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">boolean</span> <span class="token function">isTypeMatch</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">ResolvableType</span> typeToMatch<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">boolean</span> <span class="token function">isTypeMatch</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> typeToMatch<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getAliases</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>可以通过它的具体实现类(比如 ClassPathXmlApplicationContext)来获取 Bean:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">BeanFactory</span> bf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">&quot;spring.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">User</span> userBean <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span> bf<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;userBean&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>从上面代码可以看到, 使用者不需要自己来 new 对象, 而是通过工厂类的方法 getBean() 来获取对象实例, 这是典型的简单工厂模式, 只不过 Spring 是用反射机制来创建 Bean 的.</p> <h5 id="工厂方法模式"><a href="#工厂方法模式" class="header-anchor">#</a> 工厂方法模式</h5> <p>工厂方法模式说白了其实就是简单工厂模式的一种升级或者说是进一步抽象, 它可以应用于更加复杂的场景, 灵活性也更高. 在简单工厂中, 由工厂类进行所有的逻辑判断, 实例创建; <strong>如果不想在工厂类中进行判断, 可以为不同的产品提供不同的工厂, 不同的工厂生产不同的产品, 每一个工厂都只对应一个相应的对象, 这就是工厂方法模式</strong>.</p> <p>Spring 中的 <strong>FactoryBean</strong> 就是这种思想的体现, FactoryBean 可以理解为工厂 Bean, 先来看看它的定义:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">T</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这里定义一个类 UserFactoryBean 来实现 FactoryBean 接口, 主要是在 getObject() 方法里 new 一个 User 对象. 这样通过 getBean(id) 获得的是该工厂所产生的 User 的实例, 而不是 UserFactoryBean 本身的实例, 像下面这样:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">BeanFactory</span> bf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">&quot;user.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">User</span> userBean <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span> bf<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;userFactoryBean&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h5 id="单例模式"><a href="#单例模式" class="header-anchor">#</a> 单例模式</h5> <p>单例模式是指一个类在整个系统运行过程中, 只允许产生一个实例. 那 Spring 是如何实现单例模式的呢? 答案是<strong>通过单例注册表</strong>的方式, 具体来说就是使用了 HashMap. 为了方便阅读, 也对代码进行了简化:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultSingletonBeanRegistry</span> <span class="token punctuation">{</span>
  
    <span class="token comment">// 使用了线程安全容器 ConcurrentHashMap, 保存各种单实例对象</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
 
    <span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先到 HashMap 中拿 Object</span>
    <span class="token class-name">Object</span> singletonObject <span class="token operator">=</span> singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 如果没拿到通过反射创建一个对象实例, 并添加到 HashMap 中</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      singletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span>
                           <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   
   <span class="token comment">// 返回对象实例</span>
   <span class="token keyword">return</span> singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>上面的代码逻辑比较清晰, 先到 HashMap 去拿单实例对象, 没拿到就创建一个添加到 HashMap.</p> <h5 id="代理模式"><a href="#代理模式" class="header-anchor">#</a> 代理模式</h5> <p><strong>所谓代理, 是指它与被代理对象实现了相同的接口, 客户端必须通过代理才能与被代理的目标类进行交互, 而代理一般在交互的过程中(交互前后), 进行某些特定的处理, 比如在调用这个方法前做前置处理, 调用这个方法后做后置处理</strong>. 代理模式中有下面几种角色:</p> <ul><li><strong>抽象接口</strong>: 定义目标类及代理类的共同接口, 这样在任何可以使用目标对象的地方都可以使用代理对象.</li> <li><strong>目标对象</strong>: 定义了代理对象所代表的目标对象, 专注于业务功能的实现.</li> <li><strong>代理对象</strong>: 代理对象内部含有目标对象的引用, 收到客户端的调用请求时, 代理对象通常不会直接调用目标对象的方法, 而是在调用之前和之后实现一些额外的逻辑.</li></ul> <p>代理模式的好处是, 可以在目标对象业务功能的基础上添加一些<strong>公共的逻辑</strong>, 比如想给目标对象加入日志, 权限管理和事务控制等功能, 就可以使用代理类来完成, 而没必要修改目标类, 从而使得目标类保持稳定. 这其实是<strong>开闭原则</strong>的体现, 不要随意去修改别人已经写好的代码或者方法.</p> <p><strong>代理又分为静态代理和动态代理两种方式</strong>. 静态代理需要定义接口, 被代理对象(目标对象)与代理对象(Proxy) 一起实现相同的接口, 通过一个例子来理解一下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 抽象接口</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IStudentDao</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// 目标对象</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudentDao</span> <span class="token keyword">implements</span> <span class="token class-name">IStudentDao</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot; 保存成功 &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// 代理对象</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudentDaoProxy</span> <span class="token keyword">implements</span> <span class="token class-name">IStudentDao</span><span class="token punctuation">{</span>
    <span class="token comment">// 持有目标对象的引用</span>
    <span class="token keyword">private</span> <span class="token class-name">IStudentDao</span> target<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">StudentDaoProxy</span><span class="token punctuation">(</span><span class="token class-name">IStudentDao</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">// 在目标功能对象方法的前后加入事务控制</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot; 开始事务 &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        target<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 执行目标对象的方法</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot; 提交事务 &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建目标对象</span>
    <span class="token class-name">StudentDao</span> target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StudentDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment">// 创建代理对象, 把目标对象传给代理对象, 建立代理关系</span>
    <span class="token class-name">StudentDaoProxy</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StudentDaoProxy</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
    <span class="token comment">// 执行的是代理的方法</span>
    proxy<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p>而 Spring 的 <strong>AOP 采用的是动态代理的方式</strong>, 而动态代理就是指代理类在程序运行时由 JVM 动态创建. 在上面静态代理的例子中, 代理类(StudentDaoProxy)是自己定义好的, 在程序运行之前就已经编译完成. 而动态代理, 代理类并不是在 Java 代码中定义的, 而是在运行时根据在 Java 代码中的&quot;指示&quot;动态生成的. 那怎么 &quot;指示&quot; JDK 去动态地生成代理类呢?</p> <p>在 Java 的 <code>java.lang.reflect</code>​ 包里提供了一个 Proxy 类和一个 <strong>InvocationHandler</strong> 接口, 通过这个类和这个接口可以生成动态代理对象. 具体来说有如下步骤:</p> <ol><li>定义一个 InvocationHandler 类, 将需要扩展的逻辑集中放到这个类中, 比如下面的例子模拟了添加事务控制的逻辑.</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInvocationHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">private</span> <span class="token class-name">Object</span> obj<span class="token punctuation">;</span>
 
    <span class="token keyword">public</span> <span class="token class-name">MyInvocationHandler</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token operator">=</span>obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
            <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
 
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot; 开始事务 &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot; 开始事务 &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><ol start="2"><li>使用 Proxy 的 newProxyInstance() 方法动态的创建代理对象:</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建目标对象 StudentDao</span>
  <span class="token class-name">IStudentDao</span> stuDAO <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StudentDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 创建 MyInvocationHandler 对象</span>
  <span class="token class-name">InvocationHandler</span> handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyInvocationHandler</span><span class="token punctuation">(</span>stuDAO<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 使用 Proxy.newProxyInstance 动态的创建代理对象 stuProxy</span>
  <span class="token class-name">IStudentDao</span> stuProxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IStudentDao</span><span class="token punctuation">)</span> 
 <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>stuDAO<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stuDAO<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 动用代理对象的方法</span>
  stuProxy<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>**上面的代码实现和静态代理一样的功能, 相比于静态代理, 动态代理的优势在于可以很方便地对代理类的函数进行统一的处理, 而不用修改每个代理类中的方法. **</p> <p><strong>Spring 实现了通过动态代理对类进行方法级别的切面增强</strong>, 解释一下这句话, 其实就是动态生成目标对象的代理类, 并在代理类的方法中设置拦截器, 通过执行拦截器中的逻辑增强了代理方法的功能, 从而实现 AOP.</p> <h3 id="通用组件"><a href="#通用组件" class="header-anchor">#</a> 通用组件</h3> <h4 id="_31-logger组件-tomcat的日志框架及实战"><a href="#_31-logger组件-tomcat的日志框架及实战" class="header-anchor">#</a> 31.Logger组件:Tomcat的日志框架及实战</h4> <p>每一个系统都有一些通用的模块, 比如日志模块, 异常处理模块, 工具类等, 对于 Tomcat 来说, 比较重要的通用模块有日志, Session 管理和集群管理. 下面来介绍这些通用模块.</p> <p>日志模块作为一个通用的功能, 在系统里通常会使用第三方的日志框架. Java 的日志框架有很多, 比如: JUL(Java Util Logging), Log4j, Logback, Log4j2, Tinylog 等. 除此之外, 还有 JCL(Apache Commons Logging)和 SLF4J 这样的“门面日志”. 下面是 SLF4J 与日志框架 Logback, Log4j 的关系图:</p> <p><img src="/img/image-20230405162108-n8et45j.png" alt=""></p> <p>先来解释一下什么是&quot;门面日志&quot;. &quot;门面日志&quot; 利用了设计模式中的门面模式思想, <strong>对外提供一套通用的日志记录的 API, 而不提供具体的日志输出服务, 如果要实现日志输出, 需要集成其他的日志框架, 比如 Log4j, Logback, Log4j2 等</strong>.</p> <p>这种门面模式的好处在于, 记录日志的 <strong>API 和日志输出的服务分离开</strong>, 代码里面只需要关注记录日志的 API, <strong>通过 SLF4J 指定的接口记录日志; 而日志输出通过引入 JAR 包的方式即可指定其他的日志框架</strong>. ** 当需要改变系统的日志输出服务时, 不用修改代码, 只需要改变引入日志输出框架 JAR 包**.</p> <p>这里就来看看 Tomcat 的日志模块是如何实现的. 默认情况下, Tomcat 使用自身的 JULI 作为 Tomcat 内部的日志处理系统. JULI 的日志门面采用了 JCL; 而 JULI 的具体实现是构建在 Java 原生的日志系统 <code>java.util.logging</code>​ 之上的, 所以在看 JULI 的日志系统之前, 先简单介绍一下 Java 的日志系统.</p> <h5 id="java日志系统"><a href="#java日志系统" class="header-anchor">#</a> Java日志系统</h5> <p>Java 的日志包在 <code>java.util.logging</code>​ 路径下, 包含了几个比较重要的组件, 通过一张图来理解一下:</p> <p><img src="/img/image-20230405162108-gmhlkau.png" alt=""></p> <p>从图上看到这样几个重要的组件:</p> <ul><li>Logger: 用来记录日志的类.</li> <li>Handler: 规定了日志的输出方式, 如控制台输出, 写入文件.</li> <li>Level: 定义了日志的不同等级.</li> <li>Formatter: 将日志信息格式化, 比如纯文本, XML.</li></ul> <p>可以通过下面的代码来使用这些组件:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">Logger</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token string">&quot;com.mycompany.myapp&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    logger<span class="token punctuation">.</span><span class="token function">setLevel</span><span class="token punctuation">(</span><span class="token class-name">Level</span><span class="token punctuation">.</span><span class="token constant">FINE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    logger<span class="token punctuation">.</span><span class="token function">setUseParentHandlers</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Handler</span> hd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConsoleHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    hd<span class="token punctuation">.</span><span class="token function">setLevel</span><span class="token punctuation">(</span><span class="token class-name">Level</span><span class="token punctuation">.</span><span class="token constant">FINE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    logger<span class="token punctuation">.</span><span class="token function">addHandler</span><span class="token punctuation">(</span>hd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;start log&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h5 id="juli"><a href="#juli" class="header-anchor">#</a> JULI</h5> <p>JULI 对日志的处理方式与 Java 自带的基本一致, 但是 Tomcat 中可以包含多个应用, 而每个应用的日志系统应该相互独立. Java 的原生日志系统是每个 JVM 有一份日志的配置文件, 这不符合 Tomcat 多应用的场景, 所以 JULI 重新实现了一些日志接口.</p> <p><strong>DirectJDKLog</strong></p> <p>Log 的基础实现类是 DirectJDKLog, 这个类相对简单, 就包装了一下 Java 的 Logger 类. 但是它也在原来的基础上进行了一些修改, 比如修改默认的格式化方式.</p> <p><strong>LogFactory</strong></p> <p>Log 使用了工厂模式来向外提供实例, LogFactory 是一个单例, 可以通过 SeviceLoader 为 Log 提供自定义的实现版本, 如果没有配置, 就默认使用 DirectJDKLog.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">LogFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 通过 ServiceLoader 尝试加载 Log 的实现类</span>
    <span class="token class-name">ServiceLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Log</span><span class="token punctuation">&gt;</span></span> logLoader <span class="token operator">=</span> <span class="token class-name">ServiceLoader</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Log</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Log</span><span class="token punctuation">&gt;</span></span> m<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>
  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Log</span> log<span class="token operator">:</span> logLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Log</span><span class="token punctuation">&gt;</span></span> c<span class="token operator">=</span>log<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            m<span class="token operator">=</span>c<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> <span class="token operator">|</span> <span class="token class-name">SecurityException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  
    <span class="token comment">// 如何没有定义 Log 的实现类, discoveredLogConstructor 为 null</span>
    discoveredLogConstructor <span class="token operator">=</span> m<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>下面的代码是 LogFactory 的 getInstance() 方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Log</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">LogConfigurationException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果 discoveredLogConstructor 为 null, 也就没有定义 Log 类, 默认用 DirectJDKLog</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>discoveredLogConstructor <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">DirectJDKLog</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> discoveredLogConstructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ReflectiveOperationException</span> <span class="token operator">|</span> <span class="token class-name">IllegalArgumentException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">LogConfigurationException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>Handler</strong></p> <p>在 JULI 中就自定义了两个 Handler: FileHandler 和 AsyncFileHandler. FileHandler 可以简单地理解为一个在特定位置写文件的工具类, 有一些写操作常用的方法, 如 open, write(publish), close, flush 等, 使用了读写锁. 其中的日志信息通过 Formatter 来格式化.</p> <p>AsyncFileHandler 继承自 FileHandler, 实现了异步的写操作. 其中缓存存储是通过阻塞双端队列 LinkedBlockingDeque 来实现的. 当应用要通过这个 Handler 来记录一条消息时, 消息会先被存储到队列中, 而在后台会有一个专门的线程来处理队列中的消息, 取出的消息会通过父类的 publish 方法写入相应文件内. 这样就可以在大量日志需要写入的时候起到缓冲作用, 防止都阻塞在写日志这个动作上. 需要注意的是, 我们可以为阻塞双端队列设置不同的模式, 在不同模式下, 对新进入的消息有不同的处理方式, 有些模式下会直接丢弃一些日志:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>OVERFLOW_DROP_LAST: 丢弃栈顶的元素 
OVERFLOW_DROP_FIRSH: 丢弃栈底的元素 
OVERFLOW_DROP_FLUSH: 等待一定时间并重试, 不会丢失元素 
OVERFLOW_DROP_CURRENT: 丢弃放入的元素
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>Formatter</strong></p> <p>Formatter 通过一个 format 方法将日志记录 LogRecord 转化成格式化的字符串, JULI 提供了三个新的 Formatter.</p> <ul><li>OnlineFormatter: 基本与 Java 自带的 SimpleFormatter 格式相同, 不过把所有内容都写到了一行中.</li> <li>VerbatimFormatter: 只记录了日志信息, 没有任何额外的信息.</li> <li>JdkLoggerFormatter: 格式化了一个轻量级的日志信息.</li></ul> <p><strong>日志配置</strong></p> <p>Tomcat 的日志配置文件为 Tomcat 文件夹下<code>conf/logging.properties</code>​. 拆解一下这个配置文件, 首先可以看到各种 Handler 的配置:</p> <div class="language-properties line-numbers-mode"><pre class="language-properties"><code><span class="token key attr-name">handlers</span> <span class="token punctuation">=</span> <span class="token value attr-value">1catalina.org.apache.juli.AsyncFileHandler, 2localhost.org.apache.juli.AsyncFileHandler, 3manager.org.apache.juli.AsyncFileHandler, 4host-manager.org.apache.juli.AsyncFileHandler, java.util.logging.ConsoleHandler.handlers = 1catalina.org.apache.juli.AsyncFileHandler, java.util.logging.ConsoleHandler</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>以 <code>1catalina.org.apache.juli.AsyncFileHandler</code>​ 为例, 数字是为了区分同一个类的不同实例; catalina, localhost, manager 和 host-manager 是 Tomcat 用来区分不同系统日志的标志; 后面的字符串表示了 Handler 具体类型, 如果要添加 Tomcat 服务器的自定义 Handler, 需要在字符串里添加.</p> <p>接下来是每个 Handler 设置日志等级, 目录和文件前缀, 自定义的 Handler 也要在这里配置详细信息:</p> <div class="language-properties line-numbers-mode"><pre class="language-properties"><code><span class="token key attr-name">1catalina.org.apache.juli.AsyncFileHandler.level</span> <span class="token punctuation">=</span> <span class="token value attr-value">FINE</span>
<span class="token key attr-name">1catalina.org.apache.juli.AsyncFileHandler.directory</span> <span class="token punctuation">=</span> <span class="token value attr-value">${catalina.base}/logs</span>
<span class="token key attr-name">1catalina.org.apache.juli.AsyncFileHandler.prefix</span> <span class="token punctuation">=</span> <span class="token value attr-value">catalina.</span>
<span class="token key attr-name">1catalina.org.apache.juli.AsyncFileHandler.maxDays</span> <span class="token punctuation">=</span> <span class="token value attr-value">90</span>
<span class="token key attr-name">1catalina.org.apache.juli.AsyncFileHandler.encoding</span> <span class="token punctuation">=</span> <span class="token value attr-value">UTF-8</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h5 id="tomcat-slf4j-logback"><a href="#tomcat-slf4j-logback" class="header-anchor">#</a> Tomcat+SLF4J+Logback</h5> <p>前面提到, <strong>SLF4J 和 JCL 都是日志门面</strong>, 那它们有什么区别呢? 它们的区别主要体现在日志服务类的绑定机制上. JCL 采用运行时动态绑定的机制, 在运行时动态寻找和加载日志框架实现.</p> <p>SLF4J 日志输出服务绑定则相对简单很多, <strong>在编译时就静态绑定日志框架</strong>, 只需要提前引入需要的日志框架. 另外 Logback 可以说 Log4j 的进化版, 在性能和可用性方面都有所提升.</p> <p>基于此来实战一下如何将 Tomcat 默认的日志框架切换成为 &quot;SLF4J + Logback&quot;. 具体的步骤是:</p> <ol><li>根据 Tomcat 版本, 从<a href="https://github.com/tomcat-slf4j-logback/tomcat-slf4j-logback/releases" target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>下载所需要文件. 解压后你会看到一个类似于 Tomcat 目录结构的文件夹.</li> <li>替换或拷贝下列这些文件到 Tomcat 的安装目录:</li></ol> <p><img src="/img/image-20230405162108-xcx2xlr.jpg" alt=""></p> <ol start="3"><li>删除 <code>&lt;Tomcat&gt;/conf/logging.properties</code>​</li> <li>启动 Tomcat</li></ol> <h4 id="_32-manager组件-tomcat的session管理机制解析"><a href="#_32-manager组件-tomcat的session管理机制解析" class="header-anchor">#</a> 32.Manager组件:Tomcat的Session管理机制解析</h4> <p><strong>可以通过 Request 对象的 getSession() 方法来获取 Session, 并通过 Session 对象来读取和写入属性值</strong>. 而 Session 的管理是由 Web 容器来完成的, 主要是对 Session 的创建和销毁, 除此之外 Web 容器还需要将 Session 状态的变化通知给监听者.</p> <p>当然 Session 管理还可以交给 Spring 来做, 好处是与特定的 Web 容器解耦, <strong>Spring Session 的核心原理是通过 Filter 拦截 Servlet 请求, 将标准的 ServletRequest 包装一下, 换成 Spring 的 Request 对象, 这样当调用 Request 对象的 getSession() 方法时, Spring 会创建和管理 Session</strong>.</p> <p>那么 Tomcat 的 Session 管理机制还需要了解吗? 还是有必要, 因为只有了解这些原理, 才能更好的理解 Spring Session, 以及 Spring Session 为什么设计成这样. 这里就从 Session 的创建, Session 的清理以及 Session 的事件通知这几个方面来了解 Tomcat 的 Session 管理机制.</p> <h5 id="session的创建"><a href="#session的创建" class="header-anchor">#</a> Session的创建</h5> <p>Tomcat 中主要由每个 <strong>Context 容器内的一个 Manager 对象来管理 Session</strong>. 默认实现类为 StandardManager. 下面通过它的接口来了解一下 StandardManager 的功能:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Manager</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Context</span> <span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setContext</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">SessionIdGenerator</span> <span class="token function">getSessionIdGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSessionIdGenerator</span><span class="token punctuation">(</span><span class="token class-name">SessionIdGenerator</span> sessionIdGenerator<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getSessionCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSessionCounter</span><span class="token punctuation">(</span><span class="token keyword">long</span> sessionCounter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMaxActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMaxActive</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxActive<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getActiveSessions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getExpiredSessions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setExpiredSessions</span><span class="token punctuation">(</span><span class="token keyword">long</span> expiredSessions<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getRejectedSessions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSessionMaxAliveTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSessionMaxAliveTime</span><span class="token punctuation">(</span><span class="token keyword">int</span> sessionMaxAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSessionAverageAliveTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSessionCreateRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSessionExpireRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Session</span> session<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">changeSessionId</span><span class="token punctuation">(</span><span class="token class-name">Session</span> session<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">changeSessionId</span><span class="token punctuation">(</span><span class="token class-name">Session</span> session<span class="token punctuation">,</span> <span class="token class-name">String</span> newId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Session</span> <span class="token function">createEmptySession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Session</span> <span class="token function">createSession</span><span class="token punctuation">(</span><span class="token class-name">String</span> sessionId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Session</span> <span class="token function">findSession</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Session</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findSessions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Session</span> session<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Session</span> session<span class="token punctuation">,</span> <span class="token keyword">boolean</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addPropertyChangeListener</span><span class="token punctuation">(</span><span class="token class-name">PropertyChangeListener</span> listener<span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removePropertyChangeListener</span><span class="token punctuation">(</span><span class="token class-name">PropertyChangeListener</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unload</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">willAttributeDistribute</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>不出意外在接口中看到了添加和删除 Session 的方法; 另外还有 load() 和 unload() 方法, 它们的作用是分别是将 Session 持久化到存储介质和从存储介质加载 Session.</p> <p>当调用 <code>HttpServletRequest.getSession(true)</code>​时, 这个参数 true 的意思是&quot;如果当前请求还没有 Session, 就创建一个新的&quot;. 那 Tomcat 在背后做了些什么呢?</p> <p>HttpServletRequest 是一个接口, Tomcat 实现了这个接口, 具体实现类是: <code>org.apache.catalina.connector.Request</code>​.</p> <p>但这并不是我们拿到的 Request, Tomcat 为了避免把一些实现细节暴露出来, 还有基于安全上的考虑, <strong>定义了 Request 的包装类, 叫作 RequestFacade</strong>, 可以通过代码来理解一下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Request</span> <span class="token keyword">implements</span> <span class="token class-name">HttpServletRequest</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestFacade</span> <span class="token keyword">implements</span> <span class="token class-name">HttpServletRequest</span> <span class="token punctuation">{</span>
  <span class="token keyword">protected</span> <span class="token class-name">Request</span> request <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  
  <span class="token keyword">public</span> <span class="token class-name">HttpSession</span> <span class="token function">getSession</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> create<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span>create<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>因此我们拿到的 Request 类其实是 <strong>RequestFacade</strong>, RequestFacade 的 getSession() 方法调用的是 Request 类的 getSession() 方法, 继续来看 Session 具体是如何创建的:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Context</span> context <span class="token operator">=</span> <span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>context <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token class-name">Manager</span> manager <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>manager <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
 
session <span class="token operator">=</span> manager<span class="token punctuation">.</span><span class="token function">createSession</span><span class="token punctuation">(</span>sessionId<span class="token punctuation">)</span><span class="token punctuation">;</span>
session<span class="token punctuation">.</span><span class="token function">access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>从上面的代码可以看出, Request 对象中持有 Context 容器对象, 而 Context 容器持有 Session 管理器 Manager, 这样通过 Context 组件就能拿到 Manager 组件, 最后由 Manager 组件来创建 Session.</p> <p>因此最后还是到了 <strong>StandardManager</strong>, StandardManager 的父类叫 ManagerBase, 这个 createSession 方法定义在 ManagerBase 中, StandardManager 直接重用这个方法.</p> <p>接着来看 ManagerBase 的 createSession() 是如何实现的:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">Session</span> <span class="token function">createSession</span><span class="token punctuation">(</span><span class="token class-name">String</span> sessionId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 首先判断 Session 数量是不是到了最大值, 最大 Session 数可以通过参数设置</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>maxActiveSessions <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token function">getActiveSessions</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> maxActiveSessions<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        rejectedSessions<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TooManyActiveSessionsException</span><span class="token punctuation">(</span>
                sm<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">&quot;managerBase.createSession.ise&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                maxActiveSessions<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">// 重用或者创建一个新的 Session 对象, 请注意在 Tomcat 中就是 StandardSession</span>
    <span class="token comment">// 它是 HttpSession 的具体实现类, 而 HttpSession 是 Servlet 规范中定义的接口</span>
    <span class="token class-name">Session</span> session <span class="token operator">=</span> <span class="token function">createEmptySession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
 
    <span class="token comment">// 初始化新 Session 的值</span>
    session<span class="token punctuation">.</span><span class="token function">setNew</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    session<span class="token punctuation">.</span><span class="token function">setValid</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    session<span class="token punctuation">.</span><span class="token function">setCreationTime</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    session<span class="token punctuation">.</span><span class="token function">setMaxInactiveInterval</span><span class="token punctuation">(</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSessionTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> id <span class="token operator">=</span> sessionId<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        id <span class="token operator">=</span> <span class="token function">generateSessionId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    session<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 这里会将 Session 添加到 ConcurrentHashMap 中</span>
    sessionCounter<span class="token operator">++</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 将创建时间添加到 LinkedList 中, 并且把最先添加的时间移除</span>
    <span class="token comment">// 主要还是方便清理过期 Session</span>
    <span class="token class-name">SessionTiming</span> timing <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SessionTiming</span><span class="token punctuation">(</span>session<span class="token punctuation">.</span><span class="token function">getCreationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sessionCreationTiming<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sessionCreationTiming<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>timing<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sessionCreationTiming<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> session
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>到此明白了 Session 是如何创建出来的, 创建出来后 Session 会被保存到一个 <strong>ConcurrentHashMap</strong> 中:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Session</span><span class="token punctuation">&gt;</span></span> sessions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>请注意 Session 的具体实现类是 <strong>StandardSession</strong>, StandardSession 同时实现了 <code>javax.servlet.http.HttpSession</code>​和<code>org.apache.catalina.Session</code>​ 接口, 并且对程序员暴露的是 StandardSessionFacade 外观类, 保证了 StandardSession 的安全, 避免了程序员调用其内部方法进行不当操作. StandardSession 的核心成员变量如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StandardSession</span> <span class="token keyword">implements</span> <span class="token class-name">HttpSession</span><span class="token punctuation">,</span> <span class="token class-name">Session</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">protected</span> <span class="token class-name">ConcurrentMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> attributes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">long</span> creationTime <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> expiring <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">transient</span> <span class="token class-name">StandardSessionFacade</span> facade <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token class-name">String</span> id <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> lastAccessedTime <span class="token operator">=</span> creationTime<span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">transient</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SessionListener</span><span class="token punctuation">&gt;</span></span> listeners <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">transient</span> <span class="token class-name">Manager</span> manager <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> maxInactiveInterval <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> isNew <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> isValid <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">transient</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> notes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hashtable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">transient</span> <span class="token class-name">Principal</span> principal <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h5 id="session的清理"><a href="#session的清理" class="header-anchor">#</a> Session的清理</h5> <p>再来看看 Tomcat 是如何清理过期的 Session. 在 Tomcat 热加载与热部署部分讲到容器组件会开启一个 ContainerBackgroundProcessor 后台线程, 调用自己以及子容器的 backgroundProcess 进行一些后台逻辑的处理, 和 Lifecycle 一样, 这个动作也是具有传递性的, 也就是说子容器还会把这个动作传递给自己的子容器. 可以参考下图来理解这个过程.</p> <p><img src="/img/image-20230405162152-2ymjieo.jpg" alt=""></p> <p>其中父容器会遍历所有的子容器并调用其 backgroundProcess() 方法, 而 StandardContext 重写了该方法, 它会调用 StandardManager 的 backgroundProcess() 进而完成 Session 的清理工作, 下面是 StandardManager 的 backgroundProcess() 方法的代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backgroundProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// processExpiresFrequency 默认值为 6, 而 backgroundProcess 默认每隔 10s 调用一次, 也就是说除了任务执行的耗时, 每隔 60s 执行一次</span>
    count <span class="token operator">=</span> <span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> processExpiresFrequency<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 默认每隔 60s 执行一次 Session 清理</span>
        <span class="token function">processExpires</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token comment">/**
 * 单线程处理, 不存在线程安全问题
 */</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">processExpires</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
    <span class="token comment">// 获取所有的 Session</span>
    <span class="token class-name">Session</span> sessions<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">findSessions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token keyword">int</span> expireHere <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sessions<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Session 的过期是在 isValid() 方法里处理的</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sessions<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>sessions<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">isValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            expireHere<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p><strong>backgroundProcess() 由 Tomcat 后台线程调用</strong>, 默认是每隔 10 秒调用一次, 但是 Session 的清理动作不能太频繁, 因为需要遍历 Session 列表, 会耗费 CPU 资源, 所以在 backgroundProcess() 方法中做了取模处理, backgroundProcess() 调用 6 次, 才执行一次 Session 清理, 也就是说 Session 清理<strong>每 60 秒执行一次</strong>.</p> <h5 id="session事件通知"><a href="#session事件通知" class="header-anchor">#</a> Session事件通知</h5> <p>按照 Servlet 规范, 在 Session 的生命周期过程中, <strong>要将事件通知监听者</strong>, Servlet 规范定义了 Session 的监听器接口:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">HttpSessionListener</span> <span class="token keyword">extends</span> <span class="token class-name">EventListener</span> <span class="token punctuation">{</span>
    <span class="token comment">// Session 创建时调用</span>
    <span class="token keyword">public</span> <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">sessionCreated</span><span class="token punctuation">(</span><span class="token class-name">HttpSessionEvent</span> se<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
  
    <span class="token comment">// Session 销毁时调用</span>
    <span class="token keyword">public</span> <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">sessionDestroyed</span><span class="token punctuation">(</span><span class="token class-name">HttpSessionEvent</span> se<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>注意到这两个方法的参数都是 HttpSessionEvent, 所以 Tomcat 需要先创建 HttpSessionEvent 对象, 然后遍历 Context 内部的 LifecycleListener, 并且判断是否为 HttpSessionListener 实例, 如果是的话则调用 HttpSessionListener 的 sessionCreated() 方法进行事件通知. 这些事情都是在 Session 的 setId() 方法中完成的:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>session<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">,</span> <span class="token keyword">boolean</span> notify<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果这个 id 已经存在, 先从 Manager 中删除</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>manager <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        manager<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
 
    <span class="token comment">// 添加新的 Session</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>manager <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        manager<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment">// 这里面完成了 HttpSessionListener 事件通知</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>notify<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">tellNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>从代码看到 setId() 方法调用了 tellNew() 方法, 那 tellNew() 又是如何实现的呢?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tellNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
    <span class="token comment">// 通知 org.apache.catalina.SessionListener</span>
    <span class="token function">fireSessionEvent</span><span class="token punctuation">(</span><span class="token class-name">Session</span><span class="token punctuation">.</span><span class="token constant">SESSION_CREATED_EVENT</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment">// 获取 Context 内部的 LifecycleListener 并判断是否为 HttpSessionListener</span>
    <span class="token class-name">Context</span> context <span class="token operator">=</span> manager<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Object</span> listeners<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getApplicationLifecycleListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>listeners <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> listeners<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  
        <span class="token comment">// 创建 HttpSessionEvent</span>
        <span class="token class-name">HttpSessionEvent</span> event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpSessionEvent</span><span class="token punctuation">(</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> listeners<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 判断是否是 HttpSessionListener</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>listeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">HttpSessionListener</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
          
            <span class="token class-name">HttpSessionListener</span> listener <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HttpSessionListener</span><span class="token punctuation">)</span> listeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment">// 注意这是容器内部事件</span>
            context<span class="token punctuation">.</span><span class="token function">fireContainerEvent</span><span class="token punctuation">(</span><span class="token string">&quot;beforeSessionCreated&quot;</span><span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>   
            <span class="token comment">// 触发 Session Created 事件</span>
            listener<span class="token punctuation">.</span><span class="token function">sessionCreated</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
      
            <span class="token comment">// 注意这也是容器内部事件</span>
            context<span class="token punctuation">.</span><span class="token function">fireContainerEvent</span><span class="token punctuation">(</span><span class="token string">&quot;afterSessionCreated&quot;</span><span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
      
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>上面代码的逻辑是, 先通过 StandardContext 将 HttpSessionListener 类型的 Listener 取出, 然后依次调用它们的 sessionCreated() 方法.</p> <h5 id="总结-15"><a href="#总结-15" class="header-anchor">#</a> 总结</h5> <p>这里从 Request 谈到了 Session 的创建, 销毁和事件通知, 里面涉及不少相关的类, 下图是这些类的关系:</p> <p><img src="/img/image-20230405162152-33c5ovy.jpg" alt=""></p> <p>Servlet 规范中定义了 HttpServletRequest 和 HttpSession 接口, Tomcat 实现了这些接口, 但具体实现细节并没有暴露给开发者, 因此定义了<strong>两个包装类, RequestFacade 和 StandardSessionFacade</strong>.</p> <p>Tomcat 是通过 Manager 来管理 Session 的, 默认实现是 StandardManager. StandardContext 持有 StandardManager 的实例, 并存放了 HttpSessionListener 集合, Session 在创建和销毁时, 会通知监听器.</p> <h4 id="_33-cluster组件-tomcat的集群通信原理"><a href="#_33-cluster组件-tomcat的集群通信原理" class="header-anchor">#</a> 33.Cluster组件:Tomcat的集群通信原理</h4> <p>为了支持水平扩展和高可用, Tomcat 提供了集群部署的能力, 但与此同时也带来了<strong>分布式系统的一个通用问题</strong>, 那就是如何在集群中的<strong>多个节点之间保持数据的一致性</strong>, 比如会话(Session)信息.</p> <p>要实现这一点, 基本上有两种方式, 一种是把所有 Session 数据放到一台服务器或者一个数据库中, 集群中的所有节点通过访问这台 Session 服务器来获取数据. 另一种方式就是在集群中的节点间进行 Session 数据的同步拷贝, 这里又分为两种策略: 第一种是将一个节点的 Session 拷贝到集群中其他所有节点; 第二种是只将一个节点上的 Session 数据拷贝到另一个备份节点.</p> <p><strong>对于 Tomcat 的 Session 管理来说, 这两种方式都支持</strong>. 这里就来看看第二种方式的实现原理, 也就是 <strong>Tomcat 集群通信</strong>的原理和配置方法, 最后通过官网上的一个例子来了解下 Tomcat 集群到底是如何工作的.</p> <h5 id="集群通信原理"><a href="#集群通信原理" class="header-anchor">#</a> 集群通信原理</h5> <p>要实现集群通信, 首先要知道集群中都有哪些成员. Tomcat 是通过<strong>组播</strong>(Multicast)来实现的. 那什么是组播呢? 为了理解组播, 先来说说什么是&quot;单播&quot;. 网络节点之间的通信就好像是人们之间的对话一样, 一个人对另外一个人说话, 此时信息的接收和传递只在两个节点之间进行, 比如你在收发电子邮件, 浏览网页时, 使用的就是单播, 也就是 &quot;点对点通信&quot;.</p> <p>如果一台主机需要将同一个消息发送多个主机逐个传输, 效率就会比较低, 于是就出现组播技术. 组播是<strong>一台主机向指定的一组主机发送数据报包</strong>, 组播通信的过程是这样的: 每一个 Tomcat 节点在启动时和运行时都会周期性(默认 500 毫秒)发送组播心跳包, 同一个集群内的节点都在相同的<strong>组播地址</strong>和<strong>端口</strong>监听这些信息; 在一定的时间内(默认 3 秒)不发送<strong>组播报文</strong>的节点就会被认为已经崩溃了, 会从集群中删去. 因此通过组播, 集群中每个成员都能维护一个集群成员列表.</p> <h5 id="集群通信配置"><a href="#集群通信配置" class="header-anchor">#</a> 集群通信配置</h5> <p>有了集群成员的列表, 集群中的节点就能通过 <strong>TCP</strong> 连接向其他节点传输 Session 数据. Tomcat 通过 SimpleTcpCluster 类来进行<strong>会话复制</strong>(In-Memory Replication). 要开启集群功能, 只需要将 <code>server.xml</code>​ 里的这一行的注释去掉就行:</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token comment">&lt;!-- 
&lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot;/&gt;
--&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>变成这样:</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Cluster</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.ha.tcp.SimpleTcpCluster<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>虽然只是简单的一行配置, 但这一行配置等同于下面这样的配置, 也就是说 Tomcat 给我们设置了很多默认参数, 这些参数都跟集群通信有关.</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token comment">&lt;!-- 
  SimpleTcpCluster 是用来复制 Session 的组件. 复制 Session 有同步和异步两种方式: 
  同步模式下, 向浏览器的发送响应数据前, 需要先将 Session 拷贝到其他节点完; 
  异步模式下, 无需等待 Session 拷贝完成就可响应. 异步模式更高效, 但是同步模式
  可靠性更高. 
  同步异步模式由 channelSendOptions 参数控制, 默认值是 8, 为异步模式; 4 是同步模式. 
  在异步模式下, 可以通过加上 &quot; 拷贝确认 &quot;(Acknowledge)来提高可靠性, 此时
  channelSendOptions 设为 10
--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Cluster</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.ha.tcp.SimpleTcpCluster<span class="token punctuation">&quot;</span></span>
                 <span class="token attr-name">channelSendOptions</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
   <span class="token comment">&lt;!--
    Manager 决定如何管理集群的 Session 信息. 
    Tomcat 提供了两种 Manager: BackupManager 和 DeltaManager. 
    BackupManager－集群下的某一节点的 Session, 将复制到一个备份节点. 
    DeltaManager－ 集群下某一节点的 Session, 将复制到所有其他节点. 
    DeltaManager 是 Tomcat 默认的集群 Manager. 
  
    expireSessionsOnShutdown－设置为 true 时, 一个节点关闭时, 
    将导致集群下的所有 Session 失效
    notifyListenersOnReplication－集群下节点间的 Session 复制, 
    删除操作, 是否通知 session listeners
  
    maxInactiveInterval－集群下 Session 的有效时间 (单位:s). 
    maxInactiveInterval 内未活动的 Session, 将被 Tomcat 回收. 
    默认值为 1800(30min)
  --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Manager</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.ha.session.DeltaManager<span class="token punctuation">&quot;</span></span>
                   <span class="token attr-name">expireSessionsOnShutdown</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>false<span class="token punctuation">&quot;</span></span>
                   <span class="token attr-name">notifyListenersOnReplication</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>true<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
 
   <span class="token comment">&lt;!--
    Channel 是 Tomcat 节点之间进行通讯的工具. 
    Channel 包括 5 个组件: Membership, Receiver, Sender, 
    Transport, Interceptor
   --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Channel</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.tribes.group.GroupChannel<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
     <span class="token comment">&lt;!--
      Membership 维护集群的可用节点列表. 它可以检查到新增的节点, 
      也可以检查没有心跳的节点
      className－指定 Membership 使用的类
      address－组播地址
      port－组播端口
      frequency－发送心跳 (向组播地址发送 UDP 数据包) 的时间间隔 (单位:ms). 
      dropTime－Membership 在 dropTime(单位:ms) 内未收到某一节点的心跳, 
      则将该节点从可用节点列表删除. 默认值为 3000. 
     --&gt;</span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Membership</span>  <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.tribes.membership.
         McastService<span class="token punctuation">&quot;</span></span>
         <span class="token attr-name">address</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>228.0.0.4<span class="token punctuation">&quot;</span></span>
         <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>45564<span class="token punctuation">&quot;</span></span>
         <span class="token attr-name">frequency</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>500<span class="token punctuation">&quot;</span></span>
         <span class="token attr-name">dropTime</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>3000<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
   
     <span class="token comment">&lt;!--
       Receiver 用于各个节点接收其他节点发送的数据. 
       接收器分为两种: BioReceiver(阻塞式), NioReceiver(非阻塞式)
 
       className－指定 Receiver 使用的类
       address－接收消息的地址
       port－接收消息的端口
       autoBind－端口的变化区间, 如果 port 为 4000, autoBind 为 100, 
                 接收器将在 4000-4099 间取一个端口进行监听. 
       selectorTimeout－NioReceiver 内 Selector 轮询的超时时间
       maxThreads－线程池的最大线程数
     --&gt;</span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Receiver</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.tribes.transport.nio.
         NioReceiver<span class="token punctuation">&quot;</span></span>
         <span class="token attr-name">address</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>auto<span class="token punctuation">&quot;</span></span>
         <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>4000<span class="token punctuation">&quot;</span></span>
         <span class="token attr-name">autoBind</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>100<span class="token punctuation">&quot;</span></span>
         <span class="token attr-name">selectorTimeout</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>5000<span class="token punctuation">&quot;</span></span>
         <span class="token attr-name">maxThreads</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>6<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
 
      <span class="token comment">&lt;!--
         Sender 用于向其他节点发送数据, Sender 内嵌了 Transport 组件, 
         Transport 真正负责发送消息. 
      --&gt;</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Sender</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.tribes.transport.
          ReplicationTransmitter<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
          <span class="token comment">&lt;!--
            Transport 分为两种: bio.PooledMultiSender(阻塞式)
            和 nio.PooledParallelSender(非阻塞式), PooledParallelSender
            是从 tcp 连接池中获取连接, 可以实现并行发送, 即集群中的节点可以
            同时向其他所有节点发送数据而互不影响. 
           --&gt;</span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Transport</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.tribes.
          transport.nio.PooledParallelSender<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>   
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Sender</span><span class="token punctuation">&gt;</span></span>
   
       <span class="token comment">&lt;!--
         Interceptor : Cluster 的拦截器
         TcpFailureDetector－TcpFailureDetector 可以拦截到某个节点关闭
         的信息, 并尝试通过 TCP 连接到此节点, 以确保此节点真正关闭, 从而更新集
         群可用节点列表           
        --&gt;</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Interceptor</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.tribes.group.
       interceptors.TcpFailureDetector<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
   
       <span class="token comment">&lt;!--
         MessageDispatchInterceptor－查看 Cluster 组件发送消息的
         方式是否设置为 Channel.SEND_OPTIONS_ASYNCHRONOUS, 如果是, 
         MessageDispatchInterceptor 先将等待发送的消息进行排队, 
         然后将排好队的消息转给 Sender. 
        --&gt;</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Interceptor</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.tribes.group.
       interceptors.MessageDispatchInterceptor<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Channel</span><span class="token punctuation">&gt;</span></span>
 
  <span class="token comment">&lt;!--
    Valve : Tomcat 的拦截器, 
    ReplicationValve－在处理请求前后打日志; 过滤不涉及 Session 变化的请求.            
    --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Valve</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.ha.tcp.ReplicationValve<span class="token punctuation">&quot;</span></span>
    <span class="token attr-name">filter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Valve</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.ha.session.
  JvmRouteBinderValve<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
 
  <span class="token comment">&lt;!--
    Deployer 用于集群的 farm 功能, 监控应用中文件的更新, 以保证集群中所有节点
    应用的一致性, 如某个用户上传文件到集群中某个节点的应用程序目录下, Deployer
    会监测到这一操作并把文件拷贝到集群中其他节点相同应用的对应目录下以保持
    所有应用的一致, 这是一个相当强大的功能. 
  --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Deployer</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.ha.deploy.FarmWarDeployer<span class="token punctuation">&quot;</span></span>
     <span class="token attr-name">tempDir</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/tmp/war-temp/<span class="token punctuation">&quot;</span></span>
     <span class="token attr-name">deployDir</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/tmp/war-deploy/<span class="token punctuation">&quot;</span></span>
     <span class="token attr-name">watchDir</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/tmp/war-listen/<span class="token punctuation">&quot;</span></span>
     <span class="token attr-name">watchEnabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>false<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
 
  <span class="token comment">&lt;!--
    ClusterListener : 监听器, 监听 Cluster 组件接收的消息
    使用 DeltaManager 时, Cluster 接收的信息通过 ClusterSessionListener
    传递给 DeltaManager, 从而更新自己的 Session 列表. 
    --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ClusterListener</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.ha.session.
  ClusterSessionListener<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Cluster</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br></div></div><p>从上面的的参数列表可以看到, 默认情况下 Session 管理组件 DeltaManager 会在节点之间<strong>拷贝 Session</strong>, DeltaManager 采用的一种 <strong>all-to-all</strong> 的工作方式, <strong>即集群中的节点会把 Session 数据向所有其他节点拷贝</strong>, 而不管其他节点是否部署了当前应用. 当集群节点数比较少时, 比如少于 4 个, 这种 all-to-all 的方式是不错的选择; 但是当集群中的节点数量比较多时, 数据拷贝的开销成指数级增长, 这种情况下可以考虑 BackupManager, BackupManager 只向一个备份节点拷贝数据.</p> <p>在大体了解了 Tomcat 集群实现模型后, 就可以对集群作出更优化的配置了. Tomcat 推荐了一套配置, 使用了比 DeltaManager 更高效的 BackupManager, 并且通过 ReplicationValve 设置了请求过滤.</p> <p>这里还请注意在一台服务器部署多个节点时需要修改 Receiver 的侦听端口, 另外为了在节点间高效地拷贝数据, 所有 Tomcat 节点最好采用相同的配置, 具体配置如下:</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Cluster</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.ha.tcp.SimpleTcpCluster<span class="token punctuation">&quot;</span></span>
                 <span class="token attr-name">channelSendOptions</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>6<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Manager</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.ha.session.BackupManager<span class="token punctuation">&quot;</span></span>
                   <span class="token attr-name">expireSessionsOnShutdown</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>false<span class="token punctuation">&quot;</span></span>
                   <span class="token attr-name">notifyListenersOnReplication</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>true<span class="token punctuation">&quot;</span></span>
                   <span class="token attr-name">mapSendOptions</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>6<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
   
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Channel</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.tribes.group.
     GroupChannel<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
   
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Membership</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.tribes.membership.
     McastService<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name">address</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>228.0.0.4<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>45564<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name">frequency</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>500<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name">dropTime</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>3000<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
   
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Receiver</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.tribes.transport.nio.
     NioReceiver<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name">address</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>auto<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>5000<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name">selectorTimeout</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>100<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name">maxThreads</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>6<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
 
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Sender</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.tribes.transport.
     ReplicationTransmitter<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Transport</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.tribes.transport.
          nio.PooledParallelSender<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Sender</span><span class="token punctuation">&gt;</span></span>
   
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Interceptor</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.tribes.group.
     interceptors.TcpFailureDetector<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
   
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Interceptor</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.tribes.group.
     interceptors.MessageDispatchInterceptor<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
   
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Interceptor</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.tribes.group.
     interceptors.ThroughputInterceptor<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Channel</span><span class="token punctuation">&gt;</span></span>
 
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Valve</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.ha.tcp.ReplicationValve<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name">filter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>.*\.gif|.*\.js|.*\.jpeg|.*\.jpg|.*\.png|.*\
               .htm|.*\.html|.*\.css|.*\.txt<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
 
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Deployer</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.ha.deploy.FarmWarDeployer<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name">tempDir</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/tmp/war-temp/<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name">deployDir</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/tmp/war-deploy/<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name">watchDir</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/tmp/war-listen/<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name">watchEnabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>false<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ClusterListener</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.apache.catalina.ha.session.
    ClusterSessionListener<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Cluster</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br></div></div><h5 id="集群工作过程"><a href="#集群工作过程" class="header-anchor">#</a> 集群工作过程</h5> <p>Tomcat 的官网给出了一个例子, 来说明 Tomcat 集群模式下是如何工作的, 以及 Tomcat 集群是如何实现高可用的. 比如集群由 Tomcat A 和 Tomcat B 两个 Tomcat 实例组成, 按照时间先后顺序发生了如下事件:</p> <p><strong>1. Tomcat A 启动</strong></p> <p>Tomcat A 启动过程中, 当 Host 对象被创建时, 一个 Cluster 组件(默认是 SimpleTcpCluster)被关联到这个 Host 对象. 当某个应用在 <code>web.xml</code>​ 中设置了 Distributable 时, Tomcat 将为此应用的上下文环境创建一个 DeltaManager. SimpleTcpCluster 启动 Membership 服务和 Replication 服务.</p> <p><strong>2. Tomcat B 启动(在 Tomcat A 之后启动)</strong></p> <p>首先 Tomcat B 会执行和 Tomcat A 一样的操作, 然后 SimpleTcpCluster 会建立一个由 Tomcat A 和 Tomcat B 组成的 Membership. 接着 Tomcat B 向集群中的 Tomcat A 请求 Session 数据, 如果 Tomcat A 没有响应 Tomcat B 的拷贝请求, Tomcat B 会在 60 秒后 time out. 在 Session 数据拷贝完成之前 Tomcat B 不会接收浏览器的请求.</p> <p><strong>3. Tomcat A 接收 HTTP 请求, 创建 Session 1</strong></p> <p>Tomcat A 响应客户请求, 在把结果发送回客户端之前, ReplicationValve 会拦截当前请求(如果 Filter 中配置了不需拦截的请求类型, 这一步就不会进行, 默认配置下拦截所有请求), 如果发现当前请求更新了 Session, 就调用 Replication 服务建立 TCP 连接将 Session 拷贝到 Membership 列表中的其他节点即 Tomcat B. 在拷贝时, 所有保存在当前 Session 中的可序列化的对象都会被拷贝, 而不仅仅是发生更新的部分.</p> <p><strong>4. Tomcat A 崩溃</strong></p> <p>当 Tomcat A 崩溃时, Tomcat B 会被告知 Tomcat A 已从集群中退出, 然后 Tomcat B 就会把 Tomcat A 从自己的 Membership 列表中删除. 并且 Tomcat B 的 Session 更新时不再往 Tomcat A 拷贝, 同时负载均衡器会把后续的 HTTP 请求全部转发给 Tomcat B. 在此过程中所有的 Session 数据不会丢失.</p> <p><strong>5. Tomcat B 接收 Tomcat A 的请求</strong></p> <p>Tomcat B 正常响应本应该发往 Tomcat A 的请求, 因为 Tomcat B 保存了 Tomcat A 的所有 Session 数据.</p> <p><strong>6. Tomcat A 重新启动</strong></p> <p>Tomcat A 按步骤 1, 2 操作启动, 加入集群, 并从 Tomcat B 拷贝所有 Session 数据, 拷贝完成后开始接收请求.</p> <p><strong>7. Tomcat A 接收请求, Session 1 被用户注销</strong></p> <p>Tomcat 继续接收发往 Tomcat A 的请求, Session 1 设置为失效. 请注意这里的失效并非因为 Tomcat A 处于非活动状态超过设置的时间, 而是应用程序执行了注销的操作(比如用户登出)而引起的 Session 失效. 这时 Tomcat A 向 Tomcat B 发送一个 Session 1 Expired 的消息, Tomcat B 收到消息后也会把 Session 1 设置为失效.</p> <p><strong>8. Tomcat B 接收到一个新请求, 创建 Session 2</strong></p> <p>同理这个新的 Session 也会被拷贝到 Tomcat A.</p> <p><strong>9. Tomcat A 上的 Session 2 过期</strong></p> <p>因超时原因引起的 Session 失效 Tomcat A 无需通知 Tomcat B, Tomcat B 同样知道 Session 2 已经超时. 因此对于 Tomcat 集群有一点非常重要, <strong>所有节点的操作系统时间必须一致</strong>. 不然会出现某个节点 Session 已过期而在另一节点此 Session 仍处于活动状态的现象.</p> <h5 id="总结-16"><a href="#总结-16" class="header-anchor">#</a> 总结</h5> <p>这里分析了 Tomcat 的集群工作原理和配置方式, 还通过官网上的一个例子说明了 Tomcat 集群的工作过程. Tomcat 集群对 Session 的拷贝支持两种方式: DeltaManager 和 BackupManager.</p> <p>当集群中节点比较少时, 可以采用 DeltaManager, 因为 Session 数据在集群中各个节点都有备份, 任何一个节点崩溃都不会对整体造成影响, 可靠性比较高.</p> <p>当集群中节点数比较多时, 可以采用 BackupManager, 这是因为一个节点的 Session 只会拷贝到另一个节点, 数据拷贝的开销比较少, 同时只要这两个节点不同时崩溃, Session 数据就不会丢失.</p> <h3 id="性能优化"><a href="#性能优化" class="header-anchor">#</a> 性能优化</h3> <h4 id="_34-jvm-gc原理及调优的基本思路"><a href="#_34-jvm-gc原理及调优的基本思路" class="header-anchor">#</a> 34.JVM GC原理及调优的基本思路</h4> <p>和 Web 应用程序一样, Tomcat 作为一个 Java 程序也跑在 JVM 中, 因此如果要对 Tomcat 进行调优, 需要先了解 JVM 调优的原理. 而对于 JVM 调优来说, 主要是 JVM 垃圾收集的优化, 一般来说是因为有问题才需要优化, 所以对于 JVM GC 来说, 如果观察到 Tomcat 进程的 CPU 使用率比较高, 并且在 GC 日志中发现 GC 次数比较频繁, GC 停顿时间长, 这表明需要对 GC 进行优化了.</p> <p>在对 GC 调优的过程中, 不仅需要知道 GC 的原理, 更重要的是要熟练使用各种监控和分析工具, 具备 GC 调优的实战能力. CMS 和 G1 是时下使用率比较高的两款垃圾收集器, 从 Java 9 开始, 采用 G1 作为默认垃圾收集器, 而 G1 的目标也是逐步取代 CMS.</p> <h5 id="cms-vs-g1"><a href="#cms-vs-g1" class="header-anchor">#</a> CMS vs G1</h5> <p>CMS 收集器将 Java 堆分为<strong>年轻代</strong>(Young)或<strong>年老代</strong>(Old). 这主要是因为有研究表明, 超过 90％ 的对象在第一次 GC 时就被回收掉, 但是少数对象往往会存活较长的时间.</p> <p>CMS 还将年轻代内存空间分为<strong>幸存者空间</strong>(Survivor)和<strong>伊甸园空间</strong>(Eden). 新的对象始终在 Eden 空间上创建. 一旦一个对象在一次垃圾收集后还幸存, 就会被移动到幸存者空间. 当一个对象在多次垃圾收集之后还存活时, 它会移动到年老代. 这样做的目的是在年轻代和年老代采用不同的收集算法, 以达到较高的收集效率, 比如在年轻代采用<strong>复制-整理算法</strong>, 在年老代采用<strong>标记-清理算法</strong>. 因此 CMS 将 Java 堆分成如下区域:</p> <p><img src="/img/image-20230405162238-fon1zjr.png" alt=""></p> <p>与 CMS 相比, G1 收集器有两大特点:</p> <ul><li>G1 可以并发完成大部分 GC 的工作, 这期间不会&quot;Stop-The-World&quot;.</li> <li>G1 使用<strong>非连续空间</strong>, 这使 G1 能够有效地处理非常大的堆. 此外, G1 可以同时收集年轻代和年老代. G1 并没有将 Java 堆分成三个空间(Eden, Survivor 和 Old), 而是将堆分成许多(通常是几百个)非常小的区域. 这些区域是固定大小的(默认情况下大约为 2MB). 每个区域都分配给一个空间.  G1 收集器的 Java 堆如下图所示:</li></ul> <p><img src="/img/image-20230405162238-efnv7sg.png" alt=""></p> <p>图上的 U 表示 &quot;未分配&quot; 区域. G1 将堆拆分成小的区域, 一个最大的好处是可以做局部区域的垃圾回收, 而不需要每次都回收整个区域比如年轻代和年老代, 这样回收的停顿时间会比较短. 具体的收集过程是:</p> <ul><li>将所有存活的对象将从<strong>收集的区域</strong>复制到<strong>未分配的区域</strong>, 比如收集的区域是 Eden 空间, 把 Eden 中的存活对象复制到未分配区域, 这个未分配区域就成了 Survivor 空间. 理想情况下, 如果一个区域全是垃圾(意味着一个存活的对象都没有), 则可以直接将该区域声明为 &quot;未分配&quot;.</li> <li>为了优化收集时间, G1 总是优先选择垃圾最多的区域, 从而最大限度地减少后续分配和释放堆空间所需的工作量. 这也是 G1 收集器名字的由来---Garbage-First.</li></ul> <h5 id="gc调优原则"><a href="#gc调优原则" class="header-anchor">#</a> GC调优原则</h5> <p>GC 是有代价的, 因此调优的根本原则是<strong>每一次 GC 都回收尽可能多的对象</strong>, 也就是减少无用功. 因此在做具体调优的时候, 针对 CMS 和 G1 两种垃圾收集器, 分别有一些相应的策略.</p> <p><strong>CMS收集器</strong></p> <p>对于 CMS 收集器来说, 最重要的是<strong>合理地设置年轻代和年老代的大小</strong>. 年轻代太小的话, 会导致频繁的 Minor GC, 并且很有可能存活期短的对象也不能被回收, GC 的效率就不高. 而年老代太小的话, 容纳不下从年轻代过来的新对象, 会频繁触发单线程 Full GC, 导致较长时间的 GC 暂停, 影响 Web 应用的响应时间.</p> <p><strong>G1收集器</strong></p> <p>对于 G1 收集器来说, 不推荐直接设置年轻代的大小, 这一点跟 CMS 收集器不一样, 这是因为 G1 收集器会根据算法动态决定年轻代和年老代的大小. 因此对于 G1 收集器, 需要关心的是 <strong>Java 堆的总大小</strong>(<code>-Xmx</code>​).</p> <p>此外 G1 还有一个较关键的参数是 <code>-XX:MaxGCPauseMillis = n</code>​, 这个参数是用来限制最大的 GC 暂停时间, 目的是尽量不影响请求处理的响应时间. G1 将根据先前收集的信息以及检测到的垃圾量, 估计它可以立即收集的最大区域数量, 从而尽量保证 GC 时间不会超出这个限制. 因此 G1 相对来说更加智能, 使用起来更加简单.</p> <h5 id="内存调优实战"><a href="#内存调优实战" class="header-anchor">#</a> 内存调优实战</h5> <p>下面通过一个例子实战一下 Java 堆设置得过小, 导致频繁的 GC, 下面通过 GC 日志分析工具来观察 GC 活动并定位问题.</p> <ol><li>首先建立一个 Spring Boot 程序, 作为调优对象, 代码如下:</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GcTestController</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">private</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Greeting</span><span class="token punctuation">&gt;</span></span> objCache <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">ConcurrentLinkedDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/greeting&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">Greeting</span> <span class="token function">greeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Greeting</span> greeting <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Greeting</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>objCache<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">200000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            objCache<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            objCache<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> greeting<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token annotation punctuation">@Data</span>
<span class="token annotation punctuation">@AllArgsConstructor</span>
<span class="token keyword">class</span> <span class="token class-name">Greeting</span> <span class="token punctuation">{</span>
   <span class="token keyword">private</span> <span class="token class-name">String</span> message<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>上面的代码就是创建了一个对象池, 当对象池中的对象数到达 200000 时才清空一次, 用来模拟年老代对象.</p> <ol start="2"><li>用下面的命令启动测试程序:</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>java -Xmx32m -Xss256k -verbosegc -Xlog:gc*,gc+ref=debug,gc+heap=debug,gc+age=trace:file=gc-%p-%t.log:tags,uptime,time,level:filecount=2,filesize=100m -jar target/demo-0.0.1-SNAPSHOT.jar
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>给程序设置的堆的大小为 32MB, 目的是能看到 Full GC. 除此之外, 还打开了 verbosegc 日志, 注意这里使用的版本是 Java 12, 默认的垃圾收集器是 G1.</p> <ol start="3"><li>使用 JMeter 压测工具向程序发送测试请求, 访问的路径是 <code>/greeting</code>​.</li></ol> <p><img src="/img/image-20230405162238-68cyxrn.png" alt=""></p> <ol start="4"><li>使用 GCViewer 工具打开 GC 日志, 可以看到这样的图:</li></ol> <p><img src="/img/image-20230405162238-xb85yys.png" alt=""></p> <p>解释一下这张图:</p> <ul><li>图中上部的蓝线表示已使用堆的大小, 可以看到它周期的上下震荡, 这是对象池要扩展到 200000 才会清空.</li> <li>图底部的绿线表示年轻代 GC 活动, 从图上看到当堆的使用率上去了, 会触发频繁的 GC 活动.</li> <li>图中的竖线表示 Full GC, 从图上看到, 伴随着 Full GC, 蓝线会下降, 这说明 Full GC 收集了年老代中的对象.</li></ul> <p>基于上面的分析, 可以得出一个结论, 那就是 Java 堆的大小不够. 解释一下为什么得出这个结论:</p> <ul><li>GC 活动频繁: 年轻代 GC(绿色线)和年老代 GC(黑色线)都比较密集. 这说明内存空间不够, 也就是 Java 堆的大小不够.</li> <li>Java 的堆中对象在 GC 之后能够被回收, 说明不是内存泄漏.</li></ul> <p>通过 GCViewer 还发现累计 GC 暂停时间有 55.57 秒, 如下图所示:</p> <p><img src="/img/image-20230405162238-r5luoqv.png" alt=""></p> <p>因此的解决方案是调大 Java 堆的大小, 像下面这样:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>java -Xmx2048m -Xss256k -verbosegc -Xlog:gc*,gc+ref=debug,gc+heap=debug,gc+age=trace:file=gc-%p-%t.log:tags,uptime,time,level:filecount=2,filesize=100m -jar target/demo-0.0.1-SNAPSHOT.jar
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>生成的新的 GC log 分析图如下:</p> <p><img src="/img/image-20230405162238-cum3ngs.png" alt=""></p> <p>可以看到, 没有发生 Full GC, 并且年轻代 GC 也没有那么频繁了, 并且累计 GC 暂停时间只有 3.05 秒.</p> <p><img src="/img/image-20230405162238-onegv55.png" alt=""></p> <h4 id="_35-如何监控tomcat的性能"><a href="#_35-如何监控tomcat的性能" class="header-anchor">#</a> 35.如何监控Tomcat的性能?</h4> <p>本节来聊如何监控 Tomcat 的各种指标, 因为只有掌握了这些指标和信息, 才能对 Tomcat 内部发生的事情一目了然, 明白系统的瓶颈在哪里, 进而做出调优的决策.</p> <p>首先来看看到底都需要监控 Tomcat 哪些关键指标, 接着来具体学习如何通过 JConsole 来监控它们. 如果系统没有暴露 JMX 接口, 还可以通过命令行来查看 Tomcat 的性能指标.</p> <p>Web 应用的响应时间是关注的一个重点, 最后通过一个实战案例, 来看看 Web 应用的下游服务响应时间比较长的情况下, Tomcat 的各项指标是什么样子的.</p> <h5 id="tomcat的关键指标"><a href="#tomcat的关键指标" class="header-anchor">#</a> Tomcat的关键指标</h5> <p>Tomcat 的关键指标有<strong>吞吐量, 响应时间, 错误数, 线程池, CPU 以及 JVM 内存</strong>.</p> <p>其中前三个指标是最关心的<strong>业务指标</strong>, Tomcat 作为服务器, 就是要能够又快有好地处理请求, 因此吞吐量要大, 响应时间要短, 并且错误数要少.</p> <p>而后面三个指标是跟<strong>系统资源</strong>有关的, 当某个资源出现瓶颈就会影响前面的业务指标, 比如线程池中的线程数量不足会影响吞吐量和响应时间; 但是线程数太多会耗费大量 CPU, 也会影响吞吐量; 当内存不足时会触发频繁地 GC, 耗费 CPU, 最后也会反映到业务指标上来.</p> <p>那如何监控这些指标呢? Tomcat 可以通过 <strong>JMX</strong> 将上述指标暴露出来的. JMX(Java Management Extensions, 即 Java 管理扩展)是一个为应用程序, 设备, 系统等植入监控管理功能的框架. JMX 使用管理 MBean 来监控业务资源, 这些 MBean 在 JMX MBean 服务器上注册, 代表 JVM 中运行的应用程序或服务. 每个 MBean 都有一个属性列表. JMX 客户端可以连接到 MBean Server 来读写 MBean 的属性值. 可以通过下面这张图来理解一下 JMX 的工作原理:</p> <p><img src="/img/image-20230405162457-wtmtkez.png" alt=""></p> <p>Tomcat 定义了一系列 MBean 来对外暴露系统状态, 接下来看看如何通过 JConsole 来监控这些指标.</p> <h5 id="通过jconsole监控tomcat"><a href="#通过jconsole监控tomcat" class="header-anchor">#</a> 通过JConsole监控Tomcat</h5> <p>首先需要开启 JMX 的远程监听端口, 具体来说就是设置若干 JVM 参数. 可以在 Tomcat 的 bin 目录下新建一个名为 <code>setenv.sh</code>​ 的文件(或者 <code>setenv.bat</code>​, 根据操作系统类型), 然后输入下面的内容:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export JAVA_OPTS=&quot;${JAVA_OPTS} -Dcom.sun.management.jmxremote&quot;export JAVA_OPTS=&quot;${JAVA_OPTS} -Dcom.sun.management.jmxremote.port=9001&quot;export JAVA_OPTS=&quot;${JAVA_OPTS} -Djava.rmi.server.hostname=x.x.x.x&quot;export JAVA_OPTS=&quot;${JAVA_OPTS} -Dcom.sun.management.jmxremote.ssl=false&quot;export JAVA_OPTS=&quot;${JAVA_OPTS} -Dcom.sun.management.jmxremote.authenticate=false&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>重启 Tomcat, 这样 JMX 的监听端口 9001 就开启了, 接下来通过 JConsole 来连接这个端口.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>jconsole x.x.x.x:9001
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>可以看到 JConsole 的主界面:</p> <p><img src="/img/image-20230405162457-82gv2n0.png" alt=""></p> <p>前面提到的需要监控的关键指标有<strong>吞吐量, 响应时间, 错误数, 线程池, CPU 以及 JVM 内存</strong>, 接下来看看怎么在 JConsole 上找到这些指标.</p> <p><strong>吞吐量, 响应时间, 错误数</strong></p> <p>在 MBeans 标签页下选择 GlobalRequestProcessor, 这里有 Tomcat 请求处理的统计信息. 可以看到 Tomcat 中的各种连接器, 展开&quot;http-nio-8080&quot;, 可以看到这个连接器上的统计信息, 其中 maxTime 表示最长的响应时间, processingTime 表示平均响应时间, requestCount 表示吞吐量, errorCount 就是错误数.</p> <p><img src="/img/image-20230405162457-zx5xjbq.png" alt=""></p> <p><strong>线程池</strong></p> <p>选择&quot;线程&quot;标签页, 可以看到当前 Tomcat 进程中有多少线程, 如下图所示:</p> <p><img src="/img/image-20230405162457-5yudkqb.png" alt=""></p> <p>图的左下方是线程列表, 右边是线程的运行栈, 这些都是非常有用的信息. 如果大量线程阻塞, 通过观察线程栈, 能看到线程阻塞在哪个函数, 有可能是 I/O 等待, 或者是死锁.</p> <p><strong>CPU</strong></p> <p>在主界面可以找到 CPU 使用率指标, 请注意这里的 CPU 使用率指的是 Tomcat 进程占用的 CPU, 不是主机总的 CPU 使用率.</p> <p><img src="/img/image-20230405162457-iowmjst.png" alt=""></p> <p><strong>JVM 内存</strong></p> <p>选择&quot;内存&quot;标签页, 能看到 Tomcat 进程的 JVM 内存使用情况.</p> <p><img src="/img/image-20230405162457-wq7qshv.png" alt=""></p> <p>还可以查看 JVM 各内存区域的使用情况, 大的层面分堆区和非堆区. 堆区里有分为 Eden, Survivor 和 Old. 选择 &quot;VM Summary&quot; 标签, 可以看到虚拟机内的详细信息.</p> <p><img src="/img/image-20230405162457-meinc5r.png" alt=""></p> <h5 id="命令行查看tomcat指标"><a href="#命令行查看tomcat指标" class="header-anchor">#</a> 命令行查看Tomcat指标</h5> <p>极端情况下如果 Web 应用占用过多 CPU 或者内存, 又或者程序中发生了死锁, 导致 Web 应用对外没有响应, 监控系统上看不到数据, 这个时候需要登陆到目标机器, 通过命令行来查看各种指标.</p> <p>(1) 首先通过 ps 命令找到 Tomcat 进程, 拿到进程 ID.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> tomcat
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>(2) 接着查看进程状态的大致信息, 通过 <code>cat/proc/&lt;pid&gt;/status</code>​ 命令:</p> <p><img src="/img/image-20230405162457-5rygbma.png" alt=""></p> <p>(3) 监控进程的 CPU 和内存资源使用情况:</p> <p><img src="/img/image-20230405162457-cz4qiar.png" alt=""></p> <p>(4) 查看 Tomcat 的网络连接, 比如 Tomcat 在 8080 端口上监听连接请求, 通过下面的命令查看连接列表:</p> <p><img src="/img/image-20230405162457-l4hlmeo.png" alt=""></p> <p>还可以分别统计处在 &quot;已连接&quot; 状态和 &quot;TIME_WAIT&quot; 状态的连接数:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">netstat</span> <span class="token parameter variable">-na</span> <span class="token operator">|</span> <span class="token function">grep</span> ESTAB <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">8080</span> <span class="token operator">|</span> <span class="token function">wc</span> <span class="token parameter variable">-l</span>
<span class="token number">12</span>
$ <span class="token function">netstat</span> <span class="token parameter variable">-na</span> <span class="token operator">|</span> <span class="token function">grep</span> TIME_WAIT <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">8080</span> <span class="token operator">|</span> <span class="token function">wc</span> <span class="token parameter variable">-l</span>
<span class="token number">43</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>(5) 通过 ifstat 来查看网络流量, 大致可以看出 Tomcat 当前的请求数和负载状况.</p> <p><img src="/img/image-20230405162457-77iof34.png" alt=""></p> <h5 id="实战案例"><a href="#实战案例" class="header-anchor">#</a> 实战案例</h5> <p>在这个实战案例中, 会创建一个 Web 应用, 根据传入的参数 latency 来休眠相应的秒数, 目的是模拟当前的 Web 应用在访问下游服务时遇到的延迟. 然后用 JMeter 来压测这个服务, 通过 JConsole 来观察 Tomcat 的各项指标, 分析和定位问题.</p> <p>主要的步骤有:</p> <p>(1) 创建一个 Spring Boot 程序, 加入下面代码所示的一个 RestController:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DownStreamLatency</span> <span class="token punctuation">{</span>
 
    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/greeting/latency/{seconds}&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">Greeting</span> <span class="token function">greeting</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token keyword">long</span> seconds<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>seconds <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
 
        <span class="token class-name">Greeting</span> greeting <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Greeting</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token keyword">return</span> greeting<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>上面的程序会读取 URL 传过来的 seconds 参数, 先休眠相应的秒数, 再返回请求. 这样做的目的是, 客户端压测工具能够控制服务端的延迟.</p> <p>为了方便观察 Tomcat 的线程数跟延迟之间的关系, 还需要加大 Tomcat 的最大线程数, 可以在 <code>application.properties</code>​ 文件中加入这样一行:</p> <div class="language-properties line-numbers-mode"><pre class="language-properties"><code><span class="token key attr-name">server.tomcat.max-threads</span><span class="token punctuation">=</span><span class="token value attr-value">1000</span>
<span class="token key attr-name">server.tomcat.max-threads</span><span class="token punctuation">=</span><span class="token value attr-value">1000</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>(2) 启动 JMeter 开始压测, 这里将压测的线程数设置为 100:</p> <p><img src="/img/image-20230405162457-pvhfecw.png" alt=""></p> <p>注意, 还需要将客户端的 Timeout 设置为 1000 毫秒, 这是因为 JMeter 的测试线程在收到响应之前, <strong>不会发出下一次请求</strong>, 这就意味没法按照固定的吞吐量向服务端加压. 而加了 Timeout 以后, JMeter 会有固定的吞吐量向 Tomcat 发送请求.</p> <p><img src="/img/image-20230405162457-3eve09q.png" alt=""></p> <p>(3) 开启测试, 这里分三个阶段, 第一个阶段将服务端休眠时间设为 2 秒, 然后暂停一段时间. 第二和第三阶段分别将休眠时间设置成 4 秒和 6 秒.</p> <p><img src="/img/image-20230405162457-li13uu9.png" alt=""></p> <p>(4) 最后通过 JConsole 来观察结果:</p> <p><img src="/img/image-20230405162457-j4uljme.png" alt=""></p> <p>下面从线程数, 内存和 CPU 这三个指标来分析 Tomcat 的性能问题.</p> <ul><li>首先看线程数, 在第一阶段时间之前, 线程数大概是 40, 第一阶段压测开始后, 线程数增长到 250. 为什么是 250 呢? 这是因为 JMeter 每秒会发出 100 个请求, 每一个请求休眠 2 秒, 因此 Tomcat 需要 200 个工作线程来干活; 此外 Tomcat 还有一些其他线程用来处理网络通信和后台任务, 所以总数是 250 左右. 第一阶段压测暂停后, 线程数又下降到 40, 这是因为线程池会回收空闲线程. 第二阶段测试开始后, 线程数涨到了 420, 这是因为每个请求休眠了 4 秒; 同理, 看到第三阶段测试的线程数是 620.</li> <li>再来看 CPU, 在三个阶段的测试中, CPU 的峰值始终比较稳定, 这是因为 JMeter 控制了总体的吞吐量, 因为服务端用来处理这些请求所需要消耗的 CPU 基本也是一样的.</li> <li>各测试阶段的内存使用量略有增加, 这是因为线程数增加了, 创建线程也需要消耗内存.</li></ul> <p>从上面的测试结果可以得出一个结论: <strong>对于一个 Web 应用来说, 下游服务的延迟越大, Tomcat 所需要的线程数越多, 但是 CPU 保持稳定</strong>. 所以如果碰到线程数飙升但是 CPU 没有增加的情况, 这个时候可以怀疑 Web 应用所依赖的下游服务是不是出了问题, 响应时间是否变长了.</p> <h5 id="总结-17"><a href="#总结-17" class="header-anchor">#</a> 总结</h5> <p>Tomcat 的关键的性能指标主要有**吞吐量, 响应时间, 错误数, 线程池, CPU 以及 JVM 内存. **</p> <p>在实际工作中, 需要通过观察这些指标来诊断系统遇到的性能问题, 找到性能瓶颈. 如果监控到 CPU 上升, 这时可以看看吞吐量是不是也上升了, 如果是那说明正常; 如果不是的话, 可以看看 GC 的活动, 如果 GC 活动频繁, 并且内存居高不下, 基本可以断定是内存泄漏.</p> <h4 id="_36-tomcat-io和线程池的并发调优"><a href="#_36-tomcat-io和线程池的并发调优" class="header-anchor">#</a> 36.Tomcat IO和线程池的并发调优</h4> <p>Tomcat 的调优涉及 <mark><strong>I/O 模型和线程池调优, JVM 内存调优以及网络优化</strong></mark>等, 本节分析 I/O 模型和线程池调优, 由于 Web 应用程序跑在 Tomcat 的工作线程中, 因此 Web 应用对请求的处理时间也直接影响 Tomcat 整体的性能, 而 Tomcat 和 Web 应用在运行过程中所用到的资源都来自于操作系统, 因此调优需要将服务端看作是一个整体来考虑.</p> <p>**所谓的 I/O 调优指的是选择 NIO, NIO.2 还是 APR, 而线程池调优指的是给 Tomcat 的线程池设置合适的参数, 使得 Tomcat 能够又快又好地处理请求. **</p> <h5 id="i-o模型的选择"><a href="#i-o模型的选择" class="header-anchor">#</a> I/O模型的选择</h5> <p><strong>I/O 调优实际上是连接器类型的选择, 一般情况下默认都是 NIO</strong>, 在绝大多数情况下都是够用的, 除非你的 Web 应用用到了 TLS 加密传输, 而且对性能要求极高, 这个时候可以考虑 APR, 因为 APR 通过 OpenSSL 来处理 TLS 握手和加 / 解密. OpenSSL 本身用 C 语言实现, 它还对 TLS 通信做了优化, 所以性能比 Java 要高.</p> <p>什么时候考虑选择 NIO.2? 一般建议是如果 Tomcat 跑在 Windows 平台上, 并且 HTTP 请求的数据量比较大, 可以考虑 NIO.2, 这是因为 Windows 从操作系统层面实现了真正意义上的异步 I/O, 如果传输的数据量比较大, 异步 I/O 的效果就能显现出来.</p> <p>如果 <strong>Tomcat 跑在 Linux 平台上, 建议使用 NIO</strong>, 这是因为 Linux 内核没有很完善地支持异步 I/O 模型, 因此 JVM 并没有采用原生的 Linux 异步 I/O, 而是在应用层面通过 epoll 模拟了异步 I/O 模型, 只是 Java NIO 的使用者感觉不到而已. 因此可以这样理解, 在 Linux 平台上, <strong>Java NIO 和 Java NIO.2 底层都是通过 epoll 来实现的, 但是 Java NIO 更加简单高效</strong>.</p> <h5 id="线程池调优"><a href="#线程池调优" class="header-anchor">#</a> 线程池调优</h5> <p><strong>跟 I/O 模型紧密相关的是线程池, 线程池的调优就是设置合理的线程池参数</strong>. 先来看看 Tomcat 线程池中有哪些关键参数:</p> <p><img src="/img/image-20230405162514-3jn10hn.jpg" alt=""></p> <p>**这里面最核心的就是如何确定 **​<mark><strong>maxThreads</strong></mark>​ ** 的值, 如果这个参数设置小了, Tomcat 会发生线程饥饿, 并且请求的处理会在队列中排队等待, 导致响应时间变长; 如果 maxThreads 参数值过大, 同样也会有问题, 因为服务器的 CPU 的核数有限, 线程数太多会导致线程在 CPU 上来回切换, 耗费大量的切换开销. **</p> <p>那 maxThreads 设置成多少才算是合适呢? 为了理解清楚这个问题, 先来看看什么是利特尔法则(Little’s Law).</p> <p><strong>利特尔法则</strong></p> <blockquote><p>系统中的请求数 = 请求的到达速率 × 每个请求处理时间</p></blockquote> <p>其实这个公式很好理解, 举个例子: 我们去超市购物结账需要排队, 如何估算一个队列有多长呢? 队列中如果每个人都买很多东西, 那么结账的时间就越长, 队列也会越长; 同理, 短时间一下有很多人来收银台结账, 队列也会变长. 因此队列的长度等于新人加入队列的频率乘以平均每个人处理的时间.</p> <p>**计算出了队列的长度, 那么就创建相应数量的线程来处理请求, 这样既能以最快的速度处理完所有请求, 同时又没有额外的线程资源闲置和浪费. **</p> <p>假设一个单核服务器在接收请求:</p> <ul><li>如果每秒 10 个请求到达, 平均处理一个请求需要 1 秒, 那么服务器任何时候都有 10 个请求在处理, 即需要 10 个线程.</li> <li>如果每秒 10 个请求到达, 平均处理一个请求需要 2 秒, 那么服务器在每个时刻都有 20 个请求在处理, 因此需要 20 个线程.</li> <li>如果每秒 10000 个请求到达, 平均处理一个请求需要 1 秒, 那么服务器在每个时刻都有 10000 个请求在处理, 因此需要 10000 个线程.</li></ul> <p>因此可以总结出一个公式:</p> <blockquote><p>线程池大小 = 每秒请求数 × 平均请求处理时间</p></blockquote> <p>这是<strong>理想</strong>的情况, 也就是说线程一直在忙着干活, 没有被阻塞在 I/O 等待上. 实际上任务在执行中, 线程不可避免会发生阻塞, 比如阻塞在 I/O 等待上, 等待数据库或者下游服务的数据返回, 虽然通过非阻塞 I/O 模型可以减少线程的等待, 但是数据在用户空间和内核空间拷贝过程中, 线程还是阻塞的. 线程一阻塞就会让出 CPU, 线程闲置下来, 就好像工作人员不可能 24 小时不间断地处理客户的请求, 解决办法就是增加工作人员的数量, 一个人去休息另一个人再顶上. <strong>对应到线程池就是增加线程数量, 因此 I/O 密集型应用需要设置更多的线程</strong>.</p> <p><strong>线程 I/O 时间与 CPU 时间</strong></p> <p>至此又得到一个线程池个数的计算公式, 假设服务器是单核的:</p> <blockquote><p>线程池大小 = (线程 I/O 阻塞时间 + 线程 CPU 时间 )/ 线程 CPU 时间</p></blockquote> <p>其中: <strong>线程 I/O 阻塞时间 + 线程 CPU 时间 = 平均请求处理时间</strong></p> <p>对比一下两个公可以发现, <strong>平均请求处理时间</strong>在两个公式里都出现了, 这说明请求时间越长, 需要更多的线程是毫无疑问的.</p> <p>不同的是第一个公式是用<strong>每秒请求数</strong>来乘以请求处理时间; 而第二个公式用<strong>请求处理时间</strong>来除以<strong>线程 CPU 时间</strong>, 请注意 CPU 时间是小于请求处理时间的.</p> <p>虽然这两个公式是从不同的角度来看待问题的, 但都是<strong>理想情况</strong>, 都有一定的前提条件.</p> <ol><li>请求处理时间越长, 需要的线程数越多, 但前提是 CPU 核数要足够, 如果一个 CPU 来支撑 10000 TPS 并发, 创建 10000 个线程, 显然不合理, 会造成大量线程上下文切换.</li> <li>请求处理过程中, I/O 等待时间越长, 需要的线程数越多, 前提是 CUP 时间和 I/O 时间的比率要计算的足够准确.</li> <li>请求进来的速率越快, 需要的线程数越多, 前提是 CPU 核数也要跟上.</li></ol> <h5 id="实际场景下如何确定线程数"><a href="#实际场景下如何确定线程数" class="header-anchor">#</a> 实际场景下如何确定线程数</h5> <p>那么在实际情况下, 线程池的个数如何确定呢? <mark><strong>这是一个迭代的过程, 先用上面两个公式大概算出理想的线程数, 再反复压测调整, 从而达到最优</strong></mark>.</p> <p>一般来说, 如果系统的 TPS 要求足够大, 用第一个公式算出来的线程数往往会比公式二算出来的要大. 建议选取这两个值中间更靠近公式二的值. 也就是<strong>先设置一个较小的线程数, 然后进行压测, 当达到系统极限时(错误数增加, 或者响应时间大幅增加), 再逐步加大线程数, 当增加到某个值, 再增加线程数也无济于事, 甚至 TPS 反而下降, 那这个值可以认为是最佳线程数</strong>.</p> <p><strong>线程池中其他的参数, 最好就用默认值, 能不改就不改, 除非在压测的过程发现了瓶颈</strong>. 如果发现了问题就需要调整, 比如 maxQueueSize, 如果大量任务来不及处理都堆积在 maxQueueSize 中, 会导致内存耗尽, 这个时候就需要给 maxQueueSize 设一个限制. 当然, 这是一个比较极端的情况了.</p> <p>再比如 minSpareThreads 参数, 默认是 25 个线程, 如果你发现系统在闲的时候用不到 25 个线程, 就可以调小一点; 如果系统在大部分时间都比较忙, 线程池中的线程总是远远多于 25 个, 这个时候就可以把这个参数调大一点, 因为这样线程池就不需要反复地创建和销毁线程了.</p> <h4 id="_37-tomcat内存溢出的原因分析及调优"><a href="#_37-tomcat内存溢出的原因分析及调优" class="header-anchor">#</a> 37.Tomcat内存溢出的原因分析及调优</h4> <p>程序员几乎都会碰到 java.lang.OutOfMemoryError 异常, JVM 在抛出 java.lang.OutOfMemoryError 时, 除了会打印出一行描述信息, 还会打印堆栈跟踪, 因此可以通过这些信息来找到导致异常的原因. 在寻找原因前, 先来看看有哪些因素会导致 OutOfMemoryError, 其中内存泄漏是导致 OutOfMemoryError 的一个比较常见的原因, 最后通过一个实战案例来定位内存泄漏.</p> <h5 id="内存溢出场景及方案"><a href="#内存溢出场景及方案" class="header-anchor">#</a> 内存溢出场景及方案</h5> <blockquote><p>java.lang.OutOfMemoryError: Java heap space</p></blockquote> <p>JVM 无法在堆中分配对象时, 会抛出这个异常, 导致这个异常的原因可能有三种:</p> <p>(1) 内存泄漏. Java 应用程序一直持有 Java 对象的引用, 导致对象无法被 GC 回收, 比如对象池和内存池中的对象无法被 GC 回收.</p> <p>(2) 配置问题. 有可能是通过 JVM 参数指定的堆大小(或者未指定的默认大小), 对于应用程序来说是不够的. 解决办法是通过 JVM 参数加大堆的大小.</p> <p>(3) finalize() 方法的过度使用. 如果想在 Java 类实例被 GC 之前执行一些逻辑, 比如清理对象持有的资源, 可以在 Java 类中定义 finalize() 方法, 这样 JVM GC 不会立即回收这些对象实例, 而是将对象实例添加到一个叫 &quot;java.lang.ref.Finalizer.ReferenceQueue&quot; 的队列中, 执行对象的 finalize() 方法, 之后才会回收这些对象. Finalizer 线程会和主线程竞争 CPU 资源, 但由于优先级低, 所以处理速度跟不上主线程创建对象的速度, 因此 ReferenceQueue 队列中的对象就越来越多, 最终会抛出 OutOfMemoryError. 解决办法是尽量不要给 Java 类定义 finalize() 方法.</p> <blockquote><p>java.lang.OutOfMemoryError: GC overhead limit exceeded</p></blockquote> <p>出现这种 OutOfMemoryError 的原因是, 垃圾收集器一直在运行, 但是 GC 效率很低, 比如 Java 进程花费超过 98％ 的 CPU 时间来进行一次 GC, 但是<strong>回收的内存少于 2％ 的 JVM 堆, 并且连续 5 次 GC 都是这种情况</strong>, 就会抛出 OutOfMemoryError.</p> <p>解决办法是查看 GC 日志或者生成 Heap Dump, 确认一下是不是内存泄漏, 如果不是内存泄漏可以考虑增加 Java 堆的大小. 当然还可以通过参数配置来告诉 JVM 无论如何也不要抛出这个异常, 方法是配置 <code>-XX:-UseGCOverheadLimit</code>​, 但是不推荐这么做, 因为这只是延迟了 OutOfMemoryError 的出现.</p> <blockquote><p>java.lang.OutOfMemoryError: Requested array size exceeds VM limit</p></blockquote> <p>从错误消息也能猜到, 抛出这种异常的原因是&quot;<strong>请求的数组大小超过 JVM 限制</strong>&quot;, 应用程序尝试分配一个超大的数组. 比如应用程序尝试分配 512MB 的数组, 但最大堆大小为 256MB, 则将抛出 OutOfMemoryError, 并且请求的数组大小超过 VM 限制.</p> <p>通常这也是一个配置问题(JVM 堆太小), 或者是应用程序的一个 Bug, 比如程序错误地计算了数组的大小, 导致尝试创建一个大小为 1GB 的数组.</p> <blockquote><p>java.lang.OutOfMemoryError: MetaSpace</p></blockquote> <p><strong>如果 JVM 的元空间用尽</strong>, 则会抛出这个异常. 由于 JVM 元空间的内存在本地内存中分配, 但是它的大小受参数 MaxMetaSpaceSize 的限制. 当元空间大小超过 MaxMetaSpaceSize 时, JVM 将抛出带有 MetaSpace 字样的 OutOfMemoryError. 解决办法是加大 MaxMetaSpaceSize 参数的值.</p> <blockquote><p>java.lang.OutOfMemoryError: Request size bytes for reason. Out of swap space</p></blockquote> <p><strong>当本地堆内存分配失败或者本地内存快要耗尽时</strong>, Java HotSpot VM 代码会抛出这个异常, VM 会触发 &quot;致命错误处理机制&quot;, 它会生成 &quot;致命错误&quot; 日志文件, 其中包含崩溃时线程, 进程和操作系统的有用信息. 如果碰到此类型的 OutOfMemoryError, 需要根据 JVM 抛出的错误信息来进行诊断; 或者使用操作系统提供的 DTrace 工具来跟踪系统调用, 看看是什么样的程序代码在不断地分配本地内存.</p> <blockquote><p>java.lang.OutOfMemoryError: Unable to create native threads</p></blockquote> <p>抛出这个异常的过程大概是这样的:</p> <p>(1) Java 程序向 JVM 请求创建一个新的 Java 线程.</p> <p>(2) JVM 本地代码(Native Code)代理该请求, 通过调用操作系统 API 去创建一个操作系统级别的线程 Native Thread.</p> <p>(3) 操作系统尝试创建一个新的 Native Thread, 需要同时分配一些内存给该线程, 每一个 Native Thread 都有一个线程栈, 线程栈的大小由 JVM 参数 <code>-Xss</code>​ 决定.</p> <p>(4) 由于各种原因, 操作系统创建新的线程可能会失败, 下面会详细谈到.</p> <p>(5) JVM 抛出 &quot;java.lang.OutOfMemoryError: Unable to create new native thread&quot; 错误.</p> <p>因此关键在于第四步线程创建失败, JVM 就会抛出 OutOfMemoryError, 那具体有<strong>哪些因素会导致线程创建失败</strong>呢?</p> <p>(1) <strong>内存大小限制</strong>: 前面提到, Java 创建一个线程需要消耗一定的栈空间, 并通过 <code>-Xss</code>​ 参数指定. 注意栈空间如果过小, 可能会导致 StackOverflowError, 尤其是在递归调用的情况下; 但是栈空间过大会占用过多内存, 而对于一个 32 位 Java 应用来说, 用户进程空间是 4GB, 内核占用 1GB, 那么用户空间就剩下 3GB, 因此它能创建的线程数大致可以通过这个公式算出来:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Max memory(3GB) = [-Xmx] + [-XX:MaxMetaSpaceSize] + number_of_threads * [-Xss]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>不过对于 64 位的应用, 由于虚拟进程空间近乎无限大, 因此不会因为线程栈过大而耗尽虚拟地址空间. 注意, 64 位的 Java 进程能分配的最大内存数仍然受物理内存大小的限制.</p> <p>(2) <strong>ulimit 限制</strong>, 在 Linux 下执行 <code>ulimit -a</code>​, 可以看到 ulimit 对各种资源的限制.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>$ <span class="token builtin class-name">ulimit</span> <span class="token parameter variable">-a</span>
core <span class="token function">file</span> size          <span class="token punctuation">(</span>blocks, -c<span class="token punctuation">)</span> unlimited
data seg size           <span class="token punctuation">(</span>kbytes, -d<span class="token punctuation">)</span> unlimited
scheduling priority             <span class="token punctuation">(</span>-e<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token function">file</span> size               <span class="token punctuation">(</span>blocks, -f<span class="token punctuation">)</span> unlimited
pending signals                 <span class="token punctuation">(</span>-i<span class="token punctuation">)</span> <span class="token number">1028666</span>
max locked memory       <span class="token punctuation">(</span>kbytes, -l<span class="token punctuation">)</span> <span class="token number">64</span>
max memory size         <span class="token punctuation">(</span>kbytes, -m<span class="token punctuation">)</span> unlimited
<span class="token function">open</span> files                      <span class="token punctuation">(</span>-n<span class="token punctuation">)</span> <span class="token number">1048576</span>
pipe size            <span class="token punctuation">(</span><span class="token number">512</span> bytes, -p<span class="token punctuation">)</span> <span class="token number">8</span>
POSIX message queues     <span class="token punctuation">(</span>bytes, -q<span class="token punctuation">)</span> <span class="token number">819200</span>
real-time priority              <span class="token punctuation">(</span>-r<span class="token punctuation">)</span> <span class="token number">0</span>
stack size              <span class="token punctuation">(</span>kbytes, -s<span class="token punctuation">)</span> <span class="token number">8192</span>         <span class="token comment"># 线程栈大小</span>
cpu <span class="token function">time</span>               <span class="token punctuation">(</span>seconds, -t<span class="token punctuation">)</span> unlimited
max user processes              <span class="token punctuation">(</span>-u<span class="token punctuation">)</span> unlimited    <span class="token comment"># 一个进程能创建的最大线程数</span>
virtual memory          <span class="token punctuation">(</span>kbytes, -v<span class="token punctuation">)</span> unlimited
<span class="token function">file</span> locks                      <span class="token punctuation">(</span>-x<span class="token punctuation">)</span> unlimited
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>其中的 &quot;max user processes&quot; 就是一个进程能创建的最大线程数, 可以修改这个参数:</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># ulimit -u 65535</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>(3) <strong>参数 <strong>​</strong>​<code>sys.kernel.threads-max</code>​</strong>​ <strong>限制</strong>. 这个参数限制操作系统全局的线程数, 通过下面的命令可以查看它的值.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">cat</span> /proc/sys/kernel/threads-max
<span class="token number">1030516</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这表明当前系统能创建的总的线程是 1030516. 当然调整这个参数, 具体办法是:</p> <p>在 <code>/etc/sysctl.conf</code>​ 配置文件中, 加入 <code>sys.kernel.threads-max = 999999</code>​.</p> <p>(4) <strong>参数 <strong>​</strong>​<code>sys.kernel.pid_max</code>​</strong>​ <strong>限制</strong>, 这个参数表示系统全局的 PID 号数值的限制, 每一个线程都有 ID, ID 的值超过这个数, 线程就会创建失败. 跟 <code>sys.kernel.threads-max</code>​ 参数一样, 也可以将 <code>sys.kernel.pid_max</code>​ 调大, 方法是在 <code>/etc/sysctl.conf</code>​ 配置文件中, 加入 <code>sys.kernel.pid_max = 999999</code>​.</p> <p>对于线程创建失败的 OutOfMemoryError, 除了调整各种参数, 还需要从程序本身找找原因, 看看是否真的需要这么多线程, 有可能是程序的 Bug 导致创建过多的线程.</p> <h5 id="内存泄漏定位实战"><a href="#内存泄漏定位实战" class="header-anchor">#</a> 内存泄漏定位实战</h5> <p>先创建一个 Web 应用, 不断地 new 新对象放到一个 List 中, 来模拟 Web 应用中的内存泄漏. 然后通过各种工具来观察 GC 的行为, 最后通过生成 Heap Dump 来找到泄漏点.</p> <p>内存泄漏模拟程序比较简单, 创建一个 Spring Boot 应用, 定义如下所示的类:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>scheduling<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Scheduled</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span></span><span class="token punctuation">;</span>
 
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">LinkedList</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span>
 
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemLeaker</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> objs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedRate <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            objs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>这个程序做的事情就是每隔 1 秒向一个 List 中添加 50000 个对象. 接下来运行并通过工具观察它的 GC 行为:</p> <p>(1) 运行程序并打开 verbosegc, 将 GC 的日志输出到 gc.log 文件中.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>java -verbose:gc -Xloggc:gc.log -XX:+PrintGCDetails -jar mem-0.0.1-SNAPSHOT.jar
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>(2) 使用<code>jstat</code>​命令观察 GC 的过程:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>jstat -gc 94223 2000 1000
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>94223 是程序的进程 ID, 2000 表示每隔 2 秒执行一次, 1000 表示持续执行 1000 次. 下面是命令的输出:</p> <p><img src="/img/image-20230405162534-2mas2x2.png" alt=""></p> <p>其中每一列的含义是:</p> <ul><li>S0C: 第一个 Survivor 区总的大小;</li> <li>S1C: 第二个 Survivor 区总的大小;</li> <li>S0U: 第一个 Survivor 区已使用内存的大小;</li> <li>S1U: 第二个 Survivor 区已使用内存的大小.</li></ul> <p>后面的列中 E 代表 Eden, O 代表 Old, M 代表 Metadata; YGC 表示 Minor GC 的总时间, YGCT 表示 Minor GC 的次数; FGC 表示 Full GC.</p> <p>通过这个工具能大概看到各个内存区域的大小, 已经 GC 的次数和所花的时间. verbosegc 参数对程序的影响比较小, 因此很适合在生产环境现场使用.</p> <p>(3) 通过 GCViewer 工具查看 GC 日志, 用 GCViewer 打开第一步产生的 gc.log, 会看到这样的图:</p> <p><img src="/img/image-20230405162534-3n59227.png" alt=""></p> <p>图中红色的线表示年老代占用的内存, 可以看到它一直在增加, 而黑色的竖线表示一次 Full GC. 可以看到后期 JVM 在频繁地 Full GC, 但是<strong>年老代的内存并没有降下来, 这是典型的内存泄漏的特征</strong>.</p> <p>除了内存泄漏, 还可以通过 GCViewer 来观察 Minor GC 和 Full GC 的频次, 已及每次的内存回收量.</p> <p>(4) 为了找到内存泄漏点, 通过 jmap 工具生成 Heap Dump:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>jmap -dump:live,format=b,file=94223.bin 94223
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>(5) 用 Eclipse Memory Analyzer 打开 Dump 文件, 通过内存泄漏分析, 得到这样一个分析报告:</p> <p><img src="/img/image-20230405162534-2iypr18.png" alt=""></p> <p>从报告中可以看到, JVM 内存中有一个长度为 4000 万的 List, 至此也就找到了泄漏点.</p> <h4 id="_38-tomcat拒绝连接原因分析及网络优化"><a href="#_38-tomcat拒绝连接原因分析及网络优化" class="header-anchor">#</a> 38.Tomcat拒绝连接原因分析及网络优化</h4> <p>本节来看看网络通信中可能会碰到的各种错误. 网络通信方面的错误和异常也是在实际工作中经常碰到的, 需要理解异常背后的原理, 才能更快更精准地定位问题, 从而找到解决办法.</p> <p>下面会先讲讲 Java Socket 网络编程常见的异常有哪些, 然后通过一个实验来重现其中的 Connection reset 异常, 并且通过配置 Tomcat 的参数来解决这个问题.</p> <h5 id="常见异常"><a href="#常见异常" class="header-anchor">#</a> 常见异常</h5> <blockquote><p>java.net.SocketTimeoutException</p></blockquote> <p><strong>指超时错误</strong>. 超时分为<strong>连接超时</strong>和<strong>读取超时</strong>, 连接超时是指在调用 Socket.connect 方法的时候超时, 而读取超时是调用 Socket.read 方法时超时. 连接超时往往是由于网络不稳定造成的, 但是读取超时不一定是网络延迟造成的, 很有可能是下游服务的响应时间过长.</p> <blockquote><p>java.net.BindException: Address already in use: JVM_Bind</p></blockquote> <p><strong>指端口被占用</strong>. 当服务器端调用 new ServerSocket(port) 或者 Socket.bind 函数时, 如果端口已经被占用, 就会抛出这个异常. 可以用 <code>netstat –an</code>​ 命令来查看端口被谁占用了, 换一个没有被占用的端口就能解决.</p> <blockquote><p>java.net.ConnectException: Connection refused: connect</p></blockquote> <p><strong>指连接被拒绝</strong>. 当客户端调用 new Socket(ip, port) 或者 Socket.connect 函数时, 可能会抛出这个异常. 原因是指定 IP 地址的机器没有找到; 或者是机器存在, 但这个机器上没有开启指定的监听端口.</p> <p>解决办法是从客户端机器 ping 一下服务端 IP, 假如 ping 不通, 可以看看 IP 是不是写错了; 假如能 ping 通, 需要确认服务端的服务是不是崩溃了.</p> <blockquote><p>java.net.SocketException: Socket is closed</p></blockquote> <p><strong>指连接已关闭</strong>. 出现这个异常的原因是<strong>通信的一方主动关闭了 Socket 连接(调用了 Socket 的 close 方法), 接着又对 Socket 连接进行了读写操作</strong>, 这时操作系统会报 &quot;Socket 连接已关闭&quot; 的错误.</p> <blockquote><p>java.net.SocketException: Connection reset/Connect reset by peer: Socket write error</p></blockquote> <p><strong>指连接被重置</strong>. 这里有两种情况, 分别对应两种错误, <strong>通信的一方已经将 Socket 关闭, 可能是主动关闭或者是因为异常退出</strong>, (1) 这时如果通信的另一方还在<strong>写数据</strong>, 就会触发这个异常(Connect reset by peer); (2) 如果对方还在尝试从 TCP 连接中<strong>读数据</strong>, 则会抛出 Connection reset 异常.</p> <p>为了避免这些异常发生, 在编写网络通信程序时要确保:</p> <ul><li>**程序退出前要主动关闭所有的网络连接. **</li> <li>**检测通信的另一方的关闭连接操作, 当发现另一方关闭连接后自己也要关闭该连接. **</li></ul> <blockquote><p>java.net.SocketException: Broken pipe</p></blockquote> <p><strong>指通信管道已坏</strong>. 发生这个异常的场景是, 通信的一方在收到 &quot;Connect reset by peer: Socket write error&quot; 后, 如果<strong>再继续写数据</strong>则会抛出 Broken pipe 异常, 解决方法同上.</p> <blockquote><p>java.net.SocketException: Too many open files</p></blockquote> <p><strong>指进程打开文件句柄数超过限制</strong>. 当并发用户数比较大时, 服务器可能会报这个异常. 这是因为每创建一个 Socket 连接就需要一个文件句柄, 此外服务端程序在处理请求时可能也需要打开一些文件.</p> <p>可以通过 <code>lsof -p pid</code>​ 命令查看进程打开了哪些文件, 是不是有资源泄露, 也就是说进程打开的这些文件本应该被关闭, 但由于程序的 Bug 而没有被关闭.</p> <p>如果没有资源泄露, 可以通过设置增加最大文件句柄数. 具体方法是通过 <code>ulimit -a</code>​ 来查看系统目前资源限制, 通过 <code>ulimit -n 10240</code>​ 修改最大文件数.</p> <h5 id="tomcat网络参数"><a href="#tomcat网络参数" class="header-anchor">#</a> Tomcat网络参数</h5> <p>接下来看看 Tomcat 两个比较关键的参数: <mark><strong>maxConnections 和 acceptCount</strong></mark>. 在解释这个参数之前, 先简单回顾下 TCP 连接的建立过程: 客户端向服务端发送 SYN 包, 服务端回复 SYN＋ACK, 同时将这个处于 SYN_RECV 状态的连接保存到<strong>半连接队列</strong>. 客户端返回 ACK 包完成三次握手, 服务端将 ESTABLISHED 状态的连接移入<strong>accept 队列</strong>, 等待应用程序(Tomcat)调用 accept 方法将连接取走. 这里涉及两个队列:</p> <ul><li><strong>半连接队列</strong>: 保存 SYN_RECV 状态的连接. 队列长度由 <code>net.ipv4.tcp_max_syn_backlog</code>​ 设置.</li> <li><strong>accept 队列</strong>: 保存 ESTABLISHED 状态的连接. 队列长度为 <code>min(net.core.somaxconn, backlog)</code>​. 其中 backlog 是创建 ServerSocket 时指定的参数, 最终会传递给 listen 方法:</li></ul> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果设置的 backlog 大于 <code>net.core.somaxconn</code>​, accept 队列的长度将被设置为 <code>net.core.somaxconn</code>​, 而这个 backlog 参数就是 Tomcat 中的 <strong>acceptCount ** 参数, 默认值是 100, 但请注意 <code>net.core.somaxconn</code>​ 的默认值是 128. 可以想象在高并发情况下当 Tomcat 来不及处理新的连接时, 这些</strong>连接都被堆积在 accept 队列**中, 而 **acceptCount ** 参数可以控制 accept 队列的长度, 超过这个长度时, 内核会向客户端发送 RST, 这样客户端会触发上文提到的  <strong>&quot;Connection reset&quot; 异常</strong>.</p> <p>而 Tomcat 中的 <strong>maxConnections ** 是</strong>指 Tomcat 在任意时刻接收和处理的最大连接数**. 当 Tomcat 接收的连接数达到 maxConnections 时, Acceptor 线程不会再从 accept 队列中取走连接, 这时 accept 队列中的连接会越积越多.</p> <p>maxConnections 的默认值与连接器类型有关: NIO 的默认值是 10000, APR 默认是 8192.</p> <p>**所以可以发现 Tomcat 的最大并发连接数等于 **​<mark><strong>maxConnections + acceptCount</strong></mark>​ <strong>. 如果 acceptCount 设置得过大, 请求等待时间会比较长; 如果 acceptCount 设置过小, 高并发情况下, 客户端会立即触发 Connection reset 异常.</strong></p> <h5 id="tomcat网络调优实战"><a href="#tomcat网络调优实战" class="header-anchor">#</a> Tomcat网络调优实战</h5> <p>接下来通过一个直观的例子来加深对上面两个参数的理解. 先重现流量高峰时 accept 队列堆积的情况, 这样会导致客户端触发 &quot;Connection reset&quot; 异常, 然后通过调整参数解决这个问题. 主要步骤有:</p> <p>(1) 通过 JMeter 创建一个测试计划, 一个线程组, 一个请求, 如下图所示.</p> <p><strong>测试计划</strong>:</p> <p><img src="/img/image-20230405162552-ek8x6vq.png" alt=""></p> <p><strong>线程组</strong>(线程数这里设置为 1000, 模拟大流量):</p> <p><img src="/img/image-20230405162552-xjskmao.png" alt=""></p> <p><strong>请求</strong>(请求的路径是 Tomcat 自带的例子程序):</p> <p><img src="/img/image-20230405162553-b88ed3i.png" alt=""></p> <p>(2) 启动 Tomcat.</p> <p>(3) 开启 JMeter 测试, 在 View Results Tree 中会看到大量失败的请求, 请求的响应里有 &quot;Connection reset&quot; 异常, 也就是前面提到的, 当 accept 队列溢出时, 服务端的内核发送了 RST 给客户端, 使得客户端抛出了这个异常.</p> <p><img src="/img/image-20230405162553-581oils.png" alt=""></p> <p>(4) 修改内核参数, 在 <code>/etc/sysctl.conf</code>​ 中增加一行 <code>net.core.somaxconn=2048</code>​, 然后执行命令 <code>sysctl -p</code>​.</p> <p>(5) 修改 Tomcat 参数 acceptCount 为 2048, 重启 Tomcat.</p> <p><img src="/img/image-20230405162553-eebcvda.png" alt=""></p> <p>(6) 再次启动 JMeter 测试, 这一次所有的请求会成功, 也看不到异常了. 可以通过下面的命令看到系统中 ESTABLISHED 的连接数增大了, 这是因为加大了 accept 队列的长度.</p> <p><img src="/img/image-20230405162553-z8bo9vz.png" alt=""></p> <h5 id="总结-18"><a href="#总结-18" class="header-anchor">#</a> 总结</h5> <p>Tomcat 中两个比较重要的参数: acceptCount 和 maxConnections. acceptCount 用来控制内核的 TCP 连接队列长度, maxConnections 用于控制 Tomcat 层面的最大连接数. 在实战环节, 通过调整 acceptCount 和相关的内核参数 <code>somaxconn</code>​, 增加了系统的并发度.</p> <h4 id="_39-tomcat进程占用cpu过高怎么办"><a href="#_39-tomcat进程占用cpu过高怎么办" class="header-anchor">#</a> 39.Tomcat进程占用CPU过高怎么办?</h4> <p>CPU 资源经常会成为系统性能的一个瓶颈, 这其中的原因是多方面的, 可能是内存泄露导致频繁 GC, 进而引起 CPU 使用率过高; 又可能是代码中的 Bug 创建了大量的线程, 导致 CPU 上下文切换开销.</p> <p>本节就来聊聊 Tomcat 进程的 CPU 使用率过高怎么办, 以及怎样一步一步找到问题的根因.</p> <h5 id="java进程cpu使用率高-的解决思路是什么"><a href="#java进程cpu使用率高-的解决思路是什么" class="header-anchor">#</a> &quot;Java进程CPU使用率高&quot;的解决思路是什么?</h5> <p>通常所说的 CPU 使用率过高, 这里面其实隐含着一个用来比较高与低的<strong>基准值</strong>, 比如 JVM 在峰值负载下的平均 CPU 利用率为 40％, 如果 CPU 使用率飙到 80% 就可以被认为是不正常的.</p> <p>典型的 JVM 进程包含多个 Java 线程, 其中一些在等待工作, 另一些则正在执行任务. 在单个 Java 程序的情况下, 线程数可以非常低, 而对于处理大量并发事务的互联网后台来说, 线程数可能会比较高.</p> <p>对于 CPU 的问题, <mark><strong>最重要的是要找到是哪些线程在消耗 CPU, 通过线程栈定位到问题代码; 如果没有找到个别线程的 CPU 使用率特别高, 就可以考虑是不是线程上下文切换导致了 CPU 使用率过高</strong></mark>. 下面通过一个实例来学习 CPU 问题定位的过程.</p> <h5 id="定位高cpu使用率的线程和代码"><a href="#定位高cpu使用率的线程和代码" class="header-anchor">#</a> 定位高CPU使用率的线程和代码</h5> <p>(1) 写一个模拟程序来模拟 CPU 使用率过高的问题, 这个程序会在线程池中创建 4096 个线程. 代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token annotation punctuation">@EnableScheduling</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoApplication</span> <span class="token punctuation">{</span>
 
   <span class="token comment">// 创建线程池, 其中有 4096 个线程. </span>
   <span class="token keyword">private</span> <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">// 全局变量, 访问它需要加锁. </span>
   <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>
   
   <span class="token comment">// 以固定的速率向线程池中加入任务</span>
   <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedRate <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockContention</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000000</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>i <span class="token operator">-&gt;</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">::</span><span class="token function">incrementSync</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   
   <span class="token comment">// 具体任务, 就是将 count 数加一</span>
   <span class="token keyword">private</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">incrementSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      count <span class="token operator">=</span> <span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10000000</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">DemoApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>(2) 在 Linux 环境下启动程序:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>java -Xss256k -jar demo-0.0.1-SNAPSHOT.jar
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>请注意, 这里将线程栈大小指定为 256KB. 对于测试程序来说, 操作系统的默认值 8192KB 过大, 因为需要创建 4096 个线程.</p> <p>(3) 使用 top 命令, 可以看到 Java 进程的 CPU 使用率达到了 262.3%, 注意到进程 ID 是 4361.</p> <p><img src="/img/image-20230405162626-jxhv490.png" alt=""></p> <p>(4) 接着用更精细化的 top 命令查看这个 Java 进程中各线程使用 CPU 的情况:</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># top -H -p 4361</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/img/image-20230405162626-56eqgtb.png" alt=""></p> <p>从图上可以看到, 有个叫 &quot;scheduling-1&quot; 的线程占用了较多的 CPU, 达到了 42.5%. 因此下一步要找出这个线程在做什么事情.</p> <p>(5) 为了找出线程在做什么事情, 需要用 jstack 命令生成线程快照, 具体方法是:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>jstack 4361
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>jstack 的输出比较大, 可以将输出写入文件:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>jstack 4361 &gt; 4361.log
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>然后打开 4361.log, 定位到第 4 步中找到的名为 &quot;scheduling-1&quot; 的线程, 发现它的线程栈如下:</p> <p><img src="/img/image-20230405162626-g49iue1.png" alt=""></p> <p>从线程栈中看到了 <code>AbstractExecutorService.submit</code>​ 这个函数调用, 说明它是 Spring Boot 启动的<strong>周期性</strong>任务线程, 向线程池中提交任务, 这个线程消耗了大量 CPU.</p> <h5 id="进一步分析上下文切换开销"><a href="#进一步分析上下文切换开销" class="header-anchor">#</a> 进一步分析上下文切换开销</h5> <p>一般来说, 通过上面的过程就能定位到大量消耗 CPU 的线程以及有问题的代码, 比如死循环. 但是对于这个实例的问题, 可以发现这样一个情况: Java 进程占用的 CPU 是 262.3%,  而 &quot;scheduling-1&quot; 线程只占用了 42.5% 的 CPU, 那还有将近 220% 的 CPU 被谁占用了呢?</p> <p>前面在第 4 步用 <code>top -H -p 4361</code>​ 命令看到的线程列表中还有许多名为 &quot;pool-1-thread-x&quot; 的线程, 它们单个的 CPU 使用率不高, 但是似乎<strong>数量比较多</strong>. 其实这些就是线程池中干活的线程. 那剩下的 220% 的 CPU 是不是被这些线程消耗了呢?</p> <p>要弄清楚这个问题, 还需要看 jstack 的输出结果, 主要是看这些线程池中的线程是不是真的在干活, 还是在&quot;休息&quot;呢?</p> <p><img src="/img/image-20230405162626-it84tut.png" alt=""></p> <p>通过上面的图可以发现这些 &quot;pool-1-thread-x&quot; 线程<strong>基本都处于 WAITING 的状态</strong>, 那什么是 WAITING 状态呢? 或者说 Java 线程都有哪些状态呢? 可以通过下面的图来理解一下:</p> <p><img src="/img/image-20230405162626-r87lrn9.png" alt=""></p> <p>从图上看到&quot;Blocking&quot;和&quot;Waiting&quot;是两个不同的状态, 要注意它们的区别:</p> <ul><li>Blocking 指的是一个线程因为等待临界区的锁(Lock 或者 synchronized 关键字)而被阻塞的状态, 需要注意处于这个状态的线程**还没有拿到锁. **</li> <li>Waiting 指的是一个线程<strong>拿到了锁</strong>, 但是需要等待其他线程执行某些操作. 比如调用了 Object.wait(), Thread.join() 或者 LockSupport.park() 方法时, 进入 Waiting 状态. <strong>前提是这个线程已经拿到锁了</strong>, 并且在进入 Waiting 状态前, 操作系统层面会自动释放锁, 当等待条件满足, 外部调用了 Object.notify() 或者 LockSupport.unpark() 方法, 线程会重新竞争锁, 成功获得锁后才能进入到 Runnable 状态继续执行.</li></ul> <p>回到 &quot;pool-1-thread-x&quot; 线程, 这些线程都处在 &quot;Waiting&quot; 状态, 从线程栈可以看到, 这些线程 &quot;等待&quot; 在 getTask() 方法调用上, <strong>线程尝试从线程池的队列中取任务</strong>, 但是队列为空, 所以通过 LockSupport.park() 调用进到了 &quot;Waiting&quot; 状态. 那 &quot;pool-1-thread-x&quot; 线程有多少个呢? 通过下面这个命令来统计一下, 结果是 4096, 正好跟线程池中的线程数相等.</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># grep -o 'pool-1-thread' 4361.log | wc -l</span>
<span class="token number">4096</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>回到前面, 那剩下的 220% 的 CPU 到底被谁消耗了呢? 分析到这里, 应该怀疑 <strong>CPU 的上下文切换开销了</strong>, 可以看到 Java 进程中的线程数比较多. 下面通过 vmstat 命令来查看一下操作系统层面的<strong>线程上下文切换活动</strong>:</p> <p><img src="/img/image-20230405162626-l8yho7i.png" alt=""></p> <p>其中 <strong>cs 那一栏表示线程上下文切换次数, in 表示 CPU 中断次数</strong>, 可以发现这两个数字非常高, 基本证实了猜测, 线程上下文切切换消耗了大量 CPU. 那么问题来了, 具体是哪个进程导致的呢?</p> <p>停止 Spring Boot 测试程序, 再次运行 vmstat 命令, 会看到 in 和 cs 都大幅下降了, 这样就证实了引起线程上下文切换开销的 Java 进程正是 <strong>4361</strong>.</p> <p><img src="/img/image-20230405162626-6ki4o8h.png" alt=""></p> <h5 id="总结-19"><a href="#总结-19" class="header-anchor">#</a> 总结</h5> <p>当遇到 CPU 过高的问题时, 首先要定位是哪个进程的导致的, 之后可以通过 <code>top -H -p pid</code>​ 命令定位到具体的线程. 其次还要通 jstack 查看线程的状态, 看看线程的个数或者线程的状态, 如果线程数过多, 可以怀疑是线程上下文切换的开销, 可以通过 vmstat 和 pidstat 这两个工具进行确认.</p> <h4 id="_41-热点答疑-4-tomcat和jetty有哪些不同"><a href="#_41-热点答疑-4-tomcat和jetty有哪些不同" class="header-anchor">#</a> 41.热点答疑(4):Tomcat和Jetty有哪些不同?</h4> <p>这里总结一下 Tomcat 和 Jetty 的区别, 并通过一个实战案例来比较一下 Tomcat 和 Jetty 在实际场景下的表现, 帮你在做选型时有更深的理解.</p> <p>先来概括一下 Tomcat 和 Jetty 两者最大的区别. 大体来说, Tomcat 的核心竞争力是<strong>成熟稳定</strong>, 因为它经过了多年的市场考验, 应用也相当广泛, 对于比较复杂的企业级应用支持得更加全面. 也因为如此, Tomcat 在整体结构上比 Jetty 更加复杂, 功能扩展方面可能不如 Jetty 那么方便.</p> <p>而 Jetty 比较年轻, 设计上更加<strong>简洁小巧</strong>, 配置也比较简单, 功能也支持方便地扩展和裁剪, 比如可以把 Jetty 的 SessionHandler 去掉, 以节省内存资源, 因此 Jetty 还可以运行在小型的嵌入式设备中, 比如手机和机顶盒. 当然, 也可以自己开发一个 Handler, 加入 Handler 链中用来扩展 Jetty 的功能. 值得一提的是, Hadoop 和 Solr 都嵌入了 Jetty 作为 Web 服务器.</p> <p>从设计的角度来看, Tomcat 的架构基于一种<strong>多级容器的模式</strong>, 这些容器组件具有父子关系, 所有组件依附于这个骨架, 而且这个骨架是不变的, 在扩展 Tomcat 的功能时也需要基于这个骨架, 因此 Tomcat 在设计上相对来说比较复杂. 当然 Tomcat 也提供了较好的扩展机制, 比如可以自定义一个 Valve, 但相对来说学习成本还是比较大的. 而 Jetty 采用 Handler <strong>责任链模式</strong>. 由于 Handler 之间的关系比较松散, Jetty 提供 HandlerCollection 可以帮助开发者方便地构建一个 Handler 链, 同时也提供了 ScopeHandler 帮助开发者控制 Handler 链的访问顺序.</p> <p>说了一堆理论, 你可能觉得还是有点抽象, 接下来通过一个实例, 来压测一下 Tomcat 和 Jetty, 看看在同等流量压力下, Tomcat 和 Jetty 分别在吞吐量, 延迟和错误率的表现如何.</p> <p>测试的计划是这样的, 这里用 IO 与并发调优小节的 Spring Boot 应用程序. 首先用 Spring Boot 默认的 Tomcat 作为内嵌式 Web 容器, 经过一轮压测后, 将内嵌式的 Web 容器换成 Jetty, 再做一轮测试, 然后比较结果.</p> <p>这里会在每个请求的处理过程中休眠 1 秒, 适当地模拟 Web 应用的 I/O 等待时间. JMeter 客户端的线程数为 100, 压测持续 10 分钟. 在 JMeter 中创建一个 Summary Report, 在这个页面上, 可以看到各种统计指标.</p> <p><img src="/img/image-20230405164102-i23825n.png" alt=""></p> <p>第一步, 压测 Tomcat. 启动 Spring Boot 程序和 JMeter, 持续 10 分钟, 以下是测试结果, 结果分为两部分:</p> <p><strong>吞吐量, 延迟和错误率</strong></p> <p><img src="/img/image-20230405164102-sbluqm6.png" alt=""></p> <p><strong>资源使用情况</strong></p> <p><img src="/img/image-20230405164102-okyeyfz.png" alt=""></p> <p>第二步, 将 Spring Boot 的 Web 容器替换成 Jetty, 具体步骤是在 pom.xml 文件中的 spring-boot-starter-web 依赖修改下面这样:</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-tomcat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-jetty<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>编译打包, 启动 Spring Boot, 再启动 JMeter 压测, 以下是测试结果:</p> <p><strong>吞吐量, 延迟和错误率</strong></p> <p><img src="/img/image-20230405164102-jp640x6.png" alt=""></p> <p><strong>资源使用情况</strong></p> <p><img src="/img/image-20230405164102-pnofrdr.png" alt=""></p> <p>下面通过一个表格来对比 Tomcat 和 Jetty:</p> <p><img src="/img/image-20230405164102-6beqtux.jpg" alt=""></p> <p>从表格中的数据可以看到:</p> <ul><li>**Jetty 在吞吐量和响应速度方面稍有优势, 并且 Jetty 消耗的线程和内存资源明显比 Tomcat 要少, 这也恰好说明了 Jetty 在设计上更加小巧和轻量级的特点. **</li> <li>**但是 Jetty 有 2.45% 的错误率, 而 Tomcat 没有任何错误, 并且经过多次测试都是这个结果. 因此可以认为 Tomcat 比 Jetty 更加成熟和稳定. **</li></ul> <p>当然由于测试场景的限制, 以上数据并不能完全反映 Tomcat 和 Jetty 的真实能力. 但是它可以在做实际选型的时候提供一些参考: <strong>如果系统的目标是资源消耗尽量少, 并且对稳定性要求没有那么高, 可以选择轻量级的 Jetty; 如果系统是比较关键的企业级应用, 建议还是选择 Tomcat 比较稳妥</strong>.</p> <p>最后用一句话总结 Tomcat 和 Jetty 的区别: **Tomcat 好比是一位工作多年比较成熟的工程师, 轻易不会出错, 不会掉链子, 但是他有自己的想法, 不会轻易做出改变. 而 Jetty 更像是一位年轻的后起之秀, 脑子转得很快, 可塑性也很强, 但有时候也会犯一点小错误. **</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/30.系统/3000.系统/150.系统接入层/200.深入拆解Tomcat与Jetty(极客时间)🌸.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/f1b6c4/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Nginx基础</div></a> <a href="/pages/baee2f/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Netty</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/f1b6c4/" class="prev">Nginx基础</a></span> <span class="next"><a href="/pages/baee2f/">Netty</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/165.65444686.js" defer></script>
  </body>
</html>
