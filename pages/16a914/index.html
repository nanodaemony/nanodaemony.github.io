<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>类文件结构🌼 | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/82.e96ff6d7.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/4f30b9/" class="sidebar-link">Java基础</a></li><li><a href="/pages/795eca/" class="sidebar-link">类与继承</a></li><li><a href="/pages/c69152/" class="sidebar-link">抽象类与接口</a></li><li><a href="/pages/d71abb/" class="sidebar-link">内部类</a></li><li><a href="/pages/f06dca/" class="sidebar-link">枚举类</a></li><li><a href="/pages/259f57/" class="sidebar-link">常用类</a></li><li><a href="/pages/84b03b/" class="sidebar-link">关键字</a></li><li><a href="/pages/31b87b/" class="sidebar-link">注解</a></li><li><a href="/pages/f81c0d/" class="sidebar-link">异常</a></li><li><a href="/pages/ae7746/" class="sidebar-link">泛型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>容器类</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/0c88ac/" class="sidebar-link">集合容器类基础</a></li><li><a href="/pages/f805ed/" class="sidebar-link">List与Queue类</a></li><li><a href="/pages/d24b60/" class="sidebar-link">Map与Set类</a></li><li><a href="/pages/54e5d3/" class="sidebar-link">并发容器类</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/67d70f/" class="sidebar-link">多线程基础</a></li><li><a href="/pages/ffc8f7/" class="sidebar-link">Java内置锁</a></li><li><a href="/pages/c43494/" class="sidebar-link">AQS</a></li><li><a href="/pages/eb5b61/" class="sidebar-link">显式锁ReentrantLock</a></li><li><a href="/pages/eb8cbc/" class="sidebar-link">线程协作与JUC组件</a></li><li><a href="/pages/23c79a/" class="sidebar-link">Atomic原子变量与Unsafe类与CAS</a></li><li><a href="/pages/9d6ed4/" class="sidebar-link">线程池与定时任务</a></li><li><a href="/pages/5b787a/" class="sidebar-link">ThreadLocal</a></li><li><a href="/pages/db53d1/" class="sidebar-link">Java并发编程实战(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>IO</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b4d461/" class="sidebar-link">文件操作</a></li><li><a href="/pages/1b9d6c/" class="sidebar-link">IO流操作</a></li><li><a href="/pages/076a47/" class="sidebar-link">Java网络IO模型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>高级特性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d76905/" class="sidebar-link">Lambda表达式</a></li><li><a href="/pages/f7f0e6/" class="sidebar-link">流Stream</a></li><li><a href="/pages/7cc40a/" class="sidebar-link">反射</a></li><li><a href="/pages/945326/" class="sidebar-link">代理</a></li><li><a href="/pages/7fd9b4/" class="sidebar-link">Javaagent</a></li><li><a href="/pages/a3cee0/" class="sidebar-link">Guava</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>JVM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d308f6/" class="sidebar-link">走进JVM🌼</a></li><li><a href="/pages/be0269/" class="sidebar-link">JVM内存区域与对象解析🌼</a></li><li><a href="/pages/48d1be/" class="sidebar-link">垃圾收集器与内存分配策略🌼</a></li><li><a href="/pages/3a4c8a/" class="sidebar-link">JVM性能监控与故障处理工具🌼</a></li><li><a href="/pages/106680/" class="sidebar-link">调优案例分析与实战🌼</a></li><li><a href="/pages/16a914/" aria-current="page" class="active sidebar-link">类文件结构🌼</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/ea287c/" class="sidebar-link">虚拟机类加载机制🌼</a></li><li><a href="/pages/6367b0/" class="sidebar-link">虚拟机字节码执行引擎🌼</a></li><li><a href="/pages/c6c210/" class="sidebar-link">类加载及执行子系统的案例与实战🌼</a></li><li><a href="/pages/deb8b7/" class="sidebar-link">前端编译与优化🌼</a></li><li><a href="/pages/1f8f72/" class="sidebar-link">后端编译与优化🌼</a></li><li><a href="/pages/3d72db/" class="sidebar-link">Java内存模型与线程实现🌼</a></li><li><a href="/pages/ed086e/" class="sidebar-link">线程安全与内置锁优化🌼</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/56b9dd/" class="sidebar-link">Java性能问题定位分析</a></li><li><a href="/pages/939bf8/" class="sidebar-link">杂记</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>开发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>软件设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/a5f6fe/" class="sidebar-link">设计基础理论</a></li><li><a href="/pages/3b245c/" class="sidebar-link">设计模式之美(极客时间)🌟</a></li><li><a href="/pages/661fa4/" class="sidebar-link">领域驱动设计(DDD)</a></li><li><a href="/pages/856368/" class="sidebar-link">DDD实战课(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d3fbd2/" class="sidebar-link">数据库基础</a></li><li><a href="/pages/691fc3/" class="sidebar-link">数据库系统原理</a></li><li><a href="/pages/50f6b7/" class="sidebar-link">MySQL基础必知必会</a></li><li><a href="/pages/fe297e/" class="sidebar-link">MySQL特性</a></li><li><a href="/pages/07bdb6/" class="sidebar-link">MySQL索引🌟</a></li><li><a href="/pages/984715/" class="sidebar-link">MySQL锁🌟</a></li><li><a href="/pages/53b588/" class="sidebar-link">MySQL事务🌟</a></li><li><a href="/pages/becc59/" class="sidebar-link">MySQL高级特性</a></li><li><a href="/pages/056463/" class="sidebar-link">MySQL基础架构与存储引擎🌟</a></li><li><a href="/pages/63b46e/" class="sidebar-link">MySQL架构优化与运维</a></li><li><a href="/pages/9995e5/" class="sidebar-link">MySQL优化</a></li><li><a href="/pages/c1c2f6/" class="sidebar-link">MySQL架构</a></li><li><a href="/pages/8e8e0a/" class="sidebar-link">MySQL设计规范</a></li><li><a href="/pages/0219aa/" class="sidebar-link">MySQL运维</a></li><li><a href="/pages/e288c0/" class="sidebar-link">MySQL中间件</a></li><li><a href="/pages/c6cafa/" class="sidebar-link">MySQL实战45讲(极客时间)🌟</a></li><li><a href="/pages/4a6106/" class="sidebar-link">数据库LeetCode题目</a></li><li><a href="/pages/2827f1/" class="sidebar-link">数据库综合问题</a></li><li><a href="/pages/c616d5/" class="sidebar-link">MongoDB</a></li><li><a href="/pages/075e71/" class="sidebar-link">ClickHouse</a></li><li><a href="/pages/d74f6d/" class="sidebar-link">Doris</a></li><li><a href="/pages/b6bad9/" class="sidebar-link">HBase</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Spring</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bd8eb8/" class="sidebar-link">Spring Boot基础</a></li><li><a href="/pages/d0d797/" class="sidebar-link">Spring Boot应用整合</a></li><li><a href="/pages/314cdc/" class="sidebar-link">Spring MVC基础</a></li><li><a href="/pages/80de47/" class="sidebar-link">Spring AOP基础</a></li><li><a href="/pages/f0d4d6/" class="sidebar-link">Spring事务基础</a></li><li><a href="/pages/db6afe/" class="sidebar-link">Spring IOC源码分析-概览</a></li><li><a href="/pages/672e98/" class="sidebar-link">Spring IOC源码分析-getBean()</a></li><li><a href="/pages/695b90/" class="sidebar-link">Spring IOC源码分析-createBean()</a></li><li><a href="/pages/f89bcf/" class="sidebar-link">Spring AOP源码分析</a></li><li><a href="/pages/3b52f4/" class="sidebar-link">Spring事务源码分析</a></li><li><a href="/pages/186902/" class="sidebar-link">Spring Boot源码分析</a></li><li><a href="/pages/16bd1c/" class="sidebar-link">Spring MVC源码分析</a></li><li><a href="/pages/3d0c1f/" class="sidebar-link">Spring Cloud</a></li><li><a href="/pages/d56156/" class="sidebar-link">Spring编程常见错误50例(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>MyBatis</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bb032d/" class="sidebar-link">基础</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>工具与环境</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c9cb6e/" class="sidebar-link">Arthas</a></li><li><a href="/pages/3172bb/" class="sidebar-link">Maven</a></li><li><a href="/pages/37f79a/" class="sidebar-link">Git</a></li><li><a href="/pages/db9f99/" class="sidebar-link">环境搭建与部署</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c725f5/" class="sidebar-link">测试基础</a></li><li><a href="/pages/7893a4/" class="sidebar-link">单元测试</a></li><li><a href="/pages/af9f25/" class="sidebar-link">压力测试</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>代码质量</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ec2b81/" class="sidebar-link">代码整洁之道</a></li><li><a href="/pages/474cdf/" class="sidebar-link">阿里巴巴编程规范</a></li><li><a href="/pages/c47e15/" class="sidebar-link">代码之丑(极客时间)🌸</a></li><li><a href="/pages/4d4606/" class="sidebar-link">Java业务开发常见错误100例(极客时间)🌸</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/develop/#开发" data-v-06970110>开发</a></li><li data-v-06970110><a href="/develop/#Java" data-v-06970110>Java</a></li><li data-v-06970110><a href="/develop/#JVM" data-v-06970110>JVM</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">类文件结构🌼<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_30-类文件结构🌼"><a href="#_30-类文件结构🌼" class="header-anchor">#</a> 30.类文件结构🌼</h1> <p>本节对应《深入理解 Java 虚拟机》的第六章</p> <p>代码编译的结果从本地机器码转变为字节码, 是存储格式发展的一小步, 却是编程语言发展的一大步.</p> <p>由于最近十年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展, 把程序编译成二进制本地机器码(Native Code)已不再是唯一的选择, 越来越多的<strong>程序语言选择了与操作系统和机器指令集无关的, 平台中立的格式作为程序编译后的存储格式</strong>.</p> <h4 id="平台无关性"><a href="#平台无关性" class="header-anchor">#</a> 平台无关性</h4> <p>各种不同平台的虚拟机与所有平台都使用统一的程序存储格式: <mark><strong>字节码</strong></mark>, 这是构成<strong>平台无关性的基石</strong>.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521185338069.png" alt=""></p> <p>虚拟机的另外一种中立特性, 即<mark><strong>语言无关性</strong></mark>正在越来越被开发者所重视. 实现语言无关性的基础仍然是<strong>虚拟机和字节码的存储格式</strong>. 把代码编译成 Class 文件, 虚拟机并不关心 Class 的来源是何种语言.</p> <p><strong>Java 语言中的各种语法, 关键字, 常量变量和运算符号的语义最终都会由多条字节码指令组合来表达, 这决定了字节码指令所能提供的语言描述能力必须比 Java 语言本身更加强大才行</strong>. 因此, 有一些 Java 语言本身无法有效支持的语言特性并不代表在字节码中也无法有效表达出来, 这为其他程序语言实现一些有别于 Java 的语言特性提供了发挥空间.</p> <h4 id="class类文件结构"><a href="#class类文件结构" class="header-anchor">#</a> Class类文件结构</h4> <p>解析 Class 文件的数据结构是本章的最主要内容. 笔者曾经在前言中阐述过本书的写作风格: 力求在保证逻辑准确的前提下, 用尽量通俗的语言和案例去讲述虚拟机中与开发关系最为密切的内容. 但是, 对<strong>文件格式, 结构</strong>方面的学习, 有点类似于 &quot;读字典&quot;, 读者阅读本章时, 大概会不可避免地感到比较枯燥, 但这部分内容又是 Java 虚拟机的重要基础之一, 是了解虚拟机的必经之路, 如果想比较深入地学习虚拟机相关知识, 这部分是无法回避的.</p> <p>Java 技术能够一直保持着非常良好的向后兼容性, Class 文件结构的稳定功不可没, 任何一门程序语言能够获得商业上的成功, 都不可能去做升级版本后, 旧版本编译的产品就不再能够运行这种事情. <strong>本章所讲述的关于 Class 文件结构的内容, 绝大部分都是在第一版的《Java 虚拟机规范》中就已经定义好的, 内容虽然古老, 但时至今日, Java 发展经历了十余个大版本, 无数小更新, 那时定义的 Class 文件格式的各项细节几乎没有出现任何改变</strong>. 尽管不同版本的《Java 虚拟机规范》对 Class 文件格式进行了几次更新, 但基本上只是在原有结构基础上新增内容, 扩充功能, 并未对已定义的内容做出修改.</p> <p>注意: <strong>任何一个 Class 文件都对应着唯一的一个类或接口的定义信息, 但是反过来说, 类或接口并不一定都得定义在文件里(譬如类或接口也可以动态生成, 直接送入类加载器中)</strong> . 本章中, 笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为 &quot;Class 文件格式&quot;, 实际上它完全不需要以磁盘文件的形式存在.</p> <p><strong>Class 文件是一组以 8 个字节为基础单位的二进制流</strong>, 各个数据项目严格按照顺序紧凑地排列在文件之中, 中间没有添加任何分隔符, 这使得整个 Class 文件中存储的内容几乎全部是程序运行的必要数据, 没有空隙存在. 当遇到需要占用 8 个字节以上空间的数据项时, 则会按照高位在前的方式分割成若干个 8 个字节进行存储.</p> <p>根据《Java 虚拟机规范》的规定, <strong>Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据, 这种伪结构中只有两种数据类型:</strong> <mark><strong>&quot;无符号数&quot; 和 &quot;表&quot;</strong></mark> . 后面的解析都要以这两种数据类型为基础, 所以这里必须先解释清楚这两个概念.</p> <ul><li><mark><strong>无符号数属于基本的数据类型</strong></mark>, 以 u1, u2, u4, u8 来分别代表 1 个字节, 2 个字节, 4 个字节和 8 个字节的无符号数, 无符号数可以用来<strong>描述数字, 索引引用, 数量值或者按照 UTF-8 编码构成字符串值</strong>.</li> <li><mark><strong>表是由多个无符号数或者其他表作为数据项构成的复合数据类型</strong></mark>, 为了便于区分, 所有表的命名都习惯性地以 &quot;_info&quot; 结尾. 表用于描述有层次关系的复合结构的数据, 整个 Class 文件<strong>本质上也可以视作是一张表</strong>, 这张表由如下所示的数据项按严格顺序排列构成.</li></ul> <blockquote><p>Class文件表格式</p></blockquote> <p><img src="/img/Image00112-20240302133505-inljtxr.jpg" alt=""></p> <p>在代码表示上, 类文件由单个 <strong>ClassFile 结构</strong>组成(与上表一致):</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>ClassFile <span class="token punctuation">{</span>
    u4             magic<span class="token punctuation">;</span> <span class="token comment">// Class 文件的标志</span>
    u2             minor_version<span class="token punctuation">;</span><span class="token comment">// Class 的小版本号</span>
    u2             major_version<span class="token punctuation">;</span><span class="token comment">// Class 的大版本号</span>
    u2             constant_pool_count<span class="token punctuation">;</span><span class="token comment">// 常量池的数量</span>
    cp_info        constant_pool<span class="token punctuation">[</span>constant_pool_count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 常量池</span>
    u2             access_flags<span class="token punctuation">;</span><span class="token comment">// Class 的访问标记</span>
    u2             this_class<span class="token punctuation">;</span><span class="token comment">// 当前类</span>
    u2             super_class<span class="token punctuation">;</span><span class="token comment">// 父类</span>
    u2             interfaces_count<span class="token punctuation">;</span><span class="token comment">// 接口</span>
    u2             interfaces<span class="token punctuation">[</span>interfaces_count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 一个类可以实现多个接口</span>
    u2             fields_count<span class="token punctuation">;</span><span class="token comment">// Class 文件的字段属性</span>
    field_info     fields<span class="token punctuation">[</span>fields_count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 一个类会可以有个字段</span>
    u2             methods_count<span class="token punctuation">;</span><span class="token comment">// Class 文件的方法数量</span>
    method_info    methods<span class="token punctuation">[</span>methods_count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 一个类可以有个多个方法</span>
    u2             attributes_count<span class="token punctuation">;</span><span class="token comment">// 此类的属性表中的属性数</span>
    attribute_info attributes<span class="token punctuation">[</span>attributes_count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 属性表集合</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p><strong>Class 文件字节码结构组织示意图</strong>:</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20200329201337586.png" alt="image-20200329201337586"></p> <p>无论是无符号数还是表, 当需要<strong>描述同一类型但数量不定的多个数据</strong>时, 经常会使用一个前置的容量计数器加若干个连续的数据项的形式, 这时候称这一系列连续的某一类型的数据为某一类型的 &quot;<strong>集合</strong>&quot;.</p> <p>本节结束之前, 笔者需要再强调一次, Class 的结构不像 XML 等描述语言, 由于它<strong>没有任何分隔符号</strong>, 所以在表中的数据项, 无论是顺序还是数量, 甚至于数据存储的字节序(Byte Ordering, Class 文件中字节序为 Big-Endian)这样的细节, 都是被严格限定的, <strong>哪个字节代表什么含义, 长度是多少, 先后顺序如何, 全部都不允许改变</strong>.</p> <blockquote><p>class文件结构示例</p></blockquote> <p>这里将下面 Java 文件通过 javac 编译为  <strong>.class</strong> 文件:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> finalnum <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> check<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        check <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>class 文件</strong>对应的<strong>字节流码</strong>:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>cafe babe <span class="token number">0000</span> <span class="token number">0034</span> <span class="token number">0018</span> <span class="token number">0</span>a00 <span class="token number">0500</span> <span class="token number">1309</span>
<span class="token number">0004</span> <span class="token number">0014</span> <span class="token number">0900</span> <span class="token number">0400</span> <span class="token number">1507</span> <span class="token number">0016</span> <span class="token number">0700</span> <span class="token number">1701</span>
<span class="token number">0003</span> <span class="token number">6e75</span> <span class="token number">6d</span><span class="token number">01</span> <span class="token number">0001</span> <span class="token number">4901</span> <span class="token number">0008</span> <span class="token number">6669</span> <span class="token number">6e61</span>
<span class="token number">6</span>c6e <span class="token number">756d</span> <span class="token number">0100</span> <span class="token number">0d</span><span class="token number">43</span> <span class="token number">6f</span><span class="token number">6</span>e <span class="token number">7374</span> <span class="token number">616</span>e <span class="token number">7456</span>
<span class="token number">616</span>c <span class="token number">7565</span> <span class="token number">0300</span> <span class="token number">0000</span> <span class="token number">0301</span> <span class="token number">0005</span> <span class="token number">6368</span> <span class="token number">6563</span>
<span class="token number">6</span>b01 <span class="token number">0006</span> <span class="token number">3</span>c69 <span class="token number">6e69</span> <span class="token number">743</span>e <span class="token number">0100</span> <span class="token number">0328</span> <span class="token number">2956</span>
<span class="token number">0100</span> <span class="token number">0443</span> <span class="token number">6f</span><span class="token number">64</span> <span class="token number">6501</span> <span class="token number">000f</span> <span class="token number">4</span>c69 <span class="token number">6e65</span> <span class="token number">4e75</span>
<span class="token number">6d</span><span class="token number">62</span> <span class="token number">6572</span> <span class="token number">5461</span> <span class="token number">626</span>c <span class="token number">6501</span> <span class="token number">0008</span> <span class="token number">3</span>c63 <span class="token number">6</span>c69
<span class="token number">6e69</span> <span class="token number">743</span>e <span class="token number">0100</span> <span class="token number">0</span>a53 <span class="token number">6f</span><span class="token number">75</span> <span class="token number">7263</span> <span class="token number">6546</span> <span class="token number">696</span>c
<span class="token number">6501</span> <span class="token number">0009</span> <span class="token number">5465</span> <span class="token number">7374</span> <span class="token number">2e6</span>a <span class="token number">6176</span> <span class="token number">610</span>c <span class="token number">000</span>c
<span class="token number">000d</span> <span class="token number">0</span>c00 <span class="token number">0b00</span> <span class="token number">070</span>c <span class="token number">0006</span> <span class="token number">0007</span> <span class="token number">0100</span> <span class="token number">0454</span>
<span class="token number">6573</span> <span class="token number">7401</span> <span class="token number">0010</span> <span class="token number">6</span>a61 <span class="token number">7661</span> <span class="token number">2f</span><span class="token number">6</span>c <span class="token number">616</span>e <span class="token number">672f</span>
<span class="token number">4f</span><span class="token number">62</span> <span class="token number">6</span>a65 <span class="token number">6374</span> <span class="token number">0021</span> <span class="token number">0004</span> <span class="token number">0005</span> <span class="token number">0000</span> <span class="token number">0003</span>
<span class="token number">000</span>a <span class="token number">0006</span> <span class="token number">0007</span> <span class="token number">0000</span> <span class="token number">001</span>a <span class="token number">0008</span> <span class="token number">0007</span> <span class="token number">0001</span>
<span class="token number">0009</span> <span class="token number">0000</span> <span class="token number">0002</span> <span class="token number">000</span>a <span class="token number">0002</span> <span class="token number">000</span>b <span class="token number">0007</span> <span class="token number">0000</span>
<span class="token number">0002</span> <span class="token number">0001</span> <span class="token number">000</span>c <span class="token number">000d</span> <span class="token number">0001</span> <span class="token number">000</span>e <span class="token number">0000</span> <span class="token number">002</span>b
<span class="token number">0002</span> <span class="token number">0001</span> <span class="token number">0000</span> <span class="token number">000</span>b <span class="token number">2</span>ab7 <span class="token number">0001</span> <span class="token number">2</span>a10 <span class="token number">17</span>b5
<span class="token number">0002</span> b100 <span class="token number">0000</span> <span class="token number">0100</span> <span class="token number">0f</span><span class="token number">00</span> <span class="token number">0000</span> <span class="token number">0e00</span> <span class="token number">0300</span>
<span class="token number">0000</span> <span class="token number">0500</span> <span class="token number">0400</span> <span class="token number">0600</span> <span class="token number">0</span>a00 <span class="token number">0700</span> <span class="token number">0800</span> <span class="token number">1000</span>
<span class="token number">0d</span><span class="token number">00</span> <span class="token number">0100</span> <span class="token number">0e00</span> <span class="token number">0000</span> <span class="token number">1d</span><span class="token number">00</span> <span class="token number">0100</span> <span class="token number">0000</span> <span class="token number">0000</span>
<span class="token number">0506</span> b300 <span class="token number">03</span>b1 <span class="token number">0000</span> <span class="token number">0001</span> <span class="token number">000f</span> <span class="token number">0000</span> <span class="token number">0006</span>
<span class="token number">0001</span> <span class="token number">0000</span> <span class="token number">0002</span> <span class="token number">0001</span> <span class="token number">0011</span> <span class="token number">0000</span> <span class="token number">0002</span> <span class="token number">0012</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h5 id="_1-魔数与主次版本号"><a href="#_1-魔数与主次版本号" class="header-anchor">#</a> 1.魔数与主次版本号</h5> <blockquote><p>魔数</p></blockquote> <p>可以看到第一个字符为 u4 类型的 <strong>magic</strong> 变量, 称之为<strong>魔数</strong>, 该变量来表明是否是一个虚拟机能接受的 <strong>Class 文件</strong>. 上面的 Class 字节流显示 4 个字节 magic 是 &quot;0xcafe babe&quot;.</p> <blockquote><p>主次版本号</p></blockquote> <p>紧接着魔数的 4 个字节存储的是 <strong>Class 文件的版本号</strong>: 第 5 和第 6 个字节是<strong>次版本号</strong>(Minor Version), 第 7 和第 8 个字节是<strong>主版本号</strong>(Major Version).</p> <p>Java 的版本号是从 45 开始的, JDK 1.1 之后的每个 JDK 大版本发布主版本号向上加 1(JDK 1.0～1.1使用了 45.0～45.3 的版本号), 高版本的 JDK 能向下兼容以前版本的 Class 文件, 但不能运行以后版本的 Class 文件, 因为《Java 虚拟机规范》在 Class 文件校验部分明确要求了即使文件格式并未发生任何变化, <strong>虚拟机也必须拒绝执行超过其版本号的 Class 文件</strong>.</p> <p>例如, JDK 1.1 能支持版本号为 45.0～45.65535的 Class 文件, 无法执行版本号为 46.0 以上的 Class 文件, 而 JDK 1.2 则能支持 45.0～46.65535的 Class 文件. 目前最新的 JDK 版本为 13, 可生成的 Class 文件主版本号最大值为 57.0.</p> <blockquote><p>代码示例</p></blockquote> <p>为了讲解方便, 笔者准备了一段最简单的 Java 代码, 本章后面的内容都将以这段程序使用 JDK 6 编译输出的 Class 文件为基础来进行讲解, 建议读者不妨用较新版本的 JDK 跟随本章的实验流程自己动手测试一遍.</p> <blockquote><p>代码清单6-2 class文件分析示例代码</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>clazz</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> m<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>下图显示的是使用十六进制编辑器 WinHex 打开这个 Class 文件的结果, 可以清楚地看见开头 4 个字节的十六进制表示是 0xCAFEBABE, 代表次版本号的第 5 个和第 6 个字节值为 0x0000, 而主版本号的值为 0x0032, 也即是十进制的 50, 该版本号说明这个是可以被 JDK 6 或以上版本虚拟机执行的 Class 文件.</p> <p><img src="/img/Image00113-20240302133505-ipw9huw.jpg" alt="" title="Java Class 文件的结构"></p> <h5 id="_2-常量池"><a href="#_2-常量池" class="header-anchor">#</a> 2.常量池</h5> <p>紧接着<strong>主次版本号之后的是常量池入口, 常量池可以比喻为 Class 文件里的资源仓库, 它是 Class 文件结构中与其他项目关联最多的数据, 通常也是占用 Class 文件空间最大的数据项目之一, 另外, 它还是在 Class 文件中第一个出现的表类型数据项目</strong>.</p> <p>常量池在 class 文件中的结构如下:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>u2             constant_pool_count<span class="token punctuation">;</span><span class="token comment">// 常量池的数量</span>
cp_info        constant_pool<span class="token punctuation">[</span>constant_pool_count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 常量池</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>由于常量池中<strong>常量的数量是不固定</strong>的, 所以在常量池的入口需要放置一项 u2 类型的数据, 代表<strong>常量池容量计数值</strong>(constant_pool_count). 与 Java 中语言习惯不同, 这个容量计数是从 1 而不是 0 开始的, 如下图所示, 常量池容量(偏移地址: 0x00000008)为十六进制数 0x0016, 即十进制的 22, 这就代表常量池中<strong>有 21 项常量</strong>, 索引值范围为 1～21. 在 Class 文件格式规范制定之时, 设计者将第 0 项常量空出来是有特殊考虑的, 这样做的目的在于, 如果后面某些指向常量池的索引值的数据在特定情况下需要表达 &quot;不引用任何一个常量池项目&quot; 的含义, 可以把索引值设置为 0 来表示. Class 文件结构中只有常量池的容量计数是从 1 开始, 对于其他集合类型, 包括接口索引集合, 字段表集合, 方法表集合等的容量计数都与一般习惯相同, 是从 0 开始.</p> <p><img src="/img/Image00115-20240302133505-8dqtvn4.jpg" alt="" title="常量池结构"></p> <p><mark><strong>常量池中主要存放两大类常量: 字面量(Literal)和符号引用(Symbolic References)</strong></mark> .</p> <p><strong>字面量</strong>比较接近于 Java 语言层面的常量概念, 如文本字符串, 被声明为 final 的常量值等.</p> <p>而<strong>符号引用</strong>则属于<strong>编译原理</strong>方面的概念, 主要包括下面几类常量:</p> <ul><li>被模块导出或者开放的包</li> <li><strong>类和接口的全限定名</strong></li> <li><strong>字段的名称和描述符</strong></li> <li><strong>方法的名称和描述符</strong></li> <li><strong>方法句柄和方法类型</strong></li> <li>动态调用点和动态常量</li></ul> <p>Java 代码在进行 Javac 编译的时候, 并不像 C 和 C++ 那样有 &quot;连接&quot; 这一步骤, 而是在虚拟机<strong>加载 Class 文件的时候进行</strong>​<mark><strong>动态连接</strong></mark>(参考: 动态连接). 也就是说, <mark><strong>在 Class 文件中不会保存各个方法, 字段最终在内存中的布局信息, 这些字段, 方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址, 也就无法直接被虚拟机使用的. 当虚拟机做类加载时, 将会从常量池获得对应的符号引用, 再在类创建时或运行时解析, 翻译到具体的内存地址之中</strong></mark>.</p> <p><strong>常量池中每一项常量都是一个表</strong>, 截至 JDK 13, 常量表中分别有 17 种不同类型的常量. 这 17 类表都有一个共同的特点, 表结构起始的第一位是个 u1 类型的标志位(tag, 取值见下表中标志列), 代表着<strong>当前常量属于哪种常量类型</strong>. 17 种常量类型所代表的具体含义如下表所示.</p> <blockquote><p>表-常量池的项目类型</p></blockquote> <table><thead><tr><th style="text-align:center;">类型</th> <th style="text-align:center;">标志(tag)</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">CONSTANT_utf8_info</td> <td style="text-align:center;">1</td> <td style="text-align:center;">UTF-8 编码的字符串</td></tr> <tr><td style="text-align:center;">CONSTANT_Integer_info</td> <td style="text-align:center;">3</td> <td style="text-align:center;">整形字面量</td></tr> <tr><td style="text-align:center;">CONSTANT_Float_info</td> <td style="text-align:center;">4</td> <td style="text-align:center;">浮点型字面量</td></tr> <tr><td style="text-align:center;">CONSTANT_Long_info</td> <td style="text-align:center;">５</td> <td style="text-align:center;">长整型字面量</td></tr> <tr><td style="text-align:center;">CONSTANT_Double_info</td> <td style="text-align:center;">６</td> <td style="text-align:center;">双精度浮点型字面量</td></tr> <tr><td style="text-align:center;">CONSTANT_Class_info</td> <td style="text-align:center;">７</td> <td style="text-align:center;">类或接口的符号引用</td></tr> <tr><td style="text-align:center;">CONSTANT_String_info</td> <td style="text-align:center;">８</td> <td style="text-align:center;">字符串类型字面量</td></tr> <tr><td style="text-align:center;">CONSTANT_Fieldref_info</td> <td style="text-align:center;">９</td> <td style="text-align:center;">字段的符号引用</td></tr> <tr><td style="text-align:center;">CONSTANT_Methodref_info</td> <td style="text-align:center;">10</td> <td style="text-align:center;"><strong>类中方法的符号引用</strong></td></tr> <tr><td style="text-align:center;">CONSTANT_InterfaceMethodref_info</td> <td style="text-align:center;">11</td> <td style="text-align:center;">接口中方法的符号引用</td></tr> <tr><td style="text-align:center;">CONSTANT_NameAndType_info</td> <td style="text-align:center;">12</td> <td style="text-align:center;">字段或方法的符号引用</td></tr> <tr><td style="text-align:center;">CONSTANT_MothodType_info</td> <td style="text-align:center;">16</td> <td style="text-align:center;">标志方法类型</td></tr> <tr><td style="text-align:center;">CONSTANT_MethodHandle_info</td> <td style="text-align:center;">15</td> <td style="text-align:center;">表示方法句柄</td></tr> <tr><td style="text-align:center;">CONSTANT_InvokeDynamic_info</td> <td style="text-align:center;">18</td> <td style="text-align:center;">表示一个动态方法调用点</td></tr> <tr><td style="text-align:center;">CONSTANT_Dynamic_info</td> <td style="text-align:center;">17</td> <td style="text-align:center;">表示一个动态计算常量</td></tr> <tr><td style="text-align:center;">CONSTANT_Module_info</td> <td style="text-align:center;">19</td> <td style="text-align:center;">表示一个模块</td></tr> <tr><td style="text-align:center;">CONSTANT_Package_info</td> <td style="text-align:center;">20</td> <td style="text-align:center;">表示一个模块中开放或导出的包</td></tr></tbody></table> <p>之所以说常量池是最烦琐的数据, 是因为这 17 种常量类型各自有着<strong>完全独立的数据结构</strong>, 两两之间并没有什么共性和联系. 下面是 17 种常量项的结构定义总结.</p> <blockquote><p>表6-6 常量池中的17种数据类型的结构总表</p></blockquote> <p><img src="/img/Image00121-20240302133505-yjdikvg.jpg" alt=""></p> <p><img src="/img/Image00122-20240302133505-eh3byj9.jpg" alt=""></p> <p><img src="/img/Image00123-20240302133505-01xkr1q.jpg" alt=""></p> <p>在 JDK 的 bin 目录中, Oracle 公司已经准备好一个<strong>专门用于分析 Class 文件字节码的工具: javap</strong>. 下面代码清单中列出了使用 javap 工具的 -verbose 参数输出的 TestClass.class 文件字节码内容(为节省篇幅, 此清单中省略了常量池以外的信息). 笔者曾经提到过 Class 文件中还有很多数据项都要引用常量池中的常量, 建议读者不妨在本页做个记号, 因为下面代码清单 6-2 中的内容在后续的讲解之中会频繁使用到.</p> <blockquote><p>代码清单6-2 使用javap命令输出常量表</p></blockquote> <div class="language-c line-numbers-mode"><pre class="language-c"><code>C<span class="token operator">:</span>\<span class="token operator">&gt;</span> javap <span class="token operator">-</span>verbose TestClass
Compiled from <span class="token string">&quot;TestClass.java&quot;</span>
public class org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>clazz<span class="token punctuation">.</span>TestClass extends java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object
    SourceFile<span class="token operator">:</span> <span class="token string">&quot;TestClass.java&quot;</span>
    minor version<span class="token operator">:</span> <span class="token number">0</span>
    major version<span class="token operator">:</span> <span class="token number">50</span>
    Constant pool<span class="token operator">:</span>
<span class="token keyword">const</span> #<span class="token number">1</span> <span class="token operator">=</span> class        #<span class="token number">2</span><span class="token punctuation">;</span>     <span class="token comment">//  org/fenixsoft/clazz/TestClass</span>
<span class="token keyword">const</span> #<span class="token number">2</span> <span class="token operator">=</span> Asciz        org<span class="token operator">/</span>fenixsoft<span class="token operator">/</span>clazz<span class="token operator">/</span>TestClass<span class="token punctuation">;</span>
<span class="token keyword">const</span> #<span class="token number">3</span> <span class="token operator">=</span> class        #<span class="token number">4</span><span class="token punctuation">;</span>     <span class="token comment">//  java/lang/Object</span>
<span class="token keyword">const</span> #<span class="token number">4</span> <span class="token operator">=</span> Asciz        java<span class="token operator">/</span>lang<span class="token operator">/</span>Object<span class="token punctuation">;</span>
<span class="token keyword">const</span> #<span class="token number">5</span> <span class="token operator">=</span> Asciz        m<span class="token punctuation">;</span>
<span class="token keyword">const</span> #<span class="token number">6</span> <span class="token operator">=</span> Asciz        I<span class="token punctuation">;</span>
<span class="token keyword">const</span> #<span class="token number">7</span> <span class="token operator">=</span> Asciz        <span class="token operator">&lt;</span>init<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> #<span class="token number">8</span> <span class="token operator">=</span> <span class="token function">Asciz</span>        <span class="token punctuation">(</span><span class="token punctuation">)</span>V<span class="token punctuation">;</span>
<span class="token keyword">const</span> #<span class="token number">9</span> <span class="token operator">=</span> Asciz        Code<span class="token punctuation">;</span>
<span class="token keyword">const</span> #<span class="token number">10</span> <span class="token operator">=</span> Method      #<span class="token number">3.</span>#<span class="token number">11</span><span class="token punctuation">;</span> <span class="token comment">//  java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>
<span class="token keyword">const</span> #<span class="token number">11</span> <span class="token operator">=</span> NameAndType #<span class="token number">7</span><span class="token operator">:</span>#<span class="token number">8</span><span class="token punctuation">;</span><span class="token comment">//  &quot;&lt;init&gt;&quot;:()V</span>
<span class="token keyword">const</span> #<span class="token number">12</span> <span class="token operator">=</span> Asciz       LineNumberTable<span class="token punctuation">;</span>
<span class="token keyword">const</span> #<span class="token number">13</span> <span class="token operator">=</span> Asciz       LocalVariableTable<span class="token punctuation">;</span>
<span class="token keyword">const</span> #<span class="token number">14</span> <span class="token operator">=</span> Asciz       this<span class="token punctuation">;</span>
<span class="token keyword">const</span> #<span class="token number">15</span> <span class="token operator">=</span> Asciz       Lorg<span class="token operator">/</span>fenixsoft<span class="token operator">/</span>clazz<span class="token operator">/</span>TestClass<span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> #<span class="token number">16</span> <span class="token operator">=</span> Asciz       inc<span class="token punctuation">;</span>
<span class="token keyword">const</span> #<span class="token number">17</span> <span class="token operator">=</span> <span class="token function">Asciz</span>       <span class="token punctuation">(</span><span class="token punctuation">)</span>I<span class="token punctuation">;</span>
<span class="token keyword">const</span> #<span class="token number">18</span> <span class="token operator">=</span> Field       #<span class="token number">1.</span>#<span class="token number">19</span><span class="token punctuation">;</span> <span class="token comment">// org/fenixsoft/clazz/TestClass.m:I</span>
<span class="token keyword">const</span> #<span class="token number">19</span> <span class="token operator">=</span> NameAndType #<span class="token number">5</span><span class="token operator">:</span>#<span class="token number">6</span><span class="token punctuation">;</span>  <span class="token comment">// m:I</span>
<span class="token keyword">const</span> #<span class="token number">20</span> <span class="token operator">=</span> Asciz       SourceFile<span class="token punctuation">;</span>
<span class="token keyword">const</span> #<span class="token number">21</span> <span class="token operator">=</span> Asciz       TestClass<span class="token punctuation">.</span>java<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>从代码清单 6-2 中可以看到, 计算机已经把整个常量池的 21 项常量都计算了出来, 并且第 1, 2 项常量的计算结果与手工计算的结果完全一致. 仔细看一下会发现, 其中有些常量似乎从来没有在代码中出现过, 如 <code>&quot;I&quot;, &quot;V&quot;, &quot;&lt;init&gt;&quot;, &quot;LineNumberTable&quot;, &quot;LocalVariableTable&quot;</code>​ 等, 这些看起来在<strong>源代码中不存在的常量</strong>是哪里来的?</p> <p>这部分常量的确不来源于 Java 源代码, 它们都是<strong>编译器自动生成</strong>的, 会被后面即将讲到的字段表(field_info), 方法表(method_info), 属性表(attribute_info)所引用, 它们将会被<strong>用来描述一些不方便使用 &quot;固定字节&quot; 进行表达的内容</strong>, 譬如描述方法的返回值是什么, 有几个参数, 每个参数的类型是什么. 因为 Java 中的 &quot;类&quot; 是无穷无尽的, 无法通过简单的无符号数来描述一个方法用到了什么类, 因此在描述方法的这些信息时, 需要引用常量表中的符号引用进行表达. 这部分内容将在后面进一步详细阐述.</p> <h5 id="_3-访问标志"><a href="#_3-访问标志" class="header-anchor">#</a> 3.访问标志</h5> <p>在常量池结束之后, 紧接着的 <strong>2 个字节代表访问标志</strong>(access_flags), 这个标志用于识别一些类或者接口层次的访问信息, 包括:</p> <ul><li><strong>这个 Class 是类还是接口</strong></li> <li><strong>是否定义为 public 类型</strong></li> <li><strong>是否定义为 abstract 类型</strong></li> <li><strong>如果是类的话, 是否被声明为 final</strong></li> <li>...</li></ul> <p>具体的标志位以及标志的含义见表 6-7.</p> <blockquote><p>表6-7 访问标志</p></blockquote> <p><img src="/img/Image00124-20240302133505-0y4prnq.jpg" alt=""></p> <p>access_flags 中一共有 16 个标志位可以使用, 当前只定义了其中 9 个, 没有使用到的标志位要求一律为零. 以前面 TestClass 的代码为例, TestClass 是一个普通 Java 类, 不是接口, 枚举, 注解或者模块, 被 public 关键字修饰但没有被声明为 final 和 abstract, 并且它使用了 JDK 1.2 之后的编译器进行编译, 因此它的 ACC_PUBLIC, ACC_SUPER 标志应当为真, 而 ACC_FINAL, ACC_INTERFACE, ACC_ABSTRACT, ACC_SYNTHETIC, ACC_ANNOTATION, ACC_ENUM, ACC_MODULE 这七个标志应当为假, 因此它的 access_flags 的值应为: <code>0x0001|0x0020=0x0021</code>​. 从下图中看到, access_flags 标志(偏移地址: 0x000000EF)的确为 0x0021.</p> <p><img src="/img/Image00125-20240302133505-6a1hq5s.jpg" alt="" title="access_flags 标志"></p> <h5 id="_4-类索引-父类索引与接口索引集合"><a href="#_4-类索引-父类索引与接口索引集合" class="header-anchor">#</a> 4.类索引,父类索引与接口索引集合</h5> <p><strong>类索引(this_class)和父类索引(super_class)都是一个 u2 类型的数据, 而接口索引集合(interfaces)是一组 u2 类型的数据的集合, Class 文件中由这三项数据来确定该类型的</strong>​<mark><strong>继承关系</strong></mark>​ <strong>. 类索引用于确定这个类的全限定名, 父类索引用于确定这个类的父类的全限定名</strong>. 由于 Java 语言不允许多重继承, 所以<strong>父类索引</strong>只有一个, 除了 java.lang.Object 之外, 所有的 Java 类都有父类, 因此除了 java.lang.Object 外, 所有 Java 类的父类索引都不为 0. <strong>接口索引集合</strong>就用来描述这个类<strong>实现了哪些接口</strong>, 这些被实现的接口将按 implements 关键字(如果这个 Class 文件表示的是一个接口, 则应当是 extends 关键字)后的接口顺序从左到右排列在接口索引集合中.</p> <p><strong>类索引, 父类索引和接口索引集合都按顺序排列在访问标志之后</strong>, 类索引和父类索引用两个 u2 类型的索引值表示, 它们各自指向一个类型为 CONSTANT_Class_info 的类描述符常量, 通过 CONSTANT_Class_info 类型的常量中的索引值可以找到定义在 CONSTANT_Utf8_info 类型的常量中的全限定名字符串. 下图演示了代码 TestClass 中代码的类索引查找过程.</p> <p><img src="/img/Image00126-20240302133505-myls67k.jpg" alt="" title="类索引查找全限定名的过程"></p> <p>对于接口索引集合, 入口的第一项 u2 类型的数据为<strong>接口计数器</strong>(interfaces_count), 表示<strong>索引表的容量</strong>. 如果该类没有实现任何接口, 则该计数器值为 0, 后面接口的索引表不再占用任何字节. 代码 TestClass 中的代码的类索引, 父类索引与接口表索引的内容如下图所示.</p> <p><img src="/img/Image00127-20240302133505-rg2dfbe.jpg" alt="" title="类索引, 父类索引, 接口索引集合"></p> <p>从偏移地址 0x000000F1 开始的 3 个 u2 类型的值分别为 0x0001, 0x0003, 0x0000, 也就是类索引为 1, 父类索引为 3, 接口索引集合大小为 0. 查询前面代码清单 6-2 中 javap 命令计算出来的常量池, 找出对应的类和父类的常量, 结果如代码清单 6-3 所示.</p> <blockquote><p>代码清单6-3 部分常量池内容</p></blockquote> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">const</span> #<span class="token number">1</span> <span class="token operator">=</span> class        #<span class="token number">2</span><span class="token punctuation">;</span>     <span class="token comment">//  org/fenixsoft/clazz/TestClass</span>
<span class="token keyword">const</span> #<span class="token number">2</span> <span class="token operator">=</span> Asciz        org<span class="token operator">/</span>fenixsoft<span class="token operator">/</span>clazz<span class="token operator">/</span>TestClass<span class="token punctuation">;</span>
<span class="token keyword">const</span> #<span class="token number">3</span> <span class="token operator">=</span> class        #<span class="token number">4</span><span class="token punctuation">;</span>     <span class="token comment">//  java/lang/Object</span>
<span class="token keyword">const</span> #<span class="token number">4</span> <span class="token operator">=</span> Asciz        java<span class="token operator">/</span>lang<span class="token operator">/</span>Object<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h5 id="_5-字段表集合"><a href="#_5-字段表集合" class="header-anchor">#</a> 5.字段表集合</h5> <p><mark><strong>字段表(field_info)用于描述接口或者类中声明的变量</strong></mark>. Java 语言中的 &quot;字段&quot; (Field)包括<strong>类级变量以及实例级变量, 但不包括在方法内部声明的局部变量</strong>.</p> <p>Java 中字段可以包括的修饰符有字段如下:</p> <ul><li><strong>作用域(public, private, protected 修饰符)</strong></li> <li><strong>是实例变量还是类变量(static 修饰符)</strong></li> <li><strong>可变性(final)</strong></li> <li><strong>并发可见性(volatile 修饰符, 是否强制从主内存读写)</strong></li> <li><strong>可否被序列化(transient 修饰符)</strong></li> <li><strong>字段数据类型(基本类型, 对象, 数组)</strong></li> <li><strong>字段名称</strong>.</li></ul> <p>上述这些信息中, 各个修饰符都是<strong>用布尔值来表示某个修饰符是否存在</strong>, 很适合使用标志位来表示. 而字段叫做什么名字, 字段被定义为什么数据类型, 这些都是无法固定的, 只能引用常量池中的常量来描述.</p> <p>class 文件中字段表相关的结构如下:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>u2             fields_count<span class="token punctuation">;</span>        <span class="token comment">// Class 文件的字段的个数</span>
field_info     fields<span class="token punctuation">[</span>fields_count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 一个类会可以有个字段</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>下表 6-8 中列出了字段表的最终格式.</p> <blockquote><p>表6-8 字段表结构</p></blockquote> <p><img src="/img/Image00128-20240302133505-mro40co.jpg" alt=""></p> <p>字段修饰符放在 access_flags 项目中, 它与类中的 access_flags 项目是非常类似的, 都是一个 u2 的数据类型, 其中可以设置的标志位和含义如表 6-9 所示.</p> <blockquote><p>表6-9 字段访问标志</p></blockquote> <p><img src="/img/Image00129-20240302133505-ijkbkm1.jpg" alt=""></p> <p>很明显, 由于语法规则的约束, ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED 三个标志最多只能选择其一, ACC_FINAL, ACC_VOLATILE 不能同时选择. 接口之中的字段必须有 ACC_PUBLIC, ACC_STATIC, ACC_FINAL 标志, 这些都是由 Java 本身的语言规则所导致的.</p> <p>跟随 access_flags 标志的是两项索引值: name_index 和 descriptor_index. 它们都是对常量池项的引用, 分别代表着字段的简单名称以及字段和方法的描述符. 现在需要解释一下 &quot;简单名称&quot;, &quot;描述符&quot; 以及前面出现过多次的 &quot;全限定名&quot; 这三种特殊字符串的概念.</p> <p>全限定名和简单名称很好理解, 以代码清单 6-1 中的代码为例, &quot;<code>org/fenixsoft/clazz/TestClass&quot;</code>​ 是这个类的全限定名, 仅仅是把类全名中的 &quot;.&quot; 替换成了 &quot;/&quot; 而已, 为了使连续的多个全限定名之间不产生混淆, 在使用时最后一般会加入一个 &quot;;&quot; 号表示全限定名结束. 简单名称则就是指没有类型和参数修饰的方法或者字段名称, 这个类中的 inc() 方法和 m 字段的简单名称分别就是 &quot;inc&quot; 和 &quot;m&quot;.</p> <p>相比于全限定名和简单名称, <strong>方法和字段的描述符</strong>就要复杂一些. <strong>描述符的作用是用来描述字段的数据类型, 方法的参数列表(包括数量, 类型以及顺序)和返回值</strong>. 根据描述符规则, 基本数据类型(byte, char, double, float, int, long, short, boolean)以及代表无返回值的 void 类型都用一个大写字符来表示, 而对象类型则用字符 L 加对象的全限定名来表示, 详见表 6-10.</p> <blockquote><p>表6-10 描述符标识字符含义</p></blockquote> <p><img src="/img/Image00130-20240302133505-irx4ts4.jpg" alt=""></p> <p>注: void 类型在《Java 虚拟机规范》之中单独列出为 &quot;VoidDescriptor&quot;, 这里为了结构统一, 将其列在基本数据类型中一起描述.</p> <p>对于数组类型, 每一维度将使用一个前置的 <code>&quot;[&quot;</code>​ 字符来描述, 如一个定义为 &quot;<code>java.lang.String[][]</code>​&quot; 类型的二维数组将被记录成 &quot;<code>[[Ljava/lang/String;</code>​&quot;, 一个整型数组 &quot;<code>int[]</code>​&quot; 将被记录成 &quot;<code>[I</code>​&quot;.</p> <p>用描述符来描述方法时, 按照先参数列表, 后返回值的顺序描述, 参数列表按照参数的严格顺序放在一组小括号 &quot;<code>()</code>​&quot; 之内. 如方法 void inc() 的描述符为 &quot;<code>()V</code>​&quot;, 方法 java.lang.String toString() 的描述符为 &quot;<code>()Ljava/lang/String;</code>​&quot;, 方法 int indexOf(char[]source, int sourceOffset, int sourceCount, char[]target, int targetOffset, int targetCount, int fromIndex) 的描述符为 &quot;<code>([CII[CIII)I</code>​&quot;.</p> <p>对于代码清单 6-1 所编译的 TestClass.class 文件来说, 字段表集合从地址 0x000000F8 开始, 第一个 u2 类型的数据为容量计数器 fields_count, 如图 6-8 所示, 其值为 0x0001, 说明这个类只有一个字段表数据. 接下来紧跟着容量计数器的是 access_flags 标志, 值为 0x0002, 代表 private 修饰符的 ACC_PRIVATE 标志位为真(ACC_PRIVATE 标志的值为 0x0002), 其他修饰符为假. 代表字段名称的 name_index 的值为 0x0005, 从代码清单 6-2 列出的常量表中可查得第五项常量是一个 CONSTANT_Utf8_info 类型的字符串, 其值为 &quot;m&quot;, 代表字段描述符的 descriptor_index 的值为 0x0006, 指向常量池的字符串 &quot;I&quot;. 根据这些信息, 可以推断出原代码定义的字段为 &quot;private int m;&quot;.</p> <p><img src="/img/Image00131-20240302133505-qbylp9u.jpg" alt="" title="图6-8　字段表结构实例"></p> <p>字段表所包含的固定数据项目到 <strong>descriptor_index</strong> 为止就全部结束了, 不过在 descriptor_index 之后跟随着一个属性表集合, 用于存储一些额外的信息, 字段表可以在属性表中附加描述零至多项的额外信息. 对于本例中的字段 m, 它的属性表计数器为 0, 也就是没有需要额外描述的信息, 但如果将字段 m 的声明改为 &quot;<code>final static int m=123;</code>​&quot;, 那就可能会存在一项名称为 ConstantValue 的属性, 其值指向常量 123.</p> <p><strong>字段表集合中不会列出从父类或者父接口中继承而来的字段, 但有可能出现原本 Java 代码之中不存在的字段, 譬如在内部类中为了保持对外部类的访问性, 编译器就会自动添加指向外部类实例的字段</strong>(参考: 内部类原理解析). 另外, 在 Java 语言中字段是无法重载的, 两个字段的数据类型, 修饰符不管是否相同, 都必须使用不一样的名称, 但是对于 Class 文件格式来讲, 只要两个字段的描述符不是完全相同, 那字段重名就是合法的.</p> <h5 id="_6-方法表集合"><a href="#_6-方法表集合" class="header-anchor">#</a> 6.方法表集合</h5> <p>如果理解了上一节关于字段表的内容, 那本节关于方法表的内容将会变得很简单. Class 文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式, <strong>方法表的结构如同字段表一样, 依次包括访问标志(access_flags), 名称索引(name_index), 描述符索引(descriptor_index), 属性表集合(attributes)几项</strong>, 如表 6-11 所示. 这些数据项目的含义也与字段表中的非常类似, 仅在访问标志和属性表集合的可选项中有所区别.</p> <blockquote><p>表6-11 方法表结构</p></blockquote> <p><img src="/img/Image00132-20240302133505-zlxuohh.jpg" alt=""></p> <p>因为 volatile 关键字和 transient 关键字不能修饰方法, 所以方法表的访问标志中没有了 ACC_VOLATILE 标志和 ACC_TRANSIENT 标志. 与之相对, <strong>synchronized, native, strictfp 和 abstract 关键字可以修饰方法, 方法表的访问标志中也相应地增加了 ACC_SYNCHRONIZED, ACC_NATIVE, ACC_STRICTFP 和 ACC_ABSTRACT 标志</strong>. 对于方法表, 所有标志位及其取值可参见表 6-12.</p> <blockquote><p>表6-12 方法访问标志</p></blockquote> <p><img src="/img/Image00133-20240302133505-7akp1ua.jpg" alt=""></p> <p>行文至此, 也许有的读者会产生疑问, 方法的定义可以通过访问标志, 名称索引, 描述符索引来表达清楚, 但<strong>方法里面的代码去哪里</strong>了? 方法里的 Java 代码, 经过 Javac 编译器编译成字节码指令之后, <strong>存放在方法属性表集合中一个名为 &quot;Code&quot; 的属性里面, 属性表作为 Class 文件格式中最具扩展性的一种数据项目</strong>, 将在下一节中详细讲解.</p> <p>继续以代码清单 6-1 中的 Class 文件为例对方法表集合进行分析. 如图 6-9 所示, 方法表集合的<strong>入口地址为 0x00000101</strong>, 第一个 u2 类型的数据(即计数器容量)的值为 0x0002, 代表集合中有两个方法, 这两个方法为编译器添加的实例构造器 <code>&lt;init&gt;</code>​ 和源码中定义的方法 inc(). 第一个方法的访问标志值为 0x0001, 也就是只有 ACC_PUBLIC 标志为真, 名称索引值为 0x0007, 查代码清单 6-2 的常量池得方法名为 &quot;<code>&lt;init&gt;</code>​&quot;, 描述符索引值为 0x0008, 对应常量为 &quot;<code>()V</code>​&quot;, 属性表计数器 attributes_count 的值为 0x0001, 表示此方法的属性表集合有 1 项属性, 属性名称的索引值为 0x0009, 对应常量为 &quot;Code&quot;, 说明此属性是方法的字节码描述.</p> <p><img src="/img/Image00134-20240302133505-0v15frk.jpg" alt="" title="图6-9　方法表结构实例"></p> <p>与字段表集合相对应地, 如果<strong>父类方法在子类中没有被重写(Override), 方法表集合中就不会出现来自父类的方法信息</strong>. 但同样地, 有可能会出现由<strong>编译器自动添加的方法</strong>, 最常见的便是类构造器 &quot;<code>&lt;clinit&gt;()</code>​&quot; 方法和实例构造器 &quot;<code>&lt;init&gt;()</code>​&quot; 方法.</p> <p>在 Java 语言中, 要重载(Overload)一个方法, 除了要与原方法具有相同的简单名称之外, 还要求必须拥有一个<strong>与原方法不同的特征签名</strong>. 特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合, 也正是因为返回值不会包含在特征签名之中, 所以 Java 语言里面是<strong>无法仅仅依靠返回值的不同来对一个已有方法进行重载的</strong>. 但是在 Class 文件格式之中, 特征签名的范围明显要更大一些, 只要描述符不是完全一致的两个方法就可以共存. 也就是说, 如果两个方法有相同的名称和特征签名, 但返回值不同, 那么也是可以合法共存于同一个 Class 文件中的.</p> <h5 id="_7-属性表集合"><a href="#_7-属性表集合" class="header-anchor">#</a> 7.属性表集合</h5> <p>属性表(attribute_info)在前面的讲解之中已经出现过数次, <strong>Class 文件, 字段表, 方法表都可以携带自己的属性表集合</strong>, 以描述某些<strong>场景专有</strong>的信息.</p> <p>与 Class 文件中其他的数据项目要求严格的顺序, 长度和内容不同, 属性表集合的限制稍微宽松一些, <strong>不再要求各个属性表具有严格顺序</strong>, 并且《Java 虚拟机规范》允许只要不与已有属性名重复, 任何人实现的编译器都可以向属性表中写入自己定义的属性信息, Java 虚拟机运行时会忽略掉它不认识的属性. 为了能正确解析 Class 文件, 《Java 虚拟机规范》最初只预定义了 9 项所有 Java 虚拟机实现都应当能识别的属性, 而在最新的《Java 虚拟机规范》的 Java SE 12 版本中, 预定义属性已经增加到 29 项, 这些属性具体见表 6-13. 后文中将对这些属性中的关键的, 常用的部分进行讲解.</p> <blockquote><p>表6-13 虚拟机规范预定义的属性</p></blockquote> <p><img src="/img/Image00135-20240302133505-n1wx6cf.jpg" alt=""></p> <p><img src="/img/Image00136-20240302133505-vqmvi9p.jpg" alt=""></p> <p>对于每一个属性, 它的名称都要从常量池中引用一个 CONSTANT_Utf8_info 类型的常量来表示, 而属性值的结构则是完全自定义的, 只需要通过一个 u4 的长度属性去说明属性值所占用的位数即可. 一个符合规则的属性表应该满足表 6-14 中所定义的结构.</p> <blockquote><p>表6-14 属性表结构</p></blockquote> <p><img src="/img/Image00137-20240302133505-ykmgfwm.jpg" alt=""></p> <p>下面挑几个介绍一下.</p> <h6 id="_1-code属性"><a href="#_1-code属性" class="header-anchor">#</a> (1)Code属性</h6> <p><mark><strong>Java 程序方法体里面的代码经过 Javac 编译器处理之后, 最终变为字节码指令存储在 Code 属性内. Code 属性是 Class 文件中最重要的一个属性, 如果把一个 Java 程序中的信息分为代码(Code, 方法体里面的 Java 代码)和元数据(Metadata, 包括类, 字段, 方法定义及其他信息)两部分, 那么在整个 Class 文件里, Code 属性用于描述代码, 所有的其他数据项目都用于描述元数据</strong></mark>.</p> <p>Code 属性出现在方法表的属性集合之中, 但并非所有的方法表都必须存在这个属性, 譬如接口或者抽象类中的方法就不存在 Code 属性, 如果方法表有 Code 属性存在, 那么它的结构将如表 6-15 所示.</p> <blockquote><p>表6-15 Code 属性表的结构</p></blockquote> <p><img src="/img/Image00138-20240302133505-vo33l3v.jpg" alt=""></p> <p>attribute_name_index 是一项指向 CONSTANT_Utf8_info 型常量的索引, 此常量值固定为 &quot;Code&quot;, 它代表了该属性的属性名称, attribute_length 指示了属性值的长度, 由于属性名称索引与属性长度一共为 6 个字节, 所以属性值的长度固定为整个属性表长度减去 6 个字节.</p> <p>max_stack 代表了操作数栈(Operand Stack)深度的最大值. 在方法执行的任意时刻, 操作数栈都不会超过这个深度. 虚拟机运行的时候需要根据这个值来分配栈帧(Stack Frame)中的操作栈深度.</p> <p><strong>max_locals 代表了局部变量表所需的存储空间</strong>. 在这里, max_locals 的单位是变量槽(Slot), 变量槽是虚拟机为局部变量分配内存所使用的最小单位. 对于 byte, char, float, int, short, boolean 和 returnAddress 等长度不超过 32 位的数据类型, 每个局部变量占用一个变量槽, 而 double 和 long 这两种 64 位的数据类型则需要两个变量槽来存放. 方法参数(包括实例方法中的隐藏参数 &quot;this&quot;), 显式异常处理程序的参数(Exception Handler Parameter, 就是 try-catch 语句中 catch 块中所定义的异常), 方法体中定义的局部变量都需要依赖局部变量表来存放. 注意, 并不是在方法中用了多少个局部变量, 就把这些局部变量所占变量槽数量之和作为 max_locals 的值, 操作数栈和局部变量表直接决定一个该方法的栈帧所耗费的内存, 不必要的操作数栈深度和变量槽数量会造成内存的浪费. Java 虚拟机的做法是将局部变量表中的变量槽进行重用, 当代码执行超出一个局部变量的作用域时, 这个局部变量所占的变量槽可以被其他局部变量所使用, Javac 编译器会根据变量的作用域来分配变量槽给各个变量使用, 根据同时生存的最大局部变量数量和类型计算出 max_locals 的大小.</p> <p><strong>code_length 和 code 用来存储 Java 源程序编译后生成的字节码指令</strong>. code_length 代表字节码长度, code 是用于存储字节码指令的一系列字节流. 既然叫字节码指令, 那顾名思义每个指令就是一个 u1 类型的单字节, 当虚拟机读取到 code 中的一个字节码时, 就可以对应找出这个字节码代表的是什么指令, 并且可以知道这条指令后面是否需要跟随参数, 以及后续的参数应当如何解析. 我们知道一个 u1 数据类型的取值范围为 0x00～0xFF, 对应十进制的 0～255, 也就是一共可以表达 256 条指令. 目前, 《Java 虚拟机规范》已经定义了其中约 200 条编码值对应的指令含义, 编码与指令之间的对应关系可查阅本书的附录 C &quot;虚拟机字节码指令表&quot;.</p> <p>关于 code_length, 有一件值得注意的事情, 虽然它是一个 u4 类型的长度值, 理论上最大值可以达到 2 的 32 次幂, 但是《Java 虚拟机规范》中明确<strong>限制了一个方法不允许超过 65535 条字节码指令</strong>, 即它实际只使用了 u2 的长度, 如果超过这个限制, Javac 编译器就会拒绝编译. 一般来讲, 编写 Java 代码时只要不是刻意去编写一个超级长的方法来为难编译器, 是不太可能超过这个最大值的限制的. 但某些特殊情况, 例如在编译一个很复杂的 JSP 文件时, 某些 JSP 编译器会把 JSP 内容和页面输出的信息归并于一个方法之中, 就有可能因为方法生成字节码超长的原因而导致编译失败.</p> <blockquote><p>Code属性分析示例</p></blockquote> <p>了解 Code 属性是学习后面两章关于字节码执行引擎内容的必要基础, 能直接阅读字节码也是工作中分析 Java 代码语义问题的必要工具和基本技能, 为此, 笔者准备了一个比较详细的实例来讲解<strong>虚拟机是如何使用这个属性</strong>的.</p> <p>继续以代码清单 6-1 的 TestClass.class 文件为例, 如图 6-10 所示, 这是上一节分析过的实例构造器 &quot;<code>&lt;init&gt;()</code>​&quot; 方法的 Code 属性. 它的操作数栈的最大深度和本地变量表的容量都为 0x0001, 字节码区域所占空间的长度为 0x0005. 虚拟机读取到字节码区域的长度后, 按照顺序依次读入紧随的 5 个字节, 并根据字节码指令表翻译出所对应的字节码指令. 翻译 &quot;2A B7000A B1&quot; 的过程为:</p> <p>(1) 读入2A, 查表得 0x2A 对应的指令为 aload_0, 这个指令的含义是将第 0 个变量槽中为 reference 类型的本地变量推送到操作数栈顶.</p> <p>(2) 读入 B7, 查表得 0xB7 对应的指令为 invokespecial, 这条指令的作用是以栈顶的 reference 类型的数据所指向的对象作为方法接收者, 调用此对象的实例构造器方法, private 方法或者它的父类的方法. 这个方法有一个 u2 类型的参数说明具体调用哪一个方法, 它指向常量池中的一个 CONSTANT_Methodref_info 类型常量, 即此方法的符号引用.</p> <p>(3) 读入 000A, 这是 invokespecial 指令的参数, 代表一个符号引用, 查常量池得 0x000A 对应的常量为实例构造器 &quot;<code>&lt;init&gt;()</code>​&quot; 方法的符号引用.</p> <p>(4) 读入 B1, 查表得 0xB1 对应的指令为 return, 含义是从方法的返回, 并且返回值为 void. 这条指令执行后, 当前方法正常结束.</p> <p><img src="/img/Image00139-20240302133505-wda051m.jpg" alt="" title="图6-10　Code 属性结构实例"></p> <p>这段字节码虽然很短, 但可以从中看出它<strong>执行过程中的数据交换, 方法调用等操作都是基于栈(操作数栈)的</strong>. 可以初步猜测, Java 虚拟机执行字节码应该是基于栈的体系结构. 但又发现与通常基于栈的指令集里都是无参数的又不太一样, 某些指令(如 invokespecial)后面还会带有参数, 关于虚拟机字节码执行的讲解是后面两章的话题.</p> <p>再次使用 javap 命令把此 Class 文件中的另一个方法的字节码指令也计算出来, 结果如代码清单 6-4 所示.</p> <blockquote><p>代码清单6-4 用Javap命令计算字节码指令</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 原始 Java 代码</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> m<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">C</span><span class="token operator">:</span>\<span class="token operator">&gt;</span>javap <span class="token operator">-</span>verbose <span class="token class-name">TestClass</span>
<span class="token comment">// 常量表部分的输出见代码清单6-1, 因版面原因这里省略掉</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>clazz<span class="token punctuation">.</span></span>TestClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Code</span><span class="token operator">:</span>
        <span class="token class-name">Stack</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">Locals</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">Args_size</span><span class="token operator">=</span><span class="token number">1</span>
        <span class="token number">0</span><span class="token operator">:</span>   aload_0
        <span class="token number">1</span><span class="token operator">:</span>   invokespecial   #<span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>
        <span class="token number">4</span><span class="token operator">:</span>   <span class="token keyword">return</span>
    <span class="token class-name">LineNumberTable</span><span class="token operator">:</span>
        line <span class="token number">3</span><span class="token operator">:</span> <span class="token number">0</span>

    <span class="token class-name">LocalVariableTable</span><span class="token operator">:</span>
        <span class="token class-name">Start</span>  <span class="token class-name">Length</span>  <span class="token class-name">Slot</span>  <span class="token class-name">Name</span>    <span class="token class-name">Signature</span>
        <span class="token number">0</span>      <span class="token number">5</span>       <span class="token number">0</span>     <span class="token keyword">this</span>    <span class="token class-name">Lorg</span><span class="token operator">/</span>fenixsoft<span class="token operator">/</span>clazz<span class="token operator">/</span><span class="token class-name">TestClass</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Code</span><span class="token operator">:</span>
        <span class="token class-name">Stack</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">Locals</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">Args_size</span><span class="token operator">=</span><span class="token number">1</span>
        <span class="token number">0</span><span class="token operator">:</span>   aload_0
        <span class="token number">1</span><span class="token operator">:</span>   getfield        #<span class="token number">18</span><span class="token punctuation">;</span> <span class="token comment">//Field m:I</span>
        <span class="token number">4</span><span class="token operator">:</span>   iconst_1
        <span class="token number">5</span><span class="token operator">:</span>   iadd
        <span class="token number">6</span><span class="token operator">:</span>   ireturn
    <span class="token class-name">LineNumberTable</span><span class="token operator">:</span>
        line <span class="token number">8</span><span class="token operator">:</span> <span class="token number">0</span>

    <span class="token class-name">LocalVariableTable</span><span class="token operator">:</span>
        <span class="token class-name">Start</span>  <span class="token class-name">Length</span>  <span class="token class-name">Slot</span>  <span class="token class-name">Name</span>    <span class="token class-name">Signature</span>
        <span class="token number">0</span>      <span class="token number">7</span>       <span class="token number">0</span>     <span class="token keyword">this</span>    <span class="token class-name">Lorg</span><span class="token operator">/</span>fenixsoft<span class="token operator">/</span>clazz<span class="token operator">/</span><span class="token class-name">TestClass</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p>如果大家注意到 javap 中输出的 &quot;Args_size&quot; 的值, 可能还会有疑问: 这个类有两个方法, 即实例构造器 <code>&lt;init&gt;()</code>​ 和 <code>inc()</code>​, 这两个方法很明显都是没有参数的, 为什么 Args_size 会为 1? 而且无论是在参数列表里还是方法体内, 都没有定义任何局部变量, 那 Locals 又为什么会等于 1? 如果有这样疑问的读者, 大概是忽略了一条 Java 语言里面的潜规则: <strong>在任何实例方法里面, 都可以通过 &quot;this&quot; 关键字访问到此方法所属的对象</strong>. 这个访问机制对 Java 程序的编写很重要, 而它的实现非常简单, 仅仅是通过在 Javac 编译器编译的时候把对 this 关键字的访问转变为对一个普通方法参数的访问, 然后在虚拟机调用实例方法时自动传入此参数而已. 因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量, 局部变量表中也会预留出第一个变量槽位来存放对象实例的引用, 所以实例方法参数值从 1 开始计算. 这个处理只对实例方法有效, 如果代码清单 6-1 中的 inc() 方法被声明为 static, 那 Args_size 就不会等于 1 而是等于 0 了.</p> <blockquote><p>异常表</p></blockquote> <p>在字节码指令之后的是这个方法的显式异常处理表(下文简称 &quot;异常表&quot;)集合, <strong>异常表对于 Code 属性来说并不是必须存在的</strong>, 如代码清单 6-4 中就没有异常表生成.</p> <p>如果存在异常表, 那它的格式应如表 6-16 所示, 包含四个字段, 这些字段的含义为: <strong>如果当字节码从第 start_pc 行到第 end_pc 行之间(不含第 end_pc 行)出现了类型为 catch_type 或者其子类的异常(catch_type 为指向一个 CONSTANT_Class_info 型常量的索引), 则转到第 handler_pc 行继续处理</strong>. 当 catch_type 的值为 0 时, 代表任意异常情况都需要转到 handler_pc 处进行处理.</p> <blockquote><p>表6-16 属性表结构</p></blockquote> <p><img src="/img/Image00140-20240302133505-jrqx62j.jpg" alt=""></p> <p>异常表实际上是 Java 代码的一部分, 尽管字节码中有最初为处理异常而设计的跳转指令, 但《Java 虚拟机规范》中明确要求 Java 语言的编译器应当选择<strong>使用异常表</strong>而不是通过跳转指令来实现 Java 异常及 finally 处理机制.</p> <p>代码清单 6-5 是一段演示异常表如何运作的例子, 这段代码主要演示了在字节码层面 try-catch-finally 是如何体现的. 阅读字节码之前, 大家不妨先看看下面的 Java 源码, 想一下这段代码的返回值在出现异常和不出现异常的情况下分别应该是多少?</p> <blockquote><p>代码清单6-5 异常表运作演示</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Java 源码</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 编译后的 ByteCode 字节码及异常表</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Code</span><span class="token operator">:</span>
        <span class="token class-name">Stack</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">Locals</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token class-name">Args_size</span><span class="token operator">=</span><span class="token number">1</span>
        <span class="token number">0</span><span class="token operator">:</span>   iconst_1   <span class="token comment">// try 块中的 x=1</span>
        <span class="token number">1</span><span class="token operator">:</span>   istore_1
        <span class="token number">2</span><span class="token operator">:</span>   iload_1    <span class="token comment">// 保存 x 到 returnValue 中, 此时 x=1</span>
        <span class="token number">3</span><span class="token operator">:</span>   istore  <span class="token number">4</span>
        <span class="token number">5</span><span class="token operator">:</span>   iconst_3   <span class="token comment">// finaly 块中的 x=3</span>
        <span class="token number">6</span><span class="token operator">:</span>   istore_1
        <span class="token number">7</span><span class="token operator">:</span>   iload   <span class="token number">4</span>  <span class="token comment">// 将 returnValue 中的值放到栈顶, 准备给 ireturn 返回</span>
        <span class="token number">9</span><span class="token operator">:</span>   ireturn
        <span class="token number">10</span><span class="token operator">:</span>  astore_2   <span class="token comment">// 给 catch 中定义的 Exception e 赋值, 存储在变量槽 2中</span>
        <span class="token number">11</span><span class="token operator">:</span>  iconst_2   <span class="token comment">// catch 块中的 x=2</span>
        <span class="token number">12</span><span class="token operator">:</span>  istore_1
        <span class="token number">13</span><span class="token operator">:</span>  iload_1    <span class="token comment">// 保存 x 到 returnValue 中, 此时 x=2</span>
        <span class="token number">14</span><span class="token operator">:</span>  istore  <span class="token number">4</span>
        <span class="token number">16</span><span class="token operator">:</span>  iconst_3   <span class="token comment">// finaly 块中的 x=3</span>
        <span class="token number">17</span><span class="token operator">:</span>  istore_1
        <span class="token number">18</span><span class="token operator">:</span>  iload <span class="token number">4</span>    <span class="token comment">// 将 returnValue 中的值放到栈顶, 准备给 ireturn 返回</span>
        <span class="token number">20</span><span class="token operator">:</span>  ireturn
        <span class="token number">21</span><span class="token operator">:</span>  astore_3   <span class="token comment">// 如果出现了不属于 java.lang.Exception 及其子类的异常才会走到这里</span>
        <span class="token number">22</span><span class="token operator">:</span>  iconst_3   <span class="token comment">// finaly 块中的 x=3</span>
        <span class="token number">23</span><span class="token operator">:</span>  istore_1
        <span class="token number">24</span><span class="token operator">:</span>  aload_3    <span class="token comment">// 将异常放置到栈顶, 并抛出</span>
        <span class="token number">25</span><span class="token operator">:</span>  athrow
    <span class="token class-name">Exception</span> table<span class="token operator">:</span>
    from   <span class="token keyword">to</span>  <span class="token namespace">target</span> type
        <span class="token number">0</span>     <span class="token number">5</span>    <span class="token number">10</span>   <span class="token class-name">Class</span> java<span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">Exception</span>
        <span class="token number">0</span>     <span class="token number">5</span>    <span class="token number">21</span>   any
        <span class="token number">10</span>    <span class="token number">16</span>   <span class="token number">21</span>   any
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><p>编译器为这段 Java 源码生成了三条异常表记录, 对应<strong>三条可能出现的代码执行路径</strong>. 从 Java 代码的语义上讲, 这三条执行路径分别为:</p> <ul><li>如果 try 语句块中出现属于 Exception 或其子类的异常, 转到 catch 语句块处理;</li> <li>如果 try 语句块中出现不属于 Exception 或其子类的异常, 转到 finally 语句块处理;</li> <li>如果 catch 语句块中出现任何异常, 转到 finally 语句块处理.</li></ul> <p>返回到上面提出的问题, 这段代码的返回值应该是多少? 熟悉 Java 语言的读者应该很容易说出答案: 如果没有出现异常, 返回值是 1; 如果出现了 Exception 异常, 返回值是 2; 如果出现了 Exception 以外的异常, 方法非正常退出, 没有返回值. 一起来分析一下字节码的执行过程, 从字节码的层面上看看为何会有这样的返回结果.</p> <p>字节码中第 0～4 行所做的操作就是将整数 1 赋值给变量 x, 并且将此时 x 的值复制一份副本到最后一个本地变量表的变量槽中(这个变量槽里面的值在 ireturn 指令执行前将会被重新读到操作栈顶, 作为方法返回值使用. 为了讲解方便, 笔者给这个变量槽起个名字: returnValue). 如果这时候没有出现异常, 则会继续走到第 5～9 行, 将变量 x 赋值为 3, 然后将之前保存在 returnValue 中的整数 1 读入到<strong>操作栈顶</strong>, 最后 ireturn 指令会以 int 形式返回操作栈顶中的值, 方法结束. 如果出现了异常, PC 寄存器指针转到第 10 行, 第 10～20 行所做的事情是将 2 赋值给变量 x, 然后将变量 x 此时的值赋给 returnValue, 最后再将变量 x 的值改为 3. 方法返回前同样将 returnValue 中保留的整数 2 读到了操作栈顶. 从第 21 行开始的代码, 作用是将变量 x 的值赋为 3, 并将栈顶的异常抛出, 方法结束.</p> <p>尽管大家都知道这段代码出现异常的概率非常之小, 但是并不影响用它演示异常表的作用.</p> <h6 id="_2-exceptions属性"><a href="#_2-exceptions属性" class="header-anchor">#</a> (2)Exceptions属性</h6> <p>这里的 Exceptions 属性是在方法表中与 Code 属性<strong>平级</strong>的一项属性, 读者不要与前面刚刚讲解完的异常表产生混淆. <strong>Exceptions 属性的作用是列举出方法中可能抛出的受查异常(Checked Excepitons), 也就是方法描述时在 throws 关键字后面列举的异常</strong>. 它的结构见表 6-17.</p> <blockquote><p>表6-17 Exceptions 属性结构</p></blockquote> <p><img src="/img/Image00141-20240302133505-jgrwooe.jpg" alt=""></p> <p>此属性中的 number_of_exceptions 项表示方法可能抛出 number_of_exceptions 种受查异常, 每一种受查异常使用一个 exception_index_table 项表示; exception_index_table 是一个指向常量池中 CONSTANT_Class_info 型常量的索引, 代表了该受查异常的类型.</p> <h6 id="_3-innerclasses属性"><a href="#_3-innerclasses属性" class="header-anchor">#</a> (3)InnerClasses属性</h6> <p><strong>InnerClasses 属性用于记录内部类与宿主类之间的关联</strong>. 如果一个类中定义了内部类, 那编译器将会为它以及它所包含的内部类生成 InnerClasses 属性. InnerClasses 属性的结构如表 6-24 所示.</p> <blockquote><p>表6-24 InnerClasses 属性结构</p></blockquote> <p><img src="/img/Image00148-20240302133505-nc5vyei.jpg" alt=""></p> <p>数据项 number_of_classes 代表需要记录多少个内部类信息, 每一个内部类的信息都由一个 inner_classes_info 表进行描述. inner_classes_info 表的结构如表 6-25 所示.</p> <blockquote><p>表6-25 inner_classes_info 表的结构</p></blockquote> <p><img src="/img/Image00149-20240302133505-jvazo41.jpg" alt=""></p> <p>inner_class_info_index 和 outer_class_info_index 都是指向常量池中 CONSTANT_Class_info 型常量的索引, 分别代表了内部类和宿主类的符号引用.</p> <p>inner_name_index 是指向常量池中 CONSTANT_Utf8_info 型常量的索引, 代表这个内部类的名称, 如果是匿名内部类, 这项值为 0.</p> <p>inner_class_access_flags 是内部类的访问标志, 类似于类的 access_flags, 它的取值范围如表 6-26 所示.</p> <blockquote><p>表6-26 inner_class_access_flags 标志</p></blockquote> <p><img src="/img/Image00150-20240302133505-s82i8vr.jpg" alt=""></p> <h6 id="_4-运行时注解相关属性"><a href="#_4-运行时注解相关属性" class="header-anchor">#</a> (4)运行时注解相关属性</h6> <p><strong>RuntimeVisibleAnnotations 是一个变长属性, 它记录了类, 字段或方法的声明上记录运行时可见注解</strong>, 当使用反射 API 来获取类, 字段或方法上的注解时, 返回值就是通过这个属性来取到的. RuntimeVisibleAnnotations 属性的结构如表 6-38 所示.</p> <blockquote><p>表6-38 RuntimeVisibleAnnotations 属性结构</p></blockquote> <p><img src="/img/Image00162-20240302133505-jhqqzyj.jpg" alt=""></p> <p>num_annotations 是 annotations 数组的计数器, annotations 中每个元素都代表了一个运行时可见的注解, 注解在 Class 文件中以 annotation 结构来存储, 具体如表 6-39 所示.</p> <blockquote><p>表6-39 annotation属性结构</p></blockquote> <p><img src="/img/Image00163-20240302133505-2ugvu3b.jpg" alt=""></p> <p>type_index 是一个指向常量池 CONSTANT_Utf8_info 常量的索引值, 该常量应以字段描述符的形式表示一个注解. num_element_value_pairs 是 element_value_pairs 数组的计数器, element_value_pairs 中每个元素都是一个键值对, 代表该注解的参数和值.</p> <h4 id="字节码指令简介"><a href="#字节码指令简介" class="header-anchor">#</a> 字节码指令简介</h4> <p><strong>Java 虚拟机的指令由一个字节长度的, 代表着某种特定操作含义的数字(称为</strong>​<mark><strong>操作码</strong></mark>​ <strong>, Opcode)以及跟随其后的零至多个代表此操作所需的参数(称为</strong>​<mark><strong>操作数</strong></mark>​ <strong>, Operand)构成</strong>. 由于 Java 虚拟机采用<strong>面向操作数栈</strong>而不是面向寄存器的架构(这两种架构的执行过程, 区别和影响将在后面探讨, 参考: 基于栈的字节码解释执行引擎), 所以<mark><strong>大多数指令都不包含操作数, 只有一个操作码, 指令参数都存放在操作数栈中</strong></mark>.</p> <p>字节码指令集可算是一种具有鲜明特点, 优势和劣势均很突出的指令集架构, 由于限制了 Java 虚拟机操作码的<strong>长度为一个字节</strong>(即 0～255), 这意味着指令集的操作码总数不能够超过 256 条; 又由于 Class 文件格式放弃了编译后代码的操作数长度对齐, 这就意味着虚拟机在处理那些超过一个字节的数据时, 不得不在运行时从字节中重建出具体数据的结构, 譬如要将一个 16 位长度的无符号整数使用两个无符号字节存储起来(假设将它们命名为 byte1 和 byte2), 那它们的值应该是这样的:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token punctuation">(</span>byte1 <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> byte2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这种操作在某种程度上会导致解释执行字节码时将损失一些性能, 但这样做的优势也同样明显: 放弃了操作数长度对齐, 就意味着可以省略掉大量的填充和间隔符号; 用一个字节来代表操作码, 也是为了尽可能获得短小精干的编译代码.</p> <p>如果不考虑异常处理的话, 那 Java 虚拟机的解释器可以使用下面这段伪代码作为最基本的<strong>执行模型</strong>来理解, 这个执行模型虽然很简单, 但依然可以有效正确地工作:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>do {
    自动计算 PC 寄存器的值加1;
    根据 PC 寄存器指示的位置, 从字节码流中取出操作码;
    if (字节码存在操作数) 从字节码流中取出操作数;
    执行操作码所定义的操作;
} while (字节码流长度 &gt; 0);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h5 id="_1-字节码与数据类型"><a href="#_1-字节码与数据类型" class="header-anchor">#</a> 1.字节码与数据类型</h5> <p>在 Java 虚拟机的<strong>指令集</strong>中, 大多数指令都包含其操作所对应的<strong>数据类型信息</strong>, 因此看指令就大概知道知道的意思. 举个例子, iload 指令用于从局部变量表中加载 int 型的数据到操作数栈中, 而 fload 指令加载的则是 float 类型的数据. 这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的, 但在 Class 文件中它们必须拥有各自独立的操作码.</p> <p>对于大部分与数据类型相关的字节码指令, 它们的操作码助记符中都有<strong>特殊的字符来表明专门为哪种数据类型</strong>服务: <strong>i 代表对 int 类型的数据操作, l 代表 long, s 代表 short, b 代表 byte, c 代表 char, f 代表 float, d 代表 double, a 代表 reference</strong>. 也有一些指令的助记符中没有明确指明操作类型的字母, 例如 arraylength 指令, 它没有代表数据类型的特殊字符, 但操作数永远只能是一个数组类型的对象. 还有另外一些指令, 例如无条件跳转指令 goto 则是与数据类型无关的指令.</p> <p>因为 Java 虚拟机的操作码长度只有一字节, 所以包含了数据类型的操作码就为指令集的设计带来了很大的压力: 如果每一种与数据类型相关的指令都支持 Java 虚拟机所有运行时数据类型的话, 那么指令的数量恐怕就会超出一字节所能表示的数量范围了. 因此, Java 虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它, 换句话说, 指令集将会被故意设计成非完全独立的. (《Java 虚拟机规范》中把这种特性称为 &quot;Not Orthogonal&quot;, 即并非每种数据类型和每一种操作都有对应的指令.) 有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型.</p> <p>表 6-40 列举了 Java 虚拟机所<strong>支持的与数据类型相关的字节码指令</strong>, 通过使用数据类型列所代表的特殊字符替换 opcode 列的指令模板中的 T, 就可以得到一个具体的字节码指令. 如果在表中指令模板与数据类型两列共同确定的格为空, 则说明虚拟机不支持对这种数据类型执行这项操作. 例如 load 指令有操作 int 类型的 iload, 但是没有操作 byte 类型的同类指令.</p> <blockquote><p>表6-40 Java虚拟机指令集所支持的数据类型</p></blockquote> <p><img src="/img/Image00164-20240302133505-6oilm8v.jpg" alt=""></p> <p><img src="/img/Image00165-20240302133505-nt8rjkr.jpg" alt=""></p> <p>请注意, 从表 6-40 中看来, 大部分指令都没有支持整数类型 byte, char 和 short, 甚至没有任何指令支持 boolean 类型. <strong>编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展为相应的 int 类型数据, 将 boolean 和 char 类型数据零位扩展为相应的 int 类型数据</strong>. 与之类似, 在处理 boolean, byte, short 和 char 类型的数组时, 也会转换为使用对应的 int 类型的字节码指令来处理. 因此, 大多数对于 boolean, byte, short 和 char 类型数据的操作, 实际上都是使用相应的<strong>对 int 类型</strong>作为运算类型来进行的.</p> <p>在本书里, 受篇幅所限, 无法对字节码指令集中每条指令逐一讲解, 但阅读字节码作为了解 Java 虚拟机的基础技能, 是一项应当熟练掌握的能力. 笔者<strong>将字节码操作按用途大致分为 9 类</strong>, 下面按照分类来概略介绍这些指令的用法.</p> <h5 id="_2-加载和存储指令"><a href="#_2-加载和存储指令" class="header-anchor">#</a> 2.加载和存储指令</h5> <p><mark><strong>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输</strong></mark>.</p> <p>这类指令包括:</p> <ul><li>将一个<strong>局部变量</strong>加载到操作栈: <code>iload, iload_&lt;n&gt;, lload, lload_&lt;n&gt;, fload, fload_&lt;n&gt;, dload, dload_&lt;n&gt;, aload, aload_&lt;n&gt;</code>​.</li> <li>将一个<strong>数值</strong>从操作数栈存储到局部变量表: <code>istore, istore_&lt;n&gt;, lstore, lstore_&lt;n&gt;, fstore, fstore_&lt;n&gt;, dstore, dstore_&lt;n&gt;, astore, astore_&lt;n&gt;</code>​.</li> <li>将一个<strong>常量</strong>加载到操作数栈: <code>bipush, sipush, ldc, ldc_w, ldc2_w, aconst_null, iconst_m1, iconst_&lt;i&gt;, lconst_&lt;l&gt;, fconst_&lt;f&gt;, dconst_&lt;d&gt;</code>​.</li> <li>扩充局部变量表的访问索引的指令: <code>wide</code>​.</li></ul> <p><strong>存储数据的操作数栈和局部变量表主要由加载和存储指令进行操作</strong>, 除此之外, 还有少量指令, 如访问对象的字段或数组元素的指令也会向操作数栈传输数据.</p> <p>上面所列举的指令助记符中, 有一部分是以尖括号结尾的(例如 <code>iload_&lt;n&gt;</code>​), 这些指令助记符实际上代表了一组指令(例如 <code>iload_&lt;n&gt;</code>​, 它代表了 <code>iload_0, iload_1, iload_2</code>​和 <code>iload_3</code>​ 这几条指令). 这几组指令都是某个带有一个<strong>操作数的通用指令</strong>(例如 iload)的特殊形式, 对于这几组特殊指令, 它们省略掉了显式的操作数, 不需要进行取操作数的动作, 因为实际上操作数就隐含在指令中. 除了这点不同以外, 它们的语义与原生的通用指令是完全一致的(例如 iload_0 的语义与操作数为 0 时的 iload 指令语义完全一致). 这种指令表示方法, 在本书和《Java 虚拟机规范》中都是通用的.</p> <h5 id="_3-运算指令"><a href="#_3-运算指令" class="header-anchor">#</a> 3.运算指令</h5> <p><mark><strong>运算指令用于对两个操作数栈上的值进行某种特定运算, 并把结果重新存入到操作栈顶</strong></mark>.</p> <p>大体上运算指令可以分为两种: 对<strong>整型</strong>数据进行运算的指令与对<strong>浮点型</strong>数据进行运算的指令. 整数与浮点数的算术指令在溢出和被零除的时候也有各自不同的行为表现. 无论是哪种算术指令, 均是使用 Java 虚拟机的算术类型来进行计算的, 换句话说是不存在直接支持 byte, short, char 和 boolean 类型的算术指令, 对于上述几种数据的运算, 应<strong>使用操作 int 类型的指令代替</strong>. 所有的算术指令包括:</p> <ul><li><strong>加法指令</strong>: iadd, ladd, fadd, dadd</li> <li><strong>减法指令</strong>: isub, lsub, fsub, dsub</li> <li><strong>乘法指令</strong>: imul, lmul, fmul, dmul</li> <li><strong>除法指令</strong>: idiv, ldiv, fdiv, ddiv</li> <li><strong>求余指令</strong>: irem, lrem, frem, drem</li> <li><strong>取反指令</strong>: ineg, lneg, fneg, dneg</li> <li><strong>位移指令</strong>: ishl, ishr, iushr, lshl, lshr, lushr</li> <li><strong>按位或指令</strong>: ior, lor</li> <li><strong>按位与指令</strong>: iand, land</li> <li><strong>按位异或指令</strong>: ixor, lxor</li> <li><strong>局部变量自增指令</strong>: iinc</li> <li><strong>比较指令</strong>: dcmpg, dcmpl, fcmpg, fcmpl, lcmp</li></ul> <p>Java 虚拟机的指令集直接支持了在《Java 语言规范》中描述的各种对整数及浮点数操作的语义. <strong>数据运算可能会导致溢出</strong>, 例如两个很大的正整数相加, 结果可能会是一个负数, 这种数学上不可能出现的溢出现象, 对于程序员来说是很容易理解的, 但其实《Java 虚拟机规范》中并没有明确定义过整型数据溢出具体会得到什么计算结果, 仅规定了在处理整型数据时, 只有除法指令(idiv 和 ldiv)以及求余指令(irem 和 lrem)中当出现除数为零时会导致虚拟机抛出 ArithmeticException 异常, 其余任何整型数运算场景都不应该抛出运行时异常.</p> <p>《Java 虚拟机规范》要求虚拟机实现在处理浮点数时, 必须严格遵循 IEEE 754 规范中所规定行为和限制, 也就是说 Java 虚拟机必须完全支持 IEEE 754 中定义的 &quot;非正规浮点数值&quot;和 &quot;逐级下溢&quot;的运算规则. 这些规则将会使某些数值算法处理起来变得明确, 不会出现模棱两可的困境. 譬如以上规则<strong>要求 Java 虚拟机在进行浮点数运算时, 所有的运算结果都必须舍入到适当的精度, 非精确的结果必须舍入为可被表示的最接近的精确值</strong>; 如果有两种可表示的形式与该值一样接近, 那将优先选择最低有效位为零的. 这种舍入模式也是 IEEE 754 规范中的默认舍入模式, 称为向最接近数舍入模式. 而在把浮点数转换为整数时, Java 虚拟机使用 IEEE 754 标准中的向零舍入模式, 这种模式的舍入结果会导致数字被截断, 所有小数部分的有效字节都会被丢弃掉. 向零舍入模式将在目标数值类型中选择一个最接近, 但是不大于原值的数字来作为最精确的舍入结果.</p> <p>另外, <strong>Java 虚拟机在处理浮点数运算时, 不会抛出任何运行时异常</strong>(这里所讲的是 Java 语言中的异常, 请勿与 IEEE 754 规范中的浮点异常互相混淆, IEEE 754 的浮点异常是一种运算信号), 当一个操作产生溢出时, 将会使用有符号的无穷大来表示; 如果某个操作结果没有明确的数学定义的话, 将会使用 <strong>NaN</strong>(Not a Number)值来表示. 所有使用 NaN 值作为操作数的算术操作, 结果都会返回 NaN.</p> <h5 id="_4-类型转换指令"><a href="#_4-类型转换指令" class="header-anchor">#</a> 4.类型转换指令</h5> <p><mark><strong>类型转换指令可以将两种不同的数值类型相互转换, 这些转换操作一般用于实现用户代码中的显式类型转换操作</strong></mark>, 或者用来处理前面提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题.</p> <p>Java 虚拟机直接支持(即转换时无须显式的转换指令)以下数值类型的宽化类型转换(Widening Numeric Conversion, 即<strong>小范围类型向大范围类型的安全转换</strong>):</p> <ul><li>int 类型到 long, float 或者 double 类型</li> <li>long 类型到 float, double 类型</li> <li>float 类型到 double 类型</li></ul> <p>与之相对的, <strong>处理窄化类型转换(Narrowing Numeric Conversion)时, 就必须显式地使用转换指令来完成</strong>, 这些转换指令包括 <strong>i2b, i2c, i2s, l2i, f2i, f2l, d2i, d2l 和 d2f</strong>. 窄化类型转换可能会导致转换结果产生不同的正负号, 不同的数量级的情况, 转换过程很可能会<strong>导致数值的精度丢失</strong>.</p> <p>在将 int 或 long 类型窄化转换为整数类型 T 的时候, 转换过程仅仅是<strong>简单丢弃</strong>除最低位 N 字节以外的内容, N 是类型 T 的数据类型长度, 这将可能导致转换结果与输入值有不同的正负号. 对于了解计算机数值存储和表示的程序员来说这点很容易理解, 因为原来符号位处于数值的最高位, 高位被丢弃之后, 转换结果的符号就取决于低 N 字节的首位了.</p> <p>尽管数据类型窄化转换可能会发生上限溢出, 下限溢出和精度丢失等情况, 但是《Java 虚拟机规范》中明确规定数值类型的<strong>窄化转换指令永远不可能导致虚拟机抛出运行时异常</strong>.</p> <h5 id="_5-对象创建与访问指令"><a href="#_5-对象创建与访问指令" class="header-anchor">#</a> 5.对象创建与访问指令</h5> <p>虽然类实例和数组都是对象, 但 Java 虚拟机<strong>对类实例和数组的创建与操作使用了不同的字节码指令</strong>(在下一章会讲到数组和普通类的类型创建过程是不同的). 对象创建后, 就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素, 这些指令包括:</p> <ul><li><strong>创建类实例</strong>的指令: <code>new</code>​</li> <li><strong>创建数组</strong>的指令: <code>newarray, anewarray, multianewarray</code>​</li> <li>访问类字段(static 字段, 或者称为类变量)和实例字段(非 static 字段, 或者称为实例变量)的指令: <code>getfield, putfield, getstatic, putstatic</code>​</li> <li>把一个数组元素加载到操作数栈的指令: <code>baload, caload, saload, iaload, laload, faload, daload, aaload</code>​</li> <li>将一个操作数栈的值储存到数组元素中的指令: <code>bastore, castore, sastore, iastore, fastore, dastore, aastore</code>​</li> <li><strong>取数组长度</strong>的指令: <code>arraylength</code>​</li> <li>检查类实例类型的指令: <code>instanceof, checkcast</code>​</li></ul> <h5 id="_6-操作数栈管理指令"><a href="#_6-操作数栈管理指令" class="header-anchor">#</a> 6.操作数栈管理指令</h5> <p>如同操作一个普通数据结构中的堆栈那样, Java 虚拟机提供了一些用于<mark><strong>直接操作操作数栈的指令</strong></mark>, 包括:</p> <ul><li>将操作数栈的栈顶一个或两个元素<strong>出栈</strong>: <code>pop, pop2</code>​</li> <li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶: <code>dup, dup2, dup_x1, dup2_x1, dup_x2, dup2_x2</code>​</li> <li><strong>将栈最顶端的两个数值互换</strong>: <code>swap</code>​</li></ul> <h5 id="_7-控制转移指令"><a href="#_7-控制转移指令" class="header-anchor">#</a> 7.控制转移指令</h5> <p><mark><strong>控制转移指令可以让 Java 虚拟机有条件或无条件地从指定位置指令(而不是控制转移指令)的下一条指令继续执行程序, 从概念模型上理解, 可以认为控制指令就是在有条件或无条件地修改 PC 寄存器的值</strong></mark>.</p> <p>控制转移指令包括:</p> <ul><li><strong>条件分支</strong>: <code>ifeq, iflt, ifle, ifne, ifgt, ifge, ifnull, ifnonnull, if_icmpeq, if_icmpne, if_icmplt, if_icmpgt, if_icmple, if_icmpge, if_acmpeq 和 if_acmpne</code>​</li> <li><strong>复合条件分支</strong>: <code>tableswitch, lookupswitch</code>​</li> <li><strong>无条件分支</strong>: <code>goto, goto_w, jsr, jsr_w, ret</code>​</li></ul> <p>在 Java 虚拟机中有专门的指令集用来处理 int 和 reference 类型的条件分支比较操作, 为了可以无须明显标识一个数据的值是否 null, 也有专门的指令用来检测 null 值.</p> <p>与前面算术运算的规则一致, 对于 boolean 类型, byte 类型, char 类型和 short 类型的条件分支比较操作, 都使用 int 类型的比较指令来完成, 而对于 long 类型, float 类型和 double 类型的条件分支比较操作, 则会先执行<strong>相应类型的比较运算指令</strong>(dcmpg, dcmpl, fcmpg, fcmpl, lcmp), 运算指令会返回一个整型值到操作数栈中, 随后再执行 int 类型的条件分支比较操作来完成整个分支跳转. 由于<strong>各种类型的比较最终都会转化为 int 类型的比较操作</strong>, int 类型比较是否方便, 完善就显得尤为重要, 而 Java 虚拟机提供的 int 类型的条件分支指令是最为丰富, 强大的.</p> <h5 id="_8-方法调用和返回指令🌸"><a href="#_8-方法调用和返回指令🌸" class="header-anchor">#</a> 8.方法调用和返回指令🌸</h5> <p>方法调用(分派, 执行过程)将在后面具体讲解(参考: 方法调用), 这里仅列举<strong>以下五条指令用于方法调用</strong>:</p> <ul><li><strong>invokevirtual 指令</strong>: 用于<strong>调用对象的实例方法</strong>, 根据对象的实际类型进行分派(虚方法分派), 这也是 Java 语言中最常见的方法分派方式.</li> <li><strong>invokeinterface 指令</strong>: 用于<strong>调用接口方法, 它会在运行时搜索一个实现了这个接口方法的对象, 找出适合的方法进行调用</strong>.</li> <li><strong>invokespecial 指令</strong>: 用于调用一些需要特殊处理的实例方法, 包括<strong>实例初始化方法, 私有方法和父类方法</strong>.</li> <li><strong>invokestatic 指令</strong>: 用于<strong>调用类静态方法(static 方法)</strong> .</li> <li><strong>invokedynamic 指令</strong>: 用于<strong>在运行时动态解析出调用点限定符所引用的方法</strong>. 并执行该方法. 前面四条调用指令的分派逻辑都固化在 Java 虚拟机内部, 用户无法改变, 而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的.</li></ul> <p>方法调用指令与数据类型无关, 而方法返回指令是根据返回值的类型区分的, 包括 ireturn(当返回值是 boolean, byte, char, short 和 int 类型时使用), lreturn, freturn, dreturn 和 areturn, 另外还有一条 return 指令供声明为 void 的方法, 实例初始化方法, 类和接口的类初始化方法使用.</p> <h5 id="_9-异常处理指令"><a href="#_9-异常处理指令" class="header-anchor">#</a> 9.异常处理指令</h5> <p>在 Java 程序中<strong>显式抛出异常的操作(throw 语句)都由 athrow 指令</strong>来实现, 除了用 throw 语句显式抛出异常的情况之外, 《Java 虚拟机规范》还规定了许多运行时异常会在其他 Java 虚拟机指令检测到异常状况时自动抛出.</p> <p>例如前面介绍整数运算中, 当除数为零时, 虚拟机会在 idiv 或 ldiv 指令中抛出 ArithmeticException 异常.</p> <p>而在 Java 虚拟机中, <strong>处理异常(catch 语句)不是由字节码指令来实现的</strong>, 而是采用<strong>异常表</strong>来完成.</p> <h5 id="_10-同步指令🌸"><a href="#_10-同步指令🌸" class="header-anchor">#</a> 10.同步指令🌸</h5> <p>Java 虚拟机可以支持方法级的同步和方法内部一段指令序列的同步, 这两种<strong>同步结构都是使用管程</strong>(Monitor, 更常见的是直接将它称为 &quot;锁&quot;)来实现的.</p> <p><mark><strong>方法级的同步是隐式的, 无须通过字节码指令来控制, 它实现在方法调用和返回操作之中. 虚拟机可以从方法常量池中的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否被声明为同步方法. 当方法调用时, 调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置, 如果设置了, 执行线程就要求先成功持有管程, 然后才能执行方法, 最后当方法完成(无论是正常完成还是非正常完成)时释放管程. 在方法执行期间, 执行线程持有了管程, 其他任何线程都无法再获取到同一个管程. 如果一个同步方法执行期间抛出了异常, 并且在方法内部无法处理此异常, 那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放</strong></mark>.</p> <p>同步一段指令集序列通常是由 Java 语言中的 synchronized 语句块来表示的, Java 虚拟机的<mark><strong>指令集中有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义, 正确实现 synchronized 关键字需要 Javac 编译器与 Java 虚拟机两者共同协作支持</strong></mark>, 譬如有代码清单 6-6 所示的代码.</p> <blockquote><p>代码清单6-6 代码同步演示</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">onlyMe</span><span class="token punctuation">(</span><span class="token class-name">Foo</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>编译后, 这段代码生成的字节码序列如下:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>Method <span class="token keyword">void</span> <span class="token function">onlyMe</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span>
<span class="token number">0</span> aload_1                         <span class="token comment">// 将对象 f 入栈</span>
<span class="token number">1</span> dup                        　　 <span class="token comment">// 复制栈顶元素(即 f 的引用)</span>
<span class="token number">2</span> astore_2                        <span class="token comment">// 将栈顶元素存储到局部变量表变量槽 2中</span>
<span class="token number">3</span> monitorenter                    <span class="token comment">// 以栈定元素(即 f)作为锁, 开始同步! ! ! ! ! ! ! </span>
<span class="token number">4</span> aload_0                         <span class="token comment">// 将局部变量槽 0(即 this 指针)的元素入栈</span>
<span class="token number">5</span> invokevirtual #<span class="token number">5</span>                <span class="token comment">// 调用 doSomething()方法</span>
<span class="token number">8</span> aload_2                         <span class="token comment">// 将局部变量 Slow 2的元素(即 f)入栈</span>
<span class="token number">9</span> monitorexit                     <span class="token comment">// 退出同步! ! ! ! ! ! </span>
<span class="token number">10</span> <span class="token keyword">goto</span> <span class="token number">18</span>                        <span class="token comment">// 方法正常结束, 跳转到18返回</span>
<span class="token number">13</span> astore_3                       <span class="token comment">// 从这步开始是异常路径, 见下面异常表的 Taget 13</span>
<span class="token number">14</span> aload_2                        <span class="token comment">// 将局部变量 Slow 2的元素(即 f)入栈</span>
<span class="token number">15</span> monitorexit                    <span class="token comment">// 退出同步! ! ! ! ! </span>
<span class="token number">16</span> aload_3                        <span class="token comment">// 将局部变量 Slow 3的元素(即异常对象)入栈</span>
<span class="token number">17</span> athrow                         <span class="token comment">// 把异常对象重新抛出给 onlyMe()方法的调用者</span>
<span class="token number">18</span> <span class="token keyword">return</span>                         <span class="token comment">// 方法正常返回</span>

Exception table<span class="token operator">:</span>
FromTo Target Type
   <span class="token number">4</span>    <span class="token number">10</span>     <span class="token number">13</span> any
  <span class="token number">13</span>    <span class="token number">16</span>     <span class="token number">13</span> any
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p><mark><strong>编译器必须确保无论方法通过何种方式完成, 方法中调用过的每条 monitorenter 指令都必须有其对应的 monitorexit 指令, 而无论这个方法是正常结束还是异常结束</strong></mark>.</p> <p>从代码清单的字节码序列中可以看到, <strong>为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行, 编译器会自动产生一个异常处理程序, 这个异常处理程序声明可处理所有的异常, 它的目的就是用来执行 monitorexit 指令</strong>.</p> <h4 id="公有设计-私有实现"><a href="#公有设计-私有实现" class="header-anchor">#</a> 公有设计,私有实现</h4> <p>《Java 虚拟机规范》描绘了 Java 虚拟机应有的共同程序存储格式: <mark><strong>Class 文件格式以及字节码指令集</strong></mark>. 这些内容与硬件, 操作系统和具体的 Java 虚拟机实现之间是完全独立的, 虚拟机实现者可能更愿意把它们看作程序在各种 Java 平台实现之间互相安全地交互的手段.</p> <p>理解公有设计与私有实现之间的分界线是非常有必要的, <strong>任何一款 Java 虚拟机实现都必须能够读取 Class 文件并精确实现包含在其中的 Java 虚拟机代码的语义</strong>. 拿着《Java 虚拟机规范》一成不变地逐字实现其中要求的内容当然是一种可行的途径, 但一个优秀的虚拟机实现, 在满足《Java 虚拟机规范》的约束下对具体实现做出修改和优化也是完全可行的, 并且《Java 虚拟机规范》中明确鼓励实现者这样去做. 只要优化以后 Class 文件依然可以被正确读取, 并且包含在其中的语义能得到完整保持, 那<strong>实现者就可以选择以任何方式去实现这些语义, 虚拟机在后台如何处理 Class 文件完全是实现者自己的事情, 只要它在外部接口上看起来与规范描述的一致即可</strong>.</p> <p>虚拟机实现者可以使用这种伸缩性来让 Java 虚拟机获得更高的性能, 更低的内存消耗或者更好的可移植性, 选择哪种特性取决于 Java 虚拟机实现的目标和关注点是什么, 虚拟机实现的方式主要有以下两种:</p> <ul><li>将输入的 Java 虚拟机代码<strong>在加载时或执行时翻译成另一种虚拟机的指令集</strong>;</li> <li>将输入的 Java 虚拟机代码<strong>在加载时或执行时翻译成宿主机处理程序的本地指令集(即即时编译器代码生成技术)</strong> .</li></ul> <p>精确定义的虚拟机行为和目标文件格式, 不应当对虚拟机实现者的创造性产生太多的限制, Java 虚拟机是被设计成可以允许有众多不同的实现, 并且各种实现可以在保持兼容性的同时提供不同的新的, 有趣的解决方案.</p> <h4 id="本章小结"><a href="#本章小结" class="header-anchor">#</a> 本章小结</h4> <p>Class 文件是 Java 虚拟机执行引擎的数据入口, 也是 Java 技术体系的基础支柱之一. 了解 Class 文件的结构对后面进一步了解虚拟机执行引擎有很重要的意义.</p> <p>本章详细讲解了 Class 文件结构中的各个组成部分, 以及每个部分的定义, 数据结构和使用方法. 通过代码清单 6-1 的 Java 代码及其 Class 文件样例, 以实战的方式演示了 Class 的数据是如何存储和访问的. 从下一章开始, 我们将以动态的, 运行时的角度去看看字节码流在虚拟机执行引擎中是如何被解释执行的.</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/20.开发/2000.Java/600.JVM/30.类文件结构🌼.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/106680/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">调优案例分析与实战🌼</div></a> <a href="/pages/ea287c/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">虚拟机类加载机制🌼</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/106680/" class="prev">调优案例分析与实战🌼</a></span> <span class="next"><a href="/pages/ea287c/">虚拟机类加载机制🌼</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/82.e96ff6d7.js" defer></script>
  </body>
</html>
