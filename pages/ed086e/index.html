<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>线程安全与内置锁优化🌼 | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/89.f28c86d3.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/4f30b9/" class="sidebar-link">Java基础</a></li><li><a href="/pages/795eca/" class="sidebar-link">类与继承</a></li><li><a href="/pages/c69152/" class="sidebar-link">抽象类与接口</a></li><li><a href="/pages/d71abb/" class="sidebar-link">内部类</a></li><li><a href="/pages/f06dca/" class="sidebar-link">枚举类</a></li><li><a href="/pages/259f57/" class="sidebar-link">常用类</a></li><li><a href="/pages/84b03b/" class="sidebar-link">关键字</a></li><li><a href="/pages/31b87b/" class="sidebar-link">注解</a></li><li><a href="/pages/f81c0d/" class="sidebar-link">异常</a></li><li><a href="/pages/ae7746/" class="sidebar-link">泛型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>容器类</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/0c88ac/" class="sidebar-link">集合容器类基础</a></li><li><a href="/pages/f805ed/" class="sidebar-link">List与Queue类</a></li><li><a href="/pages/d24b60/" class="sidebar-link">Map与Set类</a></li><li><a href="/pages/54e5d3/" class="sidebar-link">并发容器类</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/67d70f/" class="sidebar-link">多线程基础</a></li><li><a href="/pages/ffc8f7/" class="sidebar-link">Java内置锁</a></li><li><a href="/pages/c43494/" class="sidebar-link">AQS</a></li><li><a href="/pages/eb5b61/" class="sidebar-link">显式锁ReentrantLock</a></li><li><a href="/pages/eb8cbc/" class="sidebar-link">线程协作与JUC组件</a></li><li><a href="/pages/23c79a/" class="sidebar-link">Atomic原子变量与Unsafe类与CAS</a></li><li><a href="/pages/9d6ed4/" class="sidebar-link">线程池与定时任务</a></li><li><a href="/pages/5b787a/" class="sidebar-link">ThreadLocal</a></li><li><a href="/pages/db53d1/" class="sidebar-link">Java并发编程实战(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>IO</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b4d461/" class="sidebar-link">文件操作</a></li><li><a href="/pages/1b9d6c/" class="sidebar-link">IO流操作</a></li><li><a href="/pages/076a47/" class="sidebar-link">Java网络IO模型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>高级特性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d76905/" class="sidebar-link">Lambda表达式</a></li><li><a href="/pages/f7f0e6/" class="sidebar-link">流Stream</a></li><li><a href="/pages/7cc40a/" class="sidebar-link">反射</a></li><li><a href="/pages/945326/" class="sidebar-link">代理</a></li><li><a href="/pages/7fd9b4/" class="sidebar-link">Javaagent</a></li><li><a href="/pages/a3cee0/" class="sidebar-link">Guava</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>JVM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d308f6/" class="sidebar-link">走进JVM🌼</a></li><li><a href="/pages/be0269/" class="sidebar-link">JVM内存区域与对象解析🌼</a></li><li><a href="/pages/48d1be/" class="sidebar-link">垃圾收集器与内存分配策略🌼</a></li><li><a href="/pages/3a4c8a/" class="sidebar-link">JVM性能监控与故障处理工具🌼</a></li><li><a href="/pages/106680/" class="sidebar-link">调优案例分析与实战🌼</a></li><li><a href="/pages/16a914/" class="sidebar-link">类文件结构🌼</a></li><li><a href="/pages/ea287c/" class="sidebar-link">虚拟机类加载机制🌼</a></li><li><a href="/pages/6367b0/" class="sidebar-link">虚拟机字节码执行引擎🌼</a></li><li><a href="/pages/c6c210/" class="sidebar-link">类加载及执行子系统的案例与实战🌼</a></li><li><a href="/pages/deb8b7/" class="sidebar-link">前端编译与优化🌼</a></li><li><a href="/pages/1f8f72/" class="sidebar-link">后端编译与优化🌼</a></li><li><a href="/pages/3d72db/" class="sidebar-link">Java内存模型与线程实现🌼</a></li><li><a href="/pages/ed086e/" aria-current="page" class="active sidebar-link">线程安全与内置锁优化🌼</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/56b9dd/" class="sidebar-link">Java性能问题定位分析</a></li><li><a href="/pages/939bf8/" class="sidebar-link">杂记</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>开发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>软件设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/a5f6fe/" class="sidebar-link">设计基础理论</a></li><li><a href="/pages/3b245c/" class="sidebar-link">设计模式之美(极客时间)🌟</a></li><li><a href="/pages/661fa4/" class="sidebar-link">领域驱动设计(DDD)</a></li><li><a href="/pages/856368/" class="sidebar-link">DDD实战课(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d3fbd2/" class="sidebar-link">数据库基础</a></li><li><a href="/pages/691fc3/" class="sidebar-link">数据库系统原理</a></li><li><a href="/pages/50f6b7/" class="sidebar-link">MySQL基础必知必会</a></li><li><a href="/pages/fe297e/" class="sidebar-link">MySQL特性</a></li><li><a href="/pages/07bdb6/" class="sidebar-link">MySQL索引🌟</a></li><li><a href="/pages/984715/" class="sidebar-link">MySQL锁🌟</a></li><li><a href="/pages/53b588/" class="sidebar-link">MySQL事务🌟</a></li><li><a href="/pages/becc59/" class="sidebar-link">MySQL高级特性</a></li><li><a href="/pages/056463/" class="sidebar-link">MySQL基础架构与存储引擎🌟</a></li><li><a href="/pages/63b46e/" class="sidebar-link">MySQL架构优化与运维</a></li><li><a href="/pages/9995e5/" class="sidebar-link">MySQL优化</a></li><li><a href="/pages/c1c2f6/" class="sidebar-link">MySQL架构</a></li><li><a href="/pages/8e8e0a/" class="sidebar-link">MySQL设计规范</a></li><li><a href="/pages/0219aa/" class="sidebar-link">MySQL运维</a></li><li><a href="/pages/e288c0/" class="sidebar-link">MySQL中间件</a></li><li><a href="/pages/c6cafa/" class="sidebar-link">MySQL实战45讲(极客时间)🌟</a></li><li><a href="/pages/4a6106/" class="sidebar-link">数据库LeetCode题目</a></li><li><a href="/pages/2827f1/" class="sidebar-link">数据库综合问题</a></li><li><a href="/pages/c616d5/" class="sidebar-link">MongoDB</a></li><li><a href="/pages/075e71/" class="sidebar-link">ClickHouse</a></li><li><a href="/pages/d74f6d/" class="sidebar-link">Doris</a></li><li><a href="/pages/b6bad9/" class="sidebar-link">HBase</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Spring</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bd8eb8/" class="sidebar-link">Spring Boot基础</a></li><li><a href="/pages/d0d797/" class="sidebar-link">Spring Boot应用整合</a></li><li><a href="/pages/314cdc/" class="sidebar-link">Spring MVC基础</a></li><li><a href="/pages/80de47/" class="sidebar-link">Spring AOP基础</a></li><li><a href="/pages/f0d4d6/" class="sidebar-link">Spring事务基础</a></li><li><a href="/pages/db6afe/" class="sidebar-link">Spring IOC源码分析-概览</a></li><li><a href="/pages/672e98/" class="sidebar-link">Spring IOC源码分析-getBean()</a></li><li><a href="/pages/695b90/" class="sidebar-link">Spring IOC源码分析-createBean()</a></li><li><a href="/pages/f89bcf/" class="sidebar-link">Spring AOP源码分析</a></li><li><a href="/pages/3b52f4/" class="sidebar-link">Spring事务源码分析</a></li><li><a href="/pages/186902/" class="sidebar-link">Spring Boot源码分析</a></li><li><a href="/pages/16bd1c/" class="sidebar-link">Spring MVC源码分析</a></li><li><a href="/pages/3d0c1f/" class="sidebar-link">Spring Cloud</a></li><li><a href="/pages/d56156/" class="sidebar-link">Spring编程常见错误50例(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>MyBatis</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bb032d/" class="sidebar-link">基础</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>工具与环境</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c9cb6e/" class="sidebar-link">Arthas</a></li><li><a href="/pages/3172bb/" class="sidebar-link">Maven</a></li><li><a href="/pages/37f79a/" class="sidebar-link">Git</a></li><li><a href="/pages/db9f99/" class="sidebar-link">环境搭建与部署</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c725f5/" class="sidebar-link">测试基础</a></li><li><a href="/pages/7893a4/" class="sidebar-link">单元测试</a></li><li><a href="/pages/af9f25/" class="sidebar-link">压力测试</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>代码质量</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ec2b81/" class="sidebar-link">代码整洁之道</a></li><li><a href="/pages/474cdf/" class="sidebar-link">阿里巴巴编程规范</a></li><li><a href="/pages/c47e15/" class="sidebar-link">代码之丑(极客时间)🌸</a></li><li><a href="/pages/4d4606/" class="sidebar-link">Java业务开发常见错误100例(极客时间)🌸</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/develop/#开发" data-v-06970110>开发</a></li><li data-v-06970110><a href="/develop/#Java" data-v-06970110>Java</a></li><li data-v-06970110><a href="/develop/#JVM" data-v-06970110>JVM</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">线程安全与内置锁优化🌼<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_51-线程安全与内置锁优化🌼"><a href="#_51-线程安全与内置锁优化🌼" class="header-anchor">#</a> 51.线程安全与内置锁优化🌼</h1> <p>本节对应《深入理解 Java 虚拟机》的第十三章</p> <h4 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h4> <p>在软件业发展的初期, 程序编写都是以算法为核心的, 程序员会把数据和过程分别作为独立的部分来考虑, 数据代表问题空间中的客体, 程序代码则用于处理这些数据, 这种思维方式直接站在计算机的角度去抽象问题和解决问题, 被称为<strong>面向过程</strong>的编程思想. 与此相对, 面向对象的编程思想则站在现实世界的角度去抽象和解决问题, 它把数据和行为都看作对象的一部分, 这样可以让程序员能以符合现实世界的思维方式来编写和组织程序.</p> <p>面向对象的编程思想极大地提升了现代软件开发的效率和软件可以达到的规模, 但是现实世界与计算机世界之间不可避免地存在一些差异. 例如, 人们很难想象现实中的对象在一项工作进行期间, 会被不停地中断和切换, 对象的属性(数据)可能会在中断期间被修改和变脏, 而这些事件在计算机世界中是再普通不过的事情. 有时候, 良好的设计原则不得不向现实做出一些妥协, 大家必须保证程序在计算机中正确无误地运行, 然后再考虑如何将代码组织得更好, 让程序运行得更快. 对于本章的主题 &quot;高效并发&quot; 来说, 首先需要保证并发的正确性, 然后在此基础上来实现高效. 本章就先从<strong>如何保证并发的正确性及如何实现线程安全说起</strong>.</p> <h4 id="线程安全"><a href="#线程安全" class="header-anchor">#</a> 线程安全</h4> <p>《Java 并发编程实战(Java Concurrency In Practice)》为 &quot;线程安全&quot; 做出了一个比较恰当的定义: &quot;<strong>当多个线程同时访问一个对象时, 如果不用考虑这些线程在运行时环境下的调度和交替执行, 也不需要进行额外的同步, 或者在调用方进行任何其他的协调操作, 调用这个对象的行为都可以获得正确的结果, 那就称这个对象是线程安全的</strong>&quot;.</p> <p>这个定义就很严谨而且有可操作性, 它要求线程安全的代码都必须<strong>具备一个共同特征</strong>: <strong>代码本身封装了所有必要的正确性保障手段(如互斥同步等), 令调用者无须关心多线程下的调用问题, 更无须自己实现任何措施来保证多线程环境下的正确调用</strong>. 这点听起来简单, 但其实并不容易做到, 在许多场景中, 都会将这个定义弱化一些. 如果把 &quot;调用这个对象的行为&quot; 限定为 &quot;单次调用&quot;, 这个定义的其他描述能够成立的话, 那么就已经可以称它是线程安全了. 为什么要弱化这个定义? 现在先暂且放下这个问题, 稍后再详细探讨.</p> <h5 id="_1-java语言中的线程安全"><a href="#_1-java语言中的线程安全" class="header-anchor">#</a> 1.Java语言中的线程安全</h5> <p>前面已经有了线程安全的一个可操作的定义, 那接下来就讨论一下: <strong>在 Java 语言中, 线程安全具体是如何体现的? 有哪些操作是线程安全的</strong>? 这里讨论的线程安全, 将以多个线程之间存在共享数据访问为前提. 因为如果根本不存在多线程, 又或者一段代码根本不会与其他线程共享数据, 那么从线程安全的角度上看, 程序是串行执行还是多线程执行对它来说是没有什么区别的.</p> <p>为了更深入地理解线程安全, 在这里可以不把线程安全当作一个非真即假的二元排他选项来看待, 而是按照线程安全的  <strong>&quot;安全程度&quot; 由强至弱来排序</strong>, 可以将 Java 语言中各种操作共享的数据分为以下五类: <mark><strong>不可变, 绝对线程安全, 相对线程安全, 线程兼容和线程对立</strong></mark>.</p> <p><strong>下面介绍的就是什么是线程安全, 如何理解线程安全的粒度?</strong></p> <h6 id="_1-不可变"><a href="#_1-不可变" class="header-anchor">#</a> (1)不可变</h6> <p>在 Java 语言里面(特指 JDK 5 以后, 即 Java 内存模型被修正之后的 Java 语言), <strong>不可变(Immutable)的对象一定是线程安全的, 无论是对象的方法实现还是方法的调用者, 都不需要再进行任何线程安全保障措施</strong>. 前面讲解 &quot;final 关键字带来的可见性&quot; 时曾经提到过这一点: <strong>只要一个不可变的对象被正确地构建出来(即没有发生 this 引用逃逸的情况), 那其外部的可见状态永远都不会改变, 永远都不会看到它在多个线程之中处于不一致的状态</strong>. &quot;不可变&quot; 带来的安全性是最直接, 最纯粹的.</p> <p>Java 语言中, <strong>如果多线程共享的数据是一个基本数据类型, 那么只要在定义时使用 final 关键字修饰它就可以保证它是不可变的</strong>. 如果共享数据是一个对象, 由于 Java 语言目前暂时还没有提供值类型的支持, 那就需要对象自行保证其行为不会对其状态产生任何影响才行. 如果读者没想明白这句话所指的意思, 不妨类比 java.lang.String 类的对象实例, 它是一个<strong>典型的不可变对象</strong>, 用户调用它的 substring(), replace() 和 concat() 这些方法都<strong>不会影响它原来的值, 只会返回一个新构造的字符串对象</strong>.</p> <p><strong>保证对象行为不影响自己状态的途径有很多种, 最简单的一种就是把对象里面带有状态的变量都声明为 final, 这样在构造函数结束之后, 它就是不可变的</strong>, 例如代码清单 13-1 中所示的 java.lang.Integer 构造函数, 它通过将内部状态变量 value 定义为 final 来保障状态不变.</p> <blockquote><p>代码清单13-1 JDK 中 Integer 类的构造函数</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * The value of the &lt;code&gt;Integer&lt;/code&gt;.
 * @serial
 */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>

<span class="token comment">/**
 * Constructs a newly allocated &lt;code&gt;Integer&lt;/code&gt; object that
 * represents the specified &lt;code&gt;int&lt;/code&gt; value.
 *
 * @param   value   the value to be represented by the
 * &lt;code&gt;Integer&lt;/code&gt; object.
 */</span>
<span class="token keyword">public</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在 Java 类库 API 中符合<strong>不可变要求的类型</strong>, 除了上面提到的 String 之外, 常用的还有枚举类型及 java.lang.Number 的部分子类, 如 Long 和 Double 等数值包装类型, BigInteger 和 BigDecimal 等大数据类型. 但同为 Number 子类型的原子类 AtomicInteger 和 AtomicLong 则是可变的, 读者不妨看看这两个原子类的源码, 想一想为什么它们要设计成可变的.</p> <h6 id="_2-绝对线程安全"><a href="#_2-绝对线程安全" class="header-anchor">#</a> (2)绝对线程安全</h6> <p>绝对的线程安全能够完全满足线程安全的定义, 这个定义其实是很严格的, 一个类要达到 &quot;不管运行时环境如何, 调用者都不需要任何额外的同步措施&quot; 可能需要付出非常高昂的, 甚至不切实际的代价. 在 Java API 中标注自己是线程安全的类, 大多数都不是绝对的线程安全. 可以通过 Java API 中一个不是 &quot;绝对线程安全&quot; 的 &quot;线程安全类型&quot; 来看看这个语境里的 &quot;<strong>绝对</strong>&quot; 究竟是什么意思.</p> <p>如果说 java.util.Vector 是一个线程安全的容器, 相信所有的 Java 程序员对此都不会有异议, 因为它的 add(), get() 和 size() 等方法都是被 synchronized 修饰的, 尽管这样效率不高, 但保证了具备原子性, 可见性和有序性. 不过, 即使它所有的方法都被修饰成 synchronized, 也不意味着调用它的时候就永远都不再需要同步手段了, 请看看代码清单 13-2 中的测试代码.</p> <blockquote><p>代码清单13-2 对 Vector 线程安全的测试</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Vector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> vector <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            vector<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">Thread</span> removeThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    vector<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> printThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>vector<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        removeThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        printThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 不要同时产生过多的线程, 否则会导致操作系统假死</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">activeCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>运行结果如下:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>Exception in thread &quot;Thread-132&quot; java.lang.ArrayIndexOutOfBoundsException:
Array index out of range: 17
    at java.util.Vector.remove(Vector.java:777)
    at org.fenixsoft.mulithread.VectorTest$1.run(VectorTest.java:21)
    at java.lang.Thread.run(Thread.java:662)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>很明显, 尽管这里使用到的 Vector 的 get(), remove() 和 size() 方法都是同步的, 但是在多线程的环境中, 如果不在<strong>方法调用端做额外的同步措施</strong>, 使用这段代码仍然是<strong>不安全</strong>的. 因为如果另一个线程恰好在错误的时间里删除了一个元素, 导致序号 i 已经不再可用, 再用 i 访问数组就会抛出一个 ArrayIndexOutOfBoundsException 异常. 如果要保证这段代码能正确执行下去, 所以不得不把 removeThread 和 printThread 的定义改成代码清单 13-3 所示的这样.</p> <blockquote><p>代码清单13-3 必须加入同步保证 Vector 访问的线程安全性</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Thread</span> removeThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>vector<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                vector<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Thread</span> printThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>vector<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>vector<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>假如 Vector 一定要做到绝对的线程安全, 那就必须<strong>在它内部维护一组一致性的快照访问才行</strong>, 每次对其中元素进行改动都要产生新的快照, 这样要付出的时间和空间成本都是非常大的.</p> <h6 id="_3-相对线程安全"><a href="#_3-相对线程安全" class="header-anchor">#</a> (3)相对线程安全</h6> <p><strong>相对线程安全就是通常意义上所讲的线程安全, 它需要保证对这个对象单次的操作是线程安全的</strong>, 在调用的时候不需要进行额外的保障措施, 但是对于一些特定顺序的连续调用, 就可能需要在调用端使用额外的同步手段来保证调用的正确性. 代码清单 13-2 和代码清单 13-3 就是相对线程安全的案例.</p> <p><strong>在 Java 语言中, 大部分声称线程安全的类都属于这种类型</strong>, 例如 Vector, HashTable, Collections 的 synchronizedCollection() 方法包装的集合等.</p> <h6 id="_4-线程兼容"><a href="#_4-线程兼容" class="header-anchor">#</a> (4)线程兼容</h6> <p><strong>线程兼容是指对象本身并不是线程安全的, 但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用</strong>. 平常说一个类不是线程安全的, 通常就是指这种情况. Java 类库 API 中大部分的类都是线程兼容的, 如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等.</p> <h6 id="_5-线程对立"><a href="#_5-线程对立" class="header-anchor">#</a> (5)线程对立</h6> <p><strong>线程对立是指不管调用端是否采取了同步措施, 都无法在多线程环境中并发使用代码</strong>. 由于 Java 语言天生就支持多线程的特性, 线程对立这种排斥多线程的代码是很少出现的, 而且通常都是有害的, 应当尽量避免.</p> <p>一个线程对立的例子是 Thread 类的 suspend() 和 resume() 方法. 如果有两个线程同时持有一个线程对象, 一个尝试去中断线程, 一个尝试去恢复线程, 在并发进行的情况下, 无论调用时是否进行了同步, 目标线程都存在死锁风险. 假如 suspend() 中断的线程就是即将要执行 resume() 的那个线程, 那就肯定要产生死锁了. 也正是这个原因, <strong>suspend() 和 resume() 方法都已经被声明废弃</strong>了. 常见的线程对立的操作还有 System.setIn(), Sytem.setOut() 和 System.runFinalizersOnExit() 等.</p> <h5 id="_2-线程安全的实现方法"><a href="#_2-线程安全的实现方法" class="header-anchor">#</a> 2.线程安全的实现方法</h5> <p>了解过<strong>什么是线程安全</strong>之后, 紧接着的一个问题就是应该<strong>如何实现线程安全</strong>. 这听起来似乎是一件由代码如何编写来决定的事情, 不应该出现在讲解 Java 虚拟机的书里. 确实, 如何实现线程安全与代码编写有很大的关系, 但虚拟机提供的同步和锁机制也起到了至关重要的作用. 在本节中, 如何编写代码实现线程安全, 以及虚拟机如何实现同步与锁这两方面都会涉及, 相对而言更偏重后者一些, 只要读者明白了 <strong>Java 虚拟机线程安全措施的原理与运作过程</strong>, 自己再去思考代码如何编写就不是一件困难的事情了.</p> <p>同步是指在多个线程并发访问共享数据时, 保证共享数据在同一个时刻只被一个(或者是一些, 使用信号量的时候)线程使用.</p> <p>保证线程间的<strong>安全同步</strong>有以下几种实现方式:</p> <ul><li><strong>阻塞同步</strong>(悲观策略): Synchronized, ReentrantLock.</li> <li><strong>非阻塞同步</strong>(乐观策略): CAS.</li> <li><strong>无同步</strong>: ThreadLocal, 栈封闭, 不可变类.</li></ul> <h6 id="_1-互斥-阻塞同步"><a href="#_1-互斥-阻塞同步" class="header-anchor">#</a> (1)互斥/阻塞同步</h6> <p>互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销, 因此这种同步也被称为<mark><strong>阻塞同步</strong></mark>.</p> <p><strong>互斥同步</strong>是一种最常见也是最主要的并发正确性保障手段. <strong>同步是指在多个线程并发访问共享数据时, 保证共享数据在同一个时刻只被一条(或者是一些, 当使用信号量的时候)线程使用</strong>. 而互斥是实现同步的一种手段, <strong>临界区(Critical Section), 互斥量(Mutex)和信号量(Semaphore)</strong> 都是常见的互斥实现方式. 因此在 &quot;互斥同步&quot; 这四个字里面, <mark><strong>互斥是因, 同步是果; 互斥是方法, 同步是目的</strong></mark>.</p> <p>互斥同步可以使用 <strong>synchronized</strong> 和 <strong>ReentrantLock</strong> 实现. 它是一种<strong>悲观</strong>的并发策略, 主要的问题就是线程<strong>阻塞和唤醒</strong>可能带来性能问题.</p> <blockquote><p>synchronized</p></blockquote> <p>参考: synchronized原理解析</p> <p><mark><strong>在 Java 里面, 最基本的互斥同步手段就是 synchronized 关键字, 这是一种块结构的同步语法. synchronized 关键字经过 Javac 编译之后, 会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令. 这两个字节码指令都需要一个 reference 类型的参数来指明要锁定和解锁的对象. 如果 Java 源码中的 synchronized 明确指定了对象参数, 那就以这个对象的引用作为 reference; 如果没有明确指定, 那将根据 synchronized 修饰的方法类型(如实例方法或类方法), 来决定是取代码所在的对象实例还是取类型对应的 Class 对象来作为线程要持有的锁.</strong></mark></p> <p>根据《Java 虚拟机规范》的要求, 在执行 monitorenter 指令时, 首先要去尝试获取对象的锁. 如果这个对象没被锁定, 或者当前线程已经持有了那个对象的锁, 就把<strong>锁的计数器的值增加一</strong>, 而在执行 monitorexit 指令时会将<strong>锁计数器的值减一</strong>. 一旦计数器的值为零, 锁随即就被释放了. 如果获取对象锁失败, 那当前线程就应当被阻塞等待, 直到请求锁定的对象被持有它的线程释放为止.</p> <p>从功能上看, 根据以上《Java 虚拟机规范》对 monitorenter 和 monitorexit 的行为描述, 可以得出两个关于 synchronized 的直接推论, 这是使用它时需特别注意的:</p> <ul><li><strong>被 synchronized 修饰的同步块对同一条线程来说是可重入的. 这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况</strong>.</li> <li><strong>被 synchronized 修饰的同步块在持有锁的线程执行完毕并释放锁之前, 会无条件地阻塞后面其他线程的进入</strong>. 这意味着无法像处理某些数据库中的锁那样, 强制已获取锁的线程释放锁; 也无法强制正在等待锁的线程中断等待或超时退出.</li></ul> <p>从执行成本的角度看, 持有锁是一个<strong>重量级</strong>(Heavy-Weight)的操作. 在主流 Java 虚拟机实现中, Java 的线程是映射到操作系统的原生内核线程之上的, <mark><strong>如果要阻塞或唤醒一条线程, 则需要操作系统来帮忙完成, 这就不可避免地陷入用户态到核心态的转换中, 进行这种状态转换需要耗费很多的处理器时间</strong></mark>. 尤其是对于代码特别简单的同步块(譬如被 synchronized 修饰的 getter() 或 setter() 方法), 状态转换消耗的时间甚至会比用户代码本身执行的时间还要长. 因此才说, synchronized 是 Java 语言中一个重量级的操作, 有经验的程序员都只会在确实必要的情况下才使用这种操作. 而虚拟机本身也会进行一些优化, 譬如在通知操作系统阻塞线程之前加入一段自旋等待过程, 以避免频繁地切入核心态之中. 稍后会专门介绍 Java 虚拟机锁优化的措施.</p> <blockquote><p>ReentrantLock</p></blockquote> <p>还可以使用 JUC 包中的 <strong>ReentrantLock</strong> 实现互斥同步. 相比 synchronized, ReentrantLock 增加了一些高级功能, 主要以下 3 项: 等待可中断, 可实现公平锁, 以及锁可以绑定多个条件(参考: 相比synchronized的拓展功能).</p> <h6 id="_2-非阻塞同步"><a href="#_2-非阻塞同步" class="header-anchor">#</a> (2)非阻塞同步</h6> <p>从解决问题的方式上看, 互斥同步属于一种<strong>悲观的并发策略</strong>, 其总是认为<strong>只要不去做正确的同步措施(例如加锁), 那就肯定会出现问题, 无论共享的数据是否真的会出现竞争, 它都会进行加锁</strong>(这里讨论的是概念模型, 实际上虚拟机会优化掉很大一部分不必要的加锁), 这将会导致用户态到核心态转换, 维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开销.</p> <p>随着硬件指令集的发展, 已经有了另外一个选择: <mark><strong>基于冲突检测的乐观并发策略</strong></mark>, 通俗地说就是<strong>不管风险, 先进行操作, 如果没有其他线程争用共享数据, 那操作就直接成功了; 如果共享的数据的确被争用, 产生了冲突, 那再进行其他的补偿措施, 最常用的补偿措施是不断地重试, 直到出现没有竞争的共享数据为止</strong>. 这种乐观并发策略的实现不再需要把线程阻塞挂起, 因此这种同步操作被称为<mark><strong>非阻塞同步</strong></mark>, 使用这种措施的代码也常被称为<strong>无锁(Lock-Free)编程</strong>.</p> <p>为什么笔者说使用乐观并发策略需要 &quot;硬件指令集的发展&quot;? 因为必须<mark><strong>要求操作和冲突检测这两个步骤具备原子性</strong></mark>. 靠什么来保证原子性? 如果这里再使用互斥同步来保证就完全失去意义了, <strong>所以只能靠硬件来实现这件事情, 硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成</strong>, 这类指令常用的有:</p> <ul><li>测试并设置(Test-and-Set);</li> <li>获取并增加(Fetch-and-Increment);</li> <li>交换(Swap);</li> <li><mark><strong>比较并交换</strong></mark>(Compare-and-Swap, 下文称 <strong>CAS</strong>);</li> <li>加载链接/条件储存(Load-Linked/Store-Conditional, 下文称 LL/SC).</li></ul> <p>其中, 前面的三条是 20 世纪就已经存在于大多数指令集之中的处理器指令, 后面的两条是现代处理器新增的, 而且这两条指令的目的和功能也是类似的. 在 IA64, x86 指令集中有用 cmpxchg 指令完成的 CAS 功能, 在 SPARC-TSO 中也有用 casa 指令实现的, 而在 ARM 和 PowerPC 架构下, 则需要使用一对 ldrex/strex 指令来完成 LL/SC 的功能. 因为 <strong>Java 里最终暴露出来的是 CAS 操作</strong>, 所以以 CAS 指令为例进行讲解.</p> <p><mark><strong>CAS 指令需要有三个操作数, 分别是内存位置(在 Java 中可以简单地理解为变量的内存地址, 用 V 表示), 旧的预期值(用 A 表示)和准备设置的新值(用 B 表示). CAS 指令执行时, 当且仅当 V 符合 A 时, 处理器才会用 B 更新 V 的值, 否则它就不执行更新. 但是, 不管是否更新了 V 的值, 都会返回 V 的旧值, 上述的处理过程是一个原子操作, 执行期间不会被其他线程中断</strong></mark>.</p> <p>在 JDK 5 之后, Java 类库中才开始使用 CAS 操作, 该操作由 sun.misc.Unsafe 类里面的 <strong>compareAndSwapInt()</strong>  和 <strong>compareAndSwapLong()</strong>  等几个方法包装提供. HotSpot 虚拟机在内部对这些方法做了特殊处理, <strong>即时编译出来的结果就是一条平台相关的处理器 CAS 指令</strong>, 没有方法调用的过程, 或者可以认为是无条件内联进去了. 不过由于 Unsafe 类在设计上就不是提供给用户程序调用的类(<code>Unsafe::getUnsafe()</code>​ 的代码中限制了只有启动类加载器(Bootstrap ClassLoader)加载的 Class 才能访问它), 因此在 JDK 9 之前只有 Java 类库可以使用 CAS, 譬如 J.U.C 包里面的整数原子类, 其中的 compareAndSet() 和 getAndIncrement() 等方法都使用了 Unsafe 类的 CAS 操作来实现. 而如果用户程序也有使用 CAS 操作的需求, 那要么就<strong>采用反射手段突破 Unsafe 的访问限制</strong>, 要么就只能通过 Java 类库 API 来间接使用它. 直到 JDK 9 之后, Java 类库才在 <strong>VarHandle 类里开放了面向用户程序使用的 CAS 操作</strong>.</p> <p>下面将用一段在前面章节中没有解决的问题代码来介绍如何通过 CAS 操作避免阻塞同步. 测试的代码如代码清单 12-1 所示, 为了节省版面就不重复贴到这里了. 这段代码里曾经通过 20 个线程自增 10000 次的操作来证明 volatile 变量不具备原子性, 那么如何才能让它<strong>具备原子性</strong>呢? 之前的解决方案是把 race++ 操作或 increase() 方法用同步块包裹起来, 这毫无疑问是一个解决方案, 但是如果改成代码清单 13-4 所示的写法, 效率将会提高许多.</p> <blockquote><p>代码清单13-4 Atomic 的原子自增运算</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * Atomic 变量自增运算测试
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">AtomicInteger</span> race <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        race<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">THREADS_COUNT</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span><span class="token punctuation">[</span><span class="token punctuation">]</span> threads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">[</span><span class="token constant">THREADS_COUNT</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">THREADS_COUNT</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">activeCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>race<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>运行结果如下:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>200000
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>使用 AtomicInteger 代替 int 后</strong>, 程序输出了正确的结果, 这一切都要<strong>归功于 incrementAndGet() 方法的原子性</strong>. 它的实现其实非常简单, 如代码清单 13-5 所示.</p> <blockquote><p>代码清单13-5 incrementAndGet()方法的 JDK 源码</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * Atomically increment by one the current value.
 * @return the updated value
 */</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> next <span class="token operator">=</span> current <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">// CAS</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>incrementAndGet() 方法在一个无限循环中, 不断尝试将一个比当前值大一的新值赋值给自己. 如果失败了, 那说明在执行 CAS 操作的时候, 旧值已经发生改变, 于是再次循环进行下一次操作, 直到设置成功为止</strong>.</p> <p>尽管 CAS 看起来很美好, 既简单又高效, 但显然这种操作无法涵盖互斥同步的所有使用场景, 并且 CAS 从语义上来说并不是真正完美的, 它存在一个逻辑漏洞: 如果一个变量 V 初次读取的时候是 A 值, 并且在准备赋值的时候检查到它仍然为 A 值, 那就能说明它的值没有被其他线程改变过了吗? 这是不能的, 因为如果在这段期间它的值曾经被改成 B, 后来又被改回为 A, 那 CAS 操作就会误认为它从来没有被改变过. 这个漏洞称为 CAS 操作的 &quot;<mark><strong>ABA 问题</strong></mark>&quot;. J.U.C 包为了解决这个问题, 提供了一个<strong>带有标记的原子引用类 AtomicStampedReference</strong>, 它可以通过控制变量值的版本来保证 CAS 的正确性. 不过目前来说这个类处于相当鸡肋的位置, 大部分情况下 ABA 问题不会影响程序并发的正确性, 如果需要解决 ABA 问题, 改用传统的互斥同步可能会比原子类更为高效.</p> <h6 id="_3-无同步方案"><a href="#_3-无同步方案" class="header-anchor">#</a> (3)无同步方案</h6> <p><strong>要保证线程安全, 也并非一定要进行阻塞或非阻塞同步</strong>, 同步与线程安全两者没有必然的联系. <strong>同步只是保障存在共享数据争用时正确性的手段, 如果能让一个方法本来就不涉及共享数据, 那它自然就不需要任何同步措施去保证其正确性, 因此会有一些代码天生就是线程安全的</strong>.</p> <blockquote><p>可重入代码(Reentrant Code)</p></blockquote> <p>可重入代码代码又称纯代码(Pure Code), 是指可以在代码执行的<strong>任何时刻中断它</strong>, 转而去执行另外一段代码(包括递归调用它本身), 而在控制权返回后, 原来的程序不会出现任何错误, 也不会对结果有所影响.</p> <p>在特指多线程的上下文语境里(不涉及信号量等因素), 可以认为可重入代码是线程安全代码的一个真子集, 这意味着相对线程安全来说, 可重入性是更为基础的特性, 它可以保证代码线程安全, 即<strong>所有可重入的代码都是线程安全的</strong>, 但并非所有的线程安全的代码都是可重入的.</p> <p><strong>可重入代码有一些共同的特征, 例如, 不依赖全局变量, 存储在堆上的数据和公用的系统资源, 用到的状态量都由参数中传入, 不调用非可重入的方法等</strong>. 可以通过一个比较简单的原则来判断代码是否具备可重入性: <mark><strong>如果一个方法的返回结果是可以预测的, 只要输入了相同的数据, 就都能返回相同的结果, 那它就满足可重入性的要求, 当然也就是线程安全的</strong></mark>.</p> <blockquote><p>线程本地存储(ThreadLocal)</p></blockquote> <p>线程本地存储(Thread Local Storage): 如果一段代码中所需要的数据必须与其他代码共享, 那就看看这些共享数据的代码是否能保证在同一个线程中执行. 如果能保证, 就可以<strong>把共享数据的可见范围限制在同一个线程之内</strong>, 这样无须同步也能保证线程之间不出现数据争用的问题.</p> <p>符合这种特点的应用并不少见, 大部分使用消费队列的架构模式(如 &quot;生产者-消费者&quot; 模式)都会将产品的消费过程限制在一个线程中消费完, 其中最重要的一种应用实例就是经典 Web 交互模型中的 &quot;一个请求对应一个服务器线程&quot;(Thread-per-Request)的处理方式, 这种处理方式的广泛应用使得很多 Web 服务端应用都可以<strong>使用线程本地存储</strong>来解决线程安全问题.</p> <p>Java 语言中, 如果一个变量要被多线程访问, 可以使用 volatile 关键字将它声明为 &quot;易变的&quot;; 如果一个变量只要被某个线程独享, Java 中就没有类似 C++ 中 __declspec(thread) 这样的关键字去修饰, 不过还是可以通过 <mark><strong>java.lang.ThreadLocal</strong></mark> 类来实现线程本地存储的功能. <mark><strong>每一个线程的 Thread 对象中都有一个 ThreadLocalMap 对象, 这个对象存储了一组以 ThreadLocal.threadLocalHashCode 为键, 以本地线程变量为值的 K-V 值对, ThreadLocal 对象就是当前线程的 ThreadLocalMap 的访问入口, 每一个 ThreadLocal 对象都包含了一个独一无二的 threadLocalHashCode 值, 使用这个值就可以在线程 K-V 值对中找回对应的本地线程变量</strong></mark>. (参考: ThreadLocal基础)</p> <blockquote><p>栈封闭</p></blockquote> <p>多个线程访问同一个<strong>方法的局部变量</strong>时, 不会出现线程安全问题, 因为局部变量存储在<strong>虚拟机栈</strong>中, 属于<strong>线程私有变量</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackClosedExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add100</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 方法内部局部变量</span>
        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            cnt<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">StackClosedExample</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackClosedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> example<span class="token punctuation">.</span><span class="token function">add100</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> example<span class="token punctuation">.</span><span class="token function">add100</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language-html line-numbers-mode"><pre class="language-html"><code>100
100
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>不可变类</p></blockquote> <p>不可变(<strong>Immutable</strong>)的对象一定是线程安全的, 不需要采取任何的线程安全保障措施. 参考: 不可变类.</p> <h4 id="内置锁优化"><a href="#内置锁优化" class="header-anchor">#</a> 内置锁优化</h4> <p>在早期 synchronized 是重量级的锁且效率低, 因为 monitor 是<strong>依赖底层操作系统</strong>来实现的, 而操作系统实现线程之间的转换需要从用户态转换到内核态, 这个转换要浪费很多时间.</p> <p>因此, HotSpot 虚拟机开发团队在这个版本上花费了大量的资源去实现各种锁优化技术, 如<mark><strong>适应性自旋(Adaptive Spinning), 锁消除(Lock Elimination), 锁膨胀(Lock Coarsening), 轻量级锁(Lightweight Locking), 偏向锁(Biased Locking)</strong></mark> 等, 这些技术都是为了在线程之间更高效地共享数据及解决竞争问题, 从而提高程序的执行效率.</p> <h5 id="_1-自旋锁与自适应自旋"><a href="#_1-自旋锁与自适应自旋" class="header-anchor">#</a> 1.自旋锁与自适应自旋</h5> <p>前面讨论互斥同步的时候, 提到了<strong>互斥同步对性能最大的影响是阻塞的实现</strong>, 挂起线程和恢复线程的操作都需要转入内核态中完成, 这些操作给 Java 虚拟机的并发性能带来了很大的压力. 同时, 虚拟机的开发团队也注意到在许多应用上, <strong>共享数据的锁定状态只会持续很短的一段时间, 为了这段时间去挂起和恢复线程并不值得</strong>. 现在绝大多数的个人电脑和服务器都是多路(核)处理器系统, 如果物理机器有一个以上的处理器或者处理器核心, 能让两个或以上的线程同时并行执行, 就可以让后面请求锁的那个线程 &quot;稍等一会&quot;, 但不放弃处理器的执行时间, 看看持有锁的线程是否很快就会释放锁. <mark><strong>为了让线程等待, 只须让线程执行一个忙循环(自旋), 这项技术就是所谓的自旋锁</strong></mark>.</p> <p>自旋锁在 JDK 1.4.2 中就已经引入, 只不过默认是关闭的, 可以使用 <code>-XX: +UseSpinning</code>​ 参数来开启, 在 JDK 6 中就已经改为默认开启了. 自旋等待不能代替阻塞, 且先不说对处理器数量的要求, 自旋等待本身虽然避免了线程切换的开销, <strong>但它是要占用处理器时间的</strong>, 所以如果锁被占用的时间很短, 自旋等待的效果就会非常好, 反之如果锁被占用的时间很长, 那么自旋的线程只会白白消耗处理器资源, 而不会做任何有价值的工作, 这就会带来性能的浪费. 因此<strong>自旋等待的时间必须有一定的限度, 如果自旋超过了限定的次数仍然没有成功获得锁, 就应当使用传统的方式去挂起线程</strong>. 自旋次数的默认值是十次, 用户也可以使用参数 <code>-XX: PreBlockSpin</code>​ 来自行更改.</p> <p>不过无论是默认值还是用户指定的自旋次数, 对整个 Java 虚拟机中所有的锁来说都是相同的. 在 JDK 6 中对自旋锁的优化, 引入了<strong>自适应的自旋</strong>. 自适应意味着自旋的时间不再是固定的了, 而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的. 如果在同一个锁对象上, 自旋等待刚刚成功获得过锁, 并且持有锁的线程正在运行中, 那么虚拟机就会认为这次自旋也很有可能再次成功, 进而允许自旋等待持续相对更长的时间, 比如持续 100 次忙循环. 另一方面, 如果对于某个锁, 自旋很少成功获得过锁, 那在以后要获取这个锁时将有可能直接省略掉自旋过程, 以避免浪费处理器资源. 有了自适应自旋, 随着程序运行时间的增长及性能监控信息的不断完善, 虚拟机对程序锁的状况预测就会越来越精准, 虚拟机就会变得越来越 &quot;聪明&quot; 了.</p> <p>典型场景如下, T1 线程先进入到同步逻辑中, 当 T2 需要进到同步块逻辑时, 在竞争不激烈的情况下, 无需进行阻塞(<strong>放弃 CPU 使用权</strong>), 而只需要进行自旋(<strong>不放弃 CPU 使用权</strong>), 等到 T1 退出同步逻辑之后, T2 再直接进入同步逻辑, 而无需再次竞争锁.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220601232020635.png" alt="image-20220601232020635"></p> <p>自旋锁虽然能避免进入阻塞状态从而减少开销, 但是它需要进行忙循环操作<strong>占用 CPU</strong> 时间, 它只适用于共享数据的<strong>锁定状态很短</strong>的场景. 如果太长就太多的忙循环了.</p> <h5 id="_2-锁消除"><a href="#_2-锁消除" class="header-anchor">#</a> 2.锁消除</h5> <p><mark><strong>锁消除</strong></mark>​<strong>是指虚拟机即时编译器在运行时, 对一些代码要求同步, 但是对被</strong>​<mark><strong>检测到不可能存在共享数据竞争的锁进行消除</strong></mark>​ <strong>. 锁消除的主要判定依据来源于</strong>​<mark><strong>逃逸分析</strong></mark>​<strong>的数据支持, 如果判断到一段代码中, 在堆上的所有数据都不会逃逸出去被其他线程访问到, 那就可以把它们当作栈上数据对待, 认为它们是线程私有的, 同步加锁自然就无须再进行</strong>.</p> <p>也许读者会有疑问, 变量是否逃逸, 对于虚拟机来说是需要使用复杂的过程间分析才能确定的, 但是程序员自己应该是很清楚的, 怎么会在明知道不存在数据争用的情况下还要求同步呢? 这个问题的答案是: <strong>有许多同步措施并不是程序员自己加入的</strong>, 同步的代码在 Java 程序中出现的频繁程度也许超过了大家的想象.</p> <p>看看下面的例子, 这段非常简单的代码仅仅是输出三个字符串相加的结果, 无论是源代码字面上, 还是程序语义上都没有进行同步.</p> <blockquote><p>代码清单13-6 一段看起来没有同步的代码</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">concatString</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">,</span> <span class="token class-name">String</span> s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> s1 <span class="token operator">+</span> s2 <span class="token operator">+</span> s3<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>由于 String 是一个不可变的类, 对字符串的连接操作总是通过<strong>生成新的 String 对象</strong>来进行的, 因此 Javac 编译器会对 String 连接做自动优化. 在 JDK 5 之前, 字符串加法会转化为 StringBuffer 对象的连续 append() 操作, 在 JDK 5 及以后的版本中, 会转化为 StringBuilder 对象的连续 append() 操作. 因此 StringBuffer 类是通过给方法加 <strong>synchronized</strong> 关键字保证的线程安全, 参考: StringBuffer类 . 即代码清单 13-6 所示的代码可能会变成代码清单 13-7 所示的样子.</p> <blockquote><p>代码清单13-7 Javac转化后的字符串连接操作</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">concatString</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">,</span> <span class="token class-name">String</span> s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>现在大家还认为这段代码没有涉及同步吗? 这里每个 StringBuffer.append() 方法中都有一个同步块, 锁就是 sb 对象. 虚拟机观察变量 sb, 经过逃逸分析后会发现它的动态作用域被限制在 concatString() 方法内部. 也就是 sb 的所有引用都永远不会逃逸到 concatString() 方法之外, 其他线程无法访问到它, 所以这里虽然有锁, 但是可以被安全地消除掉. <strong>在解释执行时这里仍然会加锁, 但在经过服务端编译器的即时编译之后, 这段代码就会忽略所有的同步措施而直接执行</strong>.</p> <h5 id="_3-锁粗化"><a href="#_3-锁粗化" class="header-anchor">#</a> 3.锁粗化</h5> <p>原则上, 在编写代码的时候, 总是推荐将同步块的作用范围限制得尽量小, <strong>只在共享数据的实际作用域中才进行同步, 这样是为了使得需要同步的操作数量尽可能变少, 即使存在锁竞争, 等待锁的线程也能尽可能快地拿到锁</strong>.</p> <p>大多数情况下, 上面的原则都是正确的, 但是如果一系列的连续操作都对同一个对象反复加锁和解锁, 甚至加锁操作是出现在循环体之中的, 那即使没有线程竞争, 频繁地进行互斥同步操作也会导致不必要的性能损耗.</p> <p>代码清单 13-7 所示连续的 append() 方法就属于这类情况. <strong>如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁, 将会把加锁同步的范围扩展(粗化)到整个操作序列的外部</strong>, 以代码清单 13-7 为例, 就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后, 这样<strong>只需要加锁一次</strong>就可以了.</p> <h5 id="_4-轻量级锁"><a href="#_4-轻量级锁" class="header-anchor">#</a> 4.轻量级锁</h5> <p>轻量级锁是 JDK 6 时加入的新型锁机制, 它名字中的 &quot;轻量级&quot; 是相对于使用操作系统互斥量来实现的传统锁而言的, 因此传统的锁机制就被称为 &quot;重量级&quot; 锁. 不过, 需要强调一点, 轻量级锁并不是用来代替重量级锁的, 它设计的<strong>初衷是在没有多线程竞争的前提下, 减少传统的重量级锁使用操作系统互斥量产生的性能消耗</strong>.</p> <p>要理解轻量级锁, 以及后面会讲到的偏向锁的原理和运作过程, 必须要对 HotSpot 虚拟机对象的内存布局(尤其是对象头部分)有所了解. HotSpot 虚拟机的<strong>对象头</strong>(Object Header)分为两部分, <strong>第一部分用于存储对象自身的运行时数据, 如哈希码(HashCode), GC 分代年龄(Generational GC Age)等</strong>. 这部分数据的长度在 32 位和 64 位的 Java 虚拟机中分别会占用 32 个或 64 个比特, 官方称它为 &quot;<strong>Mark Word</strong>&quot;. 这部分是<strong>实现轻量级锁和偏向锁的关键</strong>. 另外一部分用于存储指向方法区对象类型数据的指针, 如果是数组对象, 还会有一个额外的部分用于存储数组长度. 这些对象内存布局的详细内容参考(对象头), 在此不再赘述, 只针对锁的角度做进一步细化.</p> <p>由于对象头信息是与对象自身定义的数据无关的额外存储成本, 考虑到 Java 虚拟机的空间使用效率, Mark Word 被设计成<strong>一个非固定的动态数据结构</strong>, 以便在极小的空间内存储尽量多的信息. 它会根据对象的状态复用自己的存储空间. 例如在 32 位的 HotSpot 虚拟机中, 对象未被锁定的状态下, Mark Word 的 32 个比特空间里的 25 个比特将用于存储对象哈希码, <strong>4 个比特用于存储对象分代年龄, 2 个比特用于存储锁标志位, 还有 1 个比特固定为 0(这表示未进入偏向模式)</strong> . 对象除了未被锁定的正常状态外, 还有轻量级锁定, 重量级锁定, GC 标记, 可偏向等几种不同状态, 这些状态下对象头的存储内容如表 13-1 所示.</p> <blockquote><p>表13-1 HotSpot 虚拟机对象头 Mark Word</p></blockquote> <p><img src="/img/Image00231-20240302133505-lyzzin2.jpg" alt=""></p> <p>简单回顾了对象的内存布局后, 接下来就可以介绍轻量级锁的工作过程了: <strong>在代码即将进入同步块的时候, 如果此同步对象没有被锁定(锁标志位为 &quot;01&quot; 状态), 虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间, 用于存储锁对象目前的 Mark Word 的拷贝</strong>(官方为这份拷贝加了一个 Displaced 前缀, 即 Displaced Mark Word), 这时候线程堆栈与对象头的状态如图 13-3 所示.</p> <p><img src="/img/Image00232-20240302133505-bgjkskz.jpg" alt="" title="图13-3　轻量级锁 CAS 操作之前堆栈与对象的状态"></p> <p>然后, 虚拟机将使用 CAS 操作尝试把对象的 Mark Word 更新为指向 Lock Record 的指针. 如果这个更新动作成功了, 即代表<strong>该线程拥有了这个对象的锁</strong>, 并且对象 Mark Word 的锁标志位(Mark Word 的最后两个比特)将转变为 &quot;<strong>00</strong>&quot;, 表示<strong>此对象处于轻量级锁定状态</strong>. 这时候线程堆栈与对象头的状态如图 13-4 所示.</p> <p><strong>如果这个更新操作失败了, 那就意味着至少存在一条线程与当前线程竞争获取该对象的锁</strong>. 虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧, 如果是, 说明当前线程已经拥有了这个对象的锁, 那直接进入同步块继续执行就可以了, 否则就说明这个锁对象已经被其他线程抢占了. <strong>如果出现两条以上的线程争用同一个锁的情况, 那轻量级锁就不再有效, 必须要膨胀为重量级锁, 锁标志的状态值变为 &quot;10&quot;</strong> , 此时 Mark Word 中存储的就是指向重量级锁(互斥量)的指针, 后面<strong>等待锁的线程也必须进入阻塞状态</strong>.</p> <p><img src="/img/Image00233-20240302133505-2btbeuh.jpg" alt="" title="图13-4　轻量级锁 CAS 操作之后堆栈与对象的状态"></p> <p>上面描述的是<strong>轻量级锁的加锁过程</strong>, 它的解锁过程也同样是通过 CAS 操作来进行的, 如果对象的 Mark Word 仍然指向线程的锁记录, 那就用 CAS 操作把对象当前的 Mark Word 和线程中复制的 Displaced Mark Word 替换回来. 假如能够成功替换, 那整个同步过程就顺利完成了; 如果替换失败, 则说明有其他线程尝试过获取该锁, 就要在释放锁的同时, 唤醒被挂起的线程.</p> <p>轻量级锁能提升程序同步性能的依据是 &quot;<strong>对于绝大部分的锁, 在整个同步周期内都是不存在竞争的</strong>&quot; 这一经验法则. 如果没有竞争, 轻量级锁便通过 CAS 操作成功避免了使用互斥量的开销; 但如果确实存在锁竞争, 除了互斥量的本身开销外, 还额外发生了 CAS 操作的开销. 因此<strong>在有竞争的情况下, 轻量级锁反而会比传统的重量级锁更慢</strong>.</p> <h5 id="_5-偏向锁"><a href="#_5-偏向锁" class="header-anchor">#</a> 5.偏向锁</h5> <p>当一个锁对象<strong>才创建</strong>时, 是<strong>没有任何线程获得过这个锁</strong>的, 这个时候是<strong>无锁状态</strong>. 偏向锁适用于<strong>只有一个线程</strong>访问的场景.</p> <p>偏向锁也是 JDK 6 中引入的一项锁优化措施, 它的目的是<strong>消除数据在无竞争情况下的同步原语</strong>, 进一步提高程序的运行性能. <mark><strong>如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量, 那偏向锁就是在无竞争的情况下把整个同步都消除掉, 连 CAS 操作都不去做了</strong></mark>.</p> <p>偏向锁中的 &quot;偏&quot;, 就是偏心的 &quot;偏&quot;. 它的意思是这个<strong>锁会偏向于第一个获得它的线程, 如果在接下来的执行过程中, 该锁一直没有被其他的线程获取, 则持有偏向锁的线程将永远不需要再进行同步</strong>.</p> <p>如果理解了前面轻量级锁中关于对象头 Mark Word 与线程之间的操作过程, 那偏向锁的原理就会很容易理解. 假设当前虚拟机启用了偏向锁(启用参数 <code>-XX: +UseBiasedLocking</code>​, 这是自 JDK 6 起 HotSpot 虚拟机的默认值), 那么当锁对象第一次被线程获取的时候, 虚拟机将会<strong>把对象头中的标志位设置为 &quot;01&quot;</strong> , 把偏向模式设置为 &quot;1&quot;, 表示进入偏向模式. 同时使用 CAS 操作<strong>把获取到这个锁的线程的 ID 记录在对象的 Mark Word 之中</strong>. 如果 CAS 操作成功, <strong>持有偏向锁的线程以后每次进入这个锁相关的同步块时, 虚拟机都可以不再进行任何同步操作</strong>(例如加锁, 解锁及对 Mark Word 的更新操作等).</p> <p><mark><strong>一旦出现另外一个线程去尝试获取这个锁的情况, 偏向模式就马上宣告结束</strong></mark>. 根据锁对象目前是否处于被锁定的状态决定是否撤销偏向(偏向模式设置为 &quot;0&quot;), 撤销后标志位恢复到未锁定(标志位为 &quot;01&quot;)或轻量级锁定(标志位为 &quot;00&quot;)的状态, 后续的同步操作就按照上面介绍的轻量级锁那样去执行. 偏向锁, 轻量级锁的状态转化及对象 Mark Word 的关系如图 13-5 所示.</p> <p><img src="/img/Image00234-20240302133505-0qrez8g.jpg" alt="" title="图13-5　偏向锁, 轻量级锁的状态转化及对象 Mark Word 的关系"></p> <p>细心的读者看到这里可能会发现一个问题: 当对象进入偏向状态的时候, Mark Word 大部分的空间(23个比特)都用于存储持有锁的线程 ID 了, 这部分空间占用了原有存储对象哈希码的位置, 那原来对象的哈希码怎么办呢?</p> <p>在 Java 语言里面一个对象如果计算过哈希码, 就应该一直保持该值不变(强烈推荐但不强制, 因为用户可以重载 hashCode() 方法按自己的意愿返回哈希码), 否则很多依赖对象哈希码的 API 都可能存在出错风险. 而作为绝大多数对象哈希码来源的 <code>Object::hashCode()</code>​ 方法, 返回的是对象的<strong>一致性哈希码</strong>, 这个值是能强制保证不变的, 它通过在对象头中存储计算结果来保证第一次计算之后, 再次调用该方法取到的哈希码值永远不会再发生改变. 因此, <strong>当一个对象已经计算过一致性哈希码后, 它就再也无法进入偏向锁状态了</strong>; 而当一个对象当前正处于偏向锁状态, 又收到需要计算其一致性哈希码请求时, 它的偏向状态会被立即撤销, 并且锁会膨胀为重量级锁. 在重量级锁的实现中, 对象头指向了重量级锁的位置, 代表重量级锁的 ObjectMonitor 类里有字段可以记录非加锁状态(标志位为 &quot;01&quot;)下的 Mark Word, 其中自然可以存储原来的哈希码.</p> <p>偏向锁可以提高带有同步但无竞争的程序性能, 但它同样是一个带有效益权衡(Trade Off)性质的优化, 也就是说它并非总是对程序运行有利. <strong>如果程序中大多数的锁都总是被多个不同的线程访问, 那偏向模式就是多余的</strong>. 在具体问题具体分析的前提下, 有时候使用参数 <code>-XX: -UseBiasedLocking</code>​ 来禁止偏向锁优化反而可以提升性能.</p> <h5 id="_6-内置锁优化升级过程"><a href="#_6-内置锁优化升级过程" class="header-anchor">#</a> 6.内置锁优化升级过程</h5> <p>JDK6 引入了<strong>偏向锁和轻量级锁</strong>, 从而让锁拥有了<strong>四个状态</strong>: <strong>无锁状态(unlocked), 偏向锁状态(biasble), 轻量级锁状态(lightweight locked)和重量级锁状态(inflated)</strong> .</p> <p>对象头(参考 对象头)中包含的 <strong>Mark Word</strong> 在不同的<strong>锁状态</strong>下存储的内容不同, 会随着锁升级而变动. 在 <strong>32 位 JVM</strong> 中是这么存的:</p> <p>​<img src="/img/image-20240623215550-0xepx9a.png" alt="image">​</p> <p>所以内置锁有 4 种状态: <strong>无锁, 偏向锁, 轻量级锁, 重量级锁</strong>. 锁对象的状态不是一来就重量级的, 而是按照如下的顺序进行膨胀升级, 因此这也是对内置锁的一种<strong>优化措施</strong>.</p> <p>几种锁会随着<strong>竞争的激烈而逐渐升级</strong>, 注意锁<strong>可以升级不可降级</strong>, 这种策略是为了提高获得锁和释放锁的效率.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220601231206114.png" alt=""></p> <p>下图<strong>左侧</strong>是一个线程的<strong>虚拟机栈</strong>, 其中有一部分称为 <strong>Lock Record</strong> 的区域, 这是在<strong>轻量级锁</strong>运行过程创建的, 用于存放<strong>锁对象的 Mark Word</strong>. 而右侧就是一个<strong>锁对象</strong>, 包含了 <strong>Mark Word</strong> 和其它信息.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563602285907.png" alt=""></p> <h5 id="_7-锁膨胀后的优化"><a href="#_7-锁膨胀后的优化" class="header-anchor">#</a> 7.锁膨胀后的优化</h5> <p>系统<strong>并发高</strong>的时候, 可能导致<strong>锁膨胀升级</strong>, JVM 规定 synchronized 锁升级之后<strong>无法锁降级</strong>, <strong>锁的升级是不可逆的</strong>; 升级之后, 如果系统的并发下来了, 这无疑降低了系统的处理速度.</p> <p>因此可以过一段时间看看并发度, <strong>统计并发度已经很低</strong>, 并且还是重量级锁, 则可以进行<mark><strong>锁对象的切换</strong></mark>. 也就是换一个锁对象, 这样又开始偏向锁状态, 提升了处理速度; 锁对象切换时候, 需要注意并发操作.</p> <p>可以用这个工具包可以获取对象的消息头详情, 获取当前锁对象是否处于重量级锁状态.</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.openjdk.jol<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jol-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>0.9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>‍</p> <h4 id="本章小结"><a href="#本章小结" class="header-anchor">#</a> 本章小结</h4> <p>本章介绍了线程安全所涉及的概念和分类, 同步实现的方式及虚拟机的底层运作原理, 并且介绍了虚拟机为实现高效并发所做的一系列锁优化措施.</p> <p>能够写出高性能, 高伸缩性的并发程序是一门艺术, 而了解并发在系统底层是如何实现的, 则是掌握这门艺术的前提条件, 也是成长为高级程序员的必备知识之一.</p> <p>‍</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/20.开发/2000.Java/600.JVM/51.线程安全与内置锁优化🌼.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/3d72db/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Java内存模型与线程实现🌼</div></a> <a href="/pages/56b9dd/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Java性能问题定位分析</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/3d72db/" class="prev">Java内存模型与线程实现🌼</a></span> <span class="next"><a href="/pages/56b9dd/">Java性能问题定位分析</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/89.f28c86d3.js" defer></script>
  </body>
</html>
