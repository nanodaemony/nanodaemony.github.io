<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>虚拟机字节码执行引擎🌼 | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/84.220b69e7.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/4f30b9/" class="sidebar-link">Java基础</a></li><li><a href="/pages/795eca/" class="sidebar-link">类与继承</a></li><li><a href="/pages/c69152/" class="sidebar-link">抽象类与接口</a></li><li><a href="/pages/d71abb/" class="sidebar-link">内部类</a></li><li><a href="/pages/f06dca/" class="sidebar-link">枚举类</a></li><li><a href="/pages/259f57/" class="sidebar-link">常用类</a></li><li><a href="/pages/84b03b/" class="sidebar-link">关键字</a></li><li><a href="/pages/31b87b/" class="sidebar-link">注解</a></li><li><a href="/pages/f81c0d/" class="sidebar-link">异常</a></li><li><a href="/pages/ae7746/" class="sidebar-link">泛型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>容器类</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/0c88ac/" class="sidebar-link">集合容器类基础</a></li><li><a href="/pages/f805ed/" class="sidebar-link">List与Queue类</a></li><li><a href="/pages/d24b60/" class="sidebar-link">Map与Set类</a></li><li><a href="/pages/54e5d3/" class="sidebar-link">并发容器类</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/67d70f/" class="sidebar-link">多线程基础</a></li><li><a href="/pages/ffc8f7/" class="sidebar-link">Java内置锁</a></li><li><a href="/pages/c43494/" class="sidebar-link">AQS</a></li><li><a href="/pages/eb5b61/" class="sidebar-link">显式锁ReentrantLock</a></li><li><a href="/pages/eb8cbc/" class="sidebar-link">线程协作与JUC组件</a></li><li><a href="/pages/23c79a/" class="sidebar-link">Atomic原子变量与Unsafe类与CAS</a></li><li><a href="/pages/9d6ed4/" class="sidebar-link">线程池与定时任务</a></li><li><a href="/pages/5b787a/" class="sidebar-link">ThreadLocal</a></li><li><a href="/pages/db53d1/" class="sidebar-link">Java并发编程实战(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>IO</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b4d461/" class="sidebar-link">文件操作</a></li><li><a href="/pages/1b9d6c/" class="sidebar-link">IO流操作</a></li><li><a href="/pages/076a47/" class="sidebar-link">Java网络IO模型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>高级特性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d76905/" class="sidebar-link">Lambda表达式</a></li><li><a href="/pages/f7f0e6/" class="sidebar-link">流Stream</a></li><li><a href="/pages/7cc40a/" class="sidebar-link">反射</a></li><li><a href="/pages/945326/" class="sidebar-link">代理</a></li><li><a href="/pages/7fd9b4/" class="sidebar-link">Javaagent</a></li><li><a href="/pages/a3cee0/" class="sidebar-link">Guava</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>JVM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d308f6/" class="sidebar-link">走进JVM🌼</a></li><li><a href="/pages/be0269/" class="sidebar-link">JVM内存区域与对象解析🌼</a></li><li><a href="/pages/48d1be/" class="sidebar-link">垃圾收集器与内存分配策略🌼</a></li><li><a href="/pages/3a4c8a/" class="sidebar-link">JVM性能监控与故障处理工具🌼</a></li><li><a href="/pages/106680/" class="sidebar-link">调优案例分析与实战🌼</a></li><li><a href="/pages/16a914/" class="sidebar-link">类文件结构🌼</a></li><li><a href="/pages/ea287c/" class="sidebar-link">虚拟机类加载机制🌼</a></li><li><a href="/pages/6367b0/" aria-current="page" class="active sidebar-link">虚拟机字节码执行引擎🌼</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/c6c210/" class="sidebar-link">类加载及执行子系统的案例与实战🌼</a></li><li><a href="/pages/deb8b7/" class="sidebar-link">前端编译与优化🌼</a></li><li><a href="/pages/1f8f72/" class="sidebar-link">后端编译与优化🌼</a></li><li><a href="/pages/3d72db/" class="sidebar-link">Java内存模型与线程实现🌼</a></li><li><a href="/pages/ed086e/" class="sidebar-link">线程安全与内置锁优化🌼</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/56b9dd/" class="sidebar-link">Java性能问题定位分析</a></li><li><a href="/pages/939bf8/" class="sidebar-link">杂记</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>开发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>软件设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/a5f6fe/" class="sidebar-link">设计基础理论</a></li><li><a href="/pages/3b245c/" class="sidebar-link">设计模式之美(极客时间)🌟</a></li><li><a href="/pages/661fa4/" class="sidebar-link">领域驱动设计(DDD)</a></li><li><a href="/pages/856368/" class="sidebar-link">DDD实战课(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d3fbd2/" class="sidebar-link">数据库基础</a></li><li><a href="/pages/691fc3/" class="sidebar-link">数据库系统原理</a></li><li><a href="/pages/50f6b7/" class="sidebar-link">MySQL基础必知必会</a></li><li><a href="/pages/fe297e/" class="sidebar-link">MySQL特性</a></li><li><a href="/pages/07bdb6/" class="sidebar-link">MySQL索引🌟</a></li><li><a href="/pages/984715/" class="sidebar-link">MySQL锁🌟</a></li><li><a href="/pages/53b588/" class="sidebar-link">MySQL事务🌟</a></li><li><a href="/pages/becc59/" class="sidebar-link">MySQL高级特性</a></li><li><a href="/pages/056463/" class="sidebar-link">MySQL基础架构与存储引擎🌟</a></li><li><a href="/pages/63b46e/" class="sidebar-link">MySQL架构优化与运维</a></li><li><a href="/pages/9995e5/" class="sidebar-link">MySQL优化</a></li><li><a href="/pages/c1c2f6/" class="sidebar-link">MySQL架构</a></li><li><a href="/pages/8e8e0a/" class="sidebar-link">MySQL设计规范</a></li><li><a href="/pages/0219aa/" class="sidebar-link">MySQL运维</a></li><li><a href="/pages/e288c0/" class="sidebar-link">MySQL中间件</a></li><li><a href="/pages/c6cafa/" class="sidebar-link">MySQL实战45讲(极客时间)🌟</a></li><li><a href="/pages/4a6106/" class="sidebar-link">数据库LeetCode题目</a></li><li><a href="/pages/2827f1/" class="sidebar-link">数据库综合问题</a></li><li><a href="/pages/c616d5/" class="sidebar-link">MongoDB</a></li><li><a href="/pages/075e71/" class="sidebar-link">ClickHouse</a></li><li><a href="/pages/d74f6d/" class="sidebar-link">Doris</a></li><li><a href="/pages/b6bad9/" class="sidebar-link">HBase</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Spring</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bd8eb8/" class="sidebar-link">Spring Boot基础</a></li><li><a href="/pages/d0d797/" class="sidebar-link">Spring Boot应用整合</a></li><li><a href="/pages/314cdc/" class="sidebar-link">Spring MVC基础</a></li><li><a href="/pages/80de47/" class="sidebar-link">Spring AOP基础</a></li><li><a href="/pages/f0d4d6/" class="sidebar-link">Spring事务基础</a></li><li><a href="/pages/db6afe/" class="sidebar-link">Spring IOC源码分析-概览</a></li><li><a href="/pages/672e98/" class="sidebar-link">Spring IOC源码分析-getBean()</a></li><li><a href="/pages/695b90/" class="sidebar-link">Spring IOC源码分析-createBean()</a></li><li><a href="/pages/f89bcf/" class="sidebar-link">Spring AOP源码分析</a></li><li><a href="/pages/3b52f4/" class="sidebar-link">Spring事务源码分析</a></li><li><a href="/pages/186902/" class="sidebar-link">Spring Boot源码分析</a></li><li><a href="/pages/16bd1c/" class="sidebar-link">Spring MVC源码分析</a></li><li><a href="/pages/3d0c1f/" class="sidebar-link">Spring Cloud</a></li><li><a href="/pages/d56156/" class="sidebar-link">Spring编程常见错误50例(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>MyBatis</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bb032d/" class="sidebar-link">基础</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>工具与环境</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c9cb6e/" class="sidebar-link">Arthas</a></li><li><a href="/pages/3172bb/" class="sidebar-link">Maven</a></li><li><a href="/pages/37f79a/" class="sidebar-link">Git</a></li><li><a href="/pages/db9f99/" class="sidebar-link">环境搭建与部署</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c725f5/" class="sidebar-link">测试基础</a></li><li><a href="/pages/7893a4/" class="sidebar-link">单元测试</a></li><li><a href="/pages/af9f25/" class="sidebar-link">压力测试</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>代码质量</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ec2b81/" class="sidebar-link">代码整洁之道</a></li><li><a href="/pages/474cdf/" class="sidebar-link">阿里巴巴编程规范</a></li><li><a href="/pages/c47e15/" class="sidebar-link">代码之丑(极客时间)🌸</a></li><li><a href="/pages/4d4606/" class="sidebar-link">Java业务开发常见错误100例(极客时间)🌸</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/develop/#开发" data-v-06970110>开发</a></li><li data-v-06970110><a href="/develop/#Java" data-v-06970110>Java</a></li><li data-v-06970110><a href="/develop/#JVM" data-v-06970110>JVM</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">虚拟机字节码执行引擎🌼<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_32-虚拟机字节码执行引擎🌼"><a href="#_32-虚拟机字节码执行引擎🌼" class="header-anchor">#</a> 32.虚拟机字节码执行引擎🌼</h1> <p>本节对应《深入理解 Java 虚拟机》的第八章</p> <p>代码编译的结果从本地机器码转变为字节码, 是存储格式发展的一小步, 却是编程语言发展的一大步.</p> <h4 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h4> <p><strong>执行引擎</strong>是 Java 虚拟机核心的组成部分之一. &quot;虚拟机&quot; 是一个相对于 &quot;物理机&quot; 的概念, 这两种机器都有代码执行能力, 其区别是物理机的执行引擎是直接建立在处理器, 缓存, 指令集和操作系统层面上的, 而虚拟机的执行引擎则是由<strong>软件自行实现</strong>的, 因此可以不受物理条件制约地定制指令集与执行引擎的结构体系, 能够执行那些不被硬件直接支持的指令集格式.</p> <p>在《Java 虚拟机规范》中制定了 Java <strong>虚拟机字节码执行引擎的概念模型</strong>, 这个概念模型成为各大发行商的 Java 虚拟机执行引擎的统一外观(Facade). 在不同的虚拟机实现中, <mark><strong>执行引擎在执行字节码的时候, 通常会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行)两种选择</strong></mark>, 也可能两者兼备, 还可能会有同时包含几个不同级别的即时编译器一起工作的执行引擎. 但从外观上来看, 所有的 Java 虚拟机的执行引擎输入, 输出都是一致的: <mark><strong>输入的是字节码二进制流, 处理过程是字节码解析执行的等效过程, 输出的是执行结果</strong></mark>, 本章将主要从概念模型的角度来讲解虚拟机的方法调用和字节码执行.</p> <h4 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="header-anchor">#</a> 运行时栈帧结构</h4> <p><mark><strong>虚拟机以方法作为最基本的执行单元, &quot;栈帧&quot; (Stack Frame)则是用于支持虚拟机进行方法调用和方法执行背后的数据结构, 它也是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack) 的栈元素</strong></mark>. 栈帧存储了方法的局部变量表, 操作数栈, 动态连接和方法返回地址等信息, 如果读者认真阅读过第 6 章, 应该能从 Class 文件格式的方法表中找到以上大多数概念的静态对照物. <mark><strong>每一个方法从调用开始至执行结束的过程, 都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程</strong></mark>.</p> <p><mark><strong>每一个栈帧都包括了局部变量表, 操作数栈, 动态连接, 方法返回地址和一些额外的附加信息</strong></mark>. 在编译 Java 程序源码的时候, 栈帧中需要多大的局部变量表, 需要多深的操作数栈就已经被分析计算出来, 并且写入到<strong>方法表的 Code 属性</strong>之中. 换言之, <strong>一个栈帧需要分配多少内存, 并不会受到程序运行期变量数据的影响, 而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式</strong>.</p> <p>一个线程中的方法调用链可能会很长, 以 Java 程序的角度来看, 同一时刻, 同一条线程里面, 在调用堆栈的所有方法都同时处于执行状态. 而对于执行引擎来讲, 在活动线程中, <strong>只有位于栈顶的方法才是在运行的, 只有位于栈顶的栈帧才是生效的, 其被称为 &quot;当前栈帧&quot;(Current Stack Frame)</strong> , 与这个栈帧所关联的方法被称为 &quot;<strong>当前方法</strong>&quot;(Current Method). 执行引擎所运行的<strong>所有字节码指令都只针对当前栈帧进行操作</strong>, 在概念模型上, 典型的栈帧结构如图 8-1 所示.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220514163834398.png" alt="" title="图8-1　栈帧的概念结构"></p> <p>图 8-1 所示的就是虚拟机<strong>栈和栈帧的总体结构</strong>, 接下来将会详细了解栈帧中的局部变量表, 操作数栈, 动态连接, 方法返回地址等各个部分的作用和数据结构.</p> <h5 id="_1-局部变量表"><a href="#_1-局部变量表" class="header-anchor">#</a> 1.局部变量表</h5> <p><mark><strong>局部变量表是一组变量值的存储空间, 用于存放方法参数和方法内部定义的局部变量</strong></mark>. 在 Java 程序被编译为 Class 文件时, 就在方法的 Code 属性的 max_locals 数据项中确定了该方法所需分配的局部变量表的最大容量.</p> <p>局部变量表的容量以<strong>变量槽</strong>(Variable Slot)为最小单位, 一个变量槽可以存放一个 32 位以内的数据类型, Java 中占用不超过 32 位存储空间的数据类型有 boolean, byte, char, short, int, float, reference 和 returnAddress 这 8 种类型. 前面 6 种不需要多加解释, 可以按照 Java 语言中对应数据类型的概念去理解它们(仅是这样理解而已, Java 语言和 Java 虚拟机中的基本数据类型是存在本质差别的), 而第 7 种 reference 类型<strong>表示对一个对象实例的引用</strong>. 一般来说, 虚拟机实现应当能通过这个引用做到两件事情, 一是从根据引用直接或间接地查找到对象在 Java 堆中的数据存放的起始地址或索引, 二是根据引用直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息. 第 8 种 returnAddress 类型目前已经很少见了.</p> <p>对于 64 位的数据类型, Java 虚拟机会以<strong>高位对齐的方式为其分配两个连续的变量槽空间</strong>. Java 语言中明确的 <strong>64 位的数据类型只有 long 和 double 两种</strong>. 这里把 long 和 double 数据类型分割存储的做法与 &quot;long 和 double 的非原子性协定&quot; 中允许把一次 long 和 double 数据类型读写分割为两次 32 位读写的做法有些类似, 读者阅读到本书关于 Java 内存模型的内容时可以进行对比. 不过, <strong>由于局部变量表是建立在线程堆栈中的, 属于线程私有的数据, 无论读写两个连续的变量槽是否为原子操作, 都不会引起数据竞争和线程安全问题</strong>.</p> <p><strong>Java 虚拟机通过索引定位的方式使用局部变量表</strong>, 索引值的范围是从 0 开始至局部变量表最大的变量槽数量. 如果访问的是 32 位数据类型的变量, 索引 N 就代表了使用第 N 个变量槽, 如果访问的是 64 位数据类型的变量, 则说明会同时使用第 N 和 N + 1 两个变量槽. 对于两个相邻的共同存放一个 64 位数据的两个变量槽, 虚拟机不允许采用任何方式单独访问其中的某一个, 《Java 虚拟机规范》中明确要求了如果遇到进行这种操作的字节码序列, 虚拟机就应该在类加载的校验阶段中抛出异常.</p> <p><strong>当一个方法被调用时, Java 虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程, 即实参到形参的传递</strong>. 如果执行的是实例方法(没有被 static 修饰的方法), 那局部变量表中第 0 位索引的变量槽默认是用于传递方法所属对象实例的引用, 在方法中可以通过关键字 &quot;this&quot; 来访问到这个隐含的参数. 其余参数则按照参数表顺序排列, 占用从 1 开始的局部变量槽, 参数表分配完毕后, 再根据方法体内部定义的变量顺序和作用域分配其余的变量槽.</p> <blockquote><p>局部变量表槽复用对垃圾收集的影响</p></blockquote> <p>为了尽可能节省栈帧耗用的内存空间, <strong>局部变量表中的变量槽是可以重用的</strong>, 方法体中定义的变量, 其作用域并不一定会覆盖整个方法体, 如果当前字节码 PC 计数器的值已经超出了某个变量的作用域, 那这个变量对应的变量槽就可以交给其他变量来重用. 不过, 这样的设计除了节省栈帧空间以外, 还会伴随有少量额外的副作用, 例如在<strong>某些情况下变量槽的复用会直接影响到系统的垃圾收集行为</strong>, 请看代码清单 8-1, 代码清单 8-2 和代码清单 8-3 的 3 个演示.</p> <blockquote><p>代码清单8-1 局部变量表槽复用对垃圾收集的影响之一</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> placeholder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>代码清单 8-1 中的代码很简单, 向内存填充了 64MB 的数据, 然后通知虚拟机进行垃圾收集. 在虚拟机运行参数中加上 &quot;<code>-verbose: gc</code>​&quot; 来看看垃圾收集的过程, 发现在 System.gc() 运行后并没有回收掉这 64MB 的内存, 下面是运行的结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>[GC 66846K-&gt;65824K(125632K), 0.0032678 secs]
[Full GC 65824K-&gt;65746K(125632K), 0.0064131 secs]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>代码清单 8-1 的代码没有回收掉 placeholder 所占的内存是能说得过去, 因为在执行 System.gc() 时, 变量 placeholder 还处于<strong>作用域</strong>之内, 虚拟机自然不敢回收掉 placeholder 的内存. 那把代码修改一下, 变成代码清单 8-2 的样子.</p> <blockquote><p>代码清单8-2 局部变量表 Slot 复用对垃圾收集的影响之二</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> placeholder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>加入了花括号之后, placeholder 的作用域被限制在花括号以内, 从代码逻辑上讲, 在执行 System.gc() 的时候, placeholder 已经不可能再被访问了, 但执行这段程序, 会发现运行结果如下, 还是有 64MB 的内存<strong>没有</strong>被回收掉, 这又是为什么呢?</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>[GC 66846K-&gt;65888K(125632K), 0.0009397 secs]
[Full GC 65888K-&gt;65746K(125632K), 0.0051574 secs]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在解释为什么之前, 先对这段代码进行第二次修改, 在调用 System.gc() 之前加入一行 &quot;<code>int a = 0;</code>​&quot;, 变成代码清单 8-3 的样子.</p> <blockquote><p>代码清单8-3 局部变量表 Slot 复用对垃圾收集的影响之三</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> placeholder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这个修改看起来很莫名其妙, 但运行一下程序, 却发现这次内存真的<strong>被正确回收</strong>了:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>[GC 66401K-&gt;65778K(125632K), 0.0035471 secs]
[Full GC 65778K-&gt;218K(125632K), 0.0140596 secs]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>代码清单 8-1 至 8-3 中, placeholder 能否被回收的根本原因就是: <strong>局部变量表中的变量槽是否还存有关于 placeholder 数组对象的引用</strong>. 第一次修改中, 代码虽然已经离开了 placeholder 的作用域, 但在此之后, 再没有发生过任何对局部变量表的读写操作, placeholder <strong>原本所占用的变量槽还没有被其他变量所复用</strong>, 所以作为 GC Roots 一部分的局部变量表仍然保持着对它的关联. 这种关联没有被及时打断, 绝大部分情况下影响都很轻微. 但如果遇到一个方法, 其后面的代码有一些耗时很长的操作, 而前面又定义了占用了大量内存但实际上已经不会再使用的变量, 手动将其设置为 null 值(用来代替那句 <code>int a = 0</code>​, 把变量对应的局部变量槽清空)便不见得是一个绝对无意义的操作, 这种操作可以作为一种在极特殊情形(对象占用内存大, 此方法的栈帧长时间不能被回收, 方法调用次数达不到即时编译器的编译条件)下的 &quot;奇技&quot; 来使用.</p> <blockquote><p>局部变量赋初始值</p></blockquote> <p>关于局部变量表, 还有一点可能会对实际开发产生影响, <strong>就是局部变量不像前面介绍的类变量那样存在 &quot;准备阶段&quot;</strong> . 类的字段变量有<strong>两次赋初始值</strong>的过程, 一次在<strong>准备阶段</strong>, 赋予系统初始值; 另外一次在<strong>初始化阶段</strong>, 赋予程序员定义的初始值. 因此即使在初始化阶段程序员没有为类变量赋值也没有关系, 类变量仍然具有一个确定的初始值, 不会产生歧义. <strong>但局部变量就不一样了, 如果一个局部变量定义了但没有赋初始值, 那它是完全不能使用的</strong>. 所以不要认为 Java 中任何情况下都存在诸如整型变量默认为 0, 布尔型变量默认为 false 等这样的默认值规则. 如代码清单 8-4 所示, 这段代码在 Java 中其实并不能运行, 所幸编译器能在编译期间就检查到并提示出这一点, 即便编译能通过或者手动生成字节码的方式制造出下面代码的效果, 字节码校验的时候也会被虚拟机发现而导致类加载失败.</p> <blockquote><p>代码清单8-4 未赋值的局部变量</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h5 id="_2-操作数栈"><a href="#_2-操作数栈" class="header-anchor">#</a> 2.操作数栈</h5> <p><mark><strong>操作数栈(Operand Stack)也常被称为操作栈, 它是一个后入先出(Last In First Out, LIFO)栈</strong></mark>. 同局部变量表一样, 操作数栈的最大深度也在编译的时候被写入到 <strong>Code 属性</strong>的 max_stacks 数据项之中. 操作数栈的每一个元素都可以是包括 long 和 double 在内的任意 Java 数据类型. Javac 编译器的数据流分析工作保证了在方法执行的任何时候, 操作数栈的深度都不会超过在 max_stacks 数据项中设定的最大值.</p> <p><strong>当一个方法刚刚开始执行的时候, 这个方法的操作数栈是空的, 在方法的执行过程中, 会有各种字节码指令往操作数栈中写入和提取内容, 也就是出栈和入栈操作</strong>.</p> <p>譬如在做算术运算的时候是通过将运算涉及的操作数栈压入栈顶后调用运算指令来进行的, 又譬如在调用其他方法的时候是通过操作数栈来进行方法参数的传递. 举个例子, 例如整数加法的字节码指令 iadd, 这条指令在运行的时候要求操作数栈中最接近栈顶的两个元素已经存入了两个 int 型的数值, 当执行这个指令时, <strong>会把这两个 int 值出栈并相加, 然后将相加的结果重新入栈</strong>.</p> <p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配, 在编译程序代码的时候, 编译器必须要严格保证这一点, 在类校验阶段的数据流分析中还要再次验证这一点. 再以上面的 iadd 指令为例, 这个指令只能用于整型数的加法, 它在执行时, 最接近栈顶的两个元素的数据类型必须为 int 型, 不能出现一个 long 和一个 float 使用 iadd 命令相加的情况.</p> <p>另外在<strong>概念模型中, 两个不同栈帧作为不同方法的虚拟机栈的元素, 是完全相互独立的</strong>. 但是在大多虚拟机的实现里都会进行一些<strong>优化处理, 令两个栈帧出现一部分重叠</strong>. 让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起, 这样做不仅节约了一些空间, 更重要的是在进行方法调用时就可以<strong>直接共用一部分数据, 无须进行额外的参数复制传递了</strong>, 重叠的过程如图 8-2 所示.</p> <p><mark><strong>Java 虚拟机的解释执行引擎被称为 &quot;基于栈的执行引擎&quot;, 里面的 &quot;栈&quot; 就是操作数栈</strong></mark>. 后文会对基于栈的代码执行过程进行更详细的讲解, 介绍它与更常见的基于寄存器的执行引擎有哪些差别.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522150551523.png" alt="" title="图8-2　两个栈帧之间的数据共享"></p> <h5 id="_3-动态连接"><a href="#_3-动态连接" class="header-anchor">#</a> 3.动态连接</h5> <p><strong>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用, 持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)</strong> .</p> <p>Class 文件的常量池中存有大量的符号引用, 字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数. <strong>这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用, 这种转化被称为</strong>​<mark><strong>静态解析</strong></mark>​ <strong>. 另外一部分将在每一次运行期间都转化为直接引用, 这部分就称为</strong>​<mark><strong>动态连接</strong></mark>. 关于这两个转化过程的具体过程, 将在(方法调用)中再详细讲解.</p> <h5 id="_4-方法返回地址"><a href="#_4-方法返回地址" class="header-anchor">#</a> 4.方法返回地址</h5> <p><strong>当一个方法开始执行后, 只有两种方式退出这个方法</strong>.</p> <p>第一种方式是执行引擎遇到任意一个<strong>方法返回的字节码指令</strong>, 这时候可能会有返回值传递给上层的方法调用者(调用当前方法的方法称为调用者或者主调方法), 方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定, 这种退出方法的方式称为 &quot;<strong>正常调用完成</strong>&quot;(Normal Method Invocation Completion).</p> <p>另外一种退出方式是在方法执行的过程中<strong>遇到了异常</strong>, 并且这个异常没有在方法体内得到妥善处理. 无论是 Java 虚拟机内部产生的异常, 还是代码中使用 athrow 字节码指令产生的异常, 只要在本方法的异常表中没有搜索到匹配的异常处理器, 就会导致方法退出, 这种退出方法的方式称为 &quot;<strong>异常调用完成</strong>(Abrupt Method Invocation Completion)&quot;. 一个方法使用异常完成出口的方式退出, 是不会给它的上层调用者提供任何返回值的.</p> <p><strong>无论采用何种退出方式, 在方法退出之后, 都必须返回到最初方法被调用时的位置, 程序才能继续执行, 方法返回时可能需要在栈帧中保存一些信息, 用来帮助恢复它的上层主调方法的执行状态</strong>. 一般来说, 方法正常退出时, 主调方法的 PC 计数器的值就可以作为返回地址, 栈帧中很可能会保存这个计数器值. 而方法异常退出时, 返回地址是要通过异常处理器表来确定的, 栈帧中就一般不会保存这部分信息.</p> <p><strong>方法退出的过程实际上等同于把当前栈帧出栈</strong>, 因此退出时可能执行的操作有: 恢复上层方法的局部变量表和操作数栈, 把返回值(如果有的话)压入调用者栈帧的操作数栈中, 调整 PC 计数器的值以指向方法调用指令后面的一条指令等. 这里写的 &quot;可能&quot; 是由于这是基于概念模型的讨论, 只有具体到某一款 Java 虚拟机实现, 会执行哪些操作才能确定下来.</p> <h5 id="_5-附加信息"><a href="#_5-附加信息" class="header-anchor">#</a> 5.附加信息</h5> <p>《Java 虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中, 例如与调试, 性能收集相关的信息, 这部分信息完全取决于具体的虚拟机实现, 这里不再详述. 在讨论概念时, 一般会<strong>把动态连接, 方法返回地址与其他附加信息全部归为一类, 称为栈帧信息</strong>.</p> <h4 id="方法调用"><a href="#方法调用" class="header-anchor">#</a> 方法调用</h4> <p>在程序运行时, 进行方法调用是最普遍, 最频繁的操作之一, 虚拟机如何调用方法?</p> <p>方法调用并不等同于方法中的代码被执行, <mark><strong>方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法), 暂时还未涉及方法内部的具体运行过程</strong></mark>.</p> <p>但前面已经讲过, Class 文件的编译过程中不包含传统程序语言编译的连接步骤, <strong>一切方法调用在 Class 文件里面存储的都只是符号引用, 而不是方法在实际运行时内存布局中的入口地址(也就是之前说的直接引用)</strong> . 这个特性给 Java 带来了更强大的<strong>动态扩展</strong>能力, 但也<mark><strong>使得 Java 方法调用过程变得相对复杂, 某些调用需要在类加载期间, 甚至到运行期间才能确定目标方法的直接引用</strong></mark>.</p> <h5 id="_1-静态-解析"><a href="#_1-静态-解析" class="header-anchor">#</a> 1.(静态)解析</h5> <p><mark><strong>承接前面关于方法调用的话题, 所有方法调用的目标方法在 Class 文件里面都是一个常量池中的符号引用, 在类加载的解析阶段, 会将其中的一部分符号引用转化为直接引用, 这种解析能够成立的前提是: 方法在程序真正运行之前就有一个可确定的调用版本, 并且这个方法的调用版本在运行期是不可改变的. 换句话说, 调用目标在程序代码写好, 编译器进行编译那一刻就已经确定下来. 这类方法的调用被称为解析(Resolution)</strong></mark> .</p> <p>在 Java 语言中符合 &quot;<strong>编译期可知, 运行期不可变</strong>&quot; 这个要求的方法, 主要有<mark><strong>静态方法和私有方法</strong></mark>两大类, 前者与类型直接关联, 后者在外部不可被访问, 这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本, 因此它们都<mark><strong>适合在类加载阶段进行解析</strong></mark>.</p> <blockquote><p>调用方法的字节码指令</p></blockquote> <p>调用不同类型的方法, 字节码指令集里设计了不同的<strong>指令</strong>. 在 Java 虚拟机支持以下 5 条<mark><strong>方法调用字节码指令</strong></mark>, 分别是:</p> <ul><li><mark><strong>invokestatic</strong></mark>. 用于调用<strong>静态方法</strong>.</li> <li><mark><strong>invokespecial</strong></mark>. 用于调用实例构造器 <code>&lt;init&gt;()</code>​ 方法, 私有方法和父类中的方法.</li> <li><mark><strong>invokevirtual</strong></mark>. 用于调用所有的虚方法.</li> <li><mark><strong>invokeinterface</strong></mark>. 用于调用<strong>接口方法, 会在运行时再确定一个实现该接口的对象</strong>.</li> <li><mark><strong>invokedynamic</strong></mark>. 先在<strong>运行时动态解析出调用点限定符所引用的方法, 然后再执行该方法</strong>. 前面 <strong>4 条调用指令, 分派逻辑都固化在 Java 虚拟机内部, 而 invokedynamic 指令的分派逻辑是由用户设定的引导方法来决定的</strong>.</li></ul> <blockquote><p>虚方法与非虚方法</p></blockquote> <p><mark><strong>只要能被 invokestatic 和 invokespecial 指令调用的方法, 都可以在解析阶段中确定唯一的调用版本, Java 语言里符合这个条件的方法共有静态方法, 私有方法, 实例构造器, 父类方法 4 种, 再加上被 final 修饰的方法(尽管它使用 invokevirtual 指令调用), 这 5 种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用. 这些方法统称为 &quot;非虚方法&quot;</strong></mark> (Non-Virtual Method), 与之相反, 其他方法就被称为 &quot;<mark><strong>虚方法</strong></mark>&quot;(Virtual Method).</p> <p>总结一下非虚方法:</p> <ul><li>静态方法</li> <li>私有方法</li> <li>实例构造器</li> <li>父类方法</li> <li>final 修饰的方法</li></ul> <p>代码清单 8-5 演示了一种常见的<strong>解析调用</strong>的例子, 该样例中, 静态方法 sayHello() 只可能属于类型 StaticResolution, 没有任何途径可以覆盖或隐藏这个方法.</p> <blockquote><p>代码清单8-5 方法静态解析字节码示例</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * 方法静态解析演示
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticResolution</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">StaticResolution</span><span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>使用 javap 命令查看这段程序对应的字节码, 会发现的确是通过 <strong>invokestatic</strong> 命令来调用 sayHello() 方法, 而且其<strong>调用的方法版本已经在编译时就明确以常量池项的形式固化在字节码指令的参数之中</strong>(代码里的 31 号常量池项):</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>javap <span class="token operator">-</span>verbose StaticResolution
public <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Code<span class="token operator">:</span>
        Stack<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> Locals<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> Args_size<span class="token operator">=</span><span class="token number">1</span>
        <span class="token number">0</span><span class="token operator">:</span>   invokestatic    #<span class="token number">31</span><span class="token punctuation">;</span> <span class="token comment">// Method sayHello:()V</span>
        <span class="token number">3</span><span class="token operator">:</span>   <span class="token keyword">return</span>
    LineNumberTable<span class="token operator">:</span>
        line <span class="token number">15</span><span class="token operator">:</span> <span class="token number">0</span>
        line <span class="token number">16</span><span class="token operator">:</span> <span class="token number">3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Java 中的非虚方法除了使用 invokestatic, invokespecial 调用的方法之外还有一种, 就是<strong>被 final 修饰的实例方法</strong>. 虽然由于历史设计的原因, <strong>final 方法是使用 invokevirtual 指令来调用的</strong>, 但是因为它<strong>也无法被覆盖, 没有其他版本的可能, 所以也无须对方法接收者进行多态选择, 又或者说多态选择的结果肯定是唯一的</strong>. 在《Java 语言规范》中明确定义了被 final 修饰的方法是一种非虚方法.</p> <p><mark><strong>解析调用一定是个静态的过程, 在编译期间就完全确定, 在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用, 不必延迟到运行期再去完成</strong></mark>.</p> <p>而另一种主要的方法调用形式: <strong>分派(Dispatch)调用则要复杂许多, 它可能是静态的也可能是动态的, 按照分派依据的宗量数可分为单分派和多分派. 这两类分派方式两两组合就构成了静态单分派, 静态多分派, 动态单分派, 动态多分派 4 种分派组合情况</strong>, 下面来看看虚拟机中的方法分派是如何进行的.</p> <h5 id="_2-分派"><a href="#_2-分派" class="header-anchor">#</a> 2.分派</h5> <p>众所周知, Java 是一门面向对象的程序语言, 因为 Java 具备面向对象的 3 个基本特征: <strong>继承, 封装和多态</strong>. 本节讲解的分派调用过程将会揭示<strong>多态性特征</strong>的一些最基本的体现, 如 &quot;重载&quot; 和 &quot;重写&quot; 在 Java 虚拟机之中是如何实现的, 这里的实现当然不是语法上该如何写, 这里关心的依然是<mark><strong>虚拟机如何确定正确的目标方法</strong></mark>. 下面的<mark><strong>静态分派主要关于重载的实现, 动态分派主要关于重写的实现</strong></mark>.</p> <h6 id="_1-静态分派"><a href="#_1-静态分派" class="header-anchor">#</a> (1)静态分派</h6> <p>在开始讲解静态分派前先声明一点, &quot;分派&quot;(Dispatch)这个词本身就具有动态性, <strong>一般不应用在静态语境之中</strong>, 这部分原本在英文原版的《Java 虚拟机规范》和《Java 语言规范》里的说法都是 &quot;Method Overload Resolution&quot;, 即应该归入 &quot;解析&quot; 里去讲解, 但部分其他外文资料和国内翻译的许多中文资料都将这种行为称为 &quot;静态分派&quot;, 所以在此特别说明一下, 以免读者阅读英文资料时遇到这两种说法产生疑惑.</p> <blockquote><p>方法静态分派演示</p></blockquote> <p>为了解释<strong>静态分派和重载(Overload)</strong> , 这里准备了一段经常出现在面试题中的程序代码, 想一下程序的输出结果是什么. 后面的话题将围绕这个类的方法来编写重载代码, 以分析虚拟机和编译器确定方法版本的过程. 程序如代码清单 8-6 所示.</p> <blockquote><p>代码清单8-6 方法静态分派演示</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>polymorphic</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 方法静态分派演示
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticDispatch</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Human</span> guy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello,guy!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Man</span> guy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello,gentleman!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Woman</span> guy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello,lady!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Human</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Human</span> woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">StaticDispatch</span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticDispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>man<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>woman<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p>运行结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>hello,guy!
hello,guy!
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>代码清单 8-6 中的代码实际上是在考验阅读者对重载的理解程度, 为什么虚拟机会<strong>选择执行参数类型为 Human 的重载版本</strong>呢? 在解决这个问题之前, 先通过如下代码来定义两个关键概念:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Human</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>静态类型与动态类型</p></blockquote> <p>把上面代码中的 &quot;Human&quot; 称为<mark><strong>变量的 &quot;静态类型&quot;</strong></mark> (Static Type), 或者叫 &quot;外观类型&quot;(Apparent Type), 后面的 &quot;Man&quot; 则被称为<mark><strong>变量的 &quot;实际类型&quot;(Actual Type)或者叫 &quot;运行时类型&quot;(Runtime Type)</strong></mark> . 静态类型和实际类型在程序中都可能会发生变化, 区别是静态类型的变化仅仅在使用时发生, 变量本身的静态类型不会被改变, <mark><strong>并且最终的静态类型是在编译期可知的; 而实际类型变化的结果在运行期才可确定</strong></mark>, 编译器在编译程序的时候并不知道一个对象的实际类型是什么.</p> <p>不妨通过一段实际例子来解释, 譬如有下面的代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 实际类型变化</span>
<span class="token class-name">Human</span> human <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 静态类型变化</span>
sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Man</span><span class="token punctuation">)</span> human<span class="token punctuation">)</span>
sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Woman</span><span class="token punctuation">)</span> human<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>对象 human 的实际类型是可变的, 编译期间它完全是个 &quot;薛定谔的人&quot;, 到底是 Man 还是 Woman, 必须等到程序</strong>​<mark><strong>运行到这行的时候才能确定</strong></mark>. 而 human 的静态类型是 Human, 也可以在使用时(如 sayHello() 方法中的强制转型)临时改变这个类型, 但这个改变仍是在<strong>编译期是可知</strong>的, 两次 sayHello() 方法的调用, 在编译期完全可以明确转型的是 Man 还是 Woman.</p> <p>解释清楚了静态类型与实际类型的概念, 就把话题再转回到代码清单 8-6 的样例代码中. main() 里面的两次 sayHello() 方法调用, 在方法接收者已经确定是对象 &quot;sr&quot; 的前提下, <strong>使用哪个重载版本, 就完全取决于传入参数的数量和数据类型</strong>. 代码中故意定义了<strong>两个静态类型相同, 而实际类型不同的变量</strong>, 但虚拟机(或者准确地说是编译器)在重载时是<strong>通过参数的静态类型而不是实际类型作为判定依据的</strong>. 由于静态类型在编译期可知, 所以在编译阶段, Javac 编译器就<strong>根据参数的静态类型决定了会使用哪个重载版本</strong>, 因此选择了 sayHello(Human) 作为调用目标, 并把这个方法的符号引用写到 main() 方法里的两条 invokevirtual 指令的参数中.</p> <blockquote><p>静态分派定义</p></blockquote> <p><mark><strong>所有依赖静态类型来决定方法执行版本的分派动作, 都称为静态分派. 静态分派的最典型应用表现就是方法重载. 静态分派发生在编译阶段, 因此确定静态分派的动作实际上不是由虚拟机来执行的</strong></mark>, 这点也是为何一些资料选择把它归入 &quot;<strong>解析</strong>&quot; 而不是 &quot;分派&quot; 的原因.</p> <blockquote><p>选择合适的重载方法</p></blockquote> <p>需要注意 Javac 编译器虽然能确定出方法的<strong>重载版本</strong>, 但在很多情况下这个重载版本并不是 &quot;唯一&quot; 的, 往往只能确定一个 &quot;<strong>相对更合适的</strong>&quot; 版本. 这种模糊的结论在由 0 和 1 构成的计算机世界中算是个比较稀罕的事件, 产生这种模糊结论的主要原因是字面量天生的模糊性, 它不需要定义, 所以字面量就没有显式的静态类型, 它的<strong>静态类型只能通过语言, 语法的规则去理解和推断</strong>. 代码清单 8-7 演示了何谓 &quot;更加合适的&quot; 版本.</p> <blockquote><p>代码清单8-7 重载方法匹配优先级示例</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>polymorphic</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Overload</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Object</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello Object&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello int&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">long</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello long&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Character</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello Character&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">char</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello char&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello char ...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Serializable</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello Serializable&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p>上面的代码运行后会输出:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>hello char
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这很好理解, 'a' 是一个 char 类型的数据, <strong>自然会寻找参数类型为 char 的重载方法</strong>, 如果注释掉 sayHello(char arg) 方法, 那输出会变为:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>hello int
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这时发生了一次<strong>自动类型转换</strong>, 'a' 除了可以代表一个字符串, 还可以代表数字 97(字符 'a' 的 Unicode 数值为十进制数字 97), 因此参数类型为 int 的重载也是合适的. 继续注释掉 sayHello(int arg) 方法, 那输出会变为:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>hello long
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这时发生了<strong>两次自动类型转换</strong>, 'a' 转型为整数 97 之后, 进一步转型为长整数 97L, 匹配了参数类型为 long 的重载. 笔者在代码中没有写其他的类型如 float, double 等的重载, 不过实际上自动转型还能继续发生多次, 按照 <code>char &gt; int &gt; long &gt; float &gt; double</code>​ 的顺序转型进行匹配, 但不会匹配到 byte 和 short 类型的重载, 因为 char 到 byte 或 short 的转型是<strong>不安全</strong>的. 继续注释掉 sayHello(long arg)方法, 那输出会变为:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>hello Character
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这时发生了一次自动装箱, 'a' 被包装为它的封装类型 java.lang.Character, 所以匹配到了参数类型为 Character 的重载, 继续注释掉 sayHello(Character arg) 方法, 那输出会变为:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>hello Serializable
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这个输出可能会让人摸不着头脑, 一个字符或数字与序列化有什么关系? 出现 hello Serializable, 是因为 <strong>java.lang.Serializable 是 java.lang.Character 类实现的一个接口</strong>, 当自动装箱之后发现还是找不到装箱类, 但是找到了装箱类所实现的接口类型, 所以紧接着又发生一次自动转型. char 可以转型成 int, 但是 Character 是绝对不会转型为 Integer 的, 它只能安全地转型为它实现的接口或父类. Character 还实现了另外一个接口 <code>java.lang.Comparable&lt;Character&gt;</code>​, 如果同时出现两个参数分别为 Serializable 和 <code>Comparable&lt;Character&gt;</code>​ 的重载方法, 那它们在此时的优先级是一样的. 编译器无法确定要自动转型为哪种类型, 会提示 &quot;<strong>类型模糊</strong>&quot;(Type Ambiguous), 并拒绝编译. <strong>程序必须在调用时显式地指定字面量的静态类型</strong>, 如: <code>sayHello((Comparable&lt;Character&gt;)'a'</code>​), 才能编译通过. 但是如果读者愿意花费一点时间, 绕过 Javac 编译器, 自己去构造出表达相同语义的字节码, 将会发现这是能够通过 Java 虚拟机的类加载校验, 而且能够被 Java 虚拟机正常执行的, 但是会选择 Serializable 还是 <code>Comparable&lt;Character&gt;</code>​ 的重载方法则并不能事先确定, 这是《Java 虚拟机规范》所允许的, 在前面介绍接口方法解析过程时曾经提到过.</p> <p>下面继续注释掉 sayHello(Serializable arg) 方法, 输出会变为:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>hello Object
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这时是 char 装箱后<strong>转型为父类</strong>了, 如果有多个父类, 那将在继承关系中从下往上开始搜索, 越接上层的优先级越低. 即使方法调用传入的参数值为 null 时, 这个规则仍然适用. 把 sayHello(Object arg) 也注释掉, 输出将会变为:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>hello char ...
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>7 个重载方法已经被注释得只剩 1 个了, 可见<strong>变长参数的重载优先级是最低的</strong>, 这时候字符 'a' 被当作了一个 char[] 数组的元素. 笔者使用的是 char 类型的变长参数, 读者在验证时还可以选择 int 类型, Character 类型, Object 类型等的变长参数重载来把上面的过程重新折腾一遍. 但是要注意的是, 有一些在单个参数中能成立的自动转型, 如 char 转型为 int, 在变长参数中是不成立的.</p> <p>代码清单 8-7 演示了<strong>编译期间选择静态分派目标的过程, 这个过程也是 Java 语言实现方法重载的本质</strong>. 演示所用的这段程序无疑是属于很极端的例子, 除了用作面试题为难求职者之外, 在实际工作中几乎不可能存在任何有价值的用途, 拿来做演示仅仅是用于讲解重载时目标方法选择的过程, 对绝大多数下进行这样极端的重载都可算作真正的 &quot;关于茴香豆的茴有几种写法的研究&quot;. 无论对重载的认识有多么深刻, 一个合格的程序员都不应该在实际应用中写这种晦涩的重载代码.</p> <blockquote><p>解析与静态分派的关系</p></blockquote> <p>另外还有一点读者可能比较容易混淆: 笔者讲述的<mark><strong>解析与分派这两者之间的关系并不是二选一的排他关系, 它们是在不同层次上去筛选, 确定目标方法的过程</strong></mark>. 例如前面说过<strong>静态方法会在编译期确定, 在类加载期就进行解析, 而静态方法显然也是可以拥有重载版本的, 选择重载版本的过程也是通过静态分派完成的</strong>.</p> <h6 id="_2-动态分派"><a href="#_2-动态分派" class="header-anchor">#</a> (2)动态分派</h6> <p>在<strong>运行期</strong>根据<strong>实际类</strong>型确定方法执行<strong>版本</strong>的分派过程称为<strong>动态分派</strong>.</p> <p>接下来看一下 Java 语言里<strong>动态分派的实现过程</strong>, 它与 Java 语言多态性的另外一个重要应用---<mark><strong>重写</strong></mark>(Override)有着很密切的关联. 还是用前面的 Man 和 Woman 一起 sayHello 的例子来讲解动态分派, 请看代码清单 8-8 中所示的代码.</p> <blockquote><p>代码清单8-8 方法动态分派示例</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>polymorphic</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicDispatch</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
        <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;man say hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;woman say hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Human</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Human</span> woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        man<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        woman<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        man<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>运行结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>man say hello
woman say hello
woman say hello
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>对于习惯了面向对象思维的 Java 程序员们会觉得这是完全理所当然的结论. 现在的问题还是和前面的一样, Java <mark><strong>虚拟机是如何判断应该调用哪个方法</strong></mark>的?</p> <p>显然这里选择调用的方法版本是不可能再根据静态类型来决定的, 因为静态类型同样都是 Human 的两个变量 man 和 woman 在调用 sayHello() 方法时产生了不同的行为, 甚至变量 man 在两次调用中还执行了两个不同的方法. 导致这个现象的原因很明显, 是因为这两个变量的实际类型不同, Java 虚拟机是如何<strong>根据实际类型来分派方法执行版本</strong>的呢? 下面使用 javap 命令输出这段代码的字节码, 尝试从中寻找答案, 输出结果如代码清单 8-9 所示.</p> <blockquote><p>代码清单8-9 main()方法的字节码</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Code</span><span class="token operator">:</span>
        <span class="token class-name">Stack</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">Locals</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">Args_size</span><span class="token operator">=</span><span class="token number">1</span>
         <span class="token number">0</span><span class="token operator">:</span>   <span class="token keyword">new</span>     #<span class="token number">16</span><span class="token punctuation">;</span> <span class="token comment">//class org/fenixsoft/polymorphic/DynamicDispatch$Man</span>
         <span class="token number">3</span><span class="token operator">:</span>   dup
         <span class="token number">4</span><span class="token operator">:</span>   invokespecial   #<span class="token number">18</span><span class="token punctuation">;</span> <span class="token comment">//Method org/fenixsoft/polymorphic/Dynamic Dispatch$Man.&quot;&lt;init&gt;&quot;:()V</span>
         <span class="token number">7</span><span class="token operator">:</span>   astore_1
         <span class="token number">8</span><span class="token operator">:</span>   <span class="token keyword">new</span>     #<span class="token number">19</span><span class="token punctuation">;</span> <span class="token comment">//class org/fenixsoft/polymorphic/DynamicDispatch$Woman</span>
        <span class="token number">11</span><span class="token operator">:</span>  dup
        <span class="token number">12</span><span class="token operator">:</span>  invokespecial   #<span class="token number">21</span><span class="token punctuation">;</span> <span class="token comment">//Method org/fenixsoft/polymorphic/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span>
        <span class="token number">15</span><span class="token operator">:</span>  astore_2
        <span class="token number">16</span><span class="token operator">:</span>  aload_1
        <span class="token number">17</span><span class="token operator">:</span>  invokevirtual   #<span class="token number">22</span><span class="token punctuation">;</span> <span class="token comment">//Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span>
        <span class="token number">20</span><span class="token operator">:</span>  aload_2
        <span class="token number">21</span><span class="token operator">:</span>  invokevirtual   #<span class="token number">22</span><span class="token punctuation">;</span> <span class="token comment">//Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span>
        <span class="token number">24</span><span class="token operator">:</span>  <span class="token keyword">new</span>     #<span class="token number">19</span><span class="token punctuation">;</span> <span class="token comment">//class org/fenixsoft/polymorphic/DynamicDispatch$Woman</span>
        <span class="token number">27</span><span class="token operator">:</span>  dup
        <span class="token number">28</span><span class="token operator">:</span>  invokespecial   #<span class="token number">21</span><span class="token punctuation">;</span> <span class="token comment">//Method org/fenixsoft/polymorphic/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span>
        <span class="token number">31</span><span class="token operator">:</span>  astore_1
        <span class="token number">32</span><span class="token operator">:</span>  aload_1
        <span class="token number">33</span><span class="token operator">:</span>  invokevirtual   #<span class="token number">22</span><span class="token punctuation">;</span> <span class="token comment">//Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span>
        <span class="token number">36</span><span class="token operator">:</span>  <span class="token keyword">return</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>0～15 行的字节码是<strong>准备动作</strong>, 作用是建立 man 和 woman 的内存空间, 调用 Man 和 Woman 类型的<strong>实例构造器</strong>, 将这两个实例的引用存放在第 1, 2 个局部变量表的变量槽中, 这些动作实际对应了 Java 源码中的这两行:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Human</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Human</span> woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>接下来的 16～21 行是关键部分, 16 和 20 行的 aload 指令分别<strong>把刚刚创建的两个对象的引用压到栈顶</strong>, 这两个对象是<strong>将要执行的 sayHello() 方法的所有者</strong>, 称为<strong>接收者</strong>(Receiver); 17 和 21 行是<strong>方法调用指令</strong>, 这两条调用指令单从字节码角度来看, 无论是指令(都是 invokevirtual)还是参数(都是常量池中第 22 项的常量, 注释显示了这个常量是 Human.sayHello() 的符号引用)都完全一样, 但是<strong>这两句指令最终执行的目标方法并不相同</strong>. 那看来解决问题的关键还必须从 invokevirtual 指令本身入手, 要弄清楚它是如何确定调用方法版本, 如何实现多态查找来着手分析才行. 根据《Java 虚拟机规范》, <mark><strong>invokevirtual 指令的运行时解析过程</strong></mark>大致分为以下几步:</p> <ol><li>找到<strong>操作数栈顶</strong>的第一个元素所指向的对象的<strong>实际类型</strong>, 记作 C.</li> <li>如果在类型 C 中找到<strong>与常量中的描述符和简单名称都相符的方法, 则进行访问权限校验</strong>, 如果通过则返回这个方法的直接引用, 查找过程结束; 不通过则返回 java.lang.IllegalAccessError 异常.</li> <li>否则, 按照继承关系从下往上依次对 C 的<strong>各个父类</strong>进行第二步的搜索和验证过程.</li> <li>如果始终没有找到合适的方法, 则抛出 java.lang.AbstractMethodError 异常.</li></ol> <p><mark><strong>正是因为 invokevirtual 指令执行的第一步就是在运行期确定接收者的实际类型, 所以两次调用中的 invokevirtual 指令并不是把常量池中方法的符号引用解析到直接引用上就结束了, 还会根据方法接收者的实际类型来选择方法版本, 这个过程就是 Java 语言中方法重写的本质. 这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派.</strong></mark></p> <p>既然这种<strong>多态性的根源在于虚方法调用指令 invokevirtual 的执行逻辑</strong>, 那自然可以得出的结论就<mark><strong>只会对方法有效, 对字段是无效的, 因为字段不使用这条指令</strong></mark>. 事实上, 在 Java 里面只有虚方法存在, 字段永远不可能是虚的, 换句话说, 字段永远不参与多态, 哪个类的方法访问某个名字的字段时, 该名字指的就是这个类能看到的那个字段. <strong>当子类声明了与父类同名的字段时, 虽然在子类的内存中两个字段都会存在, 但是子类的字段会遮蔽父类的同名字段</strong>. 为了加深理解, 下面又编撰了一份 &quot;劣质面试题式&quot; 的代码片段, 请阅读代码清单 8-10, 思考运行后会输出什么结果.</p> <blockquote><p>代码清单8-10 字段没有多态性示例</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>polymorphic</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 字段不参与多态
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FieldHasNoPolymorphic</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> money <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            money <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;I am Father, i have $&quot;</span> <span class="token operator">+</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> money <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            money <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
            <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;I am Son,  i have $&quot;</span> <span class="token operator">+</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Father</span> gay <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;This gay has $&quot;</span> <span class="token operator">+</span> gay<span class="token punctuation">.</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p>运行后输出结果为:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>I am Son, i have $0
I am Son, i have $4
This gay has $2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>输出两句都是 &quot;I am Son&quot;, 这是因为 Son 类在创建的时候, 首先<strong>隐式调用了 Father 的构造函数</strong>, 而 Father 构造函数中对 showMeTheMoney() 的调用是一次虚方法调用, 实际执行的版本是 <code>Son::showMeTheMoney()</code>​ 方法, 所以输出的是 &quot;I am Son&quot;, 这点经过前面的分析相信读者是没有疑问的了. 而这时候虽然父类的 money 字段已经被初始化成 2 了, 但 <code>Son::showMeTheMoney()</code>​ 方法中访问的却是<strong>子类的 money 字段</strong>, 这时候结果自然还是 0, 因为它要到子类的构造函数执行时才会被初始化. main() 的最后一句通过静态类型访问到了父类中的 money, 输出了 2.</p> <h6 id="_3-单分派与多分派"><a href="#_3-单分派与多分派" class="header-anchor">#</a> (3)单分派与多分派</h6> <p><strong>方法的接收者与方法的参数统称为方法的宗量</strong>, 这个定义最早应该来源于著名的《Java 与模式》一书. <strong>根据分派基于多少种宗量, 可以将分派划分为单分派和多分派两种. 单分派是根据一个宗量对目标方法进行选择, 多分派则是根据多于一个宗量对目标方法进行选择</strong>.</p> <p>单分派和多分派的定义读起来拗口, 从字面上看也比较抽象, 不过对照着实例看并不难理解其含义, 代码清单 8-11 中举了一个 Father 和 Son 一起来做出 &quot;一个艰难的决定&quot; 的例子.</p> <blockquote><p>代码清单8-11 单分派和多分派示例</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * 单分派, 多分派演示
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dispatch</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">QQ</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> _360 <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hardChoice</span><span class="token punctuation">(</span><span class="token class-name">QQ</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;father choose qq&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hardChoice</span><span class="token punctuation">(</span>_360 arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;father choose 360&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hardChoice</span><span class="token punctuation">(</span><span class="token class-name">QQ</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;son choose qq&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hardChoice</span><span class="token punctuation">(</span>_360 arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;son choose 360&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Father</span> father <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Father</span> son <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        father<span class="token punctuation">.</span><span class="token function">hardChoice</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">_360</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        son<span class="token punctuation">.</span><span class="token function">hardChoice</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">QQ</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>运行结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>father choose 360
son choose qq
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在 main() 里调用了两次 hardChoice() 方法, 这两次 hardChoice() 方法的选择结果在程序输出中已经显示得很清楚了. 这里关注的首先是编译阶段中编译器的选择过程, 也就是<strong>静态分派</strong>的过程. 这时候选择目标方法的依据有两点: 一是静态类型是 Father 还是 Son, 二是方法参数是 QQ 还是 360. 这次选择结果的最终产物是产生了两条 invokevirtual 指令, 两条指令的参数分别为常量池中指向 <code>Father::hardChoice(360)</code>​ 及 <code>Father::hardChoice(QQ)</code>​ 方法的符号引用. 因为是根据两个宗量进行选择, 所以 <strong>Java 语言的静态分派属于多分派类型</strong>.</p> <p>再看看运行阶段中虚拟机的选择, 也就是动态分派的过程. 在执行 &quot;<code>son.hardChoice(new QQ())</code>​&quot; 这行代码时, 更准确地说, 是在执行这行代码所对应的 invokevirtual 指令时, 由于编译期已经决定目标方法的签名必须为 hardChoice(QQ), 虚拟机此时不会关心传递过来的参数 &quot;QQ&quot; 到底是 &quot;腾讯 QQ&quot; 还是 &quot;奇瑞 QQ&quot;, 因为这时候参数的静态类型, 实际类型都对方法的选择不会构成任何影响, <strong>唯一可以影响虚拟机选择的因素只有该方法的接受者的实际类型是 Father 还是 Son. 因为只有一个宗量作为选择依据, 所以 Java 语言的动态分派属于单分派类型</strong>.</p> <p>根据上述论证的结果, 可以总结一句: 如今 Java 语言<mark><strong>是一门静态多分派, 动态单分派的语言</strong></mark>. 强调 &quot;如今的 Java 语言&quot; 是因为这个结论<strong>未必会恒久不变</strong>.</p> <p><strong>按照目前 Java 语言的发展趋势, 它并没有直接变为动态语言的迹象, 而是通过内置动态语言(如 JavaScript)执行引擎, 加强与其他 Java 虚拟机上动态语言交互能力的方式来间接地满足动态性的需求</strong>. 但是作为多种语言共同执行平台的 Java 虚拟机层面上则不是如此, 早在 JDK 7 中实现的 JSR-292 里面就已经开始提供对动态语言的方法调用支持了, JDK 7 中新增的 invokedynamic 指令也成为最复杂的一条方法调用的字节码指令, 稍后将在本章中专门开一节来讲解这个与 Java 调用动态语言密切相关的特性.</p> <h6 id="_4-虚拟机动态分派的实现"><a href="#_4-虚拟机动态分派的实现" class="header-anchor">#</a> (4)虚拟机动态分派的实现</h6> <p>前面介绍的分派过程, 作为对 Java 虚拟机概念模型的解释基本上已经足够了, 它已经解决了虚拟机在分派中 &quot;会做什么&quot; 这个问题. 但如果问虚拟机 &quot;<strong>具体如何做到</strong>&quot; 的, 答案则可能因各种虚拟机的实现不同会有些差别.</p> <p>动态分派是执行非常频繁的动作, 而且<strong>动态分派的方法版本选择过程需要运行时在接收者类型的方法元数据中搜索合适的目标方法</strong>, 因此 Java 虚拟机实现基于执行性能的考虑, 真正运行时一般不会如此频繁地去反复搜索类型元数据. 面对这种情况, 一种<strong>基础而且常见的优化手段是为类型</strong>​<mark><strong>在方法区中建立一个虚方法表</strong></mark>​ <strong>(Virtual Method Table, 也称为 vtable, 与此对应的, 在 invokeinterface 执行时也会用到</strong>​<mark><strong>接口方法表</strong></mark>​ <strong>, Interface Method Table, 简称 itable), 使用虚方法表索引来代替元数据查找以提高性能</strong>. 先看看代码清单 8-11 所对应的虚方法表结构示例, 如图 8-3 所示.</p> <p><img src="/img/Image00176-20240302133505-mrl0dtj.jpg" alt="" title="图8-3　方法表结构"></p> <p><mark><strong>虚方法表中存放着各个方法的实际入口地址. 如果某个方法在子类中没有被重写, 那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的, 都指向父类的实现入口. 如果子类中重写了这个方法, 子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址</strong></mark>. 在图 8-3 中, Son 重写了来自 Father 的全部方法, 因此 Son 的方法表没有指向 Father 类型数据的箭头. 但是 Son 和 Father 都没有重写来自 Object 的方法, 所以它们的方法表中所有从 Object 继承来的方法都指向了 Object 的数据类型.</p> <p>为了程序实现方便, <strong>具有相同签名的方法, 在父类, 子类的虚方法表中都应当具有一样的索引序号</strong>, 这样当类型变换时, 仅需要变更查找的虚方法表, 就可以从不同的虚方法表中按索引转换出所需的入口地址. <strong>虚方法表一般在类加载的连接阶段进行初始化, 准备了类的变量初始值后, 虚拟机会把该类的虚方法表也一同初始化完毕</strong>.</p> <p>上文中提到了查虚方法表是分派调用的一种优化手段, 由于 Java 对象里面的方法默认(即不使用 final 修饰)就是虚方法, 虚拟机除了使用虚方法表之外, 为了进一步提高性能, 还会使用<strong>类型继承关系分析</strong>(Class Hierarchy Analysis, CHA), <strong>守护内联</strong>(Guarded Inlining), <strong>内联缓存</strong>(Inline Cache)等多种非稳定的激进优化来争取更大的性能空间, 关于这几种优化技术的原理和运作过程, 可以参考第 11 章中的相关内容.</p> <h4 id="动态类型语言支持"><a href="#动态类型语言支持" class="header-anchor">#</a> 动态类型语言支持</h4> <p>Java 虚拟机的字节码指令集的数量在二十余年间只新增过一条指令, 它就是随着 JDK 7 的发布的字节码首位新成员---<strong>invokedynamic 指令</strong>. 这条新增加的指令是 JDK 7 的项目目标: <strong>实现动态类型语言</strong>支持而进行的改进之一, 也是为 JDK 8 里可以顺利实现 Lambda 表达式而做的技术储备. 在本节中将详细了解动态语言支持这项特性出现的前因后果和它的意义与价值.</p> <h5 id="_1-动态类型语言"><a href="#_1-动态类型语言" class="header-anchor">#</a> 1.动态类型语言</h5> <p>在介绍 Java 虚拟机的动态类型语言支持之前, 要先弄明白<strong>动态类型语言是什么</strong>? 它与 Java 语言, Java 虚拟机有什么关系? 了解 <strong>Java 虚拟机提供动态类型语言支持的技术背景</strong>, 对理解这个语言特性是非常有必要的.</p> <p>何谓<strong>动态类型语言</strong>? 动态类型语言的<strong>关键特征是它的</strong>​<mark><strong>类型检查的主体过程</strong></mark>​<strong>是在运行期而不是编译期进行的</strong>, 满足这个特征的语言有很多, 常用的包括: APL, Clojure, Erlang, Groovy, JavaScript, Lisp, Lua, PHP, Prolog, Python, Ruby, 等等. 那相对地, <strong>在编译期就进行类型检查过程的语言, 譬如 C++ 和 Java 等就是最常用的静态类型语言</strong>.</p> <p>如果读者觉得上面的定义过于概念化, 那不妨通过两个例子以最浅显的方式来说明什么是 &quot;类型检查&quot; 和什么叫 &quot;在编译期还是在运行期进行&quot;. 首先看下面这段简单的 Java 代码, 思考一下它是否能正常编译和运行?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面这段 Java 代码<strong>能够正常编译</strong>, 但运行的时候会出现 NegativeArraySizeException 异常. 在《Java 虚拟机规范》中明确规定了 NegativeArraySizeException 是一个运行时异常(Runtime Exception), 通俗一点说, <strong>运行时异常就是指只要代码不执行到这一行就不会出现问题</strong>. 与运行时异常相对应的概念是连接时异常, 例如很常见的 NoClassDefFoundError 便属于连接时异常, 即使导致连接时异常的代码放在一条根本无法被执行到的路径分支上, 类加载时也照样会抛出异常.</p> <p>不过, 在 C 语言里, 语义相同的代码就会在编译期就直接报错, 而不是等到运行时才出现异常:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// GCC 拒绝编译, 报“size of array is negative”</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>由此看来, <strong>一门语言的哪一种检查行为要在运行期进行, 哪一种检查要在编译期进行并没有什么必然的因果逻辑关系, 关键是在语言规范中人为设立的约定</strong>.</p> <p>解答了什么是 &quot;连接时, 运行时&quot;, 再举一个例子来解释什么是 &quot;<mark><strong>类型检查</strong></mark>&quot;, 例如下面这一句再普通不过的代码:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>obj<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>虽然大家都能看懂这行代码要做什么, 但对于计算机来讲, 这一行 &quot;没头没尾&quot; 的代码是无法执行的, 它需要一个具体的上下文中(譬如程序语言是什么, obj 是什么类型)才有讨论的意义.</p> <p>现在先假设这行代码是在 Java 语言中, 并且变量 obj 的静态类型为 java.io.PrintStream, 那变量 obj 的实际类型就必须是 PrintStream 的子类(实现了 PrintStream 接口的类)才是合法的. 否则, 哪怕 obj 属于一个确实包含有 println(String) 方法相同签名方法的类型, 但只要它与 PrintStream 接口没有继承关系, 代码依然不可能运行, 因为类型检查不合法.</p> <p>但是相同的代码在 ECMAScript(JavaScript) 中情况则不一样, 无论 obj 具体是何种类型, 无论其继承关系如何, 只要这种类型的方法定义中确实包含有 println(String)方法, 能够找到相同签名的方法, 调用便可成功.</p> <p>产生这种差别产生的<strong>根本原因是 Java 语言在编译期间却已将 println(String)方法完整的符号引用(本例中为一项 CONSTANT_InterfaceMethodref_info 常量)生成出来, 并作为方法调用指令的参数存储到 Class 文件中</strong>, 例如下面这个样子:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>invokevirtual #<span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">//Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这个符号引用包含了该方法定义在哪个具体类型之中, 方法的名字以及参数顺序, 参数类型和方法返回值等信息, 通过这个符号引用, Java 虚拟机就可以翻译出该方法的直接引用. 而 ECMAScript 等动态类型语言与 Java 有一个核心的差异就是变量 obj 本身并没有类型, 变量 obj 的值才具有类型, 所以编译器在编译时最多只能确定方法名称, 参数, 返回值这些信息, 而不会去确定方法所在的具体类型(即方法接收者不固定).  **&quot;**​<mark><strong>变量无类型而变量值才有类型</strong></mark>​ <strong>&quot; 这个特点也是动态类型语言的一个核心特征</strong>.</p> <p>了解了动态类型和静态类型语言的区别后, 也许下一个问题就是<strong>动态, 静态类型语言两者谁更好</strong>, 或者谁更加先进呢? 这种比较不会有确切答案, 它们都有自己的优点, 选择哪种语言是需要权衡的事情. <strong>静态类型语言能够在编译期确定变量类型, 最显著的好处是编译器可以提供全面严谨的类型检查, 这样与数据类型相关的潜在问题就能在编码时被及时发现, 利于稳定性及让项目容易达到更大的规模. 而动态类型语言在运行期才确定类型, 这可以为开发人员提供极大的灵活性, 某些在静态类型语言中要花大量臃肿代码来实现的功能, 由动态类型语言去做可能会很清晰简洁, 清晰简洁通常也就意味着开发效率的提升</strong>.</p> <h5 id="_2-java与动态类型"><a href="#_2-java与动态类型" class="header-anchor">#</a> 2.Java与动态类型</h5> <p>现在回到本节的主题, 来看看 <strong>Java 语言, Java 虚拟机与动态类型语言之间有什么关系</strong>. Java 虚拟机毫无疑问是 Java 语言的运行平台, 但它的使命并不限于此, 《Java 虚拟机规范》中规划了这样一个愿景: &quot;<strong>在未来会对 Java 虚拟机进行适当的扩展, 以便更好地支持其他语言运行于 Java 虚拟机之上.</strong> &quot; 而目前确实已经有许多动态类型语言运行于 Java 虚拟机之上了, 如 Clojure, Groovy, Jython 和 JRuby 等, 能够在同一个虚拟机之上可以实现静态类型语言的严谨与动态类型语言的灵活, 这的确是一件很美妙的事情.</p> <p>但遗憾的是 Java 虚拟机层面对动态类型语言的支持一直都还有所欠缺, 主要表现在方法调用方面: JDK 7 以前的字节码指令集中, 4 条方法调用指令(invokevirtual, invokespecial, invokestatic, invokeinterface)的第一个参数都是被调用的方法的符号引用(CONSTANT_Methodref_info 或者 CONSTANT_InterfaceMethodref_info 常量), 前面已经提到过, <strong>方法的符号引用在编译时产生, 而动态类型语言只有在运行期才能确定方法的接收者</strong>. 这样, 在虚拟机上实现的动态类型语言就不得不使用 &quot;曲线救国&quot; 的方式(如编译时留个占位符类型, 运行时动态生成字节码实现具体类型到占位符类型的适配)来实现, 但这样势必会让动态类型语言实现的复杂度增加, 也会带来额外的性能和内存开销. 内存开销是很显而易见的, 方法调用产生的那一大堆的动态类就摆在那里. <strong>而其中最严重的性能瓶颈是在于动态类型方法调用时, 由于无法确定调用对象的静态类型, 而导致的方法内联无法有效进行</strong>. 在第 11 章里会讲到方法内联的重要性, 它是其他优化措施的基础, 也可以说是最重要的一项优化. 尽管也可以想一些办法(譬如调用点缓存)尽量缓解支持动态语言而导致的性能下降, 但这种改善毕竟不是本质的. 譬如有类似以下代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">var</span> arrays <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ObjectX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token class-name">Dog</span><span class="token punctuation">,</span> <span class="token class-name">Cat</span><span class="token punctuation">,</span> <span class="token class-name">Car</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>item in arrays<span class="token punctuation">)</span><span class="token punctuation">{</span>
    item<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在动态类型语言下这样的代码是没有问题, 但由于在运行时 arrays 中的元素可以是任意类型, 即使它们的类型中都有 sayHello() 方法, 也肯定无法在编译优化的时候就确定具体 sayHello() 的代码在哪里, 编译器只能不停编译它所遇见的每一个 sayHello() 方法, 并缓存起来供执行时选择, 调用和内联, 如果 arrays 数组中不同类型的对象很多, 就势必会对内联缓存产生很大的压力, 缓存的大小总是有限的, 类型信息的不确定性导致了缓存内容不断被失效和更新, 先前优化过的方法也可能被不断替换而无法重复使用. 所以<strong>这种动态类型方法调用的底层问题终归是应当在 Java 虚拟机层次上去解决才最合适</strong>. 因此, 在 Java 虚拟机层面上提供动态类型的直接支持就成为 Java 平台发展必须解决的问题, 这便是 JDK 7 时 JSR-292 提案<strong>中 invokedynamic 指令以及 java.lang.invoke 包出现的技术背景</strong>.</p> <h5 id="_3-java-lang-invoke包"><a href="#_3-java-lang-invoke包" class="header-anchor">#</a> 3.java.lang.invoke包</h5> <p>JDK 7 时新加入的 <mark><strong>java.lang.invoke</strong></mark> 包是 JSR 292 的一个重要组成部分, 这个包的主要目的是<mark><strong>在之前单纯依靠符号引用来确定调用的目标方法这条路之外, 提供一种新的动态确定目标方法的机制, 称为 &quot;方法句柄&quot;(Method Handle)</strong></mark> . 这个表达听起来也不好懂? 那不妨把方法句柄与 C/C++ 中的函数指针(Function Pointer), 或者 <code>C#</code>​ 里面的委派(Delegate)互相类比一下来理解. 举个例子, 如果要实现一个带<strong>谓词</strong>(谓词就是由外部传入的排序时比较大小的动作)的排序函数, 在 C/C++ 中的常用做法是把谓词定义为函数, 用函数指针来把谓词传递到排序方法, 像这样:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> list<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>compare<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>但在 Java 语言中做不到这一点, <strong>没有办法单独把一个函数作为参数进行传递</strong>. 普遍的做法是设计一个带有 compare() 方法的 Comparator 接口, 以实现这个接口的对象作为参数, 例如 Java 类库中的 Collections::sort() 方法就是这样定义的:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">List</span> list<span class="token punctuation">,</span> <span class="token class-name">Comparator</span> c<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>不过, 在拥有<strong>方法句柄</strong>之后, Java 语言也可以拥有类似于函数指针或者委托的方法别名这样的工具了. 代码清单 8-12 演示了方法句柄的基本用法, 无论 obj 是何种类型(临时定义的 ClassA 抑或是实现 PrintStream 接口的实现类 System.out), 都可以正确调用到 println() 方法.</p> <blockquote><p>代码清单8-12 方法句柄演示</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span></span><span class="token class-name">MethodHandles</span><span class="token punctuation">.</span><span class="token static">lookup</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span></span><span class="token class-name">MethodHandle</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span></span><span class="token class-name">MethodType</span></span><span class="token punctuation">;</span>

<span class="token comment">/**
 * JSR 292 MethodHandle 基础用法演示
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodHandleTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ClassA</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">ClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 无论 obj 最终是哪个实现类, 下面这句都能正确调用到 println 方法. </span>
        <span class="token function">getPrintlnMH</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invokeExact</span><span class="token punctuation">(</span><span class="token string">&quot;icyfenix&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">MethodHandle</span> <span class="token function">getPrintlnMH</span><span class="token punctuation">(</span><span class="token class-name">Object</span> reveiver<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token comment">// MethodType: 代表“方法类型”, 包含了方法的返回值(methodType()的第一个参数)和</span>
        <span class="token comment">// 具体参数(methodType()第二个及以后的参数). </span>
        <span class="token class-name">MethodType</span> mt <span class="token operator">=</span> <span class="token class-name">MethodType</span><span class="token punctuation">.</span><span class="token function">methodType</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// lookup()方法来自于 MethodHandles.lookup, 这句的作用是在指定类中查找符合给定的方法</span>
        <span class="token comment">// 名称, 方法类型, 并且符合调用权限的方法句柄. </span>
        <span class="token comment">// 因为这里调用的是一个虚方法, 按照 Java 语言的规则, 方法第一个参数是隐式的, 代表该方法的接</span>
        <span class="token comment">// 收者, 也即 this 指向的对象, 这个参数以前是放在参数列表中进行传递, 现在提供了 bindTo()</span>
        <span class="token comment">// 方法来完成这件事情. </span>
        <span class="token keyword">return</span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findVirtual</span><span class="token punctuation">(</span>reveiver<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;println&quot;</span><span class="token punctuation">,</span> mt<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bindTo</span><span class="token punctuation">(</span>reveiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>方法 getPrintlnMH() 中实际上是模拟了 invokevirtual 指令的执行过程, 只不过它的分派逻辑并非固化在 Class 文件的字节码上, 而是通过一个<strong>由用户设计的 Java 方法来实现</strong>. 而这个方法本身的返回值(MethodHandle 对象), 可以视为对最终调用方法的一个 &quot;引用&quot;. 以此为基础, 有了 MethodHandle 就可以写出类似于 C/C++ 那样的函数声明了:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">List</span> list<span class="token punctuation">,</span> <span class="token class-name">MethodHandle</span> compare<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>从上面的例子看来, 使用 MethodHandle 并没有多少困难, 不过看完它的用法之后, 读者大概就会产生疑问, 相同的事情, 用反射不是早就可以实现了吗?</p> <p>确实, 仅站在 Java 语言的角度看, MethodHandle 在使用方法和效果上与 Reflection 有众多相似之处. 不过, 它们也有以下这些区别:</p> <ul><li><mark><strong>Reflection 和 MethodHandle 机制本质上都是在模拟方法调用, 但是 Reflection 是在模拟 Java 代码层次的方法调用, 而 MethodHandle 是在模拟字节码层次的方法调用</strong></mark>. 在 MethodHandles.Lookup 上的 3 个方法 findStatic(), findVirtual(), findSpecial() 正是为了对应于 invokestatic, invokevirtual(以及 invokeinterface) 和 invokespecial 这几条字节码指令的执行权限校验行为, 而这些底层细节在使用 Reflection API 时是不需要关心的.</li> <li><strong>Reflection 中的 java.lang.reflect.Method 对象远比 MethodHandle 机制中的 java.lang.invoke.MethodHandle 对象所包含的信息来得多</strong>. 前者是方法在 Java 端的<strong>全面映像</strong>, 包含了方法的签名, 描述符以及方法属性表中各种属性的 Java 端表示方式, 还包含执行权限等的运行期信息. 而后者<strong>仅包含执行该方法的相关信息</strong>. 用开发人员通俗的话来讲, <mark><strong>Reflection 是重量级, 而 MethodHandle 是轻量级</strong></mark>.</li> <li>由于 <strong>MethodHandle 是对字节码的方法指令调用的模拟</strong>, 那理论上虚拟机在这方面做的各种优化(如方法内联), 在 MethodHandle 上也应当可以采用类似思路去支持(但目前实现还在继续完善中), 而<strong>通过反射去调用方法则几乎不可能直接去实施各类调用点优化措施</strong>.</li></ul> <p>MethodHandle 与 Reflection 除了上面列举的区别外, 最关键的一点还在于去掉前面讨论施加的前提 &quot;仅站在 Java 语言的角度看&quot; 之后: <strong>Reflection API 的设计目标是只为 Java 语言服务的, 而 MethodHandle 则设计为可服务于所有 Java 虚拟机之上的语言, 其中也包括了 Java 语言而已, 而且 Java 在这里并不是主角</strong>.</p> <h5 id="_4-invokedynamic指令"><a href="#_4-invokedynamic指令" class="header-anchor">#</a> 4.invokedynamic指令</h5> <p>前面提到了 JDK 7 <strong>为了更好地支持动态类型语言, 引入了第五条方法调用的字节码指令 invokedynamic, 那么 invokedynamic 到底有什么应用</strong>呢?</p> <p><strong>某种意义上可以说 invokedynamic 指令与 MethodHandle 机制的作用是一样的, 都是为了解决原有 4 条</strong> &quot;<code>invoke*</code>​&quot; <strong>指令方法分派规则完全固化在虚拟机之中的问题, 把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中, 让用户(广义的用户, 包含其他程序语言的设计者)有更高的自由度</strong>. 而且, 它们两者的思路也是可类比的, 都是为了达成同一个目的, 只是一个用上层代码和 API 来实现, 另一个用字节码和 Class 中其他属性, 常量来完成. 因此, 如果前面 MethodHandle 的例子看懂了, 相信理解 invokedynamic 指令并不困难.</p> <p><strong>每一处含有 invokedynamic 指令的位置都被称作 &quot;动态调用点(Dynamically-Computed Call Site)&quot;</strong> , 这条指令的第一个参数不再是代表方法符号引用的 CONSTANT_Methodref_info 常量, 而是变为 JDK 7 时新加入的 CONSTANT_InvokeDynamic_info 常量, 从这个新常量中可以得到 3 项信息: <strong>引导方法</strong>(Bootstrap Method, 该方法存放在新增的 BootstrapMethods 属性中), <strong>方法类型</strong>(MethodType)和<strong>名称</strong>. 引导方法是有固定的参数, 并且返回值规定是 <code>java.lang.invoke.CallSite</code>​ 对象, 这个对象<strong>代表了真正要执行的目标方法调用</strong>. 根据 <strong>CONSTANT_InvokeDynamic_info 常量中提供的信息, 虚拟机可以找到并且执行引导方法, 从而获得一个 CallSite 对象, 最终调用到要执行的目标方法上</strong>. 还是照例不依赖枯燥的概念描述, 改用一个实际例子来解释这个过程吧, 如代码清单 8-13 所示.</p> <blockquote><p>代码清单8-13 InvokeDynamic指令演示</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span></span><span class="token class-name">MethodHandles</span><span class="token punctuation">.</span><span class="token static">lookup</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span></span><span class="token class-name">CallSite</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span></span><span class="token class-name">ConstantCallSite</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span></span><span class="token class-name">MethodHandle</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span></span><span class="token class-name">MethodHandles</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span></span><span class="token class-name">MethodType</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InvokeDynamicTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token class-name">INDY_BootstrapMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invokeExact</span><span class="token punctuation">(</span><span class="token string">&quot;icyfenix&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello String:&quot;</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">CallSite</span> <span class="token class-name">BootstrapMethod</span><span class="token punctuation">(</span><span class="token class-name">MethodHandles<span class="token punctuation">.</span>Lookup</span> lookup<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">MethodType</span> mt<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConstantCallSite</span><span class="token punctuation">(</span>lookup<span class="token punctuation">.</span><span class="token function">findStatic</span><span class="token punctuation">(</span><span class="token class-name">InvokeDynamicTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> mt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">MethodType</span> <span class="token class-name">MT_BootstrapMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">MethodType</span>
                <span class="token punctuation">.</span><span class="token function">fromMethodDescriptorString</span><span class="token punctuation">(</span>
                        <span class="token string">&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String; Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">MethodHandle</span> <span class="token class-name">MH_BootstrapMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findStatic</span><span class="token punctuation">(</span><span class="token class-name">InvokeDynamicTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">&quot;BootstrapMethod&quot;</span><span class="token punctuation">,</span> <span class="token class-name">MT_BootstrapMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">MethodHandle</span> <span class="token class-name">INDY_BootstrapMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token class-name">CallSite</span> cs <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">CallSite</span><span class="token punctuation">)</span> <span class="token class-name">MH_BootstrapMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invokeWithArguments</span><span class="token punctuation">(</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;testMethod&quot;</span><span class="token punctuation">,</span>
                <span class="token class-name">MethodType</span><span class="token punctuation">.</span><span class="token function">fromMethodDescriptorString</span><span class="token punctuation">(</span><span class="token string">&quot;(Ljava/lang/String;)V&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> cs<span class="token punctuation">.</span><span class="token function">dynamicInvoker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p>这段代码与前面 MethodHandleTest 的作用基本上是一样的, 虽然没有加以注释, 但是阅读起来应当也不困难. 要是真没读懂也不要紧, 这里没写注释的主要原因是这段代码并非写给人看的, 只是为了方便编译器按照笔者的意愿来产生一段字节码而已. 前文提到过, <strong>由于 invokedynamic 指令面向的主要服务对象并非 Java 语言, 而是其他 Java 虚拟机之上的其他动态类型语言</strong>, 因此, 光靠 Java 语言的编译器 Javac 的话, 在 JDK 7 时甚至还完全没有办法生成带有 invokedynamic 指令的字节码(曾经有一个 java.dyn.InvokeDynamic 的语法糖可以实现, 但后来被取消了), 而到 JDK 8 引入了 Lambda 表达式和接口默认方法后, Java 语言才算享受到了一点 invokedynamic 指令的好处, 但用 Lambda 来解释 invokedynamic 指令运作就比较别扭, 也无法与前面 MethodHandle 的例子对应类比, 所以笔者采用一些变通的办法: John Rose 编写过一个把程序的字节码转换为使用 invokedynamic 的简单工具 INDY 来完成这件事, 这里使用这个工具来产生最终需要的字节码, 因此代码清单 8-13 中的方法名称不能随意改动, 更不能把几个方法合并到一起写, 因为它们是要被 INDY 工具读取的.</p> <p>把上面的代码编译, 再使用 INDY 转换后重新生成的字节码如代码清单 8-14 所示(结果使用 javap 输出, 因版面原因, 精简了许多无关的内容).</p> <blockquote><p>代码清单8-14 InvokeDynamic 指令演示(2)</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Constant</span> pool<span class="token operator">:</span>
    #<span class="token number">121</span> <span class="token operator">=</span> <span class="token class-name">NameAndType</span>    #<span class="token number">33</span><span class="token operator">:</span>#<span class="token number">30</span>    <span class="token comment">//  testMethod:(Ljava/lang/String;)V</span>
    #<span class="token number">123</span> <span class="token operator">=</span> <span class="token class-name">InvokeDynamic</span>  #<span class="token number">0</span><span class="token operator">:</span>#<span class="token number">121</span>    <span class="token comment">//  #0:testMethod:(Ljava/lang/String;)V</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Throwable</span><span class="token punctuation">;</span>
    <span class="token class-name">Code</span><span class="token operator">:</span>
      stack<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>
         <span class="token number">0</span><span class="token operator">:</span> ldc           #<span class="token number">23</span>        <span class="token comment">// String abc</span>
         <span class="token number">2</span><span class="token operator">:</span> invokedynamic #<span class="token number">123</span><span class="token punctuation">,</span>  <span class="token number">0</span>   <span class="token comment">// InvokeDynamic #0:testMethod: (Ljava/lang/String;)V</span>
         <span class="token number">7</span><span class="token operator">:</span> nop
         <span class="token number">8</span><span class="token operator">:</span> <span class="token keyword">return</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span></span>CallSite</span> <span class="token class-name">BootstrapMethod</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span></span>Method</span> <span class="token class-name">Handles</span>$<span class="token class-name">Lookup</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span></span>MethodType</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Throwable</span><span class="token punctuation">;</span>
    <span class="token class-name">Code</span><span class="token operator">:</span>
      stack<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">3</span>
         <span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">63</span>        <span class="token comment">// class java/lang/invoke/ConstantCallSite</span>
         <span class="token number">3</span><span class="token operator">:</span> dup
         <span class="token number">4</span><span class="token operator">:</span> aload_0
         <span class="token number">5</span><span class="token operator">:</span> ldc           #<span class="token number">1</span>         <span class="token comment">// class org/fenixsoft/InvokeDynamicTest</span>
         <span class="token number">7</span><span class="token operator">:</span> aload_1
         <span class="token number">8</span><span class="token operator">:</span> aload_2
         <span class="token number">9</span><span class="token operator">:</span> invokevirtual #<span class="token number">65</span>        <span class="token comment">// Method java/lang/invoke/MethodHandles$ Lookup.findStatic:(Ljava/lang/Class;Ljava/ lang/String;Ljava/lang/invoke/Method Type;)Ljava/lang/invoke/MethodHandle;</span>
        <span class="token number">12</span><span class="token operator">:</span> invokespecial #<span class="token number">71</span>        <span class="token comment">// Method java/lang/invoke/ConstantCallSite. &quot;&lt;init&gt;&quot;:(Ljava/lang/invoke/MethodHandle;)V</span>
        <span class="token number">15</span><span class="token operator">:</span> areturn
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>从 main() 方法的字节码中可见, <strong>原本的方法调用指令已经被替换为 invokedynamic 了</strong>, 它的参数为第 123 项常量(第二个值为 0 的参数在虚拟机中不会直接用到, 这与 invokeinterface 指令那个的值为 0 的参数一样是占位用的, 目的都是为了给常量池缓存留出足够的空间):</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token number">2</span><span class="token operator">:</span> invokedynamic #<span class="token number">123</span><span class="token punctuation">,</span>  <span class="token number">0</span> <span class="token comment">// InvokeDynamic #0:testMethod:(Ljava/lang/String;)V</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>从常量池中可见, 第 123 项常量显示 &quot;<code>#123=InvokeDynamic#0: #121</code>​&quot; 说明它是一项 CONSTANT_InvokeDynamic_info 类型常量, 常量值中前面 &quot;<code>#0</code>​&quot; 代表引导方法取 Bootstrap Methods 属性表的第 0 项(javap 没有列出属性表的具体内容, 不过示例中仅有一个引导方法, 即 BootstrapMethod()), 而后面的 &quot;<code>#121</code>​&quot; 代表引用第 121 项类型为 CONSTANT_NameAndType_info 的常量, 从这个常量中可以获取到方法名称和描述符, 即后面输出的 &quot;<code>testMethod: (Ljava/lang/String; )V</code>​&quot;.</p> <p>再看 BootstrapMethod(), 这个方法在 Java 源码中并不存在, 是由 INDY 产生的, 但是它的字节码很容易读懂, 所有逻辑都是调用 <code>MethodHandles$Lookup</code>​ 的 findStatic() 方法, 产生 testMethod() 方法的 MethodHandle, 然后用它创建一个 ConstantCallSite 对象. 最后, <strong>这个对象返回给 invokedynamic 指令实现对 testMethod()方法的调用</strong>, invokedynamic 指令的调用过程到此就宣告完成了.</p> <h5 id="_5-实战-掌控方法分派规则"><a href="#_5-实战-掌控方法分派规则" class="header-anchor">#</a> 5.实战:掌控方法分派规则</h5> <p>invokedynamic 指令与此前 4 条传统的 &quot;<code>invoke*</code>​&quot; 指令的最大区别就是<strong>它的分派逻辑不是由虚拟机决定的, 而是由程序员决定</strong>. 在介绍 Java 虚拟机动态语言支持的最后一节中, 笔者希望通过一个简单例子(如代码清单 8-15 所示), 帮助读者理解程序员可以掌控方法分派规则之后, 能做什么以前无法做到的事情.</p> <blockquote><p>代码清单8-15 方法调用问题</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">GrandFather</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">thinking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;i am grandfather&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token keyword">extends</span> <span class="token class-name">GrandFather</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">thinking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;i am father&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">thinking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 请读者在这里填入适当的代码(不能修改其他地方的代码)</span>
       <span class="token comment">// 实现调用祖父类的 thinking()方法, 打印&quot;i am grandfather&quot;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>在 Java 程序中, 可以通过 &quot;super&quot; 关键字很方便地调用到父类中的方法, 但如果要<strong>访问祖类</strong>的方法呢? 读者在往下阅读本书提供的解决方案之前, 不妨自己思考一下, 在 JDK 7 之前有没有办法解决这个问题.</p> <p>在拥有 invokedynamic 和 java.lang.invoke 包之前, 使用纯粹的 Java 语言很难处理这个问题(使用 ASM 等字节码工具直接生成字节码当然还是可以处理的, 但这已经是在字节码而不是 Java 语言层面来解决问题了), 原因是在 Son 类的 thinking() 方法中根本无法获取到一个实际类型是 GrandFather 的对象引用, 而 invokevirtual 指令的分派逻辑是固定的, 只能按照方法接收者的实际类型进行分派, 这个逻辑完全固化在虚拟机中, 程序员无法改变. 如果是 JDK 7 Update 9 之前, 使用代码清单 8-16 中的程序就可以直接解决该问题.</p> <blockquote><p>代码清单8-16 使用 MethodHandle 来解决问题</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span></span><span class="token class-name">MethodHandles</span><span class="token punctuation">.</span><span class="token static">lookup</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span></span><span class="token class-name">MethodHandle</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span></span><span class="token class-name">MethodType</span></span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>

<span class="token keyword">class</span> <span class="token class-name">GrandFather</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">thinking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;i am grandfather&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token keyword">extends</span> <span class="token class-name">GrandFather</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">thinking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;i am father&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">thinking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">MethodType</span> mt <span class="token operator">=</span> <span class="token class-name">MethodType</span><span class="token punctuation">.</span><span class="token function">methodType</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">MethodHandle</span> mh <span class="token operator">=</span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findSpecial</span><span class="token punctuation">(</span><span class="token class-name">GrandFather</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> 
                        <span class="token string">&quot;thinking&quot;</span><span class="token punctuation">,</span> mt<span class="token punctuation">,</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                mh<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thinking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>使用 JDK 7 Update 9 之前的 HotSpot 虚拟机运行, 会得到如下运行结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>i am grandfather
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>但是这个逻辑在 JDK 7 Update 9 之后被视作一个潜在的安全性缺陷修正了, 原因是必须保证 findSpecial() 查找方法版本时受到的访问约束(譬如对访问控制的限制, 对参数类型的限制)应与使用 invokespecial 指令一样, 两者必须保持精确对等, 包括在上面的场景中它只能访问到其直接父类中的方法版本. 所以在 JDK 7 Update 10 修正之后, 运行以上代码只能得到如下结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>i am father
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>那在新版本的 JDK 中, 上面的问题是否能够得到解决呢? 答案是可以的, 如果读者去查看 MethodHandles.Lookup 类的代码, 将会发现需要进行哪些访问保护, 在该 API 实现时是预留了后门的. 访问保护是通过一个 <strong>allowedModes</strong> 的参数来控制, 而且这个参数可以被设置成 &quot;TRUSTED&quot; 来绕开所有的保护措施. 尽管这个参数只是在 Java 类库本身使用, 没有开放给外部设置, 但通过反射可以轻易打破这种限制. 由此, 可以把代码清单 8-16 中子类的 thinking() 方法修改为如下所示的代码来解决问题:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">thinking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token class-name">MethodType</span> mt <span class="token operator">=</span> <span class="token class-name">MethodType</span><span class="token punctuation">.</span><span class="token function">methodType</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Field</span> lookupImpl <span class="token operator">=</span> <span class="token class-name">MethodHandles<span class="token punctuation">.</span>Lookup</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;IMPL_LOOKUP&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        lookupImpl<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">MethodHandle</span> mh <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">MethodHandles<span class="token punctuation">.</span>Lookup</span><span class="token punctuation">)</span> lookupImpl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findSpecial</span><span class="token punctuation">(</span><span class="token class-name">GrandFather</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token string">&quot;thinking&quot;</span><span class="token punctuation">,</span> mt<span class="token punctuation">,</span> <span class="token class-name">GrandFather</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        mh<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>运行以上代码, 在目前所有 JDK 版本中均可获得如下结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>i am grandfather
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="header-anchor">#</a> 基于栈的字节码解释执行引擎</h4> <p>关于 Java 虚拟机是如何调用方法, 进行版本选择的内容已经全部讲解完毕, 从本节开始来探讨<mark><strong>虚拟机是如何执行方法里面的字节码指令</strong></mark>的. 概述中曾提到过, 许多 Java 虚拟机的<strong>执行引擎在执行 Java 代码的时候都有</strong>​<mark><strong>解释执行</strong></mark>​ <strong>(通过解释器执行)和</strong>​<mark><strong>编译执行</strong></mark>​ <strong>(通过即时编译器产生本地代码执行)两种选择</strong>, 在本节中将会分析在概念模型下的 Java 虚拟机<strong>解释执行字节码时, 其执行引擎是如何工作的</strong>. 本章多次强调了 &quot;概念模型&quot;, 是因为实际的虚拟机实现, 譬如 HotSpot 的模板解释器工作的时候, 并不是按照下文中的动作一板一眼地进行机械式计算, 而是动态产生每条字节码对应的汇编代码来运行, 这与概念模型中执行过程的差异很大, 但是结果却能保证是一致的.</p> <h5 id="_1-解释执行"><a href="#_1-解释执行" class="header-anchor">#</a> 1.解释执行</h5> <p>Java 语言经常被人们定位为 &quot;解释执行&quot; 的语言, 在 Java 初生的 JDK 1.0 时代, 这种定义还算是比较准确的, 但当主流的虚拟机中都包含了<strong>即时编译器</strong>后, Class 文件中的代码到底会被解释执行还是编译执行, 就成了只有虚拟机自己才能准确判断的事. 再后来, Java 也发展出可以直接生成本地代码的编译器(如 Jaotc, GCJ), 这时候再笼统地说 &quot;解释执行&quot;, 对于整个 Java 语言来说就成了几乎是没有意义的概念, <strong>只有确定了谈论对象是某种具体的 Java 实现版本和执行引擎运行模式时, 谈解释执行还是编译执行才会比较合理确切</strong>.</p> <p>无论是解释还是编译, 也无论是物理机还是虚拟机, 对于应用程序, 机器都不可能如人那样阅读, 理解, 然后获得执行能力. <strong>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前</strong>, 都需要经过图 8-4 中的各个步骤. 如果对编译原理的相关课程还有印象的话, 很容易就会发现图 8-4 中<strong>下面的那条分支, 就是传统编译原理中程序代码到目标机器代码的生成过程; 而中间的那条分支, 自然就是解释执行的过程</strong>.</p> <p><img src="/img/Image00177-20240302133505-qa1d6h3.jpg" alt="" title="图8-4　编译过程"></p> <p>如今, 基于物理机, Java 虚拟机, 或者是非 Java 的其他高级语言虚拟机(HLLVM)的代码执行过程, 大体上都会遵循这种符合现代经典编译原理的思路, 在执行前先对程序源码进行<strong>词法分析和语法分析</strong>处理, 把源码转化为抽象语法树(Abstract Syntax Tree, AST). 对于一门具体语言的实现来说, 词法, 语法分析以至后面的优化器和目标代码生成器都可以选择独立于执行引擎, 形成一个完整意义的编译器去实现, 这类代表是 C/C++ 语言. 也可以选择把其中一部分步骤(如生成抽象语法树之前的步骤)实现为一个半独立的编译器, 这类代表是 Java 语言. 又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子之中, 如大多数的 JavaScript 执行引擎.</p> <p>在 Java 语言中, <strong>Javac 编译器完成了程序代码经过词法分析, 语法分析到抽象语法树, 再遍历语法树生成线性的字节码指令流的过程</strong>. 因为这一部分动作是在 Java 虚拟机之外进行的, 而解释器在虚拟机的内部, 所以 Java 程序的编译就是<strong>半独立</strong>的实现.</p> <h5 id="_2-基于栈的指令集与基于寄存器的指令集"><a href="#_2-基于栈的指令集与基于寄存器的指令集" class="header-anchor">#</a> 2.基于栈的指令集与基于寄存器的指令集</h5> <p>Javac 编译器输出的字节码指令流, 基本上是一种<mark><strong>基于栈的指令集架构</strong></mark>(Instruction Set Architecture, ISA), 字节码指令流里面的指令大部分都是零地址指令, 它们<strong>依赖操作数栈进行工作</strong>. 与之相对的另外一套常用的指令集架构是<strong>基于寄存器的指令集</strong>, 最典型的就是 x86 的二地址指令集, 如果说得更通俗一些就是现在主流 PC 机中物理硬件直接支持的指令集架构, 这些指令依赖寄存器进行工作. 那么, <mark><strong>基于栈的指令集与基于寄存器的指令集这两者之间有什么不同呢</strong></mark>?</p> <p>举个最简单的例子, 分别使用这两种指令集去计算 &quot;1+1&quot; 的结果, <strong>基于栈的指令集会是这样子</strong>的:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>iconst_1
iconst_1
iadd
istore_0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>两条 iconst_1 指令连续把两个常量 1 压入栈后, iadd 指令把栈顶的两个值出栈, 相加, 然后把结果<strong>放回栈顶</strong>, 最后 istore_0 把栈顶的值放到局部变量表的<strong>第 0 个变量槽</strong>中. 这种指令流中的指令通常都是不带参数的, <strong>使用操作数栈中的数据作为指令的运算输入, 指令的运算结果也存储在操作数栈之中</strong>.</p> <p>而如果用<strong>基于寄存器的指令集</strong>, 那程序可能会是这个样子:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>mov  eax<span class="token punctuation">,</span> <span class="token number">1</span>
add  eax<span class="token punctuation">,</span> <span class="token number">1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>mov 指令把 EAX 寄存器的值设为 1, 然后 add 指令再把这个值加 1, 结果就保存在 EAX 寄存器里面</strong>. 这种二地址指令是 x86 指令集中的主流, 每个指令都包含两个单独的<strong>输入参数</strong>, 依赖于寄存器来访问和存储数据.</p> <p>了解了基于栈的指令集与基于寄存器的指令集的区别后, 读者可能会有个进一步的疑问, 这两套指令集谁更好一些呢? 应该说, <mark><strong>既然两套指令集会同时并存和发展, 那肯定是各有优势的</strong></mark>, 如果有一套指令集全面优于另外一套的话, 就是直接替代而不存在选择的问题了.</p> <p><strong>基于栈的指令集主要优点是可移植, 因为寄存器由硬件直接提供, 程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束</strong>. 例如现在 32 位 80x86 体系的处理器能提供了 8 个 32 位的寄存器, 而 ARMv6 体系的处理器(在智能手机, 数码设备中相当流行的一种处理器)则提供了 30 个 32 位的通用寄存器, 其中前 16 个在用户模式中可以使用. 如果使用栈架构的指令集, 用户程序不会直接用到这些寄存器, 那就可以由虚拟机实现来自行决定把一些访问最频繁的数据(程序计数器, 栈顶缓存等)放到寄存器中以获取尽量好的性能, 这样实现起来也更简单一些. <strong>栈架构的指令集还有一些其他的优点, 如代码相对更加紧凑</strong>(字节码中每个字节就对应一条指令, 而多地址指令集中还需要存放参数), 编译器实现更加简单(不需要考虑空间分配的问题, 所需空间都在栈上操作)等.</p> <p><strong>栈架构指令集的主要缺点是理论上执行速度相对来说会稍慢一些, 所有主流物理机的指令集都是寄存器架构也从侧面印证了这点</strong>. 不过这里的执行速度是要局限在解释执行的状态下, 如果经过即时编译器输出成物理机上的汇编指令流, 那就与虚拟机采用哪种指令集架构没有什么关系了. 在解释执行时, 栈架构指令集的代码虽然紧凑, 但是<strong>完成相同功能所需的指令数量一般会比寄存器架构来得更多</strong>, 因为出栈, 入栈操作本身就产生了相当大量的指令. 更重要的是栈实现在内存中, 频繁的栈访问也就意味着频繁的内存访问, 相对于处理器来说, 内存始终是执行速度的瓶颈. 尽管虚拟机可以采取栈顶缓存的优化方法, 把最常用的操作映射到寄存器中避免直接内存访问, 但这也只是优化措施而不是解决本质问题的方法. 因此由于指令数量和内存访问的原因, 导致了栈架构指令集的执行速度会相对慢上一点.</p> <h5 id="_3-基于栈的解释器执行过程"><a href="#_3-基于栈的解释器执行过程" class="header-anchor">#</a> 3.基于栈的解释器执行过程</h5> <p>关于栈架构执行引擎的必要<strong>前置知识</strong>已经全部讲解完毕了, 本节准备了一段 Java 代码, 以便向展示在虚拟机里字节码是如何执行的. 前面曾经举过一个计算 &quot;1+1&quot; 的例子, 那种小学一年级的算数题目显然太过简单了, 给聪明的读者练习的题目起码...这里准备的是四则运算加减乘除法, 大概能达到三年级左右的数学水平, 请看代码清单 8-17.</p> <blockquote><p>代码清单8-17 一段简单的算术代码</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这段代码从 Java 语言的角度没有任何谈论的必要, 直接使用 javap 命令看看它的字节码指令, 如代码清单 8-18 所示.</p> <blockquote><p>代码清单8-18 一段简单的算术代码的字节码表示</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Code</span><span class="token operator">:</span>
        <span class="token class-name">Stack</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">Locals</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token class-name">Args_size</span><span class="token operator">=</span><span class="token number">1</span>
         <span class="token number">0</span><span class="token operator">:</span>   bipush  <span class="token number">100</span>
         <span class="token number">2</span><span class="token operator">:</span>   istore_1
         <span class="token number">3</span><span class="token operator">:</span>   sipush  <span class="token number">200</span>
         <span class="token number">6</span><span class="token operator">:</span>   istore_2
         <span class="token number">7</span><span class="token operator">:</span>   sipush  <span class="token number">300</span>
        <span class="token number">10</span><span class="token operator">:</span>  istore_3
        <span class="token number">11</span><span class="token operator">:</span>  iload_1
        <span class="token number">12</span><span class="token operator">:</span>  iload_2
        <span class="token number">13</span><span class="token operator">:</span>  iadd
        <span class="token number">14</span><span class="token operator">:</span>  iload_3
        <span class="token number">15</span><span class="token operator">:</span>  imul
        <span class="token number">16</span><span class="token operator">:</span>  ireturn
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>javap 提示这段代码需要<strong>深度为 2 的操作数栈和 4 个变量槽的局部变量空间</strong>, 笔者就根据这些信息画了图 8-5 至图 8-11 共 7 张图片, 来描述代码清单 8-13 执行过程中的代码, 操作数栈和局部变量表的变化情况.</p> <p><img src="/img/Image00178-20240302133505-bkj8m3a.jpg" alt="" title="图8-5 执行偏移地址为0的指令的情况"></p> <p>首先, 执行偏移地址为 0 的指令, Bipush 指令的作用是将单字节的整型常量值(-128～127)<strong>推入操作数栈顶</strong>, 跟随有一个参数, 指明推送的常量值, 这里是 100.</p> <p><img src="/img/Image00179-20240302133505-xmpya6n.jpg" alt="" title="图8-6 执行偏移地址为1的指令的情况"></p> <p>执行偏移地址为 2 的指令, istore_1 指令的作用是<strong>将操作数栈顶的整型值出栈并存放到第 1 个局部变量槽中</strong>. 后续 4 条指令(直到偏移为 11 的指令为止)都是做一样的事情, 也就是在对应代码中把变量 a, b, c 赋值为 100, 200, 300. 这 4 条指令的图示略过.</p> <p><img src="/img/Image00180-20240302133505-v8e1e71.jpg" alt="" title="图8-7 执行偏移地址为11的指令的情况"></p> <p>执行偏移地址为 11 的指令, iload_1 指令的作用是<strong>将局部变量表第 1 个变量槽中的整型值复制到操作数栈顶</strong>.</p> <p><img src="/img/Image00181-20240302133505-h2gha12.jpg" alt="" title="图8-8 执行偏移地址为12的指令的情况"></p> <p>执行偏移地址为 12 的指令, iload_2 指令的执行过程与 iload_1 类似, <strong>把第 2 个变量槽的整型值入栈</strong>. 画出这个指令的图示主要是为了显示下一条 iadd 指令执行前的堆栈状况.</p> <p><img src="/img/Image00182-20240302133505-bk9z3n9.jpg" alt="" title="图8-9 执行偏移地址为13的指令的情况"></p> <p>执行偏移地址为 13 的指令, <strong>iadd 指令的作用是将操作数栈中头两个栈顶元素出栈, 做整型加法, 然后把结果重新入栈</strong>. 在 iadd 指令执行完毕后, 栈中原有的 100 和 200 被出栈, 它们的和 300 被重新入栈.</p> <p><img src="/img/Image00183-20240302133505-1h3lixq.jpg" alt="" title="图8-10 执行偏移地址为14的指令的情况"></p> <p>执行偏移地址为 14 的指令, iload_3 指令把存放在第 3 个局部变量槽中的 300 入栈到操作数栈中. 这时操作数栈为两个整数 300. <strong>下一条指令 imul 是将操作数栈中头两个栈顶元素出栈, 做整型乘法, 然后把结果重新入栈</strong>, 与 iadd 完全类似, 所以就省略了图示.</p> <p><img src="/img/Image00184-20240302133505-bj8w2vt.jpg" alt="" title="图8-11 执行偏移地址为16的指令的情况"></p> <p>执行偏移地址为 16 的指令, ireturn 指令是方法<strong>返回指令</strong>之一, 它将<strong>结束方法执行并将操作数栈顶的整型值返回给该方法的调用者</strong>. 到此为止, 这段方法执行结束.</p> <p><mark><strong>再次强调上面的执行过程仅仅是一种概念模型, 虚拟机最终会对执行过程做出一系列优化来提高性能, 实际的运作过程并不会完全符合概念模型的描述</strong></mark>. 更确切地说, 实际情况会和上面描述的概念模型差距非常大, 差距产生的根本原因是虚拟机中解析器和即时编译器都<mark><strong>会对输入的字节码进行优化, 即使解释器中也不是按照字节码指令去逐条执行的</strong></mark>. 例如在 HotSpot 虚拟机中, 就有很多以 &quot;fast_&quot; 开头的非标准字节码指令用于合并, 替换输入的字节码以提升解释执行性能, 即时编译器的优化手段则更是花样繁多.</p> <p>不过从这段程序的执行中也可以看出栈结构指令集的一般运行过程, <strong>整个运算过程的中间变量都以操作数栈的出栈, 入栈为信息交换途径</strong>, 符合在前面分析的特点.</p> <p>‍</p> <h4 id="本章小结"><a href="#本章小结" class="header-anchor">#</a> 本章小结</h4> <p>本章分析了虚拟机在执行代码时, 如何找到正确的方法, 如何执行方法内的字节码, 以及执行代码时涉及的内存结构. 在第 6～8 章里面, 针对 Java 程序是如何存储的, 如何载入(创建)的, 以及如何执行的问题, 把相关知识系统地介绍了一遍, 第 9 章将一起看看这些理论知识在具体开发之中的典型应用.</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/20.开发/2000.Java/600.JVM/32.虚拟机字节码执行引擎🌼.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/ea287c/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">虚拟机类加载机制🌼</div></a> <a href="/pages/c6c210/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">类加载及执行子系统的案例与实战🌼</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/ea287c/" class="prev">虚拟机类加载机制🌼</a></span> <span class="next"><a href="/pages/c6c210/">类加载及执行子系统的案例与实战🌼</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/84.220b69e7.js" defer></script>
  </body>
</html>
