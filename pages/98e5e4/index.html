<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>容器实战高手课(极客时间)🌸 | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/192.184d249f.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>分布式系统理论</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/129626/" class="sidebar-link">分布式系统基础</a></li><li><a href="/pages/fb5d35/" class="sidebar-link">分布式共识算法</a></li><li><a href="/pages/12ac37/" class="sidebar-link">分布式系统组件</a></li><li><a href="/pages/d03ebf/" class="sidebar-link">分布式技术原理与算法解析(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>系统接入层</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/f1b6c4/" class="sidebar-link">Nginx基础</a></li><li><a href="/pages/d4123d/" class="sidebar-link">深入拆解Tomcat与Jetty(极客时间)🌸</a></li><li><a href="/pages/baee2f/" class="sidebar-link">Netty</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>服务治理-注册发现与RPC</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/05077d/" class="sidebar-link">基础</a></li><li><a href="/pages/51b6aa/" class="sidebar-link">RPC实战与核心原理(极客时间)🌸</a></li><li><a href="/pages/0966ee/" class="sidebar-link">Zookeeper</a></li><li><a href="/pages/3b7e05/" class="sidebar-link">Nacos</a></li><li><a href="/pages/7f31f8/" class="sidebar-link">Dubbo</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>服务治理-流量控制</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/44bfa8/" class="sidebar-link">负载均衡</a></li><li><a href="/pages/4d5a6c/" class="sidebar-link">限流</a></li><li><a href="/pages/e0c561/" class="sidebar-link">熔断</a></li><li><a href="/pages/12ae40/" class="sidebar-link">网关路由</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>服务治理-系统监控与安全</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/8c9210/" class="sidebar-link">系统安全性</a></li><li><a href="/pages/c9bf40/" class="sidebar-link">系统监控组件</a></li><li><a href="/pages/3f3cf7/" class="sidebar-link">运维监控系统实战(极客时间)🌸</a></li><li><a href="/pages/e20e02/" class="sidebar-link">OAuth2.0实战课(极客时间)🌟</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>中间件-消息队列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/96d94c/" class="sidebar-link">消息队列基础</a></li><li><a href="/pages/abf16c/" class="sidebar-link">RabbitMQ</a></li><li><a href="/pages/4fc3f1/" class="sidebar-link">Kafka</a></li><li><a href="/pages/013cfe/" class="sidebar-link">RocketMQ</a></li><li><a href="/pages/ed8d92/" class="sidebar-link">Disruptor</a></li><li><a href="/pages/249149/" class="sidebar-link">消息队列高手课(极客时间)🌟</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>中间件-缓存</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/946847/" class="sidebar-link">缓存基础</a></li><li><a href="/pages/e46d56/" class="sidebar-link">本地缓存</a></li><li><a href="/pages/0abfb9/" class="sidebar-link">Redis基础</a></li><li><a href="/pages/09236a/" class="sidebar-link">Redis持久化</a></li><li><a href="/pages/867f9b/" class="sidebar-link">Redis主从复制</a></li><li><a href="/pages/50cae1/" class="sidebar-link">Redis哨兵</a></li><li><a href="/pages/43b45c/" class="sidebar-link">Redis集群</a></li><li><a href="/pages/a32379/" class="sidebar-link">Redis内存管理与运维</a></li><li><a href="/pages/386037/" class="sidebar-link">Redis核心技术与实战(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>中间件-其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/23044d/" class="sidebar-link">定时任务-XXLJob</a></li><li><a href="/pages/459117/" class="sidebar-link">ES与检索</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>系统设计与优化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/41a845/" class="sidebar-link">凤凰架构</a></li><li><a href="/pages/68cc0b/" class="sidebar-link">左耳听风(极客时间)🌟</a></li><li><a href="/pages/e3e99c/" class="sidebar-link">从0开始学微服务(极客时间)🌸</a></li><li><a href="/pages/1e5368/" class="sidebar-link">高并发系统设计40问(极客时间)🌸</a></li><li><a href="/pages/33599f/" class="sidebar-link">系统性能调优必知必会(极客时间)🌸</a></li><li><a href="/pages/c83472/" class="sidebar-link">后端技术面试38讲(极客时间)</a></li><li><a href="/pages/4404b6/" class="sidebar-link">架构实战案例解析(极客时间)🌸</a></li><li><a href="/pages/8f1c1d/" class="sidebar-link">如何设计一个秒杀系统(极客时间)</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>容器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>容器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/582acf/" class="sidebar-link">部署Minikube</a></li><li><a href="/pages/98e5e4/" aria-current="page" class="active sidebar-link">容器实战高手课(极客时间)🌸</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/c6a42c/" class="sidebar-link">Kubernetes实战🌸</a></li><li><a href="/pages/f35c72/" class="sidebar-link">深入剖析Kubernetes(极客时间)🌸</a></li><li><a href="/pages/caa314/" class="sidebar-link">Istio</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>自动化运维</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/beb97f/" class="sidebar-link">持续集成(CICD)</a></li><li><a href="/pages/a0df2d/" class="sidebar-link">DevOps</a></li><li><a href="/pages/765815/" class="sidebar-link">SRE实战手册(极客时间)</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/middleware/#系统" data-v-06970110>系统</a></li><li data-v-06970110><a href="/middleware/#容器" data-v-06970110>容器</a></li><li data-v-06970110><a href="/middleware/#容器" data-v-06970110>容器</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">容器实战高手课(极客时间)🌸<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_100-容器实战高手课-极客时间-🌸"><a href="#_100-容器实战高手课-极客时间-🌸" class="header-anchor">#</a> 100.容器实战高手课(极客时间)🌸</h1> <h3 id="开篇词"><a href="#开篇词" class="header-anchor">#</a> 开篇词</h3> <h4 id="开篇词-一个态度两个步骤-成为容器实战高手"><a href="#开篇词-一个态度两个步骤-成为容器实战高手" class="header-anchor">#</a> 开篇词 | 一个态度两个步骤,成为容器实战高手</h4> <p>在 2013 年, 我加入 eBay, 从事云平台方面的工作, 最先接触的是 OpenStack 云平台. 到了 2015 年开始做 Kubernetes, 要用 Kubernetes 来管理 eBay 整个云平台. 需要迁移所有 eBay 的应用程序, 把它们从原来的物理机或者虚拟机迁移到容器的环境里.</p> <p>在 Kubernetes 具体落地的过程中, 我们碰到了形形色色的容器问题.</p> <p>首先, 容器是一种轻量级的隔离技术. 而轻量级隔离造成了一些<strong>行为模式</strong>的不同, 比如原来运行在虚拟机里的 CPU 监控程序, 移到容器之后, 再用原来的算法计算容器 CPU 使用率就不适用了.</p> <p>从<strong>隔离程度</strong>这个方面考虑, CPU, memory, IO (disk and network)真的能做到精确隔离吗? 其实还是有问题的, 比如想让多个用户容器运行在一个节点上, 就需要保证, 每个容器的磁盘容量在一定的限额范围内, 还而且需要合理分配磁盘读写性能.</p> <p>第三个方面, 就是**处理性能敏感的应用. ** 容器技术的引入, 会带来新的开销, 那么肯定会影响性能. 比如原来运行在物理机上, 有极高性能要求的程序, 在迁移到容器后, 还需要对容器网络做优化, 对 Cgroup 做优化. 只有做了这样的优化, 才能保证迁移过来的程序, 当它们运行在容器里的时候, 性能差异控制在 2% 以内(当时做迁移的标准).</p> <p>另外, 如果涉及高内存使用的应用, 做迁移的时候, 还要考虑 PageCache, Swap, 还有 HugePage 等等问题, 在叠加了 Cgroup 之后, 会带来新的变化.</p> <p>综合来看, 遇到的问题有的很简单, 看一下源代码, 写个测试代码验证一下, 一两个小时就可以搞定. 但有的问题却很复杂, 需要尝试不同的测试, 反复查看各种源代码, 陆陆续续花费一两个月的时间解决. 通过 5 年的不断努力, 团队逐渐把 eBay 所有的业务都迁移到了容器中. 现在我们的云平台上运行着百万个容器.</p> <h5 id="_1-怎么理解容器的知识体系"><a href="#_1-怎么理解容器的知识体系" class="header-anchor">#</a> 1.怎么理解容器的知识体系?</h5> <p>可以说, 从我接触容器知识到能够得心应手地解决各种容器问题, 这个过程还真是有点磕磕绊绊. 一开始, 我被各种各样的问题所淹没, 觉得容器的内容太复杂了, 没有一个系统性的解决方法. 只能见招拆招, 一个个解决, 就这样, 随着我解决的问题越来越多, 我也开始思考, 是不是有一些<strong>规律性</strong>的东西.</p> <p>容器问题虽然有很多类型, 既有基本功能问题, 也有性能问题, 还有不少稳定性问题. 但大部分问题, <mark><strong>最终都会归结到 Linux 操作系统上</strong></mark>​ **. **</p> <p>比如容器里进程被 OOM Kill 了, 这个 OOM Killer 就是 Linux 里常见的内存保护机制; 容器的进程引起平均负载增高, 而平均负载也是在 Linux 里被反复讨论的概念; 还有容器使用的 OverlayFS 系统, 看上去和 Linux 常用的 XFS, Ext4 系统不同, 但是它也是 Linux 内核维护的一种文件系统.</p> <p>其实 Linux 操作系统不外乎是**进程管理, 内存管理, 文件系统, 网络协议栈, 再加上一些安全管理. ** 这样一梳理, 容器的问题就都可以投射到 Linux 操作系统这些模块上了, 是不是一下子感觉清晰了很多?</p> <p>当然了, 容器还有自己的特殊性, <strong>Linux 内核原来的特性加上 Namespace 和 Cgroups 会带来的变化</strong>. 所以在对应到每个模块上分析问题的时候, 还需要考虑到 Namespace 和 Cgroups. 这两个概念是容器技术的基石, 后面中要讨论的容器相关问题, 多少都会和 Namespace 或者 Cgroups 相关.</p> <p>总之就是一句话, <mark><strong>可以结合 Linux 操作系统的主要模块, 把容器的知识结构系统地串联起来, 同时看到 Namespace 和 Cgroups 带来的特殊性</strong></mark>​ <strong>.</strong></p> <p><img src="/img/2f4b60ddd907c1303b08191b15876aa4-20230731161430-o1h1ld2.png" alt=""></p> <h5 id="_2-怎么解决容器问题"><a href="#_2-怎么解决容器问题" class="header-anchor">#</a> 2.怎么解决容器问题?</h5> <p>心中有了容器的知识体系, 也就能在容器实践中解决具体的问题了. 结合我自己这么多年的经历, 总结了一条经验, **解决容器问题需要一个态度 + 两个步骤. **</p> <p>在解决容器问题的过程中, 常见的误区就是浅尝辄止, 不去挖掘问题的根本原因. 接下来就拿一个具体的例子来说明.</p> <p>有一次团队一位同学问我, 怎么让 Kubernetes 节点上的容器, <strong>从内部触发自己的容器重启</strong>啊? 试了一下, 在容器中把第 1 号进程杀了, 然后容器退出, Kubernetes 自动地把容器带回来, 就能实现类似的自动重启功能了, 同事试了也可以, 认为问题解决了, 也挺开心的. 我也没有多想, 以为自己找到方法了.</p> <p>后来又有一个同事和我说, 这样做没有效果啊. 我这才发现问题没那么简单.</p> <p>所以我又花时间理了理 Linux 信号的基本知识, trace 了一下内核代码, 终于找到了真正的原因, 那就是对于<strong>发送给 1 号进程的信号, 内核会根据不同的类型, 不同的注册状态, 采取不同的处理方式</strong>. 这就是解决容器问题时我们需要的一个态度: 不要浅尝辄止, 要刨根问底.</p> <p>态度有了, 那如果在线上碰到了更加复杂的问题, 又该怎么解决呢? 这就需要两个步骤了.</p> <p>第一步就是**化繁为简, 重现问题. **</p> <p>想要做到这一点, 倒推回去, 还是需要对基本的概念足够了解. 只有对每个模块的概念都很清晰, 才能对复杂问题做拆分. 能够对问题做拆分是不是就够了呢? 其实还不够, 我自己有一个判断标准, 就是还要能够写模拟程序, 看是否可以用最简单的程序来重现问题. **如果能用简单的代码程序重现问题, 那么问题也就解决了一半. **</p> <p>接下来还需要进行第二步, 就是想办法**把黑盒系统变成白盒系统. **</p> <p>前面提到过, 容器的问题大多都会归结到 Linux 系统上. Linux 系统从内核, 库函数以及服务程序上看, 虽然都是开源的, 但是它运行在生产环境的时候, 几乎就是一个黑盒. 之所以说系统是黑盒, 一方面是因为这个系统太庞大, 太复杂了; 另一方面, 在实际运行的时候, 只有很少的 log 会记录运行的过程和参数. 所以在出问题的时候, 无法知道问题对应的代码, 也不可能在生产环境中随心所欲地加 debug log.</p> <p>因此就需要想点办法把它变成白盒, 才能去排查和解决问题. 具体怎么做呢? 这里需要<strong>熟练地掌握调试工具</strong>, 这样才能把某些函数变成 &quot;白盒&quot;, 从而找到复杂问题的根本原因, 再对症下药. 熟练掌握工具有个重要前提, 就是从全局上去掌握 Linux 系统以及容器, 回归到底层原理去看问题. 可以说把基础概念吃透了, 练好了 &quot;内功心法&quot;, 有了这个底子, 工具运用是水到渠成的事儿.</p> <h5 id="_3-本节课是如何设计的"><a href="#_3-本节课是如何设计的" class="header-anchor">#</a> 3.本节课是如何设计的?</h5> <p>这门课程会把零散的知识点体系化, 按照类似操作系统的模块划分, 来讲述我所理解的容器.</p> <p>我们将一起学习<strong>容器进程, 容器内存, 容器存储,  容器网络, 容器安全</strong>这几部分内容. 在每一节课中, 都会解决一个实际问题或者研究一个现象. 围绕这个问题, 会讲解相关的知识点, 并结合实际的操作做理解, 最终解决问题或者解释现象.</p> <p>要实现两个学习目标.</p> <p>**第一, 系统掌握容器核心点: Namespace 和 Cgroups. **</p> <p>**第二, 理解 Namespace 和 Cgroups 对 Linux 原来模块的影响, 看看它们是如何影响一些传统操作系统的行为. **</p> <p>比如 Memory Cgroup, 对 Pagecache 和 Swap 空间有怎样的影响; 再比如在 proc 文件系统下, 网络参数应用了 Network Namespace 之后, 需要如何重新设置等等.</p> <p>当一起把容器知识的框架搭建起来, 把里面的核心概念, 底层逻辑掌握之后, 其实就可以解决容器的大部分问题了.</p> <p>课程结束后, 会做一个专题加餐. 我选择了一个真实案例, 就是在生产环境中容器网络延时不稳定的问题. 在这个案例中, 会用到 <strong>perf, ftrace, bcc/ebpf 这几个 Linux 调试工具</strong>, 了解它们的原理, 熟悉它们在调试问题的不同阶段所发挥的作用, 然后用这些工具一起来解决现实场景中复杂的容器问题.</p> <p>在这个容器课程中, 每一讲里都会有一些小例子, 所以需要**有一台安装有 Linux 的机器, 或者用 VirtualBox 安装一个虚拟机来跑 Linux. Linux 的版本建议是 CentOS 8 或者是 Ubuntu 20.04. **</p> <p>最后我想说, **容器是一个很好的技术窗口, 它可以帮助你在这个瞬息万变的计算机世界里看到后面那些 &quot;不变&quot; 的技术, 只有掌握好那些 &quot;不变&quot; 的技术, 才可以更加从容地去接受技术的瞬息万变. **</p> <h4 id="_01-认识容器-容器的基本操作和实现原理"><a href="#_01-认识容器-容器的基本操作和实现原理" class="header-anchor">#</a> 01 | 认识容器:容器的基本操作和实现原理</h4> <p>容器这东西一点都不复杂, 如果你只是想用的话, 那跟着Docker 官网的说明, 应该十来分钟就能搞定. 简单来说, 它就是个小工具, 可以把你想跑的程序, 库文件啊, 配置文件都一起 &quot;打包&quot;. 然后在任何一个计算机的节点上, 都可以使用这个打好的包. 有了容器, 一个命令就能把想跑的程序跑起来, 做到了**一次打包, 就可以到处使用. **</p> <p>本节来聊聊容器背后的实现机制. 空讲原理也没什么感觉, 所以还是会先启动一个容器, 然后再一起来探讨容器里面的<mark><strong>两大关键技术---Namespace 和 Cgroups</strong></mark>. 基本上理解了这两个概念, 就能彻底搞懂容器的核心原理了.</p> <h5 id="_1-做个镜像"><a href="#_1-做个镜像" class="header-anchor">#</a> 1.做个镜像</h5> <p>启动容器的工具有很多, 在这里还是使用 Docker 这个最常用的容器管理工具. 安装完 Docker 之后, 先来用下面的命令运行一个 httpd 服务.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> centos/httpd:latest
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这命令也很简单, run 的意思就是要启动一个容器, <code>-d</code>​ 参数里 d 是 Daemon 的首字母, 也就是让容器在后台运行.</p> <p>最后一个参数 <code>centos/httpd:latest</code>​ 指定了具体要启动哪一个<strong>镜像</strong>, 比如这里启动的是 centos/httpd 这个镜像的 latest 版本.</p> <p>其实镜像就是一个<mark>特殊的</mark>​<mark><strong>文件系统</strong></mark>​<mark>, </mark>​<mark><strong>它提供了容器中程序执行需要的所有文件</strong></mark>​ <strong>. ** 具体来说, 就是</strong>应用程序想启动, 需要三类文件: <strong>​<mark><strong>相关的程序可执行文件, 库文件和配置文件</strong></mark>, 这三类文件</strong>都被容器打包做好<strong>了. 这样在容器运行的时候就</strong>不再依赖宿主机上的文件操作系统类型和配置**了, 做到了想在哪个节点上运行, 就可以在哪个节点上立刻运行.</p> <p>那么怎么来做一个容器镜像呢?</p> <p>刚才的例子里, 用的 <code>centos/httpd:latest</code>​ 这个镜像是 <strong>Docker 镜像库</strong>里直接提供的. 当然也可以自己做一个提供 httpd 服务的容器镜像, 这里仍然可以用 Docker 这个工具来自定义镜像.</p> <p>Docker 为用户自己定义镜像提供了一个叫做 <strong>Dockerfile 的文件</strong>, 在这个 Dockerfile 文件里, 可以设定自己镜像的创建步骤.</p> <p>如果自己来做一个 httpd 的镜像也不难, 其 Dockerfile 如下.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">cat</span> Dockerfile
FROM centos:8.1.1911
RUN yum <span class="token function">install</span> <span class="token parameter variable">-y</span> httpd
COPY file1 /var/www/html/
ADD  file2.tar.gz /var/www/html/
CMD <span class="token punctuation">[</span><span class="token string">&quot;/sbin/httpd&quot;</span>, <span class="token string">&quot;-D&quot;</span>, <span class="token string">&quot;FOREGROUND&quot;</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>看下它做了哪几件事: 在一个 centos 的<strong>基准镜像</strong>上安装好 httpd 的包, 然后在 httpd 提供文件服务的配置目录下, 把需要对外提供的文件 file1 和 file2 拷贝过去, 最后指定容器启动以后, 需要自动启动的 httpd 服务. 有了这个镜像, 希望容器启动后, 就运行这个 httpd 服务, 让用户可以下载 file1 还有 file2 这两个文件.</p> <p>这个 Dockerfile 的每一行, 第一个大写的词都是 Dockerfile 专门定义的指令, 也就是 <code>FROM</code>​, <code>RUN</code>​, <code>COPY</code>​, <code>ADD</code>​, <code>CMD</code>​, 这些指令都很基础, 所以不做详细解释了, 可以参考 Dockerfile 的官方文档.</p> <p>写完这个 Dockerfile 之后, 想要让它变成一个镜像, 还需要执行一下 <code>docker build</code>​ 命令.</p> <p>下面这个命令中 <code>-f ./Dockerfile</code>​ 指定 Dockerfile 文件, <code>-t registry/httpd:v1</code>​ 指定了生成出来的镜像名, 它的格式是 &quot;name:tag&quot;, 这个镜像名也是后面启动容器需要用到的.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">docker</span> build <span class="token parameter variable">-t</span> registry/httpd:v1 <span class="token parameter variable">-f</span> ./Dockerfile <span class="token builtin class-name">.</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​<code>docker build</code>​ 执行成功之后, 再运行 <code>docker images</code>​ 这个命令, 就可以看到生成的镜像了.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">docker</span> images
REPOSITORY  TAG   IMAGEID  CREATED   SIZE
registry/httpd  v1  c682fc3d4b9a  <span class="token number">4</span> seconds ago  277MB
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h5 id="_2-启动一个容器-container"><a href="#_2-启动一个容器-container" class="header-anchor">#</a> 2.启动一个容器(Container)</h5> <p>做完一个镜像之后, 就可以用这个镜像来启动一个容器了, 刚才做的镜像名字是 registry/httpd:v1, 那么还是用 docker run 这个命令来启动容器.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> registry/httpd:v1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>容器启动完成后, 可以用 <code>docker ps</code>​ 命令来查看这个已经启动的容器:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">docker</span> <span class="token function">ps</span>
CONTAINER ID      IMAGE        COMMAND     CREATED       STATUS        PORTS               NAMES
c5a9ff78d9c1        registry/httpd:v1   <span class="token string">&quot;/sbin/httpd -D FORE…&quot;</span>   <span class="token number">2</span> seconds ago       Up <span class="token number">2</span> seconds                            loving_jackson
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在前面介绍 Dockerfile 的时候说过做这个镜像是用来提供 HTTP 服务的, 也就是让用户可以下载 file1, file2 这两个文件.</p> <p>那怎样来验证建起来的容器是不是正常工作的呢? 可以通过这两步来验证:</p> <ol><li>第一步, 可以进入容器的运行空间, 查看 httpd 服务是不是启动了, 配置文件是不是正确的.</li> <li>第二步, 对于 HTTP 文件服务, 如果能用 <code>curl</code>​ 命令下载文件, 就可以证明这个容器提供了预期的 httpd 服务.</li></ol> <p>先来做第一步验证, 可以运行 <code>docker exec</code>​ 这个命令进入容器的<strong>运行空间</strong>, 至于什么是容器的运行空间, 它的标准说法是容器的命名空间(Namespace), 这个概念等会儿再做介绍.</p> <p>进入容器运行空间之后, 怎么确认 httpd 的服务进程已经在容器里启动了呢?</p> <p>运行下面这个 <code>docker exec</code>​ 命令, 也就是执行 <code>docker exec c5a9ff78d9c1 ps -ef</code>​, 可以看到 httpd 的服务进程正在容器的空间中运行.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> c5a9ff78d9c1 <span class="token function">ps</span> <span class="token parameter variable">-ef</span>
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd <span class="token parameter variable">-D</span> FOREGROUND
apache       <span class="token number">6</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd <span class="token parameter variable">-D</span> FOREGROUND
apache       <span class="token number">7</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd <span class="token parameter variable">-D</span> FOREGROUND
apache       <span class="token number">8</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd <span class="token parameter variable">-D</span> FOREGROUND
apache       <span class="token number">9</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd <span class="token parameter variable">-D</span> FOREGROUND
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>解释一下, 在这个 <code>docker exec</code>​ 后面紧跟着的 ID 表示容器的 ID, 这个 ID 就是之前运行 <code>docker ps</code>​ 查看过那个容器, 容器的 ID 值是 <code>c5a9ff78d9c1</code>​. 在这个 ID 值的后面, 就是要在容器空间里运行的 <code>ps -ef</code>​ 命令.</p> <p>接下来再来确认一下, httpd 提供文件服务的目录中 file1 和 file2 文件是否存在.</p> <p>同样可以用 <code>docker exec</code>​ 来查看一下容器的文件系统中, httpd 提供文件服务的目录 <code>/var/www/html</code>​ 是否有这两个文件. 很好, 可以看到 file1, file2 这两个文件也都放在指定目录中了.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> c5a9ff78d9c1 <span class="token function">ls</span> /var/www/html
file1
file2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>到这里完成了第一步的验证, 进入到容器的运行空间里, 验证了 httpd 服务已经启动, 配置文件也是正确的.</p> <p>那下面要做第二步的验证, 用 <code>curl</code>​ 命令来验证是否可以从容器的 httpd 服务里下载到文件.</p> <p>如果要访问 httpd 服务, 就需要知道这个容器的 IP 地址. 容器的网络空间也是独立的, 有一个它自己的 IP. 还是可以用 <code>docker exec</code>​ 进入到容器的网络空间, 查看一下这个容器的 IP.</p> <p>运行下面的这条 <code>docker exec c5a9ff78d9c1 ip addr</code>​ 命令, 可以看到容器里网络接口 eth0 上配置的 IP 是 <code>172.17.0.2</code>​. 这个 IP 目前<strong>只能在容器的宿主机上访问</strong>, 在别的机器上目前是不能访问的. 关于容器网络的知识, 会在后面介绍.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> c5a9ff78d9c1 <span class="token function">ip</span> addr
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo
       valid_lft forever preferred_lft forever
<span class="token number">168</span>: eth0@if169: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc noqueue state UP group default
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="token number">0</span>
    inet <span class="token number">172.17</span>.0.2/16 brd <span class="token number">172.17</span>.255.255 scope global eth0
       valid_lft forever preferred_lft forever
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>获取了 httpd 服务的 IP 地址之后, 随便下载一个文件试试, 比如选 file2.</p> <p>在宿主机上运行 <code>curl</code>​, 就可以下载这个文件了, 操作如下. 文件下载成功了, 这证明了这个提供 httpd 服务的容器正常运行了.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">curl</span> <span class="token parameter variable">-L</span> <span class="token parameter variable">-O</span> http://172.17.0.2/file2
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
<span class="token number">100</span>     <span class="token number">6</span>  <span class="token number">100</span>     <span class="token number">6</span>    <span class="token number">0</span>     <span class="token number">0</span>   <span class="token number">1500</span>      <span class="token number">0</span> --:--:-- --:--:-- --:--:--  <span class="token number">1500</span>
$ <span class="token function">ls</span>
file2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>上面的步骤完成之后, 第二步验证, 用 <code>curl</code>​ 下载 httpd 服务提供的文件也成功了.</p> <p>通过这上面的这些操作练习, 估计你已经初步感知到, <strong>容器的文件系统是独立的, 运行的进程环境是独立的, 网络的设置也是独立的</strong>. 感觉它们和宿主机上的文件系统, 进程环境以及网络感觉都已经分开了. 的确是这样. 刚才启动的容器, 已经从宿主机环境里被分隔出来了, 就像下面这张图里的描述一样.</p> <p><img src="/img/522a5bef9073ca778a5295ac78ecb801-20230731161430-ys3fcge.png" alt=""></p> <p>**从用户使用的角度来看, 容器和一台独立的机器或者虚拟机没有什么太大的区别, 但是它和虚拟机相比, 却没有各种复杂的硬件虚拟层, 没有独立的 Linux 内核. **</p> <p><strong>容器所有的进程调度, 内存访问, 文件的读写都直接跑在宿主机的内核之上</strong>, 这是怎么做到的呢?</p> <h5 id="_3-容器是什么"><a href="#_3-容器是什么" class="header-anchor">#</a> 3.容器是什么</h5> <p>要回答这个问题, 可以先记住这两个术语 <mark><strong>Namespace 和 Cgroups</strong></mark>. 如果有人问你 Linux 上的容器是什么, 最简单直接的回答就是 Namesapce 和 Cgroups. <mark><strong>Namespace 和 Cgroups 可以让程序在一个资源可控的独立(隔离)环境中运行, 这个就是容器了</strong></mark>.</p> <p>现在已经发现: 容器的进程, 网络还有文件系统都是独立的. 那问题来了, 容器的独立运行环境到底是怎么创造的呢? 这就要提到 Namespace 这个概念了. 所以接下来就先从已经有点感觉的 Namespace 开始分析.</p> <h6 id="_1-namespace"><a href="#_1-namespace" class="header-anchor">#</a> (1)Namespace</h6> <p>接着前面的例子, 正好有了一个正在运行的容器, 那就拿这个运行的容器来看看 Namespace 到底是什么? 在前面运行 <code>docker exec c5a9ff78d9c1 ps -ef</code>​, 看到了 5 个 httpd 进程, 而且也只有这 5 个进程.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> c5a9ff78d9c1 <span class="token function">ps</span> <span class="token parameter variable">-ef</span>
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd <span class="token parameter variable">-D</span> FOREGROUND
apache       <span class="token number">6</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd <span class="token parameter variable">-D</span> FOREGROUND
apache       <span class="token number">7</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd <span class="token parameter variable">-D</span> FOREGROUND
apache       <span class="token number">8</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd <span class="token parameter variable">-D</span> FOREGROUND
apache       <span class="token number">9</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd <span class="token parameter variable">-D</span> FOREGROUND
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>如果不用 <code>docker exec</code>​, 直接在宿主机上运行 ps -ef, 就会看到很多进程. 如果运行一下 <code>grep httpd</code>​ , 同样可以看到这 5 个 httpd 的进程:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> httpd
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root     <span class="token number">20731</span> <span class="token number">20684</span>  <span class="token number">0</span> <span class="token number">18</span>:59 ?        00:00:01 /sbin/httpd <span class="token parameter variable">-D</span> FOREGROUND
<span class="token number">48</span>       <span class="token number">20787</span> <span class="token number">20731</span>  <span class="token number">0</span> <span class="token number">18</span>:59 ?        00:00:00 /sbin/httpd <span class="token parameter variable">-D</span> FOREGROUND
<span class="token number">48</span>       <span class="token number">20788</span> <span class="token number">20731</span>  <span class="token number">0</span> <span class="token number">18</span>:59 ?        00:00:06 /sbin/httpd <span class="token parameter variable">-D</span> FOREGROUND
<span class="token number">48</span>       <span class="token number">20789</span> <span class="token number">20731</span>  <span class="token number">0</span> <span class="token number">18</span>:59 ?        00:00:05 /sbin/httpd <span class="token parameter variable">-D</span> FOREGROUND
<span class="token number">48</span>       <span class="token number">20791</span> <span class="token number">20731</span>  <span class="token number">0</span> <span class="token number">18</span>:59 ?        00:00:05 /sbin/httpd <span class="token parameter variable">-D</span> FOREGROUN
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这两组输出结果到底有什么差别呢, 可以仔细做个对比, 最大的不同就是<mark><strong>进程的 PID 不一样</strong></mark>​ **. ** 那为什么 PID 会不同呢? 或者说运行 <code>docker exec c5a9ff78d9c1 ps -ef</code>​ 和 <code>ps -ef</code>​ 实质的区别在哪里呢?</p> <p>如果理解了 PID 为何不同, 就能搞清楚 Linux Namespace 的概念了, 为了方便后文的讲解, 先用下面这张图来梳理一下看到的 PID.</p> <p><img src="/img/c8048e34bd752ffa0081f61fe5ce497e-20230731161430-hj8rgqd.png" alt=""></p> <p>**Linux 在创建容器的时候, 就会建出一个 PID Namespace, PID 其实就是进程的编号. 这个 PID Namespace, 就是指每建立出一个 Namespace, 就会单独对进程进行 PID 编号, 每个 Namespace 的 PID 编号都从 1 开始. **</p> <p>同时在这个 PID Namespace 中也只能看到 Namespace 中的进程, 而且看不到其他 Namespace 里的进程.  这也就是说, 如果有另外一个容器, 那么它也有自己的一个 PID Namespace, 而这两个 PID Namespace 之间是不能看到对方的进程的, 这里就体现出了 Namespace 的作用: <mark><strong>相互隔离</strong></mark>.</p> <p>而在宿主机上的 Host PID Namespace, 它是其他 Namespace 的父亲 Namespace, 可以看到在这台机器上的所有进程, 不过进程 PID 编号不是 Container PID Namespace 里的编号了, 而是<strong>把所有在宿主机运行的进程放在一起, 再进行编号</strong>.</p> <p>讲了 PID Namespace 之后, <mark><strong>Namespace 其实就是一种隔离机制, 主要目的是隔离运行在同一个宿主机上的容器, 让这些容器之间不能访问彼此的资源</strong></mark>​ **. **</p> <p>这种隔离有两个作用: <mark><strong>第一是可以充分地利用系统的资源, 也就是说在同一台宿主机上可以运行多个用户的容器; 第二是保证了安全性, 因为不同用户之间不能访问对方的资源</strong></mark>​ **. **</p> <p>除了 <strong>PID Namespace</strong>, 还有其他常见的 Namespace 类型, 比如之前运行了 <code>docker exec c5a9ff78d9c1 ip addr</code>​ 这个命令去查看容器内部的 IP 地址, 这里其实就是在查看 Network Namespace.</p> <p>在 Network Namespace 中都有一套**独立的网络接口, ** 比如这里的 lo, eth0, 还有独立的 TCP/IP 的协议栈配置.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> c5a9ff78d9c1 <span class="token function">ip</span> addr
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo
       valid_lft forever preferred_lft forever
<span class="token number">168</span>: eth0@if169: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc noqueue state UP group default
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="token number">0</span>
    inet <span class="token number">172.17</span>.0.2/16 brd <span class="token number">172.17</span>.255.255 scope global eth0
       valid_lft forever preferred_lft forever
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>还可以运行 <code>docker exec c5a9ff78d9c1 ls/</code>​ 查看容器中的根文件系统(rootfs). 可以发现, 它和宿主机上的根文件系统也是不一样的. <mark><strong>容器中的根文件系统, 其实就是我们做的镜像</strong></mark>​ **. **</p> <p>那容器自己的根文件系统完全独立于宿主机上的根文件系统, 这一点是怎么做到的呢? 其实这里依靠的是 <mark><strong>Mount Namespace</strong></mark>​ <strong>, Mount Namespace 保证了每个容器都有自己独立的文件目录结构</strong>.</p> <p>Namespace 的类型还有很多, 查看 &quot;Linux Programmer’s Manual&quot;, 可以看到 Linux 中所有的 Namespace: <mark><strong>cgroup/ipc/network/mount/pid/time/user/uts</strong></mark>.</p> <p>在这里需要记住的是 **Namespace 是 Linux 中实现容器的两大技术之一, 它最重要的作用是保证资源的隔离. ** 在后面讲解到具体问题时, 会不断地提到 Namespace 这个概念.</p> <p><img src="/img/c7e3984329d63d66ae37eca39ffabb0c-20230731161430-eu2rkpj.png" alt=""></p> <p>刚才说了 Namespace, 这些 Namespace 尽管类型不同, 其实都是为了隔离容器资源: <mark><strong>PID Namespace 负责隔离不同容器的进程, Network Namespace 又负责管理网络环境的隔离, Mount Namespace 管理文件系统的隔离</strong></mark>​ **. **</p> <p>正是通过这些 Namespace, 才隔离出一个容器, 这里也可以把它看作是一台 &quot;计算机&quot;. 既然是一台 &quot;计算机&quot;, 你肯定会问这个 &quot;计算机&quot; 有多少 CPU, 有多少 Memory 啊? 那么 Linux 如何为这些 &quot;计算机&quot; 来定义 CPU, 定义 Memory 的容量呢?</p> <h6 id="_2-cgroups"><a href="#_2-cgroups" class="header-anchor">#</a> (2)Cgroups</h6> <p>想要定义 &quot;计算机&quot; 各种容量大小, 就涉及到支撑容器的第二个技术 <strong>Cgroups (Control Groups)</strong> 了. <mark><strong>Cgroups 可以对指定的进程做各种计算机资源的限制, 比如限制 CPU 的使用率, 内存使用量, IO 设备的流量等等</strong></mark>.</p> <p>Cgroups 究竟有什么好处呢? 要知道, 在 Cgroups 出现之前, 任意一个进程都可以创建出成百上千个线程, 可以轻易地消耗完一台计算机的所有 CPU 资源和内存资源. 但有了 Cgroups 这个技术以后, 就可以<strong>对一个进程或者一组进程的计算机资源的消耗进行限制</strong>了.</p> <p>**Cgroups 通过不同的子系统限制了不同的资源, 每个子系统限制一种资源. 每个子系统限制资源的方式都是类似的, 就是把相关的一组进程分配到一个控制组里, 然后通过树结构进行管理, 每个控制组都设有自己的资源控制参数. **</p> <p>完整的 Cgroups 子系统的介绍, 可以查看 Linux Programmer’s Manual 中 Cgroups 的定义.</p> <p>这里只需要了解几种比较常用的 Cgroups 子系统:</p> <ol><li><strong>CPU 子系统</strong>, 用来限制一个控制组(一组进程, 可以理解为一个容器里所有的进程)可使用的最大 CPU.</li> <li><strong>memory 子系统</strong>, 用来限制一个控制组最大的内存使用量.</li> <li><strong>pids 子系统</strong>, 用来限制一个控制组里最多可以运行多少个进程.</li> <li><strong>cpuset 子系统</strong>, 这个子系统来限制一个控制组里的进程可以在哪几个物理 CPU 上运行.</li></ol> <p>因为 memory 子系统的限制参数最简单, 所以下面就用 memory 子系统为例, 一起看看 Cgroups 是怎么对一个容器做资源限制的.</p> <p>对于<strong>启动的每个容器, 都会在 Cgroups 子系统下建立一个目录, 在 Cgroups 中这个目录也被称作控制组</strong>, 比如下图里的 <code>&quot;docker-&lt;id1&gt;&quot;, &quot;docker-&lt;id2&gt;&quot;</code>​ 等. 然后<strong>设置这个控制组的参数, 通过这个方式, 来限制这个容器的内存资源</strong>.</p> <p><img src="/img/82c532059b2b74dcedbe4cd758ce2471-20230731161430-ljzlwsj.png" alt=""></p> <p>还记得之前用 Docker 创建的那个容器吗? 在每个 Cgroups 子系统下, <strong>对应这个容器就会有一个目录</strong> docker-**c5a9ff78d9c1... ** 这个容器的 ID 号, <strong>容器中所有的进程都会储存在这个控制组中 cgroup.procs 这个参数里</strong>.</p> <p>你看下面的这些进程号是不是很熟悉呢? 没错, 它们就是前面用 ps 看到的进程号.</p> <p>实际看一下这个例子里的 memory Cgroups, 它可以控制 Memory 的使用量. 比如将这个控制组 Memory 的最大用量设置为 2GB.</p> <p>具体操作是把 (2* 1024 * 1024 * 1024 = 2147483648) 这个值, 写入 memory Cgroup 控制组中的 memory.limit_in_bytes 里, **这样设置后, cgroup.procs 里面所有进程 Memory 使用量之和, 最大也不会超过 2GB. **</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token builtin class-name">cd</span> /sys/fs/cgroup/memory/system.slice/docker-c5a9ff78d9c1fedd52511e18fdbd26357250719fa0d128349547a50fad7c5de9.scope
$ <span class="token function">cat</span> cgroup.procs
<span class="token number">20731</span>
<span class="token number">20787</span>
<span class="token number">20788</span>
<span class="token number">20789</span>
<span class="token number">20791</span>
$ <span class="token builtin class-name">echo</span> <span class="token number">2147483648</span> <span class="token operator">&gt;</span> memory.limit_in_bytes
$ <span class="token function">cat</span> memory.limit_in_bytes
<span class="token number">2147483648</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>刚刚通过 memory Cgroups 定义了容器的 memory 可以使用的最大值. 其他的子系统稍微复杂一些, 但用法也和 memory 类似, 在后面会结合具体的实例来详细解释其他的 Cgroups.</p> <p>这里还要提一下 <strong>Cgroups 有 v1 和 v2 两个版本</strong>:</p> <p>Cgroups v1 在 Linux 中很早就实现了, 各种子系统比较独立, 每个进程在各个 Cgroups 子系统中独立配置, 可以属于不同的 group. 虽然这样比较灵活, 但是也存在问题, 会导致对<strong>同一进程的资源协调比较困难</strong>(比如 memory Cgroup 与 blkio Cgroup 之间就不能协作). 虽然 v1 有缺陷, 但是在主流的生产环境中, 大部分使用的还是 v1.</p> <p>Cgroups v2 做了设计改进, **解决了 v1 的问题, 使各个子系统可以协调统一地管理资源. ** 不过 Cgroups v2 在生产环境的应用还很少, 因为该版本很多子系统的实现需要较新版本的 Linux 内核, 还有无论是主流的 Linux 发行版本还是容器云平台, 比如 Kubernetes 对 v2 的支持也刚刚起步.</p> <p>所以后面 Cgroups 的讲解里, 主要还是用 <strong>Cgroups v1 这个版本</strong>, 在磁盘 I/O 的这一章, 也会介绍一下 Cgroups v2.</p> <h5 id="_4-重点总结"><a href="#_4-重点总结" class="header-anchor">#</a> 4.重点总结</h5> <p>本节对容器有了一个大致的认识, 包括它的 &quot;形&quot;, <strong>一些基本的容器操作</strong>; 还有它的 &quot;神&quot;, 也就是<strong>容器实现的原理</strong>.</p> <p>启动容器的基本操作是这样的, 首先用 Dockerfile 来建立一个容器的镜像, 然后再用这个镜像来启动一个容器.</p> <p>那启动了容器之后, 怎么检验它是不是正常工作了呢?</p> <p>可以运行 <code>docker exec</code>​ 这个命令进入容器的运行空间, 查看进程是否启动, 检查配置文件是否正确, 检验设置的服务是否能够正常提供.</p> <p>用 <code>docker exec</code>​ 命令查看了容器的进程, 网络和文件系统, 就能体会到容器的文件系统, 运行的进程环境和网络的设置都是独立的, 所以从用户使用的角度看, 容器和一台独立的机器或者虚拟机没有什么太大的区别.</p> <p>最后一起学习了 Namespace 和 Cgroups, 它们是 Linux 的两大技术, 用于实现容器的特性. 目前只需要先记住这两个技术的作用, <mark><strong>Namespace 帮助容器来实现各种计算资源的隔离, Cgroups 主要限制的是容器能够使用的某种资源量</strong></mark>​ **. **</p> <p>所以在这里可以直接记住: <mark><strong>容器其实就是 Namesapce + Cgroups</strong></mark>​ **. **</p> <h3 id="容器进程"><a href="#容器进程" class="header-anchor">#</a> 容器进程</h3> <h4 id="_02-理解进程-1-为什么我在容器中不能kill-1号进程"><a href="#_02-理解进程-1-为什么我在容器中不能kill-1号进程" class="header-anchor">#</a> 02 | 理解进程(1):为什么我在容器中不能kill 1号进程?</h4> <p>本节正式进入理解进程的模块. 后面三节将介绍容器 <strong>init 进程</strong>的特殊之处, 还有它需要具备哪些功能, 才能保证容器在运行过程中不会出现类似僵尸进程, 或者应用程序无法 graceful shutdown 的问题.</p> <p>本节会介绍 init 进程和 Linux 信号的核心概念.</p> <h5 id="_1-问题再现"><a href="#_1-问题再现" class="header-anchor">#</a> 1.问题再现</h5> <p>接下来一起再现用 <code>kill 1</code>​ 命令重启容器的问题.</p> <p>我猜你肯定想问, 为什么要在容器中执行 <code>kill 1</code>​ 或者 <code>kill -9 1</code>​ 的命令呢? 其实这是我们团队里的一位同学提出的问题. 这位同学当时遇到的情况是这样的, 他想修改容器镜像里的一个 bug, 但因为网路配置的问题, 这个同学又不想为了重建 pod 去改变 pod IP.</p> <p>如果你用过 Kubernetes 的话, 你也肯定知道, Kubernetes 上是没有 <code>restart pod</code>​ 这个命令的. 这样看来似乎只能<strong>让 pod 做个原地重启</strong>了. **当时我首先想到的, 就是在容器中使用 kill pid 1 的方式重启容器. **</p> <p>为了模拟这个过程, 可以进行下面的这段操作.</p> <p>如果你没有在容器中做过 <code>kill 1</code>​, 可以下载我在 GitHub 上的这个例子, 运行 <code>make image</code>​ 来做一个容器镜像. 然后用 Docker 构建一个容器, 用例子中的 <strong>init.sh 脚本</strong>作为这个容器的 init 进程.</p> <p>最后, 在容器中运行 <code>kill 1</code>​ 和 <code>kill -9 1</code>​, 看看会发生什么.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">docker</span> stop sig-proc<span class="token punctuation">;</span><span class="token function">docker</span> <span class="token function">rm</span> sig-proc
$ <span class="token function">docker</span> run <span class="token parameter variable">--name</span> sig-proc <span class="token parameter variable">-d</span> registry/sig-proc:v1 /init.sh
$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> sig-proc <span class="token function">bash</span>
<span class="token punctuation">[</span>root@5cc69036b7b2 /<span class="token punctuation">]</span>$ <span class="token function">ps</span> <span class="token parameter variable">-ef</span>
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> 07:23 ?        00:00:00 /bin/bash /init.sh
root         <span class="token number">8</span>     <span class="token number">1</span>  <span class="token number">0</span> 07:25 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang<span class="token operator">=</span>sleep /usr/bin/sleep <span class="token number">100</span>
root         <span class="token number">9</span>     <span class="token number">0</span>  <span class="token number">6</span> 07:27 pts/0    00:00:00 <span class="token function">bash</span>
root        <span class="token number">22</span>     <span class="token number">9</span>  <span class="token number">0</span> 07:27 pts/0    00:00:00 <span class="token function">ps</span> <span class="token parameter variable">-ef</span>
<span class="token punctuation">[</span>root@5cc69036b7b2 /<span class="token punctuation">]</span>$ <span class="token function">kill</span> <span class="token number">1</span>
<span class="token punctuation">[</span>root@5cc69036b7b2 /<span class="token punctuation">]</span>$ <span class="token function">kill</span> <span class="token parameter variable">-9</span> <span class="token number">1</span>
<span class="token punctuation">[</span>root@5cc69036b7b2 /<span class="token punctuation">]</span>$ <span class="token function">ps</span> <span class="token parameter variable">-ef</span>
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> 07:23 ?        00:00:00 /bin/bash /init.sh
root         <span class="token number">9</span>     <span class="token number">0</span>  <span class="token number">0</span> 07:27 pts/0    00:00:00 <span class="token function">bash</span>
root        <span class="token number">23</span>     <span class="token number">1</span>  <span class="token number">0</span> 07:27 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang<span class="token operator">=</span>sleep /usr/bin/sleep <span class="token number">100</span>
root        <span class="token number">24</span>     <span class="token number">9</span>  <span class="token number">0</span> 07:27 pts/0    00:00:00 <span class="token function">ps</span> <span class="token parameter variable">-ef</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>当完成前面的操作, 就会发现无论运行 <code>kill 1</code>​ (对应 Linux 中的 SIGTERM 信号)还是 <code>kill -9 1</code>​(对应 Linux 中的 SIGKILL 信号), 都<strong>无法让进程终止</strong>. 问题来了, 这两个常常用来终止进程的信号, 都对容器中的 init 进程不起作用, 这是怎么回事?</p> <p>要解释这个问题, 就要回到容器的两个最基本概念 -- <strong>init 进程和 Linux 信号</strong>中寻找答案.</p> <h5 id="_2-知识详解"><a href="#_2-知识详解" class="header-anchor">#</a> 2.知识详解</h5> <h6 id="_1-如何理解init进程"><a href="#_1-如何理解init进程" class="header-anchor">#</a> (1)如何理解init进程?</h6> <p>使用容器的<strong>理想境界</strong>是<strong>一个容器只启动一个进程</strong>, 但这在现实应用中有时是做不到的. 比如在一个容器中除了<strong>主进程</strong>之外, 可能还会启动辅助进程, 做监控或者 rotate logs; 再比如需要把原来运行在虚拟机(VM)的程序移到容器里, 这些原来跑在虚拟机上的程序本身就是多进程的.</p> <p>一旦启动了多个进程, 那么容器里就会出现一个 <strong>pid 1</strong>, 也就是常说的 <mark><strong>1 号进程或者 init 进程</strong></mark>​<mark>, 然后</mark>​<mark><strong>由这个进程创建出其他的子进程</strong></mark>​ **. **</p> <p>接下来梳理一下 init 进程是怎么来的.</p> <p>一个 Linux 操作系统, 在系统打开电源, 执行 BIOS/boot-loader 之后, 就会由 boot-loader 负责加载 Linux 内核. Linux 内核执行文件一般会放在 /boot 目录下, 文件名类似 <code>vmlinuz*</code>​. 在内核完成了操作系统的各种初始化之后, <mark><strong>这个程序需要执行的第一个用户态程就是 init 进程</strong></mark>​ **. **</p> <p>内核代码启动 1 号进程的时候, 在没有外面参数指定程序路径的情况下, 一般会从几个缺省路径尝试执行 1 号进程的代码. 这几个路径都是 Unix 常用的可执行代码路径.</p> <p>**系统启动的时候先是执行内核态的代码, 然后在内核中调用 1 号进程的代码, 从内核态切换到用户态. **</p> <p>目前主流的 Linux 发行版, 无论是 RedHat 系的还是 Debian 系的, 都会把 /sbin/init 作为符号链接指向 Systemd. <strong>Systemd 是目前最流行的 Linux init 进程</strong>, 在它之前还有 SysVinit, UpStart 等 Linux init 进程. <mark><strong>但无论是哪种 Linux init 进程, 它最基本的功能都是创建出 Linux 系统中其他所有的进程, 并且管理这些进程</strong></mark>​ **. ** 具体在 kernel 里的代码实现如下:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>init<span class="token operator">/</span>main<span class="token punctuation">.</span>c
        <span class="token comment">/*
         * We try each of these until one succeeds.
         *
         * The Bourne shell can be used instead of init if we are
         * trying to recover a really broken machine.
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>execute_command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                ret <span class="token operator">=</span> <span class="token function">run_init_process</span><span class="token punctuation">(</span>execute_command<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ret<span class="token punctuation">)</span>
                        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">&quot;Requested init %s failed (error %d).&quot;</span><span class="token punctuation">,</span>
                      execute_command<span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">&quot;/sbin/init&quot;</span><span class="token punctuation">)</span> <span class="token operator">||</span>
            <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">&quot;/etc/init&quot;</span><span class="token punctuation">)</span> <span class="token operator">||</span>
            <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">&quot;/bin/init&quot;</span><span class="token punctuation">)</span> <span class="token operator">||</span>
            <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">&quot;/bin/sh&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">&quot;No working init found.  Try passing init= option to kernel. &quot;</span>
              <span class="token string">&quot;See Linux Documentation/admin-guide/init.rst for guidance.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> /sbin/init
lrwxrwxrwx <span class="token number">1</span> root root <span class="token number">20</span> Feb  <span class="token number">5</span> 01:07 /sbin/init -<span class="token operator">&gt;</span> /lib/systemd/systemd
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在 Linux 上有了容器的概念之后, <strong>一旦容器建立了自己的 Pid Namespace(进程命名空间), 这个 Namespace 里的进程号也是从 1 开始标记的. 所以容器的 init 进程也被称为 1 号进程</strong>.</p> <p>这里只需要记住: <mark><strong>1 号进程是第一个用户态的进程, 由它直接或者间接创建了 Namespace 中的其他进程</strong></mark>​ **. **</p> <h6 id="_2-如何理解linux信号"><a href="#_2-如何理解linux信号" class="header-anchor">#</a> (2)如何理解Linux信号?</h6> <p>要想解决 &quot;为什么我在容器中不能 kill 1 号进程&quot; 这个问题, 还得看看 kill 命令起到的作用.</p> <p>运行 kill 命令, 其实<strong>在 Linux 里就是发送一个信号</strong>, 那么信号到底是什么呢? 这就涉及到 Linux 信号的概念了. 信号这个概念在很早期的 Unix 系统上就有了. 它一般会从 1 开始编号, 通常来说, <strong>信号编号是 1 到 31</strong>, 这个编号在所有的 Unix 系统上都是一样的.</p> <p>在 Linux 上可以用 <code>kill -l</code>​ 来看这些信号的编号和名字, 具体的编号和名字列在了下面, 可以看一看.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">kill</span> <span class="token parameter variable">-l</span>
 <span class="token number">1</span><span class="token punctuation">)</span> SIGHUP      <span class="token number">2</span><span class="token punctuation">)</span> SIGINT    <span class="token number">3</span><span class="token punctuation">)</span> SIGQUIT    <span class="token number">4</span><span class="token punctuation">)</span> SIGILL    <span class="token number">5</span><span class="token punctuation">)</span> SIGTRAP
 <span class="token number">6</span><span class="token punctuation">)</span> SIGABRT     <span class="token number">7</span><span class="token punctuation">)</span> SIGBUS    <span class="token number">8</span><span class="token punctuation">)</span> SIGFPE     <span class="token number">9</span><span class="token punctuation">)</span> SIGKILL  <span class="token number">10</span><span class="token punctuation">)</span> SIGUSR1
<span class="token number">11</span><span class="token punctuation">)</span> SIGSEGV    <span class="token number">12</span><span class="token punctuation">)</span> SIGUSR2  <span class="token number">13</span><span class="token punctuation">)</span> SIGPIPE   <span class="token number">14</span><span class="token punctuation">)</span> SIGALRM  <span class="token number">15</span><span class="token punctuation">)</span> SIGTERM
<span class="token number">16</span><span class="token punctuation">)</span> SIGSTKFLT  <span class="token number">17</span><span class="token punctuation">)</span> SIGCHLD  <span class="token number">18</span><span class="token punctuation">)</span> SIGCONT   <span class="token number">19</span><span class="token punctuation">)</span> SIGSTOP  <span class="token number">20</span><span class="token punctuation">)</span> SIGTSTP
<span class="token number">21</span><span class="token punctuation">)</span> SIGTTIN    <span class="token number">22</span><span class="token punctuation">)</span> SIGTTOU  <span class="token number">23</span><span class="token punctuation">)</span> SIGURG    <span class="token number">24</span><span class="token punctuation">)</span> SIGXCPU  <span class="token number">25</span><span class="token punctuation">)</span> SIGXFSZ
<span class="token number">26</span><span class="token punctuation">)</span> SIGVTALRM  <span class="token number">27</span><span class="token punctuation">)</span> SIGPROF  <span class="token number">28</span><span class="token punctuation">)</span> SIGWINCH  <span class="token number">29</span><span class="token punctuation">)</span> SIGIO    <span class="token number">30</span><span class="token punctuation">)</span> SIGPWR
<span class="token number">31</span><span class="token punctuation">)</span> SIGSYS
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>用一句话来概括, <mark><strong>信号(Signal)其实就是 Linux 进程收到的一个通知</strong></mark>​ **. ** 这些通知产生的源头有很多种, 通知的类型也有很多种.</p> <p>比如下面这几个典型的场景可以看一下:</p> <ol><li>如果按下键盘 &quot;Ctrl+C&quot;, 当前运行的进程就会收到一个信号 <strong>SIGINT</strong> 而退出;</li> <li>如果代码写得有问题, 导致内存访问出错了, 当前的进程就会收到另一个信号 <strong>SIGSEGV</strong>;</li> <li>也可以通过命令 kill &lt;pid&gt;, 直接向一个进程发送一个信号, 缺省情况下不指定信号的类型, 那么这个信号就是 SIGTERM. 也可以指定信号类型, 比如命令 &quot;<code>kill -9 &lt;pid&gt;</code>​&quot;, 这里的 9, 就是编号为 9 的信号, SIGKILL 信号.</li></ol> <p>本节主要用到 <strong>SIGTERM(15)和 SIGKILL(9)这两个信号</strong>, 所以这里主要了解这两个信号就可以了, 其他信号以后用到时再做介绍.</p> <p><strong>进程在收到信号后, 就会去做相应的处理</strong>. 怎么处理呢? 对于每一个信号, 进程对它的处理都有下面三个选择.</p> <ul><li>第一个选择是<strong>忽略(Ignore)</strong> , 就是对这个信号不做任何处理, 但是有两个信号例外, 对于 SIGKILL 和 SIGSTOP 这个两个信号, 进程是<strong>不能忽略</strong>的. 这是因为它们的主要作用是为 Linux kernel 和超级用户提供删除任意进程的特权.</li> <li>第二个选择是<strong>捕获(Catch)</strong> , 这个是指让用户进程可以<strong>注册</strong>自己针对这个信号的 handler. 具体怎么做目前暂时涉及不到, 先知道就行, 后面会进行详细介绍. **对于捕获, SIGKILL 和 SIGSTOP 这两个信号也同样例外, 这两个信号不能有用户自己的处理代码, 只能执行系统的缺省行为. **</li> <li>第三个选择是<strong>缺省行为(Default)</strong> , Linux 为每个信号都定义了一个缺省的行为, 可以在 Linux 系统中运行 <code>man 7 signal</code>​ 来查看每个信号的缺省行为.</li></ul> <p>对于大部分的信号而言, 应用程序不需要注册自己的 handler, <strong>使用系统缺省定义行为</strong>就可以了.</p> <p><img src="/img/91c4469c38904c5fc2ab62499be203f7-20230731161430-86vuzzd.png" alt=""></p> <p>SIGTERM(15)和 SIGKILL(9)这两个信号是需要重点掌握的. 现在已经讲解了信号的概念和处理方式, 这里就拿这两个信号为例, 再具体分析一下.</p> <p>首先来看 SIGTERM(15), 这个信号是 Linux 命令 <strong>kill 缺省发出</strong>的. 前面例子里的命令 <code>kill 1</code>​, 就是通过 kill 向 1 号进程发送一个信号, 在没有别的参数时, 这个信号类型就默认为 <strong>SIGTERM</strong>.</p> <p><strong>SIGTERM 这个信号是可以被捕获的, 这里的 &quot;捕获&quot; 指的就是用户进程可以为这个信号注册自己的 handler, 而这个 handler, 后面会看到, 它可以处理进程的 graceful-shutdown 问题.</strong></p> <p>再来了解一下 SIGKILL (9), 这个信号是 Linux 里两个<strong>特权信号</strong>之一. 什么是特权信号呢?</p> <p>前面已经提到过了, **特权信号就是 Linux 为 kernel 和超级用户去删除任意进程所保留的, 不能被忽略也不能被捕获. ** 那么进程一旦收到 SIGKILL, 就要退出.</p> <p>在前面的例子里, 运行的命令 <code>kill -9 1</code>​ 里的参数 &quot;-9&quot;, 其实就是指发送编号为 9 的这个 SIGKILL 信号给 1 号进程.</p> <h5 id="_3-现象解释"><a href="#_3-现象解释" class="header-anchor">#</a> 3.现象解释</h5> <p>现在应该理解 init 进程和 Linux 信号这两个概念了, 回到开头的问题上来: &quot;为什么我在容器中不能 kill 1 号进程, 甚至 SIGKILL 信号也不行? &quot;</p> <p>本节最开始, 已经尝试过用 bash 作为容器 1 号进程, 这样是无法把 1 号进程杀掉的. 那么再看看, 用别的编程语言写的 1 号进程是否也杀不掉.</p> <p>现在<strong>用 C 程序作为 init 进程</strong>, 尝试一下杀掉 1 号进程. 和 bash init 进程一样, 无论 SIGTERM 信号还是 SIGKILL 信号, 在容器里都<strong>不能杀死</strong>这个 1 号进程.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">cat</span> <span class="token expression">c<span class="token operator">-</span>init<span class="token operator">-</span>nosig<span class="token punctuation">.</span>c</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Process is sleeping\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">docker</span> <span class="token expression">stop sig<span class="token operator">-</span>proc<span class="token punctuation">;</span>docker rm sig<span class="token operator">-</span>proc</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">docker</span> <span class="token expression">run <span class="token operator">--</span>name sig<span class="token operator">-</span>proc <span class="token operator">-</span>d registry<span class="token operator">/</span>sig<span class="token operator">-</span>proc<span class="token operator">:</span>v1 <span class="token operator">/</span>c<span class="token operator">-</span>init<span class="token operator">-</span>nosig</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">docker</span> <span class="token expression">exec <span class="token operator">-</span>it sig<span class="token operator">-</span>proc bash</span></span>
<span class="token punctuation">[</span>root@<span class="token number">5</span>d3d42a031b1 <span class="token operator">/</span><span class="token punctuation">]</span># ps <span class="token operator">-</span>ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">48</span> <span class="token operator">?</span>        <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> <span class="token operator">/</span>c<span class="token operator">-</span>init<span class="token operator">-</span>nosig
root         <span class="token number">6</span>     <span class="token number">0</span>  <span class="token number">5</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">48</span> pts<span class="token operator">/</span><span class="token number">0</span>    <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> bash
root        <span class="token number">19</span>     <span class="token number">6</span>  <span class="token number">0</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">48</span> pts<span class="token operator">/</span><span class="token number">0</span>    <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> ps <span class="token operator">-</span>ef
<span class="token punctuation">[</span>root@<span class="token number">5</span>d3d42a031b1 <span class="token operator">/</span><span class="token punctuation">]</span># kill <span class="token number">1</span>
<span class="token punctuation">[</span>root@<span class="token number">5</span>d3d42a031b1 <span class="token operator">/</span><span class="token punctuation">]</span># kill <span class="token operator">-</span><span class="token number">9</span> <span class="token number">1</span>
<span class="token punctuation">[</span>root@<span class="token number">5</span>d3d42a031b1 <span class="token operator">/</span><span class="token punctuation">]</span># ps <span class="token operator">-</span>ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">48</span> <span class="token operator">?</span>        <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> <span class="token operator">/</span>c<span class="token operator">-</span>init<span class="token operator">-</span>nosig
root         <span class="token number">6</span>     <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">48</span> pts<span class="token operator">/</span><span class="token number">0</span>    <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> bash
root        <span class="token number">20</span>     <span class="token number">6</span>  <span class="token number">0</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">49</span> pts<span class="token operator">/</span><span class="token number">0</span>    <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> ps <span class="token operator">-</span>ef
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>是不是这样就可以得出结论---&quot;容器里的 1 号进程, 完全忽略了 SIGTERM 和 SIGKILL 信号了&quot; 呢? 先别着急, 再拿其他语言试试.</p> <p>接下来用 <strong>Golang 程序作为 1 号进程</strong>, 再在容器中执行 <code>kill -9 1</code>​ 和 <code>kill 1</code>​. 可以发现 <code>kill -9 1</code>​ 这个命令仍然不能杀死 1 号进程, 也就是说 SIGKILL 信号和之前的两个测试一样不起作用.</p> <p>**但是执行 **​<strong><strong>​<code>kill 1</code>​</strong></strong>​ ** 以后, SIGTERM 这个信号把 init 进程给杀了, 容器退出了. **</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code># cat <span class="token keyword">go</span><span class="token operator">-</span>init<span class="token punctuation">.</span><span class="token keyword">go</span>
<span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token punctuation">(</span>
       <span class="token string">&quot;fmt&quot;</span>
       <span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Start app\n&quot;</span><span class="token punctuation">)</span>
       time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># docker stop sig-proc;docker rm sig-proc</span>
<span class="token comment"># docker run --name sig-proc -d registry/sig-proc:v1 /go-init</span>
<span class="token comment"># docker exec -it sig-proc bash</span>
<span class="token punctuation">[</span>root@234a23aa597b /<span class="token punctuation">]</span><span class="token comment"># ps -ef</span>
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">1</span> 08:04 ?        00:00:00 /go-init
root        <span class="token number">10</span>     <span class="token number">0</span>  <span class="token number">9</span> 08:04 pts/0    00:00:00 <span class="token function">bash</span>
root        <span class="token number">23</span>    <span class="token number">10</span>  <span class="token number">0</span> 08:04 pts/0    00:00:00 <span class="token function">ps</span> <span class="token parameter variable">-ef</span>
<span class="token punctuation">[</span>root@234a23aa597b /<span class="token punctuation">]</span><span class="token comment"># kill -9 1</span>
<span class="token punctuation">[</span>root@234a23aa597b /<span class="token punctuation">]</span><span class="token comment"># kill 1</span>
<span class="token punctuation">[</span>root@234a23aa597b /<span class="token punctuation">]</span><span class="token comment"># [~]# docker ps</span>
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>对于这个测试结果, 你是不是反而觉得更加困惑了?</p> <p><strong>为什么使用不同程序, 结果就不一样呢</strong>? 接下来就看看 kill 命令下达之后, Linux 里究竟发生了什么事, 这里系统地梳理一下整个过程.</p> <p>在运行 <code>kill 1</code>​ 这个命令的时候, 希望把 SIGTERM 这个信号发送给 1 号进程, 就像下面图里的<strong>带箭头虚线</strong>.</p> <p>在 Linux 实现里, kill 命令调用了 <strong>kill() 的这个系统调用</strong>(所谓系统调用就是内核的调用接口)而进入到了内核函数 <strong>sys_kill</strong>(), 也就是下图里的<strong>实线箭头</strong>.</p> <p>而内核在决定把信号发送给 1 号进程的时候, 会调用 <strong>sig_task_ignored</strong>() 这个函数来做个判断, 这个判断有什么用呢? 它会决定内核在<strong>哪些情况下会把发送的这个信号给忽略掉</strong>. 如果信号被忽略了, 那么 init 进程就不能收到指令了.</p> <p>所以想要知道 init 进程为什么收到或者收不到信号, 都要去看看 **sig_task_ignored() 的这个内核函数的实现. **</p> <p><img src="/img/6b42b07720a1ae463ecf5cfbc23a22a3-20230731161430-uxgmxn9.png" alt="" title="sig_task_ignored() 内核函数实现示意图"></p> <p>‍</p> <p>在 sig_task_ignored() 这个函数中有三个 if{} 判断, 第一个和第三个 if{} 判断和本节的问题没有关系, 并且代码有注释, 就不讨论了. 重点来看第二个 if{}. 来分析一下, 在容器中执行 <code>kill 1</code>​ 或者 <code>kill -9 1</code>​ 的时候, 这第二个 if{} 里的三个子条件是否可以被满足呢?</p> <p>来看下面这串代码, 这里表示<mark><strong>一旦这三个子条件都被满足, 那么这个信号就不会发送给进程</strong></mark>​ **. **</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>kernel<span class="token operator">/</span>signal<span class="token punctuation">.</span>c
<span class="token keyword">static</span> bool <span class="token function">sig_task_ignored</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>t<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">,</span> bool force<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">void</span> __user <span class="token operator">*</span>handler<span class="token punctuation">;</span>
        handler <span class="token operator">=</span> <span class="token function">sig_handler</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* SIGKILL and SIGSTOP may not be sent to the global init */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">is_global_init</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sig_kernel_only</span><span class="token punctuation">(</span>sig<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> true<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>signal<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> SIGNAL_UNKILLABLE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            handler <span class="token operator">&lt;</span>mark<span class="token operator">&gt;</span> SIG_DFL <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>force <span class="token operator">&amp;&amp;</span> <span class="token function">sig_kernel_only</span><span class="token punctuation">(</span>sig<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> true<span class="token punctuation">;</span>
        <span class="token comment">/* Only allow kernel generated signals to this kthread */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> PF_KTHREAD<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                     <span class="token punctuation">(</span>handler <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> SIG_KTHREAD_KERNEL<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>force<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> true<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">sig_handler_ignored</span><span class="token punctuation">(</span>handler<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>接下来, 就逐一分析一下这三个子条件, 来说说这个 &quot; <strong>!(force &amp;&amp; sig_kernel_only(sig))</strong> &quot;.</p> <p>第一个条件里 force 的值, 对于同一个 Namespace 里发出的信号来说, 调用值是 0, 所以这个条件<strong>总是满足</strong>的.</p> <p>再来看一下第二个条件 &quot;<strong>handler == SIG_DFL</strong>&quot;, 第二个条件判断信号的 handler 是否是 SIG_DFL. 什么是 SIG_DFL 呢? <strong>对于每个信号, 用户进程如果不注册一个自己的 handler, 就会有一个系统缺省的 handler, 这个缺省的 handler 就叫作 SIG_DFL. ** 对于 SIGKILL, 前面介绍过它是特权信号, 是</strong>不允许被捕获<strong>的, 所以它的 handler 就一直是 SIG_DFL. 这第二个条件对 SIGKILL 来说</strong>总是满足**的. 对于 SIGTERM, 它是可以被捕获的. 也就是说如果用户不注册 handler, 那么这个条件对 SIGTERM 也是满足的.</p> <p>最后再来看一下第三个条件, &quot;t-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE&quot;, 这里的条件判断是这样的, <strong>进程必须是 SIGNAL_UNKILLABLE</strong> 的.</p> <p>这个 SIGNAL_UNKILLABLE flag 是在哪里置位的呢?</p> <p>可以参考下面的这段代码, 在每个 Namespace 的 init 进程建立的时候, 就会打上 <strong>SIGNAL_UNKILLABLE</strong> 这个标签, 也就是说<strong>只要是 1 号进程, 就会有这个 flag</strong>, 这个条件也是满足的.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>kernel<span class="token operator">/</span>fork<span class="token punctuation">.</span>c
                       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_child_reaper</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                <span class="token function">ns_of_pid</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token operator">-&gt;</span>child_reaper <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                p<span class="token operator">-&gt;</span>signal<span class="token operator">-&gt;</span>flags <span class="token operator">|=</span> SIGNAL_UNKILLABLE<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
<span class="token comment">/*
 * is_child_reaper returns true if the pid is the init process
 * of the current namespace. As this one could be checked before
 * pid_ns-&gt;child_reaper is assigned in copy_process, we check
 * with the pid number.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> bool <span class="token function">is_child_reaper</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pid</span> <span class="token operator">*</span>pid<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">return</span> pid<span class="token operator">-&gt;</span>numbers<span class="token punctuation">[</span>pid<span class="token operator">-&gt;</span>level<span class="token punctuation">]</span><span class="token punctuation">.</span>nr <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>可以看出来, 其实<strong>最关键的一点就是 <strong>​</strong>​<code>handler &lt;mark&gt; SIG_DFL</code>​</strong>​ **. <strong>​</strong>Linux 内核针对每个 Nnamespace 里的 init 进程, 把只有 default handler 的信号都给忽略了==**​ **. **</p> <p>如果自己注册了信号的 handler(应用程序注册信号 handler 被称作&quot;Catch the Signal&quot;), 那么这个信号 handler 就不再是 SIG_DFL. 即使是 init 进程在接收到 SIGTERM 之后也是可以退出的.</p> <p>不过, 由于 SIGKILL 是一个特例, 因为 SIGKILL 是不允许被注册用户 handler 的(还有一个不允许注册用户 handler 的信号是 SIGSTOP), 那么它只有 SIG_DFL handler.</p> <p><mark>**所以 init 进程是永远不能被 SIGKILL 所杀, 但是可以被 SIGTERM 杀死. **</mark></p> <p>说到这里, 该怎么证实这一点呢? 可以做下面两件事来验证.</p> <p>**第一件事, 可以查看 1 号进程状态中 SigCgt Bitmap. **</p> <p>可以看到, 在 Golang 程序里, 很多信号都注册了自己的 handler, 当然也包括了 SIGTERM(15), 也就是 bit 15. 而 C 程序里, 缺省状态下, 一个信号 handler 都没有注册; bash 程序里注册了两个 handler, bit 2 和 bit 17, 也就是 SIGINT 和 SIGCHLD, 但是没有注册 SIGTERM. 所以, C 程序和 bash 程序里 SIGTERM 的 handler 是 SIG_DFL(系统<strong>缺省</strong>行为), 那么它们就不能被 SIGTERM 所杀.</p> <p>具体可以看一下这段 /proc 系统的进程状态:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment">### golang init</span>
<span class="token comment"># cat /proc/1/status | grep -i SigCgt</span>
SigCgt:     fffffffe7fc1feff
<span class="token comment">### C init</span>
<span class="token comment"># cat /proc/1/status | grep -i SigCgt</span>
SigCgt:     0000000000000000
<span class="token comment">### bash init</span>
<span class="token comment"># cat /proc/1/status | grep -i SigCgt</span>
SigCgt:     0000000000010002
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>**第二件事, 给 C 程序注册一下 SIGTERM handler, 捕获 SIGTERM. **</p> <p>调用 signal() 系统调用注册 SIGTERM 的 handler, 在 handler 里主动退出, 再看看容器中 <code>kill 1</code>​ 的结果.</p> <p>这次就可以看到, **在进程状态的 SigCgt bitmap 里, bit 15 (SIGTERM) 已经置位了. 同时运行 **​<strong><strong>​<code>kill 1</code>​</strong></strong>​ ** 也可以把这个 C 程序的 init 进程给杀死了. **</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">sig_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signo<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>signo <span class="token operator">==</span> SIGTERM<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;received SIGTERM\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">signal</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">,</span> sig_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Process is sleeping\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># docker stop sig-proc;docker rm sig-proc</span>
<span class="token comment"># docker run --name sig-proc -d registry/sig-proc:v1 /c-init-sig</span>
<span class="token comment"># docker exec -it sig-proc bash</span>
<span class="token punctuation">[</span>root@043f4f717cb5 /<span class="token punctuation">]</span><span class="token comment"># ps -ef</span>
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> 09:05 ?        00:00:00 /c-init-sig
root         <span class="token number">6</span>     <span class="token number">0</span> <span class="token number">18</span> 09:06 pts/0    00:00:00 <span class="token function">bash</span>
root        <span class="token number">19</span>     <span class="token number">6</span>  <span class="token number">0</span> 09:06 pts/0    00:00:00 <span class="token function">ps</span> <span class="token parameter variable">-ef</span>
<span class="token punctuation">[</span>root@043f4f717cb5 /<span class="token punctuation">]</span><span class="token comment"># cat /proc/1/status | grep SigCgt</span>
SigCgt: 0000000000004000
<span class="token punctuation">[</span>root@043f4f717cb5 /<span class="token punctuation">]</span><span class="token comment"># kill 1</span>
<span class="token comment"># docker ps</span>
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>到这里可以确定这两点:</p> <ul><li><p><code>kill -9 1</code>​ 在容器中是不工作的, 内核阻止了 1 号进程对 SIGKILL 特权信号的响应.</p></li> <li><p><code>kill 1</code>​ 分两种情况, 如果 1 号进程没有注册 SIGTERM 的 handler, 那么对 SIGTERM 信号也不响应, 如果注册了 handler, 那么就可以响应 SIGTERM 信号.</p></li></ul> <h5 id="_4-重点总结-2"><a href="#_4-重点总结-2" class="header-anchor">#</a> 4.重点总结</h5> <p>这一讲主要讲了 init 进程. 围绕这个知识点, 提出了一个真实发生的问题: &quot;为什么我在容器中不能 kill 1 号进程?&quot;.</p> <p>想要解决这个问题, 需要掌握两个基本概念.</p> <p>第一个概念是 Linux 1 号进程. **它是第一个用户态的进程. 它直接或者间接创建了 Namespace 中的其他进程. **</p> <p>第二个概念是 Linux 信号. Linux 有 31 个基本信号, 进程在处理大部分信号时有三个选择: **忽略, 捕获和缺省行为. 其中两个特权信号 SIGKILL 和 SIGSTOP 不能被忽略或者捕获. **</p> <p>只知道基本概念还不行, 还要去解决问题. 本节尝试了用 bash, C 语言还有 Golang 程序作为容器 init 进程, 发现它们对 kill 1 的反应是不同的. 因为信号的最终处理都是在 Linux 内核中进行的, 因此需要对 Linux 内核代码进行分析.</p> <p>容器里 1 号进程对信号处理的两个要点, 这也是这一讲里需要记住的两句话:</p> <ul><li>**在容器中, 1 号进程永远不会响应 SIGKILL 和 SIGSTOP 这两个特权信号; **</li> <li>**对于其他的信号, 如果用户自己注册了 handler, 1 号进程可以响应. **</li></ul> <h4 id="_03-理解进程-2-为什么我的容器里有这么多僵尸进程"><a href="#_03-理解进程-2-为什么我的容器里有这么多僵尸进程" class="header-anchor">#</a> 03｜理解进程(2):为什么我的容器里有这么多僵尸进程?</h4> <p>本节来看看容器里为什么会产生僵尸进程, 然后去分析如何怎么解决. 通过这一讲, 你就会对僵尸进程的产生原理有一个清晰的认识, 也会更深入地理解容器 init 进程的特性.</p> <h5 id="_1-问题再现-2"><a href="#_1-问题再现-2" class="header-anchor">#</a> 1.问题再现</h5> <p>平时用容器的时候, 有的人会发现, 自己的容器运行久了之后, 运行 ps 命令会看到一些进程, 进程名后面加了 <code>&lt;defunct&gt;</code>​ 标识. 那么你自然会有这样的疑问, 这些是什么进程?</p> <p>可以自己做个容器镜像来模拟一下, 先下载这个例子, 运行 <code>make image</code>​ 之后, 再启动容器. 在容器里可以看到, 1 号进程 fork 出 1000 个子进程. 当这些子进程<strong>运行结束</strong>后, 它们的进程名字后面都加了标识.</p> <p>从它们的 <strong>Z stat(进程状态)</strong> 中可以知道, 这些都是<strong>僵尸进程</strong>(Zombie Process). 运行 top 命令, 也可以看到输出的内容显示有 <code>1000 zombie</code>​ 进程.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># docker run --name zombie-proc -d registry/zombie-proc:v1</span>
02dec161a9e8b18922bd3599b922dbd087a2ad60c9b34afccde7c91a463bde8a
<span class="token comment"># docker exec -it zombie-proc bash</span>
<span class="token comment"># ps aux</span>
<span class="token environment constant">USER</span>       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         <span class="token number">1</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">4324</span>  <span class="token number">1436</span> ?        Ss   01:23   <span class="token number">0</span>:00 /app-test <span class="token number">1000</span>
root         <span class="token number">6</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root         <span class="token number">7</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root         <span class="token number">8</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root         <span class="token number">9</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root        <span class="token number">10</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
…
root       <span class="token number">999</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root      <span class="token number">1000</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root      <span class="token number">1001</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root      <span class="token number">1002</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root      <span class="token number">1003</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root      <span class="token number">1004</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root      <span class="token number">1005</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root      <span class="token number">1023</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>  <span class="token number">12020</span>  <span class="token number">3392</span> pts/0    Ss   01:39   <span class="token number">0</span>:00 <span class="token function">bash</span>
<span class="token comment"># top</span>
<span class="token function">top</span> - 02:18:57 up <span class="token number">31</span> days, <span class="token number">15</span>:17,  <span class="token number">0</span> users,  load average: <span class="token number">0.00</span>, <span class="token number">0.01</span>, <span class="token number">0.00</span>
Tasks: <span class="token number">1003</span> total,   <span class="token number">1</span> running,   <span class="token number">2</span> sleeping,   <span class="token number">0</span> stopped, <span class="token number">1000</span> zombie
<span class="token punctuation">..</span>.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>那么问题来了, 什么是僵尸进程? 它们是怎么产生的? 僵尸进程太多会导致什么问题? 想要回答这些问题, 就要从进程状态的源头学习, 看看<strong>僵尸进程到底处于进程整个生命周期里的哪一环</strong>.</p> <h5 id="_2-知识详解-2"><a href="#_2-知识详解-2" class="header-anchor">#</a> 2.知识详解</h5> <h6 id="_1-linux的进程状态"><a href="#_1-linux的进程状态" class="header-anchor">#</a> (1)Linux的进程状态</h6> <p>无论进程还是线程, 在 Linux 内核里其实都是用 <mark><strong>task_struct{}</strong></mark>​ ** 这个结构<strong>来表示的. 它其实就是</strong>任务(task), 也就是 Linux 里基本的调度单位**. 为了方便讲解, 在这里暂且称它为进程.</p> <p>那一个进程从创建(fork)到退出(exit), 这个过程中的状态转化还是很简单的.</p> <p>下面这个图是《Linux Kernel Development》这本书里的 Linux 进程状态转化图. 从这张图中可以看出来, 在进程 &quot;活着&quot; 的时候就只有两个状态: <strong>运行态</strong>(TASK_RUNNING)和<strong>睡眠态</strong>(TASK_INTERRUPTIBLE, TASK_UNINTERRUPTIBLE).</p> <p><img src="/img/19ff7857b6ab8570f638ed5378840ec3-20230731161430-gcgqu3u.png" alt=""></p> <p>那运行态和睡眠态这两种状态分别是什么意思呢?</p> <p><strong>运行态</strong>的意思是, 无论进程是正在运行中(也就是获得了 CPU 资源), 还是进程在 run queue 队列里随时可以运行, 都处于这个状态. 想要查看进程是不是处于运行态, 其实也很简单, 比如使用 ps 命令, 可以看到处于这个<strong>状态的进程显示的是 R stat</strong>.</p> <p><strong>睡眠态</strong>是指进程需要等待某个资源而进入的状态, 要等待的资源可以是一个信号量(Semaphore), 或者是磁盘 I/O, 这个状态的进程会被放入到 wait queue 队列里. 这个睡眠态具体还包括两个子状态: 一个是<strong>可以被打断</strong>的(TASK_INTERRUPTIBLE), 用 ps 查看到的进程, 显示为 <strong>S stat</strong>. 还有一个是<strong>不可被打断</strong>的(TASK_UNINTERRUPTIBLE), 用 ps 查看进程, 就显示为 <strong>D stat</strong>.</p> <p>这两个子状态, 在后面的课程里碰到新的问题时, 会再做详细介绍, 这里只要知道这些就行了.</p> <p>除了上面进程在活的时候的两个状态, 进程在调用 <strong>do_exit</strong>() 退出的时候, 还有两个状态.</p> <p>一个是 <strong>EXIT_DEAD</strong>, 也就是进程在真正结束退出的那一瞬间的状态; 第二个是 <mark><strong>EXIT_ZOMBIE 状态, 这是进程在 EXIT_DEAD 前的一个状态, 而僵尸进程就是处于这个状态中</strong></mark>​ **. **</p> <h6 id="_2-限制容器中进程数目"><a href="#_2-限制容器中进程数目" class="header-anchor">#</a> (2)限制容器中进程数目</h6> <p>理解了 Linux 进程状态之后, 还需要知道, 在 Linux 系统中<strong>怎么限制进程数目</strong>. 因为弄清楚这个问题, 才能更深入地去理解僵尸进程的危害.</p> <p>一台 Linux 机器上的<strong>进程总数目是有限制</strong>的. 如果超过这个最大值, 那么系统就无法创建出新的进程了, 比如想 SSH 登录到这台机器上就不行了. 这个最大值可以在  <strong>/proc/sys/kernel/pid_max</strong> 这个参数中看到.</p> <p>Linux 内核在初始化系统的时候, 会根据机器 CPU 的数目来设置 pid_max 的值. 比如如果机器中 CPU 数目小于等于 32, 那么 pid_max 就会被设置为 <strong>32768</strong>(32K); 如果机器中的 CPU 数目大于 32, 那么 pid_max 就被设置为 <strong>N*1204</strong> (N 就是 CPU 数目).</p> <p>对于 Linux 系统而言, <strong>容器就是一组进程的集合. 如果容器中的应用创建过多的进程或者出现 bug, 就会产生类似 fork bomb 的行为</strong>. 这个 fork bomb 就是指在计算机中, 通过不断建立新进程来消耗系统中的进程资源, 它是一种黑客攻击方式. 这样容器中的进程数就会把整个节点的可用进程总数给消耗完. 这样不但会使同一个节点上的其他容器无法工作, 还会让<strong>宿主机本身</strong>也无法工作. 所以<mark><strong>对于每个容器来说, 都需要限制它的最大进程数目, 而这个功能由 pids Cgroup 这个子系统来完成</strong></mark>.</p> <p>而这个功能的实现方法是这样的: <mark><strong>pids Cgroup 通过 Cgroup 文件系统的方式向用户提供操作接口, 一般它的 Cgroup 文件系统挂载点在 /sys/fs/cgroup/pids. 在一个容器建立之后, 创建容器的服务会在 /sys/fs/cgroup/pids 下建立一个子目录, 就是一个控制组, 控制组里最关键的一个文件就是 pids.max. 可以向这个文件写入数值, 而这个值就是这个容器中允许的最大进程数目</strong></mark>​ <strong>.</strong></p> <p>对这个值做好限制, 容器就不会因为创建出过多进程而影响到其他容器和宿主机了. 接下来就实际上手试一试.</p> <p>下面是对一个 Docker 容器的 pids Cgroup 的操作, 可以跟着操作一下.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># pwd</span>
/sys/fs/cgroup/pids
<span class="token comment"># df ./</span>
Filesystem     1K-blocks  Used Available Use% Mounted on
cgroup                 <span class="token number">0</span>     <span class="token number">0</span>         <span class="token number">0</span>    - /sys/fs/cgroup/pids
<span class="token comment"># docker ps</span>
CONTAINER ID        IMAGE                      COMMAND                  CREATED             STATUS              PORTS               NAMES
7ecd3aa7fdc1        registry/zombie-proc:v1   <span class="token string">&quot;/app-test 1000&quot;</span>         <span class="token number">37</span> hours ago        Up <span class="token number">37</span> hours                             frosty_yalow
<span class="token comment"># pwd</span>
/sys/fs/cgroup/pids/system.slice/docker-7ecd3aa7fdc15a1e183813b1899d5d939beafb11833ad6c8b0432536e5b9871c.scope
<span class="token comment"># ls</span>
cgroup.clone_children  cgroup.procs  notify_on_release  pids.current  pids.events  pids.max  tasks
<span class="token comment"># echo 1002 &gt; pids.max</span>
<span class="token comment"># cat pids.max</span>
<span class="token number">1002</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>在前面 Linux 进程状态的介绍可知僵尸进程是 Linux 进程<strong>退出状态</strong>的一种. 从内核进程的 do_exit() 函数也可以看到, 这时候<strong>进程 task_struct 里的 mm/shm/sem/files 等文件资源都已经释放了, 只留下了一个 stask_struct instance 空壳</strong>.</p> <p>就像下面这段代码显示的一样, 从进程对应的 <code>/proc/&lt;pid&gt;</code>​ 文件目录下, 也可以看出来, 对应的资源都已经没有了.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># cat /proc/6/cmdline</span>
<span class="token comment"># cat /proc/6/smaps</span>
<span class="token comment"># cat /proc/6/maps</span>
<span class="token comment"># ls /proc/6/fd</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>并且这个进程也已经<strong>不响应任何的信号</strong>了, 无论 SIGTERM(15) 还是 SIGKILL(9). 例如上面 pid 6 的僵尸进程, 这两个信号都已经被响应了.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># kill -15 6</span>
<span class="token comment"># kill -9 6</span>
<span class="token comment"># ps -ef | grep 6</span>
root         <span class="token number">6</span>     <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">13</span>:59 ?        00:00:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>当多个容器运行在同一个宿主机上的时候, <strong>为了避免一个容器消耗完整个宿主机进程号资源, 会配置 pids Cgroup 来限制每个容器的最大进程数目</strong>. 也就是说进程数目在每个容器中也是有限的, 是一种很宝贵的资源.</p> <p>既然进程号资源在宿主机上是有限的, 显然残留的僵尸进程多了以后, 给系统带来最大问题就是它占用了进程号. <mark><strong>这就意味着, 残留的僵尸进程在容器里仍然占据着进程号资源, 很有可能会导致新的进程不能运转</strong></mark>. ** **</p> <p>这里再次借用开头的那个例子, 也就是一个产生了 1000 个僵尸进程的容器, 来理解一下这个例子中进程数的上限. 这里 1 个 init 进程 + 1000 个僵尸进程 + 1 个 bash 进程, 总共就是 1002 个进程.</p> <p>如果 pids Cgroup 也限制了这个容器的最大进程号的数量, 限制为 1002 的话, 在 pids Cgroup 里可以看到, <code>pids.current == pids.max</code>​, 也就是已经达到了容器进程号数的上限.</p> <p>这时候, 如果在容器里想再启动一个进程, 例如运行一下 ls 命令, 就会看到 <code>Resource temporarily unavailable</code>​ 的错误消息. 已经退出的无用进程, 却阻碍了有用进程的启动, 显然这样是不合理的.</p> <p>具体代码如下:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment">### On host</span>
<span class="token comment"># docker ps</span>
CONTAINER ID        IMAGE                      COMMAND             CREATED             STATUS              PORTS               NAMES
09e6e8e16346        registry/zombie-proc:v1   <span class="token string">&quot;/app-test 1000&quot;</span>    <span class="token number">29</span> minutes ago      Up <span class="token number">29</span> minutes                           peaceful_ritchie
<span class="token comment"># pwd</span>
/sys/fs/cgroup/pids/system.slice/docker-09e6e8e1634612580a03dd3496d2efed2cf2a510b9688160b414ce1d1ea3e4ae.scope
<span class="token comment"># cat pids.max</span>
<span class="token number">1002</span>
<span class="token comment"># cat pids.current</span>
<span class="token number">1002</span>
<span class="token comment">### On Container</span>
<span class="token punctuation">[</span>root@09e6e8e16346 /<span class="token punctuation">]</span><span class="token comment"># ls</span>
bash: fork: retry: Resource temporarily unavailable
bash: fork: retry: Resource temporarily unavailable
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>所以, 接下来还要看看这些僵尸进程到底是怎么产生的. 因为只有理解它的产生机制, 才能想明白怎么避免僵尸进程的出现.</p> <p>先看一下刚才模拟僵尸进程的那段小程序. 这段程序里, <mark><strong>父进程在创建完子进程之后就不管了, 这就是造成子进程变成僵尸进程的原因</strong></mark>​ **. **</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
       <span class="token keyword">int</span> i<span class="token punctuation">;</span>
       <span class="token keyword">int</span> total<span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              total <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
              total <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;To create %d processes\n&quot;</span><span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
              <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Child =&gt; PPID: %d PID: %d\n&quot;</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                             <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                      <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Child process exits\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                      <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Parent created child %d\n&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Unable to create child process. %d\n&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                      <span class="token keyword">break</span><span class="token punctuation">;</span>
              <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Paraent is sleeping\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p>前面通过分析, 发现<strong>子进程变成僵尸进程的原因在于父进程 &quot;不负责&quot;</strong> , 那找到原因后, 再想想如何来解决.</p> <p>其实解决思路很好理解, 就好像熊孩子犯了事儿, 要去找他家长来管教, 那子进程在容器里 &quot;赖着不走&quot;, 就需要<strong>让父进程出面处理</strong>了. 所以, 在 Linux 中的进程退出之后, 如果<mark><strong>进入僵尸状态, 就需要父进程调用 wait() 这个系统调用, 去回收僵尸进程的最后的那些系统资源, 比如进程号资源</strong></mark>.</p> <p>那么在刚才那段代码里, 主进程进入 sleep(100) 之前, 加上<strong>一段 wait() 函数调用</strong>, 就<strong>不会出现僵尸进程</strong>的残留了.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> status<span class="token punctuation">;</span>
    <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>而容器中所有进程的最终父进程, 就是所说的 init 进程, 由它负责生成容器中的所有其他进程. 因此<strong>容器的 init 进程有责任回收容器中的所有僵尸进程</strong>.</p> <p>前面知道了 wait() 系统调用可以回收僵尸进程, 但是 wait() 系统调用有一个问题, 需要你注意. <strong>wait() 系统调用是一个阻塞的调用, 也就是说如果没有子进程是僵尸进程的话, 这个调用就一直不会返回, 那么整个进程就会被阻塞住, 而不能去做别的事了</strong>.</p> <p>不过这也没有关系, 还有另一个方法处理. Linux 还提供了一个类似的系统调用 <strong>waitpid()</strong> , 这个调用的参数更多. 其中就有一个参数 WNOHANG, 它的含义就是, <strong>如果在调用的时候没有僵尸进程, 那么函数就马上返回了</strong>, 而不会像 wait() 调用那样一直等待在那里.</p> <p>比如社区的一个容器 init 项目 tini. 在这个例子中, 它的主进程里, 就是不断在调用带 WNOHANG 参数的 waitpid(), 通过这个方式<strong>清理容器中所有的僵尸进程</strong>.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">reap_zombies</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">pid_t</span> child_pid<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> child_exitcode_ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">pid_t</span> current_pid<span class="token punctuation">;</span>
        <span class="token keyword">int</span> current_status<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                current_pid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>current_status<span class="token punctuation">,</span> WNOHANG<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">switch</span> <span class="token punctuation">(</span>current_pid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">case</span> <span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> ECHILD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                        <span class="token function">PRINT_TRACE</span><span class="token punctuation">(</span><span class="token string">&quot;No child to wait&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                                <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h5 id="_3-重点总结"><a href="#_3-重点总结" class="header-anchor">#</a> 3.重点总结</h5> <p>本节讨论的问题是容器中的僵尸进程. 首先先用代码来模拟了这个情况, 还原了在一个容器中大量的僵尸进程是如何产生的. 为了理解它的产生原理和危害, 先要掌握两个知识点:</p> <ol><li>**Linux 进程状态中, 僵尸进程处于 EXIT_ZOMBIE 这个状态; **</li> <li><strong>容器需要对最大进程数做限制.</strong>  具体方法是向 Cgroup 中 <strong>pids.max</strong> 这个文件写入数值(这个值就是这个容器中允许的最大进程数目).</li></ol> <p>掌握了基本概念之后, 找到了僵尸进程的产生原因就是<strong>父进程在创建完子进程之后就不管了</strong>. 所以<mark><strong>需要父进程调用 wait() 或者 waitpid() 系统调用来避免僵尸进程产生</strong></mark>.</p> <p>本节只要记住下面三个主要的知识点就可以了:</p> <ul><li><strong>每一个 Linux 进程在退出的时候都会进入一个僵尸状态(EXIT_ZOMBIE);</strong></li> <li>**僵尸进程如果不清理, 就会消耗系统中的进程数资源, 最坏的情况是导致新的进程无法启动; **</li> <li>**僵尸进程一定需要父进程调用 wait() 或者 waitpid() 系统调用来清理, 这也是容器中 init 进程必须具备的一个功能. **</li></ul> <h4 id="_04-理解进程-3-为什么我在容器中的进程被强制杀死了"><a href="#_04-理解进程-3-为什么我在容器中的进程被强制杀死了" class="header-anchor">#</a> 04 | 理解进程(3):为什么我在容器中的进程被强制杀死了?</h4> <p>本节来讲容器中 init 进程的最后一讲, 为什么容器中的进程被强制杀死了. 理解了这个问题, 能够帮助你更好地管理进程, 让容器中的进程可以 <strong>graceful shutdown</strong>. 先说说为什么进程管理中做到这点很重要. 在实际生产环境中, 有不少应用在退出的时候需要做一些<strong>清理工作</strong>, 比如清理一些远端的链接, 或者是清除一些本地的临时数据. 这样的清理工作, 可以尽可能避免远端或者本地的错误发生, 比如减少丢包等问题的出现. 而这些退出清理的工作, 通常是在 SIGTERM 这个信号用户注册的 handler 里进行的.</p> <p>但是如果<strong>进程收到了 SIGKILL, 那应用程序就没机会执行这些清理工作</strong>了. 这就意味着, 一旦进程不能 graceful shutdown, 就会增加应用的出错率.</p> <p>所以接下来来重现一下, 进程在容器退出时都发生了什么.</p> <h5 id="_1-场景再现"><a href="#_1-场景再现" class="header-anchor">#</a> 1.场景再现</h5> <p>在容器平台上, 想要停止一个容器, 无论是在 Kubernetes 中去删除一个 pod, 或者用 Docker 停止一个容器, 最后都会用到 <strong>Containerd</strong> 这个服务. 而 Containerd 在停止容器的时候, <strong>就会向容器的 init 进程发送一个 SIGTERM 信号</strong>.</p> <p>可以发现, 在 init 进程退出之后, 容器内的其他进程也都立刻退出了. 不过不同的是, <mark><strong>init 进程收到的是 SIGTERM 信号, 而其他进程收到的是 SIGKILL 信号</strong></mark>. 前面提到过 SIGKILL 信号是<strong>不能被捕获</strong>的(catch)的, 也就是用户不能注册自己的 handler, 而 SIGTERM 信号却允许用户注册自己的 handler, 这样的话差别就很大了.</p> <p>那么就<strong>看看当容器退出的时候, 如何才能让容器中的进程都收到 SIGTERM 信号, 而不是 SIGKILL 信号</strong>.</p> <p>延续前面处理问题的思路, 同样可以运行一个简单的容器, 来重现这个问题, 用这里的代码执行一下 <code>make image</code>​, 然后用 Docker 启动这个容器镜像.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> fwd_sig registry/fwd_sig:v1 /c-init-sig
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>你会发现, 在用 <code>docker stop</code>​ 停止这个容器的时候, 如果用 <strong>strace</strong> 工具来监控, 就能看到容器里的 init 进程和另外一个进程收到的信号情况.</p> <p>在下面的例子里, 进程号为 15909 的就是容器里的 init 进程, 而进程号为 15959 的是容器里另外一个进程.</p> <p>在命令输出中可以看到, **init 进程(15909)收到的是 SIGTERM 信号, 而另外一个进程(15959)收到的果然是 SIGKILL 信号. **</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># ps -ef | grep c-init-sig</span>
root     <span class="token number">15857</span> <span class="token number">14391</span>  <span class="token number">0</span> 06:23 pts/0    00:00:00 <span class="token function">docker</span> run <span class="token parameter variable">-it</span> registry/fwd_sig:v1 /c-init-sig
root     <span class="token number">15909</span> <span class="token number">15879</span>  <span class="token number">0</span> 06:23 pts/0    00:00:00 /c-init-sig
root     <span class="token number">15959</span> <span class="token number">15909</span>  <span class="token number">0</span> 06:23 pts/0    00:00:00 /c-init-sig
root     <span class="token number">16046</span> <span class="token number">14607</span>  <span class="token number">0</span> 06:23 pts/3    00:00:00 <span class="token function">grep</span> <span class="token parameter variable">--color</span><span class="token operator">=</span>auto c-init-sig
<span class="token comment"># strace -p 15909</span>
strace: Process <span class="token number">15909</span> attached
restart_syscall<span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token punctuation">..</span>. resuming interrupted <span class="token builtin class-name">read</span> <span class="token punctuation">..</span>.<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=</span> ? ERESTART_RESTARTBLOCK <span class="token punctuation">(</span>Interrupted by signal<span class="token punctuation">)</span>
--- SIGTERM <span class="token punctuation">{</span>si_signo<span class="token operator">=</span>SIGTERM, <span class="token assign-left variable">si_code</span><span class="token operator">=</span>SI_USER, <span class="token assign-left variable">si_pid</span><span class="token operator">=</span><span class="token number">0</span>, <span class="token assign-left variable">si_uid</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">}</span> ---
write<span class="token punctuation">(</span><span class="token number">1</span>, <span class="token string">&quot;received SIGTERM<span class="token entity" title="\n">\n</span>&quot;</span>, <span class="token number">17</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token number">17</span>
exit_group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                           <span class="token operator">=</span> ?
+++ exited with <span class="token number">0</span> +++
<span class="token comment"># strace -p 15959</span>
strace: Process <span class="token number">15959</span> attached
restart_syscall<span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token punctuation">..</span>. resuming interrupted <span class="token builtin class-name">read</span> <span class="token punctuation">..</span>.<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=</span> ?
+++ killed by SIGKILL +++
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h5 id="_2-知识详解-信号的两个系统调用"><a href="#_2-知识详解-信号的两个系统调用" class="header-anchor">#</a> 2.知识详解:信号的两个系统调用</h5> <p>想要理解刚才的例子, 就需要搞懂信号背后的两个系统调用, 它们分别是 <strong>kill() 系统调用和 signal() 系统调用</strong>.</p> <p>这里可以结合前面讲过的信号来理解这两个系统调用. 在容器 init 进程的第一讲里介绍过信号的基本概念了, **信号就是 Linux 进程收到的一个通知. ** 本节还会再举个使用函数的例子, 帮助你进一步理解进程是如何实现 graceful shutdown 的.</p> <p>进程对信号的处理其实就包括两个问题, <mark><strong>一个是进程如何发送信号, 另一个是进程收到信号后如何处理</strong></mark>​ **. **</p> <p>在 Linux 中发送信号的系统调用是 kill(), 之前很多例子里面用的命令 <code>kill</code>​, 它内部的实现就是<strong>调用了 kill() 这个函数</strong>.</p> <p>下面是 Linux Programmer’s Manual 里对 kill() 函数的定义.</p> <p>这个函数有两个参数, 一个是 <code>sig</code>​, 代表需要发送<strong>哪个信号</strong>, 比如 sig 的值是 15 的话, 就是指发送 SIGTERM; 另一个参数是 <code>pid</code>​, 也就是指信号需要发送给<strong>哪个进程</strong>, 比如值是 1 的话, 就是指发送给进程号是 1 的进程.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>NAME
       kill <span class="token operator">-</span> send signal to a process
SYNOPSIS
       <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
       <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
       <span class="token keyword">int</span> <span class="token function">kill</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>知道了发送信号的系统调用之后, 再来看另一个系统调用, 也就是 <strong>signal()</strong>  系统调用这个函数, 它可以<strong>给信号注册 handler</strong>.</p> <p>下面是 signal() 在 Linux Programmer’s Manual 里的定义, 参数 <code>signum</code> 也就是信号的编号, 例如数值 15, 就是信号 SIGTERM; 参数 <code>handler</code> 是一个函数指针参数, 用来注册用户的信号 handler.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>NAME
       signal <span class="token operator">-</span> ANSI C signal handling
SYNOPSIS
       <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
       <span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">sighandler_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token class-name">sighandler_t</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token class-name">sighandler_t</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在容器 init 进程的第一讲里**学过进程对每种信号的处理, 包括三个选择: 调用系统缺省行为, 捕获, 忽略. ** 而这里的选择, 其实就是程序中如何去调用 signal() 这个系统调用.</p> <p>第一个选择就是<strong>缺省</strong>, 如果在代码中对某个信号, 比如 SIGTERM 信号, 不做任何 signal() 相关的系统调用, 那么在进程运行的时候, 如果接收到信号 SIGTERM, <strong>进程就会执行内核中 SIGTERM 信号的缺省代码</strong>. 对于 SIGTERM 这个信号来说, 它的<strong>缺省行为就是进程退出</strong>(terminate). 内核中对不同的信号有不同的缺省行为, 一般会采用<strong>退出</strong>(terminate), <strong>暂停</strong>(stop), <strong>忽略</strong>(ignore)这三种行为中的一种.</p> <p>那第二个选择<strong>捕获</strong>又是什么意思呢? 捕获指的就是<strong>在代码中为某个信号, 调用 signal() 注册自己的 handler. 这样进程在运行的时候, 一旦接收到信号, 就不会再去执行内核中的缺省代码, 而是会执行通过 signal() 注册的 handler</strong>.</p> <p>比如下面这段代码, 为 SIGTERM 这个信号注册了一个 handler, 在 handler 里只是做了一个打印操作. 那么这个程序在运行的时候, 如果收到 SIGTERM 信号, 它就<strong>不会退出</strong>了, 而是只在屏幕上显示出 &quot;received SIGTERM&quot;.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">sig_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signo<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>signo <span class="token operator">==</span> SIGTERM<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;received SIGTERM\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">signal</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">,</span> sig_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>再来看看第三个选择, 如果要让进程 &quot;<strong>忽略</strong>&quot; 一个信号, 就要<strong>通过 signal() 这个系统调用, 为这个信号注册一个特殊的 handler</strong>, 也就是 <code>SIG_IGN</code>​.</p> <p>比如下面的这段代码, 就是为 SIGTERM 这个信号注册 <code>SIG_IGN</code>​. 这样操作的效果, 就是在程序运行的时候, <strong>如果收到 SIGTERM 信号, 程序既不会退出, 也不会在屏幕上输出 log, 而是什么反应也没有, 就像完全没有收到这个信号一样</strong>.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">signal</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">,</span> SIG_IGN<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>好了, 通过讲解 signal() 这个系统调用, 帮助你回顾了信号处理的三个选择: <strong>缺省行为, 捕获和忽略</strong>.</p> <p>这里还想要提醒一点, <mark><strong>SIGKILL 和 SIGSTOP 信号是两个特权信号, 它们不可以被捕获和忽略</strong></mark>​ <strong>, 这个特点也反映在 signal() 调用上. 所以这两个信号一定会走缺省行为的逻辑, 这个进程就一定会被删除.</strong></p> <p>可以运行下面的这段代码, 如果用 signal() 为 SIGKILL 注册 handler, 那么它就会返回 SIG_ERR, 不允许做捕获操作.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">cat</span> <span class="token expression">reg_sigkill<span class="token punctuation">.</span>c</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">sighandler_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">sig_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signo<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>signo <span class="token operator">==</span> SIGKILL<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;received SIGKILL\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
            <span class="token class-name">sighandler_t</span> h_ret<span class="token punctuation">;</span>
            h_ret <span class="token operator">=</span> <span class="token function">signal</span><span class="token punctuation">(</span>SIGKILL<span class="token punctuation">,</span> sig_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>h_ret <span class="token operator">==</span> SIG_ERR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;SIG_ERR&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
# <span class="token punctuation">.</span><span class="token operator">/</span>reg_sigkill
SIG_ERR<span class="token operator">:</span> Invalid argument
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>最后用下面这段代码来做个小结. 这段代码<strong>用 signal() 对 SIGTERM 这个信号做了忽略, 捕获以及恢复它的缺省行为, 并且每一次都用 kill() 系统调用向进程自己发送 SIGTERM 信号, 这样做可以确认进程对 SIGTERM 信号的选择</strong>.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">sighandler_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">sig_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signo<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>signo <span class="token operator">==</span> SIGTERM<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;received SIGTERM\n\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// Set SIGTERM handler to default</span>
                <span class="token function">signal</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">,</span> SIG_DFL<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token comment">// Ignore SIGTERM, and send SIGTERM</span>
        <span class="token comment">// to process itself.</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">,</span> SIG_IGN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Ignore SIGTERM\n\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">kill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SIGTERM<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// Catch SIGERM, and send SIGTERM</span>
        <span class="token comment">// to process itself.</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">,</span> sig_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Catch SIGTERM\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">kill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SIGTERM<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">// Default SIGTERM. In sig_handler, it sets</span>
        <span class="token comment">// SIGTERM handler back to default one.</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Default SIGTERM\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">kill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SIGTERM<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>一起来总结一下刚才讲的两个系统调用:</p> <p>先说说 <strong>kill()</strong>  这个系统调用, 它其实很简单, 输入两个参数: 进程号和信号, 就把特定的信号发送给指定的进程了.</p> <p>再说说 <strong>signal()</strong>  这个调用, 它决定了进程收到特定的信号如何来处理, SIG_DFL 参数把对应信号恢复为缺省 handler, 也可以用自定义的函数作为 handler, 或者用 SIG_IGN 参数让进程忽略信号. 对于 <strong>SIGKILL</strong> 信号, 如果调用 signal() 函数, 为它注册自定义的 handler, 系统就会拒绝.</p> <h5 id="_3-解决问题"><a href="#_3-解决问题" class="header-anchor">#</a> 3.解决问题</h5> <p>学习了 kill() 和 signal() 这个两个信号相关的系统调用之后, 再回到本节最初的问题上, <strong>为什么在停止一个容器的时候, 容器 init 进程收到的 SIGTERM 信号, 而容器中其他进程却会收到 SIGKILL 信号呢</strong>?</p> <p>当 Linux 进程收到 SIGTERM 信号并且使进程退出, 这时 Linux 内核对处理进程退出的入口点就是 <strong>do_exit()</strong>  函数, do_exit() 函数中会<strong>释放进程的相关资源, 比如内存, 文件句柄, 信号量</strong>等等.</p> <p>在做完这些工作之后, 它会调用一个 <strong>exit_notify()</strong>  函数, 用来<strong>通知和这个进程相关的父子进程</strong>等.</p> <p>对于容器来说, 还要<strong>考虑 Pid Namespace 里的其他进程</strong>. 这里调用的就是 <strong>zap_pid_ns_processes()</strong>  这个函数, 而在这个函数中, 如果<mark><strong>是处于退出状态的 init 进程, 它会向 Namespace 中的其他进程都发送一个 SIGKILL 信号</strong></mark>.</p> <p>整个流程如下图所示.</p> <p><img src="/img/919c1923e68406ec62be8bb089495c1d-20230731161430-jjhc05p.png" alt=""></p> <p>可以看一下, 内核代码是这样的.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/**
 * The last thread in the cgroup-init thread group is terminating.
 * Find remaining pid_ts in the namespace, signal and wait for them
 * to exit.
 *
 * Note:  This signals each threads in the namespace - even those that
 *        belong to the same thread group, To avoid this, we would have
 *        to walk the entire tasklist looking a processes in this
 *        namespace, but that could be unnecessarily expensive if the
 *        pid namespace has just a few processes. Or we need to
 *        maintain a tasklist for each pid namespace.
 *
 */</span>
<span class="token function">rcu_read_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">read_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tasklist_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
nr <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token function">idr_for_each_entry_continue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid_ns<span class="token operator">-&gt;</span>idr<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> nr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        task <span class="token operator">=</span> <span class="token function">pid_task</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> PIDTYPE_PID<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">__fatal_signal_pending</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">group_send_sig_info</span><span class="token punctuation">(</span>SIGKILL<span class="token punctuation">,</span> SEND_SIG_PRIV<span class="token punctuation">,</span> task<span class="token punctuation">,</span> PIDTYPE_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>说到这里, 也就明白为什么<strong>容器 init 进程收到的 SIGTERM 信号, 而容器中其他进程却会收到 SIGKILL 信号</strong>了. 前面讲过, SIGKILL 是个<strong>特权信号</strong>(特权信号是 Linux <strong>为 kernel 和超级用户去删除任意进程所保留的, 不能被忽略也不能被捕获</strong>).</p> <p>**所以进程收到这个信号后, 就立刻退出了, 没有机会调用一些释放资源的 handler 之后, 再做退出动作. ** 而 SIGTERM 是可以被捕获的, 用户是可以注册自己的 handler 的, 从自己的 handler 我们可以做一些 graceful shutdown 的操作.</p> <p>因此容器中的程序在 stop container 的时候, 我们<strong>更希望进程收到 SIGTERM 信号而不是 SIGKILL 信号</strong>. 那在容器被停止的时候, 该怎么做才能<strong>让容器中的普通进程收到 SIGTERM 信号</strong>呢?</p> <p>你可能已经想到了, <mark><strong>就是让容器 init 进程来转发 SIGTERM 信号</strong></mark>. 的确是这样, 比如 Docker Container 里使用的 tini 作为 init 进程, tini 的代码中就会<strong>调用 sigtimedwait()</strong>  这个函数来查看自己收到的信号, 然后调用 kill() 把信号发给子进程.</p> <p>举个具体的例子说明, 从下面的这段代码中, 可以看到<strong>除了 SIGCHLD 这个信号外, tini 会把其他所有的信号都转发给它的子进程</strong>.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">wait_and_forward_signal</span><span class="token punctuation">(</span><span class="token class-name">sigset_t</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span> parent_sigset_ptr<span class="token punctuation">,</span> <span class="token class-name">pid_t</span> <span class="token keyword">const</span> child_pid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">siginfo_t</span> sig<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sigtimedwait</span><span class="token punctuation">(</span>parent_sigset_ptr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sig<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ts<span class="token punctuation">)</span> <span class="token operator">&lt;</span>mark<span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">switch</span> <span class="token punctuation">(</span>errno<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// ...</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">/* There is a signal to handle here */</span>
                <span class="token keyword">switch</span> <span class="token punctuation">(</span>sig<span class="token punctuation">.</span>si_signo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">case</span> SIGCHLD<span class="token operator">:</span>
                                <span class="token comment">/* Special-cased, as we don't forward SIGCHLD. Instead, we'll
                                 * fallthrough to reaping processes.
                                 */</span>
                                <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">&quot;Received SIGCHLD&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token keyword">default</span><span class="token operator">:</span>
                                <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">&quot;Passing signal: '%s'&quot;</span><span class="token punctuation">,</span> <span class="token function">strsignal</span><span class="token punctuation">(</span>sig<span class="token punctuation">.</span>si_signo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token comment">/* Forward anything else */</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">kill</span><span class="token punctuation">(</span>kill_process_group <span class="token operator">?</span> <span class="token operator">-</span>child_pid <span class="token operator">:</span> child_pid<span class="token punctuation">,</span> sig<span class="token punctuation">.</span>si_signo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                        <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> ESRCH<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                                <span class="token function">PRINT_WARNING</span><span class="token punctuation">(</span><span class="token string">&quot;Child was dead when forwarding signal&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                                                <span class="token function">PRINT_FATAL</span><span class="token punctuation">(</span><span class="token string">&quot;Unexpected error when forwarding signal: '%s'&quot;</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
                                        <span class="token punctuation">}</span>
                                <span class="token punctuation">}</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>那么在这里明确一下, 怎么解决停止容器的时候, 容器内应用程序被强制杀死的问题呢? <mark>**解决的方法就是在容器的 init 进程中对收到的信号做个转发, 发送到容器中的其他子进程, 这样容器中的所有进程在停止时, 都会收到 SIGTERM, 而不是 SIGKILL 信号了. **</mark></p> <h5 id="_4-重点小结"><a href="#_4-重点小结" class="header-anchor">#</a> 4.重点小结</h5> <p>本节要解决的问题是让容器中的进程, 在容器停止的时候, 有机会 <strong>graceful shutdown, 而不是收到 SIGKILL 信号而被强制杀死</strong>.</p> <p>首先通过对 kill() 和 signal() 这个两个系统调用的学习, 进一步理解了进程是怎样处理 Linux 信号的, 重点是信号在接收处理的三个选择: <strong>忽略, 捕获和缺省行为</strong>.</p> <p>通过代码例子, 知道了 <strong>SIGTERM 是可以被忽略和捕获的, 但是 SIGKILL 是不可以被忽略和捕获</strong>的. 了解这一点以后, 就找到了问题的解决方向, 也就是<strong>需要在停止容器时, 让容器中的应用收到 SIGTERM, 而不是 SIGKILL</strong>.</p> <p>具体怎么操作呢? <strong>可以在容器的 init 进程中对收到的信号做个转发, 发送到容器中的其他子进程. 这样一来, 容器中的所有进程在停止容器时, 都会收到 SIGTERM, 而不是 SIGKILL 信号了</strong>.</p> <p>其实解决 init 进程信号的这类问题其实并不难. 只需要先梳理一下和这个问题相关的几个知识点, 再写个小程序, 让它跑在容器里, 稍微做几个试验. 然后再看一下内核和 Docker 的源代码, 就可以很快得出结论了.</p> <h4 id="_05-容器cpu-1-怎么限制容器的cpu使用"><a href="#_05-容器cpu-1-怎么限制容器的cpu使用" class="header-anchor">#</a> 05｜容器CPU(1):怎么限制容器的CPU使用?</h4> <p>从本节开始进入容器 CPU 这个模块. 前面讲过, 容器在 Linux 系统中最核心的两个概念是 <strong>Namespace 和 Cgroups</strong>. 可以<strong>通过 Cgroups 技术限制资源</strong>. 这个资源可以分为很多类型, 比如 CPU, Memory, Storage, Network 等等. 而计算资源是最基本的一种资源, 所有的容器都需要这种资源. 本节就先聊一聊, 怎么限制容器的 CPU 使用?</p> <p>拿 Kubernetes 做例子, 具体来看下面这个 pod/container 里的 spec 定义, 在 CPU 资源相关的定义中有两项内容, 分别是 <strong>Request CPU</strong> 和 <strong>Limit CPU</strong>.</p> <div class="language-yml line-numbers-mode"><pre class="language-yml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> frontend
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> app
    <span class="token key atrule">image</span><span class="token punctuation">:</span> images.my<span class="token punctuation">-</span>company.example/app<span class="token punctuation">:</span>v4
    <span class="token key atrule">env</span><span class="token punctuation">:</span>
    <span class="token key atrule">resources</span><span class="token punctuation">:</span>
      <span class="token key atrule">requests</span><span class="token punctuation">:</span>
        <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">&quot;64Mi&quot;</span>
        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">&quot;1&quot;</span>
      <span class="token key atrule">limits</span><span class="token punctuation">:</span>
        <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">&quot;128Mi&quot;</span>
        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">&quot;2&quot;</span>
<span class="token punctuation">...</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>很多刚刚使用 Kubernetes 的同学, 可能一开始并不理解这两个参数有什么作用. 这里先说结论, <strong>在 Pod Spec 里的 &quot;Request CPU&quot; 和 &quot;Limit CPU&quot; 的值, 最后会通过 CPU Cgroup 的配置, 来实现控制容器 CPU 资源的作用</strong>.</p> <p>那接下来先从进程的 CPU 使用讲起, 然后在 CPU Cgroup 子系统中建立几个<strong>控制组</strong>, 用这个例子讲解 CPU Cgroup 中的三个最重要的参数  <strong>&quot;cpu.cfs_quota_us&quot;, &quot;cpu.cfs_period_us&quot;, &quot;cpu.shares&quot;</strong> .</p> <p>理解了这三个参数后, 就会明白要怎样限制容器 CPU 的使用了.</p> <h5 id="_1-如何理解cpu使用和cpu-cgroup"><a href="#_1-如何理解cpu使用和cpu-cgroup" class="header-anchor">#</a> 1.如何理解CPU使用和CPU Cgroup?</h5> <p>既然需要理解 CPU Cgroup, 那么就有必要先来看一下 Linux 里的 CPU 使用的概念, 这是因为 <strong>CPU Cgroup 最大的作用就是限制 CPU 使用</strong>.</p> <h6 id="_1-cpu使用的分类"><a href="#_1-cpu使用的分类" class="header-anchor">#</a> (1)CPU使用的分类</h6> <p>如果想查看 Linux 系统的 CPU 使用的话, 会用什么方法呢? 最常用的肯定是运行 Top 了.</p> <p>对照下图的 Top 运行界面, 在截图第三行, &quot; <strong>%Cpu(s)</strong> &quot; 开头的这一行, 会看到一串数值, 也就是 &quot;0.0 us, 0.0 sy, 0.0 ni, 99.9 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st&quot;, 那么这里的每一项值都是什么含义呢?</p> <p><img src="/img/3b01badf86f310a1d1f10f4b7e9c0381-20230731161430-plhm9f1.png" alt=""></p> <p>下面这张图里最长的带箭头横轴, 可以把它看成一个<strong>时间轴</strong>. 同时它的<mark><strong>上半部分代表 Linux 用户态(User space), 下半部分代表内核态(Kernel space)</strong></mark> . 这里为了方便理解, 先假设只有一个 CPU.</p> <p><img src="/img/9515e60d11766c6b2e4481af6bd382e8-20230731161430-g8v7nm4.png" alt=""></p> <p>可以用上面这张图, 把这些值挨个解释一下.</p> <p>假设一个用户<strong>程序开始运行</strong>了, 那么就对应着第一个  <strong>&quot;us&quot; 框</strong>,  <mark><strong>&quot;us&quot; 是 &quot;user&quot; 的缩写, 代表 Linux 的用户态 CPU Usage</strong></mark>. 普通用户程序代码中, <strong>只要不是调用系统调用(System Call), 这些代码的指令消耗的 CPU 就都属于 &quot;us&quot;</strong> .</p> <p>当这个用户程序代码中调用了<strong>系统调用</strong>, 比如说 read() 去读取一个文件, 这时候这个用户进程就会<strong>从用户态切换到内核态</strong>. 内核态 read() 系统调用在读到真正 disk 上的文件前, 就会进行一些文件系统层的操作. 那么这些代码指令的消耗就属于 &quot;<strong>sy</strong>&quot;, 这里就对应上面图里的第二个框.  <mark><strong>&quot;sy&quot; 是 &quot;system&quot; 的缩写, 代表内核态 CPU 使用</strong></mark>.</p> <p>接下来, 这个 read() 系统调用会向 Linux 的 Block Layer 发出一个 I/O Request, 触发一个真正的磁盘读取操作. 这时候, 这个进程一般会被置为 TASK_UNINTERRUPTIBLE. 而 Linux 会把这段时间标示成 &quot;wa&quot;, 对应图中的第三个框.  <mark><strong>&quot;wa&quot; 是 &quot;iowait&quot; 的缩写, 代表等待 I/O 的时间, 这里的 I/O 是指 Disk I/O</strong></mark>.</p> <p>紧接着, 当磁盘返回数据时, 进程在内核态拿到数据, 这里仍旧是内核态的 CPU 使用中的 &quot;sy&quot;, 也就是图中的第四个框.</p> <p>然后, 进程再<strong>从内核态切换回用户态</strong>, 在用户态得到文件数据, 这里进程又回到用户态的 CPU 使用, &quot;us&quot;, 对应图中第五个框.</p> <p>这里假设一下, 这个用户进程在读取数据之后, 没事可做就<strong>休眠</strong>了. 并且可以进一步假设, 这时在这个 CPU 上也没有其他需要运行的进程了, 那么系统就会进入 &quot;id&quot; 这个步骤, 也就是第六个框.  <mark><strong>&quot;id&quot; 是 &quot;idle&quot; 的缩写, 代表系统处于空闲状态</strong></mark>.</p> <p>如果这时这台机器在网络收到一个<strong>网络数据包</strong>, 网卡就会发出一个中断(interrupt). 相应地, CPU 会响应中断, 然后进入中断服务程序. 这时 CPU 就会进入 &quot;hi&quot;, 也就是第七个框.  <strong>&quot;hi&quot; 是 &quot;hardware irq&quot; 的缩写, 代表 CPU 处理硬中断的开销</strong>. 由于中断服务处理需要关闭中断, 所以这个硬中断的时间不能太长.</p> <p>但是, 发生中断后的工作是必须要完成的, 如果这些工作比较耗时那怎么办呢? Linux 中有一个<strong>软中断</strong>的概念(softirq), 它可以完成这些<strong>耗时比较长</strong>的工作. 可以这样理解这个软中断, <strong>从网卡收到数据包的大部分工作, 都是通过软中断来处理的</strong>. 那么, CPU 就会进入到第八个框, &quot;si&quot;. <mark><strong>这里 &quot;si&quot; 是 &quot;softirq&quot; 的缩写, 代表 CPU 处理软中断的开销</strong></mark>.</p> <p>这里要注意, **无论是 &quot;hi&quot; 还是 &quot;si&quot;, 它们的 CPU 时间都不会计入进程的 CPU 时间. 这是因为本身它们在处理的时候就不属于任何一个进程. **</p> <p>通过这个场景假设, 就已经介绍了大部分的 Linux CPU 使用. 不过, 还剩两个类型的 CPU 使用没讲到, 这里做个补充, 一次性带你做个全面了解. 这样以后解决相关问题时, 就不会再犹豫, 这些值到底影不影响 CPU Cgroup 中的限制了. 下面具体讲一下.</p> <p>一个是 &quot;ni&quot;, 是 &quot;nice&quot; 的缩写, 这里<mark><strong>表示如果进程的 nice 值是正值(1-19), 代表优先级比较低的进程运行时所占用的 CPU</strong></mark>.</p> <p>另外一个是 &quot;st&quot;,  <mark><strong>&quot;st&quot; 是 &quot;steal&quot; 的缩写, 是在虚拟机里用的一个 CPU 使用类型, 表示有多少时间是被同一个宿主机上的其他虚拟机抢走的</strong></mark>.</p> <p>综合前面的内容, 再用表格总结一下:</p> <p><img src="/img/bfff882d1d32e3d1d6b72eae52df2814-20230731161430-yw4ik9h.png" alt=""></p> <h6 id="_2-cpu-cgroup"><a href="#_2-cpu-cgroup" class="header-anchor">#</a> (2)CPU Cgroup</h6> <p><strong>Cgroups 是对指定进程做计算机资源限制的, CPU Cgroup 是 Cgroups 其中的一个 Cgroups 子系统, 它是用来限制进程的 CPU 使用的.</strong></p> <p>对于进程的 CPU 使用, 通过前面的 Linux CPU 使用分类的介绍, 知道它只包含两部分: <strong>一个是用户态, 这里的用户态包含了 us 和 ni; 还有一部分是内核态, 也就是 sy</strong>. 至于 wa, hi, si, 这些 I/O 或者中断相关的 CPU 使用, <mark><strong>CPU Cgroup 不会去做限制</strong></mark>, 那么接下来就来看看 CPU Cgoup 是怎么工作的?</p> <p><strong>每个 Cgroups 子系统都是通过一个</strong>​<mark><strong>虚拟文件系统挂载点</strong></mark>​<strong>的方式, 挂到一个缺省的目录下, CPU Cgroup 一般在 Linux 发行版里会放在 <strong>​ <mark></mark></strong>/sys/fs/cgroup/cpu</strong>​ ** 这个目录下**. 在这个子系统的目录下, <strong>每个控制组(Control Group) 都是一个子目录, 各个控制组之间的关系就是一个树状的层级关系(hierarchy)</strong> .</p> <p>比如说, 在子系统的最顶层开始建立两个控制组(也就是建立两个目录)<strong>group1</strong> 和 <strong>group2</strong>, 然后再在 group2 的下面再建立两个控制组 group3 和 group4. 这样操作以后, 就建立了一个树状的控制组层级, 可以参考下面的示意图.</p> <p><img src="/img/d74d6249f9de2cad802fccfeb878c890-20230731161430-zwfg6ky.png" alt=""></p> <p>那么每个控制组里, 都有哪些 CPU Cgroup 相关的控制信息呢? 这里需要看一下<strong>每个控制组目录中的内容</strong>:</p> <div class="language-yml line-numbers-mode"><pre class="language-yml"><code><span class="token comment"># pwd</span>
/sys/fs/cgroup/cpu
<span class="token comment"># mkdir group1 group2</span>
<span class="token comment"># cd group2</span>
<span class="token comment"># mkdir group3 group4</span>
<span class="token comment"># cd group3</span>
<span class="token comment"># ls cpu.*</span>
cpu.cfs_period_us  cpu.cfs_quota_us  cpu.rt_period_us  cpu.rt_runtime_us  cpu.shares  cpu.stat 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>考虑到在云平台里, 大部分程序都不是实时调度的进程, 而是<strong>普通调度</strong>(SCHED_NORMAL)类型进程, 那什么是普通调度类型呢?</p> <p>因为普通调度的算法在 Linux 中目前是 <strong>CFS</strong> (Completely Fair Scheduler, 即完全公平调度器). 为了方便理解, 就直接来看 CPU Cgroup 和 CFS 相关的参数, 一共有三个.</p> <p>第一个参数是 <mark><strong>cpu.cfs_period_us</strong></mark>, 它是 CFS 算法的一个<strong>调度周期</strong>, 一般它的值是 100000, 以 microseconds 为单位, 也就 100ms.</p> <p>第二个参数是 <mark><strong>cpu.cfs_quota_us</strong></mark>, 它表示 CFS 算法中, 在一个调度周期里<strong>这个控制组被允许的运行时间</strong>, 比如这个值为 50000 时, 就是 50ms. 如果用这个<strong>值去除以调度周期</strong>(也就是 cpu.cfs_period_us), 50ms/100ms = 0.5, 这样这个控制组被允许使用的 CPU 最大配额就是 <strong>0.5 个 CPU</strong>. 从这里能够看出, cpu.cfs_quota_us 是一个<strong>绝对值</strong>. 如果这个值是 200000, 也就是 200ms, 那么它除以 period, 也就是 200ms/100ms=2. 结果超过了 1 个 CPU, 这就意味着这时控制组需要 <strong>2 个 CPU</strong> 的资源配额.</p> <p>第三个参数是 <mark><strong>cpu.shares</strong></mark>. 这个值是 CPU Cgroup 对于<strong>控制组之间的 CPU 分配比例</strong>, 它的缺省值是 1024. 假设前面创建的 group3 中的 cpu.shares 是 1024, 而 group4 中的 cpu.shares 是 3072, 那么 group3:group4=1:3. 这个比例的意思是, 比如在一台 4 个 CPU 的机器上, 当 group3 和 group4 都<strong>需要 4 个 CPU 的时候</strong>, 它们实际分配到的 CPU 分别是这样的: group3 是 1 个, group4 是 3 个.</p> <p>刚才讲了 CPU Cgroup 里的三个关键参数, 接下来就通过几个例子来进一步理解一下, 代码可以在这里找到.</p> <p>第一个例子, 启动一个消耗 2 个 CPU(200%)的程序 threads-cpu, 然后把这个程序的 pid 加入到 group3 的控制组里:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>./threads-cpu/threads-cpu <span class="token number">2</span> <span class="token operator">&amp;</span> <span class="token builtin class-name">echo</span> <span class="token variable">$!</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group3/cgroup.procs
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在没有修改 cpu.cfs_quota_us 前, 用 top 命令可以看到 threads-cpu 这个进程的 CPU 使用是 199%, 近似 2 个 CPU.</p> <p><img src="/img/648acfbc5c65f5b8c71f97d89f5d57a3-20230731161430-pfg6ie3.png" alt=""></p> <p>然后, 更新这个控制组里的 <strong>cpu.cfs_quota_us</strong>, 把它设置为 150000(150ms). 把这个值除以 cpu.cfs_period_us, 计算过程是 150ms/100ms=1.5, 也就是 1.5 个 CPU, 同时也把 cpu.shares 设置为 1024.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token builtin class-name">echo</span> <span class="token number">150000</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group3/cpu.cfs_quota_us
<span class="token builtin class-name">echo</span> <span class="token number">1024</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group3/cpu.shares
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这时候再运行 top, 就会发现 threads-cpu 进程的 CPU 使用减小到了 150%. 这是因为设置的 cpu.cfs_quota_us 起了作用, <strong>限制了进程 CPU 的绝对值</strong>.</p> <p>但这时候 cpu.shares 的作用还没有发挥出来, <strong>因为 cpu.shares 是几个控制组之间的 CPU 分配比例, 而且一定要到整个节点中所有的 CPU 都跑满的时候, 它才能发挥作用</strong>.</p> <p><img src="/img/1a78305f2b6e82c0af20d0d5ab107150-20230731161430-16b17sa.png" alt=""></p> <p>下面再来运行第二个例子来理解 cpu.shares. 先把第一个例子里的程序启动, 同时按前面的内容, 一步步设置好 group3 里 cpu.cfs_quota_us 和 cpu.shares. 设置完成后, 再启动第二个程序, 并且设置好 group4 里的 <strong>cpu.cfs_quota_us 和 cpu.shares</strong>.</p> <p>group3:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>./threads-cpu/threads-cpu <span class="token number">2</span> <span class="token operator">&amp;</span>  <span class="token comment"># 启动一个消耗2个CPU的程序</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$!</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group3/cgroup.procs <span class="token comment">#把程序的pid加入到控制组</span>
<span class="token builtin class-name">echo</span> <span class="token number">150000</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group3/cpu.cfs_quota_us <span class="token comment">#限制CPU为1.5CPU</span>
<span class="token builtin class-name">echo</span> <span class="token number">1024</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group3/cpu.shares
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>group4:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>./threads-cpu/threads-cpu <span class="token number">4</span> <span class="token operator">&amp;</span>  <span class="token comment"># 启动一个消耗4个CPU的程序</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$!</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group4/cgroup.procs <span class="token comment">#把程序的pid加入到控制组</span>
<span class="token builtin class-name">echo</span> <span class="token number">350000</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group4/cpu.cfs_quota_us  <span class="token comment">#限制CPU为3.5CPU</span>
<span class="token builtin class-name">echo</span> <span class="token number">3072</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group3/cpu.shares <span class="token comment"># shares 比例 group4: group3 = 3:1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>现在节点上总共有 4 个 CPU, 而 group3 的程序需要消耗 2 个 CPU, group4 里的程序要消耗 4 个 CPU.</p> <p>即使 cpu.cfs_quota_us 已经限制了进程 CPU 使用的绝对值, group3 的限制是 1.5CPU, group4 是 3.5CPU, 1.5+3.5=5, 这个结果还是<strong>超过</strong>了节点上的 4 个 CPU.</p> <p>好了, 到这里发现在这种情况下, <strong>cpu.shares</strong> 终于开始起作用了. 在这里 shares 比例是 group4:group3=3:1, 在总共 4 个 CPU 的节点上, 按照比例, group4 里的进程应该分配到 3 个 CPU, 而 group3 里的进程会分配到 1 个 CPU.</p> <p>用 top 可以看一下, 结果和预期的一样.</p> <p><img src="/img/3179672485e2359b63bb0d76413ff490-20230731161430-87z94mf.png" alt=""></p> <p>好了对 CPU Cgroup 的参数做一个梳理.</p> <p>第一点, <mark>cpu.cfs_quota_us 和 cpu.cfs_period_us 这两个值决定了</mark>​<mark><strong>每个控制组中所有进程的可使用 CPU 资源的最大值</strong></mark>​ **. **</p> <p>第二点, <mark>cpu.shares 这个值决定了 </mark>​<mark><strong>CPU Cgroup 子系统下控制组可用 CPU 的相对比例</strong></mark>, 不过只有<strong>当系统上 CPU 完全被占满的时候, 这个比例才会在各个控制组间起作用</strong>.</p> <h5 id="_2-现象解释"><a href="#_2-现象解释" class="header-anchor">#</a> 2.现象解释</h5> <p>在解释了 Linux CPU Usage 和 CPU Cgroup 这两个基本概念之后, 再回到我们最初的问题 &quot;怎么限制容器的 CPU 使用&quot;. 有了基础知识的铺垫, 这个问题就比较好解释了.</p> <p><strong>首先, Kubernetes 会为每个容器都在 CPU Cgroup 的子系统中建立一个控制组, 然后把容器中进程写入到这个控制组里</strong>. 这时候 &quot;Limit CPU&quot; 就需要为容器设置可用 CPU 的上限. 结合前面讲的几个参数, 就能知道容器的 CPU 上限具体如何计算了.</p> <p>**容器 CPU 的上限由 cpu.cfs_quota_us 除以 cpu.cfs_period_us 得出的值来决定的. 而且在操作系统里, cpu.cfs_period_us 的值一般是个固定值, Kubernetes 不会去修改它, 所以就是只修改 **​<mark><strong>cpu.cfs_quota_us</strong></mark>​ **. **</p> <p>而 &quot;Request CPU&quot; 就是无论其他容器申请多少 CPU 资源, 即使运行时整个节点的 CPU 都被占满的情况下, 这个容器还是可以保证获得需要的 CPU 数目, 那么这个设置具体要怎么实现呢? 显然需要设置 cpu.shares 这个参数: **在 CPU Cgroup 中 cpu.shares <mark> 1024 表示 1 个 CPU 的比例, 那么 Request CPU 的值就是 n, <strong>​</strong></mark>给 cpu.shares 的赋值对应就是 n*1024==**​ **. **</p> <h5 id="_3-重点总结-2"><a href="#_3-重点总结-2" class="header-anchor">#</a> 3.重点总结</h5> <p>本节了解了 Linux 下 CPU Usage 的种类. 这里要注意的是<mark><strong>每个进程的 CPU Usage 只包含用户态(us 或 ni)和内核态(sy)两部分, 其他的系统 CPU 开销并不包含在进程的 CPU 使用中, 而 CPU Cgroup 只是对进程的 CPU 使用做了限制</strong></mark>​ **. **</p> <p>其实这一节的问题 &quot;怎么限制容器的 CPU 使用&quot;, 这个问题背后隐藏了另一个问题, 也就是<strong>容器是如何设置它的 CPU Cgroup 中参数值的</strong>? 想解决这个问题就要先知道 CPU Cgroup 都有哪些参数.</p> <p>所以本节详细介绍了 CPU Cgroup 中的主要参数, 包括这三个: **cpu.cfs_quota_us, cpu.cfs_period_us 还有 cpu.shares. **</p> <p><strong>其中 cpu.cfs_quota_us(一个调度周期里这个控制组被允许的运行时间)除以 cpu.cfs_period_us(用于设置调度周期)得到的这个值决定了 CPU Cgroup 每个控制组中 CPU 使用的上限值. cpu.shares 参数值决定了 CPU Cgroup 子系统下控制组可用 CPU 的相对比例, 当系统上 CPU 完全被占满的时候, 这个比例才会在各个控制组间起效.</strong></p> <p>明白了 CPU Cgroup 关键参数是什么含义后, Kubernetes 中 &quot;Limit CPU&quot; 和 &quot;Request CPU&quot; 也就很好解释了:</p> <p><strong>Limit CPU 就是容器所在 Cgroup 控制组中的 CPU 上限值, Request CPU 的值就是控制组中的 cpu.shares 的值.</strong></p> <h4 id="_06-容器cpu-2-如何正确地拿到容器cpu的开销"><a href="#_06-容器cpu-2-如何正确地拿到容器cpu的开销" class="header-anchor">#</a> 06｜容器CPU(2):如何正确地拿到容器CPU的开销?</h4> <p>为啥要解决这个问题呢, 还是来源于实际工作中的需要. 无论是容器的所有者还是容器平台的管理者, 想要精准地对运行着众多容器的云平台做<strong>监控</strong>, 快速排查例如应用的处理能力下降, 节点负载过高等问题, 就绕不开容器 CPU 开销. **因为 CPU 开销的异常, 往往是程序异常最明显的一个指标. **</p> <p>在一台物理机器或者虚拟机里, 如果想得到这个节点的 CPU 使用率, 最常用的命令就是 top 了吧? top 一下子就能看到整个节点当前的 CPU 使用情况. 那么在容器里, top 命令也可以做到这点吗? 想要知道答案, 还是得实际动手试一试.</p> <h5 id="_1-问题重现"><a href="#_1-问题重现" class="header-anchor">#</a> 1.问题重现</h5> <p>实际上在使用容器的时候, 如果运行 top 命令来查看当前容器总共使用了多少 CPU, 你肯定马上就会失望了. 这是因为<mark><strong>在容器中运行 top 命令, 虽然可以看到容器中每个进程的 CPU 使用率, 但是 top 中 &quot;%Cpu(s)&quot; 那一行中显示的数值, 并不是这个容器的 CPU 整体使用率, 而是容器宿主机的 CPU 使用率</strong></mark>.</p> <p>就像下面的这个例子, 在一个 12 个 CPU 的宿主机上, 启动一个容器, 然后在容器里运行 top 命令. 这时可以看到, 容器里有两个进程 threads-cpu, 总共消耗了 200% 的 CPU(2 CPU Usage), 而 &quot;%Cpu(s)&quot; 那一行的 &quot;us cpu&quot; 是 58.5%. 对于 12CPU 的系统来说, 12 * 58.5%=7.02, 也就是说这里显示总共消耗了 7 个 CPU, 远远大于容器中 2 个 CPU 的消耗.</p> <p><img src="/img/4935329c612a16fcb3c8e9e776eff064-20230731161430-ge0qqkg.png" alt=""></p> <p>这个例子说明, **top 这个工具虽然在物理机或者虚拟机上看得到系统 CPU 开销, 但是如果是放在容器环境下, **​<mark><strong>运行 top 就无法得到容器中总的 CPU 使用率</strong></mark>. 那么还有什么其他的办法吗?</p> <h5 id="_2-进程cpu使用率和系统cpu使用率"><a href="#_2-进程cpu使用率和系统cpu使用率" class="header-anchor">#</a> 2.进程CPU使用率和系统CPU使用率</h5> <p>通过问题重现, 发现 <strong>top 工具主要显示了宿主机系统整体的 CPU 使用率, 以及单个进程的 CPU 使用率</strong>. 既然没有现成的工具可以得到容器 CPU 开销, 那需要自己开发一个工具来解决问题了.</p> <p>其实自己推导, 也没有那么难, 最有效的思路还是从原理上去理解问题. 所以在解决怎样得到单个容器整体的 CPU 使用率这个问题之前, 先来学习一下, 在 Linux 中到底是<strong>如何计算单个进程的 CPU 使用率, 还有整个系统的 CPU 使用率的</strong>.</p> <h6 id="_1-进程cpu使用率"><a href="#_1-进程cpu使用率" class="header-anchor">#</a> (1)进程CPU使用率</h6> <p>Linux 中<strong>每个进程</strong>的 CPU 使用率, 都可以用 <strong>top</strong> 命令查看. 对照前面的那张示意图, 可以发现, 每个进程在 top 命令输出中都有对应的一行, 然后 &quot;%CPU&quot; 的那一列就是<strong>这个进程的实时 CPU 使用率</strong>了. 比如, 100% 就表示这个进程在这个<strong>瞬时</strong>使用了 1 个 CPU, 200% 就是使用了 2 个 CPU. 那么这个百分比的数值是怎么得到呢?</p> <p>最直接的方法, 就是<strong>从源头开始寻找答案</strong>. 因为是 top 命令的输出, 可以去看一下 top 命令的源代码. 在代码中会看到对于每个进程, <mark><strong>top 都会从 proc 文件系统中每个进程对应的 stat 文件中读取 2 个数值</strong></mark>.</p> <p>先来看这个文件, 再来解读文件中具体的两个数值. 这个 stat 文件就是 <code>/proc/[pid]/stat</code>​,  <code>[pid]</code>​ 就是替换成具体一个进程的 PID 值. 比如 PID 值为 1 的进程, 这个文件就是 <code>/proc/1/stat</code>​, 那么这个 <code>/proc/[pid]/stat</code>​ 文件里有什么信息呢?</p> <p>其实这个 stat 文件<mark><strong>实时输出了进程的状态信息</strong></mark>, 比如进程的<strong>运行态</strong>(Running 还是 Sleeping), <strong>父进程 PID, 进程优先级, 进程使用的内存</strong>等等总共 50 多项.</p> <p>完整的 stat 文件内容和格式在 proc 文件系统的 Linux programmer’s manual 里定义了. 在这里只需要重点关注这两项数值, stat 文件中的第 14 项 <strong>utime</strong> 和第 15 项 <strong>stime</strong>.</p> <p><img src="/img/310f6276c98436dfd1d8bce2a2354740-20230731161430-7nea83u.png" alt=""></p> <p>那么这两项数值 utime 和 stime 是什么含义呢? <mark><strong>utime 是表示进程的用户态部分在 Linux 调度中获得 CPU 的 ticks, stime 是表示进程的内核态部分在 Linux 调度中获得 CPU 的 ticks</strong></mark>.</p> <p>看到这个解释, 你可能又冒出一个新问题, 疑惑 ticks 是什么? <strong>这个 ticks 就是 Linux 操作系统中的一个时间单位</strong>, 可以理解成类似秒, 毫秒的概念. 在 Linux 中有个自己的时钟, 它会周期性地产生中断. 每次中断都会触发 Linux 内核去做一次进程调度, 而这<strong>一次中断就是一个 tick</strong>. 因为是周期性的中断, 比如 1 秒钟 100 次中断, 那么一个 tick 作为一个时间单位看的话, 也就是 1/100 秒.</p> <p>举个例子, 假如进程的 utime 是 130 ticks, 就相当于 130 * 1/100=1.3 秒, 也就是进程从启动开始在用户态总共运行了 1.3 秒钟.</p> <p>这里需要注意, <strong>utime 和 stime 都是一个累计值, 也就是说从进程启动开始, 这两个值就是一直在累积增长的</strong>.</p> <p>那么怎么计算, 才能知道<strong>某一进程在用户态和内核态</strong>中, 分别获得了多少 CPU 的 ticks 呢?</p> <p>首先, 可以假设这个瞬时是 1 秒钟, 这 1 秒是 T1 时刻到 T2 时刻之间的, 那么这样就能获得 T1 时刻的 utime_1 和 stime_1, 同时获得 T2 时刻的 utime_2 和 stime_2. 在这 1 秒的瞬时, 进程用户态获得的 CPU ticks 就是  <strong>(utime_2 – utime_1)</strong> , 进程内核态获得的 CPU ticks 就是  <strong>(stime_2 – stime_1)</strong> . 那么可以推导出, <strong>进程 CPU 总的开销就是用户态加上内核态</strong>, 也就是在 1 秒瞬时进程总的 CPU ticks 等于  <strong>(utime_2 – utime_1) + (stime_2 – stime_1)</strong> .</p> <p>现在得到了进程以 ticks 为单位的 CPU 开销, 接下来还要做个转化. 怎样才能把这个值转化成熟悉的百分比值呢? 其实也不难, 还是可以去 top 的源代码里得到这个百分比的计算公式.</p> <p>简单总结一下, 这个公式是这样的:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>进程的 CPU 使用率 <span class="token operator">=</span><span class="token variable"><span class="token punctuation">((</span>utime_2 – utime_1<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>stime_2 – stime_1<span class="token punctuation">))</span></span> * <span class="token number">100.0</span> / <span class="token punctuation">(</span>HZ * et * <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这个公式里每一个部分的含义如下.</p> <p>首先,  ((utime_2 – utime_1) + (stime_2 – stime_1)) 是瞬时进程<strong>总的 CPU ticks</strong>. 这个已经在前面解释过了.</p> <p>其次, 来看 100.0, 这里乘以 100.0 的目的是产生百分比数值.</p> <p>最后再讲一下 (HZ * et * 1). 这是被除数这里的三个参数.</p> <p>第一个 HZ 是什么意思呢? 前面介绍 ticks 里说了, ticks 是按照<strong>固定频率</strong>发生的, 在 Linux 系统里 1 秒钟是 100 次, 那么 <strong>HZ 就是 1 秒钟里 ticks 的次数</strong>, 这里值是 100.</p> <p>第二个参数 et 是刚才说的那个 &quot;瞬时&quot; 的时间, 也就是得到 utime_1 和 utime_2 这两个值的<strong>时间间隔</strong>.</p> <p>第三个 &quot;1&quot;, 就更容易理解了, 就是 <strong>1 个 CPU</strong>. 那么这三个值相乘, 你是不是也知道了它的意思呢? 就是<strong>在这 &quot;瞬时&quot; 的时间(et)里, 1 个 CPU 所包含的 ticks 数目</strong>.</p> <p>解释了这些参数, 可以把这个公式简化一下:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>进程的 CPU 使用率 <span class="token operator">=</span><span class="token punctuation">(</span>进程的 ticks / 单个 CPU 总 ticks<span class="token punctuation">)</span>*100.0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>知道了这个公式, 就需要上手来<strong>验证</strong>一下这个方法对不对, 怎么验证呢? 可以启动一个消耗 CPU 的小程序, 然后读取一下进程对应的 <code>/proc/[pid]/stat</code>​ 中的 utime 和 stime, 然后用这个方法来计算一下进程使用率这个百分比值, 并且和 top 的输出对比一下, 看看是否一致.</p> <p>先启动一个消耗 200% 的小程序, 它的 PID 是 10021, CPU 使用率是 200%.</p> <p><img src="/img/d7306643e9a0acec2784990d091ada72-20230731161430-mj7sjpp.png" alt=""></p> <p>然后查看这个进程对应的 stat 文件 /proc/10021/stat, 间隔 1 秒钟输出第二次, 因为 stat 文件内容很多, 我们知道 utime 和 stime 第 14 和 15 项, 所以这里只截取了前 15 项的输出. 可以看到, utime_1 = 399, stime_1=0, utime_2=600, stime_2=0.</p> <p><img src="/img/7260c5c45e395f01c09d86440682f2e1-20230731161430-5e7jqji.png" alt=""></p> <p>根据前面的公式, 计算一下进程 threads-cpu 的 CPU 使用率. 套用前面的公式, 计算的过程是:</p> <p><strong>((600 – 399) + (0 – 0)) * 100.0 / (100 * 1 * 1) =201</strong>, 也就是 201%. 这个值和运行 top 里的值是一样的, 也就验证了这个公式是没问题的.</p> <h6 id="_2-系统cpu使用率"><a href="#_2-系统cpu使用率" class="header-anchor">#</a> (2)系统CPU使用率</h6> <p>前面介绍了 Linux 中如何获取单个进程的 CPU 使用率, 下面再来看看 Linux 里是<strong>怎么计算系统的整体 CPU 使用率</strong>的.</p> <p>其实知道了如何计算单个进程的 CPU 使用率之后, 要理解系统整体的 CPU 使用率计算方法就简单多了.</p> <p>同样要计算 CPU 使用率, 首先需要拿到数据, 数据源也同样可以从 proc 文件系统里得到, 对于整个系统的 CPU 使用率, 这个文件就是  <strong>/proc/stat</strong>. 在 /proc/stat 文件的 <code>cpu</code>​ 这行有 10 列数据, 同样可以在 proc 文件系统的 Linux programmer’s manual 里, 找到每一列数据的定义, 而前 8 列数据正好对应 top 输出中 &quot;%Cpu(s)&quot; 那一行里的 8 项数据, 也就是在上一讲中, 介绍过的 <strong>user/system/nice/idle/iowait/irq/softirq/steal</strong> 这 8 项.</p> <p><img src="/img/efcac25bf71c8d307b6ebc991368e270-20230731161430-w3chjf9.png" alt=""></p> <p>而在 /proc/stat 里的每一项的数值, 就是<strong>系统自启动开始的 ticks</strong>. 那么要计算出 &quot;瞬时&quot; 的 CPU 使用率, 首先就要算出这个 &quot;瞬时&quot; 的 ticks, 比如 1 秒钟的 &quot;瞬时&quot;, 可以记录开始时刻 T1 的 ticks, 然后再记录 1 秒钟后 T2 时刻的 ticks, 再把这两者相减, 就可以得到这 1 秒钟的 ticks 了.</p> <p><img src="/img/55c515d069f8439cbabe37acd103b4c6-20230731161430-jwrutiv.png" alt=""></p> <p>这里可以得到, 在这 1 秒钟里每个 CPU 使用率的 ticks:</p> <p><img src="/img/093614b6496e075184d1294e976d98e5-20230731161430-lt919ny.png" alt=""></p> <p>想要计算每一种 CPU 使用率的百分比, 其实也很简单. 只需要把所有在这 1 秒里的 ticks 相加得到一个总值, 然后拿某一项的 ticks 值, 除以这个总值. 比如计算 idle CPU 的使用率就是:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token punctuation">(</span><span class="token number">1203</span> / <span class="token number">0</span> + <span class="token number">0</span> + <span class="token number">0</span> + <span class="token number">1203</span> + <span class="token number">0</span> + <span class="token number">0</span> + <span class="token number">0</span> + <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">100</span>%
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>现在来整体梳理一下, 通过 Linux 里的工具, 要怎样计算进程的 CPU 使用率和系统的 CPU 使用率.</p> <p>对于<strong>单个进程</strong>的 CPU 使用率计算, 需要读取对应进程的 <code>/proc/[pid]/stat</code>​ 文件, 将进程<strong>瞬时用户态和内核态的 ticks 数相加, 就能得到进程的总 ticks</strong>. 然后运用公式 &quot; <strong>(进程的 ticks / 单个 CPU 总 ticks) * 100.0</strong>&quot; 计算出进程 CPU 使用率的百分比值.</p> <p>**对于系统的 CPU 使用率, 需要读取 /proc/stat 文件, 得到瞬时各项 CPU 使用率的 ticks 值, 相加得到一个总值, 单项值除以总值就是各项 CPU 的使用率. **</p> <h5 id="_3-解决问题-2"><a href="#_3-解决问题-2" class="header-anchor">#</a> 3.解决问题</h5> <p>前面学习了在 Linux 中, top 工具是怎样计算每个进程的 CPU 使用率, 以及系统总的 CPU 使用率. 现在再来看最初的问题: 为什么在容器中运行 top 命令不能得到容器中总的 CPU 使用率?</p> <p>这就比较好解释了, <strong>对于系统总的 CPU 使用率, 需要读取 /proc/stat 文件, 但是这个文件中的各项 CPU ticks 是反映整个节点的, 并且这个 /proc/stat 文件也不包含在任意一个 Namespace 里</strong>.</p> <p>所以<mark><strong>对于 top 命令来说, 它只能显示整个节点中各项 CPU 的使用率, 不能显示单个容器的各项 CPU 的使用率</strong></mark>. 既然 top 命令不行, 还有没有办法得到整个容器的 CPU 使用率呢?</p> <p>之前已经学习过了 CPU Cgroup, <strong>每个容器都会有一个 CPU Cgroup 的控制组</strong>. 在这个控制组目录下面有很多参数文件, 有的参数可以决定这个控制组里最大的 CPU 可使用率外, 除了它们之外, <strong>目录下面还有一个可读项 cpuacct.stat</strong>.</p> <p>这里包含了<strong>两个统计值</strong>, 这两个值分别是<mark><strong>这个控制组里所有进程的内核态 ticks 和用户态的 ticks</strong></mark>, 那么就可以用前面讲过的公式, 也就是计算进程 CPU 使用率的公式, 去计算整个容器的 CPU 使用率:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>CPU 使用率 <span class="token operator">=</span><span class="token variable"><span class="token punctuation">((</span>utime_2 – utime_1<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>stime_2 – stime_1<span class="token punctuation">))</span></span> * <span class="token number">100.0</span> / <span class="token punctuation">(</span>HZ * et * <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>还是以问题重现中的例子说明, 也就是最开始启动容器里的那两个容器 threads-cpu 进程.</p> <p>就像下图显示的这样, 整个容器的 CPU 使用率的百分比就是 ((174021 - 173820) + (4 – 4)) * 100.0 / (100 * 1 * 1) = 201, 也就是 201%. <mark><strong>所以从每个容器的 CPU Cgroup 控制组里的 cpuacct.stat 的统计值中, 可以比较快地得到整个容器的 CPU 使用率</strong></mark>.</p> <p><img src="/img/3a3560e07207c81d5b1fa0b052dbafc0-20230731161430-ntfauk4.png" alt=""></p> <h5 id="_4-重点总结-3"><a href="#_4-重点总结-3" class="header-anchor">#</a> 4.重点总结</h5> <p>Linux 里获取 CPU 使用率的工具, 比如 top, 都是<strong>通过读取 proc 文件系统下的 stat 文件来得到 CPU 使用了多少 ticks</strong>. 而这里的 ticks, 是 Linux 操作系统里的一个时间单位, 可以理解成类似秒, 毫秒的概念.</p> <p>**对于每个进程来说, 它的 stat 文件是 /proc/[pid]/stat, 里面包含了进程用户态和内核态的 ticks 数目; 对于整个节点, 它的 stat 文件是 /proc/stat, 里面包含了 user/system/nice/idle/iowait 等不同 CPU 开销类型的 ticks. **</p> <p><mark><strong>由于 /proc/stat 文件是整个节点全局的状态文件, 不属于任何一个 Namespace, 因此在容器中无法通过读取 /proc/stat 文件来获取单个容器的 CPU 使用率.</strong></mark></p> <p>所以要得到单个容器的 CPU 使用率, 可以从 CPU Cgroup 每个<strong>控制组里的统计文件 cpuacct.stat</strong> 中获取. **单个容器 CPU 使用率 =((utime_2 – utime_1) + (stime_2 – stime_1)) * 100.0 / (HZ * et * 1). **</p> <p>得到单个容器的 CPU 的使用率, 那么当宿主机上负载变高的时候, 就可以很快知道是<strong>哪个容器</strong>引起的问题. 同时用户在管理自己成百上千的容器的时候, 也可以很快发现 CPU 使用率异常的容器, 这样就能及早地介入去解决问题.</p> <h4 id="_07-load-average-加了cpu-cgroup限制-为什么我的容器还是很慢"><a href="#_07-load-average-加了cpu-cgroup限制-为什么我的容器还是很慢" class="header-anchor">#</a> 07 | Load Average:加了CPU Cgroup限制,为什么我的容器还是很慢?</h4> <p>本节聊一聊平均负载(Load Average)的话题. 上一讲提到过 CPU Cgroup 可以限制进程的 CPU 资源使用, 但是 CPU Cgroup 对容器的资源限制是存在盲点的. 什么盲点呢? 就是<strong>无法通过 CPU Cgroup 来控制 Load Average 的平均负载. 而没有这个限制, 就会影响系统资源的合理调度, 很可能导致系统变得很慢</strong>.</p> <p>本节讲一下为什么加了 CPU Cgroup 的配置后, 即使保证了容器的 CPU 资源, 容器中的进程还是会运行得很慢?</p> <h5 id="_1-问题再现-3"><a href="#_1-问题再现-3" class="header-anchor">#</a> 1.问题再现</h5> <p>在 Linux 的系统维护中, 需要经常查看 CPU 使用情况, 再根据这个情况分析系统整体的运行状态. 有时候你可能会发现, 明明容器里所有进程的 CPU 使用率都很低, 甚至<strong>整个宿主机的 CPU 使用率都很低, 而机器的 Load Average 里的值却很高, 容器里进程运行得也很慢</strong>.</p> <p>这么说有些抽象, 一起动手再现一下这个情况, 就能更好地理解这个问题了. 比如说下面的 top 输出, 第三行可以显示当前的 CPU 使用情况, 可以看到整个机器的 CPU Usage 几乎为 0, 因为 &quot;id&quot; 显示 99.9%, 这说明 CPU 是处于<strong>空闲状态</strong>的. 但请注意, 这里 1 分钟的 &quot;load average&quot; 的值却高达 9.09, 这里的数值 9 几乎就意味着使用了 9 个 CPU 了, 这样 CPU Usage 和 Load Average 的数值看上去就很矛盾了.</p> <p><img src="/img/29114db9f607f6409ce678bb27d852be-20230731161430-cuc9yoq.png" alt=""></p> <p>那问题来了, 在看一个系统里 CPU 使用情况时, 到底是看 CPU Usage 还是 Load Average 呢? 这里就涉及到本节要解决的两大问题: Load Average 到底是什么, CPU Usage 和 Load Average 有什么差别? 如果 Load Average 值升高, 应用的性能下降了, 这背后的原因是什么呢?</p> <h5 id="_2-什么是load-average"><a href="#_2-什么是load-average" class="header-anchor">#</a> 2.什么是Load Average?</h5> <p>Load Average 这个概念, 可能在使用 Linux 的时候就已经注意到了, 无论是运行 uptime, 还是 top, 都可以看到类似这个输出 &quot;<strong>load average</strong>: 2.02, 1.83, 1.20&quot;. 那么这一串输出到底是什么意思呢?</p> <p>最直接的办法当然是看手册了, 如果用 &quot;Linux manual page&quot; 搜索 uptime 或者 top, 就会看到对这个 &quot;load average&quot; 和后面三个数字的解释是 &quot;<strong>the system load averages for the past 1, 5, and 15 minutes</strong>&quot;. 这个解释就是说, 后面的三个数值分别代表<strong>过去 1 分钟, 5 分钟, 15 分钟在这个节点上的 Load Average</strong>, 但是看了手册上的解释, 还是不能理解什么是 Load Average.</p> <p>如果再去网上找资料, 就会发现 Load Average 是一个很古老的概念了. 上个世纪 70 年代, 早期的 Unix 系统上就已经有了这个 Load Average, IETF 还有一个 RFC546 定义了 Load Average, 这里定义的 Load Average 是**一种 CPU 资源需求的度量.  ** 举个例子, <strong>对于一个单个 CPU 的系统, 如果在 1 分钟的时间里, 处理器上始终有一个进程在运行, 同时操作系统的进程可运行队列中始终都有 9 个进程在等待获取 CPU 资源. 那么对于这 1 分钟的时间来说, 系统的 &quot;load average&quot; 就是 1+9=10</strong>, 这个定义对绝大部分的 Unix 系统都适用.</p> <p>对于 Linux 来说, <mark><strong>如果只考虑 CPU 的资源, Load Averag 等于单位时间内正在运行的进程加上可运行队列的进程, 这个定义也是成立的</strong></mark>. 通过这个定义归纳了下面三点对 Load Average 的理解.</p> <ul><li>第一, 不论计算机 CPU 是空闲还是满负载, Load Average 都是 Linux 进程调度器中**可运行队列(Running Queue)里的一段时间的平均进程数目. **</li> <li>第二, 计算机上的 <strong>CPU 还有空闲的情况下, CPU Usage 可以直接反映到 &quot;load average&quot; 上</strong>, 什么是 CPU 还有空闲呢? 具体来说就是<strong>可运行队列中的进程数目小于 CPU 个数</strong>, 这种情况下, 单位时间进程 CPU Usage 相加的平均值应该就是 &quot;load average&quot; 的值.</li> <li>第三, 计算机上的 <strong>CPU 满负载</strong>的情况下, 计算机上的 CPU 已经是满负载了, 同时还有更多的进程在排队需要 CPU 资源. 这时 &quot;load average&quot; 就不能和 CPU Usage 等同了.</li></ul> <p>比如对于单个 CPU 的系统, CPU Usage 最大只是有 100%, 也就 1 个 CPU; 而 &quot;load average&quot; 的值可以<strong>远远大于 1</strong>, 因为 &quot;load average&quot; 看的是操作系统中<strong>可运行队列中进程的个数</strong>.</p> <p>这样的解释可能太抽象了, 为了方便理解, 一起动手验证一下. 怎么验证呢? 可以执行个程序来模拟一下, 先准备好一个可以消耗任意 CPU Usage 的程序, 在执行这个程序的时候, 后面加个数字作为参数. 比如下面的设置, 参数是 2, 就是说这个<strong>进程会创建出两个线程</strong>, 并且每个线程都跑满 100% 的 CPU, 2 个线程就是 2 * 100% = 200% 的 CPU Usage, 也就是消耗了整整两个 CPU 的资源.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># ./threads-cpu 2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>准备好了这个 CPU Usage 的模拟程序, 就可以用它来查看 CPU Usage 和 Load Average 之间的关系了.</p> <p>接下来一起跑两个例子, 第一个例子是执行 2 个满负载的线程, 第二个例子执行 6 个满负载的线程, 同样都是在一台 <strong>4 个 CPU</strong> 的节点上.</p> <p>先来看第一个例子, 在一台 4 个 CPU 的计算机节点上运行刚才这个模拟程序, 还是设置参数为 2, 也就是使用 2 个 CPU Usage. 在这个程序运行了几分钟之后, 运行 top 来查看一下 CPU Usage 和 Load Average. 可以看到两个 threads-cpu 各自都占了将近 100% 的 CPU, 两个就是 200%, 2 个 CPU, 对于 4 个 CPU 的计算机来说, <strong>CPU Usage 占了 50%</strong> , 空闲了一半, 这个我们也可以从 idle (id): 49.9% 得到印证. 这时候, Load Average 里第一项(也就是前 1 分钟的数值)为 <strong>1.98</strong>, 近似于 2. 这个值和一直运行的 200%CPU Usage 相对应, 也验证了之前归纳的第二点--- CPU 未满负载时 **CPU Usage 可以反映到 Load Average 上. **</p> <p>因为运行的时间不够, 前 5 分钟, 前 15 分钟的 Load Average 还没有到 2, 而且后面的例子程序一般都只会运行几分钟, 所以这里只看前 1 分钟的 Load Average 值就行. 另外, Linux 内核中<strong>不使用浮点计算</strong>, 这导致 Load Average 里的 1 分钟, 5 分钟, 15 分钟的时间值并不精确, 但这不影响查看 Load Average 的数值, 所以先不用管这个时间的准确性.</p> <p><img src="/img/77a6eaf2658556c4dfea076b38c82514-20230731161430-xq9ygnj.png" alt=""></p> <p>再来跑第二个例子, 同样在这个 4 个 CPU 的计算机节点上, 如果执行 CPU Usage 模拟程序 threads-cpu, 设置参数为 6, 让这个进程建出 6 个线程, 这样<strong>每个线程都会尽量去抢占 CPU, 但是计算机总共只有 4 个 CPU, 所以这 6 个线程的 CPU Usage 加起来只是 400%</strong> . 显然这时候 4 个 CPU 都被占满了, 可以看到整个节点的 idle(id)也已经是 0.0% 了. 但这个时候, 看看前 1 分钟的 <strong>Load Average</strong>, 数值不是 4 而是 <strong>5.93 接近 6</strong>, 正好模拟了 6 个高 CPU 需求的线程. 这也表明 <strong>Load Average 表示的是一段时间里运行队列中需要被调度的进程 / 线程平均数目</strong>.</p> <p><img src="/img/ae78d71d66f03b07a0c4804558bf74fc-20230731161430-dy7sr5m.png" alt=""></p> <p>讲到这里, 是不是就可以认定 Load Average 就代表一段时间里运行队列中需要被调度的进程或者线程平均数目了呢? 或许对其他的 Unix 系统来说, 这个理解已经够了, 但是<strong>对于 Linux 系统还不能这么认定</strong>.</p> <p>为什么这么说呢? 故事还要从 Linux 早期的历史说起, 那时开发者 Matthias 有这么一个发现, 比如把快速的磁盘换成了慢速的磁盘, 运行同样的负载, 系统的性能是下降的, 但是 Load Average 却没有反映出来. 他发现这是<strong>因为 Load Average 只考虑运行态的进程数目, 而没有考虑等待 I/O 的进程</strong>. 所以他认为 <strong>Load Average 如果只是考虑进程运行队列中需要被调度的进程或线程平均数目是不够的, 因为对于处于 I/O 资源等待的进程都是处于 TASK_UNINTERRUPTIBLE 状态的</strong>. 那他是怎么处理这件事的呢? 估计你也猜到了, 他给内核加一个 patch(补丁), 把处于 <strong>TASK_UNINTERRUPTIBLE</strong> 状态的进程数目也计入了 Load Average 中.</p> <p>在这里又提到了 TASK_UNINTERRUPTIBLE 状态的进程, 再强调一下, **TASK_UNINTERRUPTIBLE 是 Linux 进程状态的一种, 是进程为等待某个系统资源而进入了睡眠的状态, 并且这种睡眠的状态是不能被信号打断的. **</p> <p>**那么对于 Linux 的 Load Average 来说, 除了可运行队列中的进程数目, 等待队列中的 UNINTERRUPTIBLE 进程数目也会增加 Load Average. **</p> <p>为了验证这一点, 可以模拟一下 UNINTERRUPTIBLE 的进程, 来看看 Load Average 的变化.</p> <p>这里做一个 kernel module, 通过一个 /proc 文件系统给用户程序提供一个读取的接口, 只要用户进程读取了这个接口就会进入 UNINTERRUPTIBLE. 这样就可以模拟两个处于 UNINTERRUPTIBLE 状态的进程, 然后查看一下 Load Average 有没有增加.</p> <p>可以发现程序跑了几分钟之后, 前 1 分钟的 Load Average 差不多从 0 增加到了 <strong>2.16</strong>, 节点上 CPU Usage 几乎为 0, idle 为 99.8%. 可以看到, 可运行队列(Running Queue)中的进程数目是 0, 只有休眠队列(Sleeping Queue)中有两个进程, 并且这两个进程显示为 D state 进程, 这个 D state 进程也就是模拟出来的 TASK_UNINTERRUPTIBLE 状态的进程.</p> <p>这个例子<strong>证明了 Linux 将 TASK_UNINTERRUPTIBLE 状态的进程数目计入了 Load Average 中, 所以即使 CPU 上不做任何的计算, Load Average 仍然会升高</strong>. 如果 TASK_UNINTERRUPTIBLE 状态的进程数目有几百几千个, 那么 Load Average 的数值也可以达到几百几千.</p> <p><img src="/img/5a45ad7ca1e4229bf02255c121ae92d7-20230731161430-xiet95g.png" alt=""></p> <p>好了, 到这里就可以准确定义 Linux 系统里的 Load Average 了, 其实也很简单, 只需要记住, <strong>平均负载统计了这两种情况的进程</strong>:</p> <p>**第一种是 Linux 进程调度器中可运行队列(Running Queue)一段时间(1 分钟, 5 分钟, 15 分钟)的进程平均数. **</p> <p>**第二种是 Linux 进程调度器中休眠队列(Sleeping Queue)里的一段时间的 TASK_UNINTERRUPTIBLE 状态下的进程平均数. **</p> <p>所以最后的公式就是: <strong>==Load Average= 可运行队列进程平均数 + 休眠队列中不可打断的进程平均数==</strong></p> <p>如果打个比方来说明 Load Average 的统计原理. 可以想象<strong>每个 CPU 就是一条道路, 每个进程都是一辆车</strong>, 怎么科学统计道路的平均负载呢? 就是看单位时间通过的车辆, 一条道上的车越多, 那么这条道路的负载也就越高. 此外, Linux 计算系统负载的时候, 还额外做了个补丁把 TASK_UNINTERRUPTIBLE 状态的进程也考虑了, 这个就像道路中要把<strong>红绿灯情况</strong>也考虑进去. 一旦有了红灯, 汽车就要停下来排队, 那么即使道路很空, 但是红灯多了, 汽车也要排队等待, 也开不快.</p> <h5 id="_3-现象解释-为什么-load-average会升高"><a href="#_3-现象解释-为什么-load-average会升高" class="header-anchor">#</a> 3.现象解释:为什么 Load Average会升高?</h5> <p>解释了 Load Average 这个概念, 再回到这一讲最开始的问题, 为什么对容器已经用 CPU Cgroup 限制了它的 CPU Usage, 容器里的进程还是可以<strong>造成整个系统很高的 Load Average</strong>.</p> <p>前面理解了 Load Average 这个概念之后, 就能区分出 Load Averge 和 CPU 使用率的区别了. 那么这个看似矛盾的问题也就很好回答了, 因为 <mark><strong>Linux 下的 Load Averge 不仅仅计算了 CPU Usage 的部分, 它还计算了系统中 TASK_UNINTERRUPTIBLE 状态的进程数目</strong></mark>​ **. **</p> <p>讲到这里为止, 找到了第一个问题的答案, 那么现在再看第二个问题: 如果 Load Average 值升高, 应用的性能已经下降了, 真正的原因是什么? 问题就出在 <strong>TASK_UNINTERRUPTIBLE</strong> 状态的进程上了.</p> <p>怎么验证这个判断呢? 这时候只要运行 <code>ps aux | grep &quot; D &quot;</code>​, 就可以看到容器中有多少 TASK_UNINTERRUPTIBLE 状态(在 ps 命令中这个状态的进程标示为 &quot;D&quot; 状态)的进程, 为了方便理解, 后面简称为 D 状态进程. 而正是这些 D 状态进程引起了 Load Average 的升高.</p> <p>找到了 Load Average 升高的问题出在 D 状态进程了, 想要真正解决问题, 还有必要了解 <strong>D 状态进程产生的本质</strong>是什么?</p> <p>在 Linux 内核中有数百处<strong>调用点</strong>, 它们会<strong>把进程设置为 D 状态, 主要集中在 disk I/O 的访问和信号量(Semaphore)锁的访问上, 因此 D 状态的进程在 Linux 里是很常见的</strong>. <strong>无论是对 disk I/O 的访问还是对信号量的访问, 都是对 Linux 系统里的资源的一种竞争. ** 当进程处于 D 状态时, 就说明</strong>进程还没获得资源**, 这会在应用程序的最终性能上体现出来, 也就是说用户会发觉应用的性能下降了.</p> <p>那么 D 状态进程导致了性能下降, 肯定是想方设法去做调试的. 但目前 D 状态进程引起的<strong>容器中</strong>进程性能下降问题, Cgroups 还不能解决, 这也就是为什么用 Cgroups 做了配置, 即使保证了容器的 CPU 资源, 容器中的进程还是运行很慢的根本原因.</p> <p>这里进一步做分析, 为什么 CPU Cgroups 不能解决这个问题呢? 就是<strong>因为 Cgroups 更多的是以进程为单位进行隔离, 而 D 状态进程是内核中系统全局资源引入的, 所以 Cgroups 影响不了它</strong>.</p> <p>所以可以做的是, <strong>在生产环境中监控容器的宿主机节点里 D 状态的进程数量, 然后对 D 状态进程数目异常的节点进行分析, 比如磁盘硬件出现问题引起 D 状态进程数目增加, 这时就需要更换硬盘</strong>.</p> <h5 id="_4-重点总结-4"><a href="#_4-重点总结-4" class="header-anchor">#</a> 4.重点总结</h5> <p>这一讲从 CPU Usage 和 Load Average 差异这个现象讲起, 最主要的目的是讲清楚 Linux 下的 Load Average 这个概念.</p> <p>在其他 Unix 操作系统里 Load Average 只考虑 CPU 部分, <strong>Load Average 计算的是进程调度器中可运行队列(Running Queue)里的一段时间(1 分钟, 5 分钟, 15 分钟)的平均进程数目, 而 Linux 在这个基础上, 又加上了进程调度器中休眠队列(Sleeping Queue)里的一段时间的 TASK_UNINTERRUPTIBLE 状态的平均进程数目</strong>.</p> <p>这里需要重点掌握 Load Average 的计算公式, 如下图.</p> <p><img src="/img/0538bbc4ed03446a23be251ed2877486-20230731161430-p9d3c2n.png" alt=""></p> <p>因为 <strong>TASK_UNINTERRUPTIBLE</strong> 状态的进程同样也会竞争系统资源, 所以它会影响到应用程序的性能. 可以在容器宿主机的节点对 D 状态进程做监控, 定向分析解决.</p> <p>最后强调一下, 这一讲中提到的对 D 状态进程进行监控也很重要, 因为这是通用系统性能的监控方法.</p> <h3 id="容器内存"><a href="#容器内存" class="header-anchor">#</a> 容器内存</h3> <h4 id="_08-容器内存-我的容器为什么被杀了"><a href="#_08-容器内存-我的容器为什么被杀了" class="header-anchor">#</a> 08 | 容器内存:我的容器为什么被杀了?</h4> <p>从这一讲内容开始进入<strong>容器内存</strong>这个模块. 在使用容器的时候, 一定会伴随着 <strong>Memory Cgroup</strong>. 而 Memory Cgroup 给 Linux 原本就复杂的内存管理带来了新的变化, 下面就来学习这一块内容.</p> <p>本节来解决容器在系统中消失的问题.</p> <p>不知道你在使用容器时, 有没有过这样的经历? <strong>一个容器在系统中运行一段时间后, 突然消失了, 看看自己程序的 log 文件, 也没发现什么错误, 不像是自己程序 Crash, 但是容器就是消失了</strong>.</p> <p>那么这是怎么回事呢? 接下来就一起来 &quot;破案&quot;.</p> <h5 id="_1-问题再现-4"><a href="#_1-问题再现-4" class="header-anchor">#</a> 1.问题再现</h5> <p>**容器在系统中被杀掉, 其实只有一种情况, 那就是容器中的进程使用了太多的内存. 具体来说, 就是容器里所有进程使用的内存量, 超过了容器所在 Memory Cgroup 里的内存限制. 这时 Linux 系统就会主动杀死容器中的一个进程, 往往这会导致整个容器的退出. **</p> <p>可以做个简单的容器, 模拟一下这种容器被杀死的场景. 做容器的 Dockerfile 和代码, 可以从这里获得. 接下来用下面的这个脚本来启动容器, 先把这个容器的 Cgroup 内存上限设置为 512MB(536870912 bytes).</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token function">docker</span> stop mem_alloc<span class="token punctuation">;</span><span class="token function">docker</span> <span class="token function">rm</span> mem_alloc
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> mem_alloc registry/mem_alloc:v1
<span class="token function">sleep</span> <span class="token number">2</span>
<span class="token assign-left variable">CONTAINER_ID</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">sudo</span> <span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">--format</span> <span class="token string">&quot;{{.ID}}<span class="token entity" title="\t">\t</span>{{.Names}}&quot;</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> mem_alloc <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $1}'</span><span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token variable">$CONTAINER_ID</span>
<span class="token assign-left variable">CGROUP_CONTAINER_PATH</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">find</span> /sys/fs/cgroup/memory/ <span class="token parameter variable">-name</span> <span class="token string">&quot;*<span class="token variable">$CONTAINER_ID</span>*&quot;</span><span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token variable">$CGROUP_CONTAINER_PATH</span>
<span class="token builtin class-name">echo</span> <span class="token number">536870912</span> <span class="token operator">&gt;</span> <span class="token variable">$CGROUP_CONTAINER_PATH</span>/memory.limit_in_bytes
<span class="token function">cat</span> <span class="token variable">$CGROUP_CONTAINER_PATH</span>/memory.limit_in_bytes
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>容器启动后, 里面有一个小程序 mem_alloc 会不断地申请内存. 当它申请的内存超过 512MB 的时候, 你就会发现, 启动的这个容器消失了.</p> <p><img src="/img/8adb2c20396030b1dd7f7370d93ec919-20230731161430-ly7a004.png" alt=""></p> <p>这时候, 如果运行 <code>docker inspect</code>​ 命令查看容器退出的原因, 就会看到容器处于 &quot;exited&quot; 状态, 并且 &quot;<strong>OOMKilled</strong>&quot; 是 true.</p> <p><img src="/img/b154de19653b84d926399427867b47d8-20230731161430-tk3rnv9.png" alt=""></p> <p>那么问题来了, 什么是 OOM Killed 呢? 它和之前对容器 Memory Cgroup 做的设置有什么关系, 又是怎么引起容器退出的? 想搞清楚这些问题, 就需要先理清楚基本概念.</p> <h6 id="_1-如何理解oom-killer"><a href="#_1-如何理解oom-killer" class="header-anchor">#</a> (1)如何理解OOM Killer?</h6> <p>先来看一看 OOM Killer 是什么意思. OOM 是 Out of Memory 的缩写, 顾名思义就是内存不足的意思, 而 Killer 在这里指需要杀死某个进程. 那么 OOM Killer 就是<mark><strong>在 Linux 系统里如果内存不足时, 就需要杀死一个正在运行的进程来释放一些内存</strong></mark>​ **. **</p> <p>那么讲到这里, 你可能会有个问题了, Linux 里的程序都是<strong>调用 malloc() 来申请内存, 如果内存不足, 直接 malloc() 返回失败就可以, 为什么还要去杀死正在运行的进程</strong>呢? 其实这个和 Linux 进程的内存申请策略有关, Linux 允许进程在申请内存的时候是 overcommit 的, 这是什么意思呢? 就是说允许进程申请超过实际物理内存上限的内存.</p> <p>为了更好地理解, 我举个例子说明. 比如节点上的空闲物理内存只有 512MB 了, 但是如果一个进程调用 malloc() 申请了 600MB, 那么 malloc() 的这次申请还是被<strong>允许</strong>的. 这是因为 malloc() 申请的是<strong>内存的虚拟地址, 系统只是给了程序一个地址范围, 由于没有写入数据, 所以程序并没有得到真正的物理内存. 物理内存只有程序真的往这个地址写入数据的时候, 才会分配给程序</strong>.</p> <p>可以看得出来, 这种 overcommit 的内存申请模式可以带来一个好处, 它可以有效提高系统的内存利用率. 不过这也带来了一个问题, 就是物理内存真的不够了, 又该怎么办呢? 打个比方, 这个有点像航空公司在卖飞机票. 售卖飞机票的时候往往是<strong>超售</strong>的. 比如实际上有 100 个位子, 航空公司会卖 105 张机票, 在登机的时候如果实际登机的乘客超过了 100 个, 那么就需要按照一定规则, 不允许多出的几位乘客登机了.</p> <p>同样的道理, 遇到内存不够的这种情况, <strong>Linux 采取的措施就是杀死某个正在运行的进程</strong>.</p> <p>那么一定会问了, 在发生 OOM 的时候, Linux 到底是根据<strong>什么标准</strong>来选择被杀的进程呢? 这就要提到一个在 Linux 内核里有一个 <strong>oom_badness() 函数</strong>, 就是它定义了选择进程的标准. 其实这里的判断标准也很简单, 函数中涉及两个条件:</p> <p>第一, <strong>进程已经使用的物理内存页面数</strong>.</p> <p>第二, <strong>每个进程的 OOM 校准值 oom_score_adj</strong>. 在 /proc 文件系统中, 每个进程都有一个 /proc//oom_score_adj 的接口文件. 可以在这个文件中输入 -1000 到 1000 之间的任意一个数值, 调整进程<strong>被 OOM Kill 的几率</strong>.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>adj <span class="token operator">=</span> <span class="token punctuation">(</span>long<span class="token punctuation">)</span>p-<span class="token operator">&gt;</span>signal-<span class="token operator">&gt;</span>oom_score_adj<span class="token punctuation">;</span>
points <span class="token operator">=</span> get_mm_rss<span class="token punctuation">(</span>p-<span class="token operator">&gt;</span>mm<span class="token punctuation">)</span> + get_mm_counter<span class="token punctuation">(</span>p-<span class="token operator">&gt;</span>mm, MM_SWAPENTS<span class="token punctuation">)</span> +mm_pgtables_bytes<span class="token punctuation">(</span>p-<span class="token operator">&gt;</span>mm<span class="token punctuation">)</span> / PAGE_SIZE<span class="token punctuation">;</span>
adj *<span class="token operator">=</span> totalpages / <span class="token number">1000</span><span class="token punctuation">;</span>
points <span class="token operator">+=</span> adj<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>结合前面说的两个条件, 函数 oom_badness() 里的最终计算方法是这样的:</p> <p>**用系统总的可用页面数, 去乘以 OOM 校准值 oom_score_adj, 再加上进程已经使用的物理页面数, 计算出来的值越大, 那么这个进程被 OOM Kill 的几率也就越大. **</p> <h6 id="_2-如何理解memory-cgroup"><a href="#_2-如何理解memory-cgroup" class="header-anchor">#</a> (2)如何理解Memory Cgroup?</h6> <p>前面介绍了 OOM Killer, 容器发生 OOM Kill 大多是因为 Memory Cgroup 的限制所导致的, 所以在还需要<strong>理解 Memory Cgroup 的运行机制</strong>. 前面讲过 Cgroups 是容器的两大支柱技术之一, 在 CPU 的章节中, 也讲到了 CPU Cgroups. 那么按照同样的思路, 想理解容器 Memory, 自然要讨论一下 Memory Cgroup 了.</p> <p>**Memory Cgroup 也是 Linux Cgroups 子系统之一, 它的作用是对一组进程的 Memory 使用做限制. Memory Cgroup 的虚拟文件系统的挂载点一般在 &quot;/sys/fs/cgroup/memory&quot; 这个目录下, 这个和 CPU Cgroup 类似. 可以在 Memory Cgroup 的挂载点目录下, 创建一个子目录作为控制组. **</p> <p>每一个控制组下面有不少参数, 在这一讲里, 这里只讲跟 OOM 最相关的 3 个参数: <strong>memory.limit_in_bytes, memory.oom_control 和 memory.usage_in_bytes</strong>. 其他参数如果有兴趣, 可以参考内核的文档说明.</p> <p>首先来看第一个参数 <strong>memory.limit_in_bytes</strong>. 请注意, 这个 memory.limit_in_bytes 是每个控制组里<strong>最重要</strong>的一个参数了. 这是因为<mark><strong>一个控制组里所有进程可使用内存的最大值, 就是由这个参数的值来直接限制的</strong></mark>.</p> <p>那么一旦达到了最大值, 在这个控制组里的进程会发生什么呢?</p> <p>这就涉及到第二个参数 <strong>memory.oom_control</strong> 了. 这个 memory.oom_control 又是干啥的呢? 当控制组中的进程内存使用达到上限值时, 这个参数<strong>能够决定会不会触发 OOM Killer</strong>. 如果没有人为设置的话, memory.oom_control 的缺省值默认就会触发 OOM Killer. 这是一个控制组内的 OOM Killer, 和整个系统的 OOM Killer 的功能差不多, 差别只是被杀进程的选择范围: 控制组内的 OOM Killer 当然只能杀死控制组内的进程, 而不能选节点上的其他进程. 如果要改变缺省值, 也就是不希望触发 OOM Killer, 只要执行 <code>echo 1 &gt; memory.oom_control</code>​ 就行了, 这时候即使控制组里所有进程使用的内存达到 memory.limit_in_bytes 设置的上限值, <strong>控制组也不会杀掉里面的进程</strong>.</p> <p>需要注意这样操作以后, 就会<strong>影响到控制组中正在申请物理内存页面的进程</strong>. 这些进程会处于一个停止状态, 不能往下运行了.</p> <p>最后第三个参数, 也就是 <strong>memory.usage_in_bytes</strong>. 这个参数是只读的, 它里面的数值是当前控制组里<strong>所有进程实际使用的内存总和</strong>. 可以查看这个值, 然后把它和 memory.limit_in_bytes 里的值做比较, 根据接近程度来可以做个预判. 这两个值越接近, OOM 的风险越高. 通过这个方法就可以得知, 当前控制组内使用总的内存量有没有 OOM 的风险了.</p> <p>控制组之间也同样是树状的<strong>层级结构</strong>, 在这个结构中, 父节点的控制组里的 memory.limit_in_bytes 值, 就可以限制它的子节点中所有进程的内存使用.</p> <p>用一个具体例子来说明, 比如像下面图里展示的那样, group1 里的 memory.limit_in_bytes 设置的值是 200MB, 它的子控制组 group3 里 memory.limit_in_bytes 值是 500MB. 那么在 group3 里所有进程使用的内存总值就不能超过 200MB, 而不是 500MB.</p> <p><img src="/img/2a497b0a2e293ecf4200dc5d38c598ad-20230731161430-ufku8zx.png" alt=""></p> <p>这里介绍了 Memory Cgroup 最基本的概念, 简单总结一下:</p> <p>第一, Memory Cgroup 中每一个控制组可以为一组进程限制内存使用量, 一旦所有进程使用内存的总量达到限制值, 缺省情况下, 就会触发 OOM Killer. 这样一来, 控制组里的 &quot;某个进程&quot; 就会被杀死.</p> <p>第二, 这里杀死 &quot;某个进程&quot; 的选择标准是, **控制组中总的可用页面乘以进程的 oom_score_adj, 加上进程已经使用的物理内存页面, 所得值最大的进程, 就会被系统选中杀死. **</p> <h5 id="_2-解决问题"><a href="#_2-解决问题" class="header-anchor">#</a> 2.解决问题</h5> <p>解释了 Memory Cgroup 和 OOM Killer 后, 你应该明白了为什么容器在运行过程中会突然消失了. 对于每个容器创建后, 系统都会为它<strong>建立一个 Memory Cgroup 的控制组, 容器的所有进程都在这个控制组里</strong>.</p> <p>一般的容器云平台, 比如 Kubernetes 都会为容器设置一个<strong>内存使用的上限</strong>. 这个内存的上限值会被写入 Cgroup 里, 具体来说就是容器对应的 Memory Cgroup 控制组里 <strong>memory.limit_in_bytes</strong> 这个参数中.  所以一旦容器中<strong>进程使用的内存达到了上限值</strong>, OOM Killer 会杀死进程使容器退出.</p> <p>**那么怎样才能快速确定容器发生了 OOM 呢? 这个可以通过查看内核日志及时地发现. **</p> <p>还是拿这一讲最开始发生 OOM 的容器作为例子. 通过查看内核的日志, 使用用 <code>journal -k</code>​ 命令, 或者直接查看日志文件  <strong>/var/log/message</strong>, 会发现当容器发生 OOM Kill 的时候, 内核会输出下面的这段信息, 大致包含下面这三部分的信息:</p> <p>第一个部分就是**容器里每一个进程使用的内存页面数量. ** 在 &quot;rss&quot; 列里, &quot;rss&quot; 是 Resident Set Size 的缩写, 指的就是进程真正在使用的物理内存页面数量.</p> <p>比如下面的日志里, 看到 init 进程的 &quot;rss&quot; 是 1 个页面, mem_alloc 进程的 &quot;rss&quot; 是 130801 个页面, 内存页面的大小一般是 4KB, 可以做个估算, 130801 * 4KB 大致等于 512MB.</p> <p><img src="/img/b8796ec34cc2fffec4ca808517868b05-20230731161430-402r009.png" alt=""></p> <p>第二部分来看上面图片的  <strong>&quot;oom-kill:&quot;</strong>  这行, 这一行里列出了发生 OOM 的 <strong>Memroy Cgroup 的控制组</strong>, 可以从控制组的信息中知道 OOM 是在哪个容器发生的.</p> <p>第三部分是图中  **&quot;Killed process 7445 (mem_alloc)&quot; 这行, 它显示了最终被 OOM Killer 杀死的进程. **</p> <p>通过了解内核日志里的这些信息, 可以很快地判断出容器是因为 OOM 而退出的, 并且还可以知道是哪个进程消耗了最多的 Memory.</p> <p>那么知道了哪个进程消耗了最大内存之后, 就可以有针对性地对这个进程进行分析了, 一般有这两种情况:</p> <p>第一种情况是<strong>这个进程本身的确需要很大的内存</strong>, 这说明给 memory.limit_in_bytes 里的内存上限值设置小了, 那么就需要增大内存的上限值.</p> <p>第二种情况是**进程的代码中有 Bug, 会导致内存泄漏, 进程内存使用到达了 Memory Cgroup 中的上限. ** 如果是这种情况, 就需要具体去解决代码里的问题了.</p> <h5 id="_3-重点总结-3"><a href="#_3-重点总结-3" class="header-anchor">#</a> 3.重点总结</h5> <p>本节从容器在系统中被杀的问题, 学习了 OOM Killer 和 Memory Cgroup 这两个概念. OOM Killer 这个行为在 Linux 中很早就存在了, 它其实是<strong>一种内存过载后的保护机制, 通过牺牲个别的进程, 来保证整个节点的内存不会被全部消耗掉</strong>.</p> <p>在 Cgroup 的概念出现后, Memory Cgroup 中每一个控制组可以对一组进程限制内存使用量, 一旦所有进程使用内存的总量达到限制值, 在缺省情况下, 就会触发 OOM Killer, 控制组里的 &quot;某个进程&quot; 就会被杀死.</p> <p>请注意, 这里 Linux 系统肯定不能随心所欲地杀掉进程, 那具体要用什么选择标准呢? 杀掉 &quot;某个进程&quot; 的选择标准, 涉及到内核函数 oom_badness(). 具体的计算方法是: **系统总的可用页面数乘以进程的 OOM 校准值 oom_score_adj, 再加上进程已经使用的物理页面数, 计算出来的值越大, 那么这个进程被 OOM Kill 的几率也就越大. **</p> <p>接下来, 讲解了 Memory Cgroup 里最基本的三个参数, 分别是 **memory.limit_in_bytes,  memory.oom_control 和 memory.usage_in_bytes. ** 这里把这三个参数的作用, 总结成了一张图. 第一个和第三个参数, 下一节还会用到, 这里可以先有个印象.</p> <p><img src="/img/9222abe8d22c30daccffdfd23e95d13c-20230731161430-qffk334.png" alt=""></p> <p>容器因为 OOM 被杀, 要如何处理呢? <strong>可以通过内核日志做排查, 查看容器里内存使用最多的进程, 然后对它进行分析</strong>. 根据经验, <strong>解决思路要么是提高容器的最大内存限制, 要么需要具体去解决进程代码的 BUG</strong>.</p> <h4 id="_09-page-cache-为什么我的容器内存使用量总是在临界点"><a href="#_09-page-cache-为什么我的容器内存使用量总是在临界点" class="header-anchor">#</a> 09 | Page Cache:为什么我的容器内存使用量总是在临界点?</h4> <p>上一节讲了 Memory Cgroup 是如何控制一个容器的内存的. 如果容器使用的物理内存超过了 Memory Cgroup 里的 memory.limit_in_bytes 值, 那么容器中的进程会被 OOM Killer 杀死.</p> <p>不过在一些容器的使用场景中, 比如容器里的应用有很多文件读写, 你会发现<strong>整个容器的内存使用量已经很接近 Memory Cgroup 的上限值了, 但是在容器中接着再申请内存, 还是可以申请出来, 并且没有发生 OOM</strong>.</p> <p>这是怎么回事呢? 本节就来聊聊这个问题.</p> <h5 id="_1-问题再现-5"><a href="#_1-问题再现-5" class="header-anchor">#</a> 1.问题再现</h5> <p>可以用这里的代码做个容器镜像, 然后用下面的这个脚本启动容器, 并且设置容器 Memory Cgroup 里的内存上限值是 <strong>100MB</strong>(104857600bytes).</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token function">docker</span> stop page_cache<span class="token punctuation">;</span><span class="token function">docker</span> <span class="token function">rm</span> page_cache
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token parameter variable">-f</span> ./test.file <span class="token punctuation">]</span>
<span class="token keyword">then</span>
  <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>./test.file <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">4096</span> <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">30000</span>
  <span class="token builtin class-name">echo</span> <span class="token string">&quot;Please run start_container.sh again &quot;</span>
  <span class="token builtin class-name">exit</span> <span class="token number">0</span>
<span class="token keyword">fi</span>
<span class="token builtin class-name">echo</span> <span class="token number">3</span> <span class="token operator">&gt;</span> /proc/sys/vm/drop_caches
<span class="token function">sleep</span> <span class="token number">10</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--init</span> <span class="token parameter variable">--name</span> page_cache <span class="token parameter variable">-v</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>:/mnt registry/page_cache_test:v1
<span class="token assign-left variable">CONTAINER_ID</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">sudo</span> <span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">--format</span> <span class="token string">&quot;{{.ID}}<span class="token entity" title="\t">\t</span>{{.Names}}&quot;</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> page_cache <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $1}'</span><span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token variable">$CONTAINER_ID</span>
<span class="token assign-left variable">CGROUP_CONTAINER_PATH</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">find</span> /sys/fs/cgroup/memory/ <span class="token parameter variable">-name</span> <span class="token string">&quot;*<span class="token variable">$CONTAINER_ID</span>*&quot;</span><span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token number">104857600</span> <span class="token operator">&gt;</span> <span class="token variable">$CGROUP_CONTAINER_PATH</span>/memory.limit_in_bytes
<span class="token function">cat</span> <span class="token variable">$CGROUP_CONTAINER_PATH</span>/memory.limit_in_bytes
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>把容器启动起来后, 查看一下容器的 Memory Cgroup 下的 <strong>memory.limit_in_bytes 和 memory.usage_in_bytes</strong> 这两个值. 如下图所示, 可以看到容器内存的上限值设置为 104857600bytes(100MB), 而这时整个容器的已使用内存显示为 104767488bytes, 这个值已经<strong>非常接近上限</strong>值了.</p> <p>把容器内存上限值和已使用的内存数值做个减法, 104857600–104767488 = 90112bytes, 只差大概 90KB 左右的大小.</p> <p><img src="/img/7b592679c71cd6bd0ebecd5e31618855-20230731161430-or4mkd3.png" alt=""></p> <p>但如果这时候继续启动一个程序, 让这个程序申请并使用 50MB 的物理内存, 就会发现这个程序还是可以运行成功, 这时候容器并没有发生 OOM 的情况. 这时再去查看参数 memory.usage_in_bytes, 就会发现它的值变成了 103186432bytes, 比之前还少了一些. 那这是怎么回事呢?</p> <p><img src="/img/b2df2152bed5d65857348fa3ea39f6fe-20230731161430-q5ou4v5.png" alt=""></p> <h5 id="_2-知识详解-linux-系统有那些内存类型"><a href="#_2-知识详解-linux-系统有那些内存类型" class="header-anchor">#</a> 2.知识详解:Linux 系统有那些内存类型?</h5> <p>要解释刚才看到的容器里内存分配的现象, 就需要先理解 Linux 操作系统里<strong>有哪几种内存的类型</strong>. 只有知道了内存的类型, 才能明白<strong>每一种类型的内存, 容器分别使用了多少. 而且对于不同类型的内存, 一旦总内存增高到容器里内存最高限制的数值, 相应的处理方式也不同</strong>.</p> <h6 id="_1-linux内存类型"><a href="#_1-linux内存类型" class="header-anchor">#</a> (1)Linux内存类型</h6> <p>Linux 的各个模块都需要内存, 比如内核需要分配内存给页表, 内核栈, 还有 slab, 也就是内核各种数据结构的 Cache Pool; 用户态进程里的堆内存和栈的内存, 共享库的内存, 还有文件读写的 Page Cache.</p> <p>在这一讲里, 讨论的 Memory Cgroup 里都不会对内核的内存做限制(比如页表, slab 等). 所以主要讨论**与用户态相关的两个内存类型, RSS 和 Page Cache. **</p> <h6 id="_2-rss"><a href="#_2-rss" class="header-anchor">#</a> (2)RSS</h6> <p>先看什么是 RSS. RSS 是 <strong>Resident Set Size</strong> 的缩写, 简单来说它就是<strong>指进程真正申请到物理页面的内存大小</strong>. 这是什么意思呢?</p> <p>应用程序在申请内存的时候, 比如调用 malloc() 来申请 100MB 的内存大小, malloc() 返回成功了, 这时候系统其实只是把 100MB 的<strong>虚拟地址空间</strong>分配给了进程, 但是<strong>并没有把实际的物理内存页面分配给进程</strong>. 当进程对<strong>这块内存地址开始做真正读写操作</strong>的时候, 系统才会把实际需要的物理内存分配给进程. 而这个过程中, <strong>进程真正得到的物理内存, 就是这个 RSS 了</strong>.</p> <p>比如下面的这段代码, 先用 malloc 申请 100MB 的内存.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>p <span class="token operator">=</span> malloc<span class="token punctuation">(</span><span class="token number">100</span> * MB<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> NULL<span class="token punctuation">)</span>
    <span class="token builtin class-name">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>然后, 运行 top 命令查看这个程序在运行了 malloc() 之后的内存, 可以看到这个程序的虚拟地址空间(VIRT)已经有了 106728KB(～100MB), 但是实际的物理内存 RSS(top 命令里显示的是 RES, 就是 Resident 的简写, 和 RSS 是一个意思)在这里只有 <strong>688KB</strong>.</p> <p><img src="/img/ee7fda690625dedde1884a2813ec6ab4-20230731161430-8rww7o5.png" alt=""></p> <p>接着在程序里等待 30 秒之后, 再对这块申请的空间里写入 20MB 的数据.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>sleep<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
memset<span class="token punctuation">(</span>p, 0x00, <span class="token number">20</span> * MB<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>当用 memset() 函数对这块地址空间写入 20MB 的数据之后, 再用 top 查看, 这时候可以看到<strong>虚拟地址空间(VIRT)还是 106728, 不过物理内存 RSS(RES)的值变成了 21432(大小约为 20MB)</strong> , 这里的单位都是 KB.</p> <p><img src="/img/84979224b1798db4a16579871fe78c70-20230731161430-a5ebxdm.png" alt=""></p> <p>所以通过刚才上面的小实验, 可以<strong>验证 RSS 就是进程里真正获得的物理内存大小</strong>.</p> <p>对于进程来说, <strong>RSS 内存包含了进程的代码段内存, 栈内存, 堆内存, 共享库的内存, 这些内存是进程运行所必须的</strong>. 刚才通过 malloc/memset 得到的内存, 就是属于堆内存.</p> <p>具体的每一部分的 RSS 内存的大小, 可以查看 <code>/proc/[pid]/smaps</code>​ 文件.</p> <h6 id="_3-page-cache"><a href="#_3-page-cache" class="header-anchor">#</a> (3)Page Cache</h6> <p>每个进程除了各自独立分配到的 RSS 内存外, 如果进程<strong>对磁盘上的文件做了读写操作</strong>, Linux 还会分配内存, <strong>把磁盘上读写到的页面存放在内存中, 这部分的内存就是 Page Cache</strong>.</p> <p><mark>**Page Cache 的主要作用是提高磁盘文件的读写性能, 因为系统调用 read() 和 write() 的缺省行为都会把读过或者写过的页面存放在 Page Cache 里. **</mark></p> <p>还是用这一讲最开始的的例子: 代码程序去读取 100MB 的文件, 在读取文件前, 系统中 Page Cache 的大小是 388MB, 读取后 Page Cache 的大小是 506MB, 增长了大约 100MB 左右, 多出来的这 100MB, 正是读取文件的大小.</p> <p><img src="/img/5c3ad5044e7a40cf94ed5c61d081073b-20230731161430-u2009v9.png" alt=""></p> <p><mark><strong>在 Linux 系统里只要有空闲的内存, 系统就会自动地把读写过的磁盘文件页面放入到 Page Cache 里</strong></mark>. 那么这些内存都被 Page Cache 占用了, 一旦进程需要用到更多的物理内存, 执行 malloc() 调用做申请时, 就会发现剩余的物理内存不够了, 那该怎么办呢?</p> <p>这就要提到 Linux 的内存管理机制了. <mark><strong>Linux 的内存管理有一种内存页面回收机制(page frame reclaim), 会根据系统里空闲物理内存是否低于某个阈值(wartermark), 来决定是否启动内存的回收</strong></mark>​ <strong>.</strong></p> <p>内存回收的算法会根据不同类型的内存以及内存的最近最少用原则, 就是 <strong>LRU</strong>(Least Recently Used)算法决定哪些内存页面先被释放. 因为 Page Cache 的内存页面只是起到 <strong>Cache 作用</strong>, 自然是会被优先释放的.</p> <p>所以, Page Cache 是一种为了提高磁盘文件读写性能而利用空闲物理内存的机制. 同时内存管理中的页面回收机制, 又能保证 Cache 所占用的页面可以及时释放, 这样一来就不会影响程序对内存的真正需求了.</p> <h6 id="_4-rss-page-cache-in-memory-cgroup"><a href="#_4-rss-page-cache-in-memory-cgroup" class="header-anchor">#</a> (4)RSS &amp; Page Cache in Memory Cgroup</h6> <p>学习了 RSS 和 Page Cache 的基本概念之后, 下面来看不同类型的内存, 特别是 RSS 和 Page Cache 是如何影响 Memory Cgroup 的工作的.</p> <p>先从 Linux 的内核代码看一下, 从 mem_cgroup_charge_statistics() 这个函数里, <mark><strong>可以看到 Memory Cgroup 也的确只是统计了 RSS 和 Page Cache 这两部分的内存</strong></mark>.</p> <p>RSS 的内存, 就是在当前 Memory Cgroup 控制组里<strong>所有进程的 RSS 的总和</strong>; 而 Page Cache 这部分内存是<strong>控制组里的进程读写磁盘文件后, 被放入到 Page Cache 里的物理内存</strong>.</p> <p><img src="/img/fe65cad7205d49a4d836eb631a31b614-20230731161430-qbedznp.png" alt=""></p> <p><mark>**Memory Cgroup 控制组里 RSS 内存和 Page Cache 内存的和, 正好是 memory.usage_in_bytes 的值. **</mark></p> <p>当控制组里的进程需要申请新的物理内存, 而且 memory.usage_in_bytes 里的值超过控制组里的内存上限值 memory.limit_in_bytes, 这时前面说的 Linux 的内存回收(page frame reclaim)就会被调用起来.</p> <p>那么在这个控制组里的 page cache 的内存会根据新申请的内存大小<strong>释放一部分</strong>, 这样还是能成功申请到新的物理内存, 整个控制组里总的物理内存开销 memory.usage_in_bytes 还是不会超过上限值 memory.limit_in_bytes.</p> <h5 id="_3-解决问题-3"><a href="#_3-解决问题-3" class="header-anchor">#</a> 3.解决问题</h5> <p>明白了 Memory Cgroup 中内存类型的统计方法, 再回过头看这一讲开头的问题, 为什么 memory.usage_in_bytes 与 memory.limit_in_bytes 的值只相差了 90KB, 在容器中还是可以申请出 50MB 的物理内存?</p> <p>你应该已经知道答案了, <strong>容器里肯定有大于 50MB 的内存是 Page Cache, 因为作为 Page Cache 的内存在系统需要新申请物理内存的时候(作为 RSS)是可以被释放的</strong>.</p> <p>知道了这个答案, 那么怎么来验证呢? 验证的方法也挺简单的, 在 Memory Cgroup 中有一个参数 <strong>memory.stat</strong>, 可以<strong>显示在当前控制组里各种内存类型的实际的开销</strong>.</p> <p>那还是拿本节的容器例子, 再跑一遍代码, 这次要查看一下 memory.stat 里的数据.</p> <p>第一步, 还是用同样的脚本来启动容器, 并且设置好容器的 Memory Cgroup 里的 memory.limit_in_bytes 值为 100MB. 启动容器后, 这次不仅要看 memory.usage_in_bytes 的值, 还要看一下 <strong>memory.stat</strong>. 虽然 memory.stat 里的参数有不少, 但目前只需要关注 &quot;cache&quot; 和 &quot;rss&quot; 这两个值.</p> <p>可以看到, 容器启动后, cache, 也就是 <strong>Page Cache 占的内存是 99508224bytes</strong>, 大概是 99MB, 而 RSS 占的内存只有 1826816bytes, 也就是 1MB 多一点. 这就意味着, 在这个容器的 Memory Cgroup 里<strong>大部分的内存都被用作了 Page Cache, 而这部分内存是可以被回收的</strong>.</p> <p><img src="/img/f1b76a58b7927b89307cd9b8ffda7617-20230731161430-fledclv.png" alt=""></p> <p>那么再执行一下 mem_alloc 程序, 申请 50MB 的物理内存. 可以再来查看一下 memory.stat, 这时候 <strong>cache 的内存值降到了 46632960bytes, 大概 46MB</strong>, 而 rss 的内存值到了 54759424bytes, 54MB 左右吧. 总的 memory.usage_in_bytes 值和之前相比, 没有太多的变化.</p> <p><img src="/img/4e08dadceabc075d15469d047f4cb369-20230731161430-rni4t79.png" alt=""></p> <p>从这里发现, Page Cache 内存对判断容器实际内存使用率的影响, <strong>目前 Page Cache 完全就是 Linux 内核的一个自动的行为, 只要读写磁盘文件, 只要有空闲的内存, 就会被用作 Page Cache</strong>.</p> <p>所以, 判断容器真实的内存使用量, <strong>不能用 Memory Cgroup 里的 memory.usage_in_bytes, 而需要用 memory.stat 里的 rss 值</strong>. 这个很像用 free 命令查看节点的可用内存, 不能看 &quot;free&quot; 字段下的值, 而要看除去 Page Cache 之后的 &quot;<strong>available</strong>&quot; 字段下的值.</p> <h5 id="_4-重点总结-5"><a href="#_4-重点总结-5" class="header-anchor">#</a> 4.重点总结</h5> <p>每个容器的 Memory Cgroup 在统计每个控制组的内存使用时包含了两部分, RSS 和 Page Cache. <strong>RSS 是每个进程实际占用的物理内存, 它包括了进程的代码段内存, 进程运行时需要的堆和栈的内存, 这部分内存是进程运行所必须的</strong>. **Page Cache 是进程在运行中读写磁盘文件后, 作为 Cache 而继续保留在内存中的, 它的目的是为了提高磁盘文件的读写性能. **</p> <p>当节点的内存紧张或者 Memory Cgroup 控制组的内存达到上限的时候, Linux 会对内存做回收操作, 这个时候 <strong>Page Cache 的内存页面会被释放, 这样空出来的内存就可以分配给新的内存申请</strong>.</p> <p>正是 Page Cache 内存的这种 Cache 的特性, 对于那些有<strong>频繁磁盘访问容器, 往往会看到它的内存使用率一直接近容器内存的限制值(memory.limit_in_bytes)</strong> . 但是这时候, 并不需要担心它内存的不够, 在判断一个容器的内存使用状况的时候, 可以把 Page Cache 这部分内存使用量忽略, 而更多的考虑容器中 RSS 的内存使用量.</p> <h4 id="_10-swap-容器可以使用swap空间吗"><a href="#_10-swap-容器可以使用swap空间吗" class="header-anchor">#</a> 10 | Swap:容器可以使用Swap空间吗?</h4> <p>本节来看看容器中是否可以使用 Swap 空间.</p> <p>用过 Linux 的同学应该都很熟悉 Swap 空间了, 简单来说它就是就是一块<strong>磁盘空间</strong>. 当内存写满的时候, 就可以把内存中不常用的数据暂时写到这个 Swap 空间上. 这样一来内存空间就可以释放出来, 用来满足新的内存申请的需求.</p> <p>它的好处是可以<strong>应对一些瞬时突发的内存增大需求</strong>, 不至于因为内存一时不够而触发 OOM Killer, 导致进程被杀死. 那么对于一个容器, 特别是容器被设置了 Memory Cgroup 之后, 它还可以使用 Swap 空间吗? 会不会出现什么问题呢?</p> <h5 id="_1-问题再现-6"><a href="#_1-问题再现-6" class="header-anchor">#</a> 1.问题再现</h5> <p>接下来就结合一个小例子, 一起来看看. 首先在一个<strong>有 Swap 空间的节点上启动一个容器</strong>, 设置好它的 Memory Cgroup 的限制, 来看看接下来会发生什么. 如果节点上没有 Swap 分区, 也没有关系, 可以用下面的这组命令来新建一个.</p> <p>这个例子里, Swap 空间的大小是 20G, 可以根据自己磁盘空闲空间来决定这个 Swap 的大小. 执行完这组命令之后, 来运行 free 命令, 就可以看到 Swap 空间有 20G. 输出的结果可以参考下图.</p> <p><img src="/img/22fdc51325c3150cba606ae646f9303c-20230731161430-oe1by0l.png" alt=""></p> <p>然后再启动一个容器, 和 OOM 那一讲里的例子差不多, 容器的 Memory Cgroup 限制为 <strong>512MB</strong>, 容器中的 mem_alloc 程序去申请 2GB 内存. 可以发现, 这次和上次 OOM 那一讲里的情况不一样了, <strong>并没有发生 OOM 导致容器退出的情况, 容器运行得好好的</strong>.</p> <p>从下图可以看到, mem_alloc 进程的 RSS 内存一直在 <strong>512MB</strong>(RES: 515596)左右.</p> <p><img src="/img/04a40668910f777c7c542c0570a6878c-20230731161430-ko5i494.png" alt=""></p> <p>再看一下 Swap 空间, 使用了 1.5GB (used 1542144KB). 输出的结果如下图, 简单计算一下, 1.5GB + 512MB, 结果正好是 mem_alloc 这个程序申请的 2GB 内存.</p> <p><img src="/img/74c7ed7754054b5333d230a727add23d-20230731161430-wz8lh3o.png" alt=""></p> <p>通过刚刚的例子, 你也许会这么想, 因为有了 Swap 空间, 本来会被 OOM Kill 的容器, 可以好好地运行了. 初看这样似乎也挺好的, 不过仔细想想, <strong>这样一来, Memory Cgroup 对内存的限制不就失去了作用么</strong>?</p> <p><strong>再进一步分析, 如果一个容器中的程序发生了内存泄漏(Memory leak), 那么本来 Memory Cgroup 可以及时杀死这个进程, 让它不影响整个节点中的其他应用程序. 结果现在这个内存泄漏的进程没被杀死, 还会不断地读写 Swap 磁盘, 反而影响了整个节点的性能.</strong></p> <p>你看, 这样一分析, 对于运行容器的节点, 你是不是又觉得应该禁止使用 Swap 了呢? 不过不能一刀切地下结论, 具体情况要具体分析, 落地到具体的场景里, 就会发现情况又没有想得那么简单.</p> <p>比如某一类程序就是需要 Swap 空间, 才能防止因为<strong>偶尔的内存突然增加</strong>而被 OOM Killer 杀死. 因为这类程序重新启动的初始化时间会很长, 这样程序重启的代价就很大了, 也就是说打开 Swap 对这类程序是有意义的. <strong>这一类程序一旦放到容器中运行, 就意味着它会和 &quot;别的容器&quot; 在同一个宿主机上共同运行, 那如果这个 &quot;别的容器&quot; 如果不需要 Swap, 而是希望 Memory Cgroup 的严格内存限制. 这样一来, 在这一个宿主机上的两个容器就会有冲突了, 应该怎么解决这个问题呢</strong>? 要解决这个问题, 先来看看 Linux 里的 Swappiness 这个概念, 后面它可以帮到我们.</p> <h5 id="_2-如何正确理解swappiness参数"><a href="#_2-如何正确理解swappiness参数" class="header-anchor">#</a> 2.如何正确理解swappiness参数?</h5> <p>在普通 Linux 系统上, 如果你使用过 Swap 空间, 那么你可能<strong>配置过 proc 文件系统下的 swappiness 这个参数</strong> (/proc/sys/vm/swappiness). swappiness 的定义在Linux 内核文档中可以找到, 就是下面这段话.</p> <blockquote><p>swappiness</p> <p>This control is used to define how aggressive the kernel will swap memory pages. Higher values will increase aggressiveness, lower values decrease the amount of swap. A value of 0 instructs the kernel not to initiate swap until the amount of free and file-backed pages is less than the high water mark in a zone.</p> <p>The default value is 60.</p></blockquote> <p>前面两句话大致翻译过来, 意思就是 <mark><strong>swappiness 可以决定系统将会有多频繁地使用交换分区</strong></mark>​ <strong>. 一个较高的值会使得内核更频繁地使用交换分区, 而一个较低的取值, 则代表着内核会尽量避免使用交换分区</strong>. swappiness 的取值范围是 0–100, 缺省值 60.</p> <p>我第一次读到这个定义, 再知道了这个取值范围后, 我觉得这是一个百分比值, 也就是定义了使用 Swap 空间的<strong>频率</strong>. 当这个值是 100 的时候, 哪怕还有空闲内存, 也会去做内存交换, 尽量把内存数据写入到 Swap 空间里; 值是 0 的时候, 基本上就不做内存交换了, 也就不写 Swap 空间了. 后来再回顾的时候, 我发现这个想法不能说是完全错的, 但是想得简单了些. 那这段 swappiness 的定义, 应该怎么正确地理解呢?</p> <p>还记得上一讲里说过的两种内存类型 Page Cache 和 RSS 么?</p> <p>在有磁盘文件访问的时候, <strong>Linux 会尽量把系统的空闲内存用作 Page Cache 来提高文件的读写性能. 在没有打开 Swap 空间的情况下, 一旦内存不够, 这种情况下就只能把 Page Cache 释放了, 而 RSS 内存是不能释放的</strong>.</p> <p>在 RSS 里的内存, 大部分都是没有对应磁盘文件的内存, 比如用 malloc() 申请得到的内存, 这种内存也被称为<strong>匿名内存(Anonymous memory)</strong> . 那么当 Swap 空间打开后, 可以写入 Swap 空间的, 就是这些匿名内存.</p> <p>所以在 Swap 空间打开的时候, 问题也就来了, 在内存紧张的时候, Linux 系统<strong>怎么决定是先释放 Page Cache, 还是先把匿名内存释放并写入到 Swap 空间里</strong>呢?</p> <p>一起来分析分析, 都可能发生怎样的情况. 最可能发生的是下面两种情况:</p> <p>第一种情况是, 如果系统先把 Page Cache 都释放了, 那么一旦节点里有频繁的文件读写操作, 系统的性能就会下降.</p> <p>还有另一种情况, 如果 Linux 系统先把匿名内存都释放并写入到 Swap, 那么一旦这些被释放的匿名内存马上需要使用, 又需要从 Swap 空间读回到内存中, 这样又会让 Swap(其实也是磁盘)的读写频繁, 导致系统性能下降.</p> <p><strong>显然, 在释放内存的时候, 需要平衡 Page Cache 的释放和匿名内存的释放, 而 swappiness, 就是用来定义这个平衡的参数.</strong></p> <p>那么 swappiness 具体是怎么来控制这个平衡的? 看一下在 Linux 内核代码里是怎么用这个 swappiness 参数. 前面说了 swappiness 的这个值的范围是 0 到 100, 但是请一定要注意, <mark><strong>它不是一个百分比, 更像是一个权重</strong></mark>. <strong>它是用来定义 Page Cache 内存和匿名内存的释放的一个比例</strong>.</p> <p>结合下面的这段代码具体讲一讲.</p> <p>可以看到, 这个比例是 <strong>anon_prio : file_prio</strong>, 这里 anon_prio 的值就等于 swappiness. 下面分三个情况做讨论:</p> <p>第一种情况, 当 swappiness 的值是 100 的时候, 匿名内存和 Page Cache 内存的释放比例就是 <strong>100: 100</strong>, 也就是等比例释放了.</p> <p>第二种情况, 就是 swappiness 缺省值是 60 的时候, 匿名内存和 Page Cache 内存的释放比例就是 <strong>60 : 140</strong>, Page Cache 内存的释放要<strong>优先于</strong>匿名内存.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/*
 * With swappiness at 100, anonymous and file have the same priority.
 * This scanning priority is essentially the inverse of IO cost.
 */</span>
anon_prio <span class="token operator">=</span> swappiness<span class="token punctuation">;</span>
file_prio <span class="token operator">=</span> <span class="token number">200</span> <span class="token operator">-</span> anon_prio<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>还有一种情况, 当 swappiness 的值是 0 的时候, 会发生什么呢? 这种情况下, Linux 系统是不允许匿名内存写入 Swap 空间了吗? 可以回到前面, 再看一下那段 swappiness 的英文定义, 里面特别强调了 swappiness 为 0 的情况.</p> <p>当空闲内存少于内存一个 zone 的 &quot;high water mark&quot; 中的值的时候, Linux 还是会做内存交换, 也就是把匿名内存写入到 Swap 空间后释放内存. 在这里 zone 是 Linux 划分物理内存的一个区域, 里面有 3 个水位线(water mark), 水位线可以用来警示空闲内存的紧张程度.</p> <p>这里可以再做个试验来验证一下, 先运行 <code>echo 0 &gt; /proc/sys/vm/swappiness</code>​ 命令把 swappiness 设置为 0, 然后用之前例子里的 <strong>mem_alloc</strong> 程序来申请内存.</p> <p>比如这个节点上内存有 12GB, 同时有 2GB 的 Swap, 用 mem_alloc 申请 12GB 的内存, 可以看到 Swap 空间在 mem_alloc 调用之前, used=0, 输出结果如下图所示.</p> <p><img src="/img/a57a39f15985d7937046fa0d474ab4bc-20230731161430-ax17cs8.png" alt=""></p> <p>接下来, 调用 mem_alloc 之后, Swap 空间就被使用了.</p> <p><img src="/img/9734797b44e39617e717adab6752f8b0-20230731161430-2vfpfy9.png" alt=""></p> <p>因为 mem_alloc 申请 12GB 内存已经和节点最大内存差不多了, 如果查看 <code>cat /proc/zoneinfo</code>​ , 也可以看到 normal zone 里 high (water mark)的值和 free 的值差不多, 这样在 free&lt;high 的时候, 系统就会回收匿名内存页面并写入 Swap 空间.</p> <p><img src="/img/6707d25112f55d7e1aee362775f20241-20230731161430-3ndai5a.png" alt=""></p> <p>好了, 在这里介绍了 Linux 系统里 swappiness 的概念, 它是用来决定在内存紧张时候, 回收匿名内存和 Page Cache 内存的比例.</p> <p><mark>**swappiness 的取值范围在 0 到 100, 值为 100 的时候系统平等回收匿名内存和 Page Cache 内存; 一般缺省值为 60, 就是优先回收 Page Cache; 即使 swappiness 为 0, 也不能完全禁止 Swap 分区的使用, 就是说在内存紧张的时候, 也会使用 Swap 来回收匿名内存. **</mark></p> <h5 id="_3-解决问题-4"><a href="#_3-解决问题-4" class="header-anchor">#</a> 3.解决问题</h5> <p>那么运行了容器, 使用了 Memory Cgroup 之后, swappiness 怎么工作呢?</p> <p>如果查看一下 Memory Cgroup 控制组下面的参数, 会看到有一个 <strong>memory.swappiness</strong> 参数. 这个参数可以<strong>控制这个 Memroy Cgroup 控制组下面匿名内存和 page cache 的回收, 取值的范围和工作方式和全局的 swappiness 差不多</strong>. 这里有一个优先顺序, 在 Memory Cgorup 的控制组里, 如果设置了 memory.swappiness 参数, 它就会覆盖全局的 swappiness, 让全局的 swappiness 在这个控制组里不起作用.</p> <p>不过这里有一点不同, 需要留意: **当 memory.swappiness = 0 的时候, 对匿名页的回收是始终禁止的, 也就是始终都不会使用 Swap 空间. ** 这时 Linux 系统不会再去比较 free 内存和 zone 里的 high water mark 的值, 再决定一个 Memory Cgroup 中的匿名内存要不要回收了. 请注意, <strong>当设置了 &quot;memory.swappiness=0&quot; 时, 在 Memory Cgroup 中的进程, 就不会再使用 Swap 空间</strong>, 知道这一点很重要.</p> <p>可以跑个容器试一试, 还是在一个有 Swap 空间的节点上运行, 运行和这一讲开始一样的容器, 唯一不同的是把容器对应 Memory Cgroup 里的 memory.swappiness 设置为 0.</p> <p><img src="/img/8ab1c7f6bbac8af6d2b7e36c86b58944-20230731161430-glc8ksb.png" alt=""></p> <p>这次在容器中申请内存之后, Swap 空间就没有被使用了, 而当容器申请的内存超过 memory.limit_in_bytes 之后, 就发生了 OOM Kill.</p> <p>有了 &quot;memory.swappiness = 0&quot; 的配置和功能, 就可以解决在这一讲里最开始提出的问题了. <strong>在同一个宿主机上, 假设同时存在容器 A 和其他容器, 容器 A 上运行着需要使用 Swap 空间的应用, 而别的容器不需要使用 Swap 空间</strong>.</p> <p>那么, 还是<strong>可以在宿主机节点上打开 Swap 空间, 同时在其他容器对应的 Memory Cgroups 控制组里, 把 memory.swappiness 这个参数设置为 0</strong>. 这样一来, 不但满足了容器 A 的需求, 而且别的容器也不会受到影响, 仍然可以严格按照 Memory Cgroups 里的 memory.limit_in_bytes 来限制内存的使用.</p> <p>总之, <strong>memory.swappiness 这个参数很有用, 通过它可以让需要使用 Swap 空间的容器和不需要 Swap 的容器, 同时运行在同一个宿主机上</strong>.</p> <h5 id="_4-重点总结-6"><a href="#_4-重点总结-6" class="header-anchor">#</a> 4.重点总结</h5> <p>本节主要讨论的问题是在容器中是否可以使用 Swap? 这个问题没有看起来那么简单. 当然只要在宿主机节点上打开 Swap 空间, 在容器中就是可以用到 Swap 的. 但出现的<strong>问题是在同一个宿主机上, 对于不需要使用 swap 的容器, 它的 Memory Cgroups 的限制也失去了作用</strong>.</p> <p>针对这个问题, 学习了 Linux 中的 swappiness 这个参数. <strong>swappiness 参数值的作用是, 在系统里有 Swap 空间之后, 当系统需要回收内存的时候, 是优先释放 Page Cache 中的内存, 还是优先释放匿名内存(也就是写入 Swap)</strong> .</p> <p>swappiness 的取值范围在 0 到 100 之间, 可以记住下面三个值:</p> <ol><li>值为 100 的时候, 释放 Page Cache 和匿名内存是同等优先级的.</li> <li>值为 60, 这是大多数 Linux 系统的缺省值, 这时候 Page Cache 的释放优先级高于匿名内存的释放.</li> <li>值为 0 的时候, 当系统中空闲内存低于一个临界值的时候, 仍然会释放匿名内存并把页面写入 Swap 空间.</li></ol> <p><img src="/img/23f810fd577934a1afdb14cdc49ce4ed-20230731161430-wfe9h6z.png" alt=""></p> <p>swappiness 参数除了在 proc 文件系统下有个全局的值外, ** 在每个 Memory Cgroup 控制组里也有一个 memory.swappiness**, 那它们有什么不同呢?</p> <p>**不同就是每个 Memory Cgroup 控制组里的 swappiness 参数值为 0 的时候, 就可以让控制组里的内存停止写入 Swap. 这样一来, 有了 memory.swappiness 这个参数后, 需要使用 Swap 和不需要 Swap 的容器就可以在同一个宿主机上同时运行了, 这样对于硬件资源的利用率也就更高了. **</p> <h3 id="容器存储"><a href="#容器存储" class="header-anchor">#</a> 容器存储</h3> <h4 id="_11-容器文件系统-我在容器中读写文件怎么变慢了"><a href="#_11-容器文件系统-我在容器中读写文件怎么变慢了" class="header-anchor">#</a> 11 | 容器文件系统:我在容器中读写文件怎么变慢了?</h4> <p>从这一讲开始进入容器存储这个模块. 这一模块的内容, 都和容器里的<strong>文件读写</strong>密切相关. 因为所有的容器的运行都需要一个容器文件系统, 那么就从容器文件系统先开始讲起.</p> <p>还是和以前一样, 先来看看我之前碰到了什么问题. 这个问题具体是我们在宿主机上, 把 Linux 从 ubuntu18.04 升级到 ubuntu20.04 之后发现的. 在我们做了宿主机的升级后, 启动了一个容器, 在容器里用 fio 这个磁盘性能测试工具, 想看一下容器里文件的读写性能. 结果我们很惊讶地发现, 在 ubuntu 20.04 宿主机上的容器中文件读写的性能只有 ubuntu18.04 宿主机上的 1/8 左右了, 那这是怎么回事呢?</p> <h5 id="_1-问题再现-7"><a href="#_1-问题再现-7" class="header-anchor">#</a> 1.问题再现</h5> <p>这里提醒一下, 因为涉及到两个 Linux 的虚拟机, 问题再现这里列出了关键的结果输出截图, 不方便操作的同学可以重点看其中的思路.</p> <p>可以先启动一个 ubuntu18.04 的虚拟机, 它的 Linux 内核版本是 4.15 的, 然后在虚拟机上用命令 <code>docker run -it ubuntu:18.04 bash</code>​ 启动一个容器, 接着在容器里运行 fio 这条命令, 看一下在容器中读取文件的性能.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># fio -direct=1 -iodepth=64 -rw=read -ioengine=libaio -bs=4k -size=10G -numjobs=1  -name=./fio.test</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这里解释一下 fio 命令中的几个主要参数:</p> <p>第一个参数是 &quot;-direct=1&quot;, 代表采用非 buffered I/O 文件读写的方式, 避免文件读写过程中内存缓冲对性能的影响.</p> <p>接着来看这 &quot;-iodepth=64&quot; 和 &quot;-ioengine=libaio&quot; 这两个参数, 这里指文件读写采用<strong>异步 I/O</strong>(Async I/O)的方式, 也就是进程可以发起多个 I/O 请求, 并且不用阻塞地等待 I/O 的完成. 稍后等 I/O 完成之后, 进程会收到通知. 这种异步 I/O 很重要, 因为它可以极大地提高文件读写的性能. 在这里设置了同时发出 64 个 I/O 请求.</p> <p>然后是 &quot;-rw=read, -bs=4k, -size=10G&quot;, 这几个参数指这个测试是个读文件测试, 每次读 4KB 大小数块, 总共读 10GB 的数据.</p> <p>最后一个参数是 &quot;-numjobs=1&quot;, 指只有一个进程 / 线程在运行.</p> <p><strong>所以这条 fio 命令表示通过异步方式读取了 10GB 的磁盘文件, 用来计算文件的读取性能.</strong></p> <p>可以看到在 ubuntu 18.04, 内核 4.15 上的容器 I/O 性能是 584MB/s 的带宽, IOPS(I/O per second)是 150K 左右.</p> <p><img src="/img/1c40045943e8892834dbfba56fb0195b-20230731161430-ps4qgzw.png" alt=""></p> <p>同样再启动一个 ubuntu 20.04, 内核 5.4 的虚拟机, 然后在它的上面也启动一个容器. 运行 <code>docker run -it ubuntu:20.04 bash</code>​, 接着在容器中使用同样的 fio 命令, 可以看到它的 I/O 性能是 70MB 带宽, IOPS 是 18K 左右. 实践证明, 这的确比老版本的 ubuntu 18.04 差了很多.</p> <p><img src="/img/70bb078d3737219d8e1da4ca76d3b0c7-20230731161430-okanw0k.png" alt=""></p> <h5 id="_2-知识详解-3"><a href="#_2-知识详解-3" class="header-anchor">#</a> 2.知识详解</h5> <h6 id="_1-如何理解容器文件系统"><a href="#_1-如何理解容器文件系统" class="header-anchor">#</a> (1)如何理解容器文件系统?</h6> <p>刚才对比了升级前后的容器读写性能差异, 那想要分析刚刚说的这个性能的差异, 需要<strong>先理解容器的文件系统</strong>.</p> <p>在容器里, 运行 <code>df</code>​ 命令, 可以看到在<strong>容器中根目录 (/) 的文件系统类型是 &quot;overlay&quot;</strong> , 它不是在普通 Linux 节点上看到的 Ext4 或者 XFS 之类常见的文件系统.</p> <p>Overlay 是一个什么样的文件系统呢, 容器为什么要用这种文件系统?</p> <p><img src="/img/d343cedab568b1bdd97a29b20e583385-20230731161430-0yyrxdu.png" alt=""></p> <p>在说容器文件系统前, 先来想象一下如果没有文件系统管理的话会怎样. 假设有这么一个场景, 在一个宿主机上需要运行 100 个容器.</p> <p>在这个课程的第一讲里, 就说过每个容器都需要一个<strong>镜像</strong>, 这个镜像就把容器中程序需要运行的二进制文件, 库文件, 配置文件, 其他的依赖文件等全部都打包成一个镜像文件. <strong>如果没有特别的容器文件系统, 只是普通的 Ext4 或者 XFS 文件系统, 那么每次启动一个容器, 就需要把一个镜像文件下载并且存储在宿主机上</strong>. 举个例子, 比如说, 假设一个镜像文件的大小是 500MB, 那么 100 个容器的话, 就需要下载 500MB*100= 50GB 的文件, 并且占用 50GB 的磁盘空间.</p> <p>如果再分析一下这 50GB 里的内容, 你会发现绝大部分的操作系统里, <strong>库文件都是差不多</strong>的. 而且在容器运行的时候, 这类文件也不会被改动, 基本上都是只读的. 特别是这样的情况: 假如这 100 个容器镜像都是基于 &quot;ubuntu:18.04&quot; 的, 每个容器镜像只是额外复制了 50MB 左右自己的应用程序到 &quot;ubuntu: 18.04&quot; 里, 那么就是说在总共 50GB 的数据里, 有 90% 的数据是冗余的.</p> <p>讲到这里, 就不难推测出理想的情况应该是什么样的. 没错, 当然是<strong>在一个宿主机上只要下载并且存储存一份 &quot;ubuntu:18.04&quot;, 所有基于 &quot;ubuntu:18.04&quot; 镜像的容器都可以共享这一份通用的部分</strong>. 这样设置的话, 不同容器启动的时候, 只需要<strong>下载自己独特的程序部分就可以</strong>. 就像下面这张图展示的这样.</p> <p><img src="/img/66ebb544d59f593149c2d7f40d4528cd-20230731161430-fgvgieo.png" alt=""></p> <p><mark>**正是为了有效地减少磁盘上冗余的镜像数据, 同时减少冗余的镜像数据在网络上的传输, 选择一种针对于容器的文件系统是很有必要的, 而这类的文件系统被称为 UnionFS. **</mark></p> <p><strong>UnionFS 这类文件系统实现的主要功能是把多个目录(处于不同的分区)一起挂载(mount)在一个目录下</strong>. 这种多目录挂载的方式, 正好可以解决刚才说的容器镜像的问题.</p> <p>比如, 可以把 ubuntu18.04 这个基础镜像的文件放在一个目录 ubuntu18.04/ 下, 容器自己额外的程序文件 app_1_bin 放在 app_1/ 目录下. 然后把这两个目录挂载到 container_1/ 这个目录下, 作为容器 1 看到的文件系统; 对于容器 2, 就可以把 ubuntu18.04/ 和 app_2/ 两个目录一起挂载到 container_2 的目录下.</p> <p>这样在节点上只要保留一份 ubuntu18.04 的文件就可以了.</p> <p><img src="/img/2d830fb32bad5ee14121cd9b73328908-20230731161430-evedzmi.png" alt=""></p> <h6 id="_2-overlayfs"><a href="#_2-overlayfs" class="header-anchor">#</a> (2)OverlayFS</h6> <p>UnionFS 类似的有很多种<strong>实现</strong>, 包括在 Docker 里最早使用的 AUFS, 还有目前使用的 <strong>OverlayFS</strong>. 前面在运行 <code>df</code>​ 的时候, 看到的文件系统类型 &quot;overlay&quot; 指的就是 OverlayFS.</p> <p>在 Linux 内核 3.18 版本中, OverlayFS 代码正式合入 Linux 内核的主分支. 在这之后, <strong>OverlayFS 也就逐渐成为各个主流 Linux 发行版本里缺省使用的容器文件系统了</strong>.</p> <p>网上 Julia Evans 有个 blog, 里面有个的 OverlayFS 使用的例子, 很简单, 我们也拿这个例子来理解一下 OverlayFS 的一些基本概念.</p> <p>可以先执行一下这一组命令.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token function">umount</span> ./merged
<span class="token function">rm</span> upper lower merged work <span class="token parameter variable">-r</span>
<span class="token function">mkdir</span> upper lower merged work
<span class="token builtin class-name">echo</span> <span class="token string">&quot;I'm from lower!&quot;</span> <span class="token operator">&gt;</span> lower/in_lower.txt
<span class="token builtin class-name">echo</span> <span class="token string">&quot;I'm from upper!&quot;</span> <span class="token operator">&gt;</span> upper/in_upper.txt
<span class="token comment"># `in_both` is in both directories</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;I'm from lower!&quot;</span> <span class="token operator">&gt;</span> lower/in_both.txt
<span class="token builtin class-name">echo</span> <span class="token string">&quot;I'm from upper!&quot;</span> <span class="token operator">&gt;</span> upper/in_both.txt
<span class="token function">sudo</span> <span class="token function">mount</span> <span class="token parameter variable">-t</span> overlay overlay <span class="token punctuation">\</span>
 <span class="token parameter variable">-o</span> <span class="token assign-left variable">lowerdir</span><span class="token operator">=</span>./lower,upperdir<span class="token operator">=</span>./upper,workdir<span class="token operator">=</span>./work <span class="token punctuation">\</span>
 ./merged
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>可以看到, OverlayFS 的一个 mount 命令牵涉到<strong>四类目录</strong>, 分别是 <strong>lower, upper, merged 和 work</strong>, 那它们是什么关系呢?</p> <p>看下面这张图, 这和前面 UnionFS 的工作示意图很像, 也不奇怪, <strong>OverlayFS 就是 UnionFS 的一种实现</strong>. 接下来从下往上依次看看每一层的功能.</p> <p>首先, 最下面的 &quot;<strong>lower/</strong> &quot;, 也就是被 mount 两层目录中底下的这层(lowerdir). 在 OverlayFS 中, <strong>最底下这一层里的文件是不会被修改的, 可以认为它是只读的</strong>. 提醒一点, 在这个例子里只有一个 lower/ 目录, 不过 OverlayFS 是支持多个 lowerdir 的.</p> <p>然后看 &quot;<strong>uppder/</strong> &quot;, 它是被 mount 两层目录中上面的这层 (upperdir). 在 OverlayFS 中, 如果<strong>有文件的创建, 修改, 删除操作, 那么都会在这一层反映出来, 它是可读写的</strong>.</p> <p>接着是最上面的 &quot;<strong>merged</strong>&quot;, 它是<strong>挂载点(mount point)目录, 也是用户看到的目录, 用户的实际文件操作在这里进行</strong>.</p> <p>其实还有一个 &quot;<strong>work/</strong> &quot;, 这个目录没有在这个图里, 它只是一个存放<strong>临时文件</strong>的目录, OverlayFS 中如果有文件修改, 就会在中间过程中临时存放文件到这里.</p> <p><img src="/img/e398a145ed5b51fdee5b5fac6f5fe203-20230731161430-9mrkmju.png" alt=""></p> <p>从这个例子可以看到, <strong>OverlayFS 会 mount 两层目录, 分别是 lower 层和 upper 层, 这两层目录中的文件都会映射到挂载点上</strong>.</p> <p>从挂载点的视角看, upper 层的文件会覆盖 lower 层的文件, 比如 &quot;in_both.txt&quot; 这个文件, 在 lower 层和 upper 层都有, 但是挂载点 merged/ 里看到的只是 upper 层里的 in_both.txt.</p> <p>如果在 merged/ 目录里做<strong>文件操作</strong>, 具体包括这三种.</p> <p>第一种<strong>新建文件</strong>, 这个文件会出现在 <strong>upper/</strong>  目录中.</p> <p>第二种是<strong>删除文件</strong>, 如果删除 &quot;in_upper.txt&quot;, 那么这个文件会在 upper/ 目录中消失. 如果删除 &quot;in_lower.txt&quot;, 在 lower/ 目录里的 &quot;in_lower.txt&quot; 文件不会有变化, 只是在 upper/ 目录中增加了一个特殊文件来告诉 OverlayFS, &quot;in_lower.txt&quot; 这个文件<strong>不能出现在 merged/ 里</strong>了, 这就表示它已经被删除了.</p> <p><img src="/img/aa9c573433c84ebfe5407fd33387552f-20230731161430-ojv3x04.png" alt=""></p> <p>还有一种操作是<strong>修改文件</strong>, 类似如果修改 &quot;in_lower.txt&quot;, 那么就会<strong>在 upper/ 目录中新建一个 &quot;in_lower.txt&quot; 文件, 包含更新的内容, 而在 lower/ 中的原来的实际文件 &quot;in_lower.txt&quot; 不会改变</strong>.</p> <p>通过这个例子可以知道 OverlayFS 是怎么工作的. 可以再想一想, 怎么把它运用到容器的镜像文件上?</p> <p>其实也不难, 从系统的 mounts 信息中, 可以看到 Docker 是怎么用 OverlayFS 来挂载镜像文件的. <strong>容器镜像文件可以分成多个层(layer), 每层可以对应 OverlayFS 里 lowerdir 的一个目录, lowerdir 支持多个目录, 也就可以支持多层的镜像文件</strong>.</p> <p>在容器启动后, 对镜像文件中修改就会被保存在 upperdir 里了.</p> <p><img src="/img/b34f54d0d99473e1e235635bbce832bd-20230731161430-udfrexx.png" alt=""></p> <h5 id="_3-解决问题-5"><a href="#_3-解决问题-5" class="header-anchor">#</a> 3.解决问题</h5> <p>在理解了容器使用的 OverlayFS 文件系统后, 再回到开始的问题, 为什么<strong>在宿主机升级之后, 在容器里读写文件的性能降低</strong>了? 现在至少应该知道, 在容器中读写文件性能降低了, 那么应该是 OverlayFS 的性能在新的 ubuntu20.04 中降低了.</p> <p>要找到问题的根因, 还需要进一步的 debug. 对于性能问题, 需要使用 Linux 下的 <strong>perf 工具</strong>来查看一下, 具体怎么使用 perf 来解决问题, 会在后面讲解.</p> <p>这里只要看一下结果就可以了, <strong>自下而上是函数的一个调用顺序</strong>. 通过 perf 工具, 可以比较在容器中<strong>运行 fio 的时候</strong>, ubuntu 18.04 和 ubuntu 20.04 在内核函数调用上的不同.</p> <p><img src="/img/ea7f0caf11a52b8f0d7a294cd648663c-20230731161430-sdg5pr7.png" alt="" title="ubuntu 18.04 (Linux 内核 4.15)环境下使用 perf 输出的函数调用结果"></p> <p><img src="/img/223b74e96ac63f3c23c1a6f128b1a0f4-20230731161430-m98pcqy.png" alt="" title="ubuntu 20.04 (Linux 内核 5.4)环境下使用 perf 输出的函数调用结果"></p> <p>从系统调用框架之后的函数 aio_read() 开始比较: Linux 内核 4.15 里 aio_read() 之后调用的是 xfs_file_read_iter(), 而在 Linux 内核 5.4 里, aio_read() 之后调用的是 <strong>ovl_read_iter</strong>() 这个函数, 之后再调用 xfs_file_read_iter().</p> <p>这样就可以去查看一下, 在内核 4.15 之后新加入的这个函数 ovl_read_iter() 的代码. 查看代码后就能明白, Linux 为了完善 OverlayFS, <strong>增加了 OverlayFS 自己的 read/write 函数接口, 从而不再直接调用 OverlayFS 后端文件系统(比如 XFS, Ext4)的读写接口. 但是它只实现了同步 I/O(sync I/O), 并没有实现异步 I/O</strong>. 而在 fio 做文件系统性能测试的时候使用的是<strong>异步 I/O</strong>, 这样才可以得到文件系统的性能最大值. 所以在内核 5.4 上就无法对 OverlayFS 测出最高的性能指标了.</p> <p>在 Linux 内核 5.6 版本中, 这个问题已经通过下面的这个补丁给解决了, 有兴趣的同学可以看一下.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>commit 2406a307ac7ddfd7effeeaff6947149ec6a95b4e
Author: Jiufei Xue <span class="token operator">&lt;</span>jiufei.xue@linux.alibaba.com<span class="token operator">&gt;</span>
Date:   Wed Nov <span class="token number">20</span> <span class="token number">17</span>:45:26 <span class="token number">2019</span> +0800
 
    ovl: implement async IO routines
 
    A performance regression was observed since linux v4.19 with aio <span class="token builtin class-name">test</span> using
    fio with iodepth <span class="token number">128</span> on overlayfs.  The queue depth of the device was
    always <span class="token number">1</span> <span class="token function">which</span> is unexpected.
 
    After investigation, it was found that commit 16914e6fc7e1 <span class="token punctuation">(</span><span class="token string">&quot;ovl: add
    ovl_read_iter()&quot;</span><span class="token punctuation">)</span> and commit 2a92e07edc5e <span class="token punctuation">(</span><span class="token string">&quot;ovl: add ovl_write_iter()&quot;</span><span class="token punctuation">)</span>
    resulted <span class="token keyword">in</span> vfs_iter_<span class="token punctuation">{</span>read,write<span class="token punctuation">}</span> being called on underlying filesystem,
    <span class="token function">which</span> always results <span class="token keyword">in</span> syncronous IO.
 
    Implement async IO <span class="token keyword">for</span> stacked reading and writing.  This resolves the
    performance regresion.
 
    This is implemented by allocating a new kiocb <span class="token keyword">for</span> submitting the AIO
    request on the underlying filesystem.  When the request is completed, the
    new kiocb is freed and the completion callback is called on the original
    iocb.
 
    Signed-off-by: Jiufei Xue <span class="token operator">&lt;</span>jiufei.xue@linux.alibaba.com<span class="token operator">&gt;</span>
    Signed-off-by: Miklos Szeredi <span class="token operator">&lt;</span>mszeredi@redhat.com<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h5 id="_4-重点总结-7"><a href="#_4-重点总结-7" class="header-anchor">#</a> 4.重点总结</h5> <p>这一讲最主要的内容是理解容器文件系统. <strong>为什么要有容器自己的文件系统? 很重要的一点是减少相同镜像文件在同一个节点上的数据冗余, 可以节省磁盘空间, 也可以减少镜像文件下载占用的网络资源</strong>.</p> <p>作为容器文件系统, UnionFS 通过多个目录挂载的方式工作. OverlayFS 就是 UnionFS 的一种实现, 是目前主流 Linux 发行版本中缺省使用的容器文件系统. OverlayFS 也是把多个目录合并挂载, 被挂载的目录分为两大类: <strong>lowerdir</strong> 和 <strong>upperdir</strong>. l<strong>owerdir 允许有多个目录, 在被挂载后, 这些目录里的文件都是不会被修改或者删除的, 也就是只读的; upperdir 只有一个, 不过这个目录是可读写的, 挂载点目录中的所有文件修改都会在 upperdir 中反映出来</strong>.</p> <p>容器的镜像文件中各层正好作为 OverlayFS 的 lowerdir 的目录, 然后加上一个空的 upperdir 一起挂载好后, 就组成了容器的文件系统.</p> <p>OverlayFS 在 Linux 内核中还在不断的完善, 比如在这一讲看到的在 kenel 5.4 中对异步 I/O 操作的缺失, 这也是在使用容器文件系统的时候需要注意的.</p> <h4 id="_12-容器文件quota-容器为什么把宿主机的磁盘写满了"><a href="#_12-容器文件quota-容器为什么把宿主机的磁盘写满了" class="header-anchor">#</a> 12 | 容器文件Quota:容器为什么把宿主机的磁盘写满了?</h4> <p>本节聊一聊容器文件 Quota.</p> <p>上一讲学习了容器文件系统 OverlayFS, 这个 OverlayFS 有两层, 分别是 lowerdir 和 upperdir. <mark><strong>lowerdir 里是容器镜像中的文件, 对于容器来说是只读的; upperdir 存放的是容器对文件系统里的所有改动, 它是可读写的</strong></mark>. 从宿主机的角度看, upperdir 就是一个<strong>目录</strong>, 如果容器不断往容器文件系统中写入数据, <strong>实际上就是往宿主机的磁盘上写数据, 这些数据也就存在于宿主机的磁盘目录中</strong>. 当然对于容器来说, 如果有大量的写操作是不建议写入容器文件系统的, <strong>一般是需要给容器挂载一个 volume, 用来满足大量的文件读写</strong>.</p> <p>但是不能避免的是, 用户在容器中运行的程序有错误, 或者进行了错误的配置. 比如把 log 写在了容器文件系统上, 并且没有做 log rotation, 那么时间一久, 就会导致宿主机上的磁盘被写满. 这样影响的就不止是容器本身了, 而是<strong>整个宿主机</strong>了.</p> <p>那对于这样的问题该怎么解决呢?</p> <h5 id="_1-问题再现-8"><a href="#_1-问题再现-8" class="header-anchor">#</a> 1.问题再现</h5> <p>可以自己先启动一个容器, 一起试试<strong>不断地往容器文件系统中写入数据</strong>, 看看是一个什么样的情况. 用 Docker 启动一个容器后, 可以看到<strong>容器的根目录 (/) 也就是容器文件系统 OverlayFS</strong>, 它的大小是 160G, 已经使用了 100G. 其实这个大小也是宿主机上的磁盘空间和使用情况.</p> <p><img src="/img/c36825d1aae0c7e12b1eb100ce7f094c-20230731161430-0qr9iyf.png" alt=""></p> <p>这时候, 可以回到<strong>宿主机</strong>上验证一下, 就会发现宿主机的根目录 (/) 的大小也是 160G, 同样是使用了 100G.</p> <p><img src="/img/a6a4a5c0798f91344ef826318bd6f9da-20230731161430-g6ss2ai.png" alt=""></p> <p>好, 那现在再往容器的根目录里写入 10GB 的数据. 这里可以看到容器的根目录使用的大小增加了, 从刚才的 100G 变成现在的 110G. 而多写入的 10G 大小的数据, 对应的是 <strong>test.log</strong> 这个文件.</p> <p><img src="/img/74e171ca360426c75d9c0b4015161638-20230731161430-0aqth21.png" alt=""></p> <p>接下来再回到宿主机上, 可以看到宿主机上的根目录 (/) 里使用的大小也是 110G 了.</p> <p><img src="/img/530804c975c857204835090517d06374-20230731161430-lahk9c3.png" alt=""></p> <p>还是继续看宿主机, 看看 OverlayFS 里 <strong>upperdir 目录</strong>中有什么文件?</p> <p>这里仍然可以通过 /proc/mounts 这个路径, 找到容器 <strong>OverlayFS 对应的 lowerdir 和 upperdir</strong>. 因为写入的数据都在 upperdir 里, 就只要看 upperdir 对应的那个目录就行了. 果然里面存放着容器写入的文件 test.log, 它的大小是 10GB.</p> <p><img src="/img/136d90bc2fb6771e11966b29b9d52892-20230731161430-h138nc7.png" alt=""></p> <p>通过这个例子, 已经验证了在容器中对于 OverlayFS 中写入数据, **其实就是往宿主机的一个目录(upperdir)里写数据. ** 现在已经写了 10GB 的数据, 如果继续在容器中写入数据, 结果估计你也知道了, 就是会写满宿主机的磁盘.</p> <p>那遇到这种情况该怎么办呢?</p> <h5 id="_2-知识详解-4"><a href="#_2-知识详解-4" class="header-anchor">#</a> 2.知识详解</h5> <p>容器写自己的 OverlayFS 根目录, 结果把宿主机的磁盘写满了. 发生这个问题, 首先就会想到<strong>需要对容器做限制</strong>, 限制它写入自己 OverlayFS 的数据量, 比如只允许一个容器写 100MB 的数据. 不过实际查看 OverlayFS 文件系统的特性, 就会发现没有直接限制文件写入量的特性. 别担心, 在没有现成工具的情况下, 只要搞懂了原理, 就能想出解决办法.</p> <p>所以再来分析一下 OverlayFS, 它是<strong>通过 lowerdir 和 upperdir 两层目录联合挂载来实现的, lowerdir 是只读的, 数据只会写在 upperdir 中</strong>. 那是不是可以通过<strong>限制 upperdir 目录容量</strong>的方式, 来限制一个容器 OverlayFS 根目录的写入数据量呢?</p> <p>沿着这个思路继续往下想, 因为 upperdir 在宿主机上也是一个<strong>普通的目录</strong>, 这样就要看**宿主机上的文件系统是否可以支持对一个目录限制容量了. **</p> <p>对于 Linux 上最常用的两个文件系统 XFS 和 ext4, 它们有一个特性 <strong>Quota</strong>, 那就以 XFS 文件系统为例, 学习一下这个 Quota 概念, 然后看看这个特性能不能限制一个目录的使用量.</p> <h6 id="_1-xfs-quota"><a href="#_1-xfs-quota" class="header-anchor">#</a> (1)XFS Quota</h6> <p>在 Linux 系统里的 XFS 文件系统缺省都有 <strong>Quota 的特性, 这个特性可以为 Linux 系统里的一个用户(user), 一个用户组(group)或者一个项目(project)来限制它们使用文件系统的额度(quota), 也就是限制它们可以写入文件系统的文件总量</strong>.</p> <p>因为目标是要限制一个目录中总体的写入文件数据量, 那么显然给用户和用户组限制文件系统的写入数据量的模式, 并不适合这个需求. 因为同一个用户或者用户组可以操作多个目录, 多个用户或者用户组也可以操作同一个目录, 这样对一个用户或者用户组的限制, 就很难用来限制一个目录.</p> <p>那排除了限制用户或用户组的模式, 再来看看 <strong>Project</strong> 模式. Project 模式是怎么工作的呢? 举一个例子, 对 Linux 熟悉的同学可以一边操作, 一边体会一下它的工作方式. 不熟悉的同学也没关系, 可以重点关注后面的讲解思路.</p> <p>首先要使用 XFS Quota 特性, 必须在文件系统挂载的时候加上对应的 Quota 选项, 比如目前需要配置 Project Quota, 那么这个挂载参数就是 &quot;pquota&quot;. 对于根目录来说, **这个参数必须作为一个内核启动的参数 &quot;rootflags=pquota&quot;, 这样设置就可以保证根目录在启动挂载的时候, 带上 XFS Quota 的特性并且支持 Project 模式. **</p> <p>可以从 /proc/mounts 信息里, 看看根目录是不是带 &quot;prjquota&quot; 字段. 如果里面有这个字段, 就可以确保文件系统已经带上了支持 project 模式的 XFS quota 特性.</p> <p><img src="/img/e837543f64590c99417091854b0cc546-20230731161430-bi4tklb.png" alt=""></p> <p>下一步, 还需要给一个<strong>指定的目录打上一个 Project ID</strong>. 这个步骤可以使用 XFS 文件系统自带的工具 xfs_quota 来完成, 然后执行下面的这个命令就可以了. 执行命令之前, 先对下面的命令和输出做两点解释, 以理解这个命令的含义.</p> <p>第一点, 新建的目录 /tmp/xfs_prjquota, 我们想对它做 Quota 限制. 所以在这里要对它打上一个 Project ID.</p> <p>第二点, 通过 xfs_quota 这条命令, 给 /tmp/xfs_prjquota 打上 Project ID 值 101, 这个 101 是随便选的一个数字, 就是个 ID 标识, 先有个印象. 在后面针对 Project 进行 Quota 限制的时候, 还会用到这个 ID.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># mkdir -p  /tmp/xfs_prjquota</span>
<span class="token comment"># xfs_quota -x -c 'project -s -p /tmp/xfs_prjquota 101' /</span>
Setting up project <span class="token number">101</span> <span class="token punctuation">(</span>path /tmp/xfs_prjquota<span class="token punctuation">)</span><span class="token punctuation">..</span>.
Processed <span class="token number">1</span> <span class="token punctuation">(</span>/etc/projects and cmdline<span class="token punctuation">)</span> paths <span class="token keyword">for</span> project <span class="token number">101</span> with recursion depth infinite <span class="token punctuation">(</span>-1<span class="token punctuation">)</span>.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>最后, 还是使用 xfs_quota 命令, 对 101(刚才建立的这个 Project ID)做 Quota 限制.</p> <p>可以执行下面这条命令, 里面的 &quot;-p bhard=10m 101&quot; 就代表限制 101 这个 project ID, 限制它的数据块写入量不能超过 10MB.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># xfs_quota -x -c 'limit -p bhard=10m 101' /</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>做好限制之后, 可以尝试往 /tmp/xfs_prjquota 写数据, 看看是否可以超过 10MB. 比如尝试写入 20MB 的数据到 /tmp/xfs_prjquota 里.</p> <p>可以看到, 执行 dd 写入命令, 就会有个出错返回信息 &quot;No space left on device&quot;. 这表示已经不能再往这个目录下写入数据了, 而最后写入数据的文件 test.file 大小也停留在了 10MB.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># dd if=/dev/zero of=/tmp/xfs_prjquota/test.file bs=1024 count=20000</span>
dd: error writing <span class="token string">'/tmp/xfs_prjquota/test.file'</span><span class="token builtin class-name">:</span> No space left on device
<span class="token number">10241</span>+0 records <span class="token keyword">in</span>
<span class="token number">10240</span>+0 records out
<span class="token number">10485760</span> bytes <span class="token punctuation">(</span><span class="token number">10</span> MB, <span class="token number">10</span> MiB<span class="token punctuation">)</span> copied, <span class="token number">0.0357122</span> s, <span class="token number">294</span> MB/s
<span class="token comment"># ls -l /tmp/xfs_prjquota/test.file</span>
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">10485760</span> Oct <span class="token number">31</span> <span class="token number">10</span>:00 /tmp/xfs_prjquota/test.file
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>好了, 做到这里, 可以发现使用 XFS Quota 的 Project 模式, 确实可以限制一个目录里的写入数据量, 它实现的方式其实也不难, 就是下面这两步.</p> <p>第一步, 给目标目录打上一个 Project ID, 这个 ID 最终是写到<strong>目录对应的 inode 上</strong>. inode 是文件系统中用来描述一个文件或者一个目录的元数据, 里面包含文件大小, 数据块的位置, 文件所属用户 / 组, 文件读写属性以及其他一些属性. 那么一旦目录打上这个 ID 之后, 在这个目录下的<strong>新建的文件和目录也都会继承这个 ID</strong>.</p> <p>第二步, 在 XFS 文件系统中, 需要给这个 project ID <strong>设置一个写入数据块的限制</strong>. 有了 ID 和限制值之后, 文件系统就可以统计所有带这个 ID 文件的数据块大小总和, 并且与限制值进行比较. 一旦所有文件大小的总和达到限制值, 文件系统就不再允许更多的数据写入了.</p> <p>用一句话概括, XFS Quota 就是通过前面这两步限制了一个目录里写入的数据量.</p> <h5 id="_3-解决问题-6"><a href="#_3-解决问题-6" class="header-anchor">#</a> 3.解决问题</h5> <p>理解了 XFS Quota 对目录限流的机制之后, 再回到最开始的问题, 如何确保容器不会写满宿主机上的磁盘. 方法就是<mark><strong>对 OverlayFS 的 upperdir 目录做 XFS Quota 的限流</strong></mark>, 就是这个解决办法!</p> <p>其实 Docker 也已经实现了限流功能, 也就是<strong>用 XFS Quota 来限制容器的 OverlayFS 大小</strong>. 在用 <code>docker run</code>​ 启动容器的时候, 加上一个参数 <code>--storage-opt size= &lt;SIZE&gt;</code>​, 就能限制住容器 OverlayFS 文件系统可写入的最大数据量了.</p> <p>试一下, 这里限制的 size 是 10MB. 进入容器之后, 先运行 <code>df -h</code>​ 命令, 这时候可以看到根目录 (/)overlayfs 文件系统的大小就 10MB, 而不是之前看到的 160GB 的大小了. 这样容器在它的根目录下, 最多只能写 10MB 数据, 就不会把宿主机的磁盘给写满了.</p> <p><img src="/img/d6c65e47d669fbd3c05a583384cb7373-20230731161430-oiv046b.png" alt=""></p> <p>完成了上面这个小试验之后, 可以再看一下 Docker 的代码, 看看它的实现是不是和我们想的一样. Docker 里 SetQuota() 函数就是用来实现 XFS Quota 限制的, 可以看到它里面最重要的两步, 分别是 <code>setProjectID</code>​ 和 <code>setProjectQuota</code>​.</p> <p>其实这两步做的就是在基本概念中提到的那两步: 第一步, 给目标目录打上一个 Project ID; 第二步, 为这个 Project ID 在 XFS 文件系统中, 设置一个写入数据块的限制.</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// SetQuota - assign a unique project id to directory and set the quota limits</span>
<span class="token comment">// for that project id</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>q <span class="token operator">*</span>Control<span class="token punctuation">)</span> <span class="token function">SetQuota</span><span class="token punctuation">(</span>targetPath <span class="token builtin">string</span><span class="token punctuation">,</span> quota Quota<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
        q<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        projectID<span class="token punctuation">,</span> ok <span class="token operator">:=</span> q<span class="token punctuation">.</span>quotas<span class="token punctuation">[</span>targetPath<span class="token punctuation">]</span>
        q<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>
                q<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                projectID <span class="token operator">=</span> q<span class="token punctuation">.</span>nextProjectID
                <span class="token comment">//</span>
                <span class="token comment">// assign project id to new container directory</span>
                <span class="token comment">//</span>
                err <span class="token operator">:=</span> <span class="token function">setProjectID</span><span class="token punctuation">(</span>targetPath<span class="token punctuation">,</span> projectID<span class="token punctuation">)</span>
                <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                        q<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> err
                <span class="token punctuation">}</span>
                q<span class="token punctuation">.</span>quotas<span class="token punctuation">[</span>targetPath<span class="token punctuation">]</span> <span class="token operator">=</span> projectID
                q<span class="token punctuation">.</span>nextProjectID<span class="token operator">++</span>
                q<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
 
        <span class="token comment">//</span>
        <span class="token comment">// set the quota limit for the container's project id</span>
        <span class="token comment">//</span>
        logrus<span class="token punctuation">.</span><span class="token function">Debugf</span><span class="token punctuation">(</span><span class="token string">&quot;SetQuota(%s, %d): projectID=%d&quot;</span><span class="token punctuation">,</span> targetPath<span class="token punctuation">,</span> quota<span class="token punctuation">.</span>Size<span class="token punctuation">,</span> projectID<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">setProjectQuota</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>backingFsBlockDev<span class="token punctuation">,</span> projectID<span class="token punctuation">,</span> quota<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>那 <code>setProjectID</code> 和 <code>setProjectQuota</code> 是如何实现的呢?</p> <p>可以进入到这两个函数里看一下, **它们分别调用了 ioctl() 和 quotactl() 这两个系统调用来修改内核中 XFS 的数据结构, 从而完成 project ID 的设置和 Quota 值的设置. ** 具体的细节不在这里展开了, 如果你有兴趣可以继续去查看内核中对应的代码.</p> <p>好了, Docker 里 XFS Quota 操作的步骤完全和先前设想的一样, 那么还有最后一个问题要解决, <strong>XFS Quota 限制的目录</strong>是哪一个? 这个可以根据 /proc/mounts 中容器的 OverlayFS Mount 信息, 再结合 Docker 的代码, 就可以知道限制的目录是 &quot;<code>/var/lib/docker/overlay2/&lt;docker_id&gt;</code>​&quot;. 那这个目录下有什么呢? <strong>果然 upperdir 目录中有对应的 &quot;diff&quot; 目录, 就在里面</strong>!</p> <p><img src="/img/f61912de258cc687227613627b5f61e5-20230731161430-nv8rvp3.png" alt=""></p> <p>讲到这里, 我想你已经清楚了对于使用 OverlayFS 的容器, 应该如何去防止它把宿主机的磁盘给写满了吧? <mark><strong>方法就是对 OverlayFS 的 upperdir 目录做 XFS Quota 的限流</strong></mark>​ **. **</p> <h5 id="_4-重点总结-8"><a href="#_4-重点总结-8" class="header-anchor">#</a> 4.重点总结</h5> <p>本节问题是, 容器写了大量数据到 OverlayFS 文件系统的根目录, 在这个情况下就会把宿主机的磁盘写满.</p> <p>由于 OverlayFS 自己没有专门的特性, 可以限制文件数据写入量. 这时通过实际试验找到了解决思路: <strong>依靠底层文件系统的 Quota 特性来限制 OverlayFS 的 upperdir 目录的大小, 这样就能实现限制容器写磁盘的目的</strong>.</p> <p>底层文件系统 XFS Quota 的 Project 模式, 能够限制一个目录的文件写入量, 这个功能具体是通过这两个步骤实现:</p> <p>**第一步, 给目标目录打上一个 Project ID. **</p> <p>**第二步, 给这个 Project ID 在 XFS 文件系统中设置一个写入数据块的限制. **</p> <p><mark>**Docker 正是使用了这个方法, 也就是用 XFS Quota 来限制 OverlayFS 的 upperdir 目录, 通过这个方式控制容器 OverlayFS 的根目录大小. **</mark></p> <p>当理解了这个方法后, 对于不是用 Docker 启动的容器, 比如直接<strong>由 containerd 启动起来的容器, 也可以自己实现 XFS Quota 限制 upperdir 目录</strong>. 这样就能有效控制容器对 OverlayFS 的写数据操作, 避免宿主机的磁盘被写满.</p> <h4 id="_13-容器磁盘限速-我的容器里磁盘读写为什么不稳定"><a href="#_13-容器磁盘限速-我的容器里磁盘读写为什么不稳定" class="header-anchor">#</a> 13 | 容器磁盘限速:我的容器里磁盘读写为什么不稳定?</h4> <p>本节聊一聊磁盘读写不稳定的问题.</p> <p>上一讲讲了如何通过 XFS Quota 来限制容器文件系统的大小, 这是<strong>静态容量</strong>大小的一个限制.</p> <p>你也许会马上想到, 磁盘除了容量的划分, 还有一个<strong>读写性能</strong>的问题. 具体来说, 就是<strong>如果多个容器同时读写节点上的同一块磁盘, 那么它们的磁盘读写相互之间影响吗? 如果容器之间读写磁盘相互影响, 有什么办法解决呢</strong>?</p> <p>接下来, 就带着问题一起学习今天的内容.</p> <h5 id="_1-场景再现-2"><a href="#_1-场景再现-2" class="header-anchor">#</a> 1.场景再现</h5> <p>先用这里的代码, 运行一下 <code>make image</code>​ 来做一个带 fio 的容器镜像, fio 在之前的课程里提到过, 它是用来<strong>测试磁盘文件系统读写性能</strong>的工具. 有了这个带 fio 的镜像, 可以用它启动一个容器, 在容器中运行 fio, 就可以得到只有一个容器读写磁盘时的性能数据.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /tmp/test1
<span class="token function">docker</span> stop fio_test1<span class="token punctuation">;</span><span class="token function">docker</span> <span class="token function">rm</span> fio_test1
<span class="token function">docker</span> run <span class="token parameter variable">--name</span> fio_test1 <span class="token parameter variable">--volume</span> /tmp/test1:/tmp  registery/fio:v1 fio <span class="token parameter variable">-direct</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">-rw</span><span class="token operator">=</span>write <span class="token parameter variable">-ioengine</span><span class="token operator">=</span>libaio <span class="token parameter variable">-bs</span><span class="token operator">=</span>4k <span class="token parameter variable">-size</span><span class="token operator">=</span>1G <span class="token parameter variable">-numjobs</span><span class="token operator">=</span><span class="token number">1</span>  <span class="token parameter variable">-name</span><span class="token operator">=</span>/tmp/fio_test1.log
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面的这个 Docker 命令, 我给你简单地解释一下: 在这里第一次用到了 &quot;--volume&quot; 这个参数. 之前讲过容器文件系统, 比如 OverlayFS. 不过容器文件系统并不适合频繁地读写. 对于频繁读写的数据, 容器需要把他们到放到 &quot;<strong>volume</strong>&quot; 中. 这里的 <strong>volume 可以是一个本地的磁盘, 也可以是一个网络磁盘</strong>. 在这个例子里就<strong>使用了宿主机本地磁盘, 把磁盘上的 /tmp/test1 目录作为 volume 挂载到容器的 /tmp 目录下</strong>.</p> <p>然后在启动容器之后, 直接运行 fio 的命令, 这里的参数和前面的例子差不多, 只是这次运行的是 <strong>write</strong>, 也就是写磁盘的操作, 而写的目标盘就是挂载到 /tmp 目录的 volume.</p> <p>可以看到, fio 的运行结果如下图所示, IOPS 是 18K, 带宽 (BW) 是 70MB/s 左右.</p> <p><img src="/img/23db24d7da44d9dcf00f4020b9056b2e-20230731161430-a3ual8h.png" alt=""></p> <p>刚才模拟了一个容器写磁盘的性能. 那么如果这时候<strong>有两个容器, 都在往同一个磁盘上写数据又是什么情</strong>况呢? 可以再用下面的这个脚本试一下:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /tmp/test1
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /tmp/test2
<span class="token function">docker</span> stop fio_test1<span class="token punctuation">;</span><span class="token function">docker</span> <span class="token function">rm</span> fio_test1
<span class="token function">docker</span> stop fio_test2<span class="token punctuation">;</span><span class="token function">docker</span> <span class="token function">rm</span> fio_test2
<span class="token function">docker</span> run <span class="token parameter variable">--name</span> fio_test1 <span class="token parameter variable">--volume</span> /tmp/test1:/tmp  registery/fio:v1 fio <span class="token parameter variable">-direct</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">-rw</span><span class="token operator">=</span>write <span class="token parameter variable">-ioengine</span><span class="token operator">=</span>libaio <span class="token parameter variable">-bs</span><span class="token operator">=</span>4k <span class="token parameter variable">-size</span><span class="token operator">=</span>1G <span class="token parameter variable">-numjobs</span><span class="token operator">=</span><span class="token number">1</span>  <span class="token parameter variable">-name</span><span class="token operator">=</span>/tmp/fio_test1.log <span class="token operator">&amp;</span>
<span class="token function">docker</span> run <span class="token parameter variable">--name</span> fio_test2 <span class="token parameter variable">--volume</span> /tmp/test2:/tmp  registery/fio:v1 fio <span class="token parameter variable">-direct</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">-rw</span><span class="token operator">=</span>write <span class="token parameter variable">-ioengine</span><span class="token operator">=</span>libaio <span class="token parameter variable">-bs</span><span class="token operator">=</span>4k <span class="token parameter variable">-size</span><span class="token operator">=</span>1G <span class="token parameter variable">-numjobs</span><span class="token operator">=</span><span class="token number">1</span>  <span class="token parameter variable">-name</span><span class="token operator">=</span>/tmp/fio_test2.log <span class="token operator">&amp;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这时候, 看到的结果, 在容器 fio_test1 里, IOPS 是 15K 左右, 带宽是 59MB/s 了, 比之前单独运行的时候性能下降了不少.</p> <p><img src="/img/f45312b8153cf4f2e4206cfaf6e302cc-20230731161430-njkt770.png" alt=""></p> <p>显然从这个例子中, 可以看到<strong>多个容器同时写一块磁盘的时候, 它的性能受到了干扰</strong>. 那么有什么办法可以保证每个容器的磁盘读写性能呢?</p> <p>之前讨论过用 Cgroups 来保证容器的 CPU 使用率, 以及控制 Memroy 的可用大小. 那么你肯定想到了, 是不是也可以用 Cgroups 来保证每个容器的磁盘读写性能? 没错, 在 Cgroup v1 中有 <strong>blkio</strong> 子系统, 它可以来<strong>限制磁盘的 I/O</strong>. 不过 blkio 子系统对于磁盘 I/O 的限制, 并不像 CPU, Memory 那么直接, 下面会详细讲解.</p> <h5 id="_2-知识详解-5"><a href="#_2-知识详解-5" class="header-anchor">#</a> 2.知识详解</h5> <h6 id="_1-blkio-cgroup"><a href="#_1-blkio-cgroup" class="header-anchor">#</a> (1)Blkio Cgroup</h6> <p>在讲解 blkio Cgroup 前, 先简单了解一下<strong>衡量磁盘性能的两个常见的指标 IOPS 和吞吐量(Throughput)</strong> 是什么意思, 后面讲 Blkio Cgroup 的参数配置时会用到.</p> <p>IOPS 是 Input/Output Operations Per Second 的简称, 也就是<strong>每秒钟磁盘读写的次数</strong>, 这个数值越大, 当然也就表示性能越好.</p> <p>吞吐量(Throughput)是指<strong>每秒钟磁盘中数据的读取量, 一般以 MB/s 为单位</strong>. 这个读取量可以叫作吞吐量, 有时候也被称为带宽(Bandwidth). 刚才用到的 fio 显示结果就体现了带宽.</p> <p>IOPS 和吞吐量之间是有关联的, 在 IOPS 固定的情况下, 如果读写的每一个数据块越大, 那么吞吐量也越大, 它们的关系大概是这样的: <strong>吞吐量 = 数据块大小 * IOPS</strong>.</p> <p>再回到 blkio Cgroup 这个概念上, <strong>blkio Cgroup 也是 Cgroups 里的一个子系统</strong>. 在 Cgroups v1 里, blkio Cgroup 的虚拟文件系统挂载点一般在 &quot; <strong>/sys/fs/cgroup/blkio/</strong> &quot;. 和之前讲过的 CPU, memory Cgroup 一样, <strong>在这个 &quot;/sys/fs/cgroup/blkio/&quot; 目录下创建子目录作为控制组, 再把需要做 I/O 限制的进程 pid 写到控制组的 cgroup.procs 参数中就可以了</strong>.</p> <p>在 blkio Cgroup 中, 有四个最主要的参数, 它们可以用来<strong>限制磁盘 I/O 性能</strong>, 如下所示.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>blkio.throttle.read_iops_device
blkio.throttle.read_bps_device
blkio.throttle.write_iops_device
blkio.throttle.write_bps_device
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>前面刚说了磁盘 I/O 的两个主要性能指标 IOPS 和吞吐量, 在这里根据这四个参数的名字, 其实已经大概猜到它们的意思了. 它们分别表示: <strong>磁盘读取 IOPS 限制, 磁盘读取吞吐量限制, 磁盘写入 IOPS 限制, 磁盘写入吞吐量限制</strong>.</p> <p>对于每个参数写入值的格式, 可以参考内核blkio 的文档. 为了让你更好地理解, 在这里举个例子. 如果要对一个控制组做限制, 限制它<strong>对磁盘 /dev/vdb 的写入吞吐量不超过 10MB/s</strong>, 那么对 blkio.throttle.write_bps_device 参数的配置就是下面这个命令.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token builtin class-name">echo</span> <span class="token string">&quot;252:16 10485760&quot;</span> <span class="token operator">&gt;</span> <span class="token variable">$CGROUP_CONTAINER_PATH</span>/blkio.throttle.write_bps_device
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在这个命令中, &quot;252:16&quot; 是 /dev/vdb 的<strong>主次设备号</strong>, 可以通过 <code>ls -l /dev/vdb</code>​ 看到这两个值, 而后面的 &quot;10485760&quot; 就是 10MB 的每秒钟带宽限制.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># ls -l /dev/vdb -l</span>
brw-rw---- <span class="token number">1</span> root disk <span class="token number">252</span>, <span class="token number">16</span> Nov  <span class="token number">2</span> 08:02 /dev/vdb
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>了解了 blkio Cgroup 的参数配置, 再运行下面的这个例子, <strong>限制一个容器 blkio 的读写磁盘吞吐量</strong>, 然后在这个容器里运行一下 fio, 看看结果是什么.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /tmp/test1
<span class="token function">rm</span> <span class="token parameter variable">-f</span> /tmp/test1/*
<span class="token function">docker</span> stop fio_test1<span class="token punctuation">;</span><span class="token function">docker</span> <span class="token function">rm</span> fio_test1
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> fio_test1 <span class="token parameter variable">--volume</span> /tmp/test1:/tmp  registery/fio:v1 <span class="token function">sleep</span> <span class="token number">3600</span>
<span class="token function">sleep</span> <span class="token number">2</span>
<span class="token assign-left variable">CONTAINER_ID</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">sudo</span> <span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">--format</span> <span class="token string">&quot;{{.ID}}<span class="token entity" title="\t">\t</span>{{.Names}}&quot;</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> fio_test1 <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $1}'</span><span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token variable">$CONTAINER_ID</span>
<span class="token assign-left variable">CGROUP_CONTAINER_PATH</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">find</span> /sys/fs/cgroup/blkio/ <span class="token parameter variable">-name</span> <span class="token string">&quot;*<span class="token variable">$CONTAINER_ID</span>*&quot;</span><span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token variable">$CGROUP_CONTAINER_PATH</span>
<span class="token comment"># To get the device major and minor id from /dev for the device that /tmp/test1 is on.</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;253:0 10485760&quot;</span> <span class="token operator">&gt;</span> <span class="token variable">$CGROUP_CONTAINER_PATH</span>/blkio.throttle.read_bps_device
<span class="token builtin class-name">echo</span> <span class="token string">&quot;253:0 10485760&quot;</span> <span class="token operator">&gt;</span> <span class="token variable">$CGROUP_CONTAINER_PATH</span>/blkio.throttle.write_bps_device
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> fio_test1 fio <span class="token parameter variable">-direct</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">-rw</span><span class="token operator">=</span>write <span class="token parameter variable">-ioengine</span><span class="token operator">=</span>libaio <span class="token parameter variable">-bs</span><span class="token operator">=</span>4k <span class="token parameter variable">-size</span><span class="token operator">=</span>100MB <span class="token parameter variable">-numjobs</span><span class="token operator">=</span><span class="token number">1</span>  <span class="token parameter variable">-name</span><span class="token operator">=</span>/tmp/fio_test1.log
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> fio_test1 fio <span class="token parameter variable">-direct</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">-rw</span><span class="token operator">=</span>read <span class="token parameter variable">-ioengine</span><span class="token operator">=</span>libaio <span class="token parameter variable">-bs</span><span class="token operator">=</span>4k <span class="token parameter variable">-size</span><span class="token operator">=</span>100MB <span class="token parameter variable">-numjobs</span><span class="token operator">=</span><span class="token number">1</span>  <span class="token parameter variable">-name</span><span class="token operator">=</span>/tmp/fio_test1.log
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>在这里, 我的机器上 /tmp/test1 所在磁盘主次设备号是 &quot;253:0&quot;, 自己运行这组命令的时候, 需要把主次设备号改成自己磁盘的对应值. 还有一点要提醒一下, 不同数据块大小, 在性能测试中可以适用于不同的测试目的. 但因为这里不是要讲的重点, 所以为了方便理解概念, 这里就用固定值. 在后面的例子里, fio 读写的数据块都<strong>固定在 4KB</strong>. 所以对于磁盘的性能限制, 在 blkio Cgroup 里就只设置吞吐量限制了.</p> <p>在加了 blkio Cgroup 限制 10MB/s 后, 从 fio 运行后的输出结果里, 可以看到这个容器对磁盘无论是<strong>读还是写</strong>, 它的最大值就不会再超过 10MB/s 了.</p> <p><img src="/img/40bd4d165d174a6a4563651e6ac77322-20230731161430-7q3ls2a.png" alt=""></p> <p><img src="/img/d20f09f220d19ec82ce7203e788ad950-20230731161430-ugsj09q.png" alt=""></p> <p>**在给每个容器都加了 blkio Cgroup 限制, 限制为 10MB/s 后, 即使两个容器同时在一个磁盘上写入文件, 那么每个容器的写入磁盘的最大吞吐量, 也不会互相干扰了. **</p> <p>可以用下面的这个脚本来验证一下.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /tmp/test1
<span class="token function">rm</span> <span class="token parameter variable">-f</span> /tmp/test1/*
<span class="token function">docker</span> stop fio_test1<span class="token punctuation">;</span><span class="token function">docker</span> <span class="token function">rm</span> fio_test1
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /tmp/test2
<span class="token function">rm</span> <span class="token parameter variable">-f</span> /tmp/test2/*
<span class="token function">docker</span> stop fio_test2<span class="token punctuation">;</span><span class="token function">docker</span> <span class="token function">rm</span> fio_test2
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> fio_test1 <span class="token parameter variable">--volume</span> /tmp/test1:/tmp  registery/fio:v1 <span class="token function">sleep</span> <span class="token number">3600</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> fio_test2 <span class="token parameter variable">--volume</span> /tmp/test2:/tmp  registery/fio:v1 <span class="token function">sleep</span> <span class="token number">3600</span>
<span class="token function">sleep</span> <span class="token number">2</span>
<span class="token assign-left variable">CONTAINER_ID1</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">sudo</span> <span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">--format</span> <span class="token string">&quot;{{.ID}}<span class="token entity" title="\t">\t</span>{{.Names}}&quot;</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> fio_test1 <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $1}'</span><span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token variable">$CONTAINER_ID1</span>
<span class="token assign-left variable">CGROUP_CONTAINER_PATH1</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">find</span> /sys/fs/cgroup/blkio/ <span class="token parameter variable">-name</span> <span class="token string">&quot;*<span class="token variable">$CONTAINER_ID1</span>*&quot;</span><span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token variable">$CGROUP_CONTAINER_PATH1</span>
<span class="token comment"># To get the device major and minor id from /dev for the device that /tmp/test1 is on.</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;253:0 10485760&quot;</span> <span class="token operator">&gt;</span> <span class="token variable">$CGROUP_CONTAINER_PATH1</span>/blkio.throttle.read_bps_device
<span class="token builtin class-name">echo</span> <span class="token string">&quot;253:0 10485760&quot;</span> <span class="token operator">&gt;</span> <span class="token variable">$CGROUP_CONTAINER_PATH1</span>/blkio.throttle.write_bps_device
<span class="token assign-left variable">CONTAINER_ID2</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">sudo</span> <span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">--format</span> <span class="token string">&quot;{{.ID}}<span class="token entity" title="\t">\t</span>{{.Names}}&quot;</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> fio_test2 <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $1}'</span><span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token variable">$CONTAINER_ID2</span>
<span class="token assign-left variable">CGROUP_CONTAINER_PATH2</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">find</span> /sys/fs/cgroup/blkio/ <span class="token parameter variable">-name</span> <span class="token string">&quot;*<span class="token variable">$CONTAINER_ID2</span>*&quot;</span><span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token variable">$CGROUP_CONTAINER_PATH2</span>
<span class="token comment"># To get the device major and minor id from /dev for the device that /tmp/test1 is on.</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;253:0 10485760&quot;</span> <span class="token operator">&gt;</span> <span class="token variable">$CGROUP_CONTAINER_PATH2</span>/blkio.throttle.read_bps_device
<span class="token builtin class-name">echo</span> <span class="token string">&quot;253:0 10485760&quot;</span> <span class="token operator">&gt;</span> <span class="token variable">$CGROUP_CONTAINER_PATH2</span>/blkio.throttle.write_bps_device
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> fio_test1 fio <span class="token parameter variable">-direct</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">-rw</span><span class="token operator">=</span>write <span class="token parameter variable">-ioengine</span><span class="token operator">=</span>libaio <span class="token parameter variable">-bs</span><span class="token operator">=</span>4k <span class="token parameter variable">-size</span><span class="token operator">=</span>100MB <span class="token parameter variable">-numjobs</span><span class="token operator">=</span><span class="token number">1</span>  <span class="token parameter variable">-name</span><span class="token operator">=</span>/tmp/fio_test1.log <span class="token operator">&amp;</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> fio_test2 fio <span class="token parameter variable">-direct</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">-rw</span><span class="token operator">=</span>write <span class="token parameter variable">-ioengine</span><span class="token operator">=</span>libaio <span class="token parameter variable">-bs</span><span class="token operator">=</span>4k <span class="token parameter variable">-size</span><span class="token operator">=</span>100MB <span class="token parameter variable">-numjobs</span><span class="token operator">=</span><span class="token number">1</span>  <span class="token parameter variable">-name</span><span class="token operator">=</span>/tmp/fio_test2.log <span class="token operator">&amp;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>还是看看 fio 运行输出的结果, 这时候, fio_test1 和 fio_test2 两个容器里执行的结果都是 10MB/s 了.</p> <p><img src="/img/d9ca21124a285b8f75323060089c6630-20230731161430-c11ov2s.png" alt=""></p> <p><img src="/img/d91cbb027126df5608329a3e44bacf07-20230731161430-ek3lzds.png" alt=""></p> <p>那么做到了这一步, 是不是就可以认为, blkio Cgroup 可以完美地对磁盘 I/O 做限制了呢?</p> <p>先别急, 可以再做个试验, 把前面脚本里 fio 命令中的 &quot; <strong>-direct=1</strong>&quot; 给去掉, 也就是不让 fio 运行在 Direct I/O 模式了, 而是用 <strong>Buffered I/O</strong> 模式再运行一次, 看看 fio 执行的输出. 同时也可以运行 iostat 命令, 查看实际的磁盘写入速度. 这时候你会发现, 即使设置了 blkio Cgroup, 也根本<strong>不能</strong>限制磁盘的吞吐量了.</p> <h6 id="_2-direct-i-o-和-buffered-i-o"><a href="#_2-direct-i-o-和-buffered-i-o" class="header-anchor">#</a> (2)Direct I/O 和 Buffered I/O</h6> <p>为什么会这样的呢? 这就要提到 Linux 的两种文件 I/O 模式了: <strong>Direct I/O 和 Buffered I/O</strong>.</p> <p>Direct I/O 模式, 用户进程如果要写磁盘文件, 就会通过 Linux 内核的<strong>文件系统层 (filesystem) -&gt; 块设备层 (block layer) -&gt; 磁盘驱动 -&gt; 磁盘硬件, 这样一路下去写入磁盘</strong>.</p> <p>而如果是 Buffered I/O 模式, 那么用户进程只是把<strong>文件数据写到内存中(Page Cache)</strong> 就返回了, 而 Linux 内核自己有线程会把内存中的数据再写入到磁盘中. <mark><strong>在 Linux 里, 由于考虑到性能问题, 绝大多数的应用都会使用 Buffered I/O 模式</strong></mark>​ **. **</p> <p><img src="/img/a0f67ebbbbc5557dcdaf5c99c82a566b-20230731161430-5oo2hm6.png" alt=""></p> <p>通过前面的测试, <strong>发现 Direct I/O 可以通过 blkio Cgroup 来限制磁盘 I/O, 但是 Buffered I/O 不能被限制</strong>.</p> <p>那通过上面的两种 I/O 模式的解释, 你是不是可以想到原因呢? 是的, 原因就是<strong>被 Cgroups v1 的架构限制</strong>了.</p> <p>前面已经学习过了 v1 的 CPU Cgroup, memory Cgroup 和 blkio Cgroup, 那么 Cgroup v1 的一个整体结构, 你应该已经很熟悉了. <strong>它的每一个子系统都是独立的, 资源的限制只能在子系统中发生</strong>.</p> <p>就像下面图里的<strong>进程 pid_y</strong>, <strong>它可以分别属于 memory Cgroup 和 blkio Cgroup. 但是在 blkio Cgroup 对进程 pid_y 做磁盘 I/O 做限制的时候, blkio 子系统是不会去关心 pid_y 用了哪些内存, 哪些内存是不是属于 Page Cache, 而这些 Page Cache 的页面在刷入磁盘的时候, 产生的 I/O 也不会被计算到进程 pid_y 上面</strong>.</p> <p>就是这个原因, <strong>导致了 blkio 在 Cgroups v1 里不能限制 Buffered I/O</strong>.</p> <p><img src="/img/e6a89d666b2420293d69509554ec3785-20230731161430-27bc1c5.png" alt=""></p> <p>这个 Buffered I/O 限速的问题, <strong>在 Cgroup V2 里得到了解决</strong>, 其实这个问题也是促使 Linux 开发者重新设计 Cgroup V2 的原因之一.</p> <h5 id="_3-cgroup-v2"><a href="#_3-cgroup-v2" class="header-anchor">#</a> 3.Cgroup V2</h5> <p>Cgroup v2 相比 Cgroup v1 做的最大的变动就是<strong>一个进程属于一个控制组, 而每个控制组里可以定义自己需要的多个子系统</strong>.</p> <p>比如下面的 Cgroup V2 示意图里, 进程 pid_y 属于控制组 group2, 而在 group2 里<strong>同时打开了 io 和 memory 子系统</strong> (Cgroup V2 里的 io 子系统就等同于 Cgroup v1 里的 blkio 子系统).</p> <p>那么, <strong>Cgroup 对进程 pid_y 的磁盘 I/O 做限制的时候, 就可以考虑到进程 pid_y 写入到 Page Cache 内存的页面了, 这样 buffered I/O 的磁盘限速就实现</strong>了.</p> <p><img src="/img/9e335f68ae8d9872080b733e04b33038-20230731161430-om3536m.png" alt=""></p> <p>下面在 Cgroup v2 里, 尝试一下设置了 blkio Cgroup+Memory Cgroup 之后, 是否可以对 Buffered I/O 进行磁盘限速.</p> <p>要做的第一步, 就是在 Linux 系统里打开 Cgroup v2 的功能. 因为目前即使最新版本的 Ubuntu Linux 或者 Centos Linux, 仍然在使用 Cgroup v1 作为缺省的 Cgroup. 打开方法就是配置一个 kernel 参数 &quot;cgroup_no_v1=blkio,memory&quot;, 这表示把 Cgroup v1 的 blkio 和 Memory 两个子系统给禁止, 这样 Cgroup v2 的 io 和 Memory 这两个子系统就打开了. 可以把这个参数配置到 grub 中, 然后重启 Linux 机器, 这时 Cgroup v2 的 io 还有 Memory 这两个子系统, 它们的功能就打开了.</p> <p>系统重启后, 会看到 Cgroup v2 的<strong>虚拟文件系统被挂载到了 /sys/fs/cgroup/unified 目录</strong>下.</p> <p>然后, 用下面的这个脚本做 Cgroup v2 io 的限速配置, 并且运行 fio, 看看 buffered I/O 是否可以被限速.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># Create a new control group</span>
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /sys/fs/cgroup/unified/iotest
<span class="token comment"># enable the io and memory controller subsystem</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;+io +memory&quot;</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/unified/cgroup.subtree_control
<span class="token comment"># Add current bash pid in iotest control group.</span>
<span class="token comment"># Then all child processes of the bash will be in iotest group too,</span>
<span class="token comment"># including the fio</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$$</span> <span class="token operator">&gt;</span>/sys/fs/cgroup/unified/iotest/cgroup.procs
<span class="token comment"># 256:16 are device major and minor ids, /mnt is on the device.</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;252:16 wbps=10485760&quot;</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/unified/iotest/io.max
<span class="token builtin class-name">cd</span> /mnt
<span class="token comment">#Run the fio in non direct I/O mode</span>
fio <span class="token parameter variable">-iodepth</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">-rw</span><span class="token operator">=</span>write <span class="token parameter variable">-ioengine</span><span class="token operator">=</span>libaio <span class="token parameter variable">-bs</span><span class="token operator">=</span>4k <span class="token parameter variable">-size</span><span class="token operator">=</span>1G <span class="token parameter variable">-numjobs</span><span class="token operator">=</span><span class="token number">1</span>  <span class="token parameter variable">-name</span><span class="token operator">=</span>./fio.test
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>在这个例子里, 建立了一个<strong>名叫 iotest 的控制组, 并且在这个控制组里加入了 io 和 Memory 两个控制子系统, 对磁盘最大吞吐量的设置为 10MB</strong>. 运行 fio 的时候不加 &quot;-direct=1&quot;, 也就是让 fio 运行在 <strong>buffered I/O</strong> 模式下.</p> <p>运行 fio 写入 1GB 的数据后, 你会发现 fio 马上就执行完了, 因为系统上有足够的内存, <strong>fio 把数据写入内存就返回了</strong>, 不过只要再运行 &quot;iostat -xz 10&quot; 这个命令, 就可以看到<strong>磁盘 vdb 上稳定的写入速率</strong>是 10240wkB/s, 也就是在 io Cgroup 里限制的 10MB/s.</p> <p><img src="/img/330d7c4fe7224c81b635a7b8139aaa0b-20230731161430-rs60uet.png" alt=""></p> <p>这个结果证实了 <strong>Cgoupv2 io+Memory 两个子系统一起使用, 就可以对 buffered I/O 控制磁盘写入速率</strong>.</p> <h5 id="_4-重点总结-9"><a href="#_4-重点总结-9" class="header-anchor">#</a> 4.重点总结</h5> <p>这一讲主要想解决的问题是如何保证容器读写磁盘速率的稳定, 特别是当多个容器同时读写同一个磁盘的时候, 需要减少相互的干扰.</p> <p>Cgroup V1 的 blkiio 控制子系统, 可以用来限制容器中进程的读写的 IOPS 和吞吐量(Throughput), 但是它只能对于 <strong>Direct I/O 的读写文件做磁盘限速, 对 Buffered I/O 的文件读写, 它无法进行磁盘限速</strong>.</p> <p><mark>**这是因为 Buffered I/O 会把数据先写入到内存 Page Cache 中, 然后由内核线程把数据写入磁盘, 而 Cgroup v1 blkio 的子系统独立于 memory 子系统, 无法统计到由 Page Cache 刷入到磁盘的数据量. **</mark> 这个 Buffered I/O 无法被限速的问题, 在 Cgroup v2 里被解决了. Cgroup v2 从架构上允许一个控制组里有多个子系统协同运行, 这样在一个控制组里只要同时有 io 和 Memory 子系统, 就可以对 Buffered I/O 作磁盘读写的限速.</p> <p>虽然 Cgroup v2 解决了 Buffered I/O 磁盘读写限速的问题, 但是在现实的容器平台上也不是能够立刻使用的, 还需要等待一段时间. 目前从 runC, containerd 到 Kubernetes 都是刚刚开始支持 Cgroup v2, 而对生产环境中原有运行 Cgroup v1 的节点要迁移转化成 Cgroup v2 需要一个过程.</p> <h4 id="_14-容器中的内存与i-o-容器写文件的延时为什么波动很大"><a href="#_14-容器中的内存与i-o-容器写文件的延时为什么波动很大" class="header-anchor">#</a> 14 | 容器中的内存与I/O:容器写文件的延时为什么波动很大?</h4> <p>本节继续聊一聊容器中写文件性能波动的问题.</p> <p>上一讲中讲过 Linux 中的两种 I/O 模式, Direct I/O 和 Buffered I/O. <strong>对于 Linux 的系统调用 write() 来说, Buffered I/O 是缺省模式</strong>, 使用起来比较方便, 而且从用户角度看, 在大多数的应用场景下, 用 Buffered I/O 的 write() 函数调用返回要快一些. 所以, Buffered I/O 在程序中使用得更<strong>普遍</strong>一些.</p> <p>**当使用 Buffered I/O 的应用程序从虚拟机迁移到容器, 这时就会发现多了 Memory Cgroup 的限制之后, write() 写相同大小的数据块花费的时间, 延时波动会比较大. **</p> <p>这是怎么回事呢? 接下来就带着问题开始今天的学习.</p> <h5 id="_1-问题再现-9"><a href="#_1-问题再现-9" class="header-anchor">#</a> 1.问题再现</h5> <p>可以先动手写一个小程序, 用来模拟刚刚说的现象. 这个小程序这样来设计: <strong>从一个文件中每次读取一个 64KB 大小的数据块, 然后写到一个新文件中, 它可以不断读写 10GB 大小的数据. 同时在这个小程序中做个记录, 记录写每个 64KB 的数据块需要花费的时间.</strong></p> <p>可以先在<strong>虚拟机</strong>里直接运行, 虚拟机里内存大小是大于 10GB 的. 接着把这个程序放到<strong>容器</strong>中运行, 因为这个程序本身并不需要很多的内存, 给它做了一个 Memory Cgroup 的内存限制, 设置为 1GB.</p> <p>运行结束后, 比较一下程序写数据块的时间. 把结果画了一张图, 图里的纵轴是时间, 单位 us; 横轴是次数, 在这里记录了 96 次. 图中橘红色的线是在容器里运行的结果, 蓝色的线是在虚拟机上运行的结果.</p> <p>结果很明显, <strong>在容器中写入数据块的时间会时不时地增高到 200us</strong>; 而在虚拟机里的写入数据块时间就比较平稳, 一直在 30～50us 这个范围内.</p> <p><img src="/img/dc4bc8ed6423f45da1f32e0d257684ef-20230731161430-80w948r.png" alt=""></p> <p>通过这个小程序, 再现了问题, 那就来分析一下, 为什么会产生这样的结果.</p> <h5 id="_2-时间波动是因为dirty-pages的影响么"><a href="#_2-时间波动是因为dirty-pages的影响么" class="header-anchor">#</a> 2.时间波动是因为Dirty Pages的影响么?</h5> <p>对文件的<strong>写入操作是 Buffered I/O</strong>. 在前一讲中其实已经知道了, <mark><strong>对于 Buffer I/O, 用户的数据是先写入到 Page Cache 里的. 而这些写入了数据的内存页面, 在它们没有被写入到磁盘文件之前, 就被叫作 dirty pages. Linux 内核会有专门的内核线程(每个磁盘设备对应的 kworker/flush 线程)把 dirty pages 写入到磁盘中</strong></mark>.</p> <p>那我们自然会这样猜测, 也许是 Linux 内核对 dirty pages 的操作影响了 Buffered I/O 的写操作?</p> <p>想要验证这个想法, 需要先来看看 dirty pages 是在什么时候被写入到磁盘的. 这里就要用到  <strong>/proc/sys/vm 里和 dirty page 相关的内核参数</strong>了, 需要知道所有相关参数的含义, 才能判断出最后真正导致问题发生的原因.</p> <p>现在挨个来看一下. 为了方便后面的讲述, 可以设定一个比值 A, <mark><strong>A 等于 dirty pages 的内存 / 节点可用内存 100%</strong></mark> .</p> <p>第一个参数, <strong>dirty_background_ratio</strong>, 这个参数里的数值是一个百分比值, 缺省是 10%. 如果比值 A 大于 dirty_background_ratio 的话, 比如大于默认的 10%, <strong>内核 flush 线程就会把 dirty pages 刷到磁盘里</strong>.</p> <p>第二个参数, 是和 dirty_background_ratio 相对应一个参数, 也就是 <strong>dirty_background_bytes</strong>, 它和 dirty_background_ratio 作用相同. 区别只是 dirty_background_bytes 是具体的<strong>字节数</strong>, 它用来定义的是 dirty pages 内存的临界值, 而不是比例值.</p> <p>这里还要注意, <strong>dirty_background_ratio 和 dirty_background_bytes 只有一个可以起作用</strong>, 如果给其中一个赋值之后, 另外一个参数就归 0 了.</p> <p>接下来看第三个参数, <strong>dirty_ratio</strong>, 这个参数的数值也是一个百分比值, 缺省是 20%. 如果比值 A, 大于参数 dirty_ratio 的值, 比如大于默认设置的 20%, 这时候正在执行 Buffered I/O 写文件的进程就会被阻塞住, 直到它写的数据页面都写到磁盘为止.</p> <p>同样, 第四个参数 <strong>dirty_bytes</strong> 与 dirty_ratio 相对应, 它们的关系和 dirty_background_ratio 与 dirty_background_bytes 一样. 给其中一个赋值后, 另一个就会归零.</p> <p>然后来看 <strong>dirty_writeback_centisecs</strong>, 这个参数的值是个<strong>时间值</strong>, 以百分之一秒为单位, 缺省值是 500, 也就是 5 秒钟. 它表示<strong>每 5 秒钟会唤醒内核的 flush 线程来处理 dirty pages</strong>.</p> <p>最后还有 <strong>dirty_expire_centisecs</strong>, 这个参数的值也是一个时间值, 以百分之一秒为单位, 缺省值是 3000, 也就是 30 秒钟. 它定义了 dirty page 在内存中存放的<strong>最长时间</strong>, 如果一个 dirty page 超过这里定义的时间, 那么内核的 flush 线程也会把这个页面写入磁盘.</p> <p>好了, 从这些 dirty pages 相关的参数定义, 你会想到些什么呢?</p> <p>**进程写操作上的时间波动, 只有可能是因为 dirty pages 的数量很多, 已经达到了第三个参数 dirty_ratio 的值. 这时执行写文件功能的进程就会被暂停, 直到写文件的操作将数据页面写入磁盘, 写文件的进程才能继续运行, 所以进程里一次写文件数据块的操作时间会增加. **</p> <p>刚刚说的只是推理, 那情况真的会是这样吗? 其实可以在容器中进程不断写入数据的时候, <strong>查看节点上 dirty pages 的实时数目</strong>. 具体操作如下:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token function">watch</span> <span class="token parameter variable">-n</span> <span class="token number">1</span> <span class="token string">&quot;cat /proc/vmstat | grep dirty&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>当节点可用内存是 12GB 的时候, 假设 dirty_ratio 是 20%, dirty_background_ratio 是 10%, 那么在 1GB memory 容器中写 10GB 的数据, 就会看到它实时的 dirty pages 数目, 也<strong>就是 /proc/vmstat 里的 nr_dirty 的数值</strong>, 这个数值对应的内存并不能达到 dirty_ratio 所占的内存值.</p> <p><img src="/img/ffa122a6dc84d8093e2f84a08bdfdddb-20230731161430-4tp3agg.png" alt=""></p> <p>其实还可以再做个实验, 就是在 dirty_bytes 和 dirty_background_bytes 里写入一个很小的值.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token builtin class-name">echo</span> <span class="token number">8192</span> <span class="token operator">&gt;</span> /proc/sys/vm/dirty_bytes
<span class="token builtin class-name">echo</span> <span class="token number">4096</span> <span class="token operator">&gt;</span> /proc/sys/vm/dirty_background_bytes
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>然后再记录一下容器程序里每写入 64KB 数据块的时间, 这时候就会看到, 时不时一次写入的时间就会达到 9ms, 这已经远远高于之前看到的 200us 了.</p> <p>因此, 我们知道了这个<strong>时间的波动, 并不是强制把 dirty page 写入到磁盘引起的</strong>.</p> <h5 id="_3-调试问题"><a href="#_3-调试问题" class="header-anchor">#</a> 3.调试问题</h5> <p>那接下来还能怎么分析这个问题呢?</p> <p>可以<strong>用 perf 和 ftrace 这两个工具</strong>, 对容器里写数据块的进程做个 profile, 看看到底是调用哪个<strong>函数</strong>花费了比较长的时间. 后面会专门介绍如何使用 perf, ftrace 等工具以及它们的工作原理, 在这里只要了解调试思路就行.</p> <p>怎么使用这两个工具去定位耗时高的函数呢? 大致思路是这样的: 我们发现容器中的进程用到了 write() 这个函数调用, 然后写 64KB 数据块的时间增加了, 而 write() 是一个系统调用, 那需要进行下面这两步操作.</p> <p>**第一步, 要找到内核中 write() 这个系统调用函数下, 又调用了哪些子函数. ** 想找出主要的子函数可以查看代码, 也可以用 perf 这个工具来得到.</p> <p>然后是**第二步, 得到了 write() 的主要子函数之后, 可以用 ftrace 这个工具来 trace 这些函数的执行时间, 这样就可以找到花费时间最长的函数了. **</p> <p>下面就按照刚才梳理的思路来做一下. 首先是第一步, 在容器启动写磁盘的进程后, 在宿主机上得到这个进程的 pid, 然后运行下面的 perf 命令.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>perf record <span class="token parameter variable">-a</span> <span class="token parameter variable">-g</span> <span class="token parameter variable">-p</span> <span class="token operator">&lt;</span>pid<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>等写磁盘的进程退出之后, 这个 perf record 也就停止了.</p> <p>这时再执行 <code>perf report</code>​ 查看结果. 把 vfs_write() 函数展开之后, 就可以看到, write() 这个系统调用下面的调用到了哪些主要的子函数, 到这里第一步就完成了.</p> <p><img src="/img/4a756f36dd2c4a4ee4829e5d66835a8e-20230731161430-sui6afm.png" alt=""></p> <p>下面再来做第二步, 把主要的函数写入到 ftrace 的 set_ftrace_filter 里, 然后把 ftrace 的 tracer 设置为 function_graph, 并且<strong>打开 tracing_on 开启追踪</strong>.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># cd /sys/kernel/debug/tracing</span>
<span class="token comment"># echo vfs_write &gt;&gt; set_ftrace_filter</span>
<span class="token comment"># echo xfs_file_write_iter &gt;&gt; set_ftrace_filter</span>
<span class="token comment"># echo xfs_file_buffered_aio_write &gt;&gt; set_ftrace_filter</span>
<span class="token comment"># echo iomap_file_buffered_write</span>
<span class="token comment"># echo iomap_file_buffered_write &gt;&gt; set_ftrace_filter</span>
<span class="token comment"># echo pagecache_get_page &gt;&gt; set_ftrace_filter</span>
<span class="token comment"># echo try_to_free_mem_cgroup_pages &gt;&gt; set_ftrace_filter</span>
<span class="token comment"># echo try_charge &gt;&gt; set_ftrace_filter</span>
<span class="token comment"># echo mem_cgroup_try_charge &gt;&gt; set_ftrace_filter</span>
<span class="token comment"># echo function_graph &gt; current_tracer</span>
<span class="token comment"># echo 1 &gt; tracing_on</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>这些设置完成之后, 再运行一下容器中的写磁盘程序, 同时<strong>从 ftrace 的 trace_pipe 中读取出追踪到的这些函数</strong>.</p> <p>这时可以看到, 当<strong>需要申请 Page Cache 页面的时候, write() 系统调用会反复地调用 mem_cgroup_try_charge()</strong> , 并且在释放页面的时候, 函数 do_try_to_free_pages() 花费的时间特别长, 有 50+us(时间单位, micro-seconds)这么多.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span><span class="token punctuation">)</span>               <span class="token operator">|</span>  <span class="token function-name function">vfs_write</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">1</span><span class="token punctuation">)</span>               <span class="token operator">|</span>    xfs_file_write_iter <span class="token punctuation">[</span>xfs<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">1</span><span class="token punctuation">)</span>               <span class="token operator">|</span>      xfs_file_buffered_aio_write <span class="token punctuation">[</span>xfs<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">1</span><span class="token punctuation">)</span>               <span class="token operator">|</span>        <span class="token function-name function">iomap_file_buffered_write</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">1</span><span class="token punctuation">)</span>               <span class="token operator">|</span>          <span class="token function-name function">pagecache_get_page</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">1</span><span class="token punctuation">)</span>               <span class="token operator">|</span>            <span class="token function-name function">mem_cgroup_try_charge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">1</span><span class="token punctuation">)</span>   <span class="token number">0.338</span> us    <span class="token operator">|</span>              try_charge<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">1</span><span class="token punctuation">)</span>   <span class="token number">0.791</span> us    <span class="token operator">|</span>            <span class="token punctuation">}</span>
<span class="token number">1</span><span class="token punctuation">)</span>   <span class="token number">4.127</span> us    <span class="token operator">|</span>          <span class="token punctuation">}</span>
…
<span class="token number">1</span><span class="token punctuation">)</span>               <span class="token operator">|</span>          <span class="token function-name function">pagecache_get_page</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">1</span><span class="token punctuation">)</span>               <span class="token operator">|</span>            <span class="token function-name function">mem_cgroup_try_charge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">1</span><span class="token punctuation">)</span>               <span class="token operator">|</span>              <span class="token function-name function">try_charge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">1</span><span class="token punctuation">)</span>               <span class="token operator">|</span>                <span class="token function-name function">try_to_free_mem_cgroup_pages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">1</span><span class="token punctuation">)</span> + <span class="token number">52.798</span> us   <span class="token operator">|</span>                  do_try_to_free_pages<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">1</span><span class="token punctuation">)</span> + <span class="token number">53.958</span> us   <span class="token operator">|</span>                <span class="token punctuation">}</span>
<span class="token number">1</span><span class="token punctuation">)</span> + <span class="token number">54.751</span> us   <span class="token operator">|</span>              <span class="token punctuation">}</span>
<span class="token number">1</span><span class="token punctuation">)</span> + <span class="token number">55.188</span> us   <span class="token operator">|</span>            <span class="token punctuation">}</span>
<span class="token number">1</span><span class="token punctuation">)</span> + <span class="token number">56.742</span> us   <span class="token operator">|</span>          <span class="token punctuation">}</span>
…
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!</span> <span class="token number">109.925</span> us  <span class="token operator">|</span>        <span class="token punctuation">}</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!</span> <span class="token number">110.558</span> us  <span class="token operator">|</span>      <span class="token punctuation">}</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!</span> <span class="token number">110.984</span> us  <span class="token operator">|</span>    <span class="token punctuation">}</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!</span> <span class="token number">111.515</span> us  <span class="token operator">|</span>  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>看到这个 ftrace 的结果, 你是不是会想到, 我们在容器内存那一讲中提到的 Page Cahe 呢? 是的, 这个问题的确和 Page Cache 有关, <strong>Linux 会把所有的空闲内存利用起来, 一旦有 Buffered I/O, 这些内存都会被用作 Page Cache</strong>. 当容器加了 Memory Cgroup 限制了内存之后, 对于容器里的 Buffered I/O, <strong>就只能使用容器中允许使用的最大内存来做 Page Cache</strong>.</p> <p><mark>**那么如果容器在做内存限制的时候, Cgroup 中 memory.limit_in_bytes 设置得比较小, 而容器中的进程又有很大量的 I/O, 这样申请新的 Page Cache 内存的时候, 又会不断释放老的内存页面, 这些操作就会带来额外的系统开销了. **</mark></p> <h5 id="_4-重点总结-10"><a href="#_4-重点总结-10" class="header-anchor">#</a> 4.重点总结</h5> <p>本节讨论的问题是在容器中用 Buffered I/O 方式写文件的时候, 会出现写入时间波动的问题.</p> <p>由于这是 Buffered I/O 方式, 对于写入文件会先写到内存里, 这样就产生了 dirty pages, 所以先研究了一下 Linux 对 dirty pages 的回收机制是否会影响到容器中写入数据的波动.</p> <p>在这里最主要的是理解这两个参数, <strong>dirty_background_ratio 和 dirty_ratio</strong>, 这两个值都是相对于节点可用内存的百分比值.</p> <p><mark>**当 dirty pages 数量超过 dirty_background_ratio 对应的内存量的时候, 内核 flush 线程就会开始把 dirty pages 写入磁盘 ; 当 dirty pages 数量超过 dirty_ratio 对应的内存量, 这时候程序写文件的函数调用 write() 就会被阻塞住, 直到这次调用的 dirty pages 全部写入到磁盘. **</mark></p> <p>在节点是大内存容量, 并且 dirty_ratio 为系统缺省值 20%, dirty_background_ratio 是系统缺省值 10% 的情况下, 通过观察 /proc/vmstat 中的 nr_dirty 数值可以发现, <mark><strong>dirty pages 不会阻塞进程的 Buffered I/O 写文件操作</strong></mark>.</p> <p>所以做了另一种尝试, 使用 perf 和 ftrace 工具对容器中的写文件进程进行 profile. 用 perf 得到了系统调用 write() 在内核中的一系列子函数调用, 再用 ftrace 来查看这些子函数的调用时间.</p> <p><mark>**根据 ftrace 的结果发现写数据到 Page Cache 的时候, 需要不断地去释放原有的页面, 这个时间开销是最大的. 造成容器中 Buffered I/O write() 不稳定的原因, 正是容器在限制内存之后, Page Cache 的数量较小并且不断申请释放. **</mark></p> <p>其实这个问题也提醒了我们: <mark><strong>在对容器做 Memory Cgroup 限制内存大小的时候, 不仅要考虑容器中进程实际使用的内存量, 还要考虑容器中程序 I/O 的量, 合理预留足够的内存作为 Buffered I/O 的 Page Cache</strong></mark>.</p> <p>比如, 如果知道需要反复读写文件的大小, 并且在内存足够的情况下, 那么 Memory Cgroup 的内存限制可以超过这个文件的大小.</p> <p>还有一个解决思路是, 在程序中自己管理文件的 cache 并且调用 Direct I/O 来读写文件, 这样才会对应用程序的性能有一个更好的预期.</p> <h3 id="容器网络"><a href="#容器网络" class="header-anchor">#</a> 容器网络</h3> <h4 id="_15-容器网络-我修改了-proc-sys-net下的参数-为什么在容器中不起效"><a href="#_15-容器网络-我修改了-proc-sys-net下的参数-为什么在容器中不起效" class="header-anchor">#</a> 15 | 容器网络:我修改了/proc/sys/net下的参数,为什么在容器中不起效?</h4> <p>本节进入到了容器网络这个模块. 容器网络最明显的一个特征就是它<strong>有自己的 Network Namespace 了</strong>. 第一讲里就提到过 <strong>Network Namespace 负责管理网络环境的隔离</strong>. 本节就深入地讨论一下和 Network Namespace 相关的一个问题——容器中的网络参数.</p> <p>和之前的思路一样, 先来看一个问题. 然后在解决问题的过程中, 更深入地理解容器的网络参数配置.</p> <h5 id="_1-问题再现-10"><a href="#_1-问题再现-10" class="header-anchor">#</a> 1.问题再现</h5> <p>在容器中运行的应用程序, 如果需要用到 tcp/ip 协议栈的话, 常常需要修改一些<strong>网络参数</strong>(内核中网络协议栈的参数). 很大一部分网络参数都<strong>在 /proc 文件系统下的/proc/sys/net/目录里</strong>.</p> <p><mark>**修改这些参数主要有两种方法: 一种方法是直接到 /proc 文件系统下的 &quot;/proc/sys/net/&quot; 目录里对参数做修改; 还有一种方法是使用 sysctl 这个工具来修改. **</mark></p> <p>在启动容器之前, 根据需要我们在宿主机上已经修改过了几个参数, 也就是说这些参数的值已经不是内核里原来的缺省值了.</p> <p>比如改了下面的几个参数:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># # The default value:</span>
<span class="token comment"># cat /proc/sys/net/ipv4/tcp_congestion_control</span>
cubic
<span class="token comment"># cat /proc/sys/net/ipv4/tcp_keepalive_time</span>
<span class="token number">7200</span>
<span class="token comment"># cat /proc/sys/net/ipv4/tcp_keepalive_intvl</span>
<span class="token number">75</span>
<span class="token comment"># cat /proc/sys/net/ipv4/tcp_keepalive_probes</span>
<span class="token number">9</span>
 
<span class="token comment"># # To update the value:</span>
<span class="token comment"># echo bbr &gt; /proc/sys/net/ipv4/tcp_congestion_control</span>
<span class="token comment"># echo 600 &gt; /proc/sys/net/ipv4/tcp_keepalive_time</span>
<span class="token comment"># echo 10 &gt; /proc/sys/net/ipv4/tcp_keepalive_intvl</span>
<span class="token comment"># echo 6 &gt; /proc/sys/net/ipv4/tcp_keepalive_probes</span>
<span class="token comment">#</span>
 
<span class="token comment"># # Double check the value after update:</span>
<span class="token comment"># cat /proc/sys/net/ipv4/tcp_congestion_control</span>
bbr
<span class="token comment"># cat /proc/sys/net/ipv4/tcp_keepalive_time</span>
<span class="token number">600</span>
<span class="token comment"># cat /proc/sys/net/ipv4/tcp_keepalive_intvl</span>
<span class="token number">10</span>
<span class="token comment"># cat /proc/sys/net/ipv4/tcp_keepalive_probes</span>
<span class="token number">6</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>然后启动一个容器, 再来<strong>查看一下容器里这些参数的值</strong>. 你可以先想想, 容器里这些参数的值会是什么? 我最初觉得容器里参数值应该会继承宿主机 Network Namesapce 里的值, 实际上是不是这样呢?</p> <p>还是先按下面的脚本, 启动容器, 然后运行 <code>docker exec</code>​ 命令一起看一下:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># docker run -d --name net_para centos:8.1.1911 sleep 3600</span>
deec6082bac7b336fa28d0f87d20e1af21a784e4ef11addfc2b9146a9fa77e95
<span class="token comment"># docker exec -it net_para bash</span>
<span class="token punctuation">[</span>root@deec6082bac7 /<span class="token punctuation">]</span><span class="token comment"># cat /proc/sys/net/ipv4/tcp_congestion_control</span>
bbr
<span class="token punctuation">[</span>root@deec6082bac7 /<span class="token punctuation">]</span><span class="token comment"># cat /proc/sys/net/ipv4/tcp_keepalive_time</span>
<span class="token number">7200</span>
<span class="token punctuation">[</span>root@deec6082bac7 /<span class="token punctuation">]</span><span class="token comment"># cat /proc/sys/net/ipv4/tcp_keepalive_intvl</span>
<span class="token number">75</span>
<span class="token punctuation">[</span>root@deec6082bac7 /<span class="token punctuation">]</span><span class="token comment"># cat /proc/sys/net/ipv4/tcp_keepalive_probes</span>
<span class="token number">9</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>从这个结果看到, tcp_congestion_control 的值是 bbr, 和宿主机 Network Namespace 里的值是一样的, 而其他三个 tcp keepalive 相关的值, 都<strong>不是宿主机 Network Namespace 里设置的值, 而是原来系统里的缺省值</strong>了.</p> <p>那为什么会这样呢? 在分析这个问题之前, 需要先来看看 Network Namespace 这个概念.</p> <h5 id="_2-知识详解-6"><a href="#_2-知识详解-6" class="header-anchor">#</a> 2.知识详解</h5> <h6 id="_1-如何理解network-namespace"><a href="#_1-如何理解network-namespace" class="header-anchor">#</a> (1)如何理解Network Namespace?</h6> <p>对于 Network Namespace, 从字面上去理解的话, 可以知道它是在<strong>一台 Linux 节点上对网络的隔离</strong>, 不过它具体到底隔离了哪部分的网络资源呢?</p> <p>还是先来看看操作手册, 在 Linux Programmer’s Manual 里对 Network Namespace 有一个段简短的描述, 在里面就列出了最主要的几部分资源, 它们都是通过 Network Namespace 隔离的.</p> <p>我把这些资源做了一个梳理:</p> <p>第一种, <strong>网络设备</strong>, 这里指的是 lo, eth0 等网络设备. 通过 <code>ip link</code>​ 命令看到它们.</p> <p>第二种是 <strong>IPv4 和 IPv6 协议栈</strong>. 从这里可以知道, IP 层以及上面的 TCP 和 UPD 协议栈也是每个 Namespace 独立工作的. 所以 IP, TCP, PUD 的很多协议, 它们的相关参数也是<strong>每个 Namespace 独立</strong>的, 这些参数大多数都在 /proc/sys/net/ 目录下面, 同时也包括了 TCP 和 UPD 的 port 资源.</p> <p>第三种, <strong>IP 路由表</strong>, 这个资源也是比较好理解的, 可以在不同的 Network Namespace 运行 <code>ip route</code>​ 命令, 就能看到不同的路由表了.</p> <p>第四种是<strong>防火墙规则</strong>, 其实这里说的就是 <strong>iptables 规则</strong>了, 每个 Namespace 里都可以独立配置 iptables 规则.</p> <p>最后一种是<strong>网络的状态信息</strong>, 这些信息可以从 /proc/net 和 /sys/class/net 里得到, 这里的状态基本上包括了前面 4 种资源的的状态信息.</p> <h6 id="_2-namespace的操作"><a href="#_2-namespace的操作" class="header-anchor">#</a> (2)Namespace的操作</h6> <p>那怎么建立一个新的 Network Namespace 呢?</p> <p>**可以通过系统调用 clone() 或者 unshare() 这两个函数来建立新的 Network Namespace. **</p> <p>下面会讲两个例子, 带你体会一下这两个方法具体怎么用.</p> <p>第一种方法是在<strong>新的进程创建的时候, 伴随新进程建立, 同时也建立出新的 Network Namespace</strong>. 这个方法, 其实就是通过 clone() 系统调用<strong>带上 CLONE_NEWNET flag</strong> 来实现的.</p> <p>Clone 建立出来一个新的进程, 这个新的进程所在的 Network Namespace 也是新的. 然后执行 <code>ip link</code>​ 命令查看 Namespace 里的网络设备, 就可以确认一个新的 Network Namespace 已经建立好了.</p> <p>具体操作可以看一下这段代码.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">new_netns</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>para<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;New Namespace Devices:\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;ip link&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;\n\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
 
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Host Namespace Devices:\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;ip link&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;\n\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    pid <span class="token operator">=</span>
        <span class="token function">clone</span><span class="token punctuation">(</span>new_netns<span class="token punctuation">,</span> stack <span class="token operator">+</span> STACK_SIZE<span class="token punctuation">,</span> CLONE_NEWNET <span class="token operator">|</span> SIGCHLD<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&lt;</span>mark<span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
                <span class="token function">errExit</span><span class="token punctuation">(</span><span class="token string">&quot;clone&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
                <span class="token function">errExit</span><span class="token punctuation">(</span><span class="token string">&quot;waitpid&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>第二种方法就是<strong>调用 unshare() 这个系统调用来直接改变当前进程的 Network Namespace</strong>, 可以看一下这段代码.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
 
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Host Namespace Devices:\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;ip link&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;\n\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unshare</span><span class="token punctuation">(</span>CLONE_NEWNET<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
                <span class="token function">errExit</span><span class="token punctuation">(</span><span class="token string">&quot;unshare&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;New Namespace Devices:\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;ip link&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;\n\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>其实不仅是 Network Namespace, <strong>其它的 Namespace 也是通过 clone() 或者 unshare() 系统调用来建立的</strong>. 而创建容器的程序, 比如 runC 也是用 unshare() 给新建的容器建立 Namespace 的. 这里简单说一下 runC 是什么, 我们用 Docker 或者 containerd 去启动容器, 最后都会<strong>调用 runC 在 Linux 中把容器启动起来</strong>.</p> <p>除了在代码中用系统调用来建立 Network Namespace, 也可以用命令行工具来建立 Network Namespace. 比如用 <code>ip netns</code>​ 命令, 在下一讲学习容器网络配置的时候呢, 会用到 <code>ip netns</code>​, 这里先有个印象就行.</p> <p>在 Network Namespace 创建好了之后, 可以在宿主机上运行 <code>lsns -t net</code>​ 这个命令来查看系统里已有的 Network Namespace. 当然, <code>lsns</code>​ 也可以用来查看其它 Namespace. 用 <code>lsns</code>​ 查看已有的 Namespace 后, 还可以用 <code>nsenter</code>​ 这个命令进入到某个 Network Namespace 里, 具体去查看这个 Namespace 里的网络配置.</p> <p>比如下面的这个例子, 用之前的 clone() 的例子里的代码, 编译出 clone-ns 这个程序, 运行后再使用 <code>lsns</code>​ 查看新建的 Network Namespace, 并且用 <code>nsenter</code>​ 进入到这个 Namespace, 查看里面的 lo device.</p> <p>具体操作可以参考下面的代码:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># ./clone-ns &amp;</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">7732</span>
<span class="token comment"># Host Namespace Devices:</span>
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN mode DEFAULT group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
<span class="token number">2</span>: eth0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc fq_codel state UP mode DEFAULT group default qlen <span class="token number">1000</span>
    link/ether <span class="token number">74</span>:db:d1:80:54:14 brd ff:ff:ff:ff:ff:ff
<span class="token number">3</span>: docker0: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc noqueue state DOWN mode DEFAULT group default
    link/ether 02:42:0c:ff:2b:77 brd ff:ff:ff:ff:ff:ff
 
 
New Namespace Devices:
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
 
<span class="token comment"># lsns -t net</span>
        NS TYPE NPROCS   PID <span class="token environment constant">USER</span>    NETNSID NSFS COMMAND
<span class="token number">4026531992</span> net     <span class="token number">283</span>     <span class="token number">1</span> root unassigned      /usr/lib/systemd/systemd --switched-root <span class="token parameter variable">--system</span> <span class="token parameter variable">--deserialize</span> <span class="token number">16</span>
<span class="token number">4026532241</span> net       <span class="token number">1</span>  <span class="token number">7734</span> root unassigned      ./clone-ns
<span class="token comment"># nsenter -t 7734 -n ip addr</span>
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noop state DOWN group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h5 id="_3-解决问题-7"><a href="#_3-解决问题-7" class="header-anchor">#</a> 3.解决问题</h5> <p>那理解了 Network Namespace 之后, 再来看看这一讲最开始的问题, 应该<strong>怎么来设置容器里的网络相关参数</strong>呢?</p> <p>首先要避免走入误区. 从我一开始的例子里也可以看到, <mark><strong>容器里 Network Namespace 的网络参数并不是完全从宿主机 Host Namespace 里继承的, 也不是完全在新的 Network Namespace 建立的时候重新初始化的</strong></mark>. 这一点只要看一下内核代码中对协议栈的初始化函数, 很快就可以知道为什么会有这样的情况.</p> <p>在例子里 tcp_congestion_control 的值是从 Host Namespace 里继承的, 而 tcp_keepalive 相关的几个值会被重新初始化了. 在函数 tcp_sk_init() 里, tcp_keepalive 的三个参数都是<strong>重新初始化</strong>的, 而 tcp_congestion_control 的值是从 Host Namespace 里复制过来的.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> __net_init <span class="token function">tcp_sk_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    net<span class="token operator">-&gt;</span>ipv4<span class="token punctuation">.</span>sysctl_tcp_keepalive_time <span class="token operator">=</span> TCP_KEEPALIVE_TIME<span class="token punctuation">;</span>
    net<span class="token operator">-&gt;</span>ipv4<span class="token punctuation">.</span>sysctl_tcp_keepalive_probes <span class="token operator">=</span> TCP_KEEPALIVE_PROBES<span class="token punctuation">;</span>
    net<span class="token operator">-&gt;</span>ipv4<span class="token punctuation">.</span>sysctl_tcp_keepalive_intvl <span class="token operator">=</span> TCP_KEEPALIVE_INTVL<span class="token punctuation">;</span>
 
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Reno is always built in */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">net_eq</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> <span class="token operator">&amp;</span>init_net<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">try_module_get</span><span class="token punctuation">(</span>init_net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_congestion_control<span class="token operator">-&gt;</span>owner<span class="token punctuation">)</span><span class="token punctuation">)</span>
            net<span class="token operator">-&gt;</span>ipv4<span class="token punctuation">.</span>tcp_congestion_control <span class="token operator">=</span> init_net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_congestion_control<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
            net<span class="token operator">-&gt;</span>ipv4<span class="token punctuation">.</span>tcp_congestion_control <span class="token operator">=</span> <span class="token operator">&amp;</span>tcp_reno<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>那么现在知道 Network Namespace 的网络参数是怎么初始化的了, 你可能会问了, 在容器里也可以修改这些参数吗?</p> <p>可以启动一个普通的容器, 这里的 &quot;普通&quot; 指的不是 &quot;privileged&quot; 的那种容器, 也就是在这个容器中, 有很多操作都是不允许做的, 比如 mount 一个文件系统. 这个 privileged 容器概念, 会在后面容器安全这一讲里详细展开.</p> <p>那么在启动完一个普通容器后, 尝试一下在容器里去修改 &quot;/proc/sys/net/&quot; 下的参数. 这时候你会看到, 容器中 &quot;/proc/sys/&quot; 是<strong>只读 mount 的</strong>, 那么<strong>在容器里是不能修改 &quot;/proc/sys/net/&quot; 下面的任何参数</strong>了.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># docker run -d --name net_para centos:8.1.1911 sleep 3600</span>
977bf3f07da90422e9c1e89e56edf7a59fab5edff26317eeb253700c2fa657f7
<span class="token comment"># docker exec -it net_para bash</span>
<span class="token punctuation">[</span>root@977bf3f07da9 /<span class="token punctuation">]</span><span class="token comment"># echo 600 &gt; /proc/sys/net/ipv4/tcp_keepalive_time</span>
bash: /proc/sys/net/ipv4/tcp_keepalive_time: Read-only <span class="token function">file</span> system
<span class="token punctuation">[</span>root@977bf3f07da9 /<span class="token punctuation">]</span><span class="token comment"># cat /proc/mounts | grep &quot;proc/sys&quot;</span>
proc /proc/sys proc ro,relatime <span class="token number">0</span> <span class="token number">0</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>为什么 &quot;/proc/sys/&quot; 在容器里是只读 mount 呢?  这是<strong>因为 runC 当初出于安全的考虑, 把容器中所有 /proc 和 /sys 相关的目录缺省都做了 read-only mount 的处理</strong>.</p> <p>那应该怎么来修改容器中 Network Namespace 的网络参数呢?</p> <p>当然, 如果有宿主机上的 root 权限, 最简单粗暴的方法就是之前说的 &quot;nsenter&quot; 工具来修改容器里的网络参数. 不过这个方法在<strong>生产环境里显然是不会被允许的</strong>, 因为不会允许用户拥有宿主机的登陆权限. 其次一般来说<strong>在容器中的应用已经启动了之后, 才会做这样的修改</strong>. 也就是说, 很多 tcp 链接已经建立好了, 那么即使新改了参数, 对已经建立好的链接也不会生效了. 这就需要重启应用, 都知道生产环境里通常要避免应用重启, 那这样做显然也不合适.</p> <p>通过刚刚的排除法, 可以推理出了网络参数修改的 &quot;正确时机&quot;: <mark><strong>想修改 Network Namespace 里的网络参数, 要选择容器刚刚启动, 而容器中的应用程序还没启动之前进行</strong></mark>.</p> <p>其实, runC 也在对 /proc/sys 目录做 read-only mount 之前, 预留出了<strong>修改接口</strong>, 就是用来修改容器里 &quot;/proc/sys&quot; 下参数的, 同样也<strong>是 sysctl 的参数</strong>. <strong>而 Docker 的 –sysctl 或者 Kubernetes 里的 allowed-unsafe-sysctls 特性也都利用了 runC 的 sysctl 参数修改接口, 允许容器在启动时修改容器 Namespace 里的参数</strong>.</p> <p>比如可以试一下 docker –sysctl, 这时候会发现, 在容器的 Network Namespace 里, /proc/sys/net/ipv4/tcp_keepalive_time 这个网络参数终于被修改了!</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># docker run -d --name net_para --sysctl net.ipv4.tcp_keepalive_time=600 centos:8.1.1911 sleep 3600</span>
7efed88a44d64400ff5a6d38fdcc73f2a74a7bdc3dbc7161060f2f7d0be170d1
<span class="token comment"># docker exec net_para cat /proc/sys/net/ipv4/tcp_keepalive_time</span>
<span class="token number">600</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h5 id="_4-重点总结-11"><a href="#_4-重点总结-11" class="header-anchor">#</a> 4.重点总结</h5> <p>本节讨论问题是容器中网络参数的问题, 因为是问题发生在容器里, 又是网络的参数, 那么自然就和 <strong>Network Namespace</strong> 有关, 所以首先要理解 Network Namespace.</p> <p>**Network Namespace 可以隔离网络设备, ip 协议栈, ip 路由表, 防火墙规则, 以及可以显示独立的网络状态信息. ** 可以通过 clone() 或者 unshare() 系统调用来建立新的 Network Namespace.</p> <p>此外, 还有一些工具 &quot;ip&quot;, &quot;netns&quot;, &quot;unshare&quot;, &quot;lsns&quot; 和 &quot;nsenter&quot;, 也可以用来操作 Network Namespace.</p> <p>这些工具的适用条件整理如下, 可以做个参考.</p> <p><img src="/img/297628570c36c17bf078c8dde883f99f-20230731161430-zcxk0pn.png" alt=""></p> <p>接着分析了如何修改普通容器(非 privileged)的网络参数.</p> <p>由于安全的原因, 普通容器的 /proc/sys 是 read-only mount 的, 所以在容器启动以后, 所以无法在容器内部修改 /proc/sys/net 下网络相关的参数. <mark>这时可行的方法是</mark>​<mark>**通过 runC sysctl 相关的接口, 在容器启动的时候对容器内的网络参数做配置. **</mark></p> <p>这样一来, 想要修改网络参数就可以这么做: <strong>如果是使用 Docker, 可以加上 &quot;—sysctl&quot; 这个参数; 而如果使用 Kubernetes 的话, 就需要用到 &quot;allowed unsaft sysctl&quot; 这个特性</strong>.</p> <h4 id="_16-容器网络配置-1-容器网络不通了要怎么调试"><a href="#_16-容器网络配置-1-容器网络不通了要怎么调试" class="header-anchor">#</a> 16 | 容器网络配置(1):容器网络不通了要怎么调试?</h4> <p>上一讲了 Network Namespace 隔离了网络设备, IP 协议栈和路由表, 以及防火墙规则, 那容器 Network Namespace 里的参数怎么去配置, 现在已经很清楚了.</p> <p>其实对于网络配置的问题, 还有一个最需要关心的内容, <strong>那就是容器和外面的容器或者节点是怎么通讯的</strong>, 这就涉及到了容器网络接口配置的问题了. 本节就来聊聊<strong>容器 Network Namespace 里如何配置网络接口, 还有当容器网络不通的时候</strong>, 应该怎么去做一个简单调试.</p> <h5 id="_1-问题再现-11"><a href="#_1-问题再现-11" class="header-anchor">#</a> 1.问题再现</h5> <p>在前面的课程里, 一直是用 <code>docker run</code>​ 这个命令来启动容器的. 容器启动了之后可以看到, 在容器里面有一个 &quot;<strong>eth0</strong>&quot; 的网络接口, 接口上也配置了一个 IP 地址. <strong>不过如果想从容器里访问外面的一个 IP 地址, 比如说 39.106.233.176(这个是极客时间网址对应的 IP), 结果就发现是不能 ping 通的.</strong></p> <p>这时可能会想到, 到底是不是容器内出了问题, 在容器里无法访问, 会不会宿主机也一样不行呢?</p> <p>所以需要验证一下, 首先退出容器, 然后在宿主机的 Network Namespace 下, 再运行 <code>ping 39.106.233.176</code>​, 结果就会发现在宿主机上, 却是可以<strong>连通</strong>这个地址的.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># docker run -d --name if-test centos:8.1.1911 sleep 36000</span>
244d44f94dc2931626194c6fd3f99cec7b7c4bf61aafc6c702551e2c5ca2a371
<span class="token comment"># docker exec -it if-test bash</span>
 
<span class="token punctuation">[</span>root@244d44f94dc2 /<span class="token punctuation">]</span><span class="token comment"># ip addr</span>
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo
       valid_lft forever preferred_lft forever
<span class="token number">808</span>: eth0@if809: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc noqueue state UP group default
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="token number">0</span>
    inet <span class="token number">172.17</span>.0.2/16 brd <span class="token number">172.17</span>.255.255 scope global eth0
       valid_lft forever preferred_lft forever
 
<span class="token punctuation">[</span>root@244d44f94dc2 /<span class="token punctuation">]</span><span class="token comment"># ping 39.106.233.176       ### 容器中无法ping通</span>
PING <span class="token number">39.106</span>.233.176 <span class="token punctuation">(</span><span class="token number">39.106</span>.233.176<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.
^C
--- <span class="token number">39.106</span>.233.176 <span class="token function">ping</span> statistics ---
<span class="token number">9</span> packets transmitted, <span class="token number">0</span> received, <span class="token number">100</span>% packet loss, <span class="token function">time</span> 185ms
 
<span class="token punctuation">[</span>root@244d44f94dc2 /<span class="token punctuation">]</span><span class="token comment"># exit             ###退出容器</span>
<span class="token builtin class-name">exit</span>
 
<span class="token comment"># ping 39.106.233.176                        ### 宿主机上可以ping通</span>
PING <span class="token number">39.106</span>.233.176 <span class="token punctuation">(</span><span class="token number">39.106</span>.233.176<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.
<span class="token number">64</span> bytes from <span class="token number">39.106</span>.233.176: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">78</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">296</span> ms
<span class="token number">64</span> bytes from <span class="token number">39.106</span>.233.176: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">78</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">306</span> ms
<span class="token number">64</span> bytes from <span class="token number">39.106</span>.233.176: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">3</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">78</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">303</span> ms
^C
--- <span class="token number">39.106</span>.233.176 <span class="token function">ping</span> statistics ---
<span class="token number">4</span> packets transmitted, <span class="token number">3</span> received, <span class="token number">25</span>% packet loss, <span class="token function">time</span> 7ms
rtt min/avg/max/mdev <span class="token operator">=</span> <span class="token number">296.059</span>/301.449/305.580/4.037 ms
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>那么碰到这种容器内网络不通的问题, 应该怎么分析调试呢? 还是需要先来理解一下, <strong>容器 Network Namespace 里的网络接口是怎么配置</strong>的.</p> <h5 id="_2-基本概念"><a href="#_2-基本概念" class="header-anchor">#</a> 2.基本概念</h5> <p>在讲解容器的网络接口配置之前, 需要先建立一个整体的认识, 搞清楚<strong>容器网络接口在系统架构中处于哪个位置</strong>.</p> <p>可以看一下这张图, 图里展示的是<strong>容器有自己的 Network Namespace, eth0 是这个 Network Namespace 里的网络接口</strong>. 而<strong>宿主机上也有自己的 eth0, 宿主机上的 eth0 对应着真正的物理网卡, 可以和外面通讯</strong>.</p> <p><img src="/img/ea4a452ffbbfac9f7d7c848bf65baaca-20230731161430-4djmcto.png" alt=""></p> <p>那可以先想想, 要让容器 Network Namespace 中的数据包最终发送到<strong>物理网卡</strong>上, 需要完成哪些步骤呢? 从图上看, 大致可以知道应该包括这两步.</p> <p>**第一步, 就是要让数据包从容器的 Network Namespace 发送到 Host Network Namespace 上. **</p> <p>**第二步, 数据包发到了 Host Network Namespace 之后, 还要解决数据包怎么从宿主机上的 eth0 发送出去的问题. **</p> <p>整体的思路已经理清楚了, 接下来做具体分析.</p> <p>先来看第一步, 怎么让数据包从容器的 Network Namespace 发送到 Host Network Namespace 上面. 可以查看一下 Docker 网络的文档或者 Kubernetes 网络的文档, 这些文档里面介绍了很多种容器网络配置的方式. 不过对于<strong>容器从自己的 Network Namespace 连接到 Host Network Namespace 的方法, 一般来说就只有两类设备接口: 一类是 veth, 另外一类是  macvlan/ipvlan</strong>.</p> <p>在这些方法中, 使用最多的就是 <strong>veth 的方式</strong>, 用 Docker 启动的容器缺省的网络接口用的也是这个 veth. 既然它这么常见, 所以就用 veth 作为例子来详细讲解. 至于另外一类 macvlan/ipvlan 的方式, 下一讲会讲到.</p> <p>那什么是 veth 呢? 为了方便理解, 先来<strong>模拟一下 Docker 为容器建立 eth0 网络接口的过程</strong>, 动手操作一下, 这样就可以很快明白什么是 veth 了. 这个模拟操作主要用到的是 <strong>ip netns 这个命令</strong>, 通过它来对 Network Namespace 做操作. 首先先启动一个不带网络配置的容器, 和之前的命令比较, 主要是多加上了 &quot; <strong>--network none</strong>&quot; 参数. 可以看到, 这样在启动的容器中, Network Namespace 里就<strong>只有 loopback 一个网络设备, 而没有了 eth0 网络设备</strong>了.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># docker run -d --name if-test --network none centos:8.1.1911 sleep 36000</span>
cf3d3105b11512658a025f5b401a09c888ed3495205f31e0a0d78a2036729472
<span class="token comment"># docker exec -it if-test ip addr</span>
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo
       valid_lft forever preferred_lft forever
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>完成刚才的设置以后, 就<strong>在这个容器的 Network Namespace 里建立 veth</strong>, 可以执行一下后面的这个脚本.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token assign-left variable">pid</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">&quot;sleep 36000&quot;</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-v</span> <span class="token function">grep</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $2}'</span><span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token variable">$pid</span>
<span class="token function">ln</span> <span class="token parameter variable">-s</span> /proc/<span class="token variable">$pid</span>/ns/net /var/run/netns/<span class="token variable">$pid</span>
 
<span class="token comment"># Create a pair of veth interfaces</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> name veth_host <span class="token builtin class-name">type</span> veth peer name veth_container
<span class="token comment"># Put one of them in the new net ns</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> veth_container netns <span class="token variable">$pid</span>
 
<span class="token comment"># In the container, setup veth_container</span>
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token variable">$pid</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> veth_container name eth0
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token variable">$pid</span> <span class="token function">ip</span> addr <span class="token function">add</span> <span class="token number">172.17</span>.1.2/16 dev eth0
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token variable">$pid</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> eth0 up
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token variable">$pid</span> <span class="token function">ip</span> route <span class="token function">add</span> default via <span class="token number">172.17</span>.0.1
 
<span class="token comment"># In the host, set veth_host up</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> veth_host up
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>解释一下, 这个 veth 的建立过程是什么样的.</p> <p>首先找到这个容器里运行的进程 &quot;sleep 36000&quot; 的 pid, 通过 &quot;/proc/$pid/ns/net&quot; 这个文件<strong>得到 Network Namespace 的 ID, 这个 Network Namespace ID 既是这个进程的, 也同时属于这个容器</strong>.</p> <p>然后在 &quot;/var/run/netns/&quot; 的目录下建立一个<strong>符号链接</strong>, 指向这个容器的 Network Namespace. 完成这步操作之后, 在后面的 &quot;ip netns&quot; 操作里, 就可以<strong>用 pid 的值作为这个容器的 Network Namesapce 的标识</strong>了.</p> <p>接下来用 <code>ip link</code>​ 命令来<strong>建立一对 veth 的虚拟设备接口</strong>, 分别是 <strong>veth_container 和 veth_host</strong>. 从名字就可以看出来, <strong>veth_container 这个接口会被放在容器 Network Namespace 里, 而 veth_host 会放在宿主机的 Host Network Namespace</strong>.</p> <p>所以后面的命令也很好理解了, 就是用 <code>ip link set veth_container netns $pid</code>​ 把 veth_container 这个接口放入到容器的 Network Namespace 中.</p> <p>再然后<strong>要把 veth_container 重新命名为 eth0</strong>, 因为这时候接口已经在容器的 Network Namesapce 里了, eth0 就不会和宿主机上的 eth0 冲突了.</p> <p>最后对容器内的 eht0, 还要做基本的<strong>网络 IP 和缺省路由配置</strong>. 因为 veth_host 已经在宿主机的 Host Network Namespace 了, 就不需要再做什么了, 这时只需要 up 一下这个接口就可以了.</p> <p>那刚才这些操作完成以后, 就<strong>建立了一对 veth 虚拟设备接口</strong>. 下图直观展示了这对接口在容器和宿主机上的位置.</p> <p><img src="/img/03863cd49dad179c08c05765a419462c-20230731161430-nnm7qj0.png" alt=""></p> <p>现在再来看看 veth 的定义, 其实它也很简单. <mark><strong>veth 就是一个虚拟的网络设备, 一般都是成对创建, 而且这对设备是相互连接的. 当每个设备在不同的 Network Namespaces 的时候, Namespace 之间就可以用这对 veth 设备来进行网络通讯了</strong></mark>.</p> <p>比如可以执行下面的这段代码, <strong>试试在 veth_host 上加上一个 IP, 172.17.1.1/16, 然后从容器里就可以 ping 通这个 IP 了</strong>. 这也证明了从容器到宿主机可以利用这对 veth 接口来通讯了.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># ip addr add 172.17.1.1/16 dev veth_host</span>
<span class="token comment"># docker exec -it if-test ping 172.17.1.1</span>
PING <span class="token number">172.17</span>.1.1 <span class="token punctuation">(</span><span class="token number">172.17</span>.1.1<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.
<span class="token number">64</span> bytes from <span class="token number">172.17</span>.1.1: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.073</span> ms
<span class="token number">64</span> bytes from <span class="token number">172.17</span>.1.1: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.092</span> ms
^C
--- <span class="token number">172.17</span>.1.1 <span class="token function">ping</span> statistics ---
<span class="token number">2</span> packets transmitted, <span class="token number">2</span> received, <span class="token number">0</span>% packet loss, <span class="token function">time</span> 30ms
rtt min/avg/max/mdev <span class="token operator">=</span> <span class="token number">0.073</span>/0.082/0.092/0.013 ms
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>好了, 这样完成了第一步, <strong>通过一对 veth 虚拟设备, 可以让数据包从容器的 Network Namespace 发送到 Host Network Namespace 上</strong>.</p> <p>下面再来看第二步, <strong>数据包到了 Host Network Namespace 之后, 怎么把它从宿主机上的 eth0 发送出去</strong>?</p> <p>其实这一步就是一个<strong>普通 Linux 节点上数据包转发</strong>的问题了. 这里解决问题的方法有很多种, 比如<strong>用 nat 来做个转发, 或者建立 Overlay 网络发送, 也可以通过配置 proxy arp 加路由的方法来实现</strong>.</p> <p>因为考虑到网络环境的配置, 同时 <mark><strong>Docker 缺省使用的是 bridge + nat 的转发方式</strong></mark>,  那就在刚才讲的第一步基础上, 再手动实现一下 bridge+nat 的转发方式. 对于其他的配置方法, 可以看一下 Docker 或者 Kubernetes 相关的文档.</p> <p>Docker 程序在节点上安装完之后, 就会<strong>自动建立了一个 docker0 的 bridge interface</strong>. 所以只需要<mark><strong>把第一步中建立的 veth_host 这个设备, 接入到 docker0 这个 bridge 上</strong></mark>.</p> <p>这里要注意一下, 如果之前在 veth_host 上设置了 IP 的, 就需先运行一下 &quot;ip addr delete 172.17.1.1/16 dev veth_host&quot;, 把 IP 从 veth_host 上删除.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># ip addr delete 172.17.1.1/16 dev veth_host </span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> veth_host master docker0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这个命令执行完之后, 容器和宿主机的网络配置就会发生变化, 这种配置是什么样呢? 可以参考一下面这张图的描述.</p> <p><img src="/img/65dbd7d7328edf61fd0c17f1a4f1b135-20230731161430-eua67xj.png" alt=""></p> <p>从这张示意图中可以看出, <strong>容器和 docker0 组成了一个子网, docker0 上的 IP 就是这个子网的网关 IP</strong>. 如果要让子网通过宿主机上 eth0 去访问外网的话, 那么<strong>加上 iptables 的规则</strong>就可以了, 也就是下面这条规则.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>iptables <span class="token parameter variable">-P</span> FORWARD ACCEPT
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>进行到这里, 通过 bridge+nat 的配置, 似乎已经完成了第二步---让数据从宿主机的 eth0 发送出去. 那么这样配置, 真的可以让容器里发送数据包到外网吗? 这需要做个测试, 再重新尝试下这一讲开始的操作, 从容器里 ping 外网的 IP, 这时候, 会发现<strong>还是 ping 不通</strong>.</p> <p>其实做到这一步, 我们通过逐步的操作重现了这一讲了最开始的问题.</p> <h5 id="_3-解决问题-8"><a href="#_3-解决问题-8" class="header-anchor">#</a> 3.解决问题</h5> <p>既然现在清楚了在这个节点上容器和宿主机上的网络配置是怎么一回事. 那么要调试这个问题也有了思路, <strong>关键就是找到数据包传到哪个环节时发生了中断</strong>.</p> <p><strong>那最直接的方法, 就是在容器中继续 ping 外网的 IP 39.106.233.176, 然后在容器的 eth0 (veth_container), 容器外的 veth_host, docker0, 宿主机的 eth0 这一条数据包的路径上运行 tcpdump</strong>.</p> <p>这样就可以查到到底在哪个设备接口上没有收到 ping 的 icmp 包. 我把 tcpdump 运行的结果我列到了下面.</p> <p>容器的 eth0:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># ip netns exec $pid tcpdump -i eth0 host 39.106.233.176 -nn</span>
tcpdump: verbose output suppressed, use <span class="token parameter variable">-v</span> or <span class="token parameter variable">-vv</span> <span class="token keyword">for</span> full protocol decode
listening on eth0, link-type EN10MB <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>, capture size <span class="token number">262144</span> bytes
00:47:29.934294 IP <span class="token number">172.17</span>.1.2 <span class="token operator">&gt;</span> <span class="token number">39.106</span>.233.176: ICMP <span class="token builtin class-name">echo</span> request, <span class="token function">id</span> <span class="token number">71</span>, <span class="token function">seq</span> <span class="token number">1</span>, length <span class="token number">64</span>
00:47:30.934766 IP <span class="token number">172.17</span>.1.2 <span class="token operator">&gt;</span> <span class="token number">39.106</span>.233.176: ICMP <span class="token builtin class-name">echo</span> request, <span class="token function">id</span> <span class="token number">71</span>, <span class="token function">seq</span> <span class="token number">2</span>, length <span class="token number">64</span>
00:47:31.958875 IP <span class="token number">172.17</span>.1.2 <span class="token operator">&gt;</span> <span class="token number">39.106</span>.233.176: ICMP <span class="token builtin class-name">echo</span> request, <span class="token function">id</span> <span class="token number">71</span>, <span class="token function">seq</span> <span class="token number">3</span>, length <span class="token number">64</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>veth_host:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># tcpdump -i veth_host host 39.106.233.176 -nn</span>
tcpdump: verbose output suppressed, use <span class="token parameter variable">-v</span> or <span class="token parameter variable">-vv</span> <span class="token keyword">for</span> full protocol decode
listening on veth_host, link-type EN10MB <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>, capture size <span class="token number">262144</span> bytes
00:48:01.654720 IP <span class="token number">172.17</span>.1.2 <span class="token operator">&gt;</span> <span class="token number">39.106</span>.233.176: ICMP <span class="token builtin class-name">echo</span> request, <span class="token function">id</span> <span class="token number">71</span>, <span class="token function">seq</span> <span class="token number">32</span>, length <span class="token number">64</span>
00:48:02.678752 IP <span class="token number">172.17</span>.1.2 <span class="token operator">&gt;</span> <span class="token number">39.106</span>.233.176: ICMP <span class="token builtin class-name">echo</span> request, <span class="token function">id</span> <span class="token number">71</span>, <span class="token function">seq</span> <span class="token number">33</span>, length <span class="token number">64</span>
00:48:03.702827 IP <span class="token number">172.17</span>.1.2 <span class="token operator">&gt;</span> <span class="token number">39.106</span>.233.176: ICMP <span class="token builtin class-name">echo</span> request, <span class="token function">id</span> <span class="token number">71</span>, <span class="token function">seq</span> <span class="token number">34</span>, length <span class="token number">64</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>docker0:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># tcpdump -i docker0 host 39.106.233.176 -nn</span>
tcpdump: verbose output suppressed, use <span class="token parameter variable">-v</span> or <span class="token parameter variable">-vv</span> <span class="token keyword">for</span> full protocol decode
listening on docker0, link-type EN10MB <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>, capture size <span class="token number">262144</span> bytes
00:48:20.086841 IP <span class="token number">172.17</span>.1.2 <span class="token operator">&gt;</span> <span class="token number">39.106</span>.233.176: ICMP <span class="token builtin class-name">echo</span> request, <span class="token function">id</span> <span class="token number">71</span>, <span class="token function">seq</span> <span class="token number">50</span>, length <span class="token number">64</span>
00:48:21.110765 IP <span class="token number">172.17</span>.1.2 <span class="token operator">&gt;</span> <span class="token number">39.106</span>.233.176: ICMP <span class="token builtin class-name">echo</span> request, <span class="token function">id</span> <span class="token number">71</span>, <span class="token function">seq</span> <span class="token number">51</span>, length <span class="token number">64</span>
00:48:22.134839 IP <span class="token number">172.17</span>.1.2 <span class="token operator">&gt;</span> <span class="token number">39.106</span>.233.176: ICMP <span class="token builtin class-name">echo</span> request, <span class="token function">id</span> <span class="token number">71</span>, <span class="token function">seq</span> <span class="token number">52</span>, length <span class="token number">64</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>host eth0:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># tcpdump -i eth0 host 39.106.233.176 -nn</span>
tcpdump: verbose output suppressed, use <span class="token parameter variable">-v</span> or <span class="token parameter variable">-vv</span> <span class="token keyword">for</span> full protocol decode
listening on eth0, link-type EN10MB <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>, capture size <span class="token number">262144</span> bytes
^C
<span class="token number">0</span> packets captured
<span class="token number">0</span> packets received by filter
<span class="token number">0</span> packets dropped by kernel
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>通过上面的输出结果, <strong>发现 icmp 包到达了 docker0, 但是没有到达宿主机上的 eth0</strong>.</p> <p>因为已经配置了 iptables nat 的转发, 这个也可以通过<strong>查看 iptables 的 nat 表确认一下</strong>, 是没有问题的, 具体的操作命令如下:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># iptables -L  -t nat</span>
Chain PREROUTING <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
DOCKER     all  --  anywhere             anywhere             ADDRTYPE match dst-type LOCAL
 
Chain INPUT <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
 
Chain POSTROUTING <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
MASQUERADE  all  --  <span class="token number">172.17</span>.0.0/16        anywhere
 
Chain OUTPUT <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
DOCKER     all  --  anywhere            <span class="token operator">!</span><span class="token number">127.0</span>.0.0/8          ADDRTYPE match dst-type LOCAL
 
Chain DOCKER <span class="token punctuation">(</span><span class="token number">2</span> references<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
RETURN     all  --  anywhere             anywhere
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>那么会是什么问题呢? 因为这里<strong>需要做两个网络设备接口之间的数据包转发, 也就是从 docker0 把数据包转发到 eth0 上</strong>, 你可能想到了 Linux 协议栈里的一个常用参数 <strong>ip_forward</strong>.</p> <p>可以看一下, 它的值是 0, 当把它改成 1 之后, 那么就可以从容器中 ping 通外网 39.106.233.176 这个 IP 了!</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># cat /proc/sys/net/ipv4/ip_forward</span>
<span class="token number">0</span>
<span class="token comment"># echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span>
 
<span class="token comment"># docker exec -it if-test ping 39.106.233.176</span>
PING <span class="token number">39.106</span>.233.176 <span class="token punctuation">(</span><span class="token number">39.106</span>.233.176<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.
<span class="token number">64</span> bytes from <span class="token number">39.106</span>.233.176: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">77</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">359</span> ms
<span class="token number">64</span> bytes from <span class="token number">39.106</span>.233.176: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">77</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">346</span> ms
^C
--- <span class="token number">39.106</span>.233.176 <span class="token function">ping</span> statistics ---
<span class="token number">2</span> packets transmitted, <span class="token number">2</span> received, <span class="token number">0</span>% packet loss, <span class="token function">time</span> 1ms
rtt min/avg/max/mdev <span class="token operator">=</span> <span class="token number">345.889</span>/352.482/359.075/6.593 ms
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h5 id="_4-重点小结-2"><a href="#_4-重点小结-2" class="header-anchor">#</a> 4.重点小结</h5> <p>这一讲主要解决的问题是<strong>如何给容器配置网络接口, 让容器可以和外面通讯</strong>; 同时还学习了当容器网络不通的时候, 应该怎么来做一个简单调试.</p> <p>解决容器与外界通讯的问题, 一共需要完成两步. 第一步是, <strong>怎么让数据包从容器的 Network Namespace 发送到 Host Network Namespace 上</strong>; 第二步, <strong>数据包到了 Host Network Namespace 之后, 还需要让它可以从宿主机的 eth0 发送出去</strong>.</p> <p>想让数据从容器 Netowrk Namespace 发送到 Host Network Namespace, 可以用<strong>配置一对 veth 虚拟网络设备</strong>的方法实现. 而让数据包从宿主机的 eth0 发送出去, 就用可 <strong>bridge+nat</strong> 的方式完成. 这里讲的是最基本的一种配置, 但它也是很常用的一个网络配置. 针对其他不同需要, 容器网络还有很多种.</p> <p><strong>遇到容器中网络不通的情况, 先要理解自己的容器以及容器在宿主机上的配置, 通过对主要设备上做 tcpdump 可以找到具体在哪一步数据包停止了转发. 然后结合内核网络配置参数, 路由表信息, 防火墙规则, 一般都可以定位出根本原因, 最终解决这种网络完全不通的问题.</strong></p> <p>但是如果是网络偶尔丢包的问题, 这个就需要用到其他的一些工具来做分析了, 这个会在之后的章节做讲解.</p> <h4 id="_17-容器网络配置-2-容器网络延时要比宿主机上的高吗"><a href="#_17-容器网络配置-2-容器网络延时要比宿主机上的高吗" class="header-anchor">#</a> 17 | 容器网络配置(2):容器网络延时要比宿主机上的高吗?</h4> <p>上一讲学习了在容器中的网络接口配置, 重点讲解的<strong>是 veth 的接口配置方式</strong>, 这也是绝大部分容器用的缺省的网络配置方式.</p> <p>不过从 veth 的这种网络接口配置上看, 一个数据包要从容器里发送到宿主机外, 需要先<mark><strong>从容器里的 eth0 (veth_container) 把包发送到宿主机上 veth_host, 然后再在宿主机上通过 nat 或者路由的方式, 经过宿主机上的 eth0 向外发送</strong></mark>.</p> <p><img src="/img/219f774010ba68f3a9180f84c4d42a25-20230731161430-2h360s0.png" alt=""></p> <p>这种容器向外发送数据包的路径, 相比宿主机上直接向外发送数据包的路径, 很明显要<strong>多了一次接口层的发送和接收</strong>. 尽管 veth 是虚拟网络接口, 在软件上还是会增加一些开销. 如果应用程序对网络性能有很高的要求, 特别是之前运行在物理机器上, 现在迁移到容器上的, 如果网络配置采用 veth 方式, 就会出现<strong>网络延时增加</strong>的现象.</p> <p>本节就来聊一聊, <strong>容器网络接口对于容器中应用程序网络延时有怎样的影响, 还有这个问题应该怎么解决</strong>.</p> <h5 id="_1-问题重现-2"><a href="#_1-问题重现-2" class="header-anchor">#</a> 1.问题重现</h5> <p>对于这种 veth 接口配置导致网络延时增加的现象, 可以通过运行 <strong>netperf</strong>(Netperf 是一个衡量网络性能的工具, 它可以提供单向吞吐量和端到端延迟的测试)来模拟一下. 这里需要两台<strong>虚拟机或者物理机</strong>, 这两台机器需要同处于一个<strong>二层的网络</strong>中.</p> <p>具体的配置示意图如下:</p> <p><img src="/img/785bdc55d6bc1fb589311caf46bac81f-20230731161430-repdrum.png" alt=""></p> <p>首先需要在第一台机器上启动一个 veth 接口的<strong>容器</strong>, 容器的启动和宿主机上的配置可以参考一下这里的脚本. 在第二台机器上, 只要启动一个 netserver 就可以了. 然后分别在<strong>容器里和宿主机上运行与 netserver 交互的 netperf</strong>, 再比较一下它们延时的差异.</p> <p>可以运行 netperf 的 TCP_RR 测试用例, TCP_RR 是 netperf 里专门用来测试网络延时的, 缺省每次运行 10 秒钟. 运行以后, 还要计算平均每秒钟 TCP request/response 的次数, 这个次数越高, 就说明延时越小.</p> <p>接下来先在第一台机器的<strong>宿主机</strong>上直接运行 netperf 的 TCP_RR 测试用例 3 轮, 得到的值分别是 2504.92, 2410.14 和 2422.81, 计算一下可以得到三轮 Transactions 平均值是 2446/s.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># ./netperf -H 192.168.0.194 -t TCP_RR</span>
MIGRATED TCP REQUEST/RESPONSE TEST from <span class="token number">0.0</span>.0.0 <span class="token punctuation">(</span><span class="token number">0.0</span>.0.0<span class="token punctuation">)</span> port <span class="token number">0</span> AF_INET to <span class="token number">192.168</span>.0.194 <span class="token punctuation">(</span><span class="token punctuation">)</span> port <span class="token number">0</span> AF_INET <span class="token builtin class-name">:</span> first burst <span class="token number">0</span>
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec
 
<span class="token number">16384</span>  <span class="token number">131072</span> <span class="token number">1</span>        <span class="token number">1</span>       <span class="token number">10.00</span>    <span class="token number">2504.92</span>
<span class="token number">16384</span>  <span class="token number">131072</span>
<span class="token comment"># ./netperf -H 192.168.0.194 -t TCP_RR</span>
MIGRATED TCP REQUEST/RESPONSE TEST from <span class="token number">0.0</span>.0.0 <span class="token punctuation">(</span><span class="token number">0.0</span>.0.0<span class="token punctuation">)</span> port <span class="token number">0</span> AF_INET to <span class="token number">192.168</span>.0.194 <span class="token punctuation">(</span><span class="token punctuation">)</span> port <span class="token number">0</span> AF_INET <span class="token builtin class-name">:</span> first burst <span class="token number">0</span>
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec
 
<span class="token number">16384</span>  <span class="token number">131072</span> <span class="token number">1</span>        <span class="token number">1</span>       <span class="token number">10.00</span>    <span class="token number">2410.14</span>
<span class="token number">16384</span>  <span class="token number">131072</span>
 
<span class="token comment"># ./netperf -H 192.168.0.194 -t TCP_RR</span>
MIGRATED TCP REQUEST/RESPONSE TEST from <span class="token number">0.0</span>.0.0 <span class="token punctuation">(</span><span class="token number">0.0</span>.0.0<span class="token punctuation">)</span> port <span class="token number">0</span> AF_INET to <span class="token number">192.168</span>.0.194 <span class="token punctuation">(</span><span class="token punctuation">)</span> port <span class="token number">0</span> AF_INET <span class="token builtin class-name">:</span> first burst <span class="token number">0</span>
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec
 
<span class="token number">16384</span>  <span class="token number">131072</span> <span class="token number">1</span>        <span class="token number">1</span>       <span class="token number">10.00</span>    <span class="token number">2422.81</span>
<span class="token number">16384</span>  <span class="token number">131072</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>同样再在<strong>容器中</strong>运行一下 netperf 的 TCP_RR, 也一样运行三轮, 计算一下这三次的平均值, 得到的值是 2141.</p> <p>拿这次容器环境中的平均值和宿主机上得到的值 2446 做比较, 会发现 Transactions 下降了大概 12.5%, 也就是<strong>网络的延时</strong>超过了 10%.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token punctuation">[</span>root@4150e2a842b5 /<span class="token punctuation">]</span><span class="token comment"># ./netperf -H 192.168.0.194 -t TCP_RR</span>
MIGRATED TCP REQUEST/RESPONSE TEST from <span class="token number">0.0</span>.0.0 <span class="token punctuation">(</span><span class="token number">0.0</span>.0.0<span class="token punctuation">)</span> port <span class="token number">0</span> AF_INET to <span class="token number">192.168</span>.0.194 <span class="token punctuation">(</span><span class="token punctuation">)</span> port <span class="token number">0</span> AF_INET <span class="token builtin class-name">:</span> first burst <span class="token number">0</span>
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec
 
<span class="token number">16384</span>  <span class="token number">131072</span> <span class="token number">1</span>        <span class="token number">1</span>       <span class="token number">10.00</span>    <span class="token number">2104.68</span>
<span class="token number">16384</span>  <span class="token number">131072</span>
 
<span class="token punctuation">[</span>root@4150e2a842b5 /<span class="token punctuation">]</span><span class="token comment"># ./netperf -H 192.168.0.194 -t TCP_RR</span>
MIGRATED TCP REQUEST/RESPONSE TEST from <span class="token number">0.0</span>.0.0 <span class="token punctuation">(</span><span class="token number">0.0</span>.0.0<span class="token punctuation">)</span> port <span class="token number">0</span> AF_INET to <span class="token number">192.168</span>.0.194 <span class="token punctuation">(</span><span class="token punctuation">)</span> port <span class="token number">0</span> AF_INET <span class="token builtin class-name">:</span> first burst <span class="token number">0</span>
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec
 
<span class="token number">16384</span>  <span class="token number">131072</span> <span class="token number">1</span>        <span class="token number">1</span>       <span class="token number">10.00</span>    <span class="token number">2146.34</span>
<span class="token number">16384</span>  <span class="token number">131072</span>
 
<span class="token punctuation">[</span>root@4150e2a842b5 /<span class="token punctuation">]</span><span class="token comment"># ./netperf -H 192.168.0.194 -t TCP_RR</span>
MIGRATED TCP REQUEST/RESPONSE TEST from <span class="token number">0.0</span>.0.0 <span class="token punctuation">(</span><span class="token number">0.0</span>.0.0<span class="token punctuation">)</span> port <span class="token number">0</span> AF_INET to <span class="token number">192.168</span>.0.194 <span class="token punctuation">(</span><span class="token punctuation">)</span> port <span class="token number">0</span> AF_INET <span class="token builtin class-name">:</span> first burst <span class="token number">0</span>
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec
 
<span class="token number">16384</span>  <span class="token number">131072</span> <span class="token number">1</span>        <span class="token number">1</span>       <span class="token number">10.00</span>    <span class="token number">2173.79</span>
<span class="token number">16384</span>  <span class="token number">131072</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h5 id="_2-分析问题"><a href="#_2-分析问题" class="header-anchor">#</a> 2.分析问题</h5> <p>刚才已经得到了测试的数值, 发现 veth 方式的确带来了很高的网络延时. 现在先来分析一下, 为什么 veth 会带来这么大的网络延时, 然后再看看有什么方法可以降低容器里的网络延时.</p> <p>先回顾一下容器里 veth 接口的配置, 还是拿上一讲里容器 veth 的图作为例子.</p> <p><img src="/img/03863cd49dad179c08c05765a419462c-20230731161430-tgwj5wa.png" alt=""></p> <p>上一讲提到过, veth 的虚拟网络接口一般都是<strong>成对出现</strong>, 就像上面图里的 veth_container 和 veth_host 一样. 在每次网络传输的过程中, 数据包都需要<strong>通过 veth_container 这个接口向外发送, 而且必须保证 veth_host 先接收到这个数据包</strong>.</p> <p>虽然 veth 是一个虚拟的网络接口, 但是在接收数据包的操作上, <strong>这个虚拟接口和真实的网路接口并没有太大的区别</strong>. 这里除了没有硬件中断的处理, 其他操作都差不多, 特别是软中断(softirq)的处理部分其实就和真实的网络接口是一样的.</p> <p>可以通过阅读 Linux 内核里的 veth 的驱动代码(drivers/net/veth.c)确认一下. veth 发送数据的函数是 veth_xmit(), 它里面的主要操作就是<strong>找到 veth peer 设备, 然后触发 peer 设备去接收数据包</strong>.</p> <p>比如 veth_container 这个接口调用了 veth_xmit() 来发送数据包, 最后就是触发了它的 peer 设备 veth_host 去调用 netif_rx() 来接收数据包. 主要的代码列在下面了:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token class-name">netdev_tx_t</span> <span class="token function">veth_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* 拿到veth peer设备的net_device */</span>
    rcv <span class="token operator">=</span> <span class="token function">rcu_dereference</span><span class="token punctuation">(</span>priv<span class="token operator">-&gt;</span>peer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* 将数据送到veth peer设备 */</span> 
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token function">veth_forward_skb</span><span class="token punctuation">(</span>rcv<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> rq<span class="token punctuation">,</span> rcv_xdp<span class="token punctuation">)</span> <span class="token operator">==</span> NET_RX_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">veth_forward_skb</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span>
                            <span class="token keyword">struct</span> <span class="token class-name">veth_rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> bool xdp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     <span class="token comment">/* 这里最后调用了 netif_rx() */</span>
     <span class="token keyword">return</span> <span class="token function">__dev_forward_skb</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> skb<span class="token punctuation">)</span> <span class="token operator">?</span><span class="token operator">:</span> xdp <span class="token operator">?</span>
             <span class="token function">veth_xdp_rx</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> skb<span class="token punctuation">)</span> <span class="token operator">:</span>
             <span class="token function">netif_rx</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>而 netif_rx() 是一个网络设备驱动里面标准的接收数据包的函数, netif_rx() 里面会为这个数据包 raise 一个 softirq.</p> <p>__raise_softirq_irqoff(NET_RX_SOFTIRQ);</p> <p>其实 softirq 这个概念, 之前在 CPU 的模块中也提到过. 在处理网络数据的时候, 一些运行时间较长而且不能在硬中断中处理的工作, 就会通过 softirq 来处理. 一般在硬件中断处理结束之后, 网络 softirq 的函数才会再去执行没有完成的包的处理工作. 即使这里 softirq 的执行速度很快, 还是会带来额外的开销.</p> <p><mark>**所以根据 veth 这个虚拟网络设备的实现方式, 可以看到它必然会带来额外的开销, 这样就会增加数据包的网络延时. **</mark></p> <h5 id="_3-解决问题-9"><a href="#_3-解决问题-9" class="header-anchor">#</a> 3.解决问题</h5> <p>有什么方法可以减少容器的网络延时呢? 你可能会想到, 可不可以<strong>不使用</strong> veth 这个方式配置网络接口, 而是换成别的方式呢?</p> <p>的确是这样, 其实除了 veth 之外, 容器还可以选择其他的网络配置方式. 在 Docker 的文档中提到了 <strong>macvlan</strong> 的配置方式, 和 macvlan 很类似的方式还有 <strong>ipvlan</strong>.</p> <p>先来简单看一下 macvlan 和 ipvlan 的异同点.</p> <p>先来看这两个方式的相同之处, 无论是 macvlan 还是 ipvlan, 它们<strong>都是在一个物理的网络接口上再配置几个虚拟的网络接口</strong>. 在这些虚拟的网络接口上, 都可以<strong>配置独立的 IP, 并且这些 IP 可以属于不同的 Namespace</strong>.</p> <p>然后再说说它们的不同点. <mark><strong>对于 macvlan, 每个虚拟网络接口都有自己独立的 mac 地址; 而 ipvlan 的虚拟网络接口是和物理网络接口共享同一个 mac 地址</strong></mark>​ **. ** 而且它们都有自己的 L2/L3 的配置方式, 不过主要是拿 macvlan/ipvlan 来和 veth 做比较, 这里可以先忽略 macvlan/ipvlan 这些详细的特性.</p> <p>就以 ipvlan 为例, 运行下面的这个脚本, 为<strong>容器手动配置上 ipvlan 的网络接口</strong>.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token function">docker</span> run <span class="token parameter variable">--init</span> <span class="token parameter variable">--name</span> lat-test-1 <span class="token parameter variable">--network</span> none <span class="token parameter variable">-d</span> registry/latency-test:v1 <span class="token function">sleep</span> <span class="token number">36000</span>
 
<span class="token assign-left variable">pid1</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> inspect lat-test-1 <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> Pid <span class="token operator">|</span> <span class="token function">head</span> <span class="token parameter variable">-n</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $2}'</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token parameter variable">-F</span> <span class="token string">&quot;,&quot;</span> <span class="token string">'{print $1}'</span><span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token variable">$pid1</span>
<span class="token function">ln</span> <span class="token parameter variable">-s</span> /proc/<span class="token variable">$pid1</span>/ns/net /var/run/netns/<span class="token variable">$pid1</span>
 
<span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> <span class="token function">link</span> eth0 ipvt1 <span class="token builtin class-name">type</span> ipvlan mode l2
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev ipvt1 netns <span class="token variable">$pid1</span>
 
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token variable">$pid1</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> ipvt1 name eth0
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token variable">$pid1</span> <span class="token function">ip</span> addr <span class="token function">add</span> <span class="token number">172.17</span>.3.2/16 dev eth0
<span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token variable">$pid1</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> eth0 up
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在这个脚本里, 先启动一个容器, 这里用 &quot;—network none&quot; 的方式来启动, 也就是在<strong>容器中没有配置任何的网络接口</strong>. 接着在<strong>宿主机 eth0 的接口上增加一个 ipvlan 虚拟网络接口 ipvt1, 再把它加入到容器的 Network Namespace 里面, 重命名为容器内的 eth0, 并且配置上 IP</strong>. 这样就配置好了第一个用 ipvlan 网络接口的容器.</p> <p>可以用同样的方式配置第二个容器, 这样两个容器可以相互 ping 一下 IP, 看看网络是否配置成功了.</p> <p>两个容器配置好之后, 就像下面图中描述的一样了. 从这张图里, 很容易就能看出 macvlan/ipvlan 与 veth 网络配置有什么不一样. <mark><strong>容器的虚拟网络接口, 直接连接在了宿主机的物理网络接口上了, 形成了一个网络二层的连接</strong></mark>.</p> <p><img src="/img/d129bf1961d38ceec98d611c42939a03-20230731161430-plxw1d9.png" alt=""></p> <p>如果从容器里向宿主机外发送数据, 看上去通过的接口要比 veth 少了, 那么实际情况是不是这样呢? 先来看一下 ipvlan 接口发送数据的代码.</p> <p>从下面的 ipvlan 接口的发送代码可以看到, 如果是<strong>往宿主机外发送数据, 发送函数会直接找到 ipvlan 虚拟接口对应的物理网络接口</strong>.</p> <p>比如在我们的例子中, 这个物理接口就是宿主机上的 <strong>eth0</strong>, 然后直接调用 dev_queue_xmit(), 通过物理接口把数据直接发送出去.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ipvlan_xmit_mode_l2</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ipvlan_is_vepa</span><span class="token punctuation">(</span>ipvlan<span class="token operator">-&gt;</span>port<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">ether_addr_equal</span><span class="token punctuation">(</span>eth<span class="token operator">-&gt;</span>h_dest<span class="token punctuation">,</span> eth<span class="token operator">-&gt;</span>h_source<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_multicast_ether_addr</span><span class="token punctuation">(</span>eth<span class="token operator">-&gt;</span>h_dest<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* 
     * 对于普通的对外发送数据, 上面的if 和 else if中的条件都不成立, 
     * 所以会执行到这一步, 拿到ipvlan对应的物理网路接口设备, 
     * 然后直接从这个设备发送数据. 
     */</span> 
    skb<span class="token operator">-&gt;</span>dev <span class="token operator">=</span> ipvlan<span class="token operator">-&gt;</span>phy_dev<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">dev_queue_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><strong>和 veth 接口相比, 用 ipvlan 发送对外数据就要简单得多, 因为这种方式没有内部额外的 softirq 处理开销.</strong></p> <p>现在还可以看一下, 在实际生产环境中, 一个应用程序跑在使用 veth 接口的容器中, 跟这个应用程序跑在使用 ipvlan 接口的容器中, 两者的网络延时差异是怎样的.</p> <p>下面这张图是网络延时的监控图, <strong>图里蓝色的线表示程序运行在 veth 容器中, 黄色线表示程序运行在 ipvlan 的容器里, 绿色的线代表程序直接运行在物理机上</strong>. 从这张延时(Latency)图可以看到, 在 veth 容器里程序的网络延时要明显高一些, 而程序在 ipvlan 容器里的网络延时已经比较<strong>接近</strong>物理机上的网络延时了.</p> <p><img src="/img/2ee1cf7312d7404ba31aa48201da0d38-20230731161430-opanz4h.png" alt=""></p> <p><strong>所以对于网络延时敏感的应用程序, 可以考虑使用 ipvlan/macvlan 的容器网络配置方式来替换缺省的 veth 网络配置.</strong></p> <h5 id="_4-重点小结-3"><a href="#_4-重点小结-3" class="header-anchor">#</a> 4.重点小结</h5> <p>本节主要讨论了容器网络接口对容器中应用程序网络延时的影响. 容器通常缺省使用 veth 虚拟网络接口, 不过 veth 接口会有比较大的网络延时. 可以使用 netperf 这个工具来比较网络延时, 相比物理机上的网络延时, 使用 veth 接口容器的网络延时会增加超过 10%.</p> <p>通过对 veth 实现的代码做分析, 可以看到由于 veth 接口是成对工作, **在对外发送数据的时候, peer veth 接口都会 raise softirq 来完成一次收包操作, 这样就会带来数据包处理的额外开销. **</p> <p>如果要减小容器网络延时, 就可以<strong>给容器配置 ipvlan/macvlan 的网络接口来替代 veth 网络接口</strong>. Ipvlan/macvlan 直接在物理网络接口上虚拟出接口, 在发送对外数据包的时候可以直接通过物理接口完成, 没有节点内部类似 veth 的那种 softirq 的开销. **容器使用 ipvlan/maclan 的网络接口, 它的网络延时可以非常接近物理网络接口的延时. **</p> <p>对于延时敏感的应用程序, 可以考虑使用 ipvlan/macvlan 网络接口的容器. 不过由于 ipvlan/macvlan 网络接口直接挂载在物理网络接口上, 对于<strong>需要使用 iptables 规则的容器, 比如 Kubernetes 里使用 service 的容器, 就不能工作了</strong>. 这就需要结合实际应用的需求做个判断, 再选择合适的方案.</p> <h4 id="_18-容器网络配置-3-容器中的网络乱序包怎么这么高"><a href="#_18-容器网络配置-3-容器中的网络乱序包怎么这么高" class="header-anchor">#</a> 18 | 容器网络配置(3):容器中的网络乱序包怎么这么高?</h4> <p>本节来聊一下容器中发包乱序的问题. 这个问题也同样来自于工作实践, 用户把他们的应用程序从物理机迁移到容器之后, 从网络监控中发现, <strong>容器中数据包的重传的数量要比在物理机里高了不少</strong>.</p> <p>前面已经知道了容器网络缺省的接口是 veth, veth 接口都是<strong>成对</strong>使用的. 容器通过 veth 接口向外发送数据, 首先需要从 veth 的一个接口发送给跟它成对的另一个接口. 那么<strong>这种接口会不会引起更多的网络重传呢? 如果会引起重传, 原因是什么, 我们又要如何解决呢</strong>?</p> <h5 id="_1-问题重现-3"><a href="#_1-问题重现-3" class="header-anchor">#</a> 1.问题重现</h5> <p>可以在容器里运行一下 <code>iperf3</code>​ 命令, 向容器外部发送一下数据, 从 iperf3 的输出 &quot;Retr&quot; 列里, 可以看到有多少重传的数据包.</p> <p>比如下面的例子里, 可以看到有 162 个重传的数据包.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># iperf3 -c 192.168.147.51</span>
Connecting to <span class="token function">host</span> <span class="token number">192.168</span>.147.51, port <span class="token number">5201</span>
<span class="token punctuation">[</span>  <span class="token number">5</span><span class="token punctuation">]</span> <span class="token builtin class-name">local</span> <span class="token number">192.168</span>.225.12 port <span class="token number">51700</span> connected to <span class="token number">192.168</span>.147.51 port <span class="token number">5201</span>
<span class="token punctuation">[</span> ID<span class="token punctuation">]</span> Interval           Transfer     Bitrate                        Retr    Cwnd
<span class="token punctuation">[</span>  <span class="token number">5</span><span class="token punctuation">]</span>   <span class="token number">0.00</span>-1.00   sec  <span class="token number">1001</span> MBytes  <span class="token number">8.40</span> Gbits/sec  <span class="token number">162</span>    <span class="token number">192</span> KBytes
…
- - - - - - - - - - - - - - - - - - - - - - - - -
<span class="token punctuation">[</span> ID<span class="token punctuation">]</span> Interval           Transfer     Bitrate         Retr
<span class="token punctuation">[</span>  <span class="token number">5</span><span class="token punctuation">]</span>   <span class="token number">0.00</span>-10.00  sec  <span class="token number">9.85</span> GBytes  <span class="token number">8.46</span> Gbits/sec  <span class="token number">162</span>             sender
<span class="token punctuation">[</span>  <span class="token number">5</span><span class="token punctuation">]</span>   <span class="token number">0.00</span>-10.04  sec  <span class="token number">9.85</span> GBytes  <span class="token number">8.42</span> Gbits/sec                  receiver
 
iperf Done.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><mark><strong>网络中发生了数据包的重传, 有可能是数据包在网络中丢了, 也有可能是数据包乱序导致的</strong></mark>​ **. ** 那么怎么来判断到底是哪一种情况引起的重传呢?</p> <p>最直接的方法就是用 <strong>tcpdump</strong> 去抓包, 不过对于大流量的网络, 用 tcpdump 抓包瞬间就会有几个 GB 的数据. 可是这样做的话, 带来的额外系统开销比较大, 特别是在生产环境中这个方法也不太好用.</p> <p>所以这里有一个简单的方法, 那就是运行 <strong>netstat 命令来</strong>查看协议栈中的丢包和重传的情况. 比如在运行上面的 iperf3 命令前后, 都在容器的 Network Namespace 里运行一下 netstat 看看重传的情况.</p> <p>可以发现一共发生了 162 次(604-442)<strong>快速重传</strong>(fast retransmits), 这个数值和 iperf3 中的 Retr 列里的数值是一样的.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>-bash-4.2<span class="token comment"># nsenter -t 51598 -n netstat -s | grep retran</span>
    <span class="token number">454</span> segments retransmited
    <span class="token number">442</span> fast retransmits
-bash-4.2<span class="token comment"># nsenter -t 51598 -n netstat -s | grep retran</span>
    <span class="token number">616</span> segments retransmited
    <span class="token number">604</span> fast retransmits
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h5 id="_2-问题分析"><a href="#_2-问题分析" class="header-anchor">#</a> 2.问题分析</h5> <h6 id="_1-快速重传-fast-retransmit"><a href="#_1-快速重传-fast-retransmit" class="header-anchor">#</a> (1)快速重传(fast retransmit)</h6> <p>在刚才的问题重现里, 运行 netstat 命令后, 统计了快速重传的次数. 那什么是快速重传(fast retransmit)呢? 这里解释一下.</p> <p>TCP 协议里, 发送端(sender)向接受端(receiver)发送一个数据包, <strong>接受端(receiver)都回应 ACK</strong>. 如果超过一个协议栈规定的时间(RTO), 发送端没有收到 ACK 包, 那么发送端就会<strong>重传</strong>(Retransmit)数据包, 就像下面的示意图一样.</p> <p><img src="/img/1dbceb4bec3dc19c7560772cf3a0e328-20230731161430-hilj6su.png" alt=""></p> <p>不过这样等待一个超时之后再重传数据, 对于实际应用来说太慢了, 所以 TCP 协议又定义了<strong>快速重传</strong> (fast retransmit)的概念. 它的基本定义是这样的: **如果发送端收到 3 个重复的 ACK, 那么发送端就可以立刻重新发送 ACK 对应的下一个数据包. **</p> <p>就像下面示意图里描述的那样, 接受端没有收到 Seq 2 这个包, 但是收到了 Seq 3–5 的数据包, 那么接收端在回应 Ack 的时候, Ack 的数值只能是 2. 这是因为按顺序来说收到 Seq 1 的包之后, 后面 Seq 2 一直没有到, 所以接收端就只能一直发送 Ack 2.</p> <p>那么当发送端收到 3 个重复的 Ack 2 后, 就可以<strong>马上重新发送 Seq 2 这个数据包</strong>了, 而不用再等到重传超时之后了.</p> <p><img src="/img/4d7982fc8432c2315113332c21701f5e-20230731161430-p9l9nsr.png" alt=""></p> <p>虽然 TCP 快速重传的标准定义是需要收到 3 个重复的 Ack, 不过你会发现在 Linux 中常常收到一个 Dup Ack(重复的 Ack)后, 就马上重传数据了. 这是什么原因呢? 这里先需要提到 <strong>SACK</strong> 这个概念, SACK 也就是<strong>选择性确认</strong>(Selective Acknowledgement). 其实跟普通的 ACK 相比呢, SACK 会把接收端收到的所有包的序列信息, 都反馈给发送端.</p> <p>看看下面这张图, 就能明白这是什么意思了.</p> <p><img src="/img/2d520e708051cb4b99049e172495986e-20230731161430-ghk52zs.png" alt=""></p> <p>那有了 SACK, 对于发送端来说, 在收到 SACK 之后就已经知道接收端收到了哪些数据, 没有收到哪些数据.</p> <p>在 Linux 内核中会有个判断(可以看看下面的这个函数), 大概意思是这样的: <strong>如果在接收端收到的数据和还没有收到的数据之间, 两者数据量差得太大的话(超过了 reordering*mss_cache), 也可以马上重传数据</strong>.</p> <p>这里需要注意一下, **这里的数据量差是根据 bytes 来计算的, 而不是按照包的数目来计算的, 所以会看到即使只收到一个 SACK, Linux 也可以重发数据包. **</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">static</span> bool <span class="token function">tcp_force_fast_retransmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">return</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token function">tcp_highest_sack_seq</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">,</span>
                 tp<span class="token operator">-&gt;</span>snd_una <span class="token operator">+</span> tp<span class="token operator">-&gt;</span>reordering <span class="token operator">*</span> tp<span class="token operator">-&gt;</span>mss_cache<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>了解了快速重传的概念之后, 再来看看如果 netstat 中有<strong>大量的 &quot;fast retransmits&quot;</strong>  意味着什么? 如果再用 netstat 查看 &quot;reordering&quot;, 就可以看到大量的 SACK 发现的乱序包.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>-bash-4.2<span class="token comment"># nsenter -t 51598 -n netstat -s  | grep reordering</span>
    Detected reordering <span class="token number">501067</span> <span class="token builtin class-name">times</span> using SACK
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>其实在云平台的这种网络环境里, 网络包乱序 + SACK 之后, 产生的数据包重传的量要远远高于网络丢包引起的重传. ** 比如像下面这张图里展示的这样, Seq 2 与 Seq 3 这两个包如果</strong>乱序**的话, 那么就会引起 Seq 2 的立刻重传.</p> <p><img src="/img/f3511e4f11f5d7bcae932b347d4e2726-20230731161430-08iry81.png" alt=""></p> <h6 id="_2-veth接口的数据包的发送"><a href="#_2-veth接口的数据包的发送" class="header-anchor">#</a> (2)Veth接口的数据包的发送</h6> <p>现在知道了<strong>网络包乱序会造成数据包的重传</strong>, 接着再来看看容器的 veth 接口配置有没有可能会引起数据包的乱序.</p> <p>在上一讲里, 讲过通过 veth 接口从容器向外发送数据包, 会<strong>触发 peer veth 设备去接收数据包, 这个接收的过程就是一个网络的 softirq 的处理过程</strong>. 在触发 softirq 之前, veth 接口会<strong>模拟硬件接收数据</strong>的过程, 通过 enqueue_to_backlog() 函数把数据包放到某个 CPU 对应的数据包队列里(softnet_data).</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">netif_rx_internal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
 
    <span class="token function">net_timestamp_check</span><span class="token punctuation">(</span>netdev_tstamp_prequeue<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token function">trace_netif_rx</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_RPS</span></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">static_branch_unlikely</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rps_needed<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">struct</span> <span class="token class-name">rps_dev_flow</span> voidflow<span class="token punctuation">,</span> <span class="token operator">*</span>rflow <span class="token operator">=</span> <span class="token operator">&amp;</span>voidflow<span class="token punctuation">;</span>
            <span class="token keyword">int</span> cpu<span class="token punctuation">;</span>
 
            <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">rcu_read_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
            cpu <span class="token operator">=</span> <span class="token function">get_rps_cpu</span><span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rflow<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cpu <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
            ret <span class="token operator">=</span> <span class="token function">enqueue_to_backlog</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> cpu<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rflow<span class="token operator">-&gt;</span>last_qtail<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
            <span class="token function">rcu_read_unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">preempt_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token punctuation">{</span>
            <span class="token keyword">unsigned</span> <span class="token keyword">int</span> qtail<span class="token punctuation">;</span>
 
            ret <span class="token operator">=</span> <span class="token function">enqueue_to_backlog</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token function">get_cpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>qtail<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">put_cpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>从上面的代码, 可以看到, 在缺省的状况下(也就是没有 RPS 的情况下), enqueue_to_backlog() 把数据包放到了 &quot;当前运行的 CPU&quot;(get_cpu())对应的数据队列中. 如果是从容器里通过 veth 对外发送数据包, 那么这个 &quot;当前运行的 CPU&quot; 就是容器中发送数据的进程所在的 CPU.</p> <p>对于多核的系统, 这个<strong>发送数据的进程可以在多个 CPU 上切换运行</strong>. 进程在不同的 CPU 上把数据放入队列并且 raise softirq 之后, <strong>因为每个 CPU 上处理 softirq 是个异步操作, 所以两个 CPU network softirq handler 处理这个进程的数据包时, 处理的先后顺序并不能保证</strong>. 所以, veth 对的这种发送数据方式<strong>增加了容器向外发送数据出现乱序的几率</strong>.</p> <p><img src="/img/b43534c08738c178324f7954e6f3675f-20230731161430-g3cemt4.png" alt=""></p> <h6 id="_3-rss和rps"><a href="#_3-rss和rps" class="header-anchor">#</a> (3)RSS和RPS</h6> <p>那么对于 veth 接口的这种发包方式, 有办法减少一下乱序的几率吗? 其实在上面 netif_rx_internal() 那段代码中, 有一段在 &quot;<code>#ifdef CONFIG_RPS</code>​&quot; 中的代码.</p> <p>这段代码中在调用 enqueue_to_backlog() 的时候, 传入的 CPU 并不是当前运行的 CPU, 而是通过 <strong>get_rps_cpu()</strong>  得到的 CPU, 那么这会有什么不同呢? 这里的 RPS 又是什么意思呢?</p> <p>要解释 RPS 需要先看一下 RSS, 这个 RSS 之前说的内存 RSS, 而是和网卡硬件相关的一个概念, 它是 Receive Side Scaling 的缩写. 现在的网卡性能越来越强劲了, 从原来一条 RX 队列扩展到了 N 条 RX 队列, 而网卡的硬件中断也从一个硬件中断, 变成了每条 RX 队列都会有一个硬件中断. 每个硬件中断可以由一个 CPU 来处理, 那么对于多核的系统, 多个 CPU 可以并行的接收网络包, 这样就大大地提高了系统的网络数据的处理能力. 同时, 在网卡硬件中, 可以根据数据包的 4 元组或者 5 元组信息来保证同一个数据流, 比如一个 TCP 流的数据始终在一个 RX 队列中, 这样也能保证同一流不会出现乱序的情况.</p> <p>下面这张图, 大致描述了一下 RSS 是怎么工作的.</p> <p><img src="/img/cb625048ce5d257d49ea4492d811ed5f-20230731161430-v12zdff.png" alt=""></p> <p><strong>RSS 的实现在网卡硬件和驱动里面, 而 RPS(Receive Packet Steering)其实就是在软件层面实现类似的功能</strong>. 它主要实现的代码框架就在上面的 netif_rx_internal() 代码里, 原理也不难.</p> <p>就像下面的这张示意图里描述的这样: 在硬件中断后, CPU2 收到了数据包, 再一次对数据包计算一次四元组的 hash 值, 得到这个数据包与 CPU1 的映射关系. 接着会把这个数据包放到 CPU1 对应的 softnet_data 数据队列中, 同时向 CPU1 发送一个 IPI 的中断信号.</p> <p>这样一来, 后面 CPU1 就会继续按照 Netowrk softirq 的方式来处理这个数据包了.</p> <p><img src="/img/ac14fc0f8fbea977fb33a1081163b278-20230731161430-i6uc53w.png" alt=""></p> <p>**RSS 和 RPS 的目的都是把数据包分散到更多的 CPU 上进行处理, 使得系统有更强的网络包处理能力. 在把数据包分散到各个 CPU 时, 保证了同一个数据流在一个 CPU 上, 这样就可以减少包的乱序. **</p> <p>明白了 RPS 的概念之后, 再回头来看 veth 对外发送数据时候, 在 enqueue_to_backlog() 的时候选择 CPU 的问题. 显然, 如果对应的 veth 接口上打开了 RPS 的配置以后, 那么对于同一个数据流, 就可以始终选择同一个 CPU 了.</p> <p>打开 RPS 的方法挺简单的, 只要去 /sys 目录下, 在网络接口设备接收队列中<strong>修改队列里的 rps_cpus 的值</strong>, 这样就可以了. rps_cpus 是一个 16 进制的数, 每个 bit 代表一个 CPU. 比如在一个 12CPU 的节点上, 想让 host 上的 veth 接口在所有的 12 个 CPU 上, 都可以通过 RPS 重新分配数据包. 那么就可以执行下面这段命令:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">cat</span> <span class="token expression"><span class="token operator">/</span>sys<span class="token operator">/</span>devices<span class="token operator">/</span>virtual<span class="token operator">/</span>net<span class="token operator">/</span>veth57703b6<span class="token operator">/</span>queues<span class="token operator">/</span>rx<span class="token operator">-</span><span class="token number">0</span><span class="token operator">/</span>rps_cpus</span></span>
<span class="token number">000</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">echo</span> <span class="token expression">fff <span class="token operator">&gt;</span> <span class="token operator">/</span>sys<span class="token operator">/</span>devices<span class="token operator">/</span>virtual<span class="token operator">/</span>net<span class="token operator">/</span>veth57703b6<span class="token operator">/</span>queues<span class="token operator">/</span>rx<span class="token operator">-</span><span class="token number">0</span><span class="token operator">/</span>rps_cpus</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">cat</span> <span class="token expression"><span class="token operator">/</span>sys<span class="token operator">/</span>devices<span class="token operator">/</span>virtual<span class="token operator">/</span>net<span class="token operator">/</span>veth57703b6<span class="token operator">/</span>queues<span class="token operator">/</span>rx<span class="token operator">-</span><span class="token number">0</span><span class="token operator">/</span>rps_cpus</span></span>
fff
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h5 id="_3-重点小结"><a href="#_3-重点小结" class="header-anchor">#</a> 3.重点小结</h5> <p>本节讨论的是容器中网络包乱序引起重传的问题.</p> <p>由于在容器平台中看到大部分的重传是快速重传(fast retransmits). 快速重传的基本定义是: **如果发送端收到 3 个重复的 ACK, 那么发送端就可以立刻重新发送 ACK 对应的下一个数据包, 而不用等待发送超时. ** 不过在 Linux 系统上还会看到发送端收到一个重复的 ACK 就快速重传的, 这是因为 Linux 下对 SACK 做了一个特别的判断之后, 就可以立刻重传数据包.</p> <p>再对容器云平台中的快速重传做分析, 就会发现<strong>这些重传大部分是由包的乱序触发</strong>的. 通过对容器 veth 网络接口进一步研究, 我们知道它可能会增加数据包乱序的几率. 同时在这个分析过程中, 也看到了 Linux 网络 RPS 的特性.</p> <p><strong>RPS 和 RSS 的作用类似, 都是把数据包分散到更多的 CPU 上进行处理, 使得系统有更强的网络包处理能力. 它们的区别是 RSS 工作在网卡的硬件层, 而 RPS 工作在 Linux 内核的软件层. ** 在把数据包分散到各个 CPU 时, RPS 保证了同一个数据流是在一个 CPU 上的, 这样就可以有效减少包的乱序. 那么可以</strong>把 RPS 的这个特性配置到 veth 网络接口上, 来减少数据包乱序的几率**.</p> <p>不过这里还要说明的是, RPS 的配置还是会带来<strong>额外的系统开销</strong>, 在某些网络环境中会引起 softirq CPU 使用率的增大. 那接口要不要打开 RPS 呢? 这个问题需要根据实际情况来做个权衡.</p> <p>同时还要注意, TCP 的乱序包, 并不一定都会产生数据包的重传. 想要减少网络数据包的重传, 还可以考虑协议栈中其他参数的设置, 比如 /proc/sys/net/ipv4/tcp_reordering.</p> <h3 id="容器安全"><a href="#容器安全" class="header-anchor">#</a> 容器安全</h3> <h4 id="_19-容器安全-1-我的容器真的需要privileged权限吗"><a href="#_19-容器安全-1-我的容器真的需要privileged权限吗" class="header-anchor">#</a> 19 | 容器安全(1):我的容器真的需要privileged权限吗?</h4> <p>本节进入到了容器安全的模块. 容器安全是一个很大的话题, 容器的安全性很大程度是由容器的架构特性所决定的. 比如容器与宿主机共享 Linux 内核, 通过 Namespace 来做资源的隔离, 通过 shim/runC 的方式来启动等等.</p> <p>这些容器架构特性, 在选择使用容器之后, 作为使用容器的用户, 其实你已经没有多少能力去对架构这个层面做安全上的改动了. 你可能会说用 Kata Container, gVisor 就是安全 &quot;容器&quot; 了. 不过 Kata 或者 gVisor 只是兼容了容器接口标准, 而内部的实现完全是另外的技术了.</p> <p>那么对于使用容器的用户, 在运行容器的时候, 在安全方面可以做些什么呢? 主要可以从这两个方面来考虑: <strong>第一是赋予容器合理的 capabilities, 第二是在容器中以非 root 用户来运行程序</strong>.</p> <p>为本节先来看容器的 capabilities 的问题.</p> <h5 id="_1-问题再现-12"><a href="#_1-问题再现-12" class="header-anchor">#</a> 1.问题再现</h5> <p>刚刚使用容器的同学, 往往会发现用缺省 <code>docker run</code>​ 的方式启动容器后, 在容器里很多操作都是<strong>不允许</strong>的, 即使是以 root 用户来运行程序也不行.</p> <p>用下面的例子来重现一下这个问题. 先运行 <code>make image</code>​ 做个容器镜像, 然后运行下面的脚本:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># docker run --name iptables -it registry/iptables:v1 bash</span>
<span class="token punctuation">[</span>root@0b88d6486149 /<span class="token punctuation">]</span><span class="token comment"># iptables -L</span>
iptables v1.8.4 <span class="token punctuation">(</span>nf_tables<span class="token punctuation">)</span>: Could not fetch rule <span class="token builtin class-name">set</span> generation id: Permission denied <span class="token punctuation">(</span>you must be root<span class="token punctuation">)</span>
 
<span class="token punctuation">[</span>root@0b88d6486149 /<span class="token punctuation">]</span><span class="token comment"># id</span>
<span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在容器中运行 <code>iptables</code>​ 这个命令, 来查看一下防火墙的规则, 但是执行命令之后, 会发现结果输出中给出了 &quot;Permission denied (you must be root)&quot; 的错误提示, 这个提示要求用 root 用户来运行. 不过在容器中, 现在<strong>已经是以 root 用户</strong>来运行了, 为什么还是不可以运行 &quot;iptables&quot; 这条命令?</p> <p>是不是容器中又做了别的权限限制? 如果查一下资料, 就会看到启动容器有一个 &quot;<strong>privileged</strong>&quot; 的参数. 可以试一下用上这个参数, 没错, 用了这个参数之后, iptables 这个命令就执行成功了.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># docker stop iptables;docker rm iptables</span>
iptables
iptables
<span class="token comment"># docker run --name iptables --privileged -it registry/iptables:v1 bash</span>
<span class="token punctuation">[</span>root@44168f4b9b24 /<span class="token punctuation">]</span><span class="token comment"># iptables -L</span>
Chain INPUT <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
 
Chain FORWARD <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
 
Chain OUTPUT <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>看上去, 用了一个配置参数就已经解决了问题, 似乎很容易. 不过这里可以进一步想想, 用 &quot;privileged&quot; 参数来解决问题, 是不是一个合理的方法? 用它会有什么问题?</p> <p>要回答这些问题, 先来了解一下 &quot;privileged&quot; 是什么意思. 从 Docker 的代码里可以看到, 如果配置了 privileged 的参数的话, 就会获取所有的 <strong>capabilities</strong>, 那什么是 capabilities 呢?</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">if</span> ec<span class="token punctuation">.</span>Privileged <span class="token punctuation">{</span>
    p<span class="token punctuation">.</span>Capabilities <span class="token operator">=</span> caps<span class="token punctuation">.</span><span class="token function">GetAllCapabilities</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h5 id="_2-基本概念-2"><a href="#_2-基本概念-2" class="header-anchor">#</a> 2.基本概念</h5> <h6 id="_1-linux-capabilities"><a href="#_1-linux-capabilities" class="header-anchor">#</a> (1)Linux capabilities</h6> <p>要了解 Linux capabilities 的定义, 可以先查看一下 &quot;Linux Programmer's Manual&quot; 中关于 Linux capabilities 的描述. 在 Linux capabilities 出现前, <strong>进程的权限可以简单分为两类, 第一类是特权用户的进程(进程的有效用户 ID 是 0, 简单来说可以认为它就是 root 用户的进程), 第二类是非特权用户的进程(进程的有效用户 ID 是非 0, 可以理解为非 root 用户进程)</strong> .</p> <p>特权用户进程可以执行 Linux 系统上的<strong>所有操作</strong>, 而非特权用户在执行某些操作的时候就会<strong>被内核限制执行</strong>. 其实这个概念, 也是通常对 Linux 中 root 用户与非 root 用户的理解. 从 kernel 2.2 开始, Linux <strong>把特权用户所有的这些 &quot;特权&quot; 做了更详细的划分, 这样被划分出来的每个单元就被称为 capability</strong>. 所有的 capabilities 都在 Linux capabilities 的手册列出来了, 也可以在内核的文件 capability.h 中看到所有 capabilities 的定义.</p> <p><mark>**对于任意一个进程, 在做任意一个特权操作的时候, 都需要有这个特权操作对应的 capability. **</mark></p> <p>比如运行 iptables 命令, 对应的进程需要有 CAP_NET_ADMIN 这个 capability. 如果要 mount 一个文件系统, 那么对应的进程需要有 CAP_SYS_ADMIN 这个 capability. 不过需要注意 CAP_SYS_ADMIN 这个 capability 里允许了大量的特权操作, 包括文件系统, 交换空间, 还有对各种设备的操作, 以及系统调试相关的调用等等.</p> <p><strong>在普通 Linux 节点上, 非 root 用户启动的进程缺省没有任何 Linux capabilities, 而 root 用户启动的进程缺省包含了所有的 Linux capabilities.</strong></p> <p>可以做个试验, 对于 root 用户启动的进程, 如果把 CAP_NET_ADMIN 这个 capability 移除, 看看它是否还可以运行 iptables.</p> <p>在这里要用到 capsh 这个工具. 接下来就用 capsh 执行下面的这个命令:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># sudo /usr/sbin/capsh --keep=1 --user=root   --drop=cap_net_admin  --   -c './iptables -L;sleep 100'</span>
Chain INPUT <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
 
Chain FORWARD <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
 
Chain OUTPUT <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
iptables: Permission denied <span class="token punctuation">(</span>you must be root<span class="token punctuation">)</span>.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这时候, 可以看到即使是 root 用户, 如果把 &quot;CAP_NET_ADMIN&quot; 给移除了, 那么在执行 iptables 的时候就会看到 &quot;Permission denied (you must be root).&quot; 的提示信息.</p> <p>同时, 可以通过 /proc 文件系统找到<strong>对应进程的 status</strong>, 这样就能确认进程中的 CAP_NET_ADMIN 是否已经被移除了.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># ps -ef | grep sleep</span>
root     <span class="token number">22603</span> <span class="token number">22275</span>  <span class="token number">0</span> <span class="token number">19</span>:44 pts/1    00:00:00 <span class="token function">sudo</span> /usr/sbin/capsh <span class="token parameter variable">--keep</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">--user</span><span class="token operator">=</span>root <span class="token parameter variable">--drop</span><span class="token operator">=</span>cap_net_admin -- <span class="token parameter variable">-c</span> ./iptables -L<span class="token punctuation">;</span><span class="token function">sleep</span> <span class="token number">100</span>
root     <span class="token number">22604</span> <span class="token number">22603</span>  <span class="token number">0</span> <span class="token number">19</span>:44 pts/1    00:00:00 /bin/bash <span class="token parameter variable">-c</span> ./iptables -L<span class="token punctuation">;</span><span class="token function">sleep</span> <span class="token number">100</span>
 
<span class="token comment"># cat /proc/22604/status | grep Cap</span>
CapInh:            0000000000000000
CapPrm:          0000003fffffefff
CapEff:             0000003fffffefff
CapBnd:          0000003fffffefff
CapAmb:         0000000000000000
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>运行上面的命令查看 /proc//status 里 Linux capabilities 的相关参数之后可以发现, 输出结果中包含 5 个 Cap 参数.</p> <p>这里解释一下, <strong>对于当前进程, 直接影响某个特权操作是否可以被执行的参数, 是 &quot;CapEff&quot;</strong> , 也就是 &quot;Effective capability sets&quot;, 这是一个 bitmap, 每一个 bit 代表一项 capability 是否被打开.</p> <p>在 Linux 内核 capability.h 里把 CAP_NET_ADMIN 的值定义成 12, 所以可以看到 &quot;CapEff&quot; 的值是 &quot;0000003fffffefff&quot;, 第 4 个数值是 16 进制的 &quot;e&quot;, 而不是 f. 这表示 CAP_NET_ADMIN 对应的第 12-bit 没有被置位了(0xefff = 0xffff &amp; (~(1 &lt;&lt; 12))), 所以这个进程也就没有执行 iptables 命令的权限了.</p> <p>对于进程 status 中其他几个 capabilities 相关的参数, 它们还需要和应用程序文件属性中的 capabilities 协同工作, 这样才能得到新启动的进程最终的 capabilities 参数的值.</p> <p>看下面的图, 结合这张图看后面的讲解:</p> <p><img src="/img/d8f5fbae828ce11403e3f361858f00d1-20230731161430-urtxkwt.png" alt=""></p> <p>如果要新启动一个程序, 在 Linux 里的过程就是先通过 <strong>fork()</strong>  来创建出一个子进程, 然后调用 execve() 系统调用读取文件系统里的程序文件, 把程序文件加载到进程的代码段中开始运行.</p> <p>就像图片所描绘的那样, 这个<strong>新运行的进程里的相关 capabilities 参数的值, 是由它的父进程以及程序文件中的 capabilities 参数值计算得来的</strong>. 具体的计算过程可以看 Linux capabilities 的手册中的描述, 也可以读一下网上的这两篇文章:</p> <ol><li>Capabilities: Why They Exist and How They Work</li> <li>Linux Capabilities in Practice</li></ol> <p>这里只要记住最重要的一点, <mark><strong>文件中可以设置 capabilities 参数值, 并且这个值会影响到最后运行它的进程</strong></mark>​ <strong>. ** 比如如果把 iptables 的应用程序加上 CAP_NET_ADMIN 的 capability, 那么即使是</strong>非 root 用户也有执行 iptables 的权限**了.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">id</span>
<span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>centos<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>centos<span class="token punctuation">)</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>centos<span class="token punctuation">)</span>,10<span class="token punctuation">(</span>wheel<span class="token punctuation">)</span>
$ <span class="token function">sudo</span> setcap cap_net_admin+ep ./iptables
$ getcap ./iptables
./iptables <span class="token operator">=</span> cap_net_admin+ep
$./iptables <span class="token parameter variable">-L</span>
Chain INPUT <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
 
Chain FORWARD <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
DOCKER-<span class="token environment constant">USER</span>  all  --  anywhere             anywhere
DOCKER-ISOLATION-STAGE-1  all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED
DOCKER     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere
<span class="token punctuation">..</span>.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><strong>关于 Linux capabilities 的内容到这里就讲完了, 其实它就是把 Linux root 用户原来所有的特权做了细化, 可以更加细粒度地给进程赋予不同权限</strong>.</p> <h5 id="_3-解决问题-10"><a href="#_3-解决问题-10" class="header-anchor">#</a> 3.解决问题</h5> <p>搞懂了 Linux capabilities 之后, 那么对 privileged 的容器也很容易理解了. <mark><strong>Privileged 的容器也就是允许容器中的进程可以执行所有的特权操作</strong></mark>​ **. **</p> <p>因为安全方面的考虑, 容器缺省启动的时候, 哪怕是容器中 root 用户的进程, 系统也<strong>只允许了 15 个 capabilities</strong>. 这个可以查看 runC spec 文档中的 security 部分, 也可以查看容器 init 进程 status 里的 Cap 参数, 看一下容器中缺省的 capabilities.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># docker run --name iptables -it registry/iptables:v1 bash</span>
<span class="token punctuation">[</span>root@e54694652a42 /<span class="token punctuation">]</span><span class="token comment"># cat /proc/1/status  |grep Cap</span>
CapInh:            00000000a80425fb
CapPrm:          00000000a80425fb
CapEff:              00000000a80425fb
CapBnd:          00000000a80425fb
CapAmb:         0000000000000000
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>需要注意, <strong>当发现容器中运行某个程序的权限不够的时候, 并不能 &quot;偷懒&quot; 把容器设置为 &quot;privileged&quot;, 也就是把所有的 capabilities 都赋予了容器</strong>. 因为容器中的<strong>权限越高, 对系统安全的威胁显然也是越大</strong>的. 比如如果容器中的进程有了 CAP_SYS_ADMIN 的特权之后, 那么这些进程就可以在容器里直接访问磁盘设备, 直接可以读取或者修改宿主机上的所有文件了.</p> <p>所以在容器平台上是<strong>基本不允许把容器直接设置为 &quot;privileged&quot; 的</strong>, 需要<strong>根据容器中进程需要的最少特权来赋予 capabilities</strong>.</p> <p>结合这一讲开始的例子来说说. 在开头的例子中, 容器里需要使用 iptables. 因为使用 iptables 命令, 只需要设置 <strong>CAP_NET_ADMIN</strong> 这个 capability 就行. 那么只要在运行 Docker 的时候, 给这个容器再多加一个 NET_ADMIN 参数就可以了.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># docker run --name iptables --cap-add NET_ADMIN -it registry/iptables:v1 bash</span>
<span class="token punctuation">[</span>root@cfedf124dcf1 /<span class="token punctuation">]</span><span class="token comment"># iptables -L</span>
Chain INPUT <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
 
Chain FORWARD <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
 
Chain OUTPUT <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h5 id="_4-重点小结-4"><a href="#_4-重点小结-4" class="header-anchor">#</a> 4.重点小结</h5> <p>本节主要学习了如何给容器赋予合理的 capabilities. <mark><strong>Linux capabilities 就是把 Linux root 用户原来所有的特权做了细化, 可以更加细粒度地给进程赋予不同权限</strong></mark>​ **. **</p> <p>**对于 Linux 中的每一个特权操作都有一个对应的 capability, 对于一个 capability, 有的对应一个特权操作, 有的可以对应很多个特权操作. **</p> <p>每个 Linux 进程有 5 个 capabilities 集合参数, 其中 Effective 集合里的 capabilities 决定了当前进程可以做哪些特权操作, 而其他集合参数会和应用程序文件的 capabilities 集合参数一起来决定新启动程序的 capabilities 集合参数.</p> <p>对于容器的 root 用户, 缺省只赋予了 15 个 capabilities. 如果发现容器中进程的权限不够, 就需要<strong>分析它需要的最小 capabilities 集合</strong>, 而不是直接赋予容器 &quot;privileged&quot;. 因为 &quot;privileged&quot; 包含了所有的 Linux capabilities, 这样 &quot;privileged&quot; 就可以轻易获取宿主机上的所有资源, 这会对宿主机的安全产生威胁. 所以要根据容器中进程需要的最少特权来赋予 capabilities.</p> <h4 id="_20-容器安全-2-在容器中-我不以root用户来运行程序可以吗"><a href="#_20-容器安全-2-在容器中-我不以root用户来运行程序可以吗" class="header-anchor">#</a> 20 | 容器安全(2):在容器中,我不以root用户来运行程序可以吗?</h4> <p>上一讲学习了 Linux capabilities 的概念, 也知道了对于非 privileged 的容器, 容器中 root 用户的 capabilities 是有限制的, 因此<strong>容器中的 root 用户无法像宿主机上的 root 用户一样, 拿到完全掌控系统的特权</strong>.</p> <p>那么是不是让非 privileged 的容器以 root 用户来运行程序, 这样就能保证安全了呢? 这一讲就来聊一聊容器中的 <strong>root 用户与安全相关</strong>的问题.</p> <h5 id="_1-问题再现-13"><a href="#_1-问题再现-13" class="header-anchor">#</a> 1.问题再现</h5> <p>说到容器中的用户(user), 你可能会想到, <strong>在 Linux Namespace 中有一项隔离技术, 也就是 User Namespace</strong>. 不过在容器云平台 Kubernetes 上目前还不支持 User Namespace, 所以先来看看在没有 User Namespace 的情况下, 容器中用 root 用户运行, 会发生什么情况.</p> <p>首先可以用下面的命令启动一个容器, 在这里把宿主机上  <strong>/etc 目录以 volume 的形式挂载到了容器中的 /mnt 目录下面</strong>.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># docker run -d --name root_example -v /etc:/mnt  centos sleep 3600</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>然后可以看一下容器中的进程 &quot;sleep 3600&quot;, 它在容器中和宿主机上的用户<strong>都是 root</strong>, 也就是说, 容器中用户的 uid/gid 和宿主机上的完全一样.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># docker exec -it root_example bash -c &quot;ps -ef | grep sleep&quot;</span>
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> 01:14 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang<span class="token operator">=</span>sleep /usr/bin/sleep <span class="token number">3600</span>
 
<span class="token comment"># ps -ef | grep sleep</span>
root      <span class="token number">5473</span>  <span class="token number">5443</span>  <span class="token number">0</span> <span class="token number">18</span>:14 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang<span class="token operator">=</span>sleep /usr/bin/sleep <span class="token number">3600</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>虽然容器里 root 用户的 capabilities 被限制了一些, 但是在容器中, 对于被挂载上来的 /etc 目录下的文件, 比如说 shadow 文件, 以这个 root 用户的权限还是可以做修改的.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># docker exec -it root_example bash</span>
<span class="token punctuation">[</span>root@9c7b76232c19 /<span class="token punctuation">]</span><span class="token comment"># ls /mnt/shadow -l</span>
---------- <span class="token number">1</span> root root <span class="token number">586</span> Nov <span class="token number">26</span> <span class="token number">13</span>:47 /mnt/shadow
<span class="token punctuation">[</span>root@9c7b76232c19 /<span class="token punctuation">]</span><span class="token comment"># echo &quot;hello&quot; &gt;&gt; /mnt/shadow</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>接着看看后面这段命令输出, 可以确认<strong>在宿主机上文件被修改</strong>了.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># tail -n 3 /etc/shadow</span>
grafana:<span class="token operator">!</span><span class="token operator">!</span>:18437::::::
tcpdump:<span class="token operator">!</span><span class="token operator">!</span>:18592::::::
hello
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这个例子说明<strong>容器中的 root 用户也有权限修改宿主机上的关键文件</strong>.</p> <p>当然在云平台上, 比如说在 Kubernetes 里, 是可以限制容器去挂载宿主机的目录的. 不过, 由于容器和宿主机是<strong>共享 Linux 内核</strong>的, 一旦软件有漏洞, 那么容器中以 root 用户运行的进程就有机会去修改宿主机上的文件了. 比如 2019 年发现的一个 RunC 的漏洞 CVE-2019-5736, <strong>这导致容器中 root 用户有机会修改宿主机上的 RunC 程序, 并且容器中的 root 用户还会得到宿主机上的运行权限</strong>.</p> <h5 id="_2-问题分析-2"><a href="#_2-问题分析-2" class="header-anchor">#</a> 2.问题分析</h5> <p>对于前面的问题, 接下来就来讨论一下<strong>解决办法</strong>, 在讨论问题的过程中, 也会涉及一些新的概念, 主要有三个.</p> <h6 id="_1-方法一-run-as-non-root-user-给容器指定一个普通用户"><a href="#_1-方法一-run-as-non-root-user-给容器指定一个普通用户" class="header-anchor">#</a> (1)方法一:Run as non-root user(给容器指定一个普通用户)</h6> <p>如果不想让容器以 root 用户运行, 最直接的办法就是<strong>给容器指定一个普通用户 uid</strong>. 这个方法很简单, 比如可以在 docker 启动容器的时候加上 &quot;-u&quot; 参数, 在参数中指定 <strong>uid/gid</strong>.</p> <p>具体的操作代码如下:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># docker run -ti --name root_example -u 6667:6667 -v /etc:/mnt  centos bash</span>
bash-4.4$ <span class="token function">id</span>
<span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">6667</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">6667</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">6667</span>
bash-4.4$ <span class="token function">ps</span> <span class="token parameter variable">-ef</span>
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
<span class="token number">6667</span>         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">1</span> 01:27 pts/0    00:00:00 <span class="token function">bash</span>
<span class="token number">6667</span>         <span class="token number">8</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:27 pts/0    00:00:00 <span class="token function">ps</span> <span class="token parameter variable">-ef</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>还有另外一个办法, 就是在创建容器镜像的时候, 用 <strong>Dockerfile</strong> 为容器镜像里建立一个用户.</p> <p>为方便理解, 还是举例说明. 就像下面例子中的 nonroot, 它是一个用户名, 用 USER 关键字来指定这个 nonroot 用户, 这样操作以后, <strong>容器里缺省的进程都会以这个用户启动</strong>.</p> <p>这样在运行 Docker 命令的时候就不用加 &quot;-u&quot; 参数来指定用户了.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># cat Dockerfile</span>
FROM centos
 
RUN adduser <span class="token parameter variable">-u</span> <span class="token number">6667</span> nonroot
<span class="token environment constant">USER</span> nonroot
 
<span class="token comment"># docker build -t registry/nonroot:v1 .</span>
…
 
<span class="token comment"># docker run -d --name root_example -v /etc:/mnt registry/nonroot:v1 sleep 3600</span>
050809a716ab0a9481a6dfe711b332f74800eff5fea8b4c483fa370b62b4b9b3
 
<span class="token comment"># docker exec -it root_example bash</span>
<span class="token punctuation">[</span>nonroot@050809a716ab /<span class="token punctuation">]</span>$ <span class="token function">id</span>
<span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">6667</span><span class="token punctuation">(</span>nonroot<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">6667</span><span class="token punctuation">(</span>nonroot<span class="token punctuation">)</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">6667</span><span class="token punctuation">(</span>nonroot<span class="token punctuation">)</span>
<span class="token punctuation">[</span>nonroot@050809a716ab /<span class="token punctuation">]</span>$ <span class="token function">ps</span> <span class="token parameter variable">-ef</span>
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
nonroot      <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> 01:43 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang<span class="token operator">=</span>sleep /usr/bin/sleep <span class="token number">3600</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>好, 在容器中使用普通用户运行之后, 再看看现在能否修改被挂载上来的 /etc 目录下的文件? 显然, <strong>现在不可以修改</strong>了.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token punctuation">[</span>nonroot@050809a716ab /<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">&quot;hello&quot;</span> <span class="token operator">&gt;&gt;</span> /mnt/shadow
bash: /mnt/shadow: Permission denied
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>那么是不是只要给容器中指定了一个<strong>普通用户</strong>, 这个问题就圆满解决了呢? 其实在云平台上, 这么做还是会带来别的问题. 由于用户 uid 是<strong>整个节点中共享</strong>的, 那么在容器中定义的 uid, 也就是宿主机上的 uid, 这样就很容易引起 uid 的冲突. 比如多个客户在建立自己的容器镜像的时候都选择了同一个 uid 6667. 那么当多个客户的容器在同一个节点上运行的时候, 其实就都使用了<strong>宿主机上 uid 6667</strong>.</p> <p>在一台 Linux 系统上, <strong>每个用户下的资源是有限制的, 比如打开文件数目(open files), 最大进程数目(max user processes)等等. 一旦有很多个容器共享一个 uid, 这些容器就很可能很快消耗掉这个 uid 下的资源, 这样很容易导致这些容器都不能再正常工作</strong>.</p> <p>要解决这个问题, 必须要有一个云平台级别的 uid 管理和分配, 但选择这个方法也要付出代价. 因为这样做是可以解决问题, 但是用户在定义自己容器中的 uid 的时候, 他们就需要有额外的操作, 而且平台也需要新开发对 uid 平台级别的管理模块, 完成这些事情需要的工作量也不少.</p> <h6 id="_2-方法二-user-namespace-用户隔离技术的支持"><a href="#_2-方法二-user-namespace-用户隔离技术的支持" class="header-anchor">#</a> (2)方法二:User Namespace(用户隔离技术的支持)</h6> <p>那么在<strong>没有使用 User Namespace</strong> 的情况, 对于容器平台上的用户管理还是存在问题. 你可能会想到, 是不是应该去尝试一下 User Namespace? 就一起来看看使用 User Namespace 对解决用户管理问题有没有帮助.</p> <p>首先简单了解一下 User Namespace 的概念. <strong>User Namespace 隔离了一台 Linux 节点上的 User ID(uid)和 Group ID(gid), 它给 Namespace 中的 uid/gid 的值与宿主机上的 uid/gid 值建立了一个映射关系. 经过 User Namespace 的隔离, 在 Namespace 中看到的进程的 uid/gid, 就和宿主机 Namespace 中看到的 uid 和 gid 不一样了</strong>.</p> <p>可以看下面的这张示意图, 应该就能很快知道 User Namespace 大概是什么意思了. 比如 namespace_1 里的 uid 值是 0 到 999, 但其实它在宿主机上对应的 uid 值是 1000 到 1999. 还有一点要注意的是, User Namespace 是可以<strong>嵌套</strong>的, 比如下面图里的 namespace_2 里可以再建立一个 namespace_3, 这个嵌套的特性是其他 Namespace 没有的.</p> <p><img src="/img/539dc1552acfc634542a05825b9df6e0-20230731161430-gyj4kwk.png" alt=""></p> <p>可以启动一个带 User Namespace 的容器来感受一下. 这次启动容器, 用一下 podman 这个工具, 而不是 Docker. 跟 Docker 相比, podman 不再有守护进程 dockerd, 而是直接通过 fork/execve 的方式来启动一个新的容器. 这种方式启动容器更加简单, 也更容易维护. Podman 的命令参数兼容了绝大部分的 docker 命令行参数, 用过 Docker 的同学也很容易上手 podman.</p> <p>那接下来就用下面的命令来启动一个容器:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># podman run -ti  -v /etc:/mnt --uidmap 0:2000:1000 centos bash</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>可以看到, 其他参数和前面的 Docker 命令是一样的.</p> <p>这里在命令里增加一个参数, &quot;--uidmap 0:2000:1000&quot;, 这个是标准的 User Namespace 中 uid 的映射格式: &quot;ns_uid:host_uid:amount&quot;. 那这个例子里的 &quot;0:2000:1000&quot; 是什么意思呢? 解释一下.</p> <p>第一个 0 是指在新的 Namespace 里 uid 从 0 开始, 中间的那个 2000 指的是 Host Namespace 里被映射的 uid 从 2000 开始, 最后一个 1000 是指总共需要连续映射 1000 个 uid.</p> <p>所以可以得出, **这个容器里的 uid 0 是被映射到宿主机上的 uid 2000 的. ** 这一点可以验证一下.</p> <p>首先, 先在容器中以用户 uid 0 运行一下 <code>sleep</code>​ 这个命令:</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># id</span>
<span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
<span class="token comment"># sleep 3600</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>然后就是第二步, 到宿主机上查看一下这个进程的 uid. 这里可以看到, 进程 uid 的确是 2000 了.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># ps -ef |grep sleep</span>
<span class="token number">2000</span>     <span class="token number">27021</span> <span class="token number">26957</span>  <span class="token number">0</span> 01:32 pts/0    00:00:00 /usr/bin/coreutils --coreutils-prog-shebang<span class="token operator">=</span>sleep /usr/bin/sleep <span class="token number">3600</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>第三步, 可以再回到容器中, 仍然以容器中的 root 对被挂载上来的 /etc 目录下的文件做操作, 这时可以看到操作是<strong>不被允许</strong>的.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># echo &quot;hello&quot; &gt;&gt; /mnt/shadow</span>
bash: /mnt/shadow: Permission denied
<span class="token comment"># id</span>
<span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>通过这些操作以及和前面 User Namespace 的概念的解释, 可以总结出容器使用 User Namespace 有两个好处.</p> <p>**第一, 它把容器中 root 用户(uid 0)映射成宿主机上的普通用户. **</p> <p>作为容器中的 root, 它还是可以有一些 Linux capabilities, 那么在容器中还是可以执行一些特权的操作. 而在宿主机上 uid 是普通用户, 那么即使这个用户逃逸出容器 Namespace, 它的执行权限还是<strong>有限</strong>的.</p> <p>**第二, 对于用户在容器中自己定义普通用户 uid 的情况, 只要为每个容器在节点上分配一个 uid 范围, 就不会出现在宿主机上 uid 冲突的问题了. **</p> <p>因为在这个时候, 只要在节点上分配容器的 uid 范围就可以了, 所以从实现上说, 相比在整个平台层面给容器分配 uid, 使用 User Namespace 这个办法要方便得多.</p> <p>这里额外补充一下, 前面说了 Kubernetes 目前还不支持 User Namespace, 如果想了解相关工作的进展, 可以看一下社区的这个PR.</p> <h6 id="_3-方法三-rootless-container-以非-root-用户启动和管理容器"><a href="#_3-方法三-rootless-container-以非-root-用户启动和管理容器" class="header-anchor">#</a> (3)方法三:rootless container(以非 root 用户启动和管理容器)</h6> <p>前面已经讨论了, <strong>在容器中以非 root 用户运行进程可以降低容器的安全风险</strong>. 除了在容器中使用非 root 用户, 社区还有一个 <strong>rootless container</strong> 的概念.</p> <p>这里 rootless container 中的 &quot;rootless&quot; 不仅仅指容器中以非 root 用户来运行进程, 还指<strong>以非 root 用户来创建容器</strong>, 管理容器. 也就是说, 启动容器的时候, Docker 或者 podman 是以非 root 用户来执行的. 这样一来, 就能进一步提升容器中的安全性, 就不用再担心因为 containerd 或者 RunC 里的代码漏洞, 导致容器获得宿主机上的权限.</p> <p>可以参考 redhat blog 里的这篇文档, 在宿主机上用 redhat 这个用户通过 podman 来启动一个容器. 在这个容器中也使用了 User Namespace, 并且把容器中的 uid 0 映射为宿主机上的 redhat 用户了.</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>$ <span class="token function">id</span>
<span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">1001</span><span class="token punctuation">(</span>redhat<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">1001</span><span class="token punctuation">(</span>redhat<span class="token punctuation">)</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">1001</span><span class="token punctuation">(</span>redhat<span class="token punctuation">)</span>
$ <span class="token function">podman</span> run <span class="token parameter variable">-it</span>  ubi7/ubi <span class="token function">bash</span>   <span class="token comment">### 在宿主机上以redhat用户启动容器</span>
<span class="token punctuation">[</span>root@206f6d5cb033 /<span class="token punctuation">]</span><span class="token comment"># id     ### 容器中的用户是root</span>
<span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
<span class="token punctuation">[</span>root@206f6d5cb033 /<span class="token punctuation">]</span><span class="token comment"># sleep 3600   ### 在容器中启动一个sleep 进程</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># ps -ef |grep sleep   ###在宿主机上查看容器sleep进程对应的用户</span>
redhat   <span class="token number">29433</span> <span class="token number">29410</span>  <span class="token number">0</span> 05:14 pts/0    00:00:00 <span class="token function">sleep</span> <span class="token number">3600</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>目前 Docker 和 podman 都支持了 rootless container, Kubernetes 对rootless container 支持的工作也在进行中.</p> <h5 id="_3-重点小结-2"><a href="#_3-重点小结-2" class="header-anchor">#</a> 3.重点小结</h5> <p>本节今天讨论的内容是 root 用户与容器安全的问题. 尽管容器中 root 用户的 Linux capabilities 已经减少了很多, 但是在没有 User Namespace 的情况下, <strong>容器中 root 用户和宿主机上的 root 用户的 uid 是完全相同的, 一旦有软件的漏洞, 容器中的 root 用户就可以操控整个宿主机</strong>.</p> <p><mark><strong>为了减少安全风险, 业界都是建议在容器中以非 root 用户来运行进程</strong></mark>​ **. ** 不过在没有 User Namespace 的情况下, 在容器中使用非 root 用户, 对于容器云平台来说, 对 uid 的管理会比较麻烦.</p> <p>所以还是要分析一下 User Namespace, 它带来的好处有两个. 一个是把容器中 root 用户(uid 0)映射成宿主机上的普通用户, 另外一个好处是在云平台里对于容器 uid 的分配要容易些. <strong>除了在容器中以非 root 用户来运行进程外, Docker 和 podman 都支持了 rootless container, 也就是说它们都可以以非 root 用户来启动和管理容器, 这样就进一步降低了容器的安全风险</strong>.</p> <h3 id="结束语"><a href="#结束语" class="header-anchor">#</a> 结束语</h3> <h4 id="结束语-跳出舒适区-突破思考的惰性"><a href="#结束语-跳出舒适区-突破思考的惰性" class="header-anchor">#</a> 结束语 | 跳出舒适区,突破思考的惰性</h4> <p>在多年以前, 我在书里读到一句话, 说的是 &quot;<strong>每个人都有潜在的能量, 只是很容易被习惯所掩盖, 被时间所迷离, 被惰性所消磨</strong>.&quot;</p> <p>今天再次回看这段话, 还真是一语中的, 感触良多, 回想起专栏写作的整个过程, 这件事带给我的最大感悟就是: **跳出自己的舒适区, 才能有所突破. **</p> <h5 id="_1-突破舒适区是很难的事儿"><a href="#_1-突破舒适区是很难的事儿" class="header-anchor">#</a> 1.突破舒适区是很难的事儿</h5> <p>突破舒适区是一件很难的事儿. 这里分享一个我自己的故事, 也许你也会从这个故事里找到自己的影子.</p> <p>记得在 2 年前, 我参加过 eBay 的一个内部培训, 培训的目标就是要让自己有所&quot;突破&quot;. 我必须承认, 这个培训是我经历过的所有培训中最接地气的一个培训, 在培训过程里我也是情绪激昂的, 准备带着学到的东西回到工作里去大展身手, 好好突破一番的.</p> <p>不过等培训结束, 再回到日常工作的时候, 之前的雄心壮志, <strong>激情澎湃又被日常的琐事所淹没, 积蓄的那股劲儿又慢慢被消磨</strong>了. 周围的同事会开玩笑地对我说: &quot;程远啊, 我觉得你没有突破啊. &quot;</p> <p>其实, 我心里也知道, 所谓的&quot;突破&quot;就要跳出自己的舒适区. 不过我始终不知道怎么跳出来, 哪怕自己手上的工作再多, 工作到再晚, 但这仍然是处于自己舒适区. <strong>这是因为这一切的工作节奏还有思考的问题, 都是我自己熟悉的</strong>.</p> <p>这种熟悉很可能让我们沉湎其中, 裹足不前. 那问题来了, 意识到自己处于舒适区, 产生想要&quot;跳出去&quot;的念头的确是良好开局, 难的是怎么有效突破. 这就要聊到突破方法路径的问题了, 我想结合自己的感悟给你说一说.</p> <h5 id="_2-主动迎接挑战-在实战中进步"><a href="#_2-主动迎接挑战-在实战中进步" class="header-anchor">#</a> 2.主动迎接挑战,在实战中进步</h5> <p>不知道你有没有听过热力学里熵增的定律, 大概说的是: <strong>封闭系统的熵(能量)会不可逆地增加, 最终导致整个系统崩溃</strong>. 那怎么才能保持这个系统的活力呢? <strong>就是能量交换, 不断去引入外部的能量, 也就是负熵</strong>.</p> <p>可以引申一下, 自然会想到走出舒适区这件事, 也是同样的道理. 我们<strong>要有一种冒险家的勇气, 主动去迎接挑战, 在实战里迫使自己不断进步</strong>.</p> <p>其实选择做这样一个专栏, 对我来说就是走出舒适区的一项&quot;挑战&quot;. 在今年 7 月份, 那还是我们这个专栏筹备的前期, 我当时就一个想法, 就是把我这些年来在容器方面的积累给记录下来.</p> <p>从 7 月份决定写容器这个专栏开始, 到现在差不多也有半年的时间了, 我真的觉得, 在工作的同时把写专栏的这件事给坚持下来, 真的是一件不容易的事情. **这里不仅仅是一个简单的时间投入问题, 更多的是迫使自己再去思考的问题. **</p> <p>估计你也发现了, 我每一讲都涉及不少知识点. 我在专栏写作的过程中, 花时间最多的就是怎么把问题说清楚, 这里要解释哪些关键知识点, 适合用什么样的例子做解释, 每个知识点要讲到什么程度, 需要查阅哪些代码和资料来保证自己所讲内容的正确性.</p> <p>这样的思考模式和我日常思考工作问题的模式是完全不同的. 但也正是借着这样的机会, 我才从自己原先的舒适区里跳了出来, 工作之余同时也在思考写专栏的问题, 每天都有大量的 context switch, 也就是上下文切换.</p> <p>我很高兴自己可以坚持下来, 完成了专栏的主体部分. 可以说, 这门课既是容器的实战课, 也是我自己走出舒适区的实战训练.</p> <h5 id="_3-突破舒适区-本质是突破思考的惰性"><a href="#_3-突破舒适区-本质是突破思考的惰性" class="header-anchor">#</a> 3.突破舒适区,本质是突破思考的惰性</h5> <p>这次的专栏写作, 还让我意识到, <mark><strong>突破舒适区的本质就是突破思考的惰性. 只有不断思考, 才能推着自己不断往前走, 才能让我们更从容地解决工作上的问题</strong></mark>​ **. **</p> <p>在 2020 年的 12 月初, Kubernetes 宣布不再支持 dockershim, 也就是说 Kubernetes 节点上不能再直接用 Docker 来启动容器了. 当时我看到这条新闻, 觉得这是理所当然的, 因为我们的容器云平台上在 2019 年初就从 Docker 迁移到了 Containerd.</p> <p>不过, 后来我在专栏留言回复的过程中, 连续有三位同学留言, 问我怎么看 Kubernetes 的这个决定, 这让我又回忆起了当初我们团队是怎么做的迁移决定.</p> <p>这件事还要追溯到 2018 年的时候, 我们发现 kubelet 通过 CRI 接口就可以集成 Containerd 了, 于是我们就开始思考, 是不是应该用 Containerd 来替换 Docker 呢?</p> <p>当时我们看到的好处有两点. 第一点是这样替换之后<strong>架构上的优势</strong>, CRI 可以说是 kubelet 连接 Runtime 的标准了, 而用 Dockershim 接 Docker 再转 Containerd, 这样很累赘. 第二点好处就是<strong>降低了维护成本</strong>. Containerd 只是 Docker 中的一部分, 维护 Containerd 明显要比维护庞大的 Docker 容易.</p> <p>当然, 这么做的挑战也是很大的. 当时, 我们在生产环境中已经有 2 万台物理机节点以及几十万个容器, 而且那时候业界还几乎没有人在生产环境中用 kubelet 直接调用 Containerd. 没有前人的尝试可以借鉴, 只能咬牙打一场硬仗.</p> <p>后来我们通过一个多月的测试, 发现直接使用 Containerd, 无论是稳定性还是性能都没有问题. 有了实际测试做保障, 我们在 2019 年初又花了 3 个月时间, 才把生产环境上的 Docker 全部替换成 Containerd.</p> <p>这样的结果看似轻描淡写, 一两句话就带过了. 但实际过程里, 已经不是过五关斩六将了, 而是一直在发现问题, 解决问题, 大大小小的战役才汇聚成了最后的战果. 其实, 我在这个专栏里和你分享的一些容器问题, 也来源于我们当时的迁移实践.</p> <p>现在回想起来, 当初的这个决定无疑是非常正确的了. 不过再想想, 如果当时看到 Kubernetes 的变化, 我们没有主动思考, 等到现在 Kubernetes 宣布不再支持 Dockershim 才去做应对, 结果又会怎样呢?</p> <p>这个问题, 我觉得用数字来说话更直观. 刚才提到当时迁移的时候, 有 2 万台物理机节点以及几十万个容器. 但如果等到现在才迁移, 我们需要面对的就是 6 万台物理机和上百万的容器了.</p> <p>**你看, 无论是写专栏也好, 还是我们实际工作也好, 呆在舒适区里, 短期成本看着挺小, 不需要你大动干戈, 消耗脑细胞和精力. 但是, 当你习惯了这种思考的惰性, 就会变成温水煮青蛙而不自知, 等到外部条件发生变化时会很被动. **</p> <p>‍</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/30.系统/3100.容器/10.容器/100.容器实战高手课(极客时间)🌸.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/582acf/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">部署Minikube</div></a> <a href="/pages/c6a42c/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Kubernetes实战🌸</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/582acf/" class="prev">部署Minikube</a></span> <span class="next"><a href="/pages/c6a42c/">Kubernetes实战🌸</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/192.184d249f.js" defer></script>
  </body>
</html>
