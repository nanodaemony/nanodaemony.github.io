<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>垃圾收集器与内存分配策略🌼 | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/79.fa10f4e3.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/4f30b9/" class="sidebar-link">Java基础</a></li><li><a href="/pages/795eca/" class="sidebar-link">类与继承</a></li><li><a href="/pages/c69152/" class="sidebar-link">抽象类与接口</a></li><li><a href="/pages/d71abb/" class="sidebar-link">内部类</a></li><li><a href="/pages/f06dca/" class="sidebar-link">枚举类</a></li><li><a href="/pages/259f57/" class="sidebar-link">常用类</a></li><li><a href="/pages/84b03b/" class="sidebar-link">关键字</a></li><li><a href="/pages/31b87b/" class="sidebar-link">注解</a></li><li><a href="/pages/f81c0d/" class="sidebar-link">异常</a></li><li><a href="/pages/ae7746/" class="sidebar-link">泛型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>容器类</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/0c88ac/" class="sidebar-link">集合容器类基础</a></li><li><a href="/pages/f805ed/" class="sidebar-link">List与Queue类</a></li><li><a href="/pages/d24b60/" class="sidebar-link">Map与Set类</a></li><li><a href="/pages/54e5d3/" class="sidebar-link">并发容器类</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/67d70f/" class="sidebar-link">多线程基础</a></li><li><a href="/pages/ffc8f7/" class="sidebar-link">Java内置锁</a></li><li><a href="/pages/c43494/" class="sidebar-link">AQS</a></li><li><a href="/pages/eb5b61/" class="sidebar-link">显式锁ReentrantLock</a></li><li><a href="/pages/eb8cbc/" class="sidebar-link">线程协作与JUC组件</a></li><li><a href="/pages/23c79a/" class="sidebar-link">Atomic原子变量与Unsafe类与CAS</a></li><li><a href="/pages/9d6ed4/" class="sidebar-link">线程池与定时任务</a></li><li><a href="/pages/5b787a/" class="sidebar-link">ThreadLocal</a></li><li><a href="/pages/db53d1/" class="sidebar-link">Java并发编程实战(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>IO</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b4d461/" class="sidebar-link">文件操作</a></li><li><a href="/pages/1b9d6c/" class="sidebar-link">IO流操作</a></li><li><a href="/pages/076a47/" class="sidebar-link">Java网络IO模型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>高级特性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d76905/" class="sidebar-link">Lambda表达式</a></li><li><a href="/pages/f7f0e6/" class="sidebar-link">流Stream</a></li><li><a href="/pages/7cc40a/" class="sidebar-link">反射</a></li><li><a href="/pages/945326/" class="sidebar-link">代理</a></li><li><a href="/pages/7fd9b4/" class="sidebar-link">Javaagent</a></li><li><a href="/pages/a3cee0/" class="sidebar-link">Guava</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>JVM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d308f6/" class="sidebar-link">走进JVM🌼</a></li><li><a href="/pages/be0269/" class="sidebar-link">JVM内存区域与对象解析🌼</a></li><li><a href="/pages/48d1be/" aria-current="page" class="active sidebar-link">垃圾收集器与内存分配策略🌼</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/3a4c8a/" class="sidebar-link">JVM性能监控与故障处理工具🌼</a></li><li><a href="/pages/106680/" class="sidebar-link">调优案例分析与实战🌼</a></li><li><a href="/pages/16a914/" class="sidebar-link">类文件结构🌼</a></li><li><a href="/pages/ea287c/" class="sidebar-link">虚拟机类加载机制🌼</a></li><li><a href="/pages/6367b0/" class="sidebar-link">虚拟机字节码执行引擎🌼</a></li><li><a href="/pages/c6c210/" class="sidebar-link">类加载及执行子系统的案例与实战🌼</a></li><li><a href="/pages/deb8b7/" class="sidebar-link">前端编译与优化🌼</a></li><li><a href="/pages/1f8f72/" class="sidebar-link">后端编译与优化🌼</a></li><li><a href="/pages/3d72db/" class="sidebar-link">Java内存模型与线程实现🌼</a></li><li><a href="/pages/ed086e/" class="sidebar-link">线程安全与内置锁优化🌼</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/56b9dd/" class="sidebar-link">Java性能问题定位分析</a></li><li><a href="/pages/939bf8/" class="sidebar-link">杂记</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>开发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>软件设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/a5f6fe/" class="sidebar-link">设计基础理论</a></li><li><a href="/pages/3b245c/" class="sidebar-link">设计模式之美(极客时间)🌟</a></li><li><a href="/pages/661fa4/" class="sidebar-link">领域驱动设计(DDD)</a></li><li><a href="/pages/856368/" class="sidebar-link">DDD实战课(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d3fbd2/" class="sidebar-link">数据库基础</a></li><li><a href="/pages/691fc3/" class="sidebar-link">数据库系统原理</a></li><li><a href="/pages/50f6b7/" class="sidebar-link">MySQL基础必知必会</a></li><li><a href="/pages/fe297e/" class="sidebar-link">MySQL特性</a></li><li><a href="/pages/07bdb6/" class="sidebar-link">MySQL索引🌟</a></li><li><a href="/pages/984715/" class="sidebar-link">MySQL锁🌟</a></li><li><a href="/pages/53b588/" class="sidebar-link">MySQL事务🌟</a></li><li><a href="/pages/becc59/" class="sidebar-link">MySQL高级特性</a></li><li><a href="/pages/056463/" class="sidebar-link">MySQL基础架构与存储引擎🌟</a></li><li><a href="/pages/63b46e/" class="sidebar-link">MySQL架构优化与运维</a></li><li><a href="/pages/9995e5/" class="sidebar-link">MySQL优化</a></li><li><a href="/pages/c1c2f6/" class="sidebar-link">MySQL架构</a></li><li><a href="/pages/8e8e0a/" class="sidebar-link">MySQL设计规范</a></li><li><a href="/pages/0219aa/" class="sidebar-link">MySQL运维</a></li><li><a href="/pages/e288c0/" class="sidebar-link">MySQL中间件</a></li><li><a href="/pages/c6cafa/" class="sidebar-link">MySQL实战45讲(极客时间)🌟</a></li><li><a href="/pages/4a6106/" class="sidebar-link">数据库LeetCode题目</a></li><li><a href="/pages/2827f1/" class="sidebar-link">数据库综合问题</a></li><li><a href="/pages/c616d5/" class="sidebar-link">MongoDB</a></li><li><a href="/pages/075e71/" class="sidebar-link">ClickHouse</a></li><li><a href="/pages/d74f6d/" class="sidebar-link">Doris</a></li><li><a href="/pages/b6bad9/" class="sidebar-link">HBase</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Spring</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bd8eb8/" class="sidebar-link">Spring Boot基础</a></li><li><a href="/pages/d0d797/" class="sidebar-link">Spring Boot应用整合</a></li><li><a href="/pages/314cdc/" class="sidebar-link">Spring MVC基础</a></li><li><a href="/pages/80de47/" class="sidebar-link">Spring AOP基础</a></li><li><a href="/pages/f0d4d6/" class="sidebar-link">Spring事务基础</a></li><li><a href="/pages/db6afe/" class="sidebar-link">Spring IOC源码分析-概览</a></li><li><a href="/pages/672e98/" class="sidebar-link">Spring IOC源码分析-getBean()</a></li><li><a href="/pages/695b90/" class="sidebar-link">Spring IOC源码分析-createBean()</a></li><li><a href="/pages/f89bcf/" class="sidebar-link">Spring AOP源码分析</a></li><li><a href="/pages/3b52f4/" class="sidebar-link">Spring事务源码分析</a></li><li><a href="/pages/186902/" class="sidebar-link">Spring Boot源码分析</a></li><li><a href="/pages/16bd1c/" class="sidebar-link">Spring MVC源码分析</a></li><li><a href="/pages/3d0c1f/" class="sidebar-link">Spring Cloud</a></li><li><a href="/pages/d56156/" class="sidebar-link">Spring编程常见错误50例(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>MyBatis</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bb032d/" class="sidebar-link">基础</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>工具与环境</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c9cb6e/" class="sidebar-link">Arthas</a></li><li><a href="/pages/3172bb/" class="sidebar-link">Maven</a></li><li><a href="/pages/37f79a/" class="sidebar-link">Git</a></li><li><a href="/pages/db9f99/" class="sidebar-link">环境搭建与部署</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c725f5/" class="sidebar-link">测试基础</a></li><li><a href="/pages/7893a4/" class="sidebar-link">单元测试</a></li><li><a href="/pages/af9f25/" class="sidebar-link">压力测试</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>代码质量</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ec2b81/" class="sidebar-link">代码整洁之道</a></li><li><a href="/pages/474cdf/" class="sidebar-link">阿里巴巴编程规范</a></li><li><a href="/pages/c47e15/" class="sidebar-link">代码之丑(极客时间)🌸</a></li><li><a href="/pages/4d4606/" class="sidebar-link">Java业务开发常见错误100例(极客时间)🌸</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/develop/#开发" data-v-06970110>开发</a></li><li data-v-06970110><a href="/develop/#Java" data-v-06970110>Java</a></li><li data-v-06970110><a href="/develop/#JVM" data-v-06970110>JVM</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">垃圾收集器与内存分配策略🌼<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_21-垃圾收集器与内存分配策略🌼"><a href="#_21-垃圾收集器与内存分配策略🌼" class="header-anchor">#</a> 21.垃圾收集器与内存分配策略🌼</h1> <p>本节是《深入理解 Java 虚拟机》的第三章</p> <p>Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的高墙, 墙外面的人想进去, 墙里面的人却想出来.</p> <h4 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h4> <p>说起垃圾收集(Garbage Collection, 下文简称 GC), 有不少人把这项技术当作 Java 语言的伴生产物. 事实上, 垃圾收集的历史远远比 Java 久远, 在 1960 年诞生的 Lisp 是第一门开始使用内存动态分配和垃圾收集技术的语言. 当 Lisp 还在胚胎时期时就思考过垃圾收集需要完成的三件事情:</p> <ul><li><strong>哪些内存需要回收?</strong></li> <li><strong>什么时候回收?</strong></li> <li><strong>如何回收?</strong></li></ul> <p>经过半个世纪的发展, 今天的内存动态分配与内存回收技术已经相当成熟, 一切看起来都进入了 &quot;自动化&quot; 时代, 那为什么还要去了解垃圾收集和内存分配? 答案很简单: <strong>当需要排查各种内存溢出, 内存泄漏问题时, 当垃圾收集成为系统达到更高并发量的瓶颈时, 就必须对这些 &quot;自动化&quot; 的技术实施必要的监控和调节</strong>.</p> <blockquote><p>垃圾回收的范围</p></blockquote> <p>前面介绍了 Java 内存运行时区域的各个部分, <strong>其中程序计数器, 虚拟机栈, 本地方法栈 3 个区域是线程私有的, 随线程而生, 随线程而灭</strong>, 栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作. 每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的, 因此这几个区域的内存分配和回收都具备确定性, 在这几个区域内就不需要过多考虑如何回收的问题, 当方法结束或者线程结束时, 内存自然就跟随着回收了.</p> <p>而 Java <mark><strong>堆和方法区</strong></mark>这两个区域则有着很显著的不确定性: <strong>一个接口的多个实现类需要的内存可能会不一样, 一个方法所执行的不同条件分支所需要的内存也可能不一样, 只有处于运行期间, 才能知道程序究竟会创建哪些对象, 创建多少个对象, 这部分内存的分配和回收是动态的. 垃圾收集器所关注的正是这部分内存该如何管理, 本文后续讨论中的 &quot;内存&quot; 分配与回收也仅仅特指这一部分内存</strong>.</p> <h4 id="判断对象是否可回收"><a href="#判断对象是否可回收" class="header-anchor">#</a> 判断对象是否可回收?</h4> <p>在堆里面存放着 Java 世界中几乎所有的对象实例, 垃圾收集器在对堆进行回收前, 第一件事情就是要<strong>确定这些对象之中哪些还 &quot;存活&quot; 着, 哪些已经 &quot;死去&quot;</strong> (即不可能再被任何途径使用的对象)了.</p> <h5 id="_1-引用计数算法"><a href="#_1-引用计数算法" class="header-anchor">#</a> 1.引用计数算法</h5> <p>为对象添加一个<strong>引用计数器</strong>, 当对象增加一个引用时计数器加 1, 引用失效时减 1, 引用计数为 0 的对象就能被回收.</p> <p>主流虚拟机中并没有选择这个算法来管理内存, 因为它很难解决对象之间<strong>相互循环引用</strong>的问题. 在两个对象出现<strong>循环引用</strong>的情况下, 此时引用计数器永远不为 0, 导致<strong>无法</strong>对它们进行回收, 进而造成<strong>内存泄漏</strong>问题.</p> <blockquote><p>引用计数法缺陷示例</p></blockquote> <p>举个例子,下面对象 a 与 b 互相持有对方的引用, 因此当把对 a 与 b 的引用去除之后, 由于两个对象还存在互相之间的引用, 如果采用引用计数法就会导致这两个对象无法被回收.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceCountingGC</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">Object</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">ONE_MB</span> <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

    <span class="token comment">// 这个成员属性的唯一意义就是占点内存, 以便能在 GC 日志中看清楚是否有回收过</span>
    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bigSize <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token constant">ONE_MB</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ReferenceCountingGC</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ReferenceCountingGC</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        a<span class="token punctuation">.</span>instance <span class="token operator">=</span> b<span class="token punctuation">;</span>
        b<span class="token punctuation">.</span>instance <span class="token operator">=</span> a<span class="token punctuation">;</span>

        a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        b <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

        <span class="token comment">// 假设在这行发生 GC, objA 和 objB 是否能被回收? </span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>运行结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>[Full GC (System) [Tenured: 0K-&gt;210K(10240K), 0.0149142 secs] 4603K-&gt;210K(19456K), [Perm : 2999K-&gt;2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]
Heap
    def new generation   total 9216K, used 82K [0x00000000055e0000, 0x0000000005fe0000, 0x0000000005fe0000)
    Eden space 8192K,   1% used [0x00000000055e0000, 0x00000000055f4850, 0x0000000005de0000)
    from space 1024K,   0% used [0x0000000005de0000, 0x0000000005de0000, 0x0000000005ee0000)
    to   space 1024K,   0% used [0x0000000005ee0000, 0x0000000005ee0000, 0x0000000005fe0000)
    tenured generation   total 10240K, used 210K [0x0000000005fe0000, 0x00000000069e0000, 0x00000000069e0000)
    the space 10240K,   2% used [0x0000000005fe0000, 0x0000000006014a18, 0x0000000006014c00, 0x00000000069e0000)
    compacting perm gen  total 21248K, used 3016K [0x00000000069e0000, 0x0000000007ea0000, 0x000000000bde0000)
    the space 21248K,  14% used [0x00000000069e0000, 0x0000000006cd2398, 0x0000000006cd2400, 0x0000000007ea0000)
    No shared spaces configured.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>从运行结果中可以清楚看到内存回收日志中包含 &quot;4603K-&gt;210K&quot;, 意味着虚拟机<strong>已经回收了它们</strong>, 这也从侧面说明了 Java 虚拟机并不是通过引用计数算法来判断对象是否存活的.</p> <h5 id="_2-可达性分析算法"><a href="#_2-可达性分析算法" class="header-anchor">#</a> 2.可达性分析算法</h5> <p><strong>可达性分析(Reachability Analysis)算法</strong>的基本思路就<strong>通过一系列称为 &quot;GC Roots&quot; 的根对象作为起始节点集, 从这些节点开始, 根据引用关系向下搜索, 搜索过程所走过的路径称为 &quot;引用链&quot;(Reference Chain), 如果某个对象到 GC Roots 间没有任何引用链相连, 或者用图论的话来说就是从 GC Roots 到这个对象不可达时, 则证明此对象是不可能再被使用的</strong>. 这是主流的方法.</p> <p>如下图所示, 对象 object4, object5 虽然互有关联, 但是它们到 GC Roots 是不可达的, 因此它们将会被判定为可回收的对象.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521121813327.png" alt=""></p> <p>在 Java 技术体系里面, <strong>固定可作为 GC Roots 的对象</strong>包括以下几种:</p> <ul><li><mark><strong>在虚拟机栈(栈帧中的本地变量表)中引用的对象, 譬如各个线程被调用的方法堆栈中使用到的参数, 局部变量, 临时变量等</strong></mark>. 其实就是方法执行过程中产生的对象, 这些对象实际分配到<strong>堆</strong>中, 方法栈中保存着这些对象到堆区的引用. 在 GC 的时候, 如果这个方法的栈帧依然是有效的, 那这里面指向的对象就不能被回收, 因此需要以它们为 GC Root 来寻找存活的对象. 但是当线程结束之后, 这些对象就没有任何引用了.</li> <li><strong>在方法区中类静态属性引用的对象, 譬如 Java 类的引用类型静态变量</strong>. 静态变量所指向的对象也是在堆中的, 因此会用静态变量作为 Root 来找堆中的存活对象.</li> <li><strong>在方法区中常量引用的对象, 譬如字符串常量池(String Table)里的引用</strong>.</li> <li>在<strong>本地方法栈中 JNI(即通常所说的 Native 方法)引用的对象</strong>.</li> <li>Java 虚拟机内部的引用, 如基本数据类型对应的 Class 对象, 一些常驻的异常对象(比如 NullPointExcepiton, OutOfMemoryError)等, 还有系统类加载器.</li> <li>所有被同步锁(synchronized 关键字)持有的对象.</li> <li>反映 Java 虚拟机内部情况的 JMXBean, JVMTI 中注册的回调, 本地代码缓存等.</li></ul> <p>GC Roots 的节点主要在<strong>全局性的引用</strong>(例如常量或类静态属性) 与<strong>执行上下文</strong>(例如栈帧中的本地变量表) 中.</p> <h5 id="_3-finalize-对象自救"><a href="#_3-finalize-对象自救" class="header-anchor">#</a> 3.finalize()对象自救</h5> <p>即使在可达性分析算法中判定为不可达的对象, 也不是 &quot;非死不可&quot; 的, 这时候它们暂时还处于 &quot;<strong>缓刑</strong>&quot; 阶段, 要<strong>真正宣告一个对象死亡, 至少要经历两次标记过程</strong>.</p> <p><strong>第一次标记</strong>: <strong>如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链, 那它将会被第一次标记, 随后进行一次筛选, 筛选的条件是此对象是否有必要执行 finalize() 方法</strong>. 假如对象没有覆盖 finalize() 方法, 或者 finalize() 方法已经被虚拟机调用过, 那么虚拟机将这两种情况都视为 &quot;没有必要执行&quot;. 当对象没有<strong>覆写</strong> finalize() 方法, 或 finalize() 方法已经被虚拟机<strong>调用过</strong>时, 对象将被<strong>直接回收</strong>. 如果这个对象被判定为确有必要执行 finalize() 方法, 那么该对象将会<strong>被放置在一个名为 F-Queue 的队列之中, 并在稍后由一条由虚拟机自动建立的, 低调度优先级的 Finalizer 线程去执行它们的 finalize() 方法</strong>. 这里所说的 &quot;执行&quot; 是指虚拟机会触发这个方法开始运行, 但<strong>并不承诺</strong>一定会等待它运行结束. 这样做的原因是, 如果某个对象的 finalize() 方法执行缓慢, 或者更极端地发生了死循环, 将很可能导致 F-Queue 队列中的其他对象<strong>永久处于等待, 甚至导致整个内存回收子系统的崩溃</strong>.</p> <p><strong>第二次标记</strong>: 如果这个对象覆写了 finalize() 方法, 那么 finalize() 方法是对象逃脱死亡命运的最后一次机会, 稍后收集器将对 F-Queue 中的对象进行<strong>第二次小规模</strong>的标记, 如果对象要在 finalize() 中成功拯救自己, <strong>要重新与引用链上的任何一个对象建立关联即可</strong>, 譬如把自己(this 关键字)赋值给某个类变量或者对象的成员变量, 那在第二次标记时它将被<strong>移出</strong> &quot;即将回收&quot; 的集合; 如果对象这时候还没有逃脱, 那基本上它就真的要被回收了.</p> <p><strong>总结如何自我救赎:</strong></p> <ol><li>对象<strong>覆写</strong>了 <strong>finalize()</strong>  方法(这样在被<strong>判死后才会调用此方法</strong>, 才有机会做最后的救赎).</li> <li>在 <strong>finalize()</strong>  方法中<strong>重新引用到 &quot;GC  Roots&quot; 链</strong>上(如把当前对象的引用 this 赋值给某对象的类变量/成员变量, 重新建立可达的引用).</li></ol> <blockquote><p>一次对象自我拯救的示例</p></blockquote> <p>下面的代码可以看到一个对象的 finalize() 被执行, 但是它仍然可以存活.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * 此代码演示了两点: 
 * 1.对象可以在被 GC 时自我拯救. 
 * 2.这种自救的机会只有一次, 因为一个对象的 finalize()方法最多只会被系统自动调用一次
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalizeEscapeGC</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">FinalizeEscapeGC</span> <span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;yes, i am still alive :)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;finalize method executed!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">FinalizeEscapeGC</span><span class="token punctuation">.</span><span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalizeEscapeGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 对象第一次成功拯救自己</span>
        <span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 因为 Finalizer 方法优先级很低, 暂停0.5秒, 以等待它</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">SAVE_HOOK</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token constant">SAVE_HOOK</span><span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;no, i am dead :(&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 下面这段代码与上面的完全相同, 但是这次自救却失败了</span>
        <span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 因为 Finalizer 方法优先级很低, 暂停0.5秒, 以等待它</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">SAVE_HOOK</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token constant">SAVE_HOOK</span><span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;no, i am dead :(&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><p>运行结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>finalize method executed!
yes, i am still alive :)
no, i am dead :(
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>从代码运行结果可以看到, SAVE_HOOK 对象的 finalize() 方法确实被垃圾收集器触发过, 并且在被收集前成功逃脱了.</p> <p>另外一个值得注意的地方就是, 代码中有两段完全一样的代码片段, 执行结果却是一次逃脱成功, 一次失败了. <strong>这是因为任何一个对象的 finalize() 方法都只会被系统自动调用一次, 如果对象面临下一次回收, 它的 finalize() 方法不会被再次执行, 因此第二段代码的自救行动失败了</strong>.</p> <p>还有一点需要特别说明, 上面关于对象死亡时 finalize() 方法的描述可能带点悲情的艺术加工, 这里并不鼓励大家使用这个方法来拯救对象. 相反, 笔者建议大家<strong>尽量避免使用它</strong>, 因为它的运行代价高昂, 不确定性大, <strong>无法保证各个对象的调用顺序</strong>, 如今已被官方明确声明为不推荐使用的语法. 有些教材中描述它适合做 &quot;关闭外部资源&quot; 之类的清理性工作, 这完全是对 finalize() 方法用途的一种自我安慰. <strong>finalize() 能做的所有工作, 使用 try-finally 或者其他方式都可以做得更好, 更及时, 所以建议大家完全可以忘掉 Java 语言里面的这个方法</strong>.</p> <h4 id="引用类型"><a href="#引用类型" class="header-anchor">#</a> 引用类型</h4> <p>无论是通过引用计数算法判断对象的引用数量, 还是通过可达性分析算法判断对象是否引用链可达, 判定对象是否存活都和 &quot;<strong>引用</strong>&quot; 离不开关系. Java 提供了四种强度不同的引用类型: <strong>强软弱虚</strong>(强度递减).</p> <h5 id="_1-引用类型分类"><a href="#_1-引用类型分类" class="header-anchor">#</a> 1.引用类型分类</h5> <blockquote><p>强引用</p></blockquote> <p><strong>强引用</strong>是最传统的 &quot;引用&quot; 的定义, 是指在程序代码之中普遍存在的<strong>引用赋值</strong>.</p> <p>无论任何情况下, <strong>只要强引用关系还存在, 垃圾收集器就永远不会回收掉被引用的对象</strong>. 当内存空间不足时, 虚拟机<strong>宁愿</strong>抛出 OutOfMemoryError 错误使程序异常终止, 也<strong>不会</strong>靠随意回收具有强引用的对象来解决内存不足问题.</p> <p>被强引用的对象<strong>不会</strong>被回收. 使用 new 一个新对象的方式来创建强引用, 最普遍, 类似<strong>生活必需品</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>软应用</p></blockquote> <p><strong>软引用</strong>是用来描述一些<strong>还有用, 但非必须的对象</strong>. 被<strong>软引用</strong>关联的对象只有在<strong>内存不够</strong>的情况下才会被回收. 正常情况不会被回收, 但是 <strong>GC 做完</strong>后发现释放不出空间存放新的对象, 则会把这些软引用的对象回收掉. 如果内存足够, 垃圾回收器就不会回收它, 如果没有回收, 那么就可以继续使用. <strong>类似可有可无的生活用品</strong>.</p> <p><strong>软引用可用来实现内存敏感的高速缓存.</strong>  比如可以用于缓存浏览器的历史页面实现后退按钮.</p> <p>使用 <strong>SoftReference</strong> 类来创建软引用.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// 使对象只被软引用关联</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><p>弱引用</p></blockquote> <p><strong>弱引用</strong>也是用来描述那些<strong>非必须对象, 但是它的强度比软引用更弱一些, 被弱引用关联的对象只能生存到下一次垃圾收集发生为止</strong>. 当垃圾收集器开始工作, 无论当前内存是否足够, 都会回收掉只被弱引用关联的对象.</p> <p>使用 <strong>WeakReference</strong> 类来创建弱引用.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> wf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><p>虚引用</p></blockquote> <p><strong>虚引用</strong>也称为 &quot;幽灵引用&quot; 或者 &quot;幻影引用&quot;, 它是最弱的一种引用关系. 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也<strong>无法</strong>通过虚引用来取得一个对象实例. <strong>为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知</strong>.</p> <p>使用 <strong>PhantomReference</strong> 来创建虚引用.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> pf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h5 id="_2-引用队列"><a href="#_2-引用队列" class="header-anchor">#</a> 2.引用队列</h5> <p><strong>软引用和弱引用</strong>都可以和一个<strong>引用队列</strong>(ReferenceQueue) 联合使用, 如果软引用或弱引用所引用的对象<strong>被垃圾回收</strong>, 虚拟机就会把这个软引用或弱引用加入到<strong>与之关联的引用队列中</strong>. 虚引用必须和引用队列(ReferenceQueue) 联合使用. 当垃圾回收器准备回收一个对象时, 如果发现它还有虚引用, 就会在回收对象的内存之前, 把这个虚引用加入到与之关联的引用队列中. 程序可以通过判断引用队列中是否已经加入了虚引用, 来了解被引用的对象是否将要被垃圾回收. 程序如果发现某个虚引用已经被加入到引用队列, 那么就可以在所引用的对象的内存被回收之前采取必要的行动.</p> <h4 id="回收方法区"><a href="#回收方法区" class="header-anchor">#</a> 回收方法区</h4> <p>有些人认为<strong>方法区</strong>(如 HotSpot 虚拟机中的元空间或者永久代)是没有垃圾收集行为的, 《Java 虚拟机规范》中提到过<strong>可以不要求虚拟机在方法区中实现垃圾收集</strong>, 事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在(如 ZGC 收集器就不支持类卸载), <strong>方法区垃圾收集的 &quot;性价比&quot; 通常也是比较低的</strong>: 在 Java 堆中, 尤其是在新生代中, 对常规应用进行一次垃圾收集通常可以回收 70% 至 99% 的内存空间, 相比之下, 方法区回收囿于<strong>苛刻的判定条件</strong>, 其区域垃圾收集的回收成果往往远低于此.</p> <p>但是为了避免内存溢出, <strong>在大量使用反射, 动态代理, CGLib 等字节码框架, 动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中, 通常都需要 Java 虚拟机具备类型卸载的能力, 以保证不会对方法区造成过大的内存压力</strong>.</p> <p>方法区的垃圾收集主要回收两部分内容: <mark><strong>废弃的常量和不再使用的类型</strong></mark>.</p> <blockquote><p>如何判断常量是废弃的常量?</p></blockquote> <p>回收废弃常量与回收 Java 堆中的对象非常类似. 举个常量池中字面量回收的例子, 假如一个字符串 &quot;java&quot; 曾经进入常量池中, 但是当前系统又没有任何一个字符串对象的值是 &quot;java&quot;, 换句话说, <strong>已经没有任何字符串对象引用常量池中的 &quot;java&quot; 常量, 且虚拟机中也没有其他地方引用这个字面量</strong>. 如果在这时发生内存回收, 而且垃圾收集器判断确有必要的话, 这个 &quot;java&quot; 常量就将会被系统清理出常量池. 常量池中其他类(接口), 方法, 字段的符号引用也与此类似.</p> <blockquote><p>如何判断类是无用的类?</p></blockquote> <p>判定一个常量是否 &quot;废弃&quot; 还是相对简单, 而要<strong>判定一个类型是否属于 &quot;不再被使用的类&quot; 的条件就比较苛刻</strong>了.</p> <p>需要同时满足下面三个条件:</p> <ul><li><strong>该类所有的实例都已经被回收</strong>, 也就是 Java 堆中不存在该类及其任何派生子类的实例.</li> <li><strong>加载该类的类加载器已经被回收</strong>, 这个条件除非是经过精心设计的可替换类加载器的场景, 如 OSGi, JSP 的重加载等, 否则通常是很难达成的.</li> <li><strong>该类对应的 java.lang.Class 对象没有在任何地方被引用</strong>, 无法在任何地方通过反射访问该类的方法.</li></ul> <p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收, 这里说的仅仅是 &quot;被允许&quot;, 而并不是和对象一样, 没有引用了就必然会回收. 关于是否要对类型进行回收, HotSpot 虚拟机提供了 <code>-Xnoclassgc</code>​ 参数进行控制, 还可以使用 <code>-verbose: class</code>​ 以及 <code>-XX: +TraceClass-Loading, -XX: +TraceClassUnLoading</code>​ 查看类加载和卸载信息.</p> <h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="header-anchor">#</a> 垃圾收集算法</h4> <p>垃圾收集算法的实现涉及大量的程序细节, 且各个平台的虚拟机操作内存的方法都有差异, 在本节中暂不过多讨论算法实现, 只重点介绍<strong>分代收集理论和几种算法思想及其发展过程</strong>.</p> <p>主要介绍四种算法. 四种算法可以应用在不同的区域及场合.</p> <h5 id="_1-分代收集理论"><a href="#_1-分代收集理论" class="header-anchor">#</a> 1.分代收集理论</h5> <h6 id="_1-分代收集理论基础"><a href="#_1-分代收集理论基础" class="header-anchor">#</a> (1)分代收集理论基础</h6> <p>当前商业虚拟机的垃圾收集器, 大多数都遵循了 &quot;<mark><strong>分代收集</strong></mark>&quot;(Generational Collection) 的理论进行设计, <strong>分代收集名为理论, 实质是一套符合大多数程序运行实际情况的经验法则</strong>, 它建立在两个分代假说之上:</p> <p>(1)<strong>弱分代假说</strong>(Weak Generational Hypothesis): <strong>绝大多数对象都是朝生夕灭的</strong>.</p> <p>(2)<strong>强分代假说</strong>(Strong Generational Hypothesis): <strong>熬过越多次垃圾收集过程的对象就越难以消亡</strong>.</p> <p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则: <mark><strong>收集器应该将 Java 堆划分出不同的区域, 然后将回收对象依据其年龄(年龄即对象熬过垃圾收集过程的次数)分配到不同的区域之中存储</strong></mark>. 显而易见, 如果一个区域中大多数对象都是朝生夕灭, 难以熬过垃圾收集过程的话, 那么把它们集中放在一起, 每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象, 就能以较低代价回收到大量的空间; 如果剩下的都是难以消亡的对象, 那把它们集中放在一块, 虚拟机便可以使用较低的频率来回收这个区域, 这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用.</p> <p>在 Java 堆划分出不同的区域之后, <strong>垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了 &quot;Minor GC&quot;, &quot;Major GC&quot;, &quot;Full GC&quot; 这样的回收类型的划分</strong>; 也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法, 因而发展出了  <strong>&quot;标记-复制算法&quot;, &quot;标记-清除算法&quot;, &quot;标记-整理算法&quot;</strong>  等针对性的垃圾收集算法. 现在只需要知道, <strong>这一切的出现都始于分代收集理论</strong>.</p> <p>把分代收集理论具体放到现在的商用 Java 虚拟机里, 设计者一般至少会把 Java 堆划分为<strong>新生代</strong>(Young Generation)和<strong>老年代</strong>(Old Generation)两个区域. 顾名思义, <strong>在新生代中, 每次垃圾收集时都发现有大批对象死去, 而每次回收后存活的少量对象, 将会逐步晋升到老年代中存放</strong>. HotSpot 虚拟机源码里面存在着一些名为 &quot;*Generation&quot; 的实现, 如 &quot;DefNewGeneration&quot; 和 &quot;ParNewGeneration&quot; 等, 这些就是 HotSpot 的 &quot;分代式垃圾收集器框架&quot;. 原本 HotSpot 鼓励开发者尽量在这个框架内开发新的垃圾收集器, 但除了最早期的两组四款收集器之外, 后来的开发者并没有继续遵循. 导致此事的原因有很多, 最根本的是分代收集理论仍在不断发展之中, 如何实现也有许多细节可以改进, 被既定的代码框架约束反而不便. 其实只要仔细思考一下, 也很容易发现分代收集并非只是简单划分一下内存区域那么容易, 它至少存在一个明显的困难: <strong>对象不是孤立的, 对象之间会存在跨代引用</strong>.</p> <p>假如要现在进行一次只局限于新生代区域内的收集(Minor GC), 但新生代中的对象是完全有可能被老年代所引用的, 为了找出该区域中的存活对象, 不得不在固定的 GC Roots 之外, 再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性, 反过来也是一样. 遍历整个老年代所有对象的方案虽然理论上可行, 但无疑会为内存回收带来很大的性能负担. 为了解决这个问题, 就需要对分代收集理论添加<strong>第三条经验法则</strong>:</p> <p>(3)<strong>跨代引用假说</strong>(Intergenerational Reference Hypothesis): <strong>跨代引用相对于同代引用来说仅占极少数</strong>.</p> <p>这其实是可根据前两条假说逻辑推理得出的隐含推论: <strong>存在互相引用关系的两个对象, 是应该倾向于同时生存或者同时消亡的</strong>. 举个例子, 如果某个新生代对象存在跨代引用, 由于老年代对象难以消亡, 该引用会使得新生代对象在收集时同样得以存活, 进而在年龄增长之后晋升到老年代中, 这时跨代引用也随即被消除了.</p> <p>依据这条假说, 就<strong>不应再为了少量的跨代引用去扫描整个老年代</strong>, 也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用, 只需在新生代上建立一个<strong>全局的数据结构</strong>(该结构被称为 &quot;<strong>记忆集</strong>&quot;, Remembered Set, 参考: 记忆集与卡表), 这个结构把老年代划分成若干小块, <strong>标识出老年代的哪一块内存会存在跨代引用</strong>. 此后当发生 Minor GC 时, 只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描. 虽然这种方法需要在对象改变引用关系(如将自己或者某个属性赋值)时维护记录数据的正确性, 会增加一些运行时的开销, 但比起收集时扫描整个老年代来说仍然是划算的.</p> <h6 id="_2-基于分代收集的堆基本结构"><a href="#_2-基于分代收集的堆基本结构" class="header-anchor">#</a> (2)基于分代收集的堆基本结构</h6> <p>Hotspot 的很多虚拟机都采用<strong>分代垃圾收集算法</strong>. 所以堆还可以细分为: <strong>新生代和老年代</strong>. 再细致一点分的话分成: Eden 空间, From Survivor, To Survivor 空间等. <strong>进一步划分的目的是更好地回收内存, 或者更快地分配内存</strong>.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220517230027658.png" alt=""></p> <p>经过一次 GC 后, Eden 区和 &quot;From&quot; 区已经被<strong>清空</strong>. 这个时候, &quot;From&quot; 和 &quot;To&quot; 会<strong>交换</strong>他们的角色(复制), 也就是新的 &quot;To&quot; 就是上次 GC 前的 &quot;From&quot;, 新的 &quot;From&quot; 就是上次 GC 前的 &quot;To&quot;.</p> <p>不管怎样, 都会保证名为 <strong>To</strong> 的 Survivor 区域是<strong>空的</strong>. Minor GC 会一直重复这样的过程, 直到 &quot;To&quot; 区被填满, &quot;To&quot; 区被填满之后, 会将所有对象移动到<strong>老年代</strong>中. 这两个区一次<strong>只用一个</strong>, Minor GC 时采用<strong>复制算法</strong>将 Eden 区和一个 Survivor 区的存活对象复制到另一个 Survivor 区中. 因此在新生代中垃圾回收算法多为<strong>复制算法</strong>.</p> <p>需要注意, <strong>不是所有的垃圾收集器都是这样划分的, 比如 ZGC 收集器, 目前就没有分代收集的概念, 所以自然不会这样划分堆内存</strong>.</p> <h6 id="_3-minor-gc与full-gc"><a href="#_3-minor-gc与full-gc" class="header-anchor">#</a> (3)Minor GC与Full GC</h6> <blockquote><p>名词定义</p></blockquote> <p>刚才已经提到了 &quot;Minor GC&quot;, 后续文中还会出现其他针对不同分代的类似名词, 为避免读者产生混淆, 在这里统一定义:</p> <p>(1) <strong>部分收集(Partial GC)</strong> : 指目标不是完整收集整个 Java 堆的垃圾收集, 其中又分为:</p> <ul><li><mark><strong>新生代收集(Minor GC/Young GC)</strong></mark> : 指目标只是新生代的垃圾收集.</li> <li><mark><strong>老年代收集(Major GC/Old GC)</strong></mark> : 指目标只是老年代的垃圾收集. 目前只有 CMS 收集器会有单独收集老年代的行为.</li> <li><mark><strong>混合收集(Mixed GC)</strong></mark> : 指目标是收集整个新生代以及部分老年代的垃圾收集. 目前只有 G1 收集器会有这种行为.</li></ul> <p>(2) <strong>整堆收集(Full GC)</strong> : 收集整个 Java 堆(老年代 + 年轻代)和方法区的垃圾收集.</p> <blockquote><p>Minor GC触发条件</p></blockquote> <p>Minor GC 发生在<strong>新生代</strong>上, 因为新生代对象存活时间很短, 因此 Minor GC 会<strong>频繁</strong>执行, 执行速度一般比较快.</p> <p><strong>Eden 区满了</strong>就触发了 Minor GC.</p> <ul><li>新生代中的垃圾收集动作, 采用的是<strong>复制算法</strong>.</li> <li>对于较大的对象, 在 Minor GC 的时候可以直接进入<strong>老年代</strong>.</li></ul> <blockquote><p>Full GC触发条件</p></blockquote> <p>Full GC 发生在<strong>老年代</strong>上, 老年代对象存活时间长, 因此 Full GC <strong>很少执行</strong>, 执行速度会比 Minor GC 慢很多. 常见的触发原因:</p> <ul><li><strong>调用 System.gc()</strong> . 这个方法会<strong>建议</strong>虚拟机执行 Full GC, 但是虚拟机<strong>不一定</strong>真正去执行. 不建议使用这种方式, 而是让虚拟机管理内存. (常考)</li> <li>老年代空间不足.</li> <li>老年代空间分配担保失败(参考: 老年代空间分配担保机制).</li></ul> <h5 id="_2-标记-清除算法"><a href="#_2-标记-清除算法" class="header-anchor">#</a> 2.标记-清除算法</h5> <blockquote><p>标记-清除算法的流程</p></blockquote> <p>标记-清除(Mark-Sweep)算法主要分为<strong>标记</strong>与<strong>清除</strong>两个步骤.</p> <p><strong>首先标记出所有需要回收的对象, 在标记完成后, 统一回收掉所有被标记的对象, 也可以反过来, 标记存活的对象, 统一回收所有未被标记的对象</strong>. 标记过程就是对象是否属于垃圾的判定过程, 这在前一节讲述垃圾对象标记判定算法时其实已经介绍过了.</p> <p>之所以说它是最基础的收集算法, 是因为后续的收集算法大多都是以标记-清除算法为基础, 对其缺点进行改进而得到的.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521125600745.png" alt="" title="&quot;标记-清除&quot;算法示意图"></p> <blockquote><p>标记-清除算法的缺点</p></blockquote> <p>标记-清除算法的主要缺点有两个:</p> <ol><li><strong>第一个是执行效率不稳定</strong>. 如果 Java 堆中包含<strong>大量对象</strong>, 而且其中大部分是需要被回收的, 这时必须进行大量标记和清除的动作, 导致标记和清除两个过程的执行效率都随对象数量增长而降低.</li> <li><strong>第二个是内存空间的碎片化问题</strong>. 标记, 清除之后会产生大量不连续的内存碎片, 空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作.</li></ol> <h5 id="_3-标记-复制算法"><a href="#_3-标记-复制算法" class="header-anchor">#</a> 3.标记-复制算法</h5> <p>标记-复制算法即将<strong>内存</strong>划分为大小相等的<strong>两块</strong>, 每次<strong>只使用其中一块</strong>, 当这一块内存用完了就将还存活的对象复制到<strong>另一块上面</strong>, 然后再把使用过的内存空间进行一次清理.</p> <p>为了解决标记-清除算法<strong>面对大量可回收对象时执行效率低</strong>的问题, 提出了一种称为 &quot;半区复制&quot;(Semispace Copying)的垃圾收集算法, <strong>它将可用内存按容量划分为大小相等的两块, 每次只使用其中的一块</strong>. 当这一块的内存用完了, 就将还存活着的对象复制到另外一块上面, 然后再把已使用过的内存空间一次清理掉. <strong>如果内存中多数对象都是存活的, 这种算法将会产生大量的内存间复制的开销, 但对于多数对象都是可回收的情况, 算法需要复制的就是占少数的存活对象, 而且每次都是针对整个半区进行内存回收, 分配内存时也就不用考虑有空间碎片的复杂情况, 只要移动堆顶指针, 按顺序分配即可</strong>. 这样实现简单, 运行高效, 不过其缺陷也显而易见, 这种复制回收算法的代价是<strong>将可用内存缩小为了原来的一半</strong>, 空间浪费未免太多了一点.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521130236760.png" alt=""></p> <p>现在的商用 Java 虚拟机大多都优先采用了这种收集算法去回收新生代, IBM 公司曾有一项专门研究对新生代 &quot;朝生夕灭&quot; 的特点做了更量化的诠释--<mark><strong>新生代中的对象有 98% 熬不过第一轮收集. 因此并不需要按照 1∶1 的比例来划分新生代的内存空间</strong></mark>.</p> <p>HotSpot 虚拟机的 Serial, ParNew 等新生代收集器均采用了这种策略来设计新生代的内存布局. 具体做法是<strong>把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间, 每次分配内存只使用 Eden 和其中一块 Survivor</strong>. 发生垃圾收集时, 将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上, 然后直接清理掉 Eden 和已用过的那块 Survivor 空间. <strong>HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是</strong> <mark><strong>8∶1</strong></mark>​ <strong>, 也即每次新生代中可用内存空间为整个新生代容量的 90%(Eden 的 80% 加上一个 Survivor 的 10%), 只有一个 Survivor 空间, 即 10% 的新生代是会被 &quot;浪费&quot; 的</strong>.</p> <p>如果每次回收有多于 10% 的对象存活, 那么一块 Survivor 就<strong>不够用</strong>了, 此时需要依赖于<strong>老年代进行空间分配担保</strong>, 也就是借用老年代的空间存储放不下的对象. 如果空间担保失败, 则触发 Full GC.</p> <p><mark><strong>内存的分配担保</strong></mark>好比去银行借款, 如果信誉很好, 在 98% 的情况下都能按时偿还, 于是银行可能会默认下一次也能按时按量地偿还贷款, 只需要有一个担保人能保证如果我不能还款时, 可以从他的账户扣钱, 那银行就认为没有什么风险了. <mark><strong>内存的分配担保也一样, 如果另外一块 Survivor 空间没有足够空间存放上一次新生代收集下来的存活对象, 这些对象便将通过分配担保机制直接进入老年代, 这对虚拟机来说就是安全的</strong></mark>. 关于对新生代进行分配担保的内容, 后面介绍垃圾收集器执行规则时还会再进行讲解(参考: 空间分配担保).</p> <h5 id="_4-标记-整理算法"><a href="#_4-标记-整理算法" class="header-anchor">#</a> 4.标记-整理算法</h5> <p><strong>标记-复制算法在对象存活率较高时就要进行较多的复制操作, 效率将会降低</strong>. 更关键的是, 如果不想浪费 50% 的空间, 就需要有额外的空间进行分配担保, 以应对被使用的内存中所有对象都 100% 存活的极端情况, 所以<strong>在老年代一般不能直接选用这种算法</strong>.</p> <p>针对老年代对象的存亡特征(大对象, 且存活时间长的对象), Edward Lueders 提出了另外一种有针对性的 &quot;<strong>标记-整理</strong>&quot;(Mark-Compact)算法, 其中的标记过程仍然与 &quot;标记-清除&quot; 算法一样, 但后续步骤不是直接对可回收对象进行清理, 而是<strong>让所有存活的对象都向内存空间一端移动, 然后直接清理掉边界以外的内存</strong>.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521132900524.png" alt=""></p> <p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法, 而后者是移动式的. <strong>是否移动回收后的存活对象是一项优缺点并存的风险决策</strong>:</p> <ul><li>如果移动存活对象, 尤其是在老年代这种每次回收都有大量对象存活区域, 移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作, 而且<strong>这种对象移动操作必须全程暂停用户应用程序才能进行</strong>.</li> <li>但如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话, 弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决. 譬如通过 &quot;分区空闲分配链表&quot; 来解决内存分配问题(计算机硬盘存储大文件就不要求物理连续的磁盘空间, 能够在碎片化的硬盘上存储和访问就是通过硬盘分区表实现的). 内存的访问是用户程序最频繁的操作, 甚至都没有之一, 假如在这个环节上增加了额外的负担, 势必会直接影响应用程序的吞吐量.</li></ul> <p>基于以上两点, 是否移动对象都存在弊端, 移动则内存回收时会更复杂, 不移动则内存分配时会更复杂. 从垃圾收集的停顿时间来看, 不移动对象停顿时间会更短, 甚至可以不需要停顿, 但是从整个程序的吞吐量来看, 移动对象会更划算. 此语境中, <strong>吞吐量的实质是赋值器(Mutator, 可以理解为使用垃圾收集的用户程序, 本书为便于理解, 多数地方用 &quot;用户程序&quot; 或 &quot;用户线程&quot; 代替)与收集器的效率总和</strong>. 即使不移动对象会使得收集器的效率提升一些, 但因内存分配和访问相比垃圾收集频率要高得多, 这部分的耗时增加, 总吞吐量仍然是下降的. <strong>HotSpot 虚拟机里面关注吞吐量的 Parallel Scavenge 收集器是基于标记-整理算法的, 而关注延迟的 CMS 收集器则是基于标记-清除算法的</strong>, 这也从侧面印证这点.</p> <p>另外, 还有一种 &quot;和稀泥式&quot; 解决方案可以不在内存分配和访问上增加太大额外负担, 做法是让虚拟机平时多数时间都采用标记-清除算法, 暂时容忍内存碎片的存在, 直到内存空间的碎片化程度已经大到影响对象分配时, 再采用标记-整理算法收集一次, 以获得规整的内存空间. 前面提到的基于标记-清除算法的 CMS 收集器面临空间碎片过多时采用的就是这种处理办法.</p> <h4 id="hotspot虚拟机垃圾收集算法实现细节"><a href="#hotspot虚拟机垃圾收集算法实现细节" class="header-anchor">#</a> HotSpot虚拟机垃圾收集算法实现细节</h4> <p>前面从理论原理上介绍了常见的对象存活判定算法和垃圾收集算法, Java 虚拟机实现这些算法时, 必须对算法的执行效率有严格的考量, 才能保证虚拟机高效运行. 本章设置这部分内容主要是为了稍后介绍各款垃圾收集器时做前置知识铺垫.</p> <h5 id="_1-根节点枚举"><a href="#_1-根节点枚举" class="header-anchor">#</a> 1.根节点枚举</h5> <p>这里以可达性分析算法中从 GC Roots 集合找引用链这个操作作为介绍虚拟机高效实现的第一个例子. 固定可作为 GC Roots 的节点主要在全局性的引用(例如常量或类静态属性)与执行上下文(例如栈帧中的本地变量表)中, 尽管目标明确, 但<strong>查找过程要做到高效并非一件容易的事情</strong>, 现在 Java 应用越做越庞大, 光是方法区的大小就常有数百上千兆, 若要逐个检查以这里为起源的引用肯定得消耗不少时间.</p> <p><mark><strong>迄今为止, 所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的, 因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的 &quot;Stop The World(STW)&quot; 的困扰. 现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发, 但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行, 这里 &quot;一致性&quot; 的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上, 不会出现分析过程中, 根节点集合的对象引用关系还在不断变化的情况, 若这点不能满足的话, 分析结果准确性也就无法保证. 这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因, 即使是号称停顿时间可控, 或者(几乎)不会发生停顿的 CMS, G1, ZGC 等收集器, 枚举根节点时也是必须要停顿的</strong></mark>.</p> <p>由于目前主流 Java 虚拟机使用的都是<strong>准确式</strong>垃圾收集, 所以当用户线程停顿下来之后, 其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置, 虚拟机应当是有办法直接得到哪些地方存放着对象引用的. 在 HotSpot 的解决方案里, 是<strong>使用一组称为 OopMap 的数据结构</strong>来达到这个目的. <strong>一旦类加载动作完成的时候, HotSpot 就会把对象内什么偏移量上是什么类型的数据计算出来, 在即时编译过程中, 也会在特定的位置记录下栈里和寄存器里哪些位置是引用. 这样收集器在扫描时就可以直接得知这些信息了, 并不需要真正一个不漏地从方法区等 GC Roots 开始查找</strong>.</p> <p>下面代码清单 3-3 是 HotSpot 虚拟机客户端模式下生成的一段 <code>String::hashCode()</code>​ 方法的本地代码, 可以看到在 0x026eb7a9 处的 call 指令有 OopMap 记录, 它指明了 EBX 寄存器和栈中偏移量为 16 的内存区域中各有一个普通对象指针(Ordinary Object Pointer, OOP)的引用, 有效范围为从 call 指令开始直到 0x026eb730(指令流的起始位置) + 142(OopMap 记录的偏移量) = 0x026eb7be, 即 hlt 指令为止.</p> <blockquote><p>代码清单3-3 String.hashCode()方法编译后的本地代码</p></blockquote> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>[Verified Entry Point]
0x026eb730: mov    %eax,-0x8000(%esp)
......
;; ImplicitNullCheckStub slow case
0x026eb7a9: call   0x026e83e0       ; OopMap{ebx=Oop [16]=Oop off=142}
                                    ; *caload
                                    ; - java.lang.String::hashCode@48 (line 1489)
                                    ;   {runtime_call}
    0x026eb7ae: push   $0x83c5c18   ;   {external_word}
    0x026eb7b3: call   0x026eb7b8
    0x026eb7b8: pusha
    0x026eb7b9: call   0x0822bec0   ;   {runtime_call}
    0x026eb7be: hlt
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h5 id="_2-安全点"><a href="#_2-安全点" class="header-anchor">#</a> 2.安全点</h5> <p>在 OopMap 的协助下, HotSpot 可以快速准确地完成 GC Roots 枚举, 但一个很现实的问题随之而来: <strong>可能导致引用关系变化, 或者说导致 OopMap 内容变化的指令非常多, 如果为每一条指令都生成对应的 OopMap, 那将会需要大量的额外存储空间, 这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂</strong>.</p> <p><mark><strong>实际上 HotSpot 也的确没有为每条指令都生成 OopMap, 前面已经提到, 只是在 &quot;特定的位置&quot; 记录了这些信息, 这些位置被称为安全点(Safepoint)</strong></mark> . 有了安全点的设定, 也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集, 而是<mark><strong>强制要求必须执行到达安全点后才能够暂停</strong></mark>.</p> <p><strong>安全点就是指代码中一些特定的位置, 当线程运行到这些位置时它的状态是确定的, 这样 JVM 就可以安全的进行一些操作</strong>, 比如 GC 等, 所以 GC 不是想什么时候做就立即触发的, 是需要等待所有线程运行到安全点后才能触发.</p> <blockquote><p>安全点的选定策略</p></blockquote> <p>安全点的选定既不能太少以至于让收集器等待时间过长, 也不能太过频繁以至于过分增大运行时的内存负荷. 安全点位置的选取基本上是以 &quot;<strong>是否具有让程序长时间执行的特征</strong>&quot; 为标准进行选定的, 因为每条指令执行的时间都非常短暂, 程序不太可能因为指令流长度太长这样的原因而长时间执行, &quot;长时间执行&quot; 的最明显特征就是<strong>指令序列的复用</strong>, 例如<strong>方法调用, 循环跳转, 异常跳转等都属于指令序列复用, 所以只有具有这些功能的指令才会产生安全点</strong>.</p> <p>对于安全点, 另外一个需要考虑的问题是, <strong>如何在垃圾收集发生时让所有线程(这里其实不包括执行 JNI 调用的线程)都跑到最近的安全点, 然后停顿下来</strong>. 这里有两种方案可供选择: 抢先式中断(Preemptive Suspension)和主动式中断(Voluntary Suspension), 抢先式中断不需要线程的执行代码主动去配合, 在垃圾收集发生时, 系统首先把所有用户线程全部中断, 如果发现有用户线程中断的地方不在安全点上, 就恢复这条线程执行, 让它一会再重新中断, 直到跑到安全点上. 现在<strong>几乎没有</strong>虚拟机实现采用抢先式中断来暂停线程响应 GC 事件.</p> <p>而主动式中断的思想是当垃圾收集需要中断线程的时候, 不直接对线程操作, 仅仅简单地设置一个标志位, 各个线程执行过程时会不停地主动去轮询这个标志, 一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起. 轮询标志的地方和安全点是重合的, 另外还要加上所有创建对象和其他需要在 Java 堆上分配内存的地方, 这是为了检查是否即将要发生垃圾收集, 避免没有足够内存分配新对象.</p> <p>由于轮询操作在代码中会频繁出现, 这要求它必须足够高效. HotSpot 使用<strong>内存保护陷阱</strong>的方式, 把轮询操作精简至只有一条汇编指令的程度. 下面代码清单 3-4 中的 test 指令就是 HotSpot 生成的轮询指令, 当需要暂停用户线程时, 虚拟机把 0x160100 的内存页设置为不可读, 那线程执行到 test 指令时就会产生一个自陷异常信号, 然后在预先注册的异常处理器中挂起线程实现等待, 这样仅通过一条汇编指令便完成安全点轮询和触发线程中断了.</p> <p><strong>代码清单3-4　轮询指令</strong></p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>0x01b6d627: call   0x01b2b210          ; OopMap{[60]=Oop off=460}
                                       ; *invokeinterface size
                                       ; - Client1::main@113 (line 23)
                                       ;   {virtual_call}
    0x01b6d62c: nop                    ; OopMap{[60]=Oop off=461}
                                       ; *if_icmplt
                                       ; - Client1::main@118 (line 23)
    0x01b6d62d: test   %eax,0x160100   ;   {poll}
    0x01b6d633: mov    0x50(%esp),%esi
    0x01b6d637: cmp    %eax,%esi
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h5 id="_3-安全区域"><a href="#_3-安全区域" class="header-anchor">#</a> 3.安全区域</h5> <p>使用安全点的设计似乎已经完美<strong>解决如何停顿用户线程, 让虚拟机进入垃圾回收状态的问题</strong>了, 但实际情况却并不一定. 安全点机制保证了程序执行时, 在不太长的时间内就会遇到可进入垃圾收集过程的安全点. <strong>但程序 &quot;不执行&quot; 的时候呢</strong>? 所谓的程序不执行就是<strong>没有分配处理器时间</strong>, 典型的场景便是用户线程处于 Sleep 状态或者 Blocked 状态, <strong>这时候线程无法响应虚拟机的中断请求, 不能再走到安全的地方去中断挂起自己, 虚拟机也显然不可能持续等待线程重新被激活分配处理器时间</strong>. 对于这种情况, 就必须引入<mark><strong>安全区域</strong></mark>(Safe Region)来解决.</p> <p><mark><strong>安全区域是指能够确保在某一段代码片段之中, 引用关系不会发生变化, 因此在这个区域中任意地方开始垃圾收集都是安全的</strong></mark>. 也可以把安全区域看作被扩展<strong>拉伸了的安全点</strong>.</p> <p>当用户线程执行到安全区域里面的代码时, 首先会标识自己已经进入了安全区域, 那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了. 当线程要离开安全区域时, 它要检查虚拟机是否已经完成了根节点枚举(或者垃圾收集过程中其他需要暂停用户线程的阶段), 如果完成了, 那线程就当作没事发生过, 继续执行; 否则它就必须一直等待, 直到收到可以离开安全区域的信号为止.</p> <p>安全点是对<strong>正在执行的线程设定</strong>的. 如果一个线程处于 Sleep 或中断状态, 它就不能响应 JVM 的中断请求而运行到安全点上. 因此 JVM 引入了安全区域. 安全区域是指在一段代码片段中, <strong>引用关系不会发生变化</strong>. 在这个区域内的<strong>任意地方开始 GC 都是安全的</strong>.</p> <h5 id="_4-记忆集与卡表"><a href="#_4-记忆集与卡表" class="header-anchor">#</a> 4.记忆集与卡表</h5> <p>讲解分代收集理论的时候, 提到了为解决<strong>对象跨代引用</strong>所带来的问题, 垃圾收集器在<mark><strong>新生代中建立了名为记忆集(Remembered Set)的数据结构, 用以避免把整个老年代加进 GC Roots 扫描范围</strong></mark>. 事实上并不只是新生代, 老年代之间才有跨代引用的问题, 所有涉及部分区域收集(Partial GC)行为的垃圾收集器, 典型的如 G1, ZGC 和 Shenandoah 收集器, 都会面临相同的问题, 因此有必要进一步理清记忆集的原理和实现方式, 以便在后续章节里介绍几款最新的收集器相关知识时能更好地理解.</p> <p><strong>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构</strong>. 如果不考虑效率和成本的话, 最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构, 如代码清单 3-5 所示:</p> <blockquote><p>代码清单3-5 以对象指针来实现记忆集的伪代码</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Class</span> <span class="token class-name">RememberedSet</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> set<span class="token punctuation">[</span><span class="token constant">OBJECT_INTERGENERATIONAL_REFERENCE_SIZE</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这种记录全部含跨代引用对象的实现方案, 无论是空间占用还是维护成本都相当高昂. 而在垃圾收集的场景中, 收集器只需要通过记忆集<strong>判断出某一块非收集区域是否存在有指向了收集区域的指针</strong>就可以了, 并不需要了解这些跨代指针的全部细节. 那设计者在实现记忆集的时候, 便可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本, 下面列举了一些可供选择(当然也可以选择这个范围以外的)的记录精度:</p> <ul><li>字长精度: 每个记录精确到一个机器字长(就是处理器的寻址位数, 如常见的 32 位或 64 位, 这个精度决定了机器访问物理内存地址的指针长度), 该字包含跨代指针.</li> <li>对象精度: 每个记录精确到一个对象, 该对象里有字段含有跨代指针.</li> <li>卡精度: 每个记录精确到一块内存区域, 该区域内有对象含有跨代指针.</li></ul> <blockquote><p>使用卡表实现记忆集</p></blockquote> <p>其中, 第三种 &quot;卡精度&quot; 所指的是用一种称为 &quot;<strong>卡表</strong>&quot;(Card Table)的方式去<strong>实现记忆集</strong>, 这也是目前最常用的一种记忆集实现形式, 一些资料中甚至直接把它和记忆集混为一谈. 前面定义中提到记忆集其实是一种 &quot;抽象&quot; 的数据结构, 抽象的意思是只定义了记忆集的行为意图, 并没有定义其行为的具体实现. <mark><strong>卡表就是记忆集的一种具体实现, 它定义了记忆集的记录精度, 与堆内存的映射关系等</strong></mark>. 关于卡表与记忆集的关系, 可以按照 HashMap 与 Map 的关系来类比理解.</p> <p><strong>卡表最简单的形式可以只是一个字节数组</strong>, 而 HotSpot 虚拟机确实也是这样做的. 以下这行代码是 HotSpot 默认的卡表标记逻辑:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>CARD_TABLE [this address &gt;&gt; 9] = 0;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>字节数组 CARD_TABLE 的每一个元素都对应着其标识的内存区域中一块特定大小的内存块, 这个内存块被称作 &quot;<strong>卡页</strong>&quot;(Card Page). 一般来说, 卡页大小都是以 2 的 N 次幂的字节数, 通过上面代码可以看出 HotSpot 中使用的卡页是 2 的 9 次幂, 即 512 字节(地址右移 9 位, 相当于用地址除以 512). 那如果卡表标识内存区域的起始地址是 0x0000 的话, 数组 CARD_TABLE 的第 0, 1, 2 号元素, 分别对应了地址范围为 0x0000～0x01FF, 0x0200～0x03FF, 0x0400～0x05FF 的卡页内存块, 如下图所示.</p> <p><img src="/img/image-20240709234115-oqchz9l.png" alt="image" title="卡表与卡页对应示意图"></p> <p><mark><strong>一个卡页的内存中通常包含不止一个对象(因为一个卡页有 512 字节), 只要卡页内有一个(或更多)对象的字段存在着跨代指针, 那就将对应卡表的数组元素的值标识为 1, 称为这个元素变脏(Dirty), 没有则标识为 0. 在垃圾收集发生时, 只要筛选出卡表中变脏的元素, 就能轻易得出哪些卡页内存块中包含跨代指针, 把它们加入 GC Roots 中一并扫描</strong></mark>.</p> <p>这样的话, 只要一个卡表中的元素值为 0, 那对应的卡页就一定没有跨代指针; 如果元素值为 1, 就是存在跨代指针的.</p> <h5 id="_5-写屏障"><a href="#_5-写屏障" class="header-anchor">#</a> 5.写屏障</h5> <p>前面已经解决了如何<strong>使用记忆集来缩减 GC Roots 扫描范围的问题, 但还没有解决</strong>​<mark><strong>卡表元素如何维护的问题</strong></mark>, 例如它们何时变脏, 谁来把它们变脏等.</p> <blockquote><p>使用写屏障维护卡表状态</p></blockquote> <p>卡表元素何时变脏的答案是很明确的---<mark><strong>有其他分代区域中对象引用了本区域对象时, 其对应的卡表元素就应该变脏, 变脏时间点原则上应该发生在引用类型字段赋值的那一刻</strong></mark>. 但问题是如何变脏, 即如何在对象赋值的那一刻去更新维护卡表呢? 假如是解释执行的字节码, 那相对好处理, 虚拟机负责每条字节码指令的执行, 有充分的介入空间; 但在<strong>编译执行</strong>的场景中呢? 经过即时编译后的代码已经是纯粹的机器指令流了, 这就必须找到一个在机器码层面的手段, 把维护卡表的动作<strong>放到每一个赋值操作</strong>之中.</p> <p>在 HotSpot 虚拟机里是<mark><strong>通过写屏障(Write Barrier)技术维护卡表状态</strong></mark>的. 注意将这里提到的 &quot;写屏障&quot;, 以及后面在低延迟收集器中会提到的 &quot;读屏障&quot; 与解决并发乱序执行问题中的 &quot;内存屏障&quot; 区分开来, 避免混淆. 写屏障可以看作在虚拟机层面对 &quot;引用类型字段赋值&quot; 这个动作的 <strong>AOP 切面</strong>, 在引用对象赋值时会产生一个环形(Around)通知, 供程序执行额外的动作, 也就是说<strong>赋值的前后都在写屏障的覆盖范畴内</strong>. 在赋值前的部分的写屏障叫作写前屏障(Pre-Write Barrier), 在赋值后的则叫作写后屏障(Post-Write Barrier). HotSpot 虚拟机的许多收集器中都有使用到写屏障, 但直至 G1 收集器出现之前, 其他收集器都只用到了写后屏障. 下面这段代码清单 3-6 是一段更新卡表状态的简化逻辑:</p> <blockquote><p>代码清单3-6 写后屏障更新卡表</p></blockquote> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">oop_field_store</span><span class="token punctuation">(</span>oop<span class="token operator">*</span> field<span class="token punctuation">,</span> oop new_value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 引用字段赋值操作</span>
    <span class="token operator">*</span>field <span class="token operator">=</span> new_value<span class="token punctuation">;</span>
    <span class="token comment">// 写后屏障, 在这里完成卡表状态更新</span>
    <span class="token function">post_write_barrier</span><span class="token punctuation">(</span>field<span class="token punctuation">,</span> new_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>应用写屏障后, 虚拟机就会为所有赋值操作生成相应的指令, 一旦收集器在写屏障中增加了更新卡表操作, 无论更新的是不是老年代对新生代对象的引用, 每次只要对引用进行更新, 就会产生额外的开销</strong>, 不过这个开销与 Minor GC 时扫描整个老年代的代价相比还是低得多的.</p> <blockquote><p>伪共享问题</p></blockquote> <p>除了写屏障的开销外, 卡表在高并发场景下还面临着 &quot;<strong>伪共享</strong>&quot;(False Sharing)问题. 伪共享是处理并发底层细节时一种经常需要考虑的问题, 现代中央处理器的缓存系统中是以<strong>缓存行</strong>(Cache Line)为单位存储的, 当多线程修改互相独立的变量时, 如果这些变量恰好共享同一个缓存行, 就会彼此影响(写回, 无效化或者同步)而导致性能降低, 这就是伪共享问题.</p> <p>假设处理器的缓存行大小为 64 字节, 由于一个卡表元素占 1 个字节, 64 个卡表元素将共享同一个缓存行. 这 64 个卡表元素对应的卡页总的内存为 32KB(64×512 字节), 也就是说如果不同线程更新的对象正好处于这 32KB 的内存区域内, 就会导致更新卡表时正好写入同一个缓存行而影响性能. 为了避免伪共享问题, 一种简单的解决方案是不采用无条件的写屏障, 而是先检查卡表标记, 只有当该卡表元素未被标记过时才将其标记为变脏, 即将卡表更新的逻辑变为以下代码所示:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>CARD_TABLE <span class="token punctuation">[</span>this address <span class="token operator">&gt;&gt;</span> <span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    CARD_TABLE <span class="token punctuation">[</span>this address <span class="token operator">&gt;&gt;</span> <span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在 JDK 7 之后, HotSpot 虚拟机增加了一个新的参数 <code>-XX: +UseCondCardMark</code>​, 用来决定是否开启卡表更新的条件判断. 开启会增加一次额外判断的开销, 但能够避免伪共享问题, 两者各有性能损耗, 是否打开要根据应用实际运行情况来进行测试权衡.</p> <h5 id="_6-并发的可达性分析"><a href="#_6-并发的可达性分析" class="header-anchor">#</a> 6.并发的可达性分析</h5> <h6 id="_1-三色标记"><a href="#_1-三色标记" class="header-anchor">#</a> (1)三色标记</h6> <p>前面曾经提到了当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的, 可达性分析算法理论上要求<mark><strong>全过程都基于一个能保障一致性的快照中才能够进行分析, 这意味着必须全程冻结用户线程的运行</strong></mark>. 在根节点枚举(参考: 根节点枚举)这个步骤中, 由于 GC Roots 相比起整个 Java 堆中全部的对象毕竟还算是极少数, 且在各种优化技巧(如 OopMap)的加持下, 它带来的停顿已经是非常短暂且相对固定(不随堆容量而增长)的了. 可从 GC Roots 再继续往下遍历对象图, 这一步骤的停顿时间就必定会与 Java 堆容量直接成正比例关系了: <strong>堆越大, 存储的对象越多, 对象图结构越复杂, 要标记更多对象而产生的停顿时间自然就更长</strong>, 这听起来是理所当然的事情.</p> <p>要知道包含 &quot;标记&quot; 阶段是所有追踪式垃圾收集算法的共同特征, 如果这个阶段会随着堆变大而等比例增加停顿时间, 其影响就会波及几乎所有的垃圾收集器, 同理可知, 如果能够削减这部分停顿时间的话, 那收益也将会是系统性的.</p> <p>想解决或者降低用户线程的停顿, 就要先搞清楚<strong>为什么必须在一个能保障一致性的快照上才能进行对象图的遍历</strong>? 为了能解释清楚这个问题, 可以引入<mark><strong>三色标记</strong></mark>(Tri-color Marking) 作为工具来辅助推导, <strong>把遍历对象图过程中遇到的对象, 按照 &quot;是否访问过&quot; 这个条件标记成以下三种颜色</strong>:</p> <ul><li><mark><strong>白色: 表示对象尚未被垃圾收集器访问过</strong></mark>. 显然在可达性分析刚刚开始的阶段, <strong>所有的对象都是白色的</strong>, 若在分析结束的阶段, 仍然是白色的对象, 即代表<strong>不可达</strong>.</li> <li><mark><strong>黑色: 表示对象已经被垃圾收集器访问过, 且这个对象的所有引用都已经扫描过</strong></mark>. 黑色的对象代表<strong>已经扫描过, 它是安全存活的</strong>, 如果有其他对象引用指向了黑色对象, 无须重新扫描一遍. 黑色对象不可能直接(不经过灰色对象)指向某个白色对象.</li> <li><mark><strong>灰色: 表示对象已经被垃圾收集器访问过, 但这个对象上至少存在一个引用还没有被扫描过</strong></mark>.</li></ul> <p>关于可达性分析的扫描过程, 读者不妨发挥一下想象力, 把它看作对象图上一股以灰色为波峰的波纹从黑向白推进的过程, 如果用户线程此时是冻结的, 只有收集器线程在工作, 那不会有任何问题. 但如果<mark><strong>用户线程与收集器是并发工作</strong></mark>呢? <strong>收集器在对象图上标记颜色, 同时用户线程在修改引用关系, 即修改对象图的结构</strong>, 这样可能出现两种后果. 一种是把原本消亡的对象错误标记为存活, 这不是好事, 但其实是可以容忍的, 只不过产生了一点逃过本次收集的浮动垃圾而已, 下次收集清理掉就好. 另一种是<strong>把原本存活的对象错误标记为已消亡</strong>, 这就是非常致命的后果了, 程序肯定会因此发生错误, 下面表 3-1 演示了这样的致命错误具体是如何产生的.</p> <blockquote><p>表3-1 并发出现&quot;对象消失&quot;问题的示意</p></blockquote> <p><img src="/img/Image00026-20240302133505-rjh1sj7.jpg" alt=""></p> <p>Wilson 于 1994 年在理论上证明了, 当且仅当以下两个条件同时满足时, 会产生 &quot;<strong>对象消失</strong>&quot; 的问题, 即原本应该是黑色的对象被<strong>误标为白色</strong>:</p> <ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用;</li> <li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用.</li></ul> <h6 id="_2-增量更新与原始快照"><a href="#_2-增量更新与原始快照" class="header-anchor">#</a> (2)增量更新与原始快照</h6> <p>因此, <strong>要解决并发扫描时的对象消失问题, 只需破坏这两个条件的任意一个即可</strong>. 由此分别产生了两种解决方案: <mark><strong>增量更新(Incremental Update)和原始快照(Snapshot At The Beginning, SATB)</strong></mark> .</p> <p><strong>增量更新要破坏的是第一个条件, 当黑色对象插入新的指向白色对象的引用关系时, 就将这个新插入的引用记录下来, 等并发扫描结束之后, 再将这些记录过的引用关系中的黑色对象为根, 重新扫描一次. 这可以简化理解为, 黑色对象一旦新插入了指向白色对象的引用之后, 它就变回灰色对象了</strong>.</p> <p><strong>原始快照要破坏的是第二个条件, 当灰色对象要删除指向白色对象的引用关系时, 就将这个要删除的引用记录下来, 在并发扫描结束之后, 再将这些记录过的引用关系中的灰色对象为根, 重新扫描一次. 这也可以简化理解为, 无论引用关系删除与否, 都会按照刚刚开始扫描那一刻的对象图快照来进行搜索.</strong></p> <p>以上无论是对引用关系记录的插入还是删除, 虚拟机的记录操作都是<strong>通过写屏障实现</strong>的, 写屏障是<strong>代码级别实现</strong>的, 与 JMM 中的写屏障不一样, 这里更类似于 AOP 操作. 在 HotSpot 虚拟机中, <strong>增量更新和原始快照这两种解决方案都有实际应用</strong>, 譬如 CMS 是基于增量更新来做并发标记的, <strong>G1, Shenandoah 则是用原始快照来实现</strong>.</p> <p>到这里简要介绍了 HotSpot 虚拟机如何发起内存回收, 如何加速内存回收, 以及如何保证回收正确性等问题, 但是虚拟机如何具体地进行内存回收动作仍然未涉及. 因为内存回收如何进行是由虚拟机所采用哪一款垃圾收集器所决定的, 而通常虚拟机中往往有多种垃圾收集器, 下面将逐一介绍 HotSpot 虚拟机中出现过的垃圾收集器.</p> <h6 id="_3-写屏障"><a href="#_3-写屏障" class="header-anchor">#</a> (3)写屏障</h6> <p>给某个对象的成员变量赋值时, 其底层代码大概如下, 下面都是<strong>伪代码</strong>.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/**
 * @param field 某对象的成员变量, 如 a.b.d 
 * @param new_value 新值, 如 null
 */</span>
<span class="token keyword">void</span> <span class="token function">oop_field_store</span><span class="token punctuation">(</span>oop<span class="token operator">*</span> field<span class="token punctuation">,</span> oop new_value<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token operator">*</span>field <span class="token operator">=</span> new_value<span class="token punctuation">;</span> <span class="token comment">// 赋值操作</span>
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>所谓写屏障其实就是指在赋值操作前后, 加入一些处理(可以参考 AOP 的概念):</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">oop_field_store</span><span class="token punctuation">(</span>oop<span class="token operator">*</span> field<span class="token punctuation">,</span> oop new_value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token function">pre_write_barrier</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 写屏障-写前操作</span>
    <span class="token operator">*</span>field <span class="token operator">=</span> new_value<span class="token punctuation">;</span>               <span class="token comment">// 赋值操</span>
    <span class="token function">post_write_barrier</span><span class="token punctuation">(</span>field<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 写屏障-写后操作</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>写屏障实现SATB</p></blockquote> <p>当对象 B 的成员变量的引用发生变化时, 比如引用消失(a.b.d = null), 可以利用写屏障, 将 B 原来成员变量的引用对象 D 记录下来. SATB 是记录删掉的引用, 因此需要在删之前进行记录.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">pre_write_barrier</span><span class="token punctuation">(</span>oop<span class="token operator">*</span> field<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    oop old_value <span class="token operator">=</span> <span class="token operator">*</span>field<span class="token punctuation">;</span>    <span class="token comment">// 获取旧值</span>
    remark_set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>old_value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录原来的引用对象(加入到一个set中)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>写屏障实现增量更新</p></blockquote> <p>当对象 A 的成员变量的引用发生变化时, 比如新增引用(a.d = d), 可以利用写屏障, 将 A 新的成员变量引用对象 D 记录下来. 增量更新是记录新增的引用, 因此要在新增之后进行记录.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">post_write_barrier</span><span class="token punctuation">(</span>oop<span class="token operator">*</span> field<span class="token punctuation">,</span> oop new_value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    remark_set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 记录新引用的对象(加入到一个set中)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h6 id="_4-读屏障"><a href="#_4-读屏障" class="header-anchor">#</a> (4)读屏障</h6> <p>读屏障实现伪代码如下.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>oop <span class="token function">oop_field_load</span><span class="token punctuation">(</span>oop<span class="token operator">*</span> field<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">pre_load_barrier</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读屏障-读取前操作</span>
    <span class="token keyword">return</span> <span class="token operator">*</span>field<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>读屏障是当<strong>读取成员变量</strong>时, 一律记录下来:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">pre_load_barrier</span><span class="token punctuation">(</span>oop<span class="token operator">*</span> field<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    oop old_value <span class="token operator">=</span> <span class="token operator">*</span>field<span class="token punctuation">;</span>
    remark_set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>old_value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录读取到的对象</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h6 id="_5-总结"><a href="#_5-总结" class="header-anchor">#</a> (5)总结</h6> <p>现代<strong>追踪式(可达性分析)的垃圾回收器几乎都借鉴了三色标记的算法思想</strong>, 尽管实现的方式不尽相同: 比如白色/黑色集合一般都不会出现(但是有其他体现颜色的地方), 灰色集合可以通过栈/队列/缓存日志等方式进行实现, 遍历方式可以是广度/深度遍历等等.</p> <p>对于读写屏障, 以 HotSpot 为例, 其并发标记时对<strong>漏标</strong>的处理方案如下:</p> <ul><li>CMS: 写屏障 + 增量更新</li> <li>G1, Shenandoah: 写屏障 + SATB</li> <li>ZGC: 读屏障</li></ul> <p>工程实现中, 读写屏障还有其他功能, 比如写屏障可以用于记录跨代/区引用的变化, 读屏障可以用于支持移动对象的并发执行等. 功能之外, 还有性能的考虑, 所以对于选择哪种, 每款垃圾回收器都有自己的想法.</p> <h4 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="header-anchor">#</a> 经典垃圾收集器</h4> <h5 id="_1-基础"><a href="#_1-基础" class="header-anchor">#</a> 1.基础</h5> <p>如果说<strong>收集算法是内存回收的方法论, 那垃圾收集器就是内存回收算法的具体实现</strong>.</p> <blockquote><p>垃圾收集器概览</p></blockquote> <p>《Java 虚拟机规范》中对垃圾收集器应该如何实现并没有做出任何规定, 因此不同的厂商, 不同版本的虚拟机所包含的垃圾收集器都可能会有很大差别, 不同的虚拟机一般也都会提供各种参数供用户根据自己的应用特点和要求组合出各个内存分代所使用的收集器.</p> <p>本节标题中 &quot;经典&quot; 二字并非情怀, 它其实是<strong>讨论范围</strong>的限定语, 这里讨论的是在 JDK 7 Update 4 之后(在这个版本中正式提供了商用的 G1 收集器, 此前 G1 仍处于实验状态), JDK 11 正式发布之前, OracleJDK 中的 HotSpot 虚拟机所包含的全部可用的垃圾收集器. 使用 &quot;经典&quot; 二字是为了与几款目前仍处于实验状态, 但执行效果上有革命性改进的高性能低延迟收集器区分开来, 这些经典的收集器尽管已经算不上是最先进的技术, 但它们曾在实践中千锤百炼, 足够成熟. 各款经典收集器之间的关系如下图所示.</p> <ul><li><strong>新生代收集器</strong>: Serial, ParNew, Parallel Scavenge 收集器.</li> <li><strong>老年代收集器</strong>: Serial Old, ParNew Old, <strong>CMS 收集器</strong>.</li> <li><strong>新生代与老年代均可</strong>: <strong>G1 收集器, ZGC 等</strong>.</li></ul> <p><img src="/img/image-20230326141727-e2hy6yx.png" alt="image" title="HotSpot 虚拟机的垃圾收集器"></p> <p>这里展示了作用于不同分代的收集器, 如果<strong>两个收集器之间存在连线, 就说明它们可以搭配使用</strong>, 图中收集器所处的区域, 则表示它是<strong>属于新生代收集器或是老年代收集器</strong>. 接下来将逐一介绍这些收集器的目标, 特性, 原理和使用场景, 并重点分析 CMS 和 G1这两款相对复杂而又广泛使用的收集器, 深入了解它们的部分运作细节.</p> <p>在介绍这些收集器各自的特性之前, 先来明确一个观点: 虽然这里会对各个收集器进行比较, 但并非为了挑选一个最好的收集器出来, 虽然垃圾收集器的技术在不断进步, 但<mark><strong>直到现在还没有最好的收集器出现, 更加不存在 &quot;万能&quot; 的收集器, 所以只能根据具体应用场景选择最合适的收集器</strong></mark>. 这点不需要多加论述就能证明: 如果有一种放之四海皆准, 任何场景下都适用的完美收集器存在, HotSpot 虚拟机完全没必要实现那么多种不同的收集器了.</p> <blockquote><p>并发与并行</p></blockquote> <p>后面将会接触到若干款涉及  <strong>&quot;并发&quot; 和 &quot;并行&quot; 概念的收集器</strong>. 先解释清楚这两个名词. 并行和并发都是并发编程中的专业名词, 在谈论垃圾收集器的上下文语境中, 它们可以理解为:</p> <ul><li><mark><strong>并行(Parallel)</strong></mark>​ <strong>: 并行描述的是</strong>​<mark><strong>多条垃圾收集器线程之间</strong></mark>​<strong>的关系, 说明同一时间有多条这样的线程在协同工作, 通常默认此时用户线程是处于等待状态.</strong></li> <li><mark><strong>并发(Concurrent)</strong></mark>​ <strong>: 并发描述的是</strong>​<mark><strong>垃圾收集器线程与用户线程之间</strong></mark>​<strong>的关系, 说明同一时间垃圾收集器线程与用户线程都在运行. 由于用户线程并未被冻结, 所以程序仍然能响应服务请求, 但由于垃圾收集器线程占用了一部分系统资源, 此时应用程序的处理的吞吐量将受到一定影响.</strong></li></ul> <blockquote><p>并行与串行</p></blockquote> <ul><li><strong>串行</strong>指的是垃圾收集器与用户程序<strong>交替执行</strong>, 这意味着在执行垃圾收集的时候需要<strong>停顿用户程序</strong>.</li> <li><strong>并行</strong>指的是垃圾收集器和用户程序<strong>同时执行</strong>, 只有 <strong>CMS 和 G1 是并行</strong>执行.</li></ul> <blockquote><p>停顿时间与吞吐量的权衡</p></blockquote> <ul><li><strong>停顿时间越短就越适合需要与用户交互的程序, 良好的响应速度能提升用户体验.</strong>  使用 <strong>Parallel Scavenge 和 Parallel Old</strong> 收集器. 缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小, 垃圾回收变得频繁, 导致吞吐量下降.</li> <li><strong>高吞吐量则可以高效率地利用 CPU 时间, 尽快完成程序的运算任务, 适合在后台运算而不需要太多交互的任务.</strong>  可以使用 <strong>CMS</strong> 收集器.</li></ul> <blockquote><p>STW = Stop The World</p></blockquote> <p>STW 就是进行垃圾收集工作的时候必须暂停其他所有的<strong>工作线程</strong>.</p> <p>&quot;Stop The World&quot; 这个词语也许听起来很酷, 但这项工作是由虚拟机在后台自动发起和自动完成的, 在用户不可知, 不可控的情况下把用户的正常工作的线程全部停掉, 这对很多应用来说都是不能接受的. 对于 STW 带给用户的恶劣体验, 早期 HotSpot 虚拟机的设计者们表示完全理解, 但也同时表示非常委屈: &quot;你妈妈在给你打扫房间的时候, 肯定也会让你老老实实地在椅子上或者房间外待着, 如果她一边打扫, 你一边乱扔纸屑, 这房间还能打扫完?&quot; 这确实是一个合情合理的矛盾, 虽然垃圾收集这项工作听起来和打扫房间属于一个工种, 但实际上肯定还要比打扫房间复杂得多!</p> <p>因此, HotSpot 虚拟机开发团队<strong>为消除或者降低用户线程因垃圾收集而导致停顿的努力一直持续进行着</strong>, 从 Serial 收集器到 Parallel 收集器, 再到 Concurrent Mark Sweep(CMS)和 Garbage First(G1)收集器, 最终至现在垃圾收集器的最前沿成果 Shenandoah 和 ZGC 等, 可以看到一个个越来越构思精巧, 越来越优秀, 也越来越复杂的垃圾收集器不断涌现, 用户线程的停顿时间在持续缩短, 但是<mark><strong>仍然没有办法彻底消除</strong></mark>(这里不去讨论 RTSJ 中的收集器), 探索更优秀垃圾收集器的工作仍在继续.</p> <h5 id="_2-serial收集器"><a href="#_2-serial收集器" class="header-anchor">#</a> 2.Serial收集器</h5> <p>这个收集器是一个<strong>单线程</strong>工作的收集器, 但它的 &quot;单线程&quot; 的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作, 更重要的是强调在它<strong>进行垃圾收集时, 必须暂停其他所有工作线程(STW), 直到它收集结束</strong>.</p> <p>下图是 Serial 配合 Serial Old 一起使用的运行过程, 这里<strong>新生代采用复制算法, 老年代采用标记-整理算法.</strong></p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521141659319.png" alt="" title="Serial/Serial Old 收集器运行示意图"></p> <p>事实上, 迄今为止, 它依然是 HotSpot 虚拟机运行在客户端模式下的默认新生代收集器, 有着优于其他收集器的地方, 那就是简单而高效(与其他收集器的单线程相比), 对于<strong>内存资源受限的环境</strong>, 它是所有收集器里额外内存消耗(Memory Footprint)最小的; 对于<strong>单核处理器</strong>或处理器核心数较少的环境来说, <strong>Serial 收集器由于没有线程交互的开销, 专心做垃圾收集自然可以获得最高的单线程收集效率</strong>. 在用户桌面的应用场景以及近年来流行的部分微服务应用中, 分配给虚拟机管理的内存一般来说并不会特别大, 收集几十兆甚至一两百兆的新生代(仅仅是指新生代使用的内存, 桌面应用甚少超过这个容量), 垃圾收集的停顿时间完全可以控制在几十毫秒, 最多一百多毫秒以内, 只要不是频繁发生收集, 这点停顿时间对许多用户来说是完全可以接受的. 所以 <strong>Serial 收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择</strong>.</p> <h5 id="_3-parnew收集器"><a href="#_3-parnew收集器" class="header-anchor">#</a> 3.ParNew收集器</h5> <blockquote><p>已经退出历史舞台</p></blockquote> <p>Serial 收集器适合<strong>单 CPU</strong> 下工作, 如果有<strong>多 CPU</strong>, 那么可以考虑用 ParNew 收集器. <strong>ParNew 收集器实质上是 Serial 收集器的多线程并行版本</strong>, 除了同时使用多条线程进行垃圾收集之外, 其余的行为包括 Serial 收集器可用的所有控制参数, 其收集算法, Stop The World, 对象分配规则, 回收策略等都与 Serial 收集器<mark><strong>完全一致</strong></mark>, 在实现上这两种收集器也共用了相当多的代码. ParNew 收集器的工作过程如下图所示.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521142052614.png" alt="" title="ParNew/Serial Old 收集器运行示意图"></p> <p>ParNew 收集器除了支持多线程并行收集之外, 其他与 Serial 收集器相比并没有太多创新之处, 但它却是不少运行在<strong>服务端模式</strong>下的 HotSpot 虚拟机, 尤其是 JDK 7 之前的遗留系统中首选的新生代收集器, 其中有一个与功能, 性能无关但其实很重要的原因是: <strong>除了 Serial 收集器外, 目前只有它能与 CMS 收集器配合工作</strong>.</p> <p>可以说直到 CMS 的出现才巩固了 ParNew 的地位, 但成也萧何败也萧何, 随着垃圾收集器技术的不断改进, 更先进的 G1 收集器带着 CMS 继承者和替代者的光环登场. G1 是一个面向全堆的收集器, 不再需要其他新生代收集器的配合工作. 所以自 JDK 9 开始, ParNew 加 CMS 收集器的组合就<strong>不再是官方推荐</strong>的服务端模式下的收集器解决方案了. 官方希望它能完全被 G1 所取代, 甚至还取消了 ParNew 加 Serial Old 以及 Serial 加 CMS 这两组收集器组合的支持(其实原本也很少人这样使用), 这意味着 ParNew 和 CMS 从此只能互相搭配使用, 再也没有其他收集器能够和它们配合了. 读者也可以理解为从此以后, ParNew 合并入 CMS, 成为它专门处理新生代的组成部分. <strong>ParNew 可以说是 HotSpot 虚拟机中第一款退出历史舞台</strong>的垃圾收集器.</p> <h5 id="_4-parallel-scavenge收集器"><a href="#_4-parallel-scavenge收集器" class="header-anchor">#</a> 4.Parallel Scavenge收集器</h5> <p>与 ParNew 一样是<strong>多线程</strong>收集器. 但是主要关注<strong>吞吐量</strong>. 因此它被称为  <strong>&quot;吞吐量优先&quot;</strong>  收集器. 这里的<strong>吞吐量</strong>指 CPU 用于运行用户代码的时间占总时间的比值.</p> <blockquote><p>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)</p></blockquote> <p>如果虚拟机完成某个任务, 用户代码加上垃圾收集总共耗费了 100 分钟, 其中垃圾收集花掉 1 分钟, 那吞吐量就是 99%. <mark><strong>停顿时间越短</strong></mark>​<strong>就越适合需要与用户交互或需要保证服务响应质量的程序, 良好的响应速度能提升用户体验; 而</strong>​<mark><strong>高吞吐量</strong></mark>​<strong>则可以最高效率地利用处理器资源, 尽快完成程序的运算任务, 主要适合在后台运算而不需要太多交互的分析任务</strong>.</p> <p>下图是 Parallel Scavenge 搭配 Parallel Old, 这里<strong>新生代采用复制算法, 老年代采用标记-整理算法.</strong></p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521142336388.png" alt=""></p> <blockquote><p>吞吐量控制参数</p></blockquote> <p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量, 分别是控制最大垃圾收集停顿时间的 <code>-XX: MaxGCPauseMillis</code>​ 参数以及直接设置吞吐量大小的 <code>-XX: GCTimeRatio</code>​ 参数.</p> <ul><li>​<code>-XX: MaxGCPauseMillis</code>​ 参数是<strong>最大垃圾收集停顿时间</strong>. 收集器将尽力保证内存回收花费的时间不超过用户设定值. 不过大家<strong>不要异想天开地认为如果把这个参数的值设置得更小一点就能使得系统的垃圾收集速度变得更快</strong>, 垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的: 系统把新生代调得小一些, 收集 300MB 新生代肯定比收集 500MB 快, 但这也直接导致垃圾收集发生得更频繁, 原来 10 秒收集一次, 每次停顿 100 毫秒, 现在变成 5 秒收集一次, 每次停顿 70 毫秒. <strong>停顿时间的确在下降, 但吞吐量也降下来了</strong>.</li> <li>​<code>-XX: GCTimeRatio</code>​ 参数的值则应当是一个大于 0 小于 100 的整数, 也就是<strong>垃圾收集时间占总时间的比率</strong>, 相当于<strong>吞吐量的倒数</strong>. 譬如把此参数设置为 19, 那允许的最大垃圾收集时间就占总时间的 5% (即 1 / (1 + 19)), 默认值为 99, 即允许最大 1% (即 1 / (1 + 99)) 的垃圾收集时间.</li></ul> <p>可以通过  <strong>-XX:+UserAdaptiveSizePolicy</strong> 参数打开 GC <strong>自适应的调节策略</strong>, 就不需要手工指定新生代的大小, Eden 和 Survivor 区的比例, 晋升老年代对象年龄等细节参数了. 虚拟机会根据当前系统的运行情况收集性能监控信息, <strong>动态调整</strong>这些参数以提供最合适的停顿时间或者最大的吞吐量.</p> <h5 id="_5-serial-old收集器"><a href="#_5-serial-old收集器" class="header-anchor">#</a> 5.Serial Old收集器</h5> <p><strong>Serial Old 是 Serial 收集器的老年代版本, 它同样是一个单线程收集器, 使用标记-整理算法</strong>. 这个收集器的主要意义也是供<strong>客户端模式</strong>下的 HotSpot 虚拟机使用. 如果在服务端模式下, 它也可能有两种用途: 一种是在 JDK 5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用, 另外一种就是作为 CMS 收集器发生失败时的后备预案, 在并发收集发生 Concurrent Mode Failure 时使用. 这两点都将在后面的内容中继续讲解. Serial Old 收集器的工作过程如下图所示.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521141659319.png" alt="" title="Serial/Serial Old 收集器运行示意图"></p> <h5 id="_6-parallel-old收集器"><a href="#_6-parallel-old收集器" class="header-anchor">#</a> 6.Parallel Old收集器</h5> <p><strong>Parallel Old 是 Parallel Scavenge 收集器的老年代版本, 支持多线程并发收集, 基于标记-整理算法实现,</strong>  也是关注<strong>吞吐量</strong>.</p> <p>直到 Parallel Old 收集器出现后, &quot;<strong>吞吐量优先</strong>&quot; 收集器终于有了比较名副其实的搭配组合, <strong>在注重吞吐量或者处理器资源较为稀缺的场合, 都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器这个组合</strong>. Parallel Old 收集器的工作过程如下图所示.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521142336388.png" alt="" title="Parallel Scavenge/Parallel Old 收集器运行示意图"></p> <h5 id="_7-cms收集器"><a href="#_7-cms收集器" class="header-anchor">#</a> 7.CMS收集器</h5> <p><strong>CMS(Concurrent Mark Sweep)收集器是一种以获取</strong>​<mark><strong>最短回收停顿时间</strong></mark>​<strong>为目标的收集器</strong>. 目前很大一部分的 Java 应用集中在互联网网站或者基于浏览器的 B/S 系统的<strong>服务端</strong>上, 这类应用通常都会较为关注服务的<strong>响应速度</strong>, 希望系统停顿时间尽可能短, 以给用户带来良好的交互体验. 比如<strong>服务器尤其重视服务响应速度</strong>, 希望系统的停顿时间最短. <strong>它非常符合在注重用户体验的应用上使用, 它是 HotSpot 虚拟机第一款真正意义上的并发收集器, 它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作</strong>.</p> <p><strong>内存较小</strong>的系统可以使用: <strong>ParNew + CMS,</strong>  一般的应用场景可以用这个组合.</p> <blockquote><p>收集流程</p></blockquote> <p>从名字(包含 &quot;Mark Sweep&quot;)上就可以看出 CMS 收集器是基于<strong>标记-清除</strong>算法实现的, 它的运作过程相对于前面几种收集器来说要更复杂一些, 整个过程分为四个步骤, 包括:</p> <ul><li><strong>初始标记(STW)</strong> : 初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象, 速度<strong>很快</strong>.</li> <li><strong>并发标记</strong>: 并发标记阶段就是<strong>从 GC Roots 的直接关联对象开始遍历整个对象图的过程, 这个过程耗时较长但是不需要停顿用户线程, 可以与垃圾收集线程一起并发运行</strong>. 由于用户程序继续运行, 所以可能会有导致已经标记过的对象状态发生改变. 比如有的对象在开始并发标记的时候是存活的, 但是并发标记不会 STW, 随着用户线程释放后就变成垃圾对象了.</li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521143207389.png" alt=""></p> <ul><li><strong>重新标记(STW)</strong> : 重新标记阶段则是为了<strong>修正并发标记期间, 因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>(详见关于增量更新的讲解), 这个阶段的停顿时间通常会比初始标记阶段稍长一些, 但也远比并发标记阶段的时间短.</li> <li><strong>并发清除</strong>: 开启用户线程, 同时 GC 线程开始<strong>清理删除掉标记阶段判断的已经死亡的对象, 由于不需要移动存活对象, 所以这个阶段也是可以与用户线程同时并发的</strong>.</li></ul> <p>由于在整个过程中, 需要 STW 的地方都是耗时比较短的初始标记和重新标记阶段, 而<strong>耗时最长的并发标记和并发清除阶段中, 垃圾收集器线程都可以与用户线程一起工作而不需要停顿</strong>, 所以从总体上来说, CMS 收集器的内存回收过程是与用户线程一起并发执行的. 通过下图可以比较清楚地看到 CMS 收集器的运作步骤中并发和需要停顿的阶段.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521154058783.png" alt="" title="Concurrent Mark Sweep 收集器运行示意图"></p> <blockquote><p>CMS优缺点</p></blockquote> <p>CMS 是一款优秀的收集器, 它最主要的<strong>优点</strong>在名字上已经体现出来: <strong>并发收集, 低停顿</strong>, 一些官方公开文档里面也称之为 &quot;并发低停顿收集器&quot;(Concurrent Low Pause Collector).</p> <p>CMS 收集器是 HotSpot 虚拟机追求低停顿的第一次成功尝试, 但是它还远达不到完美的程度, 至少有<strong>以下三个明显的缺点</strong>:</p> <ul><li>首先, <strong>CMS 收集器对 CPU 资源非常敏感</strong>. 事实上, 面向并发设计的程序都对处理器资源比较敏感. 在并发阶段, 它虽然不会导致用户线程停顿, 但却会因为占用了一部分线程(或者说处理器的计算能力)而导致应用程序变慢, <strong>降低总吞吐量</strong>. CMS 默认启动的回收线程数是 (处理器核心数量 + 3) / 4, 也就是说, 如果处理器核心数在四个或以上, 并发回收时垃圾收集线程只占用不超过 25% 的处理器运算资源, 并且会随着处理器核心数量的增加而下降. 但是当处理器核心数量不足四个时, CMS 对用户程序的影响就可能变得很大. <strong>如果应用本来的处理器负载就很高, 还要分出一半的运算能力去执行收集器线程, 就可能导致用户程序的执行速度忽然大幅降低</strong>.</li> <li>然后, <strong>无法处理浮动垃圾, 从而导致执行过程存在不确定性</strong>. 由于 CMS 收集器无法处理 &quot;浮动垃圾&quot;(Floating Garbage), 有可能出现 &quot;Con-current Mode Failure&quot; 失败进而导致另一次 Full GC 的产生. 在 CMS 的并发标记和并发清理阶段, 用户线程是还在继续运行的, 程序在运行自然就还会伴随有<strong>新的垃圾</strong>对象不断产生, 但这一部分垃圾对象是出现在标记过程结束以后, CMS 无法在当次收集中处理掉它们, 只好留待下一次垃圾收集时再清理掉. 这一部分垃圾就称为 &quot;<mark><strong>浮动垃圾</strong></mark>&quot;. 同样也是由于在垃圾收集阶段用户线程还需要持续运行, 那就还需要预留足够内存空间提供给用户线程使用, 因此 CMS 收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集, 必须预留一部分空间供并发收集时的程序运作使用.</li> <li>还有最后一个缺点, CMS 是一款基于 &quot;标记-清除&quot; 算法(参考: 标记-清除算法)实现的收集器, 这意味着<strong>收集结束时可能会有大量空间碎片产生</strong>. 空间碎片过多时, 将会给大对象分配带来很大麻烦, 往往会出现老年代还有很多剩余空间, 但就是无法找到足够大的连续空间来分配当前对象, 而不得不提前触发一次 Full GC 的情况.</li></ul> <h5 id="_8-garbage-first收集器"><a href="#_8-garbage-first收集器" class="header-anchor">#</a> 8.Garbage First收集器</h5> <h6 id="_1-基础-2"><a href="#_1-基础-2" class="header-anchor">#</a> (1)基础</h6> <p>Garbage First(简称 G1)收集器是垃圾收集器技术发展历史上的里程碑式的成果, 它开创了收集器<strong>面向局部收集的设计思路和基于 Region 的内存布局形式</strong>. JDK 8 Update 40 <strong>这个版本以后的 G1 收集器才被 Oracle 官方称为 &quot;全功能的垃圾收集器&quot;(Fully-Featured Garbage Collector)</strong> .</p> <p>G1 是一款主要面向<strong>服务端应用</strong>的垃圾收集器, 主要针对配备<strong>多 CPU 及大容量内存</strong>的机器. HotSpot 开发团队最初赋予它的期望是(在比较长期的)未来可以替换掉 CMS 收集器. JDK 9 发布之日, G1 宣告取代 Parallel Scavenge 加 Parallel Old 组合, <mark><strong>成为服务端模式下的默认垃圾收集器</strong></mark>, 而 CMS 则沦落至被声明为<strong>不推荐使用</strong>(Deprecate)的收集器.</p> <p>作为 CMS 收集器的替代者和继承人, 设计者们希望做出一款能够建立起 &quot;<mark><strong>停顿时间模型</strong></mark>&quot;(Pause Prediction Model)的收集器, <strong>停顿时间模型的意思是能够支持指定在一个长度为 M 毫秒的时间片段内, 消耗在垃圾收集上的时间大概率不超过 N 毫秒这样的目标, 这几乎已经是实时 Java(RTSJ)的中软实时垃圾收集器特征了</strong>.</p> <p>那具体要怎么做才能实现这个目标呢? 首先要有一个思想上的改变, 在 G1 收集器出现之前的所有其他收集器, 包括 CMS 在内, 垃圾收集的目标范围要么是整个新生代(Minor GC), 要么就是整个老年代(Major GC), 再要么就是整个 Java 堆(Full GC). <mark><strong>而 G1 跳出了这个樊笼, 它可以面向堆内存任何部分来组成回收集(Collection Set, 一般简称 CSet)进行回收, 衡量标准不再是它属于哪个分代, 而是哪块内存中存放的垃圾数量最多, 回收收益最大, 这就是 G1 收集器的 Mixed GC 模式</strong></mark>.</p> <h6 id="_2-region"><a href="#_2-region" class="header-anchor">#</a> (2)Region</h6> <p>G1 开创的<mark><strong>基于 Region 的堆内存布局</strong></mark>是它能够实现这个目标的关键. 虽然 G1 也仍是遵循分代收集理论设计的, 但其堆内存的布局与其他收集器有非常明显的差异: <strong>G1 不再坚持固定大小以及固定数量的分代区域划分, 而是把连续的 Java 堆划分为多个大小相等的独立区域(Region), 每一个 Region 都可以根据需要, 扮演新生代的 Eden 空间, Survivor 空间, 或者老年代空间</strong>. 收集器能够对扮演不同角色的 Region 采用不同的策略去处理, 这样无论是新创建的对象还是已经存活了一段时间, 熬过多次收集的旧对象都能获取很好的收集效果.</p> <p>G1 把<strong>堆</strong>划分成多个大小相等的<strong>独立区域</strong>(Region), 新生代和老年代<strong>不再</strong>物理隔离, 各个区域是<strong>不一定连续</strong>的. 如下图所示.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521153429792.png" alt=""></p> <p>一般 <strong>Region</strong> 大小等于<strong>堆大小除以 2048(个)</strong> , 比如堆大小为 4096 M, 则 Region 大小为 2M, 当然也可以用参数 &quot;-XX:G1HeapRegionSize&quot; 手动指定 Region 大小, 推荐默认的计算方式. G1 保留了<strong>年轻代和老年代的概念</strong>, 但<strong>不再是物理隔离</strong>了, 它们都是可以不连续 Region 的集合. 默认<strong>年轻代</strong>对堆内存的占比是 <strong>5%</strong> , 如果堆大小为 4096 M, 那么年轻代占据 200MB 左右的内存, 对应大概是 100 个 Region, 可以通过 &quot;-XX:G1NewSizePercent&quot; 设置<strong>年轻代初始占比</strong>, 在系统运行中, JVM 会<strong>不停的给年轻代增加更多</strong>的 Region, 但是最多<strong>新生代的占比不会超过 60%</strong> , 可以通过 &quot;-XX:G1MaxNewSizePercent&quot; 调整. 年轻代中的 Eden 和 Survivor 对应的 region 也跟之前一样, 默认 <strong>8:1:1</strong>, 假设年轻代现在有 1000 个 region, eden 区对应 800 个, s0 对应 100 个, s1 对应 100 个.</p> <p>Region 中还有一类特殊的 <strong>Humongous 区域</strong>, 专门用来<strong>存储大对象</strong>. G1 认为只要大小超过了一个 Region 容量一半的对象即可判定为大对象. 每个 Region 的大小可以通过参数 <code>-XX: G1HeapRegionSize</code>​ 设定, 取值范围为 1MB～32MB, 且应为 2 的 N 次幂. 而对于那些超过了整个 Region 容量的超级大对象, 将会被<strong>存放在 N 个连续</strong>的 Humongous Region 之中, G1 的<strong>大多数行为都把 Humongous Region 作为老年代的一部分</strong>来进行看待.</p> <h6 id="_3-g1垃圾收集思路"><a href="#_3-g1垃圾收集思路" class="header-anchor">#</a> (3)G1垃圾收集思路</h6> <p>虽然 G1 仍然保留新生代和老年代的概念, 但新生代和老年代<strong>不再是固定</strong>的了, 它们都是一系列区域(不需要连续)的动态集合. G1 收集器之所以能建立可预测的停顿时间模型, 是因为它<strong>将 Region 作为单次回收的最小单元</strong>, 即每次收集到的内存空间都是 Region 大小的整数倍, 这样可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集. 更具体的处理思路是<mark><strong>让 G1 收集器去跟踪各个 Region 里面的垃圾堆积的 &quot;价值&quot; 大小, 价值即回收所获得的空间大小以及回收所需时间的经验值, 然后在后台维护一个优先级列表, 每次根据用户设定允许的收集停顿时间(使用参数 -XX: MaxGCPauseMillis 指定, 默认值是 200 毫秒), 优先处理回收价值收益最大的那些 Region, 这也就是 &quot;Garbage First&quot; 名字的由来</strong></mark>. 这种使用 Region 划分内存空间, 以及具有优先级的区域回收方式, 保证了 G1 收集器在有限的时间内获取尽可能高的收集效率. 比如一个 Region 花 200ms 能回收 10M 垃圾, 另外一个 Region 花 50ms 能回收 20M 垃圾, 在回收时间有限情况下, G1 当然会优先选择后面这个 Region 回收.</p> <p>G1 不管是年轻代或是老年代, <strong>回收算法主要用的是复制算法</strong>, <strong>将一个 region 中的存活对象复制到另一个 region 中, 这种不会像 CMS 那样回收完因为有很多内存碎片还需要整理一次, G1 采用复制算法回收几乎不会有太多内存碎片</strong>. 看上图觉得可能也会有很多空格, 这不算内存碎片, 因为一个 region 格子可以存放很多对象.</p> <p>从 G1 开始, <mark><strong>最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的内存分配速率(Allocation Rate), 而不追求一次把整个 Java 堆全部清理干净. 这样, 应用在分配, 同时收集器在收集, 只要收集的速度能跟得上对象分配的速度, 那一切就能运作得很完美</strong></mark>. 这种新的收集器设计思路从工程实现上看是从 G1 开始兴起的, 所以说 G1 是收集器技术发展的一个里程碑.</p> <blockquote><p>需要解决的细节问题</p></blockquote> <p>G1 将堆内存 &quot;化整为零&quot; 的 &quot;解题思路&quot;, 看起来似乎没有太多令人惊讶之处, 也完全不难理解, 但其中的实现细节可是远远没有想象中那么简单, 否则就不会用将近 10 年时间才倒腾出能够商用的 G1 收集器来. G1 收集器至少有(不限于)以下这些关键的<strong>细节问题需要妥善解决</strong>:</p> <ul><li>譬如, 将 Java 堆分成多个独立 Region 后, <strong>Region 里面存在的跨 Region 引用对象如何解决</strong>? 解决的思路已经知道: <strong>使用记忆集避免全堆作为 GC Roots 扫描</strong>, 但在 G1 收集器上记忆集的应用其实要复杂很多, 它的<strong>每个 Region 都维护有自己的记忆集</strong>, 这些记忆集会记录下别的 Region 指向自己的指针, 并标记这些指针分别在哪些卡页的范围之内. G1 的记忆集在存储结构的本质上是一种哈希表, Key 是别的 Region 的起始地址, Value 是一个集合, 里面存储的元素是卡表的索引号. 这种 &quot;双向&quot; 的卡表结构(卡表是 &quot;我指向谁&quot;, 这种结构还记录了 &quot;谁指向我&quot;)比原来的卡表实现起来更复杂, 同时由于 Region 数量比传统收集器的分代数量明显要多得多, 因此 G1 收集器要比其他的传统垃圾收集器有着<strong>更高的内存占用负担</strong>. 根据经验, <strong>G1 至少要耗费大约相当于 Java 堆容量 10% 至 20% 的额外内存来维持收集器工作</strong>.</li> <li>譬如, <strong>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行</strong>? 这里首先要解决的是<strong>用户线程改变对象引用关系时, 必须保证其不能打破原本的对象图结构, 导致标记结果出现错误</strong>, 该问题的解决办法前面讲解过: CMS 收集器采用增量更新算法实现, 而 G1 收集器则是通过<strong>原始快照(SATB)算法</strong>来实现的. 此外, 垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上, 程序要继续运行就肯定会持续有新对象被创建, G1 为每一个 Region 设计了两个名为 TAMS(Top at Mark Start)的指针, 把 Region 中的一部分空间划分出来用于并发回收过程中的新对象分配, 并发回收时新分配的对象地址都必须要在这两个指针位置以上. G1 收集器默认在这个地址以上的对象是被隐式标记过的, 即默认它们是存活的, 不纳入回收范围. 与 CMS 中的 &quot;Concurrent Mode Failure&quot; 失败会导致 Full GC 类似, 如果内存回收的速度赶不上内存分配的速度, G1 收集器也要被迫冻结用户线程执行, 导致 Full GC 而产生长时间 STW.</li> <li>譬如, <strong>怎样建立起可靠的停顿预测模型</strong>? 用户通过 <code>-XX: MaxGCPauseMillis</code>​ 参数指定的停顿时间只意味着垃圾收集发生之前的期望值, 但 G1 收集器要怎么做才能满足用户的期望呢? G1 收集器的停顿预测模型是<strong>以衰减均值(Decaying Average)为理论基础</strong>来实现的, 在垃圾收集过程中, G1 收集器会<strong>记录每个 Region 的回收耗时, 每个 Region 记忆集里的脏卡数量等各个可测量的步骤花费的成本, 并分析得出平均值, 标准偏差, 置信度等统计信息</strong>. 这里强调的 &quot;衰减平均值&quot; 是指它会比普通的平均值更容易受到新数据的影响, 平均值代表整体平均状态, 但衰减平均值更准确地代表 &quot;最近的&quot; 平均状态. 换句话说, Region 的统计状态越新越能决定其回收的价值. 然后通过这些信息预测现在开始回收的话, 由哪些 Region 组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益.</li></ul> <h6 id="_4-收集流程"><a href="#_4-收集流程" class="header-anchor">#</a> (4)收集流程</h6> <p>如果不去计算用户线程运行过程中的动作(如使用写屏障维护记忆集的操作), G1 收集器的运作过程大致可划分为以下四个步骤, 前几个步骤与 CMS 收集器类似, 主要区别在于<strong>第四步</strong>:</p> <ul><li><mark><strong>初始标记(短暂STW)</strong></mark> : 仅仅只是<strong>标记一下 GC Roots 能直接关联到的对象</strong>, 并且修改 TAMS 指针的值, 让下一阶段用户线程并发运行时, 能正确地在可用的 Region 中分配新对象. 这个阶段<strong>需要停顿线程, 但耗时很短</strong>, 而且是借用进行 Minor GC 的时候同步完成的, 所以 G1 收集器在这个阶段实际并没有额外的停顿.</li> <li><mark><strong>并发标记</strong></mark>: 从 GC Root 开始对堆中对象进行<strong>可达性分析</strong>, 递归扫描整个堆里的对象图, 找出要回收的对象, 这阶段<strong>耗时较长, 但可与用户程序并发执行</strong>. 当对象图扫描完成以后, 还要重新处理 SATB 记录下的在并发时有引用变动的对象.</li> <li><mark><strong>最终标记(短暂STW)</strong></mark> : 对用户线程做另一个<strong>短暂的暂停</strong>, 用于处理并发阶段结束后仍<strong>遗留下来的最后那少量的 SATB 记录</strong>.</li> <li><mark><strong>筛选回收(STW)</strong></mark> : 负责<strong>更新 Region 的统计数据</strong>, 对各个 Region 的<mark><strong>回收价值和成本进行排序</strong></mark>, 根据用户所期望的停顿时间来制定回收计划, 可以自由选择任意多个 Region 构成回收集, 然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中, 再清理掉整个旧 Region 的全部空间. 这里的操作<strong>涉及存活对象的移动, 是必须暂停用户线程, 由多条收集器线程并行完成的</strong>. 这里会根据用户所期望的 GC <strong>停顿 STW 时间(用参数 -XX:MaxGCPauseMillis 指定)</strong>  来制定回收计划. 比如老年代有 1000 个 Region 都满了, 但是根据预期设置的停顿时间, 本次垃圾回收可能<strong>只能停顿 200 毫秒</strong>, 那么通过之前回收成本计算得知回收其中 800 个 Region 刚好需要 200ms, 那么就只会回收 800 个 Region, 尽量把 GC 导致的停顿时间控制在<strong>指定的范围内</strong>.</li></ul> <p>从上述阶段的描述可以看出, <strong>G1 收集器除了并发标记外, 其余阶段也是要完全暂停用户线程的</strong>, 换言之, 它并非纯粹地追求低延迟, 官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量, 所以才能担当起 &quot;全功能收集器&quot; 的重任与期望.</p> <p>从 Oracle 官方透露出来的信息可获知, 回收阶段(Evacuation)其实本也有想过设计成与用户程序一起并发执行, 但这件事情做起来比较复杂, 考虑到 G1 只是回收一部分 Region, 停顿时间是用户可控制的, 所以并不迫切去实现, 而选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器(即 ZGC)中. 另外, 还考虑到 G1 不是仅仅面向低延迟, 停顿用户线程能够最大幅度提高垃圾收集效率, 为了保证吞吐量所以才选择了完全暂停用户线程的实现方案. 通过下图可以比较清楚地看到 G1 收集器的运作步骤中并发和需要停顿的阶段.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521154201453.png" alt="" title="G1收集器运行示意图"></p> <h6 id="_5-停顿时间的设置"><a href="#_5-停顿时间的设置" class="header-anchor">#</a> (5)停顿时间的设置</h6> <p>毫无疑问, 可以由用户指定期望的停顿时间是 G1 收集器很强大的一个功能, <strong>设置不同的期望停顿时间, 可使得 G1 在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡</strong>. 不过, 这里设置的 &quot;期望值&quot; 必须是<strong>符合实际</strong>的, 不能异想天开, 毕竟 G1 是要冻结用户线程来复制对象的, 这个停顿时间再怎么低也得有个限度. 它<strong>默认的停顿目标为两百毫秒</strong>, 一般来说, 回收阶段占到几十到一百甚至接近两百毫秒都很正常, 但如果把停顿时间调得非常低, 譬如设置为二十毫秒, 很可能出现的结果就是由于停顿目标时间太短, 导致每次选出来的回收集只占堆内存很小的一部分, 收集器收集的速度逐渐跟不上分配器分配的速度, 导致垃圾慢慢堆积. 很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间, 但应用运行时间一长就不行了, 最终占满堆引发 Full GC 反而降低性能, 所以<mark><strong>通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的</strong></mark>.</p> <p><strong>核心在于调节 -XX:MaxGCPauseMills(期望停顿时间) 参数的值</strong>, 需要保证<strong>年轻代 GC 别太频繁</strong>的同时, 还得考虑每次 GC 过后的存活对象有多少, 避免存活对象太多快速进入老年代, <strong>频繁触发 Mixed GC</strong>.</p> <p>假设参数 -<strong>XX:MaxGCPauseMills</strong> 设置的<strong>很大</strong>, 导致系统运行很久, 年轻代可能都占用了堆内存的 60%了, 此时才触发年轻代 GC. 那么存活下来的对象可能就会<strong>很多</strong>, 此时就会导致 Survivor 区域放不下那么多的对象, 就会进入<strong>老年代</strong>中. 或者是年轻代 GC 过后, 存活下来的对象过多, 导致进入 Survivor 区域后触发了动态年龄判定规则, 达到了 Survivor 区域的 50%, 也会快速导致一些对象进入老年代中. 但是 -<strong>XX:MaxGCPauseMills</strong> 也不能设置的很小, 因为很小的情况下会导致每次 GC 可以清理的对象太少, 久而久之可能就触发 Full GC 了.</p> <h6 id="_6-g1的优缺点"><a href="#_6-g1的优缺点" class="header-anchor">#</a> (6)G1的优缺点</h6> <p>G1 收集器常会被拿来与 CMS 收集器互相比较, 毕竟它们都非常关注停顿时间的控制, 官方资料中将它们两个并称为 &quot;The Mostly Concurrent Collectors&quot;. 在未来, G1 收集器最终还是要取代 CMS 的, 而当下它们两者并存的时间里, 分个高低优劣就无可避免.</p> <p>相比 CMS, G1 的优点有很多, 暂且不论可以指定最大停顿时间, 分 Region 的内存布局, 按收益动态确定回收集这些创新性设计带来的红利, 单从最传统的算法理论上看, G1 也更有发展潜力. 与 CMS 的 &quot;标记-清除&quot; 算法不同, <mark><strong>G1 从整体来看是基于 &quot;标记-整理&quot; 算法实现的收集器, 但从局部(两个 Region 之间)上看又是基于 &quot;标记-复制&quot; 算法实现</strong></mark>, 无论如何, 这两种算法都意味着 G1 运作期间<mark><strong>不会产生内存空间碎片</strong></mark>, 垃圾收集完成之后能提供规整的可用内存. 这种特性有利于程序长时间运行, 在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集.</p> <p>不过, G1 相对于 CMS 仍然不是占全方位, 压倒性优势的, 从它出现几年仍不能在所有应用场景中代替 CMS 就可以得知这个结论. 比起 CMS, G1 的弱项也可以列举出不少, 如在用户程序运行过程中, G1 无论是<strong>为了垃圾收集产生的内存占用(Footprint)还是程序运行时的额外执行负载(Overload)都要比 CMS 要高</strong>.</p> <ul><li><strong>G1 内存占用更大</strong>: 虽然 G1 和 CMS 都使用卡表来处理跨代指针, 但 G1 的卡表实现更为复杂, 而且堆中每个 Region, 无论扮演的是新生代还是老年代角色, 都<strong>必须有一份卡表, 这导致 G1 的记忆集(和其他内存消耗)可能会占整个堆容量的 20% 乃至更多的内存空间</strong>; 相比起来 CMS 的卡表就相当简单, 只有唯一一份, 而且只需要处理老年代到新生代的引用, 反过来则不需要, 由于新生代的对象具有朝生夕灭的不稳定性, 引用变化频繁, 能省下这个区域的维护开销是很划算的.</li> <li><strong>G1 执行负载更高</strong>: 在执行负载的角度上, 同样由于两个收集器各自的细节实现特点导致了用户程序运行时的负载会有不同, 譬如它们都使用到<strong>写屏障</strong>, CMS 用写后屏障来更新维护卡表; 而 G1 除了使用写后屏障来进行同样的(由于 G1的卡表结构复杂, 其实是更烦琐的)卡表维护操作外, 为了实现原始快照搜索(SATB)算法, 还需要使用写前屏障来跟踪并发时的指针变化情况. 相比起增量更新算法, 原始快照搜索能够减少并发标记和重新标记阶段的消耗, 避免 CMS 那样在最终标记阶段停顿时间过长的缺点, 但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担. 由于 G1 对写屏障的复杂操作要比 CMS 消耗更多的运算资源, 所以 CMS 的写屏障实现是直接的同步操作, 而 G1 就不得不将其实现为类似于消息队列的结构, 把写前屏障和写后屏障中要做的事情都放到队列里, 然后再异步处理.</li></ul> <p>以上的优缺点对比仅仅是针对 G1和 CMS 两款垃圾收集器单独某方面的实现细节的定性分析, 通常大家说哪款收集器要更好, 要好上多少, 往往是针对<strong>具体场景</strong>才能做的定量比较. 按照笔者的实践经验, 目前<mark><strong>在小内存应用上 CMS 的表现大概率仍然要会优于 G1, 而在大内存应用上 G1则大多能发挥其优势, 这个优劣势的 Java 堆容量平衡点通常在 6GB 至 8GB 之间</strong></mark>, 当然, 以上这些也仅是经验之谈, 不同应用需要量体裁衣地实际测试才能得出最合适的结论, 随着 HotSpot 的开发者对 G1 的不断优化, 也会让对比结果继续向 G1 倾斜.</p> <h6 id="_7-参数设置"><a href="#_7-参数设置" class="header-anchor">#</a> (7)参数设置</h6> <p>可配置的虚拟机参数如下:</p> <ul><li>-XX: <strong>+UseG1GC</strong>: 使用 G1 收集器.</li> <li>-XX:<strong>ParallelGCThreads</strong>: 指定 GC 工作的<strong>线程数量</strong>.</li> <li>-XX:G1HeapRegionSize: 指定 Region 大小(1MB ~ 32MB, 且必须是 2 的幂), 默认将整堆划分为 2048 个 region.</li> <li>-<strong>XX:MaxGCPauseMillis</strong>: <strong>目标暂停时间</strong>(默认 <strong>200ms</strong>).</li> <li>-XX:G1NewSizePercent: 新生代内存初始空间(默认整堆 5%).</li> <li>-XX:G1MaxNewSizePercent: 新生代内存最大空间.</li> <li>-XX:TargetSurvivorRatio: Survivor 区的填充容量(默认 50%), Survivor 区域里的一批对象(年龄1 + 年龄2 + 年龄n 的多个年龄对象)总和超过了 Survivor 区域的 50%, 此时就会把年龄 n (含)以上的对象都放入老年代.</li> <li>-XX:MaxTenuringThreshold: 最大年龄阈值(默认 15).</li> <li>-XX:InitiatingHeapOccupancyPercent: 老年代占用空间达到整堆内存阈值(默认 45%), 则执行新生代和老年代的混合收集(<strong>MixedGC</strong>), 比如堆默认有 2048 个 Region, 如果有接近 1000 个 Region 都是老年代的, 则可能就要触发 MixedGC.</li> <li>-XX:G1HeapWastePercent(默认 5%): GC 过程中空出来的 region 是否充足阈值, 在混合回收的时候, 对 Region 回收都是基于复制算法进行的, 都是把要回收的 Region 里的存活对象放入其他 Region, 然后这个 Region 中的垃圾对象全部清理掉, 这样的话在回收过程就会不断空出来新的 Region, 一旦空闲出来的 Region 数量达到了堆内存的 5%, 此时就会立即停止混合回收, 意味着本次混合回收就结束了.</li> <li>-XX:G1MixedGCLiveThresholdPercent(默认85%): Region 中的存活对象低于这个值时才会回收该 Region, 如果超过这个值, 存活对象过多, 回收的意义不大.</li> <li>-XX:G1MixedGCCountTarget: 在一次回收过程中指定做几次筛选回收(默认 8 次), 在最后一个筛选回收阶段可以回收一会, 然后暂停回收, 恢复系统运行, 一会再开始回收, 这样可以让系统不至于单次停顿时间过长.</li></ul> <h6 id="_8-g1垃圾收集类型"><a href="#_8-g1垃圾收集类型" class="header-anchor">#</a> (8)G1垃圾收集类型</h6> <ul><li><p><strong>Young GC</strong>: Young GC 并不是说现有的 Eden 区放满了就会马上触发, G1 会计算下现在 Eden 区回收大概要多久时间, 如果回收时间远远小于参数 -XX:MaxGCPauseMills 设定的值, 那么<strong>增加年轻代的 region</strong>, 继续存放新对象, 不会马上做 Young GC, <strong>直到下一次 Eden 区放满</strong>. 当计算回收时间接近参数 -<strong>XX:MaxGCPauseMills</strong> 设定的值, 那么就会触发 Young GC.</p></li> <li><p><strong>Mixed GC</strong>: 不是 Full GC, 老年代的堆占有率达到参数( <strong>-XX:InitiatingHeapOccupancyPercent</strong>) 设定的值则触发, 回收<strong>所有的 Young 和部分 Old</strong>(根据期望的 GC 停顿时间确定 old 区垃圾收集的优先顺序)以及大对象区, 正常情况 G1 的垃圾收集是先做 <strong>Mixed GC</strong>, 主要使用<strong>复制算法</strong>, 需要把各个 region 中存活的对象拷贝到别的 region 里去, 拷贝过程中如果发现<strong>没有足够的空 region</strong> 能够承载拷贝对象就会触发一次 Full GC. 大对象也会在 Mixed GC 中回收.</p></li> <li><p><strong>Full GC</strong>: 停止<strong>系统程序</strong>, 然后采用单线程进行标记, 清理和压缩整理, 好空闲出来一批 Region 来供下一次 Mixed GC 使用, 这个过程非常耗时.</p></li></ul> <h6 id="_9-g1应用场景与示例"><a href="#_9-g1应用场景与示例" class="header-anchor">#</a> (9)G1应用场景与示例</h6> <blockquote><p>什么场景适合使用G1?</p></blockquote> <ol><li>50% 以上的堆被<strong>存活对象</strong>占用.</li> <li>对象分配和晋升的<strong>速度变化</strong>非常大.</li> <li>垃圾回收<strong>时间特别长</strong>, 超过 1 秒.</li> <li>8GB 以上的<strong>堆内存</strong>(建议值), 即<strong>大内存</strong>下.</li> <li>停顿时间是 <strong>500ms 以内</strong>.</li></ol> <p>对于 Kafka 这种高并发消息的系统来说, <strong>每秒处理几万甚至几十万消息</strong>是很正常的, 一般部署 Kafka 需要用<strong>大内存机器</strong>(比如 64G), 也就是说可以给年轻代分配三四十 G 的内存用来支撑高并发处理. 这里就涉及到一个问题, 之前说对于 eden 区的 Young GC 是<strong>很快</strong>的, 这种情况下它的执行还会很快吗? 很显然不可能, 因为内存太大, 处理还是要花不少时间的, 假设三四十 G 内存回收可能最快也要<strong>几秒钟</strong>, 按 Kafka 这个<strong>并发量放满三四十 G 的 eden 区可能也就一两分钟</strong>, 那么意味着整个系统<strong>每运行一两分钟就会因为 Young GC 卡顿几秒钟</strong>没法处理新消息, 这显然不行. 这种情况可以使用 G1 收集器, 设置 -<strong>XX:MaxGCPauseMills</strong> 为 <strong>50ms</strong>, 假设 50ms 能够回收三到四个 G 内存, 然后 50ms 的卡顿完全能够接受, 用户几乎无感知, 那么整个系统就可以在卡顿几乎无感知的情况下<strong>一边处理业务一边收集垃圾</strong>.</p> <p><strong>G1 天生就适合这种大内存机器的 JVM 运行, 可以比较完美的解决大内存垃圾回收时间过长的问题. 如果用 CMS 这种收集器的话, 在大内存下由于需要处理的内存太大而导致 STW 的时间可能会很长.</strong></p> <h4 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="header-anchor">#</a> 低延迟垃圾收集器</h4> <p>HotSpot 的垃圾收集器从 Serial 发展到 CMS 再到 G1, 经历了逾二十年时间, 经过了数百上千万台服务器上的应用实践, 已经被淬炼得相当成熟了, 不过它们距离 &quot;完美&quot; 还是很遥远. 怎样的收集器才算是 &quot;完美&quot; 呢? 这听起来像是一道主观题, 其实不然, 完美难以实现, 但是确实可以把它客观描述出来.</p> <blockquote><p>衡量垃圾收集器的指标</p></blockquote> <p>衡量垃圾收集器的三项最重要的指标是: <mark><strong>内存占用(Footprint), 吞吐量(Throughput)和延迟(Latency)</strong></mark> , 三者共同构成了一个 &quot;<strong>不可能三角</strong>&quot;. 三者总体的表现会随技术进步而越来越好, 但是要在这三个方面同时具有卓越表现的 &quot;完美&quot; 收集器是极其困难甚至是不可能的, 一款优秀的收集器<strong>通常最多可以同时达成其中的两项</strong>. (这不就类似 CAP?)</p> <p>在内存占用, 吞吐量和延迟这三项指标里, <mark><strong>延迟的重要性日益凸显, 越发备受关注</strong></mark>. 其原因是随着计算机硬件的发展, 性能的提升, 大家越来越能容忍收集器多占用一点内存; 硬件性能增长, 对软件系统的处理能力是有直接助益的, 硬件的规格和性能越高, 也有助于降低收集器运行时对应用程序的影响, 换句话说, 吞吐量会更高. 但对延迟则不是这样, 硬件规格提升, 准确地说是内存的扩大, 对延迟反而会带来负面的效果, 这点也是很符合直观思维的: 虚拟机要回收完整的 1TB 的堆内存, 毫无疑问要比回收 1GB 的堆内存耗费更多时间. 由此就不难理解为何延迟会成为垃圾收集器最被重视的性能指标了. 现在来观察一下<strong>现在已接触过的垃圾收集器的停顿状况</strong>, 如下图所示.</p> <p><img src="/img/Image00036-20240302133505-tx3ykyv.jpg" alt="" title="各款收集器的并发情况"></p> <p>图中<strong>浅色阶段表示必须挂起用户线程, 深色表示收集器线程与用户线程是并发工作的</strong>. 由图可见, 在 CMS 和 G1 之前的全部收集器, 其工作的所有步骤都会产生 STW 式的停顿; CMS 和 G1 分别使用<strong>增量更新和原始快照</strong>技术, 实现了标记阶段的并发, 不会因管理的堆内存变大, 要标记的对象变多而导致停顿时间随之增长. 但是对于标记阶段之后的处理, 仍未得到妥善解决. CMS 使用标记-清除算法, 虽然避免了整理阶段收集器带来的停顿, 但是清除算法不论如何优化改进, 在设计原理上避免不了空间碎片的产生, 随着空间碎片不断淤积最终依然逃不过 STW 的命运. G1 虽然可以按更小的粒度进行回收, 从而抑制整理阶段出现时间过长的停顿, 但毕竟也还是要暂停的.</p> <p><strong>最后的两款收集器, Shenandoah 和 ZGC, 几乎整个工作过程全部都是并发的</strong>, 只有初始标记, 最终标记这些阶段有短暂的停顿, 这部分停顿的时间基本上是固定的, 与堆的容量, 堆中对象的数量没有正比例关系. 实际上, 它们都可以在任意可管理的(譬如现在 ZGC 只能管理 4TB 以内的堆)堆容量下, 实现垃圾收集的停顿都不超过十毫秒这种以前听起来是天方夜谭, 匪夷所思的目标. 这两款目前仍处于<strong>实验状态</strong>的收集器, 被官方命名为 &quot;<strong>低延迟垃圾收集器</strong>&quot;(Low-Latency Garbage Collector 或者 Low-Pause-Time Garbage Collector).</p> <h5 id="_1-shenandoah收集器"><a href="#_1-shenandoah收集器" class="header-anchor">#</a> 1.Shenandoah收集器</h5> <p>在本书所出现的众多垃圾收集器里, Shenandoah 大概是最 &quot;<strong>孤独</strong>&quot; 的一个. 现代社会竞争激烈, 连一个公司里不同团队之间都存在 &quot;部门墙&quot;, 那 Shenandoah 作为第一款不由 Oracle(包括以前的 Sun)公司的虚拟机团队所领导开发的 HotSpot 垃圾收集器, 不可避免地会受到一些来自 &quot;官方&quot; 的排挤. 如果读者的项目要求用到 Oracle 商业支持的话, 就不得不把 Shenandoah 排除在选择范围之外了.</p> <p>从代码历史渊源上讲, 比起稍后要介绍的有着 Oracle 正朔血统的 ZGC, <strong>Shenandoah 反而更像是 G1 的下一代继承者, 它们两者有着相似的堆内存布局, 在初始标记, 并发标记等许多阶段的处理思路上都高度一致, 甚至还直接共享了一部分实现代码</strong>, 这使得部分对 G1 的打磨改进和 Bug 修改会同时反映在 Shenandoah 之上, 而由于 Shenandoah 加入所带来的一些新特性, 也有部分会出现在 G1 收集器中, 譬如在并发失败后作为 &quot;逃生门&quot; 的 Full GC, G1 就是由于合并了 Shenandoah 的代码才获得多线程 Full GC 的支持.</p> <p>那 Shenandoah 相比起 G1 又有什么改进呢? 虽然 Shenandoah 也是使用基于 Region 的堆内存布局, 同样有着用于存放大对象的 Humongous Region, 默认的回收策略也同样是优先处理回收价值最大的 Region... 但在管理堆内存方面, 它<strong>与 G1 至少有三个明显的不同之处</strong>, 最重要的当然是<strong>支持并发的整理算法</strong>, G1 的回收阶段是可以多线程并行的, 但却不能与用户线程并发, 这点作为 Shenandoah 最核心的功能稍后笔者会着重讲解. 其次, <strong>Shenandoah(目前)是默认不使用分代收集的</strong>, 换言之, 不会有专门的新生代 Region 或者老年代 Region 的存在, 没有实现分代, 并不是说分代对 Shenandoah 没有价值, 这更多是出于性价比的权衡, 基于工作量上的考虑而将其放到优先级较低的位置上. 最后, <strong>Shenandoah 摒弃了在 G1 中耗费大量内存和计算资源去维护的记忆集, 改用名为 &quot;连接矩阵&quot;(Connection Matrix)的全局数据结构来记录跨 Region 的引用关系</strong>, 降低了处理跨代指针时的记忆集维护消耗, 也降低了伪共享问题的发生概率. 连接矩阵可以简单理解为一张二维表格, 如果 Region N 有对象指向 Region M, 就在表格的 N 行 M 列中打上一个标记, 如下图所示, 如果 Region 5 中的对象 Baz 引用了 Region 3 的 Foo, Foo 又引用了 Region 1 的 Bar, 那连接矩阵中的 5 行 3 列, 3 行 1 列就应该被打上标记. 在回收时通过这张表格就可以得出哪些 Region 之间产生了跨代引用.</p> <p><img src="/img/Image00037-20240302133505-vc23akl.jpg" alt="" title="Shenandoah 收集器的连接矩阵示意图"></p> <p>Shenandoah 收集器的工作过程大致可以划分为以下<strong>九个阶段</strong>:</p> <ul><li><strong>初始标记</strong>: 与 G1 一样, 首先标记与 GC Roots 直接关联的对象, 这个阶段仍是 &quot;<strong>Stop The World</strong>&quot; 的, 但停顿时间与堆大小无关, 只与 GC Roots 的数量相关.</li> <li><strong>并发标记</strong>: 与 G1 一样, 遍历对象图, 标记出全部可达的对象, 这个阶段是<strong>与用户线程一起并发的</strong>, 时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度.</li> <li><strong>最终标记</strong>: 与 G1 一样, <strong>处理剩余的 SATB 扫描</strong>, 并在这个阶段统计出回收价值最高的 Region, 将这些 Region 构成一组回收集(Collection Set). 最终标记阶段也会有一<strong>小段短暂的停顿</strong>.</li> <li><strong>并发清理</strong>: 这个阶段用于清理那些整个区域内连一个存活对象都没有找到的 Region(这类 Region 被称为 Immediate Garbage Region).</li> <li><strong>并发回收</strong>: 并发回收阶段是 Shenandoah 与之前 HotSpot 中其他收集器的<strong>核心差异</strong>. 在这个阶段, Shenandoah 要把回收集里面的存活对象先复制一份到其他未被使用的 Region 之中. 复制对象这件事情如果将用户线程冻结起来再做那是相当简单的, 但如果两者必须要同时<strong>并发进行</strong>的话, 就变得复杂起来了. 其困难点是在移动对象的同时, 用户线程仍然可能不停对被移动的对象进行读写访问, 移动对象是一次性的行为, 但移动之后整个内存中所有指向该对象的引用都还是旧对象的地址, 这是很难一瞬间全部改变过来的. 对于并发回收阶段遇到的这些困难, Shenandoah 将会通过读屏障和被称为 &quot;Brooks Pointers&quot; 的转发指针来解决(讲解完 Shenandoah 整个工作过程之后还要再回头介绍它). 并发回收阶段运行的时间长短取决于回收集的大小.</li> <li><strong>初始引用更新</strong>: 并发回收阶段复制对象结束后, 还需要把堆中所有指向旧对象的引用修正到复制后的新地址, 这个操作称为引用更新. 引用更新的初始化阶段实际上并未做什么具体的处理, 设立这个阶段只是为了建立一个线程集合点, 确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务而已. 初始引用更新时间很短, 会产生一个非常短暂的停顿.</li> <li><strong>并发引用更新</strong>: 真正开始进行引用更新操作, 这个阶段是与用户线程一起并发的, 时间长短取决于内存中涉及的引用数量的多少. 并发引用更新与并发标记不同, 它不再需要沿着对象图来搜索, 只需要按照内存物理地址的顺序, 线性地搜索出引用类型, 把旧值改为新值即可.</li> <li><strong>最终引用更新</strong>: 解决了堆中的引用更新后, 还要修正存在于 GC Roots 中的引用. 这个阶段是 Shenandoah 的最后一次停顿, 停顿时间只与 GC Roots 的数量相关.</li> <li><strong>并发清理</strong>: 经过并发回收和引用更新之后, 整个回收集中所有的 Region 已再无存活对象, 这些 Region 都变成 Immediate Garbage Regions 了, 最后再调用一次并发清理过程来回收这些 Region 的内存空间, 供以后新对象分配使用.</li></ul> <p>以上对 Shenandoah 收集器这九个阶段的工作过程的描述可能拆分得略为琐碎, 只要抓住其中<strong>三个最重要</strong>的并发阶段(<strong>并发标记, 并发回收, 并发引用更新</strong>), 就能比较容易理清 Shenandoah 是如何运作的了. 下图中黄色的区域代表的是被选入回收集的 Region, 绿色部分就代表还存活的对象, 蓝色就是用户线程可以用来分配对象的内存 Region 了. 图中不仅展示了 Shenandoah 三个并发阶段的工作过程, 还能形象地表示出并发标记阶段如何找出回收对象确定回收集, 并发回收阶段如何移动回收集中的存活对象, 并发引用更新阶段如何将指向回收集中存活对象的所有引用全部修正, 此后回收集便不存在任何引用可达的存活对象了.</p> <p><img src="/img/Image00038-20240302133505-8xbb7b4.jpg" alt="" title="Shenandoah 收集器的工作过程"></p> <h5 id="_2-zgc收集器"><a href="#_2-zgc收集器" class="header-anchor">#</a> 2.ZGC收集器</h5> <h6 id="_1-基础-3"><a href="#_1-基础-3" class="header-anchor">#</a> (1)基础</h6> <p>ZGC(&quot;Z&quot; 并非什么专业名词的缩写, 这款收集器的名字就叫作 Z Garbage Collector)是一款在 JDK 11 中新加入的具有实验性质的低延迟垃圾收集器, 是由 Oracle 公司研发的. 2018 年 Oracle 创建了 JEP 333 将 ZGC 提交给 OpenJDK, 推动其进入 OpenJDK 11 的发布清单之中.</p> <p>ZGC 和 Shenandoah 的目标是高度相似的, 都希望在尽可能<strong>对吞吐量影响不太大</strong>的前提下, 实现在<strong>任意堆内存大小</strong>下都可以把垃圾收集的停顿时间限制在<strong>十毫秒以内</strong>的低延迟. 这里给 ZGC 下一个这样的定义来概括它的主要特征: <mark><strong>ZGC 收集器是一款基于 Region 内存布局的, (暂时)不设分代的, 使用了读屏障, 染色指针和内存多重映射等技术来实现可并发的标记-整理算法的, 以低延迟为首要目标的一款垃圾收集器</strong></mark>. 接下来将逐项来介绍 ZGC 的这些技术特点.</p> <p>ZGC 的目标主要有:</p> <ul><li>支持 TB 量级的堆.</li> <li>GC 停顿时间极低, 可以低至 10ms 量级.</li> <li><strong>GC 停顿时间不会随内存空间增大而增大</strong>. 这个是很猛的特性.</li></ul> <h6 id="_2-zgc的region与内存布局"><a href="#_2-zgc的region与内存布局" class="header-anchor">#</a> (2)ZGC的Region与内存布局</h6> <p>首先从 ZGC 的<strong>内存布局</strong>说起. 与 Shenandoah 和 G1 一样, ZGC 也采用<strong>基于 Region 的堆内存布局</strong>, 但与它们不同的是, ZGC 的 Region(在一些官方资料中将它称为 Page 或者 <strong>ZPage</strong>, 本章为行文一致继续称为 Region)具有**动态性--**​<mark><strong>动态创建和销毁, 以及动态的区域容量大小</strong></mark>. 在 x64 硬件平台下, ZGC 的 Region 可以具有如图 3-19 所示的大, 中, 小三类容量:</p> <ul><li><strong>小型 Region(Small Region)</strong> : 容量固定为 2MB, 用于放置小于 256KB 的小对象.</li> <li><strong>中型 Region(Medium Region)</strong> : 容量固定为 32MB, 用于放置大于等于 256KB 但小于 4MB 的对象.</li> <li><strong>大型 Region(Large Region)</strong> : 容量不固定, 可以<strong>动态变化</strong>, 但必须为 2MB 的整数倍, 用于放置 4MB 或以上的大对象. 每个大型 Region 中只会<strong>存放一个大对象</strong>, 这也预示着虽然名字叫作 &quot;大型 Region&quot;, 但它的实际容量完全有可能小于中型 Region, 最小容量可低至 4MB. 大型 Region 在 ZGC 的实现中是<strong>不会被重分配</strong>(重分配是 ZGC 的一种处理动作, 用于复制对象的收集器阶段, 稍后会介绍到)的, 因为复制一个大对象的代价非常高昂.</li></ul> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230401144145-pz9ey01.png" alt="image" title="ZGC 的堆内存布局"></p> <p><strong>ZGC 没有分代</strong>. 之前的垃圾回收器之所以分代, 是源于 &quot;大部分对象朝生夕死&quot; 的假设, 事实上大部分系统的对象分配行为也确实符合这个假设. <strong>不同对象的生命周期是不一致的</strong>, 所以才有了分代的处理方式.</p> <p>为什么 ZGC 不分代? 因为分代实现起来麻烦, 作者就先实现出一个比较简单可用的单代版本, 后续会优化.</p> <h6 id="_3-zgc并发整理算法实现与染色指针"><a href="#_3-zgc并发整理算法实现与染色指针" class="header-anchor">#</a> (3)ZGC并发整理算法实现与染色指针</h6> <p>接下来是 ZGC 的核心问题, 即<strong>并发整理算法</strong>的实现. Shenandoah 使用转发指针和读屏障来实现并发整理, ZGC 虽然同样用到了读屏障, 但用的却是一条与 Shenandoah 完全不同, 更加复杂精巧的解题思路.</p> <p>ZGC 收集器有一个标志性的设计是它采用的<mark><strong>染色指针技术</strong></mark>(Colored Pointer, 其他类似的技术中可能将它称为 Tag Pointer 或者 Version Pointer). 从前, 如果要在对象上存储一些额外的, 只供收集器或者虚拟机本身使用的数据, 通常会在对象头中增加额外的存储字段(参考:对象头), 如对象的哈希码, 分代年龄, 锁记录等就是这样存储的. 这种记录方式在有对象访问的场景下是很自然流畅的, 不会有什么额外负担. 但如果对象存在被移动过的可能性, 即不能保证对象访问能够成功呢? 又或者有一些根本就不会去访问对象, 但又希望得知该对象的某些信息的应用场景呢? 能不能从指针或者与对象内存无关的地方得到这些信息, 譬如是否能够看出来对象被移动过? 这样的要求并非不合理的刁难, 先不去说并发移动对象可能带来的可访问性问题, 此前就遇到过这样的要求, 即追踪式收集算法的标记阶段就可能存在只跟指针打交道而不必涉及指针所引用的对象本身的场景. 例如对象标记的过程中需要给对象打上三色标记, 这些标记本质上就只和对象的引用有关, 而与对象本身无关, 某个对象只有它的引用关系能决定它存活与否, 对象上其他所有的属性都不能够影响它的存活判定结果. HotSpot 虚拟机的几种收集器有不同的标记实现方案, 有的把标记直接记录在对象头上(如 Serial 收集器), 有的把标记记录在与对象相互独立的数据结构上(如 G1, Shenandoah 使用了一种相当于堆内存的 1/64 大小的, 称为 BitMap 的结构来记录标记信息), 而 ZGC 的染色指针是最直接的, 最纯粹的, 它直接把标记信息记在引用对象的指针上, 这时, 与其说可达性分析是遍历对象图来标记对象, 还不如说是遍历 &quot;引用图&quot; 来标记 &quot;引用&quot; 了.</p> <p><strong>染色指针是一种直接将少量额外的信息存储在指针上的技术, 以前的垃圾回收器的 GC 信息都保存在对象头中, 而 ZGC 的 GC 信息保存在指针中</strong>. 可是为什么指针本身也可以存储额外信息呢? 在 64 位系统中, 理论可以访问的内存高达 16EB(2 的 64 次幂)字节. 实际上, 基于需求(用不到那么多内存), 性能(地址越宽在做地址转换时需要的页表级数越多)和成本(消耗更多晶体管)的考虑, 在 AMD64 架构中只支持到 52 位(4PB)的地址总线和 48 位(256TB)的虚拟地址空间, 所以目前 64 位的硬件实际能够支持的最大内存只有 256TB. 此外, 操作系统一侧也还会施加自己的约束, 64 位的 Linux 则分别支持 47 位(128TB)的进程虚拟地址空间和 46 位(64TB)的物理地址空间, 64 位的 Windows 系统甚至只支持 44 位(16TB)的物理地址空间. 尽管 Linux 下 64 位指针的高 18 位不能用来寻址, 但剩余的 46 位指针所能支持的 64TB 内存在今天仍然能够充分满足大型服务器的需要. 鉴于此, ZGC 的染色指针技术继续盯上了这剩下的 46 位指针宽度, 将其高 4 位提取出来存储四个标志信息. <strong>通过这些标志位, 虚拟机可以直接从指针中看到其引用对象的三色标记状态, 是否进入了重分配集(即被移动过), 是否只能通过 finalize() 方法才能被访问到</strong>, 如下图所示. 当然, 由于这些标志位进一步压缩了原本就只有 46 位的地址空间, 也直接导致 ZGC 能够管理的内存不可以超过 4TB(2 的 42 次幂).</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20230401144421-3vmomk0.png" alt="image" title="染色指针示意"></p> <p>为什么有 2 个 mark 标记?</p> <p>每一个 GC 周期开始时, 会交换使用的标记位, 使上次 GC 周期中修正的已标记状态失效, 所有引用都变成未标记.</p> <ul><li>GC 周期 1: 使用 mark0, 则周期结束所有引用 mark 标记都会成为 01.</li> <li>GC 周期 2: 使用 mark1, 则期待的 mark 标记 10, 所有引用都能被重新标记.</li></ul> <p>虽然染色指针有 4TB 的内存限制, 不能支持 32 位平台, 不能支持压缩指针(<code>-XX: +UseCompressedOops</code>​)等诸多约束, 但它带来的收益也是非常可观的, 在 JEP 333 的描述页中, ZGC 的设计者 Per Liden 在 &quot;描述&quot; 小节里陈述了<mark><strong>染色指针的三大优势</strong></mark>:</p> <ul><li><strong>染色指针可以使得一旦某个 Region 的存活对象被移走之后, 这个 Region 立即就能够被释放和重用掉, 而不必等待整个堆中所有指向该 Region 的引用都被修正后才能清理</strong>. 这点相比起 Shenandoah 是一个颇大的优势, 使得理论上只要还有一个空闲 Region, ZGC 就能完成收集, 而 Shenandoah 需要等到引用更新阶段结束以后才能释放回收集中的 Region, 这意味着堆中几乎所有对象都存活的极端情况, 需要 1∶1 复制对象到新 Region 的话, 就必须要有一半的空闲 Region 来完成收集. 至于为什么染色指针能够导致这样的结果, 笔者将在后续解释其 &quot;自愈&quot; 特性的时候进行解释.</li> <li><strong>染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量, 设置内存屏障, 尤其是写屏障的目的通常是为了记录对象引用的变动情况, 如果将这些信息直接维护在指针中, 显然就可以省去一些专门的记录操作</strong>. 实际上, 到目前为止 ZGC 都并未使用任何写屏障, 只使用了读屏障(一部分是染色指针的功劳, 一部分是 ZGC 现在还不支持分代收集, 天然就没有跨代引用的问题). 内存屏障对程序运行时性能的损耗在前面章节中已经讲解过, 能够省去一部分的内存屏障, 显然对程序运行效率是大有裨益的, 所以 ZGC 对吞吐量的影响也相对较低.</li> <li><strong>染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记, 重定位过程相关的数据, 以便日后进一步提高性能</strong>. 现在 Linux 下的 64 位指针还有前 18 位并未使用, 它们虽然不能用来寻址, 却可以通过其他手段用于信息记录. 如果开发了这 18 位, 既可以腾出已用的 4 个标志位, 将 ZGC 可支持的最大堆内存从 4TB 拓展到 64TB, 也可以利用其余位置再存储更多的标志, 譬如存储一些追踪信息来让垃圾收集器在移动对象时能将低频次使用的对象移动到不常访问的内存区域.</li></ul> <p>不过, 要顺利<strong>应用染色指针有一个必须解决的前置问题</strong>: Java 虚拟机作为一个普普通通的进程, 这样随意重新定义内存中某些指针的其中几位, 操作系统是否支持? 处理器是否支持? 这是很现实的问题, 无论中间过程如何, 程序代码最终都要转换为机器指令流交付给处理器去执行, 处理器可不会管指令流中的指针哪部分存的是标志位, 哪部分才是真正的寻址地址, 只会把整个指针都视作一个内存地址来对待. 这里面的解决方案要涉及<strong>虚拟内存映射技术</strong>, 先来复习一下这个 x86 计算机体系中的经典设计.</p> <p>在远古时代的 x86 计算机系统里面, 所有进程都是共用同一块物理内存空间的, 这样会导致不同进程之间的内存无法相互隔离, 当一个进程污染了别的进程内存后, 就只能对整个系统进行复位后才能得以恢复. 为了解决这个问题, 从 Intel 80386 处理器开始, 提供了 &quot;保护模式&quot; 用于隔离进程. 在保护模式下, 386 处理器的全部 32 条地址寻址线都有效, 进程可访问最高也可达 4GB 的内存空间, 但此时已不同于之前实模式下的物理内存寻址了, 处理器会使用<strong>分页管理机制把线性地址空间和物理地址空间分别划分为大小相同的块, 这样的内存块被称为 &quot;页&quot;(Page)</strong> . 通过<strong>在线性虚拟空间的页与物理地址空间的页之间建立的映射表, 分页管理机制会进行线性地址到物理地址空间的映射, 完成线性地址到物理地址的转换</strong>. 为方便理解, 不妨设想这样一个场景来类比: 假如你要去 &quot;中山一路3号&quot; 这个地址拜访一位朋友, 根据你所处城市的不同, 譬如在广州或者在上海, 是能够通过这个 &quot;相同的地址&quot; 定位到两个完全独立的物理位置的, 这时<strong>地址与物理位置是一对多关系映射</strong>.</p> <p>不同层次的虚拟内存到物理内存的转换关系可以在<strong>硬件层面, 操作系统层面或者软件进程层面</strong>实现, 如何完成地址转换, 是一对一, 多对一还是一对多的映射, 也可以根据实际需要来设计. Linux/x86-64 平台上的 <strong>ZGC 使用了多重映射(Multi-Mapping)将多个不同的虚拟内存地址映射到同一个物理内存地址上, 这是一种多对一映射, 意味着 ZGC 在虚拟内存中看到的地址空间要比实际的堆内存容量来得更大. 把染色指针中的标志位看作是地址的分段符, 那只要将这些不同的地址段都映射到同一个物理内存空间, 经过多重映射转换后, 就可以使用染色指针正常进行寻址了</strong>, 效果如图 3-21 所示.</p> <p><img src="/img/Image00044-20240302133505-bswl4ow.jpg" alt="" title="图3-21　多重映射下的寻址"></p> <p>在某些场景下, 多重映射技术确实可能会带来一些诸如复制大对象时会更容易这样的额外好处, 可从根源上讲, ZGC 的多重映射只是它采用染色指针技术的伴生产物, 并不是专门为了实现其他某种特性需求而去做的.</p> <h6 id="_4-zgc垃圾收集流程"><a href="#_4-zgc垃圾收集流程" class="header-anchor">#</a> (4)ZGC垃圾收集流程</h6> <p>接下来来学习 ZGC 收集器是如何工作的. ZGC 的运作过程大致可划分为以下四个大的阶段. <mark><strong>全部四个阶段都是可以并发执行的, 仅是两个阶段中间会存在短暂的停顿小阶段</strong></mark>, 这些小阶段, 譬如初始化 GC Root 直接关联对象的 Mark Start, 与之前 G1 和 Shenandoah 的 Initial Mark 阶段并没有什么差异, 就不再单独解释了. ZGC 的运作过程具体如下图所示.</p> <p><img src="/img/Image00045-20240302133505-fh3rzwl.jpg" alt="" title="ZGC 运作过程"></p> <ul><li><mark><strong>并发标记</strong></mark>: 与 G1, Shenandoah 一样, <strong>并发标记是遍历对象图做可达性分析的阶段</strong>, 前后也要经过类似于 G1, Shenandoah 的初始标记, 最终标记(尽管 ZGC 中的名字不叫这些)的<strong>短暂停顿</strong>, 而且这些停顿阶段所做的事情在目标上也是相类似的. 与 G1, Shenandoah 不同的是, <strong>ZGC 的标记是在指针上而不是在对象上进行的</strong>, 标记阶段会更新染色指针中的 Marked 0, Marked 1 标志位.</li> <li><mark><strong>并发预备重分配</strong></mark>: 这个阶段需要<strong>根据特定的查询条件统计得出本次收集过程要清理哪些 Region, 将这些 Region 组成重分配集(Relocation Set)</strong> . 重分配集与 G1 收集器的回收集(Collection Set)还是有区别的, ZGC 划分 Region 的目的并非为了像 G1 那样做收益优先的增量回收. 相反, <strong>ZGC 每次回收都会扫描所有的 Region, 用范围更大的扫描成本换取省去 G1 中记忆集的维护成本</strong>. 因此, ZGC 的重分配集只是决定了里面的存活对象会被重新复制到其他的 Region 中, 里面的 Region 会被释放, 而并不能说回收行为就只是针对这个集合里面的 Region 进行, 因为标记过程是针对全堆的. 此外, 在 JDK 12 的 ZGC 中开始支持的类卸载以及弱引用的处理, 也是在这个阶段中完成的.</li> <li><mark><strong>并发重分配</strong></mark>: 重分配是 ZGC 执行过程中的<strong>核心阶段</strong>, 这个过程要<strong>把重分配集中的存活对象复制到新的 Region 上, 并为重分配集中的每个 Region 维护一个转发表(Forward Table), 记录从旧对象到新对象的转向关系</strong>. 得益于染色指针的支持, ZGC 收集器能仅从引用上就明确得知一个对象是否处于重分配集之中, <strong>如果用户线程此时并发访问了位于重分配集中的对象, 这次访问将会被预置的内存屏障所截获, 然后立即根据 Region 上的转发表记录将访问转发到新复制的对象上, 并同时修正更新该引用的值, 使其直接指向新对象, ZGC 将这种行为称为指针的 &quot;自愈&quot;(Self-Healing) 能力</strong>. 这样做的好处是只有第一次访问旧对象会陷入转发, 也就是只慢一次, 对比 Shenandoah 的 Brooks 转发指针, 那是每次对象访问都必须付出的固定开销, 简单地说就是每次都慢, 因此 ZGC 对用户程序的运行时负载要比 Shenandoah 来得更低一些. 还有另外一个直接的好处是由于染色指针的存在, 一旦重分配集中某个 Region 的存活对象都复制完毕后, 这个 Region 就可以<strong>立即释放</strong>用于新对象的分配(但是转发表还得留着不能释放掉), 哪怕堆中还有很多指向这个对象的未更新指针也没有关系, 这些旧指针一旦被使用, 它们都是可以自愈的.</li> <li><mark><strong>并发重映射</strong></mark>: 重映射所做的就是<strong>修正整个堆中指向重分配集中旧对象的所有引用</strong>, 这一点从目标角度看是与 Shenandoah 并发引用更新阶段一样的, 但是 ZGC 的并发重映射并不是一个必须要 &quot;迫切&quot; 去完成的任务, 因为前面说过, 即使是旧引用, 它也是可以自愈的, 最多只是第一次使用时多一次转发和修正操作. 重映射清理这些旧引用的主要目的是为了不变慢(还有清理结束后可以释放转发表这样的附带收益), 所以说这并不是很 &quot;迫切&quot;. 因此, ZGC 很巧妙地<strong>把并发重映射阶段要做的工作, 合并到了下一次垃圾收集循环中的并发标记阶段里去完成</strong>, 反正它们都是要遍历所有对象的, 这样合并就节省了一次遍历对象图的开销. 一旦所有指针都被修正之后, 原来记录新旧对象关系的转发表就可以释放掉了.</li></ul> <p>ZGC 的设计理念是迄今垃圾收集器研究的最前沿成果, 它做到了<strong>几乎整个收集过程都全程可并发, 短暂停顿也只与 GC Roots 大小相关而与堆内存大小无关, 因而同样实现了任何堆上停顿都小于十毫秒的目标</strong>.</p> <h6 id="_5-zgc优缺点与问题"><a href="#_5-zgc优缺点与问题" class="header-anchor">#</a> (5)ZGC优缺点与问题</h6> <p>相比 G1, Shenandoah 等先进的垃圾收集器, ZGC 在实现细节上做了一些不同的<strong>权衡选择</strong>, 譬如 G1 需要通过写屏障来维护记忆集, 才能处理跨代指针, 得以实现 Region 的增量回收. 记忆集要占用大量的内存空间, 写屏障也对正常程序运行造成额外负担, 这些都是权衡选择的代价. ZGC 就完全没有使用记忆集, 它甚至连分代都没有, 连像 CMS 中那样只记录新生代和老年代间引用的卡表也不需要, 因而<strong>完全没有用到写屏障</strong>, 所以给用户线程带来的运行负担也要小得多. 可是, 必定要有优有劣才会称作权衡, ZGC 的这种选择也限制了它<strong>能承受的对象分配速率不会太高</strong>.</p> <blockquote><p>浮动垃圾</p></blockquote> <p>可以想象以下场景来理解 ZGC 的这个劣势: ZGC 准备要对一个很大的堆做一次完整的并发收集, 假设其全过程要持续十分钟以上(请读者切勿混淆并发时间与停顿时间, ZGC 立的 Flag 是<strong>停顿时间不超过十毫秒</strong>), 在这段时间里面, 由于应用的对象分配速率很高, 将创造大量的新对象, 这些新对象很难进入当次收集的标记范围, 通常就只能全部当作存活对象来看待---尽管其中绝大部分对象都是朝生夕灭的, 这就<strong>产生了大量的</strong>​<mark><strong>浮动垃圾</strong></mark>. 如果这种高速分配持续维持的话, 每一次完整的并发收集周期都会很长, 回收到的内存空间持续小于期间并发产生的浮动垃圾所占的空间, 堆中剩余可腾挪的空间就越来越小了. 因此, <strong>ZGC 最大的问题是浮动垃圾</strong>. ZGC 的停顿时间是在 10ms 以下, 但是 ZGC 的执行时间还是远远大于这个时间的. 假如 ZGC 全过程需要执行 10 分钟, 在这个期间由于对象分配速率很高, 将创建大量的新对象, 这些对象很难进入当次 GC, 所以只能在下次 GC 的时候进行回收, 这些只能等到下次 GC 才能回收的对象就是浮动垃圾.</p> <blockquote><p>浮动垃圾解决方法</p></blockquote> <p>目前唯一的办法就是<strong>尽可能地增加堆容量大小, 获得更多喘息的时间</strong>. 但是若要从根本上提升 ZGC 能够应对的对象分配速率, <strong>还是需要引入分代收集, 让新生对象都在一个专门的区域中创建</strong>, 然后专门针对这个区域进行更频繁, 更快的收集.</p> <h6 id="_6-zgc性能"><a href="#_6-zgc性能" class="header-anchor">#</a> (6)ZGC性能</h6> <p>ZGC 还有一个常在技术资料上被提及的优点是支持 &quot;<strong>NUMA-Aware</strong>&quot; 的内存分配. NUMA(Non-Uniform Memory Access, 非统一内存访问架构)是一种为<strong>多处理器或者多核处理器的计算机所设计的内存架构</strong>. 由于摩尔定律逐渐失效, 现代处理器因频率发展受限转而向多核方向发展, 以前原本在北桥芯片中的内存控制器也被集成到了处理器内核中, 这样每个处理器核心所在的裸晶(DIE) 都有属于自己内存管理器所管理的内存, 如果要访问被其他处理器核心管理的内存, 就必须通过 Inter-Connect 通道来完成, 这要比访问处理器的本地内存慢得多. 在 NUMA 架构下, <strong>ZGC 收集器会优先尝试在请求线程当前所处的处理器的本地内存上分配对象, 以保证高效内存访问</strong>. 在 ZGC 之前的收集器就只有针对吞吐量设计的 Parallel Scavenge 支持 NUMA 内存分配, 如今 ZGC 也成为另外一个选择.</p> <p>在性能方面, 尽管目前还处于实验状态, 还没有完成所有特性, 稳定性打磨和性能调优也仍在进行, 但即使是这种状态下的 ZGC, 其性能表现已经相当亮眼, 从官方给出的测试结果来看, 用 &quot;<strong>令人震惊的, 革命性的 ZGC</strong>&quot; 来形容都不为过.</p> <p>图 3-23 和图 3-24 是 ZGC 与 Parallel Scavenge, G1 三款收集器通过 SPECjbb 2015 的测试结果. 在 ZGC 的 &quot;弱项&quot; 吞吐量方面, 以低延迟为首要目标的 ZGC 已经达到了以高吞吐量为目标 Parallel Scavenge 的99%, 直接超越了 G1. 如果将吞吐量测试设定为面向 SLA(Service Level Agreements)应用的 &quot;Critical Throughput&quot; 的话, ZGC 的表现甚至还反超了 Parallel Scavenge 收集器.</p> <p>而在 ZGC 的强项<strong>停顿时间</strong>测试上, 它就毫不留情地与 Parallel Scavenge, G1 拉开了两个数量级的差距. 不论是平均停顿, 还是 95% 停顿, 99% 停顿, 99.9% 停顿, 抑或是最大停顿时间, <strong>ZGC 均能毫不费劲地控制在十毫秒之内</strong>, 以至于把它和另外两款停顿数百近千毫秒的收集器放到一起对比, 就几乎显示不了 ZGC 的柱状条(图 3-24a), 必须把结果的纵坐标从线性尺度调整成对数尺度(图 3-24b, 纵坐标轴的尺度是对数增长的)才能观察到 ZGC 的测试结果.</p> <p><img src="/img/Image00046-20240302133505-rr2lpp2.jpg" alt="" title="图3-23　ZGC 的吞吐量测试"></p> <p><img src="/img/Image00047-20240302133505-b0jjjwk.jpg" alt="" title="图3-24　ZGC 的停顿时间测试"></p> <p>ZGC 原本是 Oracle 作为一项商业特性(如同 JFR, JMC 这些功能)来设计和实现的, 只不过在它横空出世的 JDK 11 时期, 正好适逢 Oracle 调整许可证授权, 把所有商业特性都开源给了 OpenJDK, 所以用户对其商业性并没有明显的感知. ZGC 有着令所有开发人员趋之若鹜的优秀性能, 笔者相信它<strong>完全成熟之后, 将会成为服务端, 大内存, 低延迟应用的首选收集器的有力竞争者</strong>.</p> <h6 id="_7-zgc参数设置"><a href="#_7-zgc参数设置" class="header-anchor">#</a> (7)ZGC参数设置</h6> <p>启用 ZGC 比较简单, 设置 JVM 参数即可: <code>-XX:+UnlockExperimentalVMOptions, -XX:+UseZGC</code>​. 调优也并不难, 因为 ZGC 调优参数并不多. 它和 G1 一样, 可以调优的参数都比较少, 大部分工作 JVM 能很好的自动完成.</p> <h4 id="选择合适的垃圾收集器"><a href="#选择合适的垃圾收集器" class="header-anchor">#</a> 选择合适的垃圾收集器</h4> <p>HotSpot 虚拟机提供了种类繁多的垃圾收集器, 选择太多反而令人踌躇难决, 若只挑最先进的显然不可能满足全部应用场景, 但只用一句 &quot;必须因地制宜, 按需选用&quot; 又未免有敷衍的嫌疑, 本节就来探讨一下<strong>如何选择合适的垃圾收集器</strong>.</p> <div class="language- extra-class"><pre><code>                垃圾收集器这么多, **如何选择一款适合自己应用的收集器呢? 这个问题的答案主要受以下三个因素影响**:
</code></pre></div><ul><li><mark><strong>应用程序的主要关注点是什么</strong></mark>? 如果是数据分析, 科学计算类的任务, 目标是能尽快算出结果, 那<strong>吞吐量</strong>就是主要关注点; 如果是 SLA 应用, 那停顿时间直接影响服务质量, 严重的甚至会导致事务超时, 这样<strong>延迟就是主要关注点</strong>; 而如果是客户端应用或者嵌入式应用, 那垃圾收集的<strong>内存占用</strong>则是不可忽视的.</li> <li><mark><strong>运行应用的基础设施如何</strong></mark>? 譬如硬件规格, 要涉及的系统架构是 x86-32/64, SPARC 还是 ARM/Aarch64; 处理器的数量多少, 分配内存的大小; 选择的操作系统是 Linux, Solaris 还是 Windows 等.</li> <li><mark><strong>使用 JDK 的发行商是什么</strong></mark>? 版本号是多少? 是 OracleJDK, Open-JDK, OpenJ9 抑或是其他公司的发行版? 该 JDK 对应了《Java 虚拟机规范》的哪个版本?</li></ul> <p>一般来说, 收集器的选择就从以上这几点出发来考虑. 举个例子, 假设某个直接面向用户提供服务的 B/S 系统准备选择垃圾收集器, 一般来说<strong>延迟时间</strong>是这类应用的主要关注点, 那么:</p> <ul><li>如果你虽然没有足够预算去使用商业解决方案, 但能够掌控软硬件型号, 使用较新的版本, 同时又特别注重延迟, 那 ZGC 很值得尝试.</li> <li>如果你对还处于实验状态的收集器的稳定性有所顾虑, 或者应用必须运行在 Win-dows 操作系统下, 那 ZGC 就无缘了, 试试 Shenandoah 吧.</li> <li>如果你接手的是遗留系统, 软硬件基础设施和 JDK 版本都比较落后, 那就根据内存规模衡量一下, 对于大概 4GB 到 6GB 以下的堆内存, CMS 一般能处理得比较好, 而对于更大的堆内存, 可重点考察一下 <strong>G1</strong>.</li></ul> <p>当然, 以上都是仅从理论出发的分析, <strong>实战中切不可纸上谈兵, 根据系统实际情况去测试才是选择收集器的最终依据</strong>.</p> <p><mark><strong>内存较小可以使用 ParNew + CMS. 内存较大使用 G1. 新的 JDK 版本可以用 ZGC</strong></mark>.</p> <h4 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="header-anchor">#</a> 内存分配与回收策略</h4> <p>Java 技术体系的<strong>自动内存管理, 最根本的目标</strong>是自动化地解决两个问题: <mark><strong>自动给对象分配内存以及自动回收分配给对象的内存</strong></mark>. 关于回收内存这方面, 笔者已经使用了大量篇幅去介绍虚拟机中的垃圾收集器体系以及运作原理, 现在来探讨一下关于<mark><strong>给对象分配内存</strong></mark>的那些事儿.</p> <p><strong>对象的内存分配, 从概念上讲, 大部分都是在堆上分配(而实际上也有可能经过即时编译后被拆散为标量类型并间接地在栈上分配)</strong> . 在经典分代的设计下, 新生对象通常会分配在新生代中, 少数情况下(例如对象大小超过一定阈值)也可能会直接分配在老年代. 对象分配的规则并不是固定的, 《Java 虚拟机规范》并未规定新对象的创建和存储细节, 这取决于虚拟机当前使用的是哪一种垃圾收集器, 以及虚拟机中与内存相关的参数的设定.</p> <p>接下来的几小节内容, 将会讲解若干<mark><strong>最基本的内存分配原则</strong></mark>, 并通过代码去验证这些原则. 本节出现的代码如无特别说明, 均使用 HotSpot 虚拟机, 以客户端模式运行. 由于并未指定收集器组合, 因此本节验证的实际是<strong>使用 Serial 加 Serial Old 客户端默认收集器组合</strong>下的内存分配和回收的策略, 这种配置和收集器组合也许是开发人员做研发时的默认组合(其实现在研发时很多也默认用服务端虚拟机了), 但在生产环境中一般不会这样用, 所以主要学习的是分析方法, 而列举的分配规则反而只是次要的. 读者也不妨根据自己项目中使用的收集器编写一些程序去实践验证一下使用其他几种收集器的内存分配规则.</p> <p>对象内存分配流程图大体如下所示.</p> <p><img src="/img/image-20230325163536-k63gzvs.png" alt="https://www.processon.com/diagraming/641ea4c11fae9069cfbe5358"></p> <h5 id="_1-对象栈上分配"><a href="#_1-对象栈上分配" class="header-anchor">#</a> 1.对象栈上分配</h5> <p>普遍的认识是对象都在堆区分配, 但是也可能分配到虚拟机栈上.</p> <p>大部分对象都是在堆上进行分配, 当对象没有被引用的时候, 需要依靠 GC 进行回收内存, 如果对象数量较多的时候, 会给 GC 带来较大压力, 也间接影响了应用的性能. 为了减少临时对象在堆内分配的数量, JVM 通过<strong>逃逸分析</strong>(参考:逃逸分析)确定该对象不会被外部访问. 如果不会逃逸可以<strong>将该对象在栈上分配内存</strong>, 这样<strong>该对象所占用的内存空间就可以随栈帧出栈而销毁, 就减轻了垃圾回收的压力</strong>.</p> <p>栈上分配对象示例:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * 栈上分配, 标量替换
 * 代码调用了1亿次alloc(), 如果是分配到堆上, 大概需要1GB以上堆空间, 如果堆空间小于该值, 必然会触发GC. 
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AllotOnStack</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;Jack&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>对于上面的测试, 如果采用如下的参数执行, 则一般不会发生 GC. 其实就是<strong>开启了逃逸分析和标量替换</strong>, 使得 user 对象都分配到栈上了, 方法结束后就被销毁了, 所以不会 GC.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 使用如下参数不会发生GC</span>
<span class="token operator">-</span><span class="token class-name">Xmx15m</span> <span class="token operator">-</span><span class="token class-name">Xms15m</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">DoEscapeAnalysis</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">PrintGC</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">EliminateAllocations</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果使用下面的参数执行代码, 也就是关闭逃逸分析和标量替换, 使得 user 对象都分配到堆上了, 方法结束后对象一直在堆中, 从而触发了较多的 GC.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 使用如下参数都会发生大量GC</span>
<span class="token operator">-</span><span class="token class-name">Xmx15m</span> <span class="token operator">-</span><span class="token class-name">Xms15m</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">-</span><span class="token class-name">DoEscapeAnalysis</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">PrintGC</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">EliminateAllocations</span>
<span class="token operator">-</span><span class="token class-name">Xmx15m</span> <span class="token operator">-</span><span class="token class-name">Xms15m</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">DoEscapeAnalysis</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">PrintGC</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">-</span><span class="token class-name">EliminateAllocations</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>结论: 栈上分配依赖于逃逸分析和标量替换</strong>.</p> <h5 id="_2-对象优先在eden分配"><a href="#_2-对象优先在eden分配" class="header-anchor">#</a> 2.对象优先在Eden分配</h5> <p><mark><strong>大多数情况下, 对象在新生代 Eden 区中分配. 当 Eden 区没有足够空间进行分配时, 虚拟机将发起一次 Minor GC</strong></mark>.</p> <p>HotSpot 虚拟机提供了 <code>-XX: +PrintGCDetails</code>​ 这个收集器日志参数, 告诉虚拟机在发生垃圾收集行为时打印内存回收日志, 并且在进程退出的时候输出当前的内存各区域分配情况. 在实际的问题排查中, 收集器日志常会打印到文件后通过工具进行分析, 不过本节实验的日志并不多, 直接阅读就能看得很清楚.</p> <blockquote><p>新生代 Minor GC示例</p></blockquote> <p>在下面代码的 testAllocation() 方法中, 尝试分配三个 2MB 大小和一个 4MB 大小的对象, 在运行时通过 <code>-Xms20M, -Xmx20M, -Xmn10M</code>​ 这三个参数限制了 Java 堆大小为 20MB, 不可扩展, 其中 10MB 分配给新生代, 剩下的 10MB 分配给老年代. <code>-XX: Survivor-Ratio=8</code>​ 决定了新生代中 Eden 区与一个 Survivor 区的空间比例是 8∶1, 从输出的结果也清晰地看到 &quot;<code>eden space 8192K, from space 1024K, to space 1024K</code>​&quot; 的信息, 新生代总可用空间为 9216KB(Eden 区 + 1 个 Survivor 区的总容量).</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * VM 参数: -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testAllocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token punctuation">,</span> allocation3<span class="token punctuation">,</span> allocation4<span class="token punctuation">;</span>
    allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 出现一次 Minor GC</span>
    allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>  
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>运行结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>[GC [DefNew: 6651K-&gt;148K(9216K), 0.0070106 secs] 6651K-&gt;6292K(19456K), 0.0070426 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
Heap
    def new generation   total 9216K, used 4326K [0x029d0000, 0x033d0000, 0x033d0000)
        eden space 8192K,  51% used [0x029d0000, 0x02de4828, 0x031d0000)
        from space 1024K,  14% used [0x032d0000, 0x032f5370, 0x033d0000)
        to   space 1024K,   0% used [0x031d0000, 0x031d0000, 0x032d0000)
    tenured generation   total 10240K, used 6144K [0x033d0000, 0x03dd0000, 0x03dd0000)
            the space 10240K,  60% used [0x033d0000, 0x039d0030, 0x039d0200, 0x03dd0000)
    compacting perm gen  total 12288K, used 2114K [0x03dd0000, 0x049d0000, 0x07dd0000)
            the space 12288K,  17% used [0x03dd0000, 0x03fe0998, 0x03fe0a00, 0x049d0000)
No shared spaces configured.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>执行 testAllocation() 中<strong>分配 allocation4 对象</strong>的语句时会发生一次 Minor GC, 这次回收的结果是新生代 6651KB 变为 148KB, 而总内存占用量则几乎没有减少(因为 allocation1, 2, 3 三个对象都是存活的, 虚拟机几乎没有找到可回收的对象). <strong>产生这次垃圾收集的原因是为 allocation4 分配内存时, 发现 Eden 已经被占用了 6MB, 剩余空间已不足以分配 allocation4 所需的 4MB 内存, 因此发生 Minor GC. 垃圾收集期间虚拟机又发现已有的三个 2MB 大小的对象全部无法放入 Survivor 空间(Survivor 空间只有 1MB 大小), 所以只好通过分配担保机制提前转移到老年代去</strong>.</p> <p>这次收集结束后, 4MB 的 allocation4 对象顺利分配在 Eden 中. 因此程序执行完的结果是 Eden 占用 4MB(被 allocation4 占用), Survivor 空闲, 老年代被占用 6MB(被挪过去的 allocation1, 2, 3 占用). 通过 GC 日志就可以证实这一点.</p> <blockquote><p>Eden与Survivor区默认8:1:1</p></blockquote> <p>大量的对象被分配在 <strong>eden 区</strong>, eden 区满了后会触发 <strong>Minor GC</strong>, 可能会有 99% 以上的对象成为垃圾被回收掉, 剩余存活的对象会被挪到为空的那块 survivor 区, 下一次 eden 区满了后又会触发 Minor GC, 把 eden 区和 survivor 区的垃圾对象回收, 把剩余存活的对象一次性挪动到另外一块为空的 survivor 区, 因为新生代的对象大部分都是朝生夕死的, <strong>存活时间很短, 所以 JVM 默认的 8:1:1 的比例是很合适的</strong>, 让 eden 区尽量的大, survivor 区够用即可.</p> <p>JVM 默认有这个参数 -XX:+UseAdaptiveSizePolicy(默认开启), 会导致这个 8:1:1 比例自动变化, 因此线上实际可能不是这个比例值. 如果不想这个比例有变化可以设置参数 -XX:-UseAdaptiveSizePolicy.</p> <h5 id="_3-大对象直接进入老年代"><a href="#_3-大对象直接进入老年代" class="header-anchor">#</a> 3.大对象直接进入老年代</h5> <p><strong>大对象就是指需要大量连续内存空间的 Java 对象, 最典型的大对象便是那种很长的字符串, 或者元素数量很庞大的数组</strong>, 本节例子中的 byte[] 数组就是典型的大对象. 大对象对虚拟机的内存分配来说就是一个不折不扣的坏消息, 比遇到一个大对象更加坏的消息就是遇到一群 &quot;朝生夕灭&quot; 的 &quot;短命大对象&quot;, 写程序的时候应注意避免. 在 Java 虚拟机中要<strong>避免大对象</strong>的原因是, 在分配空间时, 它<strong>容易导致内存明明还有不少空间时就提前触发垃圾收集</strong>, 以获取足够的连续空间才能安置好它们, 而当复制对象时, 大对象就意味着高额的内存复制开销. HotSpot 虚拟机提供了 <code>-XX: PretenureSizeThreshold</code>​ 参数, <mark><strong>指定大于该设置值的对象直接在老年代分配, 这样做的目的就是避免在 Eden 区及两个 Survivor 区之间来回复制, 产生大量的内存复制操作</strong></mark>.</p> <p><strong>为什么要这样呢?</strong> <strong><strong>这是为了避免为</strong></strong>​<strong>大对象分配内存时的复制操作而降低效率</strong>. 举个例子: 如果 Eden 区 60M, From 和 To 都是 10M, 当一个对象 4M 时, 假设会一直引用这个对象, 那么这个 4M 的对象就会因为 Minor GC 在 From 和 To 之间不断移动, 影响 GC 性能.</p> <blockquote><p>大对象直接进入老年代示例</p></blockquote> <p>执行下面代码中的 testPretenureSizeThreshold() 方法后, 可以看到 Eden 空间几乎没有被使用, 而老年代的 10MB 空间被使用了 40%, 也就是 4MB 的 allocation 对象<strong>直接就分配在老年代</strong>中, 这是因为 <code>-XX: PretenureSizeThreshold</code>​ 被设置为 3MB(就是 3145728, 这个参数不能与 <code>-Xmx</code>​ 之类的参数一样直接写 3MB), 因此超过 3MB 的对象都会直接在老年代进行分配.</p> <p>注意: <code>-XX: PretenureSizeThreshold</code>​ 参数<strong>只对 Serial 和 ParNew 两款新生代收集器有效</strong>, HotSpot 的其他新生代收集器, 如 Parallel Scavenge 并不支持这个参数. 如果必须使用此参数进行调优, 可考虑 ParNew 加 CMS 的收集器组合.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * VM 参数: -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
 * -XX:PretenureSizeThreshold=3145728  指定大对象阈值为3M
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testPretenureSizeThreshold</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation<span class="token punctuation">;</span>
    <span class="token comment">// 直接分配在老年代中</span>
    allocation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>运行结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>Heap
    def new generation   total 9216K, used 671K [0x029d0000, 0x033d0000, 0x033d0000)
        eden space 8192K,   8% used [0x029d0000, 0x02a77e98, 0x031d0000)
        from space 1024K,   0% used [0x031d0000, 0x031d0000, 0x032d0000)
        to   space 1024K,   0% used [0x032d0000, 0x032d0000, 0x033d0000)
    tenured generation   total 10240K, used 4096K [0x033d0000, 0x03dd0000, 0x03dd0000)
            the space 10240K,  40% used [0x033d0000, 0x037d0010, 0x037d0200, 0x03dd0000)
    compacting perm gen  total 12288K, used 2107K [0x03dd0000, 0x049d0000, 0x07dd0000)
            the space 12288K,  17% used [0x03dd0000, 0x03fdefd0, 0x03fdf000, 0x049d0000)
No shared spaces configured.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h5 id="_4-长期存活的对象将进入老年代"><a href="#_4-长期存活的对象将进入老年代" class="header-anchor">#</a> 4.长期存活的对象将进入老年代</h5> <p>HotSpot 虚拟机中多数收集器都采用了分代收集来管理堆内存, 那内存回收时就必须能决策哪些存活对象应当放在新生代, 哪些存活对象放在老年代中. 为做到这点, <strong>虚拟机给每个对象定义了一个对象年龄(Age)计数器, 存储在对象头中</strong>(参考: 对象头). <strong>对象通常在 Eden 区里诞生, 如果经过第一次 Minor GC 后仍然存活, 并且能被 Survivor 容纳的话, 该对象会被移动到 Survivor 空间中, 并且将其对象年龄设为1岁. 对象在 Survivor 区中每熬过一次 Minor GC, 年龄就增加 1 岁, 当它的年龄增加到一定程度(默认为 15), 就会被晋升到老年代中. 对象晋升老年代的年龄阈值</strong>, 可以通过参数 <code>-XX: MaxTenuringThreshold</code>​ 设置.</p> <blockquote><p>长期存活的对象进入老年代示例</p></blockquote> <p>可以试试分别以 <code>-XX: MaxTenuringThreshold=1</code>​ 和 <code>-XX: MaxTenuringThreshold=15</code>​ 两种设置来执行下面代码中的 testTenuringThreshold() 方法, 此方法中 allocation1 对象需要 256KB 内存, Survivor 空间可以容纳. 当 <code>-XX: MaxTenuringThreshold=1</code>​ 时, allocation1 对象在第二次 GC 发生时进入老年代, 新生代已使用的内存在垃圾收集以后非常干净地变成 0KB. 而当 <code>-XX: MaxTenuringThreshold=15</code>​ 时, 第二次 GC 发生后, allocation1 对象则还留在新生代 Survivor 空间, 这时候新生代仍然有 404KB 被占用.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * VM 参数: -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:Survivor-
   Ratio=8 -XX:MaxTenuringThreshold=1
 * -XX:+PrintTenuringDistribution
 */</span>
<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unused&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testTenuringThreshold</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token punctuation">,</span> allocation3<span class="token punctuation">;</span>
    <span class="token comment">// 什么时候进入老年代决定于 XX:MaxTenuring-Threshold 设置</span>
    allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>_1MB <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   
    allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation3 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>以 <code>-XX: MaxTenuringThreshold=1</code>​ 参数来运行的结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>[GC [DefNew
Desired Survivor size 524288 bytes, new threshold 1 (max 1)
- age   1:     414664 bytes,     414664 total
: 4859K-&gt;404K(9216K), 0.0065012 secs] 4859K-&gt;4500K(19456K), 0.0065283 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]
[GC [DefNew
Desired Survivor size 524288 bytes, new threshold 1 (max 1)
: 4500K-&gt;0K(9216K), 0.0009253 secs] 8596K-&gt;4500K(19456K), 0.0009458 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
Heap
    def new generation   total 9216K, used 4178K [0x029d0000, 0x033d0000, 0x033d0000)
        eden space 8192K,  51% used [0x029d0000, 0x02de4828, 0x031d0000)
        from space 1024K,   0% used [0x031d0000, 0x031d0000, 0x032d0000)
        to   space 1024K,   0% used [0x032d0000, 0x032d0000, 0x033d0000)
    tenured generation   total 10240K, used 4500K [0x033d0000, 0x03dd0000, 0x03dd0000)
            the space 10240K,  43% used [0x033d0000, 0x03835348, 0x03835400, 0x03dd0000)
    com\pacting perm gen  total 12288K, used 2114K [0x03dd0000, 0x049d0000, 0x07dd0000)
            the space 12288K,  17% used [0x03dd0000, 0x03fe0998, 0x03fe0a00, 0x049d0000)
No shared spaces configured.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>以 <code>-XX: MaxTenuringThreshold=15</code>​ 参数来运行的结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>[GC [DefNew
Desired Survivor size 524288 bytes, new threshold 15 (max 15)
- age   1:     414664 bytes,     414664 total
: 4859K-&gt;404K(9216K), 0.0049637 secs] 4859K-&gt;4500K(19456K), 0.0049932 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
[GC [DefNew
Desired Survivor size 524288 bytes, new threshold 15 (max 15)
- age   2:     414520 bytes,     414520 total
: 4500K-&gt;404K(9216K), 0.0008091 secs] 8596K-&gt;4500K(19456K), 0.0008305 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
Heap
    def new generation   total 9216K, used 4582K [0x029d0000, 0x033d0000, 0x033d0000)
        eden space 8192K,  51% used [0x029d0000, 0x02de4828, 0x031d0000)
        from space 1024K,  39% used [0x031d0000, 0x03235338, 0x032d0000)
        to   space 1024K,   0% used [0x032d0000, 0x032d0000, 0x033d0000)
    tenured generation   total 10240K, used 4096K [0x033d0000, 0x03dd0000, 0x03dd0000)
            the space 10240K,  40% used [0x033d0000, 0x037d0010, 0x037d0200, 0x03dd0000)
    compacting perm gen  total 12288K, used 2114K [0x03dd0000, 0x049d0000, 0x07dd0000)
            the space 12288K,  17% used [0x03dd0000, 0x03fe0998, 0x03fe0a00, 0x049d0000)
No shared spaces configured.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h5 id="_5-动态对象年龄判定"><a href="#_5-动态对象年龄判定" class="header-anchor">#</a> 5.动态对象年龄判定</h5> <p>为了能更好地适应不同程序的内存状况, HotSpot 虚拟机并<strong>不是永远要求</strong>对象的年龄必须达到 <code>-XX: MaxTenuringThreshold</code>​ 才能晋升老年代, <mark><strong>如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半, 年龄大于或等于该年龄的对象就可以直接进入老年代</strong></mark>, 无须等到 <code>-XX: MaxTenuringThreshold</code>​ 中要求的年龄.</p> <p>对象动态年龄判断机制一般是在 Minor GC 之后触发的.</p> <blockquote><p>动态对象年龄判定示例</p></blockquote> <p>执行下面代码中的 testTenuringThreshold2() 方法, 并将设置 <code>-XX: MaxTenuring-Threshold=15</code>​, 发现运行结果中 Survivor 占用仍然为 0%, 而老年代比预期增加了 6%, 也就是说 allocation1, allocation2 对象都直接进入了老年代, 并没有等到 15 岁的临界年龄. 因为这两个对象加起来已经到达了 512KB, 并且它们是同年龄的, <strong>满足同年对象达到 Survivor 空间一半的规则</strong>. 只要注释掉其中一个对象的 new 操作, 就会发现另外一个就不会晋升到老年代了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * VM 参数: -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
   -XX:MaxTenuringThreshold=15
 * -XX:+PrintTenuringDistribution
 */</span>
<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unused&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testTenuringThreshold2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token punctuation">,</span> allocation3<span class="token punctuation">,</span> allocation4<span class="token punctuation">;</span>
    <span class="token comment">// allocation1+allocation2大于 survivo 空间一半</span>
    allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>_1MB <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
    allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>_1MB <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation4 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>运行结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>[GC [DefNew
Desired Survivor size 524288 bytes, new threshold 1 (max 15)
- age   1:     676824 bytes,     676824 total
: 5115K-&gt;660K(9216K), 0.0050136 secs] 5115K-&gt;4756K(19456K), 0.0050443 secs] [Times: user=0.00 sys=0.01, real=0.01 secs]
[GC [DefNew
Desired Survivor size 524288 bytes, new threshold 15 (max 15)
: 4756K-&gt;0K(9216K), 0.0010571 secs] 8852K-&gt;4756K(19456K), 0.0011009 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
Heap
    def new generation   total 9216K, used 4178K [0x029d0000, 0x033d0000, 0x033d0000)
        eden space 8192K,  51% used [0x029d0000, 0x02de4828, 0x031d0000)
        from space 1024K,   0% used [0x031d0000, 0x031d0000, 0x032d0000)
        to   space 1024K,   0% used [0x032d0000, 0x032d0000, 0x033d0000)
    tenured generation   total 10240K, used 4756K [0x033d0000, 0x03dd0000, 0x03dd0000)
            the space 10240K,  46% used [0x033d0000, 0x038753e8, 0x03875400, 0x03dd0000)
    compacting perm gen  total 12288K, used 2114K [0x03dd0000, 0x049d0000, 0x07dd0000)
        the space 12288K,  17% used [0x03dd0000, 0x03fe09a0, 0x03fe0a00, 0x049d0000)
No shared spaces configured.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h5 id="_6-老年代空间分配担保机制"><a href="#_6-老年代空间分配担保机制" class="header-anchor">#</a> 6.老年代空间分配担保机制</h5> <p><mark><strong>在发生 Minor GC 之前, 虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间, 如果这个条件成立, 那这一次 Minor GC 可以确保是安全的</strong></mark>. 如果不成立, 则虚拟机会先查看 <code>-XX: HandlePromotionFailure</code>​ 参数的设置值<strong>是否允许担保失败</strong>(Handle Promotion Failure); 如果允许, 那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小, 如果大于, 将<mark><strong>尝试进行一次 Minor GC, 尽管这次 Minor GC 是有风险的</strong></mark>; 如果小于, 或者 <code>-XX: HandlePromotionFailure</code>​ 设置<strong>不允许冒险</strong>, 那这时就要改为<mark><strong>进行一次 Full GC</strong></mark>. 这时会对老年代和年轻代一起回收一次垃圾, 如果回收完还是没有足够空间存放新的对象就会发生 &quot;<strong>OOM</strong>&quot;.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220521114637643.png" alt=""></p> <p>解释一下 &quot;冒险&quot; 是冒了什么风险: 前面提到过, 新生代使用复制收集算法, 但为了内存利用率, 只使用其中一个 Survivor 空间来作为轮换备份, 因此当出现大量对象在 Minor GC 后仍然存活的情况, 最极端的情况就是<strong>内存回收后新生代中所有对象都存活, 需要老年代进行分配担保(这就是老年代空间担保机制), 把 Survivor 无法容纳的对象直接送入老年代</strong>, 这与生活中贷款担保类似. 老年代要进行这样的担保, 前提是老年代本身还有容纳这些对象的剩余空间, 但一共有多少对象会在这次回收中活下来在实际完成内存回收之前是无法明确知道的, 所以<strong>只能取之前每一次回收晋升到老年代对象容量的平均大小作为经验值, 与老年代的剩余空间进行比较, 决定是否进行 Full GC 来让老年代腾出更多空间</strong>.</p> <p>这里其实就是<strong>假设</strong>年轻代的<strong>全部对象</strong>都突然一下子放到老年代中, 如果老年代<strong>都能放得下</strong>, 就可以<strong>放心做 Minor GC</strong>了, 因为 Minor GC <strong>最多</strong>也就是把年轻代的全部对象都放到老年代中, 如果不能全部放下, 那就需要考虑一下是<strong>否有必要执行一次 Full GC</strong> 来清理老年代的空间来存放可能到来的年轻代对象了. <strong>担保的含义</strong>就是担保老年代中一定有空间来存放年轻代中可能来的对象.</p> <p><strong>取历史平均值</strong>来比较其实仍然是一种赌概率的解决办法, 也就是说假如某次 Minor GC 存活后的对象突增, 远远高于历史平均值的话, 依然会导致担保失败. 如果出现了担保失败, 那就只好老老实实地重新发起一次 Full GC, 这样停顿时间就很长了. 虽然担保失败时绕的圈子是最大的, 但通常情况下都还是会将 <code>-XX: HandlePromotionFailure</code>​ 开关<strong>打开</strong>, 避免 Full GC 过于频繁.</p> <blockquote><p>空间分配担保示例</p></blockquote> <p>参见下面代码, 请先以 JDK 6 Update 24 之前的 HotSpot 运行测试代码.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * VM 参数: -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:-Handle-
   PromotionFailure
 */</span>
<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unused&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testHandlePromotion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token punctuation">,</span> allocation3<span class="token punctuation">,</span> allocation4<span class="token punctuation">,</span> allocation5<span class="token punctuation">,</span> alloca<span class="token operator">-</span>tion6<span class="token punctuation">,</span> allocation7<span class="token punctuation">;</span>
    allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation1 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
    allocation4 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    allocation5 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    allocation6 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    allocation7 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>以 <code>-XX: HandlePromotionFailure=false</code>​ 参数来运行的结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>[GC [DefNew: 6651K-&gt;148K(9216K), 0.0078936 secs] 6651K-&gt;4244K(19456K), 0.0079192 secs] [Times: user=0.00 sys=0.02, real=0.02 secs]
[GC [DefNew: 6378K-&gt;6378K(9216K), 0.0000206 secs][Tenured: 4096K-&gt;4244K(10240K), 0.0042901 secs] 10474K-&gt;4244K(19456K), [Perm : 2104K-&gt;2104K(12288K)], 0.0043613 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>以 <code>-XX: HandlePromotionFailure=true</code>​ 参数来运行的结果:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>[GC [DefNew: 6651K-&gt;148K(9216K), 0.0054913 secs] 6651K-&gt;4244K(19456K), 0.0055327 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
[GC [DefNew: 6378K-&gt;148K(9216K), 0.0006584 secs] 10474K-&gt;4244K(19456K), 0.0006857 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在 JDK 6 Update 24 之后, 这个测试结果就有了差异, <code>-XX: HandlePromotionFailure</code>​ 参数<strong>不会再影响到虚拟机的空间分配担保策略</strong>, 观察 OpenJDK 中的源码变化(见下面代码清单), 虽然源码中还定义了 <code>-XX: HandlePromotionFailure</code>​ 参数, 但是在实际虚拟机中<strong>已经不会再使用它</strong>. JDK 6 Update 24 之后的<mark><strong>规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小, 就会进行 Minor GC, 否则将进行 Full GC</strong></mark>.</p> <blockquote><p>HotSpot 中空间分配检查的代码片段</p></blockquote> <div class="language-c line-numbers-mode"><pre class="language-c"><code>bool TenuredGeneration<span class="token operator">::</span><span class="token function">promotion_attempt_is_safe</span><span class="token punctuation">(</span><span class="token class-name">size_t</span>
max_promotion_in_bytes<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token comment">// 老年代最大可用的连续空间</span>
    <span class="token class-name">size_t</span> available <span class="token operator">=</span> <span class="token function">max_contiguous_available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 每次晋升到老年代的平均大小</span>
    <span class="token class-name">size_t</span> av_promo <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token function">gc_stats</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">avg_promoted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">padded_average</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 老年代可用空间是否大于平均晋升大小, 或者老年代可用空间是否大于当此 GC 时新生代所有对象容量</span>
    bool res <span class="token operator">=</span> <span class="token punctuation">(</span>available <span class="token operator">&gt;=</span> av_promo<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>available <span class="token operator">&gt;=</span> max_promotion_in_bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="内存泄漏与内存溢出"><a href="#内存泄漏与内存溢出" class="header-anchor">#</a> 内存泄漏与内存溢出</h4> <h5 id="_1-内存泄漏"><a href="#_1-内存泄漏" class="header-anchor">#</a> 1.内存泄漏</h5> <h6 id="_1-基础-4"><a href="#_1-基础-4" class="header-anchor">#</a> (1)基础</h6> <p><strong>指无用对象(不再使用的对象)持续占有内存或无用对象的内存得不到及时释放</strong>, 从而造成的内存空间的浪费称为内存泄露. 某些对象可以关联到 GC Roots 对象, 但是在业务上已经不需要再使用了, 这些对象不会被 GC 所回收, 然而它却占用内存, 这就会导致内存泄漏.</p> <h6 id="_2-内存泄漏原因"><a href="#_2-内存泄漏原因" class="header-anchor">#</a> (2)内存泄漏原因</h6> <p><strong>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露</strong>, 尽管短生命周期对象已经不再需要, 但是<strong>因为长生命周期的对象持有它的引用而导致不能被回收</strong>. 具体主要有如下几大类场景:</p> <blockquote><p>静态集合类</p></blockquote> <p>使用静态集合类, 比如 Set, Vector, HashMap 等集合类的时候需要特别注意. 当这些类被定义成<strong>静态</strong>时, 其生命周期跟应用程序一样长, 这时候就有可能发生内存泄漏.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 例子 </span>
<span class="token keyword">class</span> <span class="token class-name">StaticTest</span> <span class="token punctuation">{</span> 
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Vector</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token class-name">Object</span> object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            v<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            object <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上面的代码中, 循环申请 object 对象, 并添加到 Vector 中, 然后设置 object = null(就是清除栈中引用变量 object), 但是这些对象被 vector 引用着, 必然不能被 GC 回收, 造成内存泄露. 因此要释放这些对象, 还需要将它们从 vector 中删除.</p> <blockquote><p>监听器未释放</p></blockquote> <p>许多场景都需要和监听器打交道, 通常一个应用中会用到很多监听器, 但往往在释放的时候却没有去删除这些监听器, 从而增加了内存泄漏的可能.</p> <blockquote><p>各种连接未关闭</p></blockquote> <p>比如<strong>数据库连接</strong>, 网络连接和 IO 连接等, 除非其显式的调用了其 <strong>close()</strong>  方法将其连接关闭, 否则可能不会自动被 GC 回收.</p> <blockquote><p>内部类和外部模块等的引用</p></blockquote> <p><strong>内部类</strong>的引用是比较容易遗忘的一种, 而且一旦没释放可能导致一系列的后继类对象没有释放. 在调用外部模块的时候, 也应该注意防止内存泄漏, 如果模块 A 调用了外部模块 B 的一个方法, 如 register(Object o), 这个方法有可能就使得 A 模块持有传入对象的引用, 这时候需要查看 B 模块是否提供了出去引用的方法, 这种情况容易忽略, 而且发生内存泄漏的话, 还比较难察觉.</p> <blockquote><p>单例模式</p></blockquote> <p>因为单利对象初始化后将在 JVM 的整个生命周期内存在, 如果它持有一个生命周期比较短的外部对象的引用, 那么这个外部对象就不能被回收, 从而导致内存泄漏. 如果这个外部对象还持有其他对象的引用, 那么内存泄漏更严重.</p> <blockquote><p>native对象</p></blockquote> <p>一些 native 的对象可能造成内存泄漏. 比如 Java 使用 OpenCV 的包进行图像处理, 其中的 Mat 对象需要手动调用其 native 的 release() 方法进行内存释放, 不然可能就会造成内存泄漏.</p> <h5 id="_2-内存溢出"><a href="#_2-内存溢出" class="header-anchor">#</a> 2.内存溢出</h5> <p><strong>内存溢出</strong>: 指程序运行过程中<strong>无法申请到足够的内存</strong>而导致的一种错误, 当内存较小的时候可能正常的业务也会导致内存溢出. <strong>内存泄露是内存溢出的一种诱因</strong>, 不是唯一因素.</p> <p>说白了就是<strong>内存不够</strong>用了, 详细示例参考: OutOfMemoryError异常示例.</p> <h5 id="_3-处理方法"><a href="#_3-处理方法" class="header-anchor">#</a> 3.处理方法</h5> <p>如果是<strong>内存泄漏</strong>, 可进一步通过工具查看泄漏对象到 GC Roots 的引用链. 于是就能找到泄露对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的. 掌握了泄漏对象的类型信息及 GC Roots 引用链的信息, 就可以比较准确的定位出泄漏代码的位置.</p> <p>如果<strong>不存在泄漏</strong>, 换句话说就是内存中的对象确实还必须存活着, 那就应当检查虚拟机的<strong>堆参数</strong>(-Xmx 与 -Xms), 与机器物理内存对比看是否还可以调大, 从代码上检查是否存在某些对象生命周期过长, 持有状态时间过长的情况, 尝试减少的程序运行期的内存消耗.</p> <blockquote><p>排查工具</p></blockquote> <ul><li><strong>MemoryAnalyzer</strong>: 一个功能丰富的 JAVA <strong>堆转储</strong>文件分析工具, 可以发现内存漏洞和减少内存消耗.</li> <li><strong>EclipseMAT</strong>: 是一款开源的 JAVA 内存分析软件, 查找内存泄漏, 能容易找到大块内存并验证谁在一直占用它.</li></ul> <h4 id="本章小结"><a href="#本章小结" class="header-anchor">#</a> 本章小结</h4> <p>本章介绍了垃圾收集的算法, 若干款 HotSpot 虚拟机中提供的垃圾收集器的特点以及运作原理. 通过代码实例验证了 Java 虚拟机中自动内存分配及回收的主要规则.</p> <p>垃圾收集器在许多场景中都是影响系统停顿时间和吞吐能力的重要因素之一, 虚拟机之所以提供多种不同的收集器以及大量的调节参数, 就是因为只有根据实际应用需求, 实现方式选择最优的收集方式才能获取最好的性能. 没有固定收集器, 参数组合, 没有最优的调优方法, 虚拟机也就没有什么必然的内存回收行为. 因此学习虚拟机内存知识, 如果要到实践调优阶段, 必须<strong>了解每个具体收集器的行为, 优势劣势, 调节参数</strong>. 在接下来的两章中, 作者将会介绍内存分析的工具和一些具体调优的案例.</p> <p>‍</p> <h4 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h4> <ul><li>如何阅读GC日志: <a href="https://www.jianshu.com/p/4e508ed55155" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/4e508ed55155<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>《深入理解 Java 虚拟机: JVM 高级特性与最佳实践(第二版》</li> <li><a href="https://my.oschina.net/hosee/blog/644618" target="_blank" rel="noopener noreferrer">https://my.oschina.net/hosee/blog/644618<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://cloud.tencent.com/developer/article/1958285" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1958285<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>‍</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/20.开发/2000.Java/600.JVM/21.垃圾收集器与内存分配策略🌼.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/be0269/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">JVM内存区域与对象解析🌼</div></a> <a href="/pages/3a4c8a/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">JVM性能监控与故障处理工具🌼</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/be0269/" class="prev">JVM内存区域与对象解析🌼</a></span> <span class="next"><a href="/pages/3a4c8a/">JVM性能监控与故障处理工具🌼</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/79.fa10f4e3.js" defer></script>
  </body>
</html>
