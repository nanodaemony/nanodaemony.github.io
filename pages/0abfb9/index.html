<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis基础 | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/156.bcc397ae.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>分布式系统理论</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/129626/" class="sidebar-link">分布式系统基础</a></li><li><a href="/pages/fb5d35/" class="sidebar-link">分布式共识算法</a></li><li><a href="/pages/12ac37/" class="sidebar-link">分布式系统组件</a></li><li><a href="/pages/d03ebf/" class="sidebar-link">分布式技术原理与算法解析(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>系统接入层</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/f1b6c4/" class="sidebar-link">Nginx基础</a></li><li><a href="/pages/d4123d/" class="sidebar-link">深入拆解Tomcat与Jetty(极客时间)🌸</a></li><li><a href="/pages/baee2f/" class="sidebar-link">Netty</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>服务治理-注册发现与RPC</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/05077d/" class="sidebar-link">基础</a></li><li><a href="/pages/51b6aa/" class="sidebar-link">RPC实战与核心原理(极客时间)🌸</a></li><li><a href="/pages/0966ee/" class="sidebar-link">Zookeeper</a></li><li><a href="/pages/3b7e05/" class="sidebar-link">Nacos</a></li><li><a href="/pages/7f31f8/" class="sidebar-link">Dubbo</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>服务治理-流量控制</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/44bfa8/" class="sidebar-link">负载均衡</a></li><li><a href="/pages/4d5a6c/" class="sidebar-link">限流</a></li><li><a href="/pages/e0c561/" class="sidebar-link">熔断</a></li><li><a href="/pages/12ae40/" class="sidebar-link">网关路由</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>服务治理-系统监控与安全</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/8c9210/" class="sidebar-link">系统安全性</a></li><li><a href="/pages/c9bf40/" class="sidebar-link">系统监控组件</a></li><li><a href="/pages/3f3cf7/" class="sidebar-link">运维监控系统实战(极客时间)🌸</a></li><li><a href="/pages/e20e02/" class="sidebar-link">OAuth2.0实战课(极客时间)🌟</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>中间件-消息队列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/96d94c/" class="sidebar-link">消息队列基础</a></li><li><a href="/pages/abf16c/" class="sidebar-link">RabbitMQ</a></li><li><a href="/pages/4fc3f1/" class="sidebar-link">Kafka</a></li><li><a href="/pages/013cfe/" class="sidebar-link">RocketMQ</a></li><li><a href="/pages/ed8d92/" class="sidebar-link">Disruptor</a></li><li><a href="/pages/249149/" class="sidebar-link">消息队列高手课(极客时间)🌟</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>中间件-缓存</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/946847/" class="sidebar-link">缓存基础</a></li><li><a href="/pages/e46d56/" class="sidebar-link">本地缓存</a></li><li><a href="/pages/0abfb9/" aria-current="page" class="active sidebar-link">Redis基础</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/09236a/" class="sidebar-link">Redis持久化</a></li><li><a href="/pages/867f9b/" class="sidebar-link">Redis主从复制</a></li><li><a href="/pages/50cae1/" class="sidebar-link">Redis哨兵</a></li><li><a href="/pages/43b45c/" class="sidebar-link">Redis集群</a></li><li><a href="/pages/a32379/" class="sidebar-link">Redis内存管理与运维</a></li><li><a href="/pages/386037/" class="sidebar-link">Redis核心技术与实战(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>中间件-其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/23044d/" class="sidebar-link">定时任务-XXLJob</a></li><li><a href="/pages/459117/" class="sidebar-link">ES与检索</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>系统设计与优化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/41a845/" class="sidebar-link">凤凰架构</a></li><li><a href="/pages/68cc0b/" class="sidebar-link">左耳听风(极客时间)🌟</a></li><li><a href="/pages/e3e99c/" class="sidebar-link">从0开始学微服务(极客时间)🌸</a></li><li><a href="/pages/1e5368/" class="sidebar-link">高并发系统设计40问(极客时间)🌸</a></li><li><a href="/pages/33599f/" class="sidebar-link">系统性能调优必知必会(极客时间)🌸</a></li><li><a href="/pages/c83472/" class="sidebar-link">后端技术面试38讲(极客时间)</a></li><li><a href="/pages/4404b6/" class="sidebar-link">架构实战案例解析(极客时间)🌸</a></li><li><a href="/pages/8f1c1d/" class="sidebar-link">如何设计一个秒杀系统(极客时间)</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>容器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>容器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/582acf/" class="sidebar-link">部署Minikube</a></li><li><a href="/pages/98e5e4/" class="sidebar-link">容器实战高手课(极客时间)🌸</a></li><li><a href="/pages/c6a42c/" class="sidebar-link">Kubernetes实战🌸</a></li><li><a href="/pages/f35c72/" class="sidebar-link">深入剖析Kubernetes(极客时间)🌸</a></li><li><a href="/pages/caa314/" class="sidebar-link">Istio</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>自动化运维</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/beb97f/" class="sidebar-link">持续集成(CICD)</a></li><li><a href="/pages/a0df2d/" class="sidebar-link">DevOps</a></li><li><a href="/pages/765815/" class="sidebar-link">SRE实战手册(极客时间)</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/middleware/#系统" data-v-06970110>系统</a></li><li data-v-06970110><a href="/middleware/#系统" data-v-06970110>系统</a></li><li data-v-06970110><a href="/middleware/#中间件-缓存" data-v-06970110>中间件-缓存</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">Redis基础<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_30-redis基础"><a href="#_30-redis基础" class="header-anchor">#</a> 30.Redis基础</h1> <h4 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h4> <h5 id="_1-概述"><a href="#_1-概述" class="header-anchor">#</a> 1.概述</h5> <p>Redis 是<strong>非关系型(NoSQL) 内存键值数据库</strong>.</p> <h6 id="_1-redis特性"><a href="#_1-redis特性" class="header-anchor">#</a> (1)Redis特性</h6> <ul><li><strong>速度快</strong>: 单线程模型, 数据都在内存中.</li> <li>基于<strong>键值对</strong>的数据结构服务器: NoSQL 非关系型.</li> <li>功能丰富: 缓存, 发布订阅, Lua 脚本, 简单事务, 流水线.</li> <li><strong>可以持久化</strong>: RDB 和 AOF.</li> <li><strong>主从复制</strong>: 实现数据多个副本.</li> <li><strong>高可用与分布式</strong>: Redis Sentinel, Redis Cluster.</li></ul> <blockquote><p>Redis与Memcached对比</p></blockquote> <p>两者都是<strong>非关系型内存键值数据库</strong>, 主要有以下不同:</p> <ul><li><strong>数据类型</strong>. Memcached <strong>仅支持字符串类型</strong>, 而 Redis 支持五种不同的数据类型, 应用场景丰富.</li> <li><strong>数据持久化</strong>. Redis 支持两种持久化策略: <strong>RDB 快照和 AOF 日志</strong>, 而 Memcached <strong>不支持</strong>持久化.</li> <li><strong>分布式</strong>. Memcached <strong>不支持分布式</strong>, 只能通过在客户端使用<strong>一致性哈希</strong>来实现分布式存储, 这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点. Redis Cluster 提供<strong>分布式</strong>的支持.</li> <li><strong>内存管理机制</strong>. 在 Redis 中, 并不是所有数据都一直存储在内存中, 可以将一些<strong>很久没用的 value 交换到磁盘</strong>, 而 Memcached 的数据则会<strong>一直</strong>在内存中. Memcached 将内存分割成<strong>特定长度的块</strong>来存储数据, 以完全解决内存碎片的问题. 但这种方式会使得内存的利用率不高, 例如块的大小为 128 bytes, 只存储 100 bytes 的数据, 那么剩下的 28 bytes 就浪费掉了.</li></ul> <h6 id="_2-redis应用场景"><a href="#_2-redis应用场景" class="header-anchor">#</a> (2)Redis应用场景</h6> <ul><li><strong>缓存</strong>: 将热点数据放到<strong>内存</strong>中, 设置内存的<strong>最大使用量</strong>以及<strong>淘汰策略</strong>来保证缓存命中率. (1)<strong>缓存热点数据</strong>: 缓存热点数据, 可以降低数据库压力. (2)<strong>缓存 Session</strong>: 可以使用 Redis 来统一存储多台应用服务器的<strong>会话信息</strong>. 当应用服务器不再存储用户的会话信息, 使得服务器<strong>无状态</strong>, 一个用户可以请求任意一个应用服务器, 从而更容易实现高可用性以及<strong>可伸缩性</strong>.</li> <li><strong>分布式锁实现</strong>: 可以使用 Redis 自带的 <strong>SETNX 命令</strong>实现分布式锁, 也可以使用官方提供的 <strong>RedLock 分布式锁</strong>实现.</li> <li><strong>社交网络</strong>: Set 可以实现交集, 并集等操作, 从而实现<strong>共同好友</strong>等功能.</li> <li><strong>排行榜系统</strong>: ZSet 可以实现<strong>有序性</strong>操作, 从而实现<strong>排行榜</strong>等功能.</li> <li><strong>计数器</strong>: 可以对 <strong>String</strong> 进行自增自减运算, 从而实现计数器功能. Redis 这种内存型数据库的读写性能非常高, 很适合<strong>存储频繁读写的计数量</strong>. 比如视频的播放量, 商品浏览次数等.</li> <li><strong>查找表</strong>: 例如 <strong>DNS</strong> 记录就很适合使用 Redis 进行存储. 查找表和缓存类似, 也是利用了 <strong>Redis 快速</strong>的查找特性. 但查找表的内容不能失效, 而缓存的内容可以失效, 因为缓存不作为可靠的数据来源.</li> <li><strong>附近位置, 摇一摇</strong>: Redis 的 GEO 功能可以用于实现附近位置, 摇一摇这种基于位置信息的功能.</li></ul> <h5 id="_2-命令与架构基础🌟"><a href="#_2-命令与架构基础🌟" class="header-anchor">#</a> 2.命令与架构基础🌟</h5> <h6 id="_1-单线程架构"><a href="#_1-单线程架构" class="header-anchor">#</a> (1)单线程架构</h6> <p>Redis 是<strong>单线程架构</strong>, 单线程没有并发问题.</p> <p>注意 Redis 的<mark><strong>单线程主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的, 这也是 Redis 对外提供键值存储服务的主要流程</strong></mark>. 但 Redis 的其他功能, 比如持久化, 异步删除, 集群数据同步等, 其实是由额外的线程执行的.</p> <blockquote><p>为什么单线程还能这么快?</p></blockquote> <p>原因如下:</p> <ul><li><strong>纯内存访问</strong>. Redis 数据都存放在<strong>内存</strong>中, 访问速度极快.</li> <li><strong>IO 多路复用架构</strong>. Redis 使用 <strong>epoll 作为 IO 多路复用的实现</strong>, 再加上 Redis 自身的事件处理模型将 <strong>epoll</strong> 中的连接, 读写, 关闭等都转化为事件, 在 IO 上浪费时间少.</li> <li><strong>单线程架构</strong>. 简化了数据结构和算法实现, 同时<strong>单线程避免了线程切换</strong>的竞争产生的开销.</li></ul> <blockquote><p>单线程可能引发的问题?</p></blockquote> <p>正因为 Redis 是单线程, 所以要小心使用 Redis 指令, <strong>对于那些耗时的指令(比如 keys), 一定要谨慎使用</strong>, 一不小心就可能会导致 Redis 卡顿. 如果每个命令<strong>执行时间过长</strong>, 会造成其他命令的<strong>阻塞</strong>, 这非常难受.</p> <h6 id="_2-命令执行基本流程"><a href="#_2-命令执行基本流程" class="header-anchor">#</a> (2)命令执行基本流程</h6> <p>Redis 的 IO 多路复用: Redis 利用 epoll 来实现 IO 多路复用, 将连接信息和事件放到队列中, 依次放到文件事件分派器, 事件分派器将事件分发给事件处理器.</p> <p><img src="/img/image-20231226230320-7gvfrv4.png" alt="image"></p> <p>Redis 命令执行流程如下图.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20211218115418923.png" alt="" title="Redis命令执行流程"></p> <ul><li><strong>发送命令</strong></li> <li><strong>命令排队</strong></li> <li><strong>执行命令</strong></li> <li><strong>返回结果</strong></li></ul> <p>其中 <strong>发送命令 + 响应结果</strong> 是通过<strong>网络</strong>进行的, 使用命令时应尽量<strong>减少这个次数</strong>. 由于是<strong>单线程</strong>架构, 所以如果命令过多或者前面的命令执行阻塞着, 后面的命令需要在队列中<strong>排队执行</strong>. <strong>慢查询</strong>主要统计<strong>执行命令</strong>的时间.</p> <h4 id="基本命令"><a href="#基本命令" class="header-anchor">#</a> 基本命令</h4> <h5 id="_1-全局命令🌟"><a href="#_1-全局命令🌟" class="header-anchor">#</a> 1.全局命令🌟</h5> <p>一些常见的全部数据结构都<strong>通用</strong>的命令.</p> <table><thead><tr><th style="text-align:center;">命令</th> <th style="text-align:center;">释义</th></tr></thead> <tbody><tr><td style="text-align:center;">**keys ***</td> <td style="text-align:center;">查看所有键, 复杂度 O(N), <strong>会遍历所有键, 线上禁止使用</strong></td></tr> <tr><td style="text-align:center;"><strong>dbsize</strong></td> <td style="text-align:center;">获取键总数, 不会遍历所有键, 直接从遍历获取, 复杂度 O(1)</td></tr> <tr><td style="text-align:center;"><strong>exists key</strong></td> <td style="text-align:center;">查看<strong>键是否存在</strong></td></tr> <tr><td style="text-align:center;"><strong>del key [key ...]</strong></td> <td style="text-align:center;"><strong>删除键</strong>, 可同时删多个键</td></tr> <tr><td style="text-align:center;"><strong>expire key seconds</strong></td> <td style="text-align:center;">对键添加<strong>过期时间</strong>, 返回大于等于 0 即是过期时间, -1 是没有设置, -2 是键不存在</td></tr> <tr><td style="text-align:center;"><strong>ttl key</strong></td> <td style="text-align:center;">查看键剩余的<strong>过期时间</strong></td></tr> <tr><td style="text-align:center;"><strong>type key</strong></td> <td style="text-align:center;">查看键的<strong>数据结构</strong></td></tr> <tr><td style="text-align:center;"><strong>object encoding key</strong></td> <td style="text-align:center;">获取键的<strong>内部编码</strong></td></tr></tbody></table> <h5 id="_2-键管理命令"><a href="#_2-键管理命令" class="header-anchor">#</a> 2.键管理命令</h5> <h6 id="_1-单个键管理"><a href="#_1-单个键管理" class="header-anchor">#</a> (1)单个键管理</h6> <blockquote><p>键过期</p></blockquote> <p>与键过期相关的指令.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>expire key seconds		<span class="token comment"># 键在seconds秒后过期</span>
expire key timestamp	<span class="token comment"># 键在秒级时间戳timestamp后过期</span>
ttl key				    <span class="token comment"># 查看键过期剩余时间, 秒级(ttl = time to leave)</span>
pttl key			    <span class="token comment"># 查看键过期剩余时间, 毫秒级</span>
expireat key timestamp	<span class="token comment"># 设置键的秒级过期时间戳</span>
pexpire key milliseconds	<span class="token comment"># 键在milliseconds毫秒后过期</span>
setex 				    <span class="token comment"># 设置键并设置过期时间, 多用! ! </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>返回值的含义:</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>大于等于 <span class="token number">0</span> 的整数: 键剩余过期时间
-1: 键没有设置过期时间
-2: 键不存在
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>与过期相关的命令需要<strong>注意</strong>:</p> <ul><li>如果 expire key 不存在, 返回结果为 0.</li> <li>如果设置过期时间为负值, 键会立即被删除, 犹如使用了 del 命令一样.</li> <li>persist 命令可以将键的<strong>过期时间清除</strong>, 清除后 ttl 变为 -1, 这样键就不会过期了.</li> <li>对于<strong>字符串类型的键</strong>, 执行 <strong>set 命令</strong>会<strong>去掉</strong>过期时间(ttl 变为 -1), 这在开发中很容易被忽视. <strong>setex 命令</strong>做为 <strong>set + expire</strong> 命令的组合, 即是原子命令, 且少了一次网络时间, 开发多用! !</li> <li>Redis <strong>不支持二级数据结构</strong>(如 hash, list) <strong>内部元素的过期功能</strong>. 如不能对 hash 中某个元素设置过期.</li></ul> <blockquote><p>迁移键</p></blockquote> <p>有三种方式:</p> <ul><li>move: 不建议使用. 仅在实例内部用.</li> <li><strong>dump + restore</strong>: dump 会将键值序列化, 采用 RDB 格式. restore 将序列化的数据还原.</li> <li><strong>migrate</strong>: 实际就是将 dump, restore, del 三个命令进行组合, 从而简化了流程, 而且具有原子性. <strong>推荐使用</strong>.</li></ul> <table><thead><tr><th style="text-align:center;">命令</th> <th style="text-align:center;">作用域</th> <th style="text-align:center;">原子性</th> <th style="text-align:center;">支持多个键</th></tr></thead> <tbody><tr><td style="text-align:center;">move</td> <td style="text-align:center;">Redis 实例内部</td> <td style="text-align:center;">是</td> <td style="text-align:center;">否</td></tr> <tr><td style="text-align:center;">dump + restore</td> <td style="text-align:center;">Redis 实例之间</td> <td style="text-align:center;">否</td> <td style="text-align:center;">否</td></tr> <tr><td style="text-align:center;"><strong>migrate</strong></td> <td style="text-align:center;"><strong>Redis 实例之间</strong></td> <td style="text-align:center;"><strong>是</strong></td> <td style="text-align:center;"><strong>是</strong></td></tr></tbody></table> <h6 id="_2-遍历键"><a href="#_2-遍历键" class="header-anchor">#</a> (2)遍历键</h6> <p>提供了两种遍历键的方式: <strong>keys 和 scan</strong>.</p> <blockquote><p>keys全量遍历键</p></blockquote> <p>全量遍历键, 用来列出所有满足特定正则字符串规则的 key.</p> <p>注意: 如果包含<strong>大量的键</strong>, 就可能会造成 Redis <strong>阻塞</strong>! <strong>生产环境别用</strong>!</p> <blockquote><p>scan渐进式遍历键</p></blockquote> <p>采用 scan 命令以<strong>渐进式</strong>的方式遍历键, 以<strong>解决 keys 指令可能造成的阻塞问题</strong>, 每次 scan 命令的时间<strong>复杂度是 O(1)</strong> . 每次执行 scan 可以想象成只扫描一个字典中的<strong>一部分键</strong>, 直到将字典中的所有键遍历完成.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>scan cursor <span class="token punctuation">[</span>match pattern<span class="token punctuation">]</span> <span class="token punctuation">[</span>count number<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>参数如下:</p> <ul><li><strong>cursor: 游标</strong>, 必备参数. 第一次遍历从 0 开始, 每次 scan 遍历完会返回当前的 <strong>cursor</strong> 值, 直到其值为 0, 表示遍历结束.</li> <li>match pattern: 匹配模式(正则模式), 可选.</li> <li>count number: 每次要遍历的键的个数, 默认 10.</li></ul> <p>注意: 每次 scan 完成都会返回上一次遍历的游标值, 下一次请求时<strong>携带</strong>上从这个 cursor 开始遍历. 注意: 如果 scan 过程中如果有键的增删等变化, 可能会造成键的遍历<strong>不完全或重复的问题</strong>. 可能出现新增的键可能没有遍历到, 遍历出了重复的键等情况, 也就是说 scan 并不能保证完整的遍历出来所有的键, 这些是在开发时需要考虑的.</p> <p>此外还有其他集合类型的遍历指令. 如 <strong>hscan, sscan, zscan</strong> 等来解决 hgetall, smembers, zrange 等可能带来的阻塞问题.</p> <h4 id="基础数据结构🌟"><a href="#基础数据结构🌟" class="header-anchor">#</a> 基础数据结构🌟</h4> <h5 id="_1-string"><a href="#_1-string" class="header-anchor">#</a> 1.String</h5> <p>非常重要, 其他的都是基于这个来的. 字符串类型的<strong>值</strong>可以是: <strong>简单字符串, 复复杂字符串(JSON, XML等), 数字(整数, 浮点数), 甚至是二进制(图片, 视频, 音频等)</strong> , 最大 512M.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522192440962.png" alt=""></p> <h6 id="基本命令-2"><a href="#基本命令-2" class="header-anchor">#</a> 基本命令</h6> <p><strong>(1)设置值</strong></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">set</span> key value <span class="token punctuation">[</span>ex seconds<span class="token punctuation">]</span> <span class="token punctuation">[</span>px milliseconds<span class="token punctuation">]</span> <span class="token punctuation">[</span>nx<span class="token operator">|</span>xx<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><strong>ex seconds</strong>: 设置<strong>秒级</strong>过期时间.</li> <li><strong>px milliseconds</strong>: 设置<strong>毫秒级</strong>过期时间.</li> <li><strong>nx</strong>: 键必须<strong>不存在</strong>才可以设置成功, 用于<strong>添加</strong>.</li> <li><strong>xx</strong>: 键必须<strong>存在</strong>才可以设置成功, 用于<strong>更新</strong>.</li></ul> <p>除 set 之外, 还有两个命令: <strong>setex</strong>, <strong>extnx</strong>. 其作用与上述的 ex 和 nx 选项相同.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>setex key seconds value
setnx key value
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>setnx的应用</p></blockquote> <p>由于 Redis 的<strong>单线程</strong>机制, 如果<strong>多个</strong>客户端同时执行 setex key seconds value, 根据 setnx 的特性则<strong>只有一个</strong>客户端能够设置成功, 所以 setnx 可以作为<strong>分布式锁</strong>的一种实现方案.</p> <p><strong>(2)获取值</strong></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>get key	  <span class="token comment"># 键不存在返回nil</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>(3)批量设置值</strong></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>mset key value <span class="token punctuation">[</span>key value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>	<span class="token comment"># 一次性设置多个值</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>(4)批量获取值</strong></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>mget key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
mget a b c d
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>批量设置与获取可以提高效率, 因为如果执行 N 次单个 get 命令会在网络中<strong>往返 N 次</strong>, 而批量操作只会在网络中<strong>往返 1 次</strong>, 可以<strong>减少 Redis 或网络阻塞</strong>.</p> <p><strong>(5)计数</strong></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>incr key
decr key
incrby key increment
decrby key decrement
incrbyfloat key increment
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>可以自增, 自减, 设置增量</strong>. Redis 由于其<strong>单线程</strong>架构, 计数的时候贼方便, 都<strong>不需要使用 CAS 来保证计数准确性</strong>. 比如可以记录某文章, 视频被点赞的次数.</p> <p><strong>(6)其他</strong></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>append key value   	<span class="token comment"># 在字符串后面追加value, 变长</span>
strlen key		    <span class="token comment"># 字符串长度</span>
getset key value	<span class="token comment"># 设置并返回原值, 返回键原来的值</span>
getrange key start end  <span class="token comment"># 获取部分字符串</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h6 id="内部编码"><a href="#内部编码" class="header-anchor">#</a> 内部编码</h6> <p>Redis 会根据当前值的<strong>类型和长度</strong>决定使用哪种内部编码实现.</p> <ul><li><strong>int</strong>: 8 字节的长整形.</li> <li><strong>embstr</strong>: 小于等于 39 个字节的字符串.</li> <li><strong>raw</strong>: 大于 39 个字节的字符串.</li></ul> <h6 id="使用场景"><a href="#使用场景" class="header-anchor">#</a> 使用场景</h6> <p><strong>缓存功能</strong>: 推荐的键名定义方式: <strong>业务名:对象名🆔[属性]</strong> .</p> <p><strong>计数</strong>: 快速计数, 查询缓存, 比如实现<strong>视频播放数计数</strong>.</p> <p><strong>共享 session</strong>: 使用 Redis 存储各个 Web 服务器的 <strong>session</strong> 信息, 集中管理.</p> <p><strong>限速</strong>: 防止短信功接口不被频繁访问, 限制一分钟内只能请求一次. 限制一个 IP 地址在一分钟内的访问次数.</p> <h5 id="_2-hash"><a href="#_2-hash" class="header-anchor">#</a> 2.Hash</h5> <p>结构如下, KEY 里面的 <strong>value</strong> 才包含<strong>真正的 key 和 value</strong>. 可以看成一个双层的 map.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522192945126.png" alt=""></p> <p>Hash 类型的<strong>值</strong>本身又是一个<strong>键值对结构</strong>. 注意业务重点关注 <code>Filed : Value</code>​ 关系.</p> <h6 id="基本命令-3"><a href="#基本命令-3" class="header-anchor">#</a> 基本命令</h6> <p><strong>(1)设置值</strong></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>hset key field value
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-bash line-numbers-mode"><pre class="language-bash"><code>hest user:1 name tom
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>(2)获取值</strong></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>hget key field
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-bash line-numbers-mode"><pre class="language-bash"><code>hget user:1 name
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>(3)删除field</strong></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>hdel key field <span class="token punctuation">[</span>field <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>可以批量删除 field.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>hdel user:1 name address class
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>(4)计算field个数</strong></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>hlen key
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>(5)批量设置与获取</strong></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>hmget key field <span class="token punctuation">[</span>field <span class="token punctuation">..</span>.<span class="token punctuation">]</span>		<span class="token comment"># 批量获取</span>
hmset key field value <span class="token punctuation">[</span>field value<span class="token punctuation">..</span>.<span class="token punctuation">]</span>  <span class="token comment"># 批量设置</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>(6)判断filed是否存在</strong></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>hexists key field
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>(7)其他</strong></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>hkeys key  		<span class="token comment"># 获取所有field</span>
hvals key		<span class="token comment"># 获取所有value</span>
hgetall key		<span class="token comment"># 获取所有的field-value, 即返回Map</span>
hincrby key field 	<span class="token comment"># 自增, 作用在field上</span>
hincrbyfloat key field  <span class="token comment"># 自增</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h6 id="内部编码-2"><a href="#内部编码-2" class="header-anchor">#</a> 内部编码</h6> <ul><li><strong>ziplist</strong>(压缩列表): 当 filed <strong>个数少</strong>且没有大的 value 时使用.</li> <li><strong>hashtable</strong>(哈希表): 当 filed 个数多或有大的 value 时使用.</li></ul> <p>ziplist 更加<strong>紧凑</strong>, 在数据量较少时可以连续存储元素, 更节约内存.</p> <h6 id="使用场景-2"><a href="#使用场景-2" class="header-anchor">#</a> 使用场景</h6> <p><strong>(1)缓存用户信息</strong></p> <p>实现方式:</p> <ul><li>序列化字符串类型: 将用户信息序列号之后用一个键保存(需要反序列化).</li> <li>使用 hash: 只用一个键保存 id, 用户信息用 field-value 保存.</li></ul> <p>可以用于记录的<strong>用户信息</strong>, 比如 key 是用户的 id, field 是用的信息(如名字, 学校等), value 是信息的值. 好处: hash 是紧凑的, 有这个值才设置, 而关系型数据库是稀疏的.</p> <p>(2)购物车场景</p> <p>以用户 id 为 key, 商品 id 为 filed, 商品数量为 value.</p> <h6 id="再哈希"><a href="#再哈希" class="header-anchor">#</a> 再哈希</h6> <p>Redis 中的字典相当于 Java 中的 <strong>HashMap</strong>, 内部实现也差不多类似, 都是通过  <strong>&quot;数组 + 链表&quot;</strong>  的链地址法来解决部分 <strong>哈希冲突</strong>, 同时这样的结构也吸收了两种不同数据结构的优点.</p> <p><strong>实际上 hash 结构的内部包含两个 hashtable</strong>, 通常情况下<strong>只有一个</strong> hashtable 是<strong>有值</strong>的, 但是在字典扩容缩容时, 需要分配新的 hashtable, 然后进行<strong>渐进式搬迁</strong>.</p> <p>大字典的扩容是比较耗时间的, 需要<strong>重新申请新的数组</strong>, 然后将<strong>旧字典</strong>所有链表中的元素重新挂接到新的数组下面, 这是一个 <strong>O(N) 级别</strong>的操作, 作为单线程的 Redis 很难承受这样耗时的过程, 所以 Redis 使用 <strong>渐进式 rehash</strong> 小步搬迁:</p> <p><img src="/img/image-20230217001625-ruu5qo1.png" alt="image"></p> <p>渐进式 rehash 会在 rehash 的同时, 保留<strong>新旧两个 hash 结构</strong>, 如上图所示. 如果正在迁移那么查询时会<strong>同时查询两个 hash 结构</strong>, 然后在后续的定时任务以及 hash 操作指令中, 循序渐进的把旧字典的内容迁移到新字典中. 当搬迁完成了, 就会使用新的 hash 结构取而代之.</p> <h6 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h6> <p><strong>过期功能不能使用在 field 上, 只能用到 key 上</strong>.</p> <p>Redis 的集群架构下不适合大规模的使用, 需要注意某些热点的 key 被集中分配到某个结点, 导致结点压力大.</p> <h5 id="_3-list"><a href="#_3-list" class="header-anchor">#</a> 3.List</h5> <p>列表用于存储多个<strong>有序</strong>的字符串, 每个字符串称为元素. 由于元素是<strong>有序</strong>的, 所以可以通过<strong>索引</strong>来访问元素或者进行<strong>范围访问</strong>. 可以充当栈与队列的角色.</p> <p>列表从左到右索引为 <strong>0 ~ N - 1</strong>, 从右到左为  <strong>-1 ~ -N</strong>.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522210259629.png" alt=""></p> <h6 id="基本命令-4"><a href="#基本命令-4" class="header-anchor">#</a> 基本命令</h6> <p><strong>(1)插入元素</strong></p> <p><strong>左右两边</strong>插入元素: 插入两端.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>lpush key value <span class="token punctuation">[</span>value<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
rpush key value <span class="token punctuation">[</span>value<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>指定位置处</strong>插入元素: 找到<strong>等于 pivot</strong> 的元素并在前或后插入元素.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>linsert key before<span class="token operator">|</span>after pivot value
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>(2)查找元素</strong></p> <p>获取指定范围元素.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>lrange key start end 
lrange key <span class="token number">0</span> <span class="token parameter variable">-1</span> 	<span class="token comment"># 列出全部元素</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>获取列表指定索引下标的元素.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>lindex key index
lindex name <span class="token parameter variable">-1</span>	<span class="token comment"># 获取最后一个元素</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>获取列表长度.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>llen key
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>(3)删除元素</strong></p> <p>左右两边弹出删除.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>lpop key
rpop key
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>按照索引范围修建列表.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>ltrim key start end
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>(4)修改元素</strong></p> <p>修改指定索引处的元素.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>lset key index newValue
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>(5)阻塞弹出</strong></p> <p>阻塞式弹出元素. 从左右阻塞式弹出元素, 即普通弹出的阻塞版本.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>blpop key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token function">timeout</span>
brpop key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token function">timeout</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>key [key...]</strong> : 多个列表的键. <strong>timeout</strong>: 阻塞时间.</p> <ul><li>若列表为空, timeout = 3, 则客户端等待 3 秒后返回, 若 timeout = 0, 则此时客户端一直阻塞等下去. 若等待期间插入元素则立即返回.</li> <li>列表不为空, 立即返回.</li></ul> <blockquote><p>使用brpop需要注意的点</p></blockquote> <p>如果是多个键, 那么 brpop 会从左到右遍历键, 一旦有一个键能弹出元素, 客户端立即返回. 如果多个客户端对一个同一个键执行 brpop, 那么最先执行 brpop 命令的客户端可以先获取到弹出值. 然后后面的继续阻塞.</p> <h6 id="内部编码-3"><a href="#内部编码-3" class="header-anchor">#</a> 内部编码</h6> <ul><li><strong>ziplist</strong>: <strong>压缩列表</strong>. 元素少且元素长度小时使用, 减少内存消耗.</li> <li><strong>linkedlist</strong>: <strong>链表</strong>. 元素多使用.</li></ul> <h6 id="使用场景-3"><a href="#使用场景-3" class="header-anchor">#</a> 使用场景</h6> <p><strong>(1)消息队列</strong></p> <p>使用 <strong>lpush + brpop</strong> 可以实现<strong>阻塞队列</strong>, 生产者客户端使用 lpush 生产, 多个消费者客户端从使用 brpop 命令阻塞式 &quot;抢&quot; 列表中的元素, 多个客户端保证了消费的负载均衡和高可用.</p> <ul><li><strong>lpush + lpop = Stack</strong>(栈)</li> <li><strong>lpush + rpop = Queue</strong>(队列)</li> <li>lpush + ltrim = Capped Collection(有限集合)</li> <li><strong>lpush + brpop = Message Queue</strong>(消息队列)</li></ul> <p><strong>(2)消息流类的场景</strong></p> <p>每个<strong>用户的文章列表</strong>用 list 存储, 然后可以分页获取列表. 还可以应用到微博, 微信公众号等的消息流.</p> <h5 id="_4-set"><a href="#_4-set" class="header-anchor">#</a> 4.Set</h5> <p>用于保存多个字符串元素, 与列表不同, set 中元素<strong>不能重复</strong>, 并且集合中元素是<strong>无序</strong>的. 除增删改查之外还可以做多个集合的<strong>交集, 并集, 差集</strong>.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522210816969.png" alt=""></p> <h6 id="基本命令-5"><a href="#基本命令-5" class="header-anchor">#</a> 基本命令</h6> <blockquote><p>集合内操作</p></blockquote> <p>添加元素.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>sadd key element <span class="token punctuation">[</span>element<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>删除元素.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>srem key element <span class="token punctuation">[</span>element<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>计算元素个数: 是 <strong>O(1)</strong>  的命令, 不会遍历集合的元素, 而是直接用 Redis 的内部计数变量.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>scard key
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>判断元素是否在集合中</strong>: 是则返回 1, 不是返回 0.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>sismember key element
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>随机返回集合汇总指定个数元素, <strong>默认返回一个, 不删除元素</strong>.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>srandmember key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>从集合<strong>随机弹出元素</strong>, 并且删除该元素.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>spop key
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>获取所有元素, 结果无序</strong>. 是比较重的指令, 元素过多会<strong>阻塞</strong>.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>smembers key
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>集合间操作</p></blockquote> <p>求多个集合的<strong>交集</strong>.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>sinter key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>求多个集合的<strong>并集</strong>.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>sunion key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>求多个集合的<strong>差集</strong>. 以第一个集合为基准, 减去后面所有集合的并集, 最后看第一个集合还剩多少元素.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">sdiff</span> key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>将<strong>结果进行保存</strong>. 将集合间交集, 并集, 差集的结果保存在 destination key 中.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>sinterstore destination key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
sunionstore destination key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
sdiffstore destination key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h6 id="内部编码-4"><a href="#内部编码-4" class="header-anchor">#</a> 内部编码</h6> <ul><li><strong>intset</strong>: 元素是整数且个数较少时使用.</li> <li><strong>hashtable</strong>: 元素较多或不全是整数时使用.</li></ul> <h6 id="使用场景-4"><a href="#使用场景-4" class="header-anchor">#</a> 使用场景</h6> <p><strong>(1)标签</strong></p> <p>集合类型的典型场景是<strong>标签</strong>. 比如一个用户的兴趣点就是标签, 使用集合间的交并差就可以用在<strong>社交</strong>上, 比如计算<strong>共同兴趣</strong>.</p> <ul><li>sadd = Tagging(标签)</li> <li>spop/srandmember = Random item(生成随机数, 比如抽奖)</li> <li>sadd + sinter = Social Graph(<strong>社交需求</strong>)</li></ul> <p>(2)抽奖</p> <p>srandmember 和 spop 等弹出元素的命令可以用于抽奖的场景.</p> <p>(3)<strong>社交关注模型</strong></p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span><span class="token punctuation">)</span> 诸葛关注的人: 
zhugeSet -<span class="token operator">&gt;</span> <span class="token punctuation">{</span>guojia, xushu<span class="token punctuation">}</span>
<span class="token number">2</span><span class="token punctuation">)</span> 杨过关注的人:
yangguoSet -<span class="token operator">&gt;</span> <span class="token punctuation">{</span>zhuge, baiqi, guojia, xushu<span class="token punctuation">}</span>
<span class="token number">3</span><span class="token punctuation">)</span> 郭嘉关注的人: 
guojiaSet -<span class="token operator">&gt;</span> <span class="token punctuation">{</span>zhuge, yangguo, baiqi, xushu, xunyu<span class="token punctuation">)</span>
<span class="token number">4</span><span class="token punctuation">)</span> 我和杨过共同关注<span class="token punctuation">(</span>求交集<span class="token punctuation">)</span>: 
SINTER zhugeSet yangguoSet -<span class="token operator">&gt;</span> <span class="token punctuation">{</span>guojia, xushu<span class="token punctuation">}</span>
<span class="token number">5</span><span class="token punctuation">)</span> 我关注的人也关注他<span class="token punctuation">(</span>杨过<span class="token punctuation">)</span>: 
SISMEMBER guojiaSet yangguo 
SISMEMBER xushuSet yangguo
<span class="token number">6</span><span class="token punctuation">)</span> 我可能认识的人<span class="token punctuation">(</span>一种简单的实现<span class="token punctuation">)</span>: 
SDIFF yangguoSet zhugeSet -<span class="token operator">&gt;</span> <span class="token punctuation">{</span>zhuge, baiqi<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h5 id="_5-zset"><a href="#_5-zset" class="header-anchor">#</a> 5.Zset</h5> <p>Zset 在 <strong>Set 类型</strong>的基础上增加了一个<strong>分数</strong>, 其特性为<strong>元素不可重复且多了排序的功能</strong>. 元素不能重复但是 <strong>score 可以重复</strong>.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522210935147.png" alt=""></p> <p>比较一下 列表, 集合, 有序集合.</p> <table><thead><tr><th style="text-align:center;">数据结构</th> <th style="text-align:center;">是否允许元素重复</th> <th style="text-align:center;">是否有序</th> <th style="text-align:center;">有序实现方式</th> <th style="text-align:center;">应用场景</th></tr></thead> <tbody><tr><td style="text-align:center;"><strong>List</strong></td> <td style="text-align:center;">是</td> <td style="text-align:center;">是</td> <td style="text-align:center;">索引下标</td> <td style="text-align:center;"><strong>时间轴, 消息队列</strong>等</td></tr> <tr><td style="text-align:center;"><strong>Set</strong></td> <td style="text-align:center;">否</td> <td style="text-align:center;">否</td> <td style="text-align:center;">无</td> <td style="text-align:center;"><strong>标签, 社交系统</strong>等</td></tr> <tr><td style="text-align:center;"><strong>Zset</strong></td> <td style="text-align:center;">否</td> <td style="text-align:center;">是</td> <td style="text-align:center;">分数值</td> <td style="text-align:center;"><strong>排行榜系统</strong>等.</td></tr></tbody></table> <h6 id="命令"><a href="#命令" class="header-anchor">#</a> 命令</h6> <blockquote><p>集合内操作</p></blockquote> <p>添加成员.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>zadd key score member <span class="token punctuation">[</span>score member<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>计算成员<strong>个数</strong>.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>zcard key
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>计算某个成员<strong>分数</strong>.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>zscore key member
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>计算成员<strong>排名</strong>.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>zrank key member	<span class="token comment"># 从低到高排名</span>
zrevrank key member	<span class="token comment"># 从高到低排名</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>删除成员.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>zrem key member <span class="token punctuation">[</span>member<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>增加成员分数</strong>.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>zincrby key increment member
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>返回<strong>指定排名范围</strong>的成员.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>zrange key start end <span class="token punctuation">[</span>withscores<span class="token punctuation">]</span>	    <span class="token comment"># 从低到高返回</span>
zrevrank key start end <span class="token punctuation">[</span>withscores<span class="token punctuation">]</span> 	<span class="token comment"># 从高到低返回</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>返回<strong>指定分数范围</strong>的成员, 也有正反两种方式.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>zrangescore key min max <span class="token punctuation">[</span>withscores<span class="token punctuation">]</span> <span class="token punctuation">[</span>limit offset count<span class="token punctuation">]</span>
zrevrankscore key min max <span class="token punctuation">[</span>withscores<span class="token punctuation">]</span> <span class="token punctuation">[</span>limit offset count<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>返回指定分数范围成员的<strong>个数</strong>.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>zcount key min max
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>删除指定<strong>排名内</strong>的升序元素.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>zremrangebyrank key start end
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>删除指定<strong>分数范围</strong>的成员.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>zremrangebyscore key start end
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>集合间操作</p></blockquote> <p>两集合交集.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>zinterstore destination numkeys key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token punctuation">[</span>weights weight <span class="token punctuation">[</span>weight<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>aggregate <span class="token function">sum</span><span class="token operator">|</span>min<span class="token operator">|</span>max<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>两集合并集. 如果每个 key 表示一天的搜索排行, 那么 zunionstore 可以用于计算七日总搜索的<strong>排行前十</strong>的场景.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>zunionstore destination numkeys key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token punctuation">[</span>weights weight <span class="token punctuation">[</span>weight<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>aggregate <span class="token function">sum</span><span class="token operator">|</span>min<span class="token operator">|</span>max<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h6 id="内部编码-5"><a href="#内部编码-5" class="header-anchor">#</a> 内部编码</h6> <ul><li><strong>ziplist</strong>: 压缩列表. 元素个数较少且值较小时用.</li> <li><strong>skiplist</strong>: <strong>跳表</strong>. 元素个数多或值大时用. 后面详细介绍跳表.</li></ul> <h6 id="使用场景-5"><a href="#使用场景-5" class="header-anchor">#</a> 使用场景</h6> <p><strong>(1)排行榜系统</strong></p> <p>典型应用就是<strong>排行榜系统</strong>. 比如按用户点赞数, 按播放数排名. 可以轻易获取排行榜前十的内容.</p> <h5 id="_6-内部编码"><a href="#_6-内部编码" class="header-anchor">#</a> 6.内部编码</h5> <p>前面介绍了五种基本的数据结构, 还有一些拓展的结构都是基于它们实现的. <mark><strong>键的类型只能为字符串, 值支持五种数据类型: 字符串, 列表, 集合, 散列表, 有序集合.</strong></mark></p> <table><thead><tr><th style="text-align:center;">数据类型</th> <th style="text-align:center;">可以存储的值</th> <th style="text-align:left;">操作</th></tr></thead> <tbody><tr><td style="text-align:center;"><strong>STRING</strong></td> <td style="text-align:center;">字符串, 整数或者浮点数</td> <td style="text-align:left;">1.对整个字符串或者字符串的其中一部分执行操作. 2.对整数和浮点数执行自增或者自减操作.</td></tr> <tr><td style="text-align:center;"><strong>LIST</strong></td> <td style="text-align:center;"><strong>列表</strong></td> <td style="text-align:left;">1.从两端<strong>压入或者弹出</strong>元素. 2.对单个或者多个元素. 3.进行修剪, 只保留一个范围内的元素.</td></tr> <tr><td style="text-align:center;"><strong>SET</strong></td> <td style="text-align:center;"><strong>无序</strong>集合</td> <td style="text-align:left;">1.添加, 获取, 移除单个元素. 2.检查一个元素是否存在于集合中. 3.计算交集, 并集, 差集. 4.从集合里面随机获取元素.</td></tr> <tr><td style="text-align:center;"><strong>HASH</strong></td> <td style="text-align:center;">包含<strong>键值对</strong>的无序散列表</td> <td style="text-align:left;">1.添加, 获取, 移除单个键值对. 2.获取所有键值对. 3.检查某个键是否存在.</td></tr> <tr><td style="text-align:center;"><strong>ZSET</strong></td> <td style="text-align:center;"><strong>有序集合</strong></td> <td style="text-align:left;">1.添加, 获取, 删除元素. 2.根据分值范围或者成员来获取元素. 3.计算一个键的排名.</td></tr></tbody></table> <p>每一种数据结构都有<strong>两种以上</strong>的<strong>内部编码</strong>实现.</p> <blockquote><p>为什么这样设计?</p></blockquote> <p><strong>可以改进内部编码但不影响对外的数据结构和命令, 可以平滑升级</strong>. 多种内部编码在不同的应用场景下可以<strong>发挥各自的优势</strong>, 比如有的数据结构可以节省内存.</p> <table><thead><tr><th style="text-align:center;">数据结构</th> <th style="text-align:center;">内部编码</th></tr></thead> <tbody><tr><td style="text-align:center;"><strong>string</strong></td> <td style="text-align:center;">raw, int, embstr</td></tr> <tr><td style="text-align:center;"><strong>hash</strong></td> <td style="text-align:center;"><strong>hashtable</strong>, ziplist</td></tr> <tr><td style="text-align:center;"><strong>list</strong></td> <td style="text-align:center;"><strong>linkedlist</strong>, ziplist</td></tr> <tr><td style="text-align:center;"><strong>set</strong></td> <td style="text-align:center;"><strong>hashtable</strong>, intset</td></tr> <tr><td style="text-align:center;"><strong>zset</strong></td> <td style="text-align:center;"><strong>skiplist(跳表)</strong> , ziplist</td></tr></tbody></table> <h4 id="重要底层数据结构"><a href="#重要底层数据结构" class="header-anchor">#</a> 重要底层数据结构</h4> <h5 id="_1-字典dictht"><a href="#_1-字典dictht" class="header-anchor">#</a> 1.字典dictht</h5> <p><strong>dictht</strong> 是一个<strong>散列表</strong>结构, 使用<strong>拉链法解决哈希冲突</strong>.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictht</span> <span class="token punctuation">{</span>
    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span>
<span class="token punctuation">}</span> dictht<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>
        <span class="token class-name">uint64_t</span> u64<span class="token punctuation">;</span>
        <span class="token class-name">int64_t</span> s64<span class="token punctuation">;</span>
        <span class="token keyword">double</span> d<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>Redis 的字典 dict 中包含<strong>两个哈希表 dictht</strong>, 这是为了方便<strong>进行 rehash 操作</strong>. 在扩容时, 将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面, 完成之后<strong>释放空间并交换</strong>两个 dictht 的角色.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dict</span> <span class="token punctuation">{</span>
    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>
    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> rehashidx<span class="token punctuation">;</span> <span class="token comment">/* rehashing not in progress if rehashidx == -1 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> iterators<span class="token punctuation">;</span> <span class="token comment">/* number of iterators currently running */</span>
<span class="token punctuation">}</span> dict<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>rehash</strong> 操作不是一次性完成, 而是采用<strong>渐进方式</strong>, 这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的<strong>负担(阻塞)</strong> .</p> <p>渐进式 rehash 通过记录 dict 的 rehashidx 完成, 它从 0 开始, 然后每执行一次 rehash 都会递增. 例如在一次 rehash 中, 要把 dict[0] rehash 到 dict[1], 这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上, dict[0] 的 table[rehashidx] 指向 null, 并令 rehashidx++.</p> <p><strong>在 rehash 期间</strong>, 每次对字典执行添加, 删除, 查找或者更新操作时, 都会<strong>执行一次渐进式 rehash</strong>.</p> <p>采用渐进式 rehash 会导致字典中的数据分散在<strong>两个</strong> dictht 上, 因此对字典的查找操作也需要分别到两个 dictht 去执行.</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">dictRehash</span><span class="token punctuation">(</span>dict <span class="token operator">*</span>d<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> empty_visits <span class="token operator">=</span> n <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">/* Max number of empty buckets to visit. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">dictIsRehashing</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">&amp;&amp;</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dictEntry <span class="token operator">*</span>de<span class="token punctuation">,</span> <span class="token operator">*</span>nextde<span class="token punctuation">;</span>

        <span class="token comment">/* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0 */</span>
        <span class="token function">assert</span><span class="token punctuation">(</span>d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> d<span class="token operator">-&gt;</span>rehashidx<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">[</span>d<span class="token operator">-&gt;</span>rehashidx<span class="token punctuation">]</span> <span class="token operator">&lt;</span>mark<span class="token operator">&gt;</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            d<span class="token operator">-&gt;</span>rehashidx<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>empty_visits <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        de <span class="token operator">=</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">[</span>d<span class="token operator">-&gt;</span>rehashidx<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">/* Move all the keys in this bucket from the old to the new hash HT */</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>de<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">uint64_t</span> h<span class="token punctuation">;</span>

            nextde <span class="token operator">=</span> de<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            <span class="token comment">/* Get the index in the new hash table */</span>
            h <span class="token operator">=</span> <span class="token function">dictHashKey</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> de<span class="token operator">-&gt;</span>key<span class="token punctuation">)</span> <span class="token operator">&amp;</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sizemask<span class="token punctuation">;</span>
            de<span class="token operator">-&gt;</span>next <span class="token operator">=</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">[</span>h<span class="token punctuation">]</span><span class="token punctuation">;</span>
            d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> de<span class="token punctuation">;</span>
            d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used<span class="token operator">--</span><span class="token punctuation">;</span>
            d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used<span class="token operator">++</span><span class="token punctuation">;</span>
            de <span class="token operator">=</span> nextde<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">[</span>d<span class="token operator">-&gt;</span>rehashidx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        d<span class="token operator">-&gt;</span>rehashidx<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Check if we already rehashed the whole table... */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">zfree</span><span class="token punctuation">(</span>d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">)</span><span class="token punctuation">;</span>
        d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">_dictReset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        d<span class="token operator">-&gt;</span>rehashidx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* More to rehash... */</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><h5 id="_2-redisobject对象"><a href="#_2-redisobject对象" class="header-anchor">#</a> 2.RedisObject对象</h5> <h6 id="_1-概述-2"><a href="#_1-概述-2" class="header-anchor">#</a> (1)概述</h6> <p>redisObject 是一个<strong>结构体</strong>. Redis 内部<strong>使用 redisObject 对象来表示所有的 key 和 value</strong>, 每次在 Redis 数据块中创建一个键值对时, 一个是键对象, 一个是值对象. Redis 存储数据<strong>都采用 redisObject 封装</strong>.</p> <p>redisObject 最主要的信息:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span><span class="token punctuation">{</span>
    <span class="token comment">// 当前对象使用的数据类型 </span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// 当前对象内部编码类型</span>
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// 与对象的数据内容相关, 如果是整数, 直接存储数据; 否则表示指向数据的指针</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
    <span class="token comment">// 记录当前对象被引用的次数, 用于通过引用次数回收内存</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>
    <span class="token comment">// 记录最后一次被程序访问的时间,用于辅助 LRU 算法实现内存回收</span>
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span><span class="token number">22</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> robj
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220527224418151.png" alt=""></p> <h6 id="_2-内存回收与共享"><a href="#_2-内存回收与共享" class="header-anchor">#</a> (2)内存回收与共享</h6> <p>因为 C 语言<strong>不具备自动内存回收功能</strong>, 当将 redisObject 对象作为数据库的键或值而不是作为参数存储时其生命周期是非常长的, 为了解决这个问题, Redis <strong>自己构建了一个内存回收机制</strong>, 通过 redisobject 结构中的 <strong>refcount</strong> 实现. 这个属性会随着对象的<strong>使用状态而不断变化</strong>. 当对象的引用计数值变为 0 时, 对象所占用的<strong>内存就会被释放</strong>. refcount 属性除了能实现内存回收以外, 还能实现内存共享(参考: 共享对象池).</p> <p>高并发写入场景中, 在条件允许情况下, 建议字符串<strong>长度控制在 39 字节</strong>以内, 减少<strong>创建 redisObject</strong> 内存分配次数, 从而提高性能.</p> <h5 id="_3-跳表"><a href="#_3-跳表" class="header-anchor">#</a> 3.跳表</h5> <p><strong>跳表</strong>是 <strong>zset</strong> 的底层数据结构之一. 跳表是基于<strong>多指针有序链表</strong>实现的, 可以看成多个<strong>有序链表</strong>. 在<strong>查找</strong>时, 从<strong>上层指针</strong>开始查找, 找到对应的区间之后再到<strong>下一层</strong>去查找. 下图演示了查找 22 的过程. 更多参考: 跳表SkipList.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563520325342.png" alt="1563520325342"></p> <blockquote><p>为什么要用跳表而不用其他​数据结构?</p></blockquote> <p>由于 zset 要支持<strong>随机的插入和删除</strong>, 所以它<strong>不宜使用数组来实现</strong>, 关于排序问题, 也很容易就想到<strong>红黑树/平衡树</strong>这样的树形结构, 与红黑树等平衡树相比, 跳表具有以下优点:</p> <ul><li><strong>插入速度非常快速, 因为不需要进行旋转等操作来维护平衡性</strong>.</li> <li>更容易实现.</li> <li>支持<strong>无锁操作</strong>.</li></ul> <p>基于以上的一些考虑, Redis 采用了 <strong>跳跃表</strong> 来实现 Zset.</p> <h4 id="redis高级功能"><a href="#redis高级功能" class="header-anchor">#</a> Redis高级功能</h4> <h5 id="_1-pipeline流水线"><a href="#_1-pipeline流水线" class="header-anchor">#</a> 1.Pipeline流水线</h5> <p>流水线技术采用将<strong>多条命令打包</strong>的方式将命令发送到 Redis 进行执行, 并将<strong>多条命令</strong>的执行结果以<strong>打包</strong>的方式返回给客户端, 这样多条命令<strong>只在网络中传输一次</strong>, 这就大大<strong>节省了网络中传输命令的</strong>时间与开销.</p> <p>许多客户端带有这个功能, 如 Jedis. 客户端与服务端网络延时越大, 效果越明显. 而且组装后的命令比单个命令逐一执行要快.</p> <p>需要注意到是用 pipeline 方式打包命令发送, Redis <strong>必须在处理完所有命令前先缓存起所有命令的处理结果</strong>. 打包的命令越多, 缓存消耗内存也越多. 所以并不是打包的命令越多越好. 如果一次 Pipeline 操作数据量或命令太多, 可能导致<strong>阻塞</strong>, 可以分成几次执行.</p> <p>pipeline 中发送的每个 command 都会被 server 立即执行, 如果执行失败, 将会在此后的响应中得到信息; 也就是 <mark><strong>pipeline 并不是表达 &quot;所有 command 都一起成功&quot; 的语义, 管道中前面命令失败, 后面命令不会有影响, 而是会继续执行后面的目录, 并将所有命令的执行结果一起返回, 包括报错的结果</strong></mark>.  ****</p> <blockquote><p>原生的批量操作命令如 mget 一次也能批量操作数据, 和 Pipeline 有什么不同?</p></blockquote> <ul><li><strong>原生批量</strong>操作命令是<strong>原子</strong>的, <strong>Pipeline 是非原子</strong>的.</li> <li><strong>原生批量</strong>命令是<strong>一个命令对应多个 key</strong>, Pipeline 则支持<strong>多个命令</strong>.</li> <li><strong>原生批量</strong>命令是 Redis <strong>服务端</strong>支持实现, 而 Pipeline 由<strong>客户端和服务器共同支持</strong>实现.</li></ul> <blockquote><p>Pipeline使用示例</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Pipeline</span> pl <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">pipelined</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pl<span class="token punctuation">.</span><span class="token function">incr</span><span class="token punctuation">(</span><span class="token string">&quot;pipelineKey&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pl<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span> <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 模拟管道报错</span>
    <span class="token comment">// pl.setbit(&quot;test&quot;, -1, true);</span>
<span class="token punctuation">}</span>

<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> results <span class="token operator">=</span> pl<span class="token punctuation">.</span><span class="token function">syncAndReturnAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h5 id="_2-事务与lua🌟"><a href="#_2-事务与lua🌟" class="header-anchor">#</a> 2.事务与Lua🌟</h5> <p>为了保证多条命令组合的<strong>原子性</strong>, Redis 提供了<strong>简单的事务</strong>功能以及<strong>集成 Lua 脚本</strong>来解决.</p> <h6 id="_1-简单事务"><a href="#_1-简单事务" class="header-anchor">#</a> (1)简单事务</h6> <p><mark><strong>Redis 事务需要将多个命令放到 multi 和 exec 命令直接执行</strong></mark>. 这两个命令直接的命令是原子执行的. 执行 multi 命令后, 后面的命令并<strong>不会立即执行</strong>, 而是暂时保存起来, 直到执行 exec 命令才<strong>统一执行</strong>. 一个事务包含<strong>多个命令</strong>, 服务器在执行事务期间就不会去执行其它客户端的命令请求.</p> <p>事务中的<strong>多个命令被一次性发送</strong>给服务器, 而不是一条一条发送, 这种方式被称为<strong>流水线</strong>, 它可以减少客户端与服务器之间的网络通信次数从而提升性能.</p> <table><thead><tr><th style="text-align:center;">命令</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:center;"><strong>MULTI</strong></td> <td style="text-align:center;">表示<strong>开始收集命令</strong>, 后面所有命令都<strong>不是马上执行</strong>, 而是加入到一个<strong>队列</strong>中</td></tr> <tr><td style="text-align:center;"><strong>EXEC</strong></td> <td style="text-align:center;"><strong>执行</strong> MULTI 后面命令<strong>队列中的所有命令</strong></td></tr> <tr><td style="text-align:center;">DISCARD</td> <td style="text-align:center;">取代 exec 命令, 停止事务功能</td></tr> <tr><td style="text-align:center;">WATCH</td> <td style="text-align:center;">&quot;观察&quot;, &quot;监控&quot;一个 KEY, 在当前队列外的其他命令操作这个 KEY 时, <strong>放弃执行自己</strong>队列的命令, 是一种<strong>乐观锁</strong>的策略</td></tr> <tr><td style="text-align:center;">UNWATCH</td> <td style="text-align:center;">放弃监控一个 KEY</td></tr></tbody></table> <p><mark><strong>之所以是简单事务是因为 Redis 在事务失败时不进行回滚, 而是继续执行余下的命令</strong></mark>, 这与传统事务型数据库不一样, 以下是这种做法的优点: Redis 命令只会因为错误的<strong>语法而失败</strong>(并且这些问题不能在入队时发现), 或是命令用在了错误类型的键上面. 从实用性的角度来说, <strong>失败的命令是由编程错误</strong>造成的, 这些错误应该在开发过程中被发现, 而不应该出现在生产环境中. 因为不需要对回滚进行支持, 所以 Redis 的内部可以<strong>保持简单且快速</strong>.</p> <p>因此需要<strong>加强对生产环境中的错误异常处理</strong>.</p> <p>Redis 事务的几个特点:</p> <ul><li><strong>单独的隔离操作</strong>: 事务中的所有命令会被序列化, 按顺序执行, 在执行的过程中不会被其他客户端发送来的命令打断.</li> <li><strong>没有隔离级别的概念</strong>: 队列中的命令在事务没有被提交之前不会被实际执行.</li> <li><strong>不保证原子性</strong>: Redis 中的一个事务中如果存在命令执行失败, 那么其他命令依然会被执行, 没有回滚机制.</li> <li>Redis 是以<strong>乐观锁</strong>的策略操作事务的, 如上述的 WATCH 指令, 没有悲观锁.</li></ul> <blockquote><p>事务执行出错怎么办?</p></blockquote> <p>分为两种, 一是<strong>命令错误</strong>. 即命令写错了, 这种时候<strong>不执行</strong>事务. 第二种是<strong>运行时错误</strong>, 语法正确但是发生一些异常, 这种时候前面之前的命令是不会变化的, Redis <mark><strong>不支持回滚</strong></mark>. 需要开发人员自己解决.</p> <h6 id="_2-集成lua脚本"><a href="#_2-集成lua脚本" class="header-anchor">#</a> (2)集成Lua脚本</h6> <p>集成 Lua 脚本可以<strong>自己定义指令</strong>. 执行 Lua 脚本用 <strong>eval</strong>(单次调用脚本, 每次都传输到服务端) 或 <strong>evalsha</strong>(脚本存在服务端, 复用) 命令.</p> <p>Lua 脚本发送到服务端之后会被当做一个<strong>普通命令</strong>排队执行.</p> <h5 id="_3-bitmaps"><a href="#_3-bitmaps" class="header-anchor">#</a> 3.Bitmaps</h5> <p>实现<strong>对位</strong>的操作, 可以节约内存.</p> <p>Bitmaps 本身也是一种<strong>字符串</strong>, 只不过可以对字符串的<strong>位</strong>进行操作. 可以把它想成一个以位为单位的数组, 数组中每个单元<strong>只能存储 0 或 1</strong>, 数组的下标称为<strong>偏移量</strong>.</p> <blockquote><p>使用场景</p></blockquote> <ul><li>可以用于用户<strong>登录统计</strong>, 如活跃用户数统计.</li> <li>网址<strong>黑名单, 白名单</strong>.</li></ul> <blockquote><p>基本操作</p></blockquote> <p><strong>设置值</strong>: 设置键的第 offset 个位(从 0 算起)的值.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>setbit key offset value
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>获取值</strong>: 获取 offset 处的值.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>getbit key offset
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>获取 1 的个数</strong>: 获取 Bitmaps 指定范围内值为 1 的个数(不给范围则为全部).</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>bitcount key <span class="token punctuation">[</span>start end<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>Bitmaps 间的运算</strong>: 可以做多个 Bitmaps 直接的交集, 并集, 非, 异或等操作并将结果放在 destkey 中.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>bitop and<span class="token operator">|</span>or<span class="token operator">|</span>not<span class="token operator">|</span>xor destkey key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>计算 Bitmaps 中第一个值为 targetBit 的偏移量.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>bitops key targetBit <span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token punctuation">[</span>end<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h5 id="_4-hyperloglog"><a href="#_4-hyperloglog" class="header-anchor">#</a> 4.HyperLogLog</h5> <p>HyperLogLog 实际也是<strong>字符串</strong>类型. 它是一种<strong>基数算法</strong>, 通过 HyperLogLog 可以利用<strong>极小的内存空间完成独立总数的统计</strong>, 数据集可以是 <strong>IP, Email, ID</strong> 等.</p> <p>提供了三个命令: <strong>pfadd, pfcount, pfmerge</strong>.</p> <p>HyperLogLog 使用内存量小的惊人, 所以存在一定的<strong>误差率</strong>, 官方给 0.81% 误差.</p> <blockquote><p>使用场景</p></blockquote> <ul><li>只为了计算<strong>独立总数</strong>, 不需要获取单条数据.</li> <li>能够容忍一定的误差率.</li></ul> <h5 id="_5-发布订阅"><a href="#_5-发布订阅" class="header-anchor">#</a> 5.发布订阅</h5> <p>Redis 也提供了发布消息, 订阅频道, 取消订阅以及按照模式订阅的<strong>基础</strong>发布订阅功能.</p> <p>相比于专业的消息队列系统, Redis 的发布订阅略显<strong>粗糙</strong>, 例如<strong>无法实现消息堆积和回溯</strong>. 如果能容忍的场景是可以的, 因为实现简单. 可以用于变更通知.</p> <h5 id="_6-geo"><a href="#_6-geo" class="header-anchor">#</a> 6.GEO</h5> <p>Redis 提供了 GEO(<strong>地理信息定位</strong>) 的功能, 可以方便的存放<strong>地理位置</strong>. 可以用于实现<strong>附近位置, 摇一摇</strong>这种基于位置信息的功能. GEO 底层采用 <strong>zset</strong> 实现.</p> <p>GEO 可以存储地理位置的<strong>精度, 维度, 成员信息</strong>. 使用 GEO 可以方便的计算两个位置之间的<strong>距离</strong>以及其他位置信息.</p> <p>在一个地图应用中, 车的数据, 餐馆的数据, 人的数据可能会有百万千万条, 如果使用 <strong>Redis</strong> 的 GEO 数据结构, 它们将<strong>全部放在一个</strong> zset 集合中. 在 <strong>Redis</strong> 的集群中, 集合可能会从一个节点迁移到另一个节点, 如果单个 key 的数据过大, 会对集群的迁移工作造成较大的影响, 在集群环境中单个 key 对应的数据量不宜超过 1M, 否则会导致集群迁移出现卡顿现象, 影响线上服务的正常运行.</p> <p>所以建议 <strong>GEO</strong> 数据使用 <strong>单独的 Redis 实例部署</strong>, 不使用集群环境.</p> <p>如果数据量过亿甚至更大, 就需要对 <strong>GEO</strong> 数据进行拆分, 按国家拆分, 按省拆分, 按市拆分, 在人口特大城市甚至可以按区拆分. 这样就可以显著降低单个 zset 集合的大小.</p> <h5 id="_7-事件"><a href="#_7-事件" class="header-anchor">#</a> 7.事件</h5> <p>Redis 服务器是一个<strong>事件驱动</strong>程序.</p> <h6 id="_1-文件事件"><a href="#_1-文件事件" class="header-anchor">#</a> (1)文件事件</h6> <p><strong>服务器</strong>通过<strong>套接字</strong>与客户端或其它服务器进行通信, <strong>文件事件就是对套接字操作的抽象</strong>.</p> <p>Redis 基于 <strong>Reactor 模式</strong>开发了自己的网络事件处理器, 使用 IO <strong>多路复用</strong>程序来同时监听多个套接字, 并将到达的事件传送给文件事件分派器, 分派器会根据套接字产生的<strong>事件类型</strong>调用相应的事件处理器.</p> <h6 id="_2-时间事件"><a href="#_2-时间事件" class="header-anchor">#</a> (2)时间事件</h6> <p>服务器有一些操作需要在<strong>给定的时间点</strong>执行, 时间事件是对这类定时操作的抽象.</p> <p>时间事件又分为:</p> <ul><li><strong>定时事件</strong>: 是让一段程序在指定的时间之内执行一次.</li> <li><strong>周期性事件</strong>: 是让一段程序每隔指定时间就执行一次.</li></ul> <p>Redis 将所有时间事件都放在一个<strong>无序链表</strong>中, 通过遍历整个链表查找出已到达的时间事件, 并调用相应的事件处理器.</p> <h6 id="_3-事件的调度与执行"><a href="#_3-事件的调度与执行" class="header-anchor">#</a> (3)事件的调度与执行</h6> <p>服务器需要<strong>不断监听文件事件的套接字</strong>才能得到待处理的文件事件, 但是不能一直监听, 否则时间事件无法在规定的时间内执行, 因此监听时间应该根据距离现在最近的时间事件来决定.</p> <p>事件调度与执行由 <strong>aeProcessEvents 函数</strong>负责, 伪代码如下:</p> <div class="language-python line-numbers-mode"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 获取到达时间离当前时间最接近的时间事件</span>
    time_event <span class="token operator">=</span> aeSearchNearestTimer<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 计算最接近的时间事件距离到达还有多少毫秒</span>
    remaind_ms <span class="token operator">=</span> time_event<span class="token punctuation">.</span>when <span class="token operator">-</span> unix_ts_now<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 如果事件已到达, 那么 remaind_ms 的值可能为负数, 将它设为 0</span>
    <span class="token keyword">if</span> remaind_ms <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
        remaind_ms <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment"># 根据remaind_ms的值, 创建timeval</span>
    timeval <span class="token operator">=</span> create_timeval_with_ms<span class="token punctuation">(</span>remaind_ms<span class="token punctuation">)</span>
    <span class="token comment"># 阻塞并等待文件事件产生, 最大阻塞时间由传入的timeval决定</span>
    aeApiPoll<span class="token punctuation">(</span>timeval<span class="token punctuation">)</span>
    <span class="token comment"># 处理所有已产生的文件事件</span>
    procesFileEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 处理所有已到达的时间事件</span>
    processTimeEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>将 <strong>aeProcessEvents 函数</strong>置于一个<strong>循环里面</strong>, 加上初始化和清理函数, 就构成了 Redis 服务器的<strong>主函数</strong>, 伪代码如下:</p> <div class="language-python line-numbers-mode"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 初始化服务器</span>
    init_server<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 一直处理事件, 直到服务器关闭为止</span>
    <span class="token keyword">while</span> server_is_not_shutdown<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        aeProcessEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 服务器关闭, 执行清理操作</span>
    clean_server<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>从事件处理的角度来看, 服务器运行流程如下:</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220522211928514.png" alt=""></p> <h4 id="redis客户端"><a href="#redis客户端" class="header-anchor">#</a> Redis客户端</h4> <p>Redis 使用<strong>单线程</strong>来处理多个客户端的访问.</p> <h5 id="_1-客户端通信协议"><a href="#_1-客户端通信协议" class="header-anchor">#</a> 1.客户端通信协议</h5> <p>客户端与服务端的通信协议建立在 <strong>TCP</strong> 至上. Redis 定义了 <strong>RESP</strong>(Redis 序列化协议) 用于客户端与服务端交互. 有了这个通信协议各个编程语言就可以自己实现相应的 Redis 客户端.</p> <h5 id="_2-客户端管理"><a href="#_2-客户端管理" class="header-anchor">#</a> 2.客户端管理</h5> <p>Redis 提供了客户端相关的 API 对其<strong>状态进行监控和管理</strong>.</p> <h6 id="_1-输入与输出缓冲区"><a href="#_1-输入与输出缓冲区" class="header-anchor">#</a> (1)输入与输出缓冲区</h6> <p><strong>输入缓冲区</strong>: Redis 为每个客户端分配了输入缓冲区, 作用是将客户端<strong>发送的命令进行缓存</strong>, 之后 Redis 会逐渐<strong>拉取</strong>指令并执行. 如果有指令执行时间过长, 可能导致输入缓冲区指令堆积严重.</p> <p><strong>输出缓冲区</strong>: Redis 也为每个客户端分配了输出缓冲区, 作用是<strong>保存返回给客户端命令执行的结果</strong>, 为与客户端交互返回结果提供缓冲. 按客户端不同输出缓冲区还可以具体分为普通客户端输出缓冲区, 发布订阅输出缓冲区, 复制输出缓冲区. 实际上输出缓冲区由两部分组成: <strong>固定缓冲区(16K) 和动态缓冲区</strong>, 固定缓冲区(使用的是字节数组) 返回比较小的执行结果, 动态缓冲区(使用的是列表) 返回比较大的结果. 固定缓冲区用尽则使用动态缓冲区.</p> <h6 id="_2-客户端管理指令"><a href="#_2-客户端管理指令" class="header-anchor">#</a> (2)客户端管理指令</h6> <p><strong>列出与 Redis 服务器相连接的所有客户端连接信息</strong>: 输出每一行就表示一个客户端连接. 每个连接都有一些重要的属性. 如<strong>标识属性</strong>: id(唯一 ID), addr(客户端连接 IP 与端口), fd(socket 的文件描述符), name(客户端名字), <strong>输入缓冲区属性</strong>: qbuf(输入缓存区总容量), qbuf-free(输入缓存区剩余容量), <strong>输出缓冲区属性</strong>: obl, oll, omem, <strong>存活状态属性</strong>: age(已连接时间), idle(最近一次空闲时间).</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>client list
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>获取客户端信息</strong>: 可以有效的帮助开发和运维找到客户端可能存在的问题.</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>info client
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h5 id="_3-jedis"><a href="#_3-jedis" class="header-anchor">#</a> 3.Jedis</h5> <p><strong>Jedis</strong> 是 Java 实现的 Redis 客户端. 基础使用是用<strong>直连</strong>的方式, 但最好使用 <strong>Jedis 连接池</strong>(JedisPool) 的方式进行操作, 这样可以减少连接时创建 <strong>TCP 连接</strong>的开销. JedisPool 是<strong>单例</strong>的.</p> <p>Jedis.close() 在<strong>直连状态</strong>下是<strong>关闭连接</strong>, 如果使用了连接池, 则使用完成后 <strong>close 操作不是关闭</strong>连接, 而是<strong>归还</strong>到连接池中.</p> <p>Jedis 还可以实现 <strong>Pipeline</strong> 操作和执行 <strong>Lua 脚本</strong>(也有 eval 和 evalsha 两个方法).</p> <p>引入相关依赖:</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.9.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>示例代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisSingleTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>

        <span class="token class-name">JedisPoolConfig</span> jedisPoolConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMaxTotal</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMinIdle</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// timeout, 这里既是连接超时又是读写超时, 从Jedis 2.8开始有区分connectionTimeout和soTimeout的构造函数</span>
        <span class="token class-name">JedisPool</span> jedisPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPool</span><span class="token punctuation">(</span>jedisPoolConfig<span class="token punctuation">,</span> <span class="token string">&quot;192.168.0.60&quot;</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 从redis连接池里拿出一个连接执行命令</span>
            jedis <span class="token operator">=</span> jedisPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;single&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;nano&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;single&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 管道示例</span>
            <span class="token comment">// 管道的命令执行方式: cat redis.txt | redis-cli -h 127.0.0.1 -a password - p 6379 --pipe</span>
            <span class="token comment">/* Pipeline pl = jedis.pipelined();
            for (int i = 0; i &lt; 10; i++) {
                pl.incr(&quot;pipelineKey&quot;);
                pl.set(&quot;nano&quot; + i, &quot;nano&quot;);
            }
            List&lt;Object&gt; results = pl.syncAndReturnAll();
            System.out.println(results);*/</span>

            <span class="token comment">// lua脚本模拟一个商品减库存的原子操作</span>
            <span class="token comment">// lua脚本命令执行方式: redis-cli --eval /tmp/test.lua , 10</span>
            <span class="token comment">/*jedis.set(&quot;product_count_10016&quot;, &quot;15&quot;);  //初始化商品10016的库存
            String script = &quot; local count = redis.call('get', KEYS[1]) &quot; +
                            &quot; local a = tonumber(count) &quot; +
                            &quot; local b = tonumber(ARGV[1]) &quot; +
                            &quot; if a &gt;= b then &quot; +
                            &quot;   redis.call('set', KEYS[1], a-b) &quot; +
                            &quot;   return 1 &quot; +
                            &quot; end &quot; +
                            &quot; return 0 &quot;;
            Object obj = jedis.eval(script, Arrays.asList(&quot;product_count_10016&quot;), Arrays.asList(&quot;10&quot;));
            System.out.println(obj);*/</span>

        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token comment">// 注意这里不是关闭连接, 在JedisPool模式下, Jedis会被归还给资源池. </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>jedis <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br></div></div><h4 id="一个简单的论坛系统应用示例"><a href="#一个简单的论坛系统应用示例" class="header-anchor">#</a> 一个简单的论坛系统应用示例</h4> <p>该论坛系统功能如下:</p> <ul><li>可以发布文章.</li> <li>可以对文章进行<strong>点赞</strong>.</li> <li>在首页可以按文章的发布时间或者文章的<strong>点赞数进行排序显示</strong>.</li></ul> <blockquote><p>文章信息</p></blockquote> <p>文章包括标题, 作者, 赞数等信息, 在关系型数据库中很容易构建一张表来存储这些信息, 在 Redis 中可以使用 <strong>HASH</strong> 来存储每种信息以及其对应的值的映射.</p> <p>Redis 没有关系型数据库中的<strong>表</strong>这一概念来将同种类型的数据存放在一起, 而是使用<strong>命名空间</strong>的方式来实现这一功能. <strong>键名的前面部分存储命名空间</strong>, 后面部分的内容存储 ID, 通常<strong>使用 : 来进行分隔</strong>. 例如下面的 HASH 的键名为 article:92617, 其中 article 为命名空间, ID 为 92617.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563520443633.png" alt=""></p> <blockquote><p>点赞功能</p></blockquote> <p>当有用户为一篇文章点赞时, 除了要对该文章的 votes 字段进行加 1 操作, 还必须记录该用户已经对该文章进行了点赞, 防止用户点赞次数超过 1. 可以建立文章的<strong>已投票用户</strong>集合来进行记录.</p> <p>为了节约内存, 规定一篇文章发布满一周之后, 就不能再对它进行投票, 而文章的已投票集合也会被删除, 可以为文章的已投票集合设置一个一周的<strong>过期时间</strong>就能实现这个规定.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563520458408.png" alt=""></p> <blockquote><p>对文章进行排序</p></blockquote> <p>为了按发布时间和点赞数进行排序, 可以建立一个文章发布时间的<strong>有序集合</strong>和一个文章点赞数的有序集合. 下图中的 score 就是这里所说的点赞数; 下面所示的有序集合分值并不直接是时间和点赞数, 而是根据时间和点赞数间接计算出来的.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/1563520475567.png" alt=""></p> <p>‍</p> <p>‍</p> <h4 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h4> <ul><li><strong>Redis 命令</strong>在线查询: <a href="http://redisdoc.com/" target="_blank" rel="noopener noreferrer">http://redisdoc.com/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Carlson J L. Redis in Action[J]. Media.johnwiley.com.au, 2013.</li> <li><a href="http://redisbook.com/index.html" target="_blank" rel="noopener noreferrer">黄健宏. Redis 设计与实现 [M]. 机械工业出版社, 2014.<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://redislabs.com/ebook/foreword/" target="_blank" rel="noopener noreferrer">REDIS IN ACTION<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://ticki.github.io/blog/skip-lists-done-right/" target="_blank" rel="noopener noreferrer">Skip Lists: Done Right<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://www.cnblogs.com/loveincode/p/7411911.html" target="_blank" rel="noopener noreferrer">论述 Redis 和 Memcached 的差异<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://wiki.jikexueyuan.com/project/redis-guide" target="_blank" rel="noopener noreferrer">Redis 3.0 中文版- 分片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://www.scienjus.com/redis-use-case/" target="_blank" rel="noopener noreferrer">Redis 应用场景<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://redis.io/topics/lru-cache" target="_blank" rel="noopener noreferrer">Using Redis as an LRU cache<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p><strong>优秀文章</strong>:</p> <ul><li>阿里云 Redis 开发规范 - <a href="https://www.infoq.cn/article/K7dB5AFKI9mr5Ugbs_px" target="_blank" rel="noopener noreferrer">https://www.infoq.cn/article/K7dB5AFKI9mr5Ugbs_px<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>为什么要防止 bigkey?  - <a href="https://mp.weixin.qq.com/s?__biz=Mzg2NTEyNzE0OA==&amp;mid=2247483677&amp;idx=1&amp;sn=5c320b46f0e06ce9369a29909d62b401&amp;chksm=ce5f9e9ef928178834021b6f9b939550ac400abae5c31e1933bafca2f16b23d028cc51813aec&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s?__biz=Mzg2NTEyNzE0OA==&amp;mid=2247483677&amp;idx=1&amp;sn=5c320b46f0e06ce9369a29909d62b401&amp;chksm=ce5f9e9ef928178834021b6f9b939550ac400abae5c31e1933bafca2f16b23d028cc51813aec&amp;scene=21#wechat_redirect<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Redis【入门】就这一篇!  - <a href="https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/" target="_blank" rel="noopener noreferrer">https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>《Redis 设计与实现》 - <a href="http://redisbook.com/" target="_blank" rel="noopener noreferrer">http://redisbook.com/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>【官方文档】Redis 数据类型介绍 - <a href="http://www.redis.cn/topics/data-types-intro.html" target="_blank" rel="noopener noreferrer">http://www.redis.cn/topics/data-types-intro.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>《Redis 深度历险》 - <a href="https://book.douban.com/subject/30386804/" target="_blank" rel="noopener noreferrer">https://book.douban.com/subject/30386804/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>阿里云 Redis 开发规范 - <a href="https://www.infoq.cn/article/K7dB5AFKI9mr5Ugbs_px" target="_blank" rel="noopener noreferrer">https://www.infoq.cn/article/K7dB5AFKI9mr5Ugbs_px<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Redis 快速入门 - 易百教程 - <a href="https://www.yiibai.com/redis/redis_quick_guide.html" target="_blank" rel="noopener noreferrer">https://www.yiibai.com/redis/redis_quick_guide.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Redis【入门】就这一篇! - <a href="https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/" target="_blank" rel="noopener noreferrer">https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p><strong>Redis</strong>数据结构源码分析:</p> <ul><li>Redis 数据结构-字符串源码分析: <a href="https://my.oschina.net/mengyuankan/blog/1926320" target="_blank" rel="noopener noreferrer">https://my.oschina.net/mengyuankan/blog/1926320<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Redis 数据结构-字典源码分析:  <a href="https://my.oschina.net/mengyuankan/blog/1929593" target="_blank" rel="noopener noreferrer">https://my.oschina.net/mengyuankan/blog/1929593<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/30.系统/3000.系统/1200.中间件-缓存/30.Redis基础.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/e46d56/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">本地缓存</div></a> <a href="/pages/09236a/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Redis持久化</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/e46d56/" class="prev">本地缓存</a></span> <span class="next"><a href="/pages/09236a/">Redis持久化</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/156.bcc397ae.js" defer></script>
  </body>
</html>
