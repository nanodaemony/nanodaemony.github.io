<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java并发编程实战(极客时间)🌸 | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/67.690dd59b.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/4f30b9/" class="sidebar-link">Java基础</a></li><li><a href="/pages/795eca/" class="sidebar-link">类与继承</a></li><li><a href="/pages/c69152/" class="sidebar-link">抽象类与接口</a></li><li><a href="/pages/d71abb/" class="sidebar-link">内部类</a></li><li><a href="/pages/f06dca/" class="sidebar-link">枚举类</a></li><li><a href="/pages/259f57/" class="sidebar-link">常用类</a></li><li><a href="/pages/84b03b/" class="sidebar-link">关键字</a></li><li><a href="/pages/31b87b/" class="sidebar-link">注解</a></li><li><a href="/pages/f81c0d/" class="sidebar-link">异常</a></li><li><a href="/pages/ae7746/" class="sidebar-link">泛型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>容器类</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/0c88ac/" class="sidebar-link">集合容器类基础</a></li><li><a href="/pages/f805ed/" class="sidebar-link">List与Queue类</a></li><li><a href="/pages/d24b60/" class="sidebar-link">Map与Set类</a></li><li><a href="/pages/54e5d3/" class="sidebar-link">并发容器类</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/67d70f/" class="sidebar-link">多线程基础</a></li><li><a href="/pages/ffc8f7/" class="sidebar-link">Java内置锁</a></li><li><a href="/pages/c43494/" class="sidebar-link">AQS</a></li><li><a href="/pages/eb5b61/" class="sidebar-link">显式锁ReentrantLock</a></li><li><a href="/pages/eb8cbc/" class="sidebar-link">线程协作与JUC组件</a></li><li><a href="/pages/23c79a/" class="sidebar-link">Atomic原子变量与Unsafe类与CAS</a></li><li><a href="/pages/9d6ed4/" class="sidebar-link">线程池与定时任务</a></li><li><a href="/pages/5b787a/" class="sidebar-link">ThreadLocal</a></li><li><a href="/pages/db53d1/" aria-current="page" class="active sidebar-link">Java并发编程实战(极客时间)🌸</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>IO</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b4d461/" class="sidebar-link">文件操作</a></li><li><a href="/pages/1b9d6c/" class="sidebar-link">IO流操作</a></li><li><a href="/pages/076a47/" class="sidebar-link">Java网络IO模型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>高级特性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d76905/" class="sidebar-link">Lambda表达式</a></li><li><a href="/pages/f7f0e6/" class="sidebar-link">流Stream</a></li><li><a href="/pages/7cc40a/" class="sidebar-link">反射</a></li><li><a href="/pages/945326/" class="sidebar-link">代理</a></li><li><a href="/pages/7fd9b4/" class="sidebar-link">Javaagent</a></li><li><a href="/pages/a3cee0/" class="sidebar-link">Guava</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>JVM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d308f6/" class="sidebar-link">走进JVM🌼</a></li><li><a href="/pages/be0269/" class="sidebar-link">JVM内存区域与对象解析🌼</a></li><li><a href="/pages/48d1be/" class="sidebar-link">垃圾收集器与内存分配策略🌼</a></li><li><a href="/pages/3a4c8a/" class="sidebar-link">JVM性能监控与故障处理工具🌼</a></li><li><a href="/pages/106680/" class="sidebar-link">调优案例分析与实战🌼</a></li><li><a href="/pages/16a914/" class="sidebar-link">类文件结构🌼</a></li><li><a href="/pages/ea287c/" class="sidebar-link">虚拟机类加载机制🌼</a></li><li><a href="/pages/6367b0/" class="sidebar-link">虚拟机字节码执行引擎🌼</a></li><li><a href="/pages/c6c210/" class="sidebar-link">类加载及执行子系统的案例与实战🌼</a></li><li><a href="/pages/deb8b7/" class="sidebar-link">前端编译与优化🌼</a></li><li><a href="/pages/1f8f72/" class="sidebar-link">后端编译与优化🌼</a></li><li><a href="/pages/3d72db/" class="sidebar-link">Java内存模型与线程实现🌼</a></li><li><a href="/pages/ed086e/" class="sidebar-link">线程安全与内置锁优化🌼</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/56b9dd/" class="sidebar-link">Java性能问题定位分析</a></li><li><a href="/pages/939bf8/" class="sidebar-link">杂记</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>开发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>软件设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/a5f6fe/" class="sidebar-link">设计基础理论</a></li><li><a href="/pages/3b245c/" class="sidebar-link">设计模式之美(极客时间)🌟</a></li><li><a href="/pages/661fa4/" class="sidebar-link">领域驱动设计(DDD)</a></li><li><a href="/pages/856368/" class="sidebar-link">DDD实战课(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d3fbd2/" class="sidebar-link">数据库基础</a></li><li><a href="/pages/691fc3/" class="sidebar-link">数据库系统原理</a></li><li><a href="/pages/50f6b7/" class="sidebar-link">MySQL基础必知必会</a></li><li><a href="/pages/fe297e/" class="sidebar-link">MySQL特性</a></li><li><a href="/pages/07bdb6/" class="sidebar-link">MySQL索引🌟</a></li><li><a href="/pages/984715/" class="sidebar-link">MySQL锁🌟</a></li><li><a href="/pages/53b588/" class="sidebar-link">MySQL事务🌟</a></li><li><a href="/pages/becc59/" class="sidebar-link">MySQL高级特性</a></li><li><a href="/pages/056463/" class="sidebar-link">MySQL基础架构与存储引擎🌟</a></li><li><a href="/pages/63b46e/" class="sidebar-link">MySQL架构优化与运维</a></li><li><a href="/pages/9995e5/" class="sidebar-link">MySQL优化</a></li><li><a href="/pages/c1c2f6/" class="sidebar-link">MySQL架构</a></li><li><a href="/pages/8e8e0a/" class="sidebar-link">MySQL设计规范</a></li><li><a href="/pages/0219aa/" class="sidebar-link">MySQL运维</a></li><li><a href="/pages/e288c0/" class="sidebar-link">MySQL中间件</a></li><li><a href="/pages/c6cafa/" class="sidebar-link">MySQL实战45讲(极客时间)🌟</a></li><li><a href="/pages/4a6106/" class="sidebar-link">数据库LeetCode题目</a></li><li><a href="/pages/2827f1/" class="sidebar-link">数据库综合问题</a></li><li><a href="/pages/c616d5/" class="sidebar-link">MongoDB</a></li><li><a href="/pages/075e71/" class="sidebar-link">ClickHouse</a></li><li><a href="/pages/d74f6d/" class="sidebar-link">Doris</a></li><li><a href="/pages/b6bad9/" class="sidebar-link">HBase</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Spring</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bd8eb8/" class="sidebar-link">Spring Boot基础</a></li><li><a href="/pages/d0d797/" class="sidebar-link">Spring Boot应用整合</a></li><li><a href="/pages/314cdc/" class="sidebar-link">Spring MVC基础</a></li><li><a href="/pages/80de47/" class="sidebar-link">Spring AOP基础</a></li><li><a href="/pages/f0d4d6/" class="sidebar-link">Spring事务基础</a></li><li><a href="/pages/db6afe/" class="sidebar-link">Spring IOC源码分析-概览</a></li><li><a href="/pages/672e98/" class="sidebar-link">Spring IOC源码分析-getBean()</a></li><li><a href="/pages/695b90/" class="sidebar-link">Spring IOC源码分析-createBean()</a></li><li><a href="/pages/f89bcf/" class="sidebar-link">Spring AOP源码分析</a></li><li><a href="/pages/3b52f4/" class="sidebar-link">Spring事务源码分析</a></li><li><a href="/pages/186902/" class="sidebar-link">Spring Boot源码分析</a></li><li><a href="/pages/16bd1c/" class="sidebar-link">Spring MVC源码分析</a></li><li><a href="/pages/3d0c1f/" class="sidebar-link">Spring Cloud</a></li><li><a href="/pages/d56156/" class="sidebar-link">Spring编程常见错误50例(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>MyBatis</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bb032d/" class="sidebar-link">基础</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>工具与环境</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c9cb6e/" class="sidebar-link">Arthas</a></li><li><a href="/pages/3172bb/" class="sidebar-link">Maven</a></li><li><a href="/pages/37f79a/" class="sidebar-link">Git</a></li><li><a href="/pages/db9f99/" class="sidebar-link">环境搭建与部署</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c725f5/" class="sidebar-link">测试基础</a></li><li><a href="/pages/7893a4/" class="sidebar-link">单元测试</a></li><li><a href="/pages/af9f25/" class="sidebar-link">压力测试</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>代码质量</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ec2b81/" class="sidebar-link">代码整洁之道</a></li><li><a href="/pages/474cdf/" class="sidebar-link">阿里巴巴编程规范</a></li><li><a href="/pages/c47e15/" class="sidebar-link">代码之丑(极客时间)🌸</a></li><li><a href="/pages/4d4606/" class="sidebar-link">Java业务开发常见错误100例(极客时间)🌸</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/develop/#开发" data-v-06970110>开发</a></li><li data-v-06970110><a href="/develop/#Java" data-v-06970110>Java</a></li><li data-v-06970110><a href="/develop/#并发" data-v-06970110>并发</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">Java并发编程实战(极客时间)🌸<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_400-java并发编程实战-极客时间-🌸"><a href="#_400-java并发编程实战-极客时间-🌸" class="header-anchor">#</a> 400.Java并发编程实战(极客时间)🌸</h1> <h3 id="开篇词"><a href="#开篇词" class="header-anchor">#</a> 开篇词</h3> <h4 id="开篇词-你为什么需要学习并发编程"><a href="#开篇词-你为什么需要学习并发编程" class="header-anchor">#</a> 开篇词-你为什么需要学习并发编程?</h4> <p>你好, 我是王宝令, 资深架构师, 目前从事电商架构的设计工作. 从毕业到现在, 我前前后后写了 15 年的程序, 刚毕业的时候从事证券业务的开发, 开发语言是 C/C++, 之后从事 ERP 产品的研发, 开发语言主要是 C# 和 Java, 最近几年主要是从事 Java 开发平台和基础中间件的设计开发工作.</p> <p>还记得毕业后我接触的第一个项目是证券相关的, 国外的同事用 C 语言写了一个内存数据库, 代码写得极为简练优美, 我当时怀着无比崇敬的心情把代码看了又看, 看完感觉受益匪浅. 不过兴奋之余, 我也有些焦虑, 因为其中一块并发相关的代码, 我看得是云里雾里, 总感觉自己没有悟透.</p> <p>我下意识地告诉自己说这块的知识积累还不够, 所以要勤学苦练. 你可知道, 15 年前相关的学习资料并不多, 我的师傅向我推荐了《操作系统原理》这本教材, 他说: &quot;并发编程最早的应用领域就是操作系统的实现, 你把这本书看懂了, 并发的问题自然就解决了.&quot; 但是理论和实践之间总是有鸿沟的, 之后好多年, 最让我感到无助的还是处理并发相关的问题.</p> <p>并发编程的掌握过程并不容易. 我相信为了解决这个问题, 你也听别人总结过并发编程的第一原则, 那就是不要写并发程序. 这个原则在我刚毕业的那几年曾经是行得通的, 那个时候多核服务器还是一种奢侈品, 系统的并发量也很低, 借助数据库和类似 Tomcat 这种中间件, 我们基本上不用写并发程序. 或者说, 并发问题基本上都被中间件和数据库解决了.</p> <p>**但是最近几年, 并发编程已经慢慢成为一项必备技能. **</p> <p>这主要是硬件的驱动以及国内互联网行业的飞速发展决定的, 现在 64 核的服务器已经飞入寻常百姓家, 大型互联网厂商的系统并发量轻松过百万, 传统的中间件和数据库已经不能为我们遮风挡雨, 反而成了瓶颈所在.</p> <p>并发编程最近几年成为非常热门的领域, 人才稀缺. 但与此同时, 关于并发编程的书籍也渐渐丰富起来了. 所以当极客时间团队和我聊这个专栏的时候, 我的第一个疑问就是目前市面上已经有很多这方面的图书了, 而且很多都非常优秀, 是否还有必要搞一个这样的专栏.</p> <p>但是深入想过之后, 我坚定了写作的信心. 这些年接触的大部分同学, 都是工作几年后很多技术突飞猛进, 却只有并发编程成为瓶颈, 虽然并发相关的类库他们也熟悉, 却总是写不出正确, 高效的并发程序, 原因在哪里? 我发现很多人是因为某个地方有了盲点, 忽略了一些细节, 但恰恰是这些细节决定了程序的正确性和效率.</p> <p>而这个盲点有时候涉及对操作系统的理解, 有时候又涉及一点硬件知识, 非常复杂, 如果要推荐相关图书, 可能要推荐好几本, 这就有点 &quot;大炮打蚊子&quot; 的感觉了, 效率很差. 同时图书更追求严谨性, 却也因此失掉了形象性, 所以阅读的过程也确实有点艰辛.</p> <p>我想, 如果能够把这些问题解决, 那么做这个事情应该是有意义的.</p> <p>例如, Java 里 synchronized, wait()/notify() 相关的知识很琐碎, 看懂难, 会用更难. 但实际上 synchronized, wait(), notify() 不过是操作系统领域里<strong>管程模型</strong>的一种实现而已, Java SDK 并发包里的条件变量 Condition 也是管程里的概念, synchronized, wait()/notify(), 条件变量这些知识如果单独理解, 自然是管中窥豹. 但是如果站在管程这个理论模型的高度, 就会发现这些知识原来这么简单, 同时用起来也就得心应手了.</p> <p>管程作为一种解决并发问题的模型, 是继信号量模型之后的一项重大创新, 它与信号量在逻辑上是等价的(可以用管程实现信号量, 也可以用信号量实现管程), 但是相比之下管程更易用. 而且, 很多编程语言都支持管程, 搞懂管程, 对学习其他很多语言的并发编程有很大帮助. 然而, 很多人急于学习 Java 并发编程技术, 却忽略了技术背后的理论和模型, 而理论和模型却往往比具体的技术更为重要.</p> <p>此外, Java 经过这些年的发展, Java SDK 并发包提供了非常丰富的功能, 对于初学者来说可谓是眼花缭乱, 好多人觉得无从下手. 但是, Java SDK 并发包乃是并发大师 Doug Lea 出品, 堪称经典, 它内部一定是有章可循的. 那它的章法在哪里呢?</p> <p><mark><strong>其实并发编程可以总结为三个核心问题: 分工, 同步, 互斥</strong></mark>​ <strong>.</strong></p> <p><mark><strong>所谓分工指的是如何高效地拆解任务并分配给线程, 而同步指的是线程之间如何协作, 互斥则是保证同一时刻只允许一个线程访问共享资源</strong></mark>. Java SDK 并发包很大部分内容都是按照这三个维度组织的, 例如 Fork/Join 框架就是一种分工模式, CountDownLatch 就是一种典型的同步方式, 而可重入锁则是一种互斥手段.</p> <p>当把并发编程核心的问题搞清楚, 再回过头来看 Java SDK 并发包, 你会感觉豁然开朗, 它不过是<strong>针对并发问题开发出来的工具</strong>而已.</p> <p>而且这三个核心问题是跨语言的, 如果要学习其他语言的并发编程类库, 完全可以顺着这三个问题按图索骥. Java SDK 并发包其余的一部分则是并发容器和原子类, 这些比较容易理解, 属于辅助工具, 其他语言里基本都能找到对应的.</p> <p>**所以, 你说并发编程难学吗? **</p> <p>首先, 难是肯定的. 因为这其中涉及操作系统, CPU, 内存等等多方面的知识, 如果你缺少某一块, 那理解起来自然困难. 其次, 难不难学也可能因人而异, 就我的经验来看, 很多人在学习并发编程的时候, 总是喜欢从点出发, 希望能从点里找到规律或者本质, 最后却把自己绕晕了.</p> <p>并发编程并不是 Java 特有的语言特性, 它是一个通用且早已成熟的领域. Java 只是根据自身情况做了实现罢了, 当你理解或学习并发编程的时候, 如果能够站在较高层面, 系统且有体系地思考问题, 那就会容易很多.</p> <p>所以, 我希望这个专栏更多地谈及问题背后的本质, 问题的起源, 同时站在理论, 模型的角度讲解 Java 并发, 让你的知识更成体系, 融会贯通. 最终让你能够得心应手地解决各种并发难题, 同时将这些知识用于其他编程语言, 让你的一分辛劳三分收获.</p> <p>下面就是这个专栏的目录, 你可以快速了解下整个专栏的知识结构体系.</p> <p><img src="/img/67857bd7fdbb63a3c7864a47244f9425-20230731162452-6d9qt3o.png" alt=""></p> <p><strong>当然要坚持下去, 不能三天打鱼两天晒网, 因为滴水穿石非一日之功.</strong></p> <p>很多人都说学习是反人性的, 开始容易, 但是长久的坚持却很难. 这个我也认同, 我面试的时候, 就经常问候选人一个问题: &quot;工作中, 有没有一件事你自己坚持了很久, 并且从中获益?&quot; 如果候选人能够回答出来, 那会是整个面试的加分项, 因为我觉得, 坚持真是一个可贵的品质, 一件事情, 有的人三分热度, 而有的人, 一做就能做一年, 或者更久. 放长到时间的维度里看, 这两种人, 最后的成就绝对是指数级的差距.</p> <h4 id="学习攻略-如何才能学好并发编程"><a href="#学习攻略-如何才能学好并发编程" class="header-anchor">#</a> 学习攻略-如何才能学好并发编程?</h4> <p>并发编程并不是一门相对独立的学科, 而是一个综合学科. 并发编程相关的概念和技术看上非常零散, 相关度也很低, 总给你一种这样的感觉: 我已经学习很多相关技术了, 可还是搞不定并发编程. 那如何才能学习好并发编程呢?</p> <p>其实很简单, 只要你能从两个方面突破一下就可以了. 一个是 &quot;跳出来看全景&quot;, 另一个是 &quot;钻进去看本质&quot;.</p> <h5 id="跳出来看全景🍀"><a href="#跳出来看全景🍀" class="header-anchor">#</a> 跳出来看全景🍀</h5> <p>先说&quot;跳出来&quot;. 学习最忌讳的就是 &quot;盲人摸象&quot;, 只看到局部, 而没有看到全局. 所以需要从一个个单一的知识和技术中 &quot;跳出来&quot;, 高屋建瓴地看并发编程. 当然, 这<strong>首要之事就是需要建立起一张全景图</strong>.</p> <p>不过, 并发编程相关的知识和技术还真是错综复杂, 时至今日也还没有一张普遍认可的全景图, 也许这正是很多人在并发编程方面难以突破的原因. 好在经过多年摸爬滚打, 我已经&quot;勾勒&quot;出了一张全景图, 不一定科学, 但是在某种程度上它还是可以指导你学好并发编程的.</p> <p>在我看来, 并发编程领域可以抽象成<strong>三个核心问题: 分工, 同步和互斥</strong>.</p> <h6 id="_1-分工"><a href="#_1-分工" class="header-anchor">#</a> (1)分工</h6> <p><strong>所谓分工, 类似于现实中一个组织完成一个项目, 项目经理要拆分任务, 安排合适的成员去完成</strong>.</p> <p>在并发编程领域, 你就是项目经理, <strong>线程就是项目组成员</strong>. 任务分解和分工对于项目成败非常关键, 不过在并发领域里, 分工更重要, 它直接决定了并发程序的性能. 在现实世界里, 分工是很复杂的.</p> <p>既然分工很重要又很复杂, 那一定有前辈努力尝试解决过, 并且也一定有成果. 的确, 在并发编程领域这方面的成果还是很丰硕的. Java SDK 并发包里的 <strong>Executor, Fork/Join, Future 本质上都是一种分工方法</strong>. 除此之外, 并发编程领域还总结了一些设计模式, 基本上都是和分工方法相关的, 例如生产者-消费者, Thread-Per-Message, Worker Thread 模式等都是用来指导如何分工的.</p> <p>学习这部分内容, 最佳的方式就是和现实世界做对比. 例如生产者-消费者模式, 可以类比一下餐馆里的大厨和服务员, 大厨就是生产者, 负责做菜, 做完放到出菜口, 而服务员就是消费者, 把做好的菜给你端过来. 不过, 我们经常会发现, 出菜口有时候一下子出了好几个菜, 服务员是可以把这一批菜同时端给你的. 其实这就是生产者-消费者模式的一个优点, 生产者一个一个地生产数据, 而消费者可以批处理, 这样就提高了性能.</p> <h6 id="_2-同步"><a href="#_2-同步" class="header-anchor">#</a> (2)同步</h6> <p>分好工之后, 就是具体执行了. 在项目执行过程中, 任务之间是有依赖的, 一个任务结束后, 依赖它的后续任务就可以开工了, 后续工作怎么知道可以开工了呢? 这个就是靠沟通协作了, 这是一项很重要的工作.</p> <p>在<strong>并发编程领域里的同步, 主要指的就是线程间的协作</strong>, 本质上和现实生活中的协作没区别, 不过是<strong>一个线程执行完了一个任务, 如何通知执行后续任务的线程开工</strong>而已.</p> <p>协作一般是和分工相关的. Java SDK 并发包里的 Executor, Fork/Join, Future 本质上都是分工方法, 但同时也能解决线程协作的问题. 例如, 用 Future 可以发起一个异步调用, 当主线程通过 get() 方法取结果时, 主线程就会等待, 当异步执行的结果返回时, get() 方法就自动返回了. 主线程和异步线程之间的协作, Future 工具类已经帮我们解决了. 除此之外, Java SDK 里提供的 CountDownLatch, CyclicBarrier, Phaser, Exchanger 也都是用来解决线程协作问题的.</p> <p>不过还有很多场景, 是需要自己来处理线程之间的协作的.</p> <p>工作中遇到的线程协作问题, 基本上都可以描述为这样的一个问题: <mark><strong>当某个条件不满足时, 线程需要等待, 当某个条件满足时, 线程需要被唤醒执行</strong></mark>. 例如, 在生产者-消费者模型里, 也有类似的描述, &quot;当队列满时, 生产者线程等待, 当队列不满时, 生产者线程需要被唤醒执行; 当队列空时, 消费者线程等待, 当队列不空时, 消费者线程需要被唤醒执行.&quot;</p> <p>在 Java 并发编程领域, 解决协作问题的核心技术是<strong>管程</strong>, 上面提到的<strong>所有线程协作技术底层都是利用管程解决</strong>的. 管程是一种解决并发问题的通用模型, 除了能解决线程协作问题, 还能解决下面将要介绍的互斥问题. 可以这么说, <strong>管程是解决并发问题的万能钥匙</strong>.</p> <p>所以说, 这部分内容关键是理解管程模型, 学好它就可以解决所有问题. 其次是了解 Java SDK 并发包提供的几个线程协作的工具类的应用场景, 用好它们可以妥妥地提高工作效率.</p> <h6 id="_3-互斥"><a href="#_3-互斥" class="header-anchor">#</a> (3)互斥</h6> <p>分工, 同步主要强调的是性能, 但并发程序里还有一部分是关于正确性的, 用专业术语叫 &quot;<strong>线程安全</strong>&quot;. 并发程序里, 当多个线程同时访问同一个共享变量的时候, 结果是不确定的. 不确定, 则意味着可能正确, 也可能错误, 事先是不知道的. 而<strong>导致不确定的主要源头是可见性问题, 有序性问题和原子性问题, 为了解决这三个问题, Java 语言引入了内存模型, 内存模型提供了一系列的规则, 利用这些规则, 可以避免可见性问题, 有序性问题, 但是还不足以完全解决线程安全问题. 解决线程安全问题的核心方案还是互斥</strong>.</p> <p>**所谓互斥, 指的是同一时刻, 只允许一个线程访问共享变量. **</p> <p>实现互斥的核心技术就是<strong>锁</strong>, Java 语言里 synchronized, SDK 里的各种 Lock 都能解决<strong>互斥问题</strong>. 虽说锁解决了安全性问题, 但同时也带来了性能问题, 那如何保证安全性的同时又尽量提高性能呢? 可以分场景优化, Java SDK 里提供的 ReadWriteLock, StampedLock 就可以优化读多写少场景下锁的性能. 还可以使用无锁的数据结构, 例如 Java SDK 里提供的原子类都是基于无锁技术实现的.</p> <p>除此之外, 还有一些其他的方案, 原理是不共享变量或者变量只允许读. 这方面, Java 提供了 ThreadLocal 和 final 关键字, 还有一种 Copy-on-write 的模式.</p> <p>使用锁除了要注意性能问题外, 还需要注意死锁问题.</p> <p>这部分内容比较复杂, 往往还是跨领域的, 例如要理解可见性, 就需要了解一些 CPU 和缓存的知识; 要理解原子性, 就需要理解一些操作系统的知识; 很多无锁算法的实现往往也需要理解 CPU 缓存. 这部分内容的学习, 需要博览群书, 在大脑里建立起 CPU, 内存, I/O 执行的模拟器. 这样遇到问题就能得心应手了.</p> <p>跳出来, 看全景, 可以让你的知识成体系, 所学知识也融汇贯通起来, 由点成线, 由线及面, 画出自己的知识全景图.</p> <p><img src="/img/81c879aa2ecdeec399e68bf1c1cc29a9-20230731162452-u0yie62.png" alt="" title="并发编程全景图之思维导图"></p> <h5 id="_2-钻进去看本质"><a href="#_2-钻进去看本质" class="header-anchor">#</a> 2.钻进去看本质</h5> <p>但是光跳出来还不够, 还需要下一步, 就是<strong>在某个问题上钻进去, 深入理解, 找到本质</strong>.</p> <p>就拿我个人来说, 我已经烦透了去讲述或被讲述一堆概念和结论, 而不分析这些概念和结论是怎么来的, 以及它们是用来解决什么问题的. 在大学里, 这样的教材很流行, 直接导致了芸芸学子成绩很高, 但解决问题的能力很差. 其实, 知其然知其所以然, 才算真的学明白了.</p> <p>我属于理论派, <strong>我认为工程上的解决方案, 一定要有理论做基础</strong>. 所以在学习并发编程的过程中, 我都会探索它背后的理论是什么. 比如, 当看到 Java SDK 里面的条件变量 Condition 的时候, 我会下意识地问, &quot;它是从哪儿来的? 是 Java 的特有概念, 还是一个通用的编程概念?&quot; 当我知道它来自管程的时候, 我又会问, &quot;管程被提出的背景和解决的问题是什么?&quot; 这样一路探索下来, 可以发现 Java 语言里的并发技术基本都是有理论基础的, 并且这些理论在其他编程语言里也有类似的实现. 所以我认为, 技术的本质是背后的理论模型.</p> <h3 id="并发理论基础"><a href="#并发理论基础" class="header-anchor">#</a> 并发理论基础</h3> <h4 id="_01-可见性-原子性和有序性问题-并发编程bug的源头🍀"><a href="#_01-可见性-原子性和有序性问题-并发编程bug的源头🍀" class="header-anchor">#</a> 01-可见性,原子性和有序性问题:并发编程Bug的源头🍀</h4> <p>编写正确的并发程序是一件极困难的事情, 并发程序的 Bug 往往会诡异地出现, 然后又诡异地消失, 很难重现, 也很难追踪, 很多时候都让人很抓狂. 但要快速而又精准地解决 &quot;并发&quot; 类的疑难杂症, 就要理解这件事情的本质, 追本溯源, 深入分析这些 Bug 的源头在哪里.</p> <p><strong>那为什么并发编程容易出问题呢? 它是怎么出问题的? 今天就重点聊聊这些 Bug 的源头</strong>.</p> <h5 id="并发程序幕后的故事"><a href="#并发程序幕后的故事" class="header-anchor">#</a> 并发程序幕后的故事</h5> <p>这些年 CPU, 内存, I/O 设备都在不断迭代, 不断朝着更快的方向努力. 但在这个快速发展的过程中, 有一个<strong>核心矛盾一直存在, 就是这三者的速度差异</strong>. CPU 和内存的速度差异可以形象地描述为: CPU 是天上一天, 内存是地上一年(假设 CPU 执行一条普通指令需要一天, 那么 CPU 读写内存得等待一年的时间). 内存和 I/O 设备的速度差异就更大了, 内存是天上一天, I/O 设备是地上十年.</p> <p>程序里大部分语句都要访问内存, 有些还要访问 I/O, 根据木桶理论(一只水桶能装多少水取决于它最短的那块木板), 程序整体的性能取决于最慢的操作——读写 I/O 设备, 也就是说单方面提高 CPU 性能是无效的.</p> <p>为了合理利用 CPU 的高性能, 平衡这三者的速度差异, 计算机体系机构, 操作系统, 编译程序都做出了贡献, 主要体现为:</p> <ol><li>CPU 增加了<strong>缓存</strong>, 以均衡与内存的速度差异;</li> <li>操作系统增加了进程, 线程, 以分时复用 CPU, 进而均衡 CPU 与 I/O 设备的速度差异;</li> <li>编译程序优化指令执行次序, 使得缓存能够得到更加合理地利用.</li></ol> <p>现在几乎所有的程序都默默地享受着这些成果, 但是天下没有免费的午餐, 并发程序很多诡异问题的根源也在这里.</p> <h5 id="源头之一-缓存导致的可见性问题"><a href="#源头之一-缓存导致的可见性问题" class="header-anchor">#</a> 源头之一:缓存导致的可见性问题</h5> <p>在单核时代, 所有的线程都是在一颗 CPU 上执行, CPU 缓存与内存的数据一致性容易解决. 因为所有线程都是操作同一个 CPU 的缓存, 一个线程对缓存的写, 对另外一个线程来说一定是可见的. 例如在下面的图中, 线程 A 和线程 B 都是操作同一个 CPU 里面的缓存, 所以线程 A 更新了变量 V 的值, 那么线程 B 之后再访问变量 V, 得到的一定是 V 的最新值(线程 A 写过的值).</p> <p><img src="/img/18d87850b677c4757c55ad21cf53a7bb-20230731162452-bvs7820.png" alt="" title="CPU 缓存与内存的关系图"></p> <p><mark><strong>一个线程对共享变量的修改, 另外一个线程能够立刻看到, 称为可见性</strong></mark>.</p> <p>多核时代, 每颗 CPU 都有自己的缓存, 这时 CPU 缓存与内存的数据一致性就没那么容易解决了, 当多个线程在不同的 CPU 上执行时, 这些<strong>线程操作的是不同的 CPU 缓存</strong>. 比如下图中, 线程 A 操作的是 CPU-1 上的缓存, <strong>而线程 B 操作的是 CPU-2 上的缓存, 很明显, 这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了</strong>. 这个就属于硬件程序员给软件程序员挖的 &quot;坑&quot;.</p> <p><img src="/img/3c022480823a6143f35d0f474b8e95c5-20230731162452-mu0n1m6.png" alt="" title="多核 CPU 的缓存与内存关系图"></p> <p>下面再用一段代码来验证一下多核场景下的可见性问题. 下面的代码, 每执行一次 add10K() 方法, 都会循环 10000 次 <code>count += 1</code>​ 操作. 在 calc() 方法中创建了两个线程, 每个线程调用一次 add10K() 方法. 想一想执行 calc() 方法得到的结果应该是多少呢?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>idx<span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            count <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 创建两个线程, 执行 add() 操作</span>
        <span class="token class-name">Thread</span> th1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
            test<span class="token punctuation">.</span><span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> th2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
            test<span class="token punctuation">.</span><span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 启动两个线程</span>
        th1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        th2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 等待两个线程执行结束</span>
        th1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        th2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>直觉来看应该是 20000, 因为在单线程里调用两次 add10K() 方法, count 的值就是 20000, 但实际上 calc() 的执行结果是个 10000 到 20000 之间的<strong>随机数</strong>. 为什么呢?</p> <p>假设线程 A 和线程 B 同时开始执行, 那么<strong>第一次都会将 count = 0 读到各自的 CPU 缓存里, 执行完 count+=1 之后, 各自 CPU 缓存里的值都是 1, 同时写入内存后, 会发现内存中是 1, 而不是期望的 2</strong>. 之后由于各自的 CPU 缓存里都有了 count 的值, <mark><strong>两个线程都是基于 CPU 缓存里的 count 值来计算, 所以导致最终 count 的值都是小于 20000 的. 这就是缓存的可见性问题</strong></mark>.</p> <p>循环 10000 次 <code>count += 1</code>​ 操作如果改为循环 1 亿次, 就会发现效果更明显, 最终 count 的值接近 1 亿, 而不是 2 亿. 如果循环 10000 次, count 的值接近 20000, 原因是<strong>两个线程不是同时启动的, 有一个时差</strong>.</p> <p><img src="/img/ae4dca1e38c9f70ff196d9b26f63920b-20230731162452-h85x6d4.png" alt="" title="变量 count 在 CPU 缓存和内存的分布图"></p> <h5 id="源头之二-线程切换带来的原子性问题"><a href="#源头之二-线程切换带来的原子性问题" class="header-anchor">#</a> 源头之二:线程切换带来的原子性问题</h5> <p>由于 IO 太慢, 早期的操作系统就发明了多进程, 即便在单核的 CPU 上也可以一边听着歌, 一边写 Bug, 这个就是多进程的功劳.</p> <p>操作系统允许某个进程执行一小段时间, 例如 50 毫秒, 过了 50 毫秒操作系统就会重新选择一个进程来执行(称为&quot;任务切换&quot;), 这个 50 毫秒称为 &quot;<strong>时间片</strong>&quot;.</p> <p><img src="/img/87f461dfb05e073219f70c60ec02fb7d-20230731162452-4xpy8nf.png" alt="" title="线程切换示意图"></p> <p>在一个时间片内, 如果一个进程进行一个 IO 操作, 例如读个文件, 这个时候该进程可以把自己标记为 &quot;休眠状态&quot; 并出让 CPU 的使用权, 待文件读进内存, 操作系统会把这个休眠的进程唤醒, 唤醒后的进程就有机会重新获得 CPU 的使用权了.</p> <p>这里的进程在等待 IO 时之所以会释放 CPU 使用权, 是为了让 CPU 在这段等待时间里可以做别的事情, 这样一来 CPU 的使用率就上来了; 此外, 如果这时有另外一个进程也读文件, 读文件的操作就会排队, 磁盘驱动在完成一个进程的读操作后, 发现有排队的任务, 就会立即启动下一个读操作, 这样 IO 的使用率也上来了.</p> <p>是不是很简单的逻辑? 但是, 虽然看似简单, 支持多进程分时复用在操作系统的发展史上却具有里程碑意义, Unix 就是因为解决了这个问题而名噪天下的.</p> <p>早期的操作系统基于进程来调度 CPU, 不同进程间是不共享内存空间的, 所以进程要做任务切换就要切换内存映射地址, 而一个进程创建的所有线程, 都是共享一个内存空间的, 所以线程做任务切换成本就很低了. 现代的操作系统都基于更轻量的线程来调度, 现在提到的 &quot;任务切换&quot; 都是指 &quot;线程切换&quot;.</p> <p>Java 并发程序都是基于多线程的, 自然也会涉及到任务切换, 也许你想不到, 任务切换竟然也是并发编程里诡异 Bug 的源头之一. <strong>任务切换的时机大多数是在时间片结束的时候</strong>, 现在基本都使用高级语言编程, 高级语言里一条语句往往需要多条 CPU 指令完成, 例如上面代码中的 <code>count += 1</code>​, 至少需要<strong>三条 CPU 指令</strong>.</p> <ul><li>指令 1: 首先需要<strong>把变量 count 从内存加载到 CPU 的寄存器</strong>;</li> <li>指令 2: 之后在<strong>寄存器中执行 +1 操作</strong>;</li> <li>指令 3: 最后<strong>将结果写入内存(缓存机制导致可能写入的是 CPU 缓存而不是内存)</strong> .</li></ul> <p><mark><strong>操作系统做任务切换, 可以发生在任何一条 CPU 指令执行完, 是的, 是 CPU 指令, 而不是高级语言里的一条语句</strong></mark>. 对于上面的三条指令来说, 假设 count = 0, 如果线程 A 在指令 1 执行完后做线程切换, 线程 A 和线程 B 按照下图的序列执行, 那么会发现两个线程都执行了 count += 1 的操作, 但是得到的结果不是期望的 2, 而是 1.</p> <p><img src="/img/370c361a07bb676fab7ddb7bd521495f-20230731162452-4jvgxvv.png" alt="" title="非原子操作的执行路径示意图"></p> <p>有人潜意识里面觉得 count+=1 这个操作是一个不可分割的整体, 就像一个原子一样, 线程的切换可以发生在 count+=1 之前, 也可以发生在 count+=1 之后, 但就是不会发生在中间. <mark><strong>我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性. CPU 能保证的原子操作是 CPU 指令级别的, 而不是高级语言的操作符, 这是违背大家直觉的地方. 因此, 很多时候需要在高级语言层面保证操作的原子性</strong></mark>.</p> <h5 id="源头之三-编译优化带来的有序性问题"><a href="#源头之三-编译优化带来的有序性问题" class="header-anchor">#</a> 源头之三:编译优化带来的有序性问题</h5> <p>那并发编程里还有没有其他有违直觉容易导致诡异 Bug 的技术呢? 还有, 就是有序性. 顾名思义, <strong>有序性指的是程序按照代码的先后顺序执行. 编译器为了优化性能, 有时候会改变程序中语句的先后顺序. ** 例如程序中: &quot;a=6; b=7;&quot; 编译器优化后可能变成 &quot;b=7; a=6;&quot;, 在这个例子中, 编译器调整了语句的顺序, 但是</strong>不影响程序的最终结果**. 不过有时候编译器及解释器的优化可能导致意想不到的 Bug.</p> <p>在 Java 领域一个经典的案例就是利用<strong>双重检查创建单例对象</strong>, 例如下面的代码: 在获取实例 getInstance() 的方法中, 首先判断 instance 是否为空, 如果为空, 则锁定 Singleton.class 并再次检查 instance 是否为空, 如果还为空则创建 Singleton 的一个实例.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>假设有两个线程 A, B 同时调用 getInstance() 方法, 他们会同时发现 <code>instance &lt;mark&gt; null</code>​, 于是同时对 Singleton.class 加锁, 此时 JVM 保证只有一个线程能够加锁成功(假设是线程 A), 另外一个线程则会处于等待状态(假设是线程 B); 线程 A 会创建一个 Singleton 实例, 之后释放锁, 锁释放后, 线程 B 被唤醒, 线程 B 再次尝试加锁, 此时是可以加锁成功的, 加锁成功后, 线程 B 检查 <code>instance &lt;/mark&gt; null</code>​ 时会发现, 已经创建过 Singleton 实例了, 所以线程 B 不会再创建一个 Singleton 实例.</p> <p>这看上去一切都很完美, 无懈可击, 但实际上这个 getInstance() 方法并不完美. 问题出在哪里呢? 出在 new 操作上, 直觉上来说 new 操作应该是:</p> <ol><li>分配一块内存 M;</li> <li>在内存 M 上初始化 Singleton 对象;</li> <li>然后 M 的地址赋值给 instance 变量.</li></ol> <p>但是实际上优化后的执行路径却是这样的:</p> <ol><li><strong>分配一块内存 M;</strong></li> <li><strong>将 M 的地址赋值给 instance 变量;</strong></li> <li><strong>最后在内存 M 上初始化 Singleton 对象.</strong></li></ol> <p>优化后会导致什么问题呢? 假设线程 A 先执行 getInstance() 方法, 当执行完指令 2 时恰好发生了线程切换, 切换到了线程 B 上; 如果此时线程 B 也执行 getInstance() 方法, 那么线程 B 在执行第一个判断时会发现 <code>instance != null</code>​ , 所以直接返回 instance, 而此时的 instance 是没有初始化过的, 如果这个时候访问 instance 的成员变量就可能<strong>触发空指针异常</strong>.</p> <p><img src="/img/f4bb30d80d60516da1d62ade65c38e85-20230731162452-l36ihqx.png" alt="" title="双重检查创建单例的异常执行路径"></p> <h5 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h5> <p>要写好并发程序, 首先要知道并发程序的问题在哪里, 只有确定了 &quot;靶子&quot;, 才有可能把问题解决, 毕竟所有的解决方案都是针对问题的. 并发程序经常出现的诡异问题看上去非常无厘头, 但是深究的话, 无外乎就是直觉欺骗了我们, <strong>只要能够深刻理解可见性, 原子性, 有序性在并发场景下的原理, 很多并发 Bug 都是可以理解, 可以诊断的</strong>.</p> <p>在介绍可见性, 原子性, 有序性的时候, 特意提到<strong>缓存</strong>导致的可见性问题, <strong>线程切换</strong>带来的原子性问题, <strong>编译优化</strong>带来的有序性问题, 其实缓存, 线程, 编译优化的目的和写并发程序的目的是相同的, 都是提高程序性能. 但是技术在解决一个问题的同时, 必然会带来另外一个问题, 所以<strong>在采用一项技术的同时, 一定要清楚它带来的问题是什么, 以及如何规避</strong>.</p> <h4 id="_02-java内存模型-java如何解决可见性和有序性问题🍀"><a href="#_02-java内存模型-java如何解决可见性和有序性问题🍀" class="header-anchor">#</a> 02-Java内存模型:Java如何解决可见性和有序性问题🍀</h4> <p>上一节讲到在并发场景中, 因<strong>可见性, 原子性, 有序性</strong>导致的问题常常会违背大家的直觉, 从而成为并发编程的 Bug 之源. 这三者在编程领域属于<strong>共性问题</strong>, 所有的编程语言都会遇到, Java 在诞生之初就支持多线程, 自然也有针对这三者的技术方案, 而且在编程语言领域处于领先地位. 理解 Java 解决并发问题的解决方案, 对于理解其他语言的解决方案有触类旁通的效果.</p> <p>那就先来聊聊如何解决其中的<strong>可见性和有序性</strong>导致的问题, 这也就引出来了今天的主角--<strong>Java 内存模型</strong>.</p> <h5 id="什么是java内存模型"><a href="#什么是java内存模型" class="header-anchor">#</a> 什么是Java内存模型?</h5> <p>前面提到, <mark><strong>导致可见性的原因是缓存, 导致有序性的原因是编译优化,</strong></mark>  那解决可见性, 有序性最直接的办法就是<mark><strong>禁用缓存和编译优化</strong></mark>, 但是这样问题虽然解决了, 那程序的性能可就堪忧了.</p> <p>合理的方案应该是<strong>按需禁用缓存以及编译优化</strong>. 如何做到 &quot;按需禁用&quot; 呢? 对于并发程序, 何时禁用缓存以及编译优化只有程序员知道, 那<strong>所谓 &quot;按需禁用&quot; 其实就是指按照程序员的要求来禁用</strong>. 所以为了解决可见性和有序性问题, <strong>只需要提供给程序员按需禁用缓存和编译优化的方法即可</strong>.</p> <p>Java 内存模型是个很复杂的规范, 可以从不同的视角来解读, 站在程序员的视角, 本质上可以理解为, <mark><strong>Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法</strong></mark>. 具体来说, 这些方法包括 <strong>volatile</strong>, <strong>synchronized</strong> 和 <strong>final</strong> 三个关键字, 以及六项 <strong>Happens-Before 规则</strong>, 这也正是本节的重点内容.</p> <h5 id="使用volatile的困惑"><a href="#使用volatile的困惑" class="header-anchor">#</a> 使用volatile的困惑</h5> <p>volatile 关键字并不是 Java 的特产, 古老的 C 语言里也有, 它最原始的意义就是禁用 CPU 缓存.</p> <p>例如, 声明一个 volatile 变量 <code>volatile int x = 0</code>​, 它表达的是: <strong>告诉编译器, 对这个变量的读写, 不能使用 CPU 缓存, 必须从内存中读取或者写入</strong>. 这个语义看上去相当明确, 但是在实际使用的时候却会带来困惑.</p> <p>例如下面的示例代码, 假设线程 A 执行 writer() 方法, 按照 volatile 语义, 会把变量 &quot;v=true&quot; 写入内存; 假设线程 B 执行 reader() 方法, 同样按照 volatile 语义, 线程 B 会从内存中读取变量 v, 如果线程 B 看到 &quot;v == true&quot; 时, 那么线程 B 看到的变量 x 是多少呢?</p> <p>直觉上看, 应该是 42, 那实际应该是多少呢? 这个要看 Java 的版本, 如果在低于 1.5 版本上运行, x 可能是 42, 也有可能是 0; <strong>如果在 1.5 以上的版本上运行, x 就是等于 42</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 以下代码来源于【参考 1】</span>
<span class="token keyword">class</span> <span class="token class-name">VolatileExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> v <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
        v <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 这里 x 会是多少呢? </span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>分析一下, 为什么 1.5 以前的版本会出现 x = 0 的情况呢? 我相信你一定想到了, <strong>变量 x 可能被 CPU 缓存而导致可见性问题</strong>. 这个问题在 1.5 版本已经被圆满解决了. Java 内存模型在 1.5 版本对 volatile 语义进行了增强. 怎么增强的呢? 答案是一项 <strong>Happens-Before 规则</strong>.</p> <h5 id="happens-before规则"><a href="#happens-before规则" class="header-anchor">#</a> Happens-Before规则</h5> <p>如何理解 Happens-Before 呢? 如果望文生义(很多网文也都爱按字面意思翻译成&quot;先行发生&quot;), 那就南辕北辙了, Happens-Before 并不是说前面一个操作发生在后续操作的前面, 它真正要表达的是: <mark><strong>前面一个操作的结果对后续操作是可见的</strong></mark>. 就像有心灵感应的两个人, 虽然远隔千里, 一个人心之所想, 另一个人都看得到. Happens-Before 规则就是要保证线程之间的这种 &quot;心灵感应&quot;. 所以比较正式的说法是: <strong>Happens-Before 约束了编译器的优化行为, 虽允许编译器优化, 但是要求编译器优化后一定遵守 Happens-Before 规则</strong>.</p> <p>Happens-Before 规则应该是 Java 内存模型里面最晦涩的内容了, 和程序员相关的规则一共有如下六项, <strong>都是关于可见性</strong>的.</p> <p>恰好前面示例代码涉及到这六项规则中的前三项, 为便于理解, 也会分析上面的示例代码, 来看看规则 1, 2 和 3 到底该如何理解. 至于其他三项, 也会结合其他例子作以说明.</p> <h6 id="_1-程序的顺序性规则"><a href="#_1-程序的顺序性规则" class="header-anchor">#</a> (1)程序的顺序性规则</h6> <p>这条规则是<strong>指在一个线程中, 按照程序顺序, 前面的操作 Happens-Before 于后续的任意操作</strong>. 这还是比较容易理解的, 比如刚才那段示例代码, 按照程序的顺序, 代码 &quot;x = 42;&quot; Happens-Before 于代码 &quot;v = true;&quot;, 这就是规则 1 的内容, 也比较符合单线程里面的思维: <mark><strong>程序前面对某个变量的修改一定是对后续操作可见的</strong></mark>.</p> <p>为方便查看, 这里将那段示例代码放这里.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 以下代码来源于【参考 1】</span>
<span class="token keyword">class</span> <span class="token class-name">VolatileExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> v <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
        v <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 这里 x 会是多少呢? </span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h6 id="_2-volatile变量规则"><a href="#_2-volatile变量规则" class="header-anchor">#</a> (2)volatile变量规则</h6> <p>这条规则是指<strong>对一个 volatile 变量的写操作, Happens-Before 于后续对这个 volatile 变量的读操作</strong>.</p> <p>这个就有点费解了, 对一个 volatile 变量的写操作相对于后续对这个 volatile 变量的读操作可见, 这怎么看都是禁用缓存的意思啊, 貌似和 1.5 版本以前的语义没有变化啊? 如果单看这个规则, 的确是这样, 但是如果关联一下规则 3, 就有点不一样的感觉了.</p> <h6 id="_3-传递性"><a href="#_3-传递性" class="header-anchor">#</a> (3)传递性</h6> <p>这条规则是指<strong>如果 A Happens-Before B, 且 B Happens-Before C, 那么 A Happens-Before C</strong>.</p> <p>将规则 3 的传递性应用到上面的例子中, 会发生什么呢? 可以看下面的图:</p> <p><img src="/img/23a76954d4683a18877e907d51017937-20230731162452-vxswniq.png" alt="" title="示例代码中的传递性规则"></p> <p>从图中可以看到:</p> <ol><li>&quot;x=42&quot; Happens-Before 写变量 &quot;v=true&quot; , 这是<strong>规则 1</strong> 的内容;</li> <li>写变量 &quot;v=true&quot; Happens-Before 读变量 &quot;v=true&quot;, 这是<strong>规则 2</strong> 的内容 .</li></ol> <p>再根据这个传递性规则, 就能得到结果: &quot;x=42&quot; Happens-Before 读变量 &quot;v=true&quot;. 这意味着什么呢?</p> <p>如果<strong>线程 B 读到了 &quot;v=true&quot;, 那么线程 A 设置的 &quot;x=42&quot; 对线程 B 是可见的</strong>. 也就是说, 线程 B 能看到 &quot;x == 42&quot;, 有没有一种恍然大悟的感觉? 这就是 1.5 版本对 volatile 语义的增强, <strong>这个增强意义重大, 1.5 版本的并发工具包(java.util.concurrent)就是靠 volatile 语义来搞定可见性的</strong>, 这个在后面会详细介绍.</p> <h6 id="_4-管程中锁的规则"><a href="#_4-管程中锁的规则" class="header-anchor">#</a> (4)管程中锁的规则</h6> <p>这条规则是指<strong>对一个锁的解锁 Happens-Before 于后续对这个锁的加锁</strong>.</p> <p>要理解这个规则, 就首先要了解 &quot;管程指的是什么&quot;. <strong>管程</strong>是一种通用的同步原语, <strong>在 Java 中指的就是 synchronized, synchronized 是 Java 里对管程的实现</strong>.</p> <p>管程中的锁在 Java 里是隐式实现的, 例如下面的代码, 在进入同步块之前, 会自动加锁, 而在代码块执行完会自动释放锁, 加锁以及释放锁都是编译器实现的.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 此处自动加锁</span>
    <span class="token comment">// x 是共享变量, 初始值 =10</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span> <span class="token comment">// 此处自动解锁</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>所以结合规则 4, 可以这样理解: 假设 x 的初始值是 10, 线程 A 执行完代码块后 x 的值会变成 12(执行完自动释放锁), 线程 B 进入代码块时, 能够看到线程 A 对 x 的写操作, 也就是线程 B 能够看到 x==12. 这个也是符合直觉的, 应该不难理解.</p> <h6 id="_5-线程start-规则"><a href="#_5-线程start-规则" class="header-anchor">#</a> (5)线程start()规则</h6> <p>这条是关于线程启动的. 它是<strong>指主线程 A 启动子线程 B 后, 子线程 B 能够看到主线程在启动子线程 B 前的操作</strong>.  换句话说就是, <strong>如果线程 A 调用线程 B 的 start() 方法(即在线程 A 中启动线程 B), 那么该 start() 操作 Happens-Before 于线程 B 中的任意操作</strong>. 具体可参考下面示例代码.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Thread</span> <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 主线程调用 B.start() 之前</span>
    <span class="token comment">// 所有对共享变量的修改, 此处皆可见</span>
    <span class="token comment">// 此例中, var==77</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 此处对共享变量 var 修改</span>
<span class="token keyword">var</span> <span class="token operator">=</span> <span class="token number">77</span><span class="token punctuation">;</span>
<span class="token comment">// 主线程启动子线程</span>
<span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h6 id="_6-线程join-规则"><a href="#_6-线程join-规则" class="header-anchor">#</a> (6)线程join()规则</h6> <p>这条是关于<strong>线程等待</strong>的. 它是指主线程 A 等待子线程 B 完成(主线程 A 通过调用子线程 B 的 join() 方法实现), 当子线程 B 完成后(主线程 A 中 join() 方法返回), 主线程能够看到子线程的操作. 当然所谓的 &quot;看到&quot;, 指的是对<strong>共享变量</strong>的操作.</p> <p>换句话说就是, <strong>如果在线程 A 中, 调用线程 B 的 join() 并成功返回, 那么线程 B 中的任意操作 Happens-Before 于该 join() 操作的返回</strong>. 具体可参考下面示例代码.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Thread</span> <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 此处对共享变量 var 修改</span>
    <span class="token keyword">var</span> <span class="token operator">=</span> <span class="token number">66</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 例如此处对共享变量修改, </span>
<span class="token comment">// 则这个修改结果对线程 B 可见</span>
<span class="token comment">// 主线程启动子线程</span>
<span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 子线程所有对共享变量的修改</span>
<span class="token comment">// 在主线程调用 B.join() 之后皆可见</span>
<span class="token comment">// 此例中, var==66</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h5 id="被忽视的final"><a href="#被忽视的final" class="header-anchor">#</a> 被忽视的final</h5> <p>前面讲 volatile 为的是禁用缓存以及编译优化, 下面再从另外一个方面来看, 有没有办法告诉编译器优化得更好一点呢? 这个可以有, 就是 <strong>final 关键字</strong>.</p> <p><mark><strong>final 修饰变量时, 初衷是告诉编译器: 这个变量生而不变, 可以使劲儿优化</strong></mark>​ <strong>.</strong>  Java 编译器在 1.5 以前的版本的确优化得很努力, 以至于都优化错了.</p> <p>问题类似于前面提到的利用双重检查方法创建单例, 构造函数的错误重排导致线程可能看到 final 变量的值会变化.  在 1.5 以后 Java 内存模型对 final 类型变量的重排进行了约束. 现在只要提供正确构造函数没有 &quot;逸出&quot;, 就不会出问题了.</p> <p>&quot;逸出&quot; 有点抽象, 还是举个例子, 在下面例子中, 在构造函数里面将 this 赋值给了全局变量 global.obj, 这就是 &quot;逸出&quot;, 线程通过 global.obj 读取 x 是有可能读到 0 的. 因此一定要避免 &quot;逸出&quot;.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 以下代码来源于【参考 1】</span>
<span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
<span class="token comment">// 错误的构造函数</span>
<span class="token keyword">public</span> <span class="token class-name">FinalFieldExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    y <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// 此处就是讲 this 逸出</span>
    global<span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h5 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h5> <p>Java 的内存模型是并发编程领域的一次重要创新, 之后 C++, C#, Golang 等高级语言都开始支持内存模型. Java 内存模型里面, 最晦涩的部分就是 Happens-Before 规则了, Happens-Before 规则最初是在一篇叫做<strong>Time, Clocks, and the Ordering of Events in a Distributed System</strong> 的论文中提出来的, 在这篇论文中, Happens-Before 的语义是一种因果关系. 在现实世界里, <mark><strong>如果 A 事件是导致 B 事件的起因, 那么 A 事件一定是先于(Happens-Before)B 事件发生的, 这个就是 Happens-Before 语义的现实理解</strong></mark>.</p> <p>在 Java 语言里面, <strong>Happens-Before 的语义本质上是一种可见性, A Happens-Before B 意味着 A 事件对 B 事件来说是可见的, 无论 A 事件和 B 事件是否发生在同一个线程里. 例如 A 事件发生在线程 1 上, B 事件发生在线程 2 上, Happens-Before 规则保证线程 2 上也能看到 A 事件的发生</strong>.</p> <p>Java 内存模型主要分为两部分, 一部分面向编写并发程序的应用开发人员, 另一部分是面向 JVM 的实现人员的, 一般可以重点关注前者, 也就是和编写并发程序相关的部分, 这部分内容的核心就是 Happens-Before 规则.</p> <h5 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h5> <ol><li><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="noopener noreferrer">JSR 133 (Java Memory Model) FAQ<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://ifeve.com/jmm-faq/" target="_blank" rel="noopener noreferrer">Java 内存模型 FAQ<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf" target="_blank" rel="noopener noreferrer">JSR-133: Java^(TM) Memory Model and Thread Specification<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h4 id="_03-互斥锁-上-解决原子性问题🍀"><a href="#_03-互斥锁-上-解决原子性问题🍀" class="header-anchor">#</a> 03-互斥锁(上):解决原子性问题🍀</h4> <p>前面提到, <strong>一个或者多个操作在 CPU 执行的过程中不被中断的特性, 称为 &quot;原子性&quot;</strong> . 理解这个特性有助于分析并发编程 Bug 出现的原因, 例如利用它可以分析出 long 型变量在 32 位机器上读写可能出现的诡异 Bug, 明明已经把变量成功写入内存, 重新读出来却不是自己写入的.</p> <p>**那原子性问题到底该如何解决呢? **</p> <p>原子性问题的源头是<strong>线程切换</strong>, 如果能够<strong>禁用线程切换</strong>那不就能解决这个问题了吗? 而操作系统做线程切换是依赖 CPU 中断的, 所以<strong>禁止 CPU 发生中断就能够禁止线程切换</strong>.</p> <p>在早期单核 CPU 时代, 这个方案的确是可行的, 而且也有很多应用案例, 但是并不适合多核场景. 这里以 32 位 CPU 上执行 long 型变量的写操作为例来说明这个问题, long 型变量是 64 位, 在 32 位 CPU 上执行写操作会被<strong>拆分成两次写操作</strong>(写高 32 位和写低 32 位, 如下图所示).</p> <p><img src="/img/65c4982ab38a640f67f0ee4bceb8f14a-20230731162452-dvcz737.png" alt=""></p> <p>在单核 CPU 场景下, 同一时刻只有一个线程执行, 禁止 CPU 中断, 意味着操作系统不会重新调度线程, 也就是禁止了线程切换, 获得 CPU 使用权的线程就可以不间断地执行, 所以两次写操作一定是: 要么都被执行, 要么都没有被执行, 具有原子性.</p> <p>但是<strong>在多核场景</strong>下, 同一时刻, 有可能有两个线程同时在执行, 一个线程执行在 CPU-1 上, 一个线程执行在 CPU-2 上, 此时禁止 CPU 中断, <strong>只能保证 CPU 上的线程连续执行, 并不能保证同一时刻只有一个线程执行</strong>, 如果这两个线程同时写 long 型变量高 32 位的话, 那就有可能出现开头提及的诡异 Bug 了.</p> <p>&quot;<strong>同一时刻只有一个线程执行</strong>&quot; 这个条件非常重要, 这称为<strong>互斥</strong>. 如果能够<strong>保证对共享变量的修改是互斥</strong>的, 那无论是单核 CPU 还是多核 CPU, 就都能保证<strong>原子性</strong>了.</p> <h5 id="简易锁模型"><a href="#简易锁模型" class="header-anchor">#</a> 简易锁模型</h5> <p>当谈到互斥, 相信你一定想到了那个杀手级解决方案: <strong>锁</strong>. 同时大脑中还会出现以下模型:</p> <p><img src="/img/c32f1f9b70962824332da0201d509193-20230731162452-sqb50su.png" alt="" title="简易锁模型"></p> <p>一段<strong>需要互斥执行的代码</strong>一般称为<strong>临界区</strong>. 线程在进入临界区之前, 首先尝试加锁 lock(), 如果成功, 则进入临界区, 此时称这个线程持有锁; 否则就等待, 直到持有锁的线程解锁; 持有锁的线程执行完临界区的代码后, 执行解锁 unlock().</p> <p>这个过程非常像办公室里高峰期抢占坑位, 每个人都是进坑锁门(加锁), 出坑开门(解锁), 如厕这个事就是临界区. 很长时间里, 我也是这么理解的. 这样理解本身没有问题, 但却很容易忽视两个非常非常重要的点: <strong>我们锁的是什么? 我们保护的又是什么?</strong></p> <h5 id="改进后的锁模型"><a href="#改进后的锁模型" class="header-anchor">#</a> 改进后的锁模型</h5> <p>在现实世界里, <strong>锁和锁要保护的资源是有对应关系的</strong>, 比如你用你家的锁保护你家的东西, 我用我家的锁保护我家的东西. 在并发编程世界里, <strong>锁和资源</strong>也应该有这个关系, 但这个关系在上面的模型中是没有体现的, 所以需要完善一下这个模型.</p> <p><img src="/img/670687e46d10a0192ea89ae11a1dd5d1-20230731162452-l6qzldz.png" alt="" title="改进后的锁模型"></p> <p>首先, <strong>要把临界区要保护的资源标注出来</strong>, 如图中临界区里增加了一个元素: <strong>受保护的资源 R</strong>; 其次, <strong>要保护资源 R 就得为它创建一把锁 LR</strong>; 最后, <strong>针对这把锁 LR, 还需在进出临界区时添上加锁操作和解锁操作</strong>. 另外, 在锁 LR 和受保护资源之间, 特地用一条线做了关联, 这个关联关系非常重要. <strong>很多并发 Bug 的出现都是因为把它忽略了, 然后就出现了类似锁自家门来保护他家资产的事情</strong>, 这样的 Bug 非常不好诊断, 因为潜意识里可能认为已经正确加锁了.</p> <h5 id="java-语言提供的锁技术-synchronized"><a href="#java-语言提供的锁技术-synchronized" class="header-anchor">#</a> Java 语言提供的锁技术:synchronized</h5> <p>锁是一种通用的技术方案, Java 语言提供的 <strong>synchronized</strong> 关键字, 就是锁的一种<strong>实现</strong>. synchronized 关键字可以用来修饰方法, 也可以用来修饰代码块, 它的使用示例基本上都是下面这个样子:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
    <span class="token comment">// 修饰非静态方法</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 临界区</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 修饰静态方法</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 临界区</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 修饰代码块</span>
    <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">void</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 临界区</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>看完之后你可能会觉得有点奇怪, 这个和我上面提到的模型有点对不上号啊, 加锁 lock() 和解锁 unlock() 在哪里呢? 其实这两个操作都是有的, 只是<strong>这两个操作是被 Java 默默加上的, Java 编译器会在 synchronized 修饰的方法或代码块前后自动加上加锁 lock() 和解锁 unlock()</strong> , 这样做的好处就是加锁 lock() 和解锁 unlock() 一定是成对出现的, 毕竟忘记解锁 unlock() 可是个致命的 Bug(意味着其他线程只能死等下去了).</p> <p>那 synchronized 里的加锁 lock() 和解锁 unlock() <strong>锁定的对象</strong>在哪里呢? 上面的代码只有修饰代码块的时候, 锁定了一个 obj 对象, 那修饰方法的时候锁定的是什么呢? 这个也是 Java 的一条隐式规则:</p> <blockquote><p>当修饰静态方法的时候, 锁定的是当前类的 Class 对象, 在上面的例子中就是 Class X;
当修饰非静态方法的时候, 锁定的是当前实例对象 this.</p></blockquote> <p>对于上面的例子, synchronized 修饰静态方法相当于:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
    <span class="token comment">// 修饰静态方法</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">X</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 临界区</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>修饰非静态方法, 相当于:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
    <span class="token comment">// 修饰非静态方法</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 临界区</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h5 id="用synchronized解决count-1问题"><a href="#用synchronized解决count-1问题" class="header-anchor">#</a> 用synchronized解决count+=1问题</h5> <p>回想一下提到过的 count+=1 存在的并发问题, 现在可以尝试用 synchronized 来改一改, 代码如下所示. SafeCalc 这个类有两个方法: 一个是 get() 方法, 用来获得 value 的值; 另一个是 addOne() 方法, 用来给 value 加 1, 并且 addOne() 方法用 synchronized 修饰. 那么使用的这两个方法有没有并发问题呢?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">SafeCalc</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> value <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        value <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>先来看看 addOne() 方法, 首先可以肯定, 被 synchronized 修饰后, 无论是单核 CPU 还是多核 CPU, 只有一个线程能够执行 addOne() 方法, 所以一定能保证原子操作, 那<strong>是否有可见性问题</strong>呢? 要回答这问题, 就要重温一下上一节提到的<strong>管程中锁的规则</strong>.</p> <blockquote><p>管程中锁的规则: 对一个锁的解锁 Happens-Before 于后续对这个锁的加锁.</p></blockquote> <p><strong>管程, 就是这里的 synchronized</strong>(至于为什么叫管程, 后面会介绍), synchronized 修饰的临界区是<strong>互斥</strong>的, 也就是说同一时刻只有一个线程执行临界区的代码; 而所谓 &quot;对一个锁解锁 Happens-Before 后续对这个锁的加锁&quot;, 指的是**前一个线程的解锁操作对后一个线程的加锁操作可见, 综合 Happens-Before 的传递性原则, 就能知道前一个线程在临界区修改的共享变量(该操作在解锁之前), 对后续进入临界区(该操作在加锁之后)的线程是可见的. 所以, 这里可见性问题就已经解决了. **</p> <p>按照这个规则, 如果多个线程同时执行 addOne() 方法, <strong>可见性是可以保证</strong>的, 也就说如果有 1000 个线程执行 addOne() 方法, 最终结果一定是 value 的值增加了 1000. 问题终于解决了!</p> <p>但也许, 你一不小心就忽视了 get() 方法. 执行 addOne() 方法后, value 的值对 get() 方法是可见的吗? 这个可见性是<strong>没法保证</strong>的. <strong>管程中锁的规则, 是只保证后续对这个锁的加锁的可见性</strong>, 而 get() 方法并没有加锁操作, 所以可见性没法保证. 那如何解决呢? 很简单, 就是 get() 方法也 synchronized 一下, 完整的代码如下所示.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">SafeCalc</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> value <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        value <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>上面的代码转换为提到的锁模型, 就是下图这样. get() 方法和 addOne() 方法都需要访问 value 这个受保护的资源, 这个资源<strong>用 this 这把锁</strong>来保护. 线程要进入临界区 get() 和 addOne(), 必须先获得 this 这把锁, 这样 get() 和 addOne() 也是互斥的.</p> <p><img src="/img/1968c7229a80d117d55346f1ad6fb8fe-20230731162452-9sc3zn2.png" alt="" title="保护临界区 get() 和 addOne() 的示意图"></p> <p>这个模型更像现实世界里面球赛门票的管理, 一个座位只允许一个人使用, 这个座位就是 &quot;受保护资源&quot;, 球场的入口就是 Java 类里的方法, 而门票就是用来保护资源的 &quot;锁&quot;, Java 里的检票工作是由 synchronized 解决的.</p> <h5 id="锁和受保护资源的关系"><a href="#锁和受保护资源的关系" class="header-anchor">#</a> 锁和受保护资源的关系</h5> <p>前面提到, 受保护资源和锁之间的关联关系非常重要, 他们的关系是怎样的呢? 一个合理的关系是: <mark><strong>受保护资源和锁之间的关联关系是 N:1 的关系</strong></mark>. 还拿前面球赛门票的管理来类比, 就是一个座位, 只能用一张票来保护, 如果多发了重复的票, 那就要打架了. 现实世界里, 可以用多把锁来保护同一个资源, 但在并发领域是不行的, 并发领域的锁和现实世界的锁不是完全匹配的. 不过倒是可以用同一把锁来保护多个资源, 这个对应到现实世界就是所谓的 &quot;包场&quot; 了.</p> <p>上面那个例子稍作改动, 把 value 改成静态变量, 把 addOne() 方法改成静态方法, 此时 get() 方法和 addOne() 方法是否存在并发问题呢?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">SafeCalc</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">long</span> value <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        value <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>如果仔细观察, 就会发现改动后的代码是<strong>用两个锁保护一个资源</strong>. 这个受保护的资源就是静态变量 value, 两个锁分别是 this 和 SafeCalc.class. 可以用下面这幅图来形象描述这个关系. <strong>由于临界区 get() 和 addOne() 是用两个锁保护的, 因此这两个临界区没有互斥关系, 临界区 addOne() 对 value 的修改对临界区 get() 也没有可见性保证, 这就导致并发问题了</strong>.</p> <p><img src="/img/a160200b55c66e18fcd9c27fbccfeb1c-20230731162452-sm76891.png" alt="" title="两把锁保护一个资源的示意图"></p> <h5 id="总结-3"><a href="#总结-3" class="header-anchor">#</a> 总结</h5> <p>互斥锁, 在并发领域的知名度极高, 只要有了并发问题, 大家首先容易想到的就是加锁, 因为大家都知道, 加锁能够保证执行临界区代码的互斥性. 这样理解虽然正确, 但是却不能够指导你真正用好互斥锁. 临界区的代码是操作受保护资源的路径, 类似于球场的入口, 入口一定要检票, 也就是要加锁, 但不是随便一把锁都能有效. 所以<strong>必须深入分析锁定的对象和受保护资源的关系, 综合考虑受保护资源的访问路径, 多方面考量才能用好互斥锁</strong>.</p> <p>synchronized 是 Java 在语言层面提供的互斥原语, 其实 Java 里面还有很多其他类型的锁, 但作为互斥锁, 原理都是相通的: 锁, 一定有一个要锁定的对象, 至于这个锁定的对象要保护的资源以及在哪里加锁/解锁, 就属于设计层面的事情了.</p> <h4 id="_04-互斥锁-下-如何用一把锁保护多个资源-🍀"><a href="#_04-互斥锁-下-如何用一把锁保护多个资源-🍀" class="header-anchor">#</a> 04-互斥锁(下):如何用一把锁保护多个资源?🍀</h4> <p>上一节提到<strong>受保护资源和锁之间合理的关联关系应该是 N:1 的关系</strong>, 也就是说可以用一把锁来保护多个资源, 但是不能用多把锁来保护一个资源, 并且也重点强调了 &quot;不能用多把锁来保护一个资源&quot; 这个问题. 而至于<strong>如何保护多个资源</strong>, 今天就来聊聊. 当要保护多个资源时, <strong>首先要区分这些资源是否存在关联关系</strong>.</p> <h5 id="保护没有关联关系的多个资源"><a href="#保护没有关联关系的多个资源" class="header-anchor">#</a> 保护没有关联关系的多个资源</h5> <p>在现实世界里, 球场的座位和电影院的座位就是没有关联关系的, 这种场景非常容易解决, 那就是球赛有球赛的门票, 电影院有电影院的门票, 各自管理各自的.</p> <p>同样这对应到编程领域, 也很容易解决. 例如, 银行业务中有针对账户余额(余额是一种资源)的取款操作, 也有针对账户密码(密码也是一种资源)的更改操作, 可以为账户余额和账户密码分配不同的锁来解决并发问题, 这个还是很简单的.</p> <p>相关的示例代码如下, 账户类 Account 有两个成员变量, 分别是账户余额 balance 和账户密码 password. 取款 withdraw() 和查看余额 getBalance() 操作会访问账户余额 balance, 我们创建一个 final 对象 <strong>balLock</strong> 作为锁(类比球赛门票); 而更改密码 updatePassword() 和查看密码 getPassword() 操作会修改账户密码 password, 我们创建一个 final 对象 <strong>pwLock</strong> 作为锁(类比电影票). 不同的资源用不同的锁保护, 各自管各自的, 很简单.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>
    <span class="token comment">// 锁: 保护账户余额</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> balLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 账户余额  </span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> balance<span class="token punctuation">;</span>
    <span class="token comment">// 锁: 保护账户密码</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> pwLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 账户密码</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>

    <span class="token comment">// 取款</span>
    <span class="token keyword">void</span> <span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span>balLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">&gt;</span> amt<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 查看余额</span>
    <span class="token class-name">Integer</span> <span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span>balLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> balance<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 更改密码</span>
    <span class="token keyword">void</span> <span class="token function">updatePassword</span><span class="token punctuation">(</span><span class="token class-name">String</span> pw<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span>pwLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> pw<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 查看密码</span>
    <span class="token class-name">String</span> <span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span>pwLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> password<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><p>当然也可以用一把互斥锁来保护多个资源, 例如可以用 this 这一把锁来管理账户类里<strong>所有的资源</strong>: 账户余额和用户密码. 具体实现很简单, 示例程序中所有的方法都增加同步关键字 synchronized 就可以了, 这里就不一一展示了.</p> <p>但是<strong>用一把锁有个问题, 就是性能太差</strong>, 会导致取款, 查看余额, 修改密码, 查看密码这四个操作都是串行的. 而用两把锁, 取款和修改密码是可以并行的. <strong>用不同的锁对受保护资源进行精细化管理, 能够提升性能</strong>. 这种锁还有个名字, 叫<strong>细粒度锁</strong>.</p> <h5 id="保护有关联关系的多个资源"><a href="#保护有关联关系的多个资源" class="header-anchor">#</a> 保护有关联关系的多个资源</h5> <p>如果多个资源是<strong>有关联关系</strong>的, 那这个问题就有点复杂了. 例如银行业务里面的转账操作, 账户 A 减少 100 元, 账户 B 增加 100 元. 这两个账户就是有关联关系的. 那对于像转账这种有关联关系的操作, 应该怎么去解决呢? 先把这个问题代码化. 先声明一个账户类: Account, 该类有一个成员变量余额: balance, 还有一个用于转账的方法: transfer(), 然后怎么保证转账操作 transfer() 没有并发问题呢?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> balance<span class="token punctuation">;</span>
    <span class="token comment">// 转账</span>
    <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">&gt;</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>
            target<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>相信你的直觉会告诉你这样的解决方案: 用户 synchronized 关键字修饰一下 transfer() 方法就可以了, 于是你很快就完成了相关的代码, 如下所示.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> balance<span class="token punctuation">;</span>
    <span class="token comment">// 转账</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">&gt;</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>
            target<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在这段代码中, <strong>临界区内有两个资源</strong>, 分别是转出账户的余额 this.balance 和转入账户的余额 target.balance, 并且用的是一把锁 this, 符合前面提到的, 多个资源可以用一把锁来保护, 这看上去完全正确呀. 真的是这样吗? 可惜, 这个方案仅仅是看似正确, 为什么呢?</p> <p>问题就出在 this 这把锁上, <strong>this 这把锁可以保护自己的余额 this.balance, 却保护不了别人的余额 target.balance</strong>, 就像你不能用自家的锁来保护别人家的资产, 也不能用自己的票来保护别人的座位一样.</p> <p><img src="/img/0fbd63fec759e409f45ca4982f82a014-20230731162452-daob240.png" alt="" title="用锁 this 保护 this.balance 和 target.balance 的示意图"></p> <p>下面具体分析一下, 假设有 A, B, C 三个账户, 余额都是 200 元, 用两个线程分别执行两个转账操作: 账户 A 转给账户 B 100 元, 账户 B 转给账户 C 100 元, 最后期望的结果应该是账户 A 的余额是 100 元, 账户 B 的余额是 200 元,  账户 C 的余额是 300 元.</p> <p>假设线程 1 执行账户 A 转账户 B 的操作, 线程 2 执行账户 B 转账户 C 的操作. 这两个线程分别<strong>在两颗 CPU 上同时执行</strong>, 那它们是互斥的吗? <strong>实际上并不是. 因为线程 1 锁定的是账户 A 的实例(A.this), 而线程 2 锁定的是账户 B 的实例(B.this), 所以这两个线程可以同时进入临界区 transfer()</strong> . 同时进入临界区的结果是什么呢? 线程 1 和线程 2 都会读到账户 B 的余额为 200, 导致最终账户 B 的余额可能是 300(线程 1 后于线程 2 写 B.balance, 线程 2 写的 B.balance 值被线程 1 覆盖), 可能是 100(线程 1 先于线程 2 写 B.balance, 线程 1 写的 B.balance 值被线程 2 覆盖), 就是不可能是 200.</p> <p><img src="/img/647b7a28f42f45d85b236588f66b3f98-20230731162452-58pr1ra.png" alt="" title="并发转账示意图"></p> <h5 id="使用锁的正确姿势"><a href="#使用锁的正确姿势" class="header-anchor">#</a> 使用锁的正确姿势</h5> <p>在上一节提到用同一把锁来保护多个资源, 也就是现实世界的 &quot;包场&quot;, 那在编程领域应该怎么 &quot;包场&quot; 呢? 很简单, 只要<strong>锁能覆盖所有受保护资源</strong>就可以了. 在上面的例子中, <strong>this 是对象级别的锁, 所以 A 对象和 B 对象都有自己的锁, 如何让 A 对象和 B 对象共享一把锁呢</strong>?</p> <p>其实方案还挺多的, <strong>比如可以让所有对象都持有一个唯一性的对象</strong>, 这个对象在创建 Account 时传入. 方案有了, 完成代码就简单了. 示例代码如下, 把 Account 默认构造函数变为 private, 同时增加一个带 Object lock 参数的构造函数, <strong>创建 Account 对象时, 传入相同的 lock, 这样所有的 Account 对象都会共享这个 lock 了</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span> lock<span class="token punctuation">;</span> 
    <span class="token keyword">private</span> <span class="token keyword">int</span> balance<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Account</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 创建 Account 时传入同一个 lock 对象</span>
    <span class="token keyword">public</span> <span class="token class-name">Account</span><span class="token punctuation">(</span><span class="token class-name">Object</span> lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>lock <span class="token operator">=</span> lock<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 转账</span>
    <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 此处检查所有对象共享的锁</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">&gt;</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>
                target<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>这个办法确实能解决问题, 但是有点小瑕疵, 它要求在创建 Account 对象的时候必须传入同一个对象, 如果创建 Account 对象时, 传入的 lock 不是同一个对象, 那可就惨了, 会出现锁自家门来保护他家资产的荒唐事. 在真实的项目场景中, 创建 Account 对象的代码很可能分散在多个工程中, 传入共享的 lock 真的很难.</p> <p>所以, 上面的方案缺乏实践的可行性, 需要更好的方案. 还真有, 就是<strong>用 Account.class 作为共享的锁</strong>. <strong>Account.class 这个类对象是所有 Account 对象共享的, 而且这个对象是 Java 虚拟机在加载 Account 类的时候创建的, 所以不用担心它的唯一性</strong>. 使用 Account.class 作为共享的锁, 就无需在创建 Account 对象时传入了, 代码更简单.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> balance<span class="token punctuation">;</span>
    <span class="token comment">// 转账</span>
    <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Account</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">&gt;</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>
                target<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>下面这幅图很直观地展示了如何使用共享的锁 Account.class 来保护不同对象的临界区.</p> <p><img src="/img/7764244d5b6e4075a875b4e8bf4b6155-20230731162452-m030zup.png" alt=""></p> <h5 id="总结-4"><a href="#总结-4" class="header-anchor">#</a> 总结</h5> <p>相信你看完本节后, 对如何<strong>保护多个资源</strong>已经很有心得了, 关键是要分析多个资源之间的关系. <strong>如果资源之间没有关系, 很好处理, 每个资源一把锁就可以了. 如果资源之间有关联关系, 就要选择一个粒度更大的锁, 这个锁应该能够覆盖所有相关的资源</strong>. 除此之外, 还要梳理出有哪些访问路径, 所有的访问路径都要设置合适的锁, 这个过程可以类比一下门票管理.</p> <p>再引申一下上面提到的关联关系, 关联关系如果用更具体, 更专业的语言来描述的话, 其实是一种 &quot;原子性&quot; 特征, 前面提到的原子性, 主要是面向 CPU 指令的, 转账操作的原子性则是属于是面向高级语言的, 不过它们本质上是一样的.</p> <p><strong>&quot;原子性&quot; 的本质</strong>是什么? 其实不是不可分割, 不可分割只是外在表现, 其本质是多个资源间有一致性的要求, <strong>操作的中间状态对外不可见</strong>. 例如, 在 32 位的机器上写 long 型变量有中间状态(只写了 64 位中的 32 位), 在银行转账的操作中也有中间状态(账户 A 减少了 100, 账户 B 还没来得及发生变化). 所以<strong>解决原子性问题, 是要保证中间状态对外不可见</strong>.</p> <h4 id="_05-一不小心就死锁了怎么办"><a href="#_05-一不小心就死锁了怎么办" class="header-anchor">#</a> 05-一不小心就死锁了怎么办?</h4> <p>上一节用 Account.class 作为互斥锁, 来解决银行业务里面的转账问题, 虽然这个方案不存在并发问题, 但是所有账户的转账操作都是串行的, 例如账户 A 转账户 B, 账户 C 转账户 D 这两个转账操作现实世界里是可以并行的, 但是在这个方案里却被串行化了, 这样的话, 性能太差.</p> <p>那下面就尝试着把性能提升一下.</p> <h5 id="向现实世界要答案"><a href="#向现实世界要答案" class="header-anchor">#</a> 向现实世界要答案</h5> <p>现实世界里, 账户转账操作是支持并发的, 而且绝对是真正的并行, 银行所有的窗口都可以做转账操作. 只要能仿照现实世界做转账操作, 串行的问题就解决了.</p> <p>试想在古代, 没有信息化, 账户的存在形式真的就是一个账本, 而且每个账户都有一个账本, 这些账本都统一存放在文件架上. 银行柜员在做转账时, 要去文件架上把转出账本和转入账本都拿到手, 然后做转账. 这个柜员在拿账本的时候可能遇到以下三种情况:</p> <ol><li>文件架上恰好有转出账本和转入账本, 那就同时拿走;</li> <li>如果文件架上只有转出账本和转入账本之一, 那这个柜员就先把文件架上有的账本拿到手, 同时等着其他柜员把另外一个账本送回来;</li> <li>转出账本和转入账本都没有, 那这个柜员就等着两个账本都被送回来.</li></ol> <p>上面这个过程在编程的世界里怎么实现呢? 其实用<strong>两把锁</strong>就实现了, 转出账本一把, 转入账本另一把. 在 transfer() 方法内部, <strong>首先尝试锁定转出账户 this(先把转出账本拿到手), 然后尝试锁定转入账户 target(再把转入账本拿到手), 只有当两者都成功时, 才执行转账操作</strong>. 这个逻辑可以图形化为下图这个样子.</p> <p><img src="/img/475fb68fa271caf742f652fc35c07ed5-20230731162452-p48fiba.png" alt="" title="两个转账操作并行示意图"></p> <p>而至于详细的代码实现, 如下所示. 经过这样的优化后, 账户 A 转账户 B 和账户 C 转账户 D 这两个转账操作就可以并行了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> balance<span class="token punctuation">;</span>
    <span class="token comment">// 转账</span>
    <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 锁定转出账户</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 锁定转入账户</span>
            <span class="token keyword">synchronized</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">&gt;</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>
                    target<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h5 id="没有免费的午餐"><a href="#没有免费的午餐" class="header-anchor">#</a> 没有免费的午餐</h5> <p>上面的实现看上去很完美, 并且也算是将锁用得出神入化了. 相对于用 Account.class 作为互斥锁, 锁定的范围太大, 而锁定两个账户范围就小多了, 这样的锁, 上一节介绍过, 叫<strong>细粒度锁</strong>. <strong>使用细粒度锁可以提高并行度, 是性能优化的一个重要手段</strong>.</p> <p>这个时候可能你已经开始警觉了, 使用细粒度锁这么简单, 有这样的好事, 是不是也要付出点什么代价啊? 编写并发程序就需要这样时时刻刻保持谨慎.</p> <p>**的确, 使用细粒度锁是有代价的, 这个代价就是可能会导致死锁. **</p> <p>在详细介绍死锁之前, 先看看现实世界里的一种特殊场景. 如果有客户找柜员张三做个转账业务: 账户 A 转账户 B 100 元, 此时另一个客户找柜员李四也做个转账业务: 账户 B 转账户 A 100 元, 于是张三和李四同时都去文件架上拿账本, 这时候有可能凑巧张三拿到了账本 A, 李四拿到了账本 B. 张三拿到账本 A 后就等着账本 B(账本 B 已经被李四拿走), 而李四拿到账本 B 后就等着账本 A(账本 A 已经被张三拿走), 他们要等多久呢? 他们会永远等待下去...因为张三不会把账本 A 送回去, 李四也不会把账本 B 送回去. 姑且称为死等吧.</p> <p><img src="/img/30b4a32e6934315dc480e53a1ff44398-20230731162452-8t6r9x6.png" alt="" title="转账业务中的&quot;死等&quot;"></p> <p>现实世界里的死等, 就是编程领域的死锁了. <strong>死锁</strong>的一个比较专业的定义是: <strong>一组互相竞争资源的线程因互相等待, 导致 &quot;永久&quot; 阻塞的现象</strong>.</p> <p>上面转账的代码是怎么发生死锁的呢? 假设线程 T1 执行账户 A 转账户 B 的操作, 账户 A.transfer(账户 B); 同时线程 T2 执行账户 B 转账户 A 的操作, 账户 B.transfer(账户 A). 当 T1 和 T2 同时执行完 ① 处的代码时, T1 获得了账户 A 的锁(对于 T1, this 是账户 A), 而 T2 获得了账户 B 的锁(对于 T2, this 是账户 B). 之后 T1 和 T2 在执行 ② 处的代码时, T1 试图获取账户 B 的锁时, 发现账户 B 已经被锁定(被 T2 锁定), 所以 T1 开始等待; T2 则试图获取账户 A 的锁时, 发现账户 A 已经被锁定(被 T1 锁定), 所以 T2 也开始等待. 于是 T1 和 T2 会无期限地等待下去, 也就是所说的死锁了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> balance<span class="token punctuation">;</span>
    <span class="token comment">// 转账</span>
    <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 锁定转出账户</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment">// ①</span>
            <span class="token comment">// 锁定转入账户</span>
            <span class="token keyword">synchronized</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// ②</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">&gt;</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>
                    target<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>关于这种现象, 还可以借助资源分配图来可视化锁的占用情况(资源分配图是个有向图, 它可以描述资源和线程的状态). 其中, 资源用方形节点表示, 线程用圆形节点表示; 资源中的点指向线程的边表示线程已经获得该资源, 线程指向资源的边则表示线程请求资源, 但尚未得到. 转账发生死锁时的资源分配图就如下图所示, 一个&quot;各据山头死等&quot;的尴尬局面.</p> <p><img src="/img/aab899af7f3db5c9f2fbea66c1af5c17-20230731162452-ke733iy.png" alt="" title="转账发生死锁时的资源分配图"></p> <h5 id="如何预防死锁"><a href="#如何预防死锁" class="header-anchor">#</a> 如何预防死锁</h5> <p>并发程序一旦死锁, 一般没有特别好的方法, 很多时候只能重启应用. 因此, <strong>解决死锁问题最好的办法还是规避死锁</strong>.</p> <p>那如何避免死锁呢? 要避免死锁就需要分析死锁发生的条件, 只有以下这<strong>四个条件都发生</strong>时才会出现死锁:</p> <ol><li><strong>互斥</strong>, 共享资源 X 和 Y 只能被一个线程占用;</li> <li><strong>占有且等待</strong>, 线程 T1 已经取得共享资源 X, 在等待共享资源 Y 的时候, 不释放共享资源 X;</li> <li><strong>不可抢占</strong>, 其他线程不能强行抢占线程 T1 占有的资源;</li> <li><strong>循环等待</strong>, 线程 T1 等待线程 T2 占有的资源, 线程 T2 等待线程 T1 占有的资源, 就是循环等待.</li></ol> <p>反过来分析, <strong>也就是说只要破坏其中一个, 就可以成功避免死锁的发生</strong>.</p> <p>其中, 互斥这个条件没有办法破坏, 因为用锁为的就是互斥. 不过其他三个条件都是有办法破坏掉的, 到底如何做呢?</p> <ol><li>对于 &quot;占用且等待&quot; 这个条件, 可以<strong>一次性申请所有的资源</strong>, 这样就不存在等待了.</li> <li>对于 &quot;不可抢占&quot; 这个条件, 占用部分资源的线程进一步申请其他资源时, <strong>如果申请不到, 可以主动释放它占有的资源</strong>, 这样不可抢占这个条件就破坏掉了.</li> <li>对于 &quot;循环等待&quot; 这个条件, 可以<strong>靠按序申请资源来预防</strong>. 所谓按序申请, 是指资源是有线性顺序的, 申请的时候可以先申请资源序号小的, 再申请资源序号大的, 这样线性化后自然就不存在循环了.</li></ol> <p>已经从理论上解决了如何预防死锁, 那具体如何体现在代码上呢? 下面就来尝试用代码实践一下这些理论.</p> <h6 id="_1-破坏占用且等待条件"><a href="#_1-破坏占用且等待条件" class="header-anchor">#</a> (1)破坏占用且等待条件</h6> <p>从理论上讲, 要破坏这个条件, 可以一次性申请所有资源. 在现实世界里, 就拿前面提到的转账操作来讲, 它需要的<strong>资源有两个, 一个是转出账户, 另一个是转入账户</strong>, 当这两个账户同时被申请时, 该怎么解决这个问题呢?</p> <p>可以增加一个账本管理员, 然后只允许账本管理员从文件架上拿账本, 也就是说柜员不能直接在文件架上拿账本, 必须通过账本管理员才能拿到想要的账本. 例如, 张三同时申请账本 A 和 B, 账本管理员如果发现文件架上只有账本 A, 这个时候账本管理员是不会把账本 A 拿下来给张三的, 只有账本 A 和 B 都在的时候才会给张三. 这样就保证了 &quot;一次性申请所有资源&quot;.</p> <p><img src="/img/b373b4cbefc412942fde6e4861a1a071-20230731162452-8srj682.png" alt="" title="通过账本管理员拿账本"></p> <p>对应到编程领域, &quot;同时申请&quot; 这个操作是一个临界区, 也需要一个角色(Java 里面的类)来管理这个临界区, 就把这个角色定为 <strong>Allocator</strong>. 它有两个重要功能, 分别是: <strong>同时申请资源 apply() 和同时释放资源 free()</strong> . 账户 Account 类里面持有一个 Allocator 的单例(必须是单例, 只能由一个人来分配资源). 当账户 Account 在执行转账操作的时候, 首先向 Allocator 同时申请转出账户和转入账户这两个资源, 成功后再锁定这两个资源; 当转账操作执行完, 释放锁之后, 需通知 Allocator 同时释放转出账户和转入账户这两个资源. 具体的代码实现如下.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Allocator</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> als <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 一次性申请所有资源</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">Object</span> from<span class="token punctuation">,</span> <span class="token class-name">Object</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>als<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span> <span class="token operator">||</span> als<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            als<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>
            als<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 归还资源</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span><span class="token class-name">Object</span> from<span class="token punctuation">,</span> <span class="token class-name">Object</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        als<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>
        als<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>
    <span class="token comment">// actr 应该为单例</span>
    <span class="token keyword">private</span> <span class="token class-name">Allocator</span> actr<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> balance<span class="token punctuation">;</span>
    <span class="token comment">// 转账</span>
    <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 一次性申请转出账户和转入账户, 直到成功</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>actr<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 锁定转出账户</span>
            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment">// 锁定转入账户</span>
                <span class="token keyword">synchronized</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">&gt;</span> amt<span class="token punctuation">)</span><span class="token punctuation">{</span>
                        <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>
                        target<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            actr<span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><h6 id="_2-破坏不可抢占条件"><a href="#_2-破坏不可抢占条件" class="header-anchor">#</a> (2)破坏不可抢占条件</h6> <p>破坏不可抢占条件看上去很简单, <strong>核心是要能够主动释放它占有的资源, 这一点 synchronized 是做不到的</strong>. 原因是 synchronized 申请资源的时候, 如果申请不到, 线程直接进入阻塞状态了, 而线程进入阻塞状态, 啥都干不了, 也释放不了线程已经占有的资源.</p> <p>你可能会质疑, &quot;Java 作为排行榜第一的语言, 这都解决不了?&quot; 你的怀疑很有道理, Java 在语言层次确实没有解决这个问题, 不过在 SDK 层面还是解决了的, java.util.concurrent 这个包下面提供的 <strong>Lock</strong> 是可以轻松解决这个问题的. 关于这个话题, 后面会详细讲.</p> <h6 id="_3-破坏循环等待条件"><a href="#_3-破坏循环等待条件" class="header-anchor">#</a> (3)破坏循环等待条件</h6> <p>破坏这个条件, 需要<strong>对资源进行排序, 然后按序申请资源</strong>. 这个实现非常简单, 假设每个账户都有不同的属性 id, 这个 id 可以作为排序字段, 申请的时候, 可以按照从小到大的顺序来申请. 比如下面代码中, ①~⑥ 处的代码对转出账户(this)和转入账户(target)排序, 然后按照序号从小到大的顺序锁定账户. 这样就不存在 &quot;循环&quot; 等待了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> balance<span class="token punctuation">;</span>
    <span class="token comment">// 转账</span>
    <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">Account</span> left <span class="token operator">=</span> <span class="token keyword">this</span>            <span class="token comment">// ①</span>
        <span class="token class-name">Account</span> right <span class="token operator">=</span> target<span class="token punctuation">;</span>        <span class="token comment">// ②</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">&gt;</span> target<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// ③</span>
            left <span class="token operator">=</span> target<span class="token punctuation">;</span>             <span class="token comment">// ④</span>
            right <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>              <span class="token comment">// ⑤</span>
        <span class="token punctuation">}</span>                              <span class="token comment">// ⑥</span>
        <span class="token comment">// 锁定序号小的账户</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">// 锁定序号大的账户</span>
            <span class="token keyword">synchronized</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">&gt;</span> amt<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>
                    target<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h5 id="总结-5"><a href="#总结-5" class="header-anchor">#</a> 总结</h5> <p>当在编程世界里遇到问题时, 应不局限于当下, 可以换个思路, 向现实世界要答案, <strong>利用现实世界的模型来构思解决方案</strong>, 这样往往能够让方案更容易理解, 也更能够看清楚问题的本质. 但是现实世界的模型有些细节往往会被忽视. 因为在现实世界里, 人太智能了, 以致有些细节实在是显得太不重要了. 在转账的模型中, 为什么会忽视死锁问题呢? 原因主要是在现实世界, 大家会交流, 并且会很智能地交流. 而编程世界里, 两个线程是不会智能地交流的. 所以在利用现实模型建模的时候, 还要仔细对比现实世界和编程世界里的各角色之间的差异.</p> <p>本节主要讲了<strong>用细粒度锁来锁定多个资源时, 要注意死锁的问题</strong>. 这个就需要能把它强化为一个思维定势, 遇到这种场景, 马上想到可能存在死锁问题. 当知道风险之后, 才有机会谈如何预防和避免, 因此, <strong>识别出风险很重要</strong>.</p> <p>预防死锁主要是破坏三个条件中的一个, 有了这个思路后, 实现就简单了. 但仍需注意的是, 有时候预防死锁成本也是很高的. 例如上面转账那个例子, 破坏占用且等待条件的成本就比破坏循环等待条件的成本高, 破坏占用且等待条件, 也是锁了所有的账户, 而且还是用了死循环 <code>while(!actr.apply(this, target));</code>​ 方法, 不过好在 apply() 这个方法基本不耗时. 在转账这个例子中, 破坏循环等待条件就是成本最低的一个方案.</p> <p>所以在选择具体方案的时候, 还需要<strong>评估一下操作成本, 从中选择一个成本最低的方案</strong>.</p> <h4 id="_06-用-等待-通知-机制优化循环等待"><a href="#_06-用-等待-通知-机制优化循环等待" class="header-anchor">#</a> 06-用&quot;等待-通知&quot;机制优化循环等待</h4> <p>由上一节你应该已经知道, 在<strong>破坏占用且等待条件</strong>的时候, 如果转出账本和转入账本不满足同时在文件架上这个条件, 就用死循环的方式来循环等待, 核心代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 一次性申请转出账户和转入账户, 直到成功 </span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>actr<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果 apply() 操作耗时非常短, 而且并发冲突量也不大时, 这个方案还挺不错的, 因为这种场景下, <strong>循环</strong>上几次或者几十次就能一次性获取转出账户和转入账户了. 但是如果 apply() 操作耗时长, 或者并发冲突量大的时候, 循环等待这种方案就不适用了, 因为在这种场景下, 可能要循环上万次才能获取到锁, <strong>太消耗 CPU 了</strong>.</p> <p>其实在这种场景下, 最好的方案应该是: 如果线程要求的条件(转出账本和转入账本同在文件架上)不满足, 则<strong>线程阻塞自己</strong>, 进入<strong>等待</strong>状态; 当线程要求的条件(转出账本和转入账本同在文件架上)满足后, <strong>通知</strong>等待的线程重新执行. 其中, <strong>使用线程阻塞的方式就能避免循环等待消耗 CPU 的问题, 而不是使用死循环一直浪费 CPU</strong>.</p> <p>那 Java 语言是否支持这种<strong>等待-通知机制</strong>呢? 答案是: 一定支持(毕竟占据排行榜第一那么久). 下面就来看看 Java 语言是如何支持<strong>等待-通知机制</strong>的.</p> <h5 id="完美的就医流程"><a href="#完美的就医流程" class="header-anchor">#</a> 完美的就医流程</h5> <p>在介绍 Java 语言如何支持 等待-通知机制 之前, 先看一个现实世界里面的就医流程, 因为它有着完善的等待-通知机制, 所以对比就医流程, 我们就能更好地理解和应用并发编程中的等待-通知机制.</p> <p>就医流程基本上是这样:</p> <ol><li>患者先去挂号, 然后到就诊门口分诊, 等待叫号;</li> <li>当叫到自己的号时, 患者就可以找大夫就诊了;</li> <li>就诊过程中, 大夫可能会让患者去做检查, 同时叫下一位患者;</li> <li>当患者做完检查后, 拿检测报告重新分诊, 等待叫号;</li> <li>当大夫再次叫到自己的号时, 患者再去找大夫就诊.</li></ol> <p>或许你已经发现了, 这个有着完美等待-通知机制的就医流程, 不仅能够保证同一时刻大夫只为一个患者服务, 而且还能够保证大夫和患者的效率. 与此同时你可能也会有疑问, &quot;这个就医流程很复杂呀, 前面描述的等待-通知机制相较而言是不是太简单了?&quot; 那这个复杂度是否是必须的呢? 这个是必须的, 我们不能忽视等待-通知机制中的一些细节.</p> <p>下面来对比看一下前面都忽视了哪些细节.</p> <ol><li>患者到就诊门口分诊, 类似于线程要<strong>去获取互斥锁</strong>; 当患者被叫到时, 类似线程已经<strong>获取到锁</strong>了.</li> <li>大夫让患者去做检查(缺乏检测报告不能诊断病因), 类似于线程要求的<strong>条件没有满足</strong>.</li> <li>患者去做检查, 类似于线程进入<strong>等待状态</strong>; 然后<strong>大夫叫下一个患者, 这个步骤在前面的等待-通知机制中忽视了, 这个步骤对应到程序里, 本质是线程释放持有的互斥锁</strong>.</li> <li>患者做完检查, 类似于线程要求的<strong>条件已经满足</strong>; <strong>患者拿检测报告重新分诊, 类似于线程需要重新获取互斥锁, 这个步骤在前面的等待-通知机制中也忽视了</strong>.</li></ol> <p>所以加上这些至关重要的细节, 综合一下, 就可以得出<mark><strong>一个完整的等待-通知机制: 线程首先获取互斥锁, 当线程要求的条件不满足时, 释放互斥锁, 进入等待状态; 当要求的条件满足时, 通知等待的线程, 重新获取互斥锁</strong></mark>.</p> <h5 id="用synchronized实现等待-通知机制"><a href="#用synchronized实现等待-通知机制" class="header-anchor">#</a> 用synchronized实现等待-通知机制</h5> <p>在 Java 里, 等待-通知机制可以有多种实现方式, 比如 Java 语言内置的 <strong>synchronized 配合 wait(), notify(), notifyAll()</strong>  这三个方法就能轻松实现.</p> <p>如何用 synchronized 实现互斥锁, 你应该已经很熟悉了. 在下面这个图里, 左边有一个等待队列, 同一时刻, 只允许一个线程进入 synchronized 保护的临界区(这个临界区可以看作大夫的诊室), 当有一个线程进入临界区后, 其他线程就只能进入图中左边的等待队列里等待(相当于患者分诊等待). **这个等待队列和互斥锁是一对一的关系, 每个互斥锁都有自己独立的等待队列. **</p> <p><img src="/img/9196583fbadda6b514449ea9220a3b81-20230731162452-4p49khp.png" alt="" title="wait() 操作工作原理图"></p> <p>在并发程序中, 当一个线程进入临界区后, 由于某些条件不满足, 需要进入<strong>等待状态</strong>, Java 对象的 wait() 方法就能够满足这种需求. 如上图所示, 当调用 wait() 方法后, <strong>当前线程就会被阻塞</strong>, 并且进入到右边的等待队列中, <strong>这个等待队列也是互斥锁的等待队列</strong>. 线程在进入等待队列的同时, <strong>会释放持有的互斥锁</strong>, 线程释放锁后, 其他线程就有机会获得锁, 并进入临界区了.</p> <p>那线程要求的条件满足时, 该怎么通知这个等待的线程呢? 很简单, 就是 Java 对象的 notify() 和 notifyAll() 方法. 下面这个图里大致描述了这个过程, 当条件满足时调用 notify(), 会通知等待队列(<strong>互斥锁的等待队列</strong>)中的线程, 告诉它<strong>条件曾经满足过</strong>.</p> <p><img src="/img/16e8842d3499830a59c03f38f75f0885-20230731162452-nl0nzcb.png" alt="" title="notify() 操作工作原理图"></p> <p>为什么说是曾经满足过呢? 因为<strong>notify() 只能保证在通知时间点, 条件是满足的</strong>. 而被通知线程的<strong>执行时间点和通知的时间点</strong>基本上不会重合, 所以当线程执行的时候, 很可能条件已经不满足了(保不齐有其他线程插队). 这一点需要格外注意.</p> <p>除此之外, 还有一个需要注意的点, 被通知的线程要想重新执行, <strong>仍然需要获取到互斥锁</strong>(因为曾经获取的锁在调用 wait() 时已经<strong>释放</strong>了).</p> <p>上面一直强调 wait(), notify(), notifyAll() 方法操作的等待队列是互斥锁的等待队列, 所以<strong>如果 synchronized 锁定的是 this, 那么对应的一定是 this.wait(), this.notify(), this.notifyAll(); 如果 synchronized 锁定的是 target, 那么对应的一定是 target.wait(), target.notify(), target.notifyAll()</strong> . 而且 wait(), notify(), notifyAll() 这三个方法能够被调用的<strong>前提是已经获取了相应的互斥锁</strong>, 所以会发现 wait(), notify(), notifyAll() 都是在 synchronized{} 内部被调用的. 如果在 synchronized{} 外部调用, 或者锁定的 this, 而用 target.wait() 调用的话, JVM 会抛出一个运行时异常: <code>java.lang.IllegalMonitorStateException</code>​.</p> <h5 id="小试牛刀-一个更好地资源分配器"><a href="#小试牛刀-一个更好地资源分配器" class="header-anchor">#</a> 小试牛刀:一个更好地资源分配器</h5> <p>等待-通知机制的基本原理搞清楚后, 就来看看它如何解决一次性申请转出账户和转入账户的问题吧. 在这个等待-通知机制中, 需要考虑以下四个要素.</p> <ol><li>互斥锁: 前面提到 Allocator 需要是单例的, 所以可以<strong>用 this 作为互斥锁</strong>.</li> <li>线程要求的条件: 转出账户和转入账户<strong>都没有被分配过</strong>.</li> <li>何时等待: 线程要求的<strong>条件不满足就等待</strong>.</li> <li>何时通知: 当有线程释放账户时就通知.</li></ol> <p>将上面几个问题考虑清楚, 可以快速完成下面的代码. 需要注意的是使用了:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">while</span><span class="token punctuation">(</span>条件不满足<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>利用这种范式可以解决上面提到的<strong>条件曾经满足过</strong>这个问题. 因为当 wait() 返回时, 有可能条件已经发生变化了, 曾经条件满足, 但是现在已经不满足了, 所以<strong>要重新检验条件是否满足</strong>. 范式, 意味着是经典做法, 所以没有特殊理由不要尝试换个写法. 后面在介绍&quot;管程&quot;的时候, 会详细介绍这个经典做法的前世今生.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Allocator</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> als<span class="token punctuation">;</span>
    <span class="token comment">// 一次性申请所有资源</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">Object</span> from<span class="token punctuation">,</span> <span class="token class-name">Object</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 经典写法</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>als<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span> <span class="token operator">||</span> als<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 进行等待</span>
                <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 唤醒后会继续进入到while中再次判断条件是否满足 不满足则继续等待</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 满足条件: 获得资源</span>
        als<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>
        als<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 归还资源</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span><span class="token class-name">Object</span> from<span class="token punctuation">,</span> <span class="token class-name">Object</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        als<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>
        als<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h5 id="尽量使用notifyall"><a href="#尽量使用notifyall" class="header-anchor">#</a> 尽量使用notifyAll()</h5> <p>在上面的代码中, 用的是 notifyAll() 来实现通知机制, 为什么不使用 notify() 呢? 这二者是有区别的, <strong>notify() 是会随机地通知等待队列中的一个线程, 而 notifyAll() 会通知等待队列中的所有线程</strong>. 从感觉上来讲, 应该是 notify() 更好一些, 因为即便通知所有线程, 也只有一个线程能够进入临界区. 但那所谓的感觉往往都蕴藏着风险, 实际上使用 notify() 也很有风险, <strong>它的风险在于可能导致某些线程永远不会被通知到</strong>.</p> <p>假设有资源 A, B, C, D, 线程 1 申请到了 AB, 线程 2 申请到了 CD, 此时线程 3 申请 AB, 会进入等待队列(AB 分配给线程 1, 线程 3 要求的条件不满足), 线程 4 申请 CD 也会进入等待队列. 再假设之后线程 1 归还了资源 AB, 如果使用 notify() 来通知等待队列中的线程, 有可能被通知的是线程 4, 但线程 4 申请的是 CD, 所以此时线程 4 还是会继续等待, 而真正该唤醒的线程 3 就再也没有机会被唤醒了.</p> <p><strong>所以除非经过深思熟虑, 否则尽量使用 notifyAll()</strong> .</p> <h5 id="总结-6"><a href="#总结-6" class="header-anchor">#</a> 总结</h5> <p>等待-通知机制是一种非常普遍的线程间协作的方式. 工作中经常看到有同学使用轮询的方式来等待某个状态, 其实很多情况下都可以用今天介绍的等待-通知机制来优化. Java 语言内置的 <strong>synchronized 配合 wait(), notify(), notifyAll() 这三个方法可以快速实现这种机制</strong>, 但是它们的使用看上去还是有点复杂, 所以需要认真理解等待队列和 wait(), notify(), notifyAll() 的关系. 最好用现实世界做个类比, 这样有助于你的理解.</p> <h4 id="_07-安全性-活跃性以及性能问题"><a href="#_07-安全性-活跃性以及性能问题" class="header-anchor">#</a> 07-安全性,活跃性以及性能问题</h4> <p>通过前面六节开启了一个简单的并发旅程, 相信现在你对并发编程需要注意的问题已经有了更深入的理解, 这是一个很大的进步, 正所谓只有发现问题, 才能解决问题. 但是前面六篇文章的知识点可能还是有点分散, 所以是时候将其总结一下了.</p> <p>并发编程中需要注意的问题有很多, 很庆幸前人已经总结过了, 主要有三个方面, 分别是: <strong>安全性问题, 活跃性问题和性能问题</strong>. 下面就来一一介绍这些问题.</p> <h5 id="安全性问题"><a href="#安全性问题" class="header-anchor">#</a> 安全性问题</h5> <p>相信你一定听说过类似这样的描述: 这个方法不是线程安全的, 这个类不是线程安全的, 等等.</p> <p>那什么是线程安全呢? 其实本质上就是<strong>正确性</strong>, 而正确性的含义就是<strong>程序按照自己期望的执行</strong>. 那如何才能写出线程安全的程序呢? 前面已经介绍了并发 Bug 的三个主要源头: <strong>原子性问题, 可见性问题和有序性问题</strong>. 也就是说, 理论上线程安全的程序, 就要避免出现原子性问题, 可见性问题和有序性问题.</p> <p>那是不是所有的代码都需要认真分析一遍是否存在这三个问题呢? 当然不是, 其实只有一种情况需要: <mark><strong>存在共享数据并且该数据会发生变化, 通俗地讲就是有多个线程会同时读写同一数据</strong></mark>. 那如果能够做到<strong>不共享数据或者数据状态不发生变化, 不就能够保证线程的安全性</strong>了嘛. 有不少技术方案都是基于这个理论的, 例如<strong>线程本地存储(Thread Local Storage, TLS), 不变模式</strong>等等, 后面会详细介绍相关的技术方案是如何在 Java 语言中实现的.</p> <p>但现实生活中, <strong>必须共享会发生变化的数据</strong>, 这样的应用场景还是很多的.</p> <p>当多个线程同时访问同一数据, 并且至少有一个线程会写这个数据的时候, 如果不采取防护措施, 那么就会导致并发 Bug, 对此还有一个专业的术语, 叫做<strong>数据竞争</strong>(Data Race). 比如, 前面的 add10K() 的方法, 当多个线程调用时候就会发生<strong>数据竞争</strong>, 如下所示.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>idx<span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            count <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>那是不是在访问数据的地方, 加个锁保护一下就能解决所有的并发问题了呢? 显然没有这么简单. 例如, 对于上面示例, 稍作修改, 增加两个被 synchronized 修饰的 get() 和 set() 方法,  add10K() 方法里面通过 get() 和 set() 方法来访问 value 变量, 修改后的代码如下所示. 对于修改后的代码, 所有访问共享变量 value 的地方, 都增加了互斥锁, 此时是不存在数据竞争的. 但很显然修改后的 add10K() 方法<strong>并不是线程安全的</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">long</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>
        count <span class="token operator">=</span> v<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>idx<span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">set</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>假设 count=0, 当两个线程同时执行 get() 方法时, get() 方法会返回相同的值 0, 两个线程执行 get()+1 操作, 结果都是 1, 之后两个线程再将结果 1 写入了内存. 你本来期望的是 2, 而结果却是 1.</p> <p>这种问题, 有个官方的称呼, 叫<strong>竞态条件</strong>(Race Condition). 所谓<strong>竞态条件, 指的是程序的执行结果依赖线程执行的顺序</strong>. 例如上面的例子, 如果<strong>两个线程完全同时执行</strong>, 那么结果是 1; 如果两个线程是前后执行, 那么结果就是 2. 在并发环境里, 线程的执行顺序是不确定的, 如果程序存在竞态条件问题, 那就意味着程序执行的结果是不确定的, 而执行结果不确定这可是个大 Bug.</p> <p>下面再结合一个例子来说明下<strong>竞态条件</strong>, 就是前面文章中提到的转账操作. 转账操作里面有个判断条件--转出金额不能大于账户余额, 但在并发环境里面, 如果不加控制, 当多个线程同时对一个账号执行转出操作时, 就有可能出现超额转出问题. 假设账户 A 有余额 200, 线程 1 和线程 2 都要从账户 A 转出 150, 在下面的代码里, 有可能线程 1 和线程 2 同时执行到第 6 行, 这样线程 1 和线程 2 都会发现转出金额 150 小于账户余额 200, 于是就会发生超额转出的情况.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> balance<span class="token punctuation">;</span>
    <span class="token comment">// 转账</span>
    <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">&gt;</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>
            target<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>所以也可以按照下面这样来理解<strong>竞态条件</strong>. 在并发场景中, 程序的执行依赖于某个状态变量, 也就是类似于下面这样:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>状态变量 满足 执行条件<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    执行操作
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>当某个线程发现状态变量满足执行条件后, 开始执行操作; 可是就在这个线程执行操作的时候, 其他线程同时修改了状态变量, 导致状态变量不满足执行条件了</strong>. 当然很多场景下, 这个条件不是显式的, 例如前面 addOne 的例子中, set(get() + 1) 这个复合操作, 其实就隐式依赖 get() 的结果.</p> <p>那面对数据竞争和竞态条件问题, 又该如何保证线程的安全性呢? 其实这两类问题, 都可以用<strong>互斥</strong>这个技术方案, 而实现<strong>互斥</strong>的方案有很多, CPU 提供了相关的互斥指令, 操作系统, 编程语言也会提供相关的 API. 从逻辑上来看, 可以统一归为: <strong>锁</strong>. 前面几章也粗略地介绍了如何使用锁, 相信你已经胸中有丘壑了.</p> <h5 id="活跃性问题"><a href="#活跃性问题" class="header-anchor">#</a> 活跃性问题</h5> <p>所谓活跃性问题, 指的是某个操作无法执行下去. 常见的 &quot;死锁&quot; 就是一种典型的活跃性问题, 当然<strong>除了死锁外, 还有两种情况, 分别是 &quot;活锁&quot; 和 &quot;饥饿&quot;</strong> .</p> <p>发生 &quot;死锁&quot; 后线程会互相等待, 而且会一直等待下去, 在技术上的表现形式是线程永久地 &quot;阻塞&quot; 了. 但<strong>有时线程虽然没有发生阻塞, 但仍然会存在执行不下去的情况, 这就是所谓的 &quot;活锁&quot;</strong> . 可以类比现实世界里的例子, 路人甲从左手边出门, 路人乙从右手边进门, 两人为了不相撞, 互相谦让, 路人甲让路走右手边, 路人乙也让路走左手边, 结果是两人又相撞了. 这种情况, 基本上谦让几次就解决了, 因为人会交流啊. 可是如果这种情况发生在编程世界了, 就有可能会一直没完没了地 &quot;谦让&quot; 下去, 成为没有发生阻塞但依然执行不下去的 &quot;活锁&quot;.</p> <p>解决 &quot;<strong>活锁</strong>&quot; 的方案很简单, 谦让时, <strong>尝试等待一个随机的时间</strong>就可以了. 例如上面的那个例子, 路人甲走左手边发现前面有人, 并不是立刻换到右手边, 而是等待一个随机的时间后, 再换到右手边; 同样, 路人乙也不是立刻切换路线, 也是等待一个随机的时间再切换. 由于路人甲和路人乙等待的时间是随机的, 所以同时相撞后再次相撞的概率就很低了. &quot;等待一个随机时间&quot; 的方案虽然很简单, 却非常有效, Raft 这样知名的分布式一致性算法中也用到了它.</p> <p>那 &quot;<strong>饥饿</strong>&quot; 该怎么去理解呢? <strong>所谓 &quot;饥饿&quot; 指的是线程因无法访问所需资源而无法执行下去的情况</strong>. &quot;不患寡, 而患不均&quot;, 如果线程优先级 &quot;不均&quot;, 在 CPU 繁忙的情况下, 优先级低的线程得到执行的机会很小, 就可能发生线程 &quot;饥饿&quot;; 持有锁的线程, 如果执行的时间过长, 也可能导致 &quot;饿死&quot; 问题.</p> <p>解决 &quot;<strong>饥饿</strong>&quot; 问题的方案很简单, 有三种方案: <strong>一是保证资源充足, 二是公平地分配资源, 三就是避免持有锁的线程长时间执行</strong>. 这三个方案中, 方案一和方案三的适用场景比较有限, 因为很多场景下, 资源的稀缺性是没办法解决的, 持有锁的线程执行的时间也很难缩短. 倒是方案二的适用场景相对来说更多一些.</p> <p>那如何公平地分配资源呢? 在并发编程里, 主要是<strong>使用公平锁</strong>. 所谓公平锁, 是一种<strong>先来后到</strong>的方案, 线程的等待是有顺序的, 排在等待队列前面的线程会优先获得资源.</p> <h5 id="性能问题"><a href="#性能问题" class="header-anchor">#</a> 性能问题</h5> <p>使用 &quot;锁&quot; 要非常小心, 但是如果小心过度, 也可能出 &quot;性能问题&quot;.  <strong>&quot;锁&quot; 的过度使用可能导致串行化的范围过大, 这样就不能够发挥多线程的优势了, 而之所以使用多线程搞并发程序, 为的就是提升性能</strong>.</p> <p>所以要尽量减少串行, 那串行对性能的影响是怎么样的呢? 假设串行百分比是 5%, 用多核多线程相比单核单线程能提速多少呢?</p> <p>有个阿姆达尔(Amdahl)定律, 代表了处理器并行运算之后效率提升的能力, 它正好可以解决这个问题, 具体公式如下:</p> <p><img src="/img/image-20240122234830-lqb7i9a.png" alt="image"></p> <p>公式里的 n 可以理解为 CPU 的核数, p 可以理解为并行百分比, 那 (1-p) 就是串行百分比了, 也就是假设的 5%. 再假设 CPU 的核数(也就是 n)无穷大, 那加速比 S 的极限就是 20. 也就是说, <strong>如果串行率是 5%, 那么无论采用什么技术, 最高也就只能提高 20 倍的性能</strong>.</p> <p>所以使用锁的时候一定要关注对性能的影响. 那怎么才能避免锁带来的性能问题呢? 这个问题很复杂, <strong>Java SDK 并发包里之所以有那么多东西, 有很大一部分原因就是要提升在某个特定领域的性能</strong>.</p> <p>不过从方案层面, 可以这样来解决这个问题.</p> <p>第一, 既然使用锁会带来性能问题, 那最好的方案自然就是<strong>使用无锁的算法和数据结构</strong>了. 在这方面有很多相关的技术, 例如线程本地存储 (Thread Local Storage, TLS), 写入时复制 (Copy-on-write), 乐观锁等; Java 并发包里面的原子类也是一种无锁的数据结构; Disruptor 则是一个无锁的内存队列, 性能都非常好.</p> <p>第二, <strong>减少锁持有的时间</strong>. 互斥锁本质上是将并行的程序串行化, 所以要增加并行度, 一定要减少持有锁的时间. 这个方案具体的实现技术也有很多, 例如使用细粒度的锁, 一个典型的例子就是 Java 并发包里的 ConcurrentHashMap, 它使用了所谓<strong>分段锁</strong>的技术; 还可以使用读写锁, 也就是读是无锁的, 只有写的时候才会互斥.</p> <p>性能方面的度量指标有很多, 我觉得有三个指标非常重要, 就是: <mark><strong>吞吐量, 延迟和并发量</strong></mark>.</p> <ol><li><strong>吞吐量</strong>: 指的是单位时间内能处理的请求数量. 吞吐量越高, 说明性能越好.</li> <li><strong>延迟</strong>: 指的是从发出请求到收到响应的时间. 延迟越小, 说明性能越好.</li> <li><strong>并发量</strong>: 指的是能同时处理的请求数量, 一般来说随着并发量的增加, 延迟也会增加. 所以延迟这个指标, 一般都会是基于并发量来说的. 例如并发量是 1000 的时候, 延迟是 50 毫秒.</li></ol> <h5 id="总结-7"><a href="#总结-7" class="header-anchor">#</a> 总结</h5> <p>并发编程是一个复杂的技术领域, 微观上涉及到原子性问题, 可见性问题和有序性问题, 宏观则表现为安全性, 活跃性以及性能问题.</p> <p>在设计并发程序的时候, 主要是从宏观出发, 也就是要重点关注它的<strong>安全性, 活跃性以及性能</strong>. 安全性方面要注意数据竞争和竞态条件, 活跃性方面需要注意死锁, 活锁, 饥饿等问题, 性能方面虽然介绍了两个方案, 但是遇到具体问题, 还是要具体分析, 根据特定的场景选择合适的数据结构和算法.</p> <h4 id="_08-管程-并发编程的万能钥匙"><a href="#_08-管程-并发编程的万能钥匙" class="header-anchor">#</a> 08-管程:并发编程的万能钥匙</h4> <p>并发编程这个技术领域已经发展了半个世纪了, 相关的理论和技术纷繁复杂. 那有没有一种核心技术可以很方便地解决并发问题呢? 这个问题如果让我选择, 我一定会选择<strong>管程</strong>技术. Java 语言在 1.5 之前, 提供的唯一的并发原语就是管程, 而且 1.5 之后提供的 SDK 并发包, 也是<strong>以管程技术为基础</strong>的. 除此之外, C/C++, C# 等高级语言也都支持管程.</p> <p>可以这么说, <strong>管程就是一把解决并发问题的万能钥匙</strong>.</p> <h5 id="什么是管程"><a href="#什么是管程" class="header-anchor">#</a> 什么是管程</h5> <p>不知道你是否曾思考过这个问题: 为什么 Java 在 1.5 之前仅仅提供了 synchronized 关键字及 wait(), notify(), notifyAll() 这三个看似从天而降的方法? 在刚接触 Java 的时候, 我以为它会提供信号量这种编程原语, 因为操作系统原理课程告诉我, 用信号量能解决所有并发问题, 结果我发现不是. 后来我找到了原因: <strong>Java 采用的是管程技术, synchronized 关键字及 wait(), notify(), notifyAll() 这三个方法都是管程的组成部分. 而管程和信号量是等价的, 所谓等价指的是用管程能够实现信号量, 也能用信号量实现管程. 但是管程更容易使用, 所以 Java 选择了管程</strong>.</p> <p>管程, 对应的英文是 Monitor, 很多 Java 领域的同学都喜欢将其翻译成&quot;监视器&quot;, 这是直译. 操作系统领域一般都翻译成 &quot;管程&quot;, 这个是意译, 而我也更倾向于使用 &quot;管程&quot;.</p> <p>所谓<mark><strong>管程, 指的是管理共享变量以及对共享变量的操作过程, 让它们支持并发</strong></mark>. 翻译为 Java 领域的语言, 就是管理类的成员变量和成员方法, 让这个类是线程安全的. 那管程是怎么管的呢?</p> <h5 id="mesa模型"><a href="#mesa模型" class="header-anchor">#</a> MESA模型</h5> <p>在管程的发展史上, 先后出现过三种不同的管程模型, 分别是: Hasen 模型, Hoare 模型和 MESA 模型. 其中, 现在广泛应用的是 MESA 模型, 并且 Java 管程的实现参考的也是 MESA 模型. 所以重点介绍一下 MESA 模型.</p> <p>在并发编程领域, 有两大核心问题: 一个是<strong>互斥</strong>, 即同一时刻只允许一个线程访问共享资源; 另一个是<strong>同步</strong>, 即线程之间如何通信, 协作. <strong>这两大问题, 管程都是能够解决的</strong>.</p> <p>先来看看管程是如何解决<strong>互斥</strong>问题的.</p> <p><strong>管程解决互斥问题的思路很简单, 就是将共享变量及其对共享变量的操作统一封装起来</strong>. 在下图中, 管程 X 将共享变量 queue 这个队列和相关的操作入队 enq(), 出队 deq() 都封装起来了; 线程 A 和线程 B 如果想访问共享变量 queue, 只能通过调用管程提供的 enq(), deq() 方法来实现; enq(), deq() 保证互斥性, <strong>只允许一个线程进入管程</strong>. 不知你有没有发现, 管程模型和面向对象高度契合的. 估计这也是 Java 选择管程的原因吧. 在前面介绍的互斥锁用法, 其背后的模型其实就是它.</p> <p><img src="/img/d764ad186dc9985a0693087aa0ddbcf7-20230731162452-nrzl9qe.png" alt="" title="管程模型的代码化语义"></p> <p>那管程如何解决线程间的<strong>同步</strong>问题呢?</p> <p>这个就比较复杂了, 不过可以借鉴一下曾经提到过的就医流程, 它可以帮助你快速地理解这个问题. 为进一步便于理解, 下面展示了一幅 MESA 管程模型示意图, 它<strong>详细描述了 MESA 模型的主要组成部分</strong>.</p> <p>在<strong>管程模型里, 共享变量和对共享变量的操作是被封装起来的, 图中最外层的框就代表封装</strong>的意思. 框的上面只有一个入口, 并且在入口旁边还有一个入口等待队列. <strong>当多个线程同时试图进入管程内部时, 只允许一个线程进入, 其他线程则在入口等待队列中等待</strong>. 这个过程类似就医流程的分诊, 只允许一个患者就诊, 其他患者都在门口等待.</p> <p>管程里还引入了条件变量的概念, 而且<strong>每个条件变量都对应有一个等待队列</strong>, 如下图, 条件变量 A 和条件变量 B 分别都有自己的等待队列.</p> <p><img src="/img/59734caf26e3bc9ab207d0976b709c6f-20230731162452-xap4nv0.png" alt="" title="MESA 管程模型"></p> <p>那条件变量和等待队列的作用是什么呢? 其实就是<strong>解决线程同步问题</strong>. 也可以结合上面提到的入队出队例子加深一下理解.</p> <p>假设有个线程 T1 执行出队操作, 不过需要注意的是执行<strong>出队</strong>操作, 有个前提条件, 就是队列不能是空的, 而队列不空这个前提条件就是管程里的条件变量. 如果线程 T1 进入管程后恰好发现队列是空的, 那怎么办呢? 等待啊, 去哪里等呢? 就<strong>去条件变量对应的等待队列里面</strong>等. 此时线程 T1 就去 &quot;队列不空&quot; 这个条件变量的等待队列中等待. 这个过程类似于大夫发现你要去验个血, 于是给你开了个验血的单子, 你就去验血的队伍里排队. 线程 T1 进入条件变量的等待队列后, 是允许其他线程进入管程的. 这和去验血的时候, 医生可以给其他患者诊治, 道理都是一样的.</p> <p>再假设之后另外一个线程 T2 执行入队操作, 入队操作执行成功之后, &quot;<strong>队列不空</strong>&quot; 这个条件对于线程 T1 来说已经满足了, 此时线程 T2 要通知 T1, 告诉它需要的条件已经满足了. 当线程 T1 得到通知后, 会从等待队列里面出来, 但是出来之后不是马上执行, 而是重新进入到入口等待队列里面. 这个过程类似你验血完, 回来找大夫, 需要重新分诊.</p> <p>条件变量及其等待队列讲清楚了, 下面再说说 wait(), notify(), notifyAll() 这三个操作. 前面提到线程 T1 发现 &quot;队列不空&quot; 这个条件不满足, 需要进到对应的等待队列里等待. 这个过程就是<strong>通过调用 wait() 来实现</strong>的. 如果用对象 A 代表 &quot;队列不空&quot; 这个条件, 那么线程 T1 需要调用 A.wait(). 同理当 &quot;队列不空&quot; 这个条件满足时, 线程 T2 需要调用 A.notify() 来通知 A 等待队列中的一个线程, 此时这个队列里面只有线程 T1. 至于 notifyAll() 这个方法, 它可以通知等待队列中的所有线程.</p> <p>这里还是来一段代码再次说明一下. 下面的代码实现的是一个阻塞队列, <strong>阻塞队列有两个操作分别是入队和出队</strong>, 这两个方法都是先获取互斥锁, 类比管程模型中的入口.</p> <ol><li>对于入队操作, 如果队列已满, 就需要等待直到队列不满, 所以这里用了 <code>notFull.await();</code>​.</li> <li>对于出队操作, 如果队列为空, 就需要等待直到队列不空, 所以就用了 <code>notEmpty.await();</code>​.</li> <li>如果入队成功, 那么队列就不空了, 就需要通知条件变量: 队列不空 <code>notEmpty</code>​ 对应的等待队列.</li> <li>如果出队成功, 那就队列就不满了, 就需要通知条件变量: 队列不满 <code>notFull</code>​ 对应的等待队列.</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlockedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 条件变量: 队列不满  </span>
    <span class="token keyword">final</span> <span class="token class-name">Condition</span> notFull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 条件变量: 队列不空  </span>
    <span class="token keyword">final</span> <span class="token class-name">Condition</span> notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 入队</span>
    <span class="token keyword">void</span> <span class="token function">enq</span><span class="token punctuation">(</span><span class="token class-name">T</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>队列已满<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 等待队列不满 </span>
                notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 省略入队操作...</span>
            <span class="token comment">// 入队后, 通知可出队</span>
            notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 出队</span>
    <span class="token keyword">void</span> <span class="token function">deq</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>队列已空<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 等待队列不空</span>
                notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 省略出队操作...</span>
            <span class="token comment">// 出队后, 通知可入队</span>
            notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><p>在这段示例代码中, 用了 Java 并发包里面的 Lock 和 Condition, 如果你看着吃力, 也没关系, 后面还会详细介绍, 这个例子只是先让你明白条件变量及其等待队列是怎么回事. 需要注意的是: <strong>await() 和前面提到的 wait() 语义是一样的; signal() 和前面提到的 notify() 语义是一样的</strong>.</p> <h5 id="wait-的正确姿势"><a href="#wait-的正确姿势" class="header-anchor">#</a> wait()的正确姿势</h5> <p>但是有一点, 需要再次提醒, 对于 MESA 管程来说, <strong>有一个编程范式, 就是需要在一个 while 循环里面调用 wait(). 这个是 MESA 管程特有的</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">while</span><span class="token punctuation">(</span>条件不满足<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Hasen 模型, Hoare 模型和 MESA 模型的一个<strong>核心区别就是当条件满足后, 如何通知相关线程</strong>. 管程要求同一时刻只允许一个线程执行, 那当线程 T2 的操作使线程 T1 等待的条件满足时, T1 和 T2 究竟谁可以执行呢?</p> <ol><li>Hasen 模型里面, 要求 notify() 放在代码的最后, 这样 T2 通知完 T1 后, T2 就结束了, 然后 T1 再执行, 这样就能保证同一时刻只有一个线程执行.</li> <li>Hoare 模型里面, T2 通知完 T1 后, T2 阻塞, T1 马上执行; 等 T1 执行完, 再唤醒 T2, 也能保证同一时刻只有一个线程执行. 但是相比 Hasen 模型, T2 多了一次阻塞唤醒操作.</li> <li>MESA 管程里面, <strong>T2 通知完 T1 后, T2 还是会接着执行, T1 并不立即执行, 仅仅是从条件变量的等待队列进到入口等待队列里面. 这样做的好处是 notify() 不用放到代码的最后, T2 也没有多余的阻塞唤醒操作. 但是也有个副作用, 就是当 T1 再次执行的时候, 可能曾经满足的条件, 现在已经不满足了, 所以需要以循环方式检验条件变量</strong>.</li></ol> <h5 id="notify-何时可以使用"><a href="#notify-何时可以使用" class="header-anchor">#</a> notify()何时可以使用</h5> <p>还有一个需要注意的地方, 就是 notify() 和 notifyAll() 的使用, 前面曾经介绍过, <strong>除非经过深思熟虑, 否则尽量使用 notifyAll()</strong> . 那什么时候可以使用 notify() 呢? 需要满足以下三个条件:</p> <ol><li><strong>所有等待线程拥有相同的等待条件</strong>;</li> <li><strong>所有等待线程被唤醒后, 执行相同的操作</strong>;</li> <li><strong>只需要唤醒一个线程</strong>.</li></ol> <p>比如上面阻塞队列的例子中, 对于 &quot;队列不满&quot; 这个条件变量, 其阻塞队列里的线程都是在等待 &quot;队列不满&quot; 这个条件, 反映在代码里就是下面这 3 行代码. 对所有等待线程来说, 都是执行这 3 行代码, <strong>重点是 while 里面的等待条件是完全相同的</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>队列已满<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 等待队列不满</span>
    notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>所有等待线程被唤醒后执行的操作也是相同的, 都是下面这几行:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 省略入队操作...</span>
<span class="token comment">// 入队后, 通知可出队</span>
notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>同时也满足第 3 条, 只需要唤醒一个线程. 所以上面阻塞队列的代码, 使用 signal() 是可以的.</p> <h5 id="总结-8"><a href="#总结-8" class="header-anchor">#</a> 总结</h5> <p>Java 参考了 MESA 模型, 语言内置的管程(synchronized)对 MESA 模型进行了精简. MESA 模型中, 条件变量可以有多个, Java 语言内置的管程里只有一个条件变量. 具体如下图所示.</p> <p><img src="/img/e78da693aa84c350e12e80c9ffe1153d-20230731162452-w8cznx5.png" alt="" title="Java 中的管程示意图"></p> <p>Java 内置的管程方案(synchronized)使用简单, synchronized 关键字修饰的代码块, 在编译期会自动生成相关加锁和解锁的代码, 但是仅支持一个条件变量; 而 Java SDK 并发包实现的管程支持多个条件变量, 不过并发包里的锁, 需要开发人员自己进行加锁和解锁操作.</p> <p>并发编程里两大核心问题——互斥和同步, 都可以由管程来帮你解决. 学好管程, 理论上所有的并发问题你都可以解决, 并且很多并发工具类底层都是管程实现的, 所以学好管程, 就是相当于掌握了一把并发编程的万能钥匙.</p> <h4 id="_09-java线程-上-java线程的生命周期🍀"><a href="#_09-java线程-上-java线程的生命周期🍀" class="header-anchor">#</a> 09-Java线程(上):Java线程的生命周期🍀</h4> <p>在 Java 领域, 实现并发程序的主要手段就是多线程. 线程是操作系统里的一个概念, 虽然各种不同的开发语言如 Java, C# 等都对其进行了封装, 但是万变不离操作系统. <strong>Java 语言里的线程本质上就是操作系统的线程, 它们是一一对应的</strong>.</p> <p>在操作系统层面, 线程也有 &quot;生老病死&quot;, 专业的说法叫有<strong>生命周期</strong>. 对于有生命周期的事物, 要学好它, 思路非常简单, 只要能搞懂<strong>生命周期中各个节点的状态转换机制</strong>就可以了.</p> <p>虽然不同的开发语言对于操作系统线程进行了不同的封装, 但是对于线程的生命周期这部分, 基本上是雷同的. 所以, 可以先来了解一下<strong>通用的线程生命周期模型</strong>, 这部分内容也适用于很多其他编程语言; 然后再详细有针对性地学习一下 Java 中线程的生命周期.</p> <h5 id="通用的线程生命周期"><a href="#通用的线程生命周期" class="header-anchor">#</a> 通用的线程生命周期</h5> <p>通用的线程生命周期基本上可以用下图这个 &quot;五态模型&quot; 来描述. 这五态分别是: <strong>初始状态, 可运行状态, 运行状态, 休眠状态</strong>和<strong>终止状态</strong>.</p> <p><img src="/img/92df4e90e0a21aa654639d64c6c1ca02-20230731162452-eku2agl.png" alt="" title="通用线程状态转换图-五态模型"></p> <p>这 &quot;五态模型&quot; 的详细情况如下所示.</p> <ol><li><strong>初始状态: ** 指的是线程已经被创建, 但是还</strong>不允许分配 CPU 执行**. 这个状态属于编程语言特有的, 不过这里所谓的被创建, 仅仅是在编程语言层面被创建, 而<strong>在操作系统层面, 真正的线程还没有创建</strong>.</li> <li><strong>可运行状态</strong>: 指的是线程<strong>可以分配 CPU 执行</strong>. 在这种状态下, 真正的操作系统线程<strong>已经被成功创建</strong>了, 所以可以分配 CPU 执行.</li> <li><strong>运行状态</strong>: 当有空闲的 CPU 时, 操作系统会将其<strong>分配给一个处于可运行状态的线程</strong>, 被分配到 CPU 的线程的状态就转换成了<strong>运行状态</strong>.</li> <li><strong>休眠状态</strong>: 运行状态的线程如果<strong>调用一个阻塞的 API(例如以阻塞方式读文件)或者等待某个事件(例如条件变量)</strong> , 那么线程的状态就会转换到<strong>休眠状态, 同时释放 CPU 使用权, 休眠状态的线程永远没有机会获得 CPU 使用权. 当等待的事件出现了, 线程就会从休眠状态转换到可运行状态</strong>.</li> <li><strong>终止状态</strong>: 线程执行完或者出现异常就会进入<strong>终止状态</strong>, 终止状态的线程不会切换到其他任何状态, 进入终止状态也就意味着线程的生命周期结束了.</li></ol> <p>这五种状态在不同编程语言里会有简化合并. 例如, C 语言的 POSIX Threads 规范, 就把初始状态和可运行状态合并了; Java 语言里则把可运行状态和运行状态合并了, 这两个状态在操作系统调度层面有用, 而 JVM 层面不关心这两个状态, 因为 JVM 把线程调度交给操作系统处理了.</p> <p>除了简化合并, 这五种状态也有<strong>可能被细化</strong>, 比如 Java 语言里就细化了休眠状态(这个下面会详细讲解).</p> <h5 id="java中线程的生命周期"><a href="#java中线程的生命周期" class="header-anchor">#</a> Java中线程的生命周期</h5> <p>介绍完通用的线程生命周期模型, 接下来就来详细看看 Java 语言里的线程生命周期是什么样的.</p> <p>Java 语言中线程共有六种状态, 分别是:</p> <ol><li><strong>NEW(初始化状态)</strong></li> <li><strong>RUNNABLE(可运行/运行状态)</strong></li> <li><strong>BLOCKED(阻塞状态)</strong></li> <li><strong>WAITING(无时限等待)</strong></li> <li><strong>TIMED_WAITING(有时限等待)</strong></li> <li><strong>TERMINATED(终止状态)</strong></li></ol> <p>这看上去挺复杂的, 状态类型也比较多. <mark><strong>但其实在操作系统层面, Java 线程中的 BLOCKED, WAITING, TIMED_WAITING 是一种状态, 即前面提到的休眠状态. 也就是说只要 Java 线程处于这三种状态之一, 那么这个线程就永远没有 CPU 的使用权</strong></mark>.</p> <p>所以 Java 线程的生命周期可以简化为下图:</p> <p><img src="/img/14d5ebdae35bc89ddc07820d3b187cd7-20230731162452-hi7wnsq.png" alt="" title="Java 中的线程状态转换图"></p> <p>其中, <strong>BLOCKED, WAITING, TIMED_WAITING 可以理解为线程导致休眠状态的三种原因</strong>. 那具体是哪些情形会导致线程从 RUNNABLE 状态转换到这三种状态呢? 而这三种状态又是何时转换回 RUNNABLE 的呢? 以及 NEW, TERMINATED 和 RUNNABLE 状态是如何转换的?</p> <h6 id="_1-runnable与blocked的状态转换"><a href="#_1-runnable与blocked的状态转换" class="header-anchor">#</a> (1)RUNNABLE与BLOCKED的状态转换</h6> <p><strong>只有一种场景会触发这种转换, 就是线程等待 synchronized 的隐式锁</strong>. synchronized 修饰的方法, 代码块同一时刻只允许一个线程执行, 其他线程只能等待, 这种情况下, <strong>等待的线程就会从 RUNNABLE 转换到 BLOCKED 状态. 而当等待的线程获得 synchronized 隐式锁时, 就又会从 BLOCKED 转换到 RUNNABLE 状态</strong>.</p> <p>如果你熟悉操作系统线程的生命周期的话, 可能会有个疑问: 线程调用阻塞式 API 时, 是否会转换到 BLOCKED 状态呢? 在操作系统层面, 线程是会转换到休眠状态的, 但是在 JVM 层面, Java 线程的状态不会发生变化, 也就是说 Java 线程的状态会依然保持 RUNNABLE 状态. <mark><strong>JVM 层面并不关心操作系统调度相关的状态</strong></mark>, 因为在 JVM 看来, 等待 CPU 使用权(操作系统层面此时处于可执行状态)与等待 I/O(操作系统层面此时处于休眠状态)没有区别, 都是在等待某个资源, 所以都归入了 RUNNABLE 状态.</p> <p>而平时所谓的 Java 在调用阻塞式 API 时, 线程会阻塞, <strong>指的是操作系统线程的状态, 并不是 Java 线程的状态</strong>.</p> <h6 id="_2-runnable与waiting的状态转换"><a href="#_2-runnable与waiting的状态转换" class="header-anchor">#</a> (2)RUNNABLE与WAITING的状态转换</h6> <p>总体来说, 有三种场景会触发这种转换.</p> <p><strong>第一种场景, 获得 synchronized 隐式锁的线程, 调用无参数的 Object.wait() 方法</strong>. 其中, wait() 方法在上一节讲解管程的时候已经深入介绍过了, 这里就不再赘述.</p> <p><strong>第二种场景, 调用无参数的 Thread.join() 方法</strong>. 其中的 join() 是一种<strong>线程同步方法</strong>, 例如有一个线程对象 thread A, 当调用 A.join() 的时候, 执行这条语句的线程会等待 thread A 执行完, 而等待中的这个线程, 其状态会从 RUNNABLE 转换到 WAITING. 当线程 thread A 执行完, 原来等待它的线程又会从 WAITING 状态转换到 RUNNABLE.</p> <p><strong>第三种场景, 调用 LockSupport.park() 方法</strong>. 其中的 LockSupport 对象, 也许你有点陌生, 其实 Java 并发包中的锁, 都是基于它实现的. 调用 LockSupport.park() 方法, 当前线程会<strong>阻塞</strong>, 线程的状态会从 RUNNABLE 转换到 WAITING. 调用 LockSupport.unpark(Thread thread) 可唤醒目标线程, 目标线程的状态又会从 WAITING 状态转换到 RUNNABLE.</p> <h6 id="_3-runnable与timed-waiting的状态转换"><a href="#_3-runnable与timed-waiting的状态转换" class="header-anchor">#</a> (3)RUNNABLE与TIMED_WAITING的状态转换</h6> <p>有五种场景会触发这种转换:</p> <ol><li>调用<strong>带超时参数</strong>的 Thread.sleep(long millis) 方法;</li> <li>获得 synchronized 隐式锁的线程, 调用<strong>带超时参数</strong>的 Object.wait(long timeout) 方法;</li> <li>调用<strong>带超时参数</strong>的 Thread.join(long millis) 方法;</li> <li>调用<strong>带超时参数</strong>的 LockSupport.parkNanos(Object blocker, long deadline) 方法;</li> <li>调用<strong>带超时参数</strong>的 LockSupport.parkUntil(long deadline) 方法.</li></ol> <p>可以发现, 其实 TIMED_WAITING 和 WAITING 状态的区别, 仅仅是触发条件多了<strong>超时参数</strong>.</p> <h6 id="_4-从new到runnable状态"><a href="#_4-从new到runnable状态" class="header-anchor">#</a> (4)从NEW到RUNNABLE状态</h6> <p>Java 刚创建出来的 Thread 对象就是 NEW 状态, 而创建 Thread 对象主要有两种方法. 一种是继承 Thread 对象, 重写 run() 方法. 示例代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 自定义线程对象</span>
<span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 线程需要执行的代码</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 创建线程对象</span>
<span class="token class-name">MyThread</span> myThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>另一种是实现 Runnable 接口, 重写 run() 方法, 并将该实现类作为创建 Thread 对象的参数. 示例代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 实现 Runnable 接口</span>
<span class="token keyword">class</span> <span class="token class-name">Runner</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 线程需要执行的代码</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 创建线程对象</span>
<span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>NEW 状态的线程, 不会被操作系统调度, 因此不会执行</strong>. Java 线程要执行, 就必须转换到 RUNNABLE 状态. 从 NEW 状态转换到 RUNNABLE 状态很简单, 只要<strong>调用线程对象的 start() 方法</strong>就可以了, 示例代码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">MyThread</span> myThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 从 NEW 状态转换到 RUNNABLE 状态</span>
myThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h6 id="_5-从runnable到terminated状态"><a href="#_5-从runnable到terminated状态" class="header-anchor">#</a> (5)从RUNNABLE到TERMINATED状态</h6> <p><strong>线程执行完 run() 方法后, 会自动转换到 TERMINATED 状态, 当然如果执行 run() 方法的时候异常抛出, 也会导致线程终止</strong>. 有时候需要强制中断 run() 方法的执行, 例如 run() 方法访问一个很慢的网络, 等不下去了, 想终止怎么办呢? Java 的 Thread 类里面倒是有个 stop() 方法, 不过已经标记为 @Deprecated, 所以不建议使用了. 正确的姿势其实是调用 interrupt() 方法.</p> <p>**那 stop() 和 interrupt() 方法的主要区别是什么呢? **</p> <p>stop() 方法会真的杀死线程, 不给线程喘息的机会, 如果线程持有 ReentrantLock 锁, 被 stop() 的线程并不会自动调用 ReentrantLock 的 unlock() 去释放锁, 那其他线程就再也没机会获得 ReentrantLock 锁, 这实在是太危险了. 所以该方法就不建议使用了, 类似的方法还有 suspend() 和 resume() 方法, 这两个方法同样也都不建议使用了.</p> <p>而 interrupt() 方法就温柔多了, <strong>interrupt() 方法仅仅是通知线程</strong>, 线程有机会执行一些后续操作, 同时也可以无视这个通知. 被 interrupt 的线程, 是怎么收到通知的呢? 一种是异常, 另一种是主动检测.</p> <p>当线程 A 处于 WAITING, TIMED_WAITING 状态时, 如果其他线程调用线程 A 的 interrupt() 方法, 会使线程 A 返回到 RUNNABLE 状态, 同时线程 A 的代码会触发 InterruptedException 异常. 上面提到转换到 WAITING, TIMED_WAITING 状态的触发条件, 都是调用了类似 wait(), join(), sleep() 这样的方法, 看这些方法的签名, 发现都会 throws InterruptedException 这个异常. 这个异常的触发条件就是: <strong>其他线程调用了该线程的 interrupt() 方法</strong>.</p> <p>当线程 A 处于 RUNNABLE 状态时, 并且阻塞在 java.nio.channels.InterruptibleChannel 上时, 如果其他线程调用线程 A 的 interrupt() 方法, 线程 A 会触发 java.nio.channels.ClosedByInterruptException 这个异常; 而阻塞在 java.nio.channels.Selector 上时, 如果其他线程调用线程 A 的 interrupt() 方法, 线程 A 的 java.nio.channels.Selector 会立即返回.</p> <p>上面这两种情况属于被中断的线程通过异常的方式获得了通知. 还有一种是主动检测, 如果线程处于 RUNNABLE 状态, 并且没有阻塞在某个 I/O 操作上, 例如中断计算圆周率的线程 A, 这时就得依赖线程 A 主动检测中断状态了. 如果其他线程调用线程 A 的 interrupt() 方法, 那么线程 A 可以通过 isInterrupted() 方法, 检测是不是自己被中断了.</p> <h5 id="总结-9"><a href="#总结-9" class="header-anchor">#</a> 总结</h5> <p>理解 Java 线程的各种状态以及生命周期对于诊断多线程 Bug 非常有帮助, 多线程程序很难调试, 出了 Bug 基本上都是靠日志, 靠线程 dump 来跟踪问题, 分析线程 dump 的一个基本功就是分析线程状态, 大部分的死锁, 饥饿, 活锁问题都需要跟踪分析线程的状态. 同时本文介绍的线程生命周期具备很强的通用性, 对于学习其他语言的多线程编程也有很大的帮助.</p> <h4 id="_10-java线程-中-创建多少线程才是合适的-🍀"><a href="#_10-java线程-中-创建多少线程才是合适的-🍀" class="header-anchor">#</a> 10-Java线程(中):创建多少线程才是合适的?🍀</h4> <p>在 Java 领域, 实现并发程序的主要手段就是多线程, 使用多线程还是比较简单的, 但是<strong>使用多少个线程</strong>却是个困难的问题. 工作中, 经常有人问, &quot;各种线程池的线程数量调整成多少是合适的?&quot; 或者 &quot;Tomcat 的线程数, Jdbc 连接池的连接数是多少?&quot; 等等. 那<strong>应该如何设置合适的线程数</strong>呢?</p> <p>要解决这个问题, 首先要分析以下两个问题:</p> <ol><li>为什么要使用多线程?</li> <li>多线程的应用场景有哪些?</li></ol> <h5 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="header-anchor">#</a> 为什么要使用多线程?</h5> <p>使用多线程, 本质上就是提升程序性能. 不过此刻谈到的性能, 可能在你脑海里还是比较笼统的, 基本上就是快, 快, 快, 这种无法度量的感性认识很不科学, 所以在提升性能之前, 首要问题是: <strong>如何度量性能</strong>.</p> <p>度量性能的指标有很多, 但是有两个指标是最核心的, 它们就是<strong>延迟和吞吐量</strong>. <strong>延迟</strong>指的是发出请求到收到响应这个过程的时间; 延迟越短, 意味着程序执行得越快, 性能也就越好. <strong>吞吐量</strong>指的是在单位时间内能处理请求的数量; 吞吐量越大, 意味着程序能处理的请求越多, 性能也就越好. 这两个指标内部有一定的联系(同等条件下, 延迟越短, 吞吐量越大), 但是由于它们隶属不同的维度(一个是时间维度, 一个是空间维度), 并不能互相转换.</p> <p>所谓提升性能, 从度量的角度, 主要是<strong>降低延迟, 提高吞吐量</strong>. 这也是使用多线程的主要目的. 那该怎么降低延迟, 提高吞吐量呢? 这个就要从多线程的应用场景说起了.</p> <h5 id="多线程的应用场景"><a href="#多线程的应用场景" class="header-anchor">#</a> 多线程的应用场景</h5> <p>要想 &quot;降低延迟, 提高吞吐量&quot;, 对应的方法, 基本上有两个方向, 一个方向是<strong>优化算法</strong>, 另一个方向是<strong>将硬件的性能发挥到极致</strong>. 前者属于算法范畴, 后者则是和并发编程息息相关了. 那计算机主要有哪些硬件呢? 主要是两类: 一个是 I/O, 一个是 CPU. 简言之, <strong>在并发编程领域, 提升性能本质上就是提升硬件的利用率, 再具体点来说, 就是提升 I/O 的利用率和 CPU 的利用率</strong>.</p> <p>估计这个时候你会有个疑问, 操作系统不是已经解决了硬件的利用率问题了吗? 的确是这样, 例如操作系统已经解决了磁盘和网卡的利用率问题, 利用中断机制还能避免 CPU 轮询 I/O 状态, 也提升了 CPU 的利用率. 但是操作系统解决硬件利用率问题的对象往往是单一的硬件设备, 而并发程序, 往往需要 CPU 和 I/O 设备相互配合工作, 也就是说, <strong>需要解决 CPU 和 I/O 设备综合利用率的问题</strong>. 关于这个综合利用率的问题, 操作系统虽然没有办法完美解决, 但是却提供了方案, 那就是: 多线程.</p> <p>下面用一个简单的示例来说明: 如何利用多线程来提升 CPU 和 I/O 设备的利用率? 假设程序按照 CPU 计算和 I/O 操作交叉执行的方式运行, 而且 CPU 计算和 I/O 操作的耗时是 1:1.</p> <p>如下图所示, 如果<strong>只有一个线程</strong>, 执行 CPU 计算的时候, I/O 设备空闲; 执行 I/O 操作的时候, CPU 空闲, 所以 CPU 的利用率和 I/O 设备的利用率都是 50%.</p> <p><img src="/img/b5ee606d45d6a5c278cac82e0ba4aa66-20230731162452-4my2t0r.png" alt="" title="单线程执行示意图"></p> <p>如果<strong>有两个线程</strong>, 如下图所示, 当线程 A 执行 CPU 计算的时候, 线程 B 执行 I/O 操作; 当线程 A 执行 I/O 操作的时候, 线程 B 执行 CPU 计算, 这样 CPU 的利用率和 I/O 设备的利用率就都达到了 100%.</p> <p><img src="/img/c4b11ea40c23a006e955f7963570495f-20230731162452-zgdm6ug.png" alt="" title="二线程执行示意图"></p> <p>将 CPU 的利用率和 I/O 设备的利用率都提升到了 100%, 会对性能产生了哪些影响呢? 通过上面的图示, 很容易看出: 单位时间处理的请求数量翻了一番, 也就是说吞吐量提高了 1 倍. 此时可以逆向思维一下, <mark><strong>如果 CPU 和 I/O 设备的利用率都很低, 那么可以尝试通过增加线程来提高吞吐量</strong></mark>.</p> <p><strong>在单核时代, 多线程主要就是用来平衡 CPU 和 I/O 设备的</strong>. 如果程序只有 CPU 计算, 而没有 I/O 操作的话, 多线程不但不会提升性能, 还会使性能变得更差, 原因是增加了线程切换的成本. 但是在多核时代, 这种纯计算型的程序也可以利用多线程来提升性能. 为什么呢? <strong>因为利用多核可以降低响应时间</strong>.</p> <p>为便于理解, 这里举个简单的例子说明一下: 计算 1+2+...+100 亿的值, 如果在 4 核的 CPU 上利用 4 个线程执行, 线程 A 计算 [1, 25 亿), 线程 B 计算 [25 亿, 50 亿), 线程 C 计算 [50, 75 亿), 线程 D 计算 [75 亿, 100 亿], 之后汇总, 那么理论上应该比一个线程计算 [1, 100 亿] 快将近 4 倍, 响应时间能够降到 25%. 一个线程, 对于 4 核的 CPU, CPU 的利用率只有 25%, 而 4 个线程, 则能够将 CPU 的利用率提高到 100%.</p> <p><img src="/img/3c0cf831d6c80dc83976f88f99b23c18-20230731162452-rjehpzy.png" alt="" title="多核执行多线程示意图"></p> <h5 id="创建多少线程合适"><a href="#创建多少线程合适" class="header-anchor">#</a> 创建多少线程合适?</h5> <p>创建多少线程合适, 要看多线程具体的应用场景. <strong>程序一般都是 CPU 计算和 I/O 操作交叉执行的</strong>, 由于 I/O 设备的速度相对于 CPU 来说都很慢, 所以大部分情况下, I/O 操作执行的时间相对于 CPU 计算来说都非常长, 这种场景一般都称为 I/O 密集型计算; 和 I/O 密集型计算相对的就是 CPU 密集型计算了, CPU 密集型计算大部分场景下都是纯 CPU 计算. I/O 密集型程序和 CPU 密集型程序, 计算最佳线程数的方法是不同的.</p> <p>下面对这两个场景分别说明.</p> <p>对于 <strong>CPU 密集型计算</strong>, 多线程本质上是<mark><strong>提升多核 CPU 的利用率</strong></mark>, 所以对于一个 4 核的 CPU, 每个核一个线程, 理论上创建 4 个线程就可以了, 再多创建线程也只是增加线程切换的成本. 所以, **对于 CPU 密集型的计算场景, 理论上 &quot;<strong>​</strong>==线程的数量 = CPU 核数<mark>**​ <strong>&quot; 就是最合适的</strong>. 不过在工程上, <strong>线程的数量一般会设置为 &quot;<strong>​</strong></strong></mark>CPU 核数 +== <strong>1&quot;</strong> , 这样的话, <strong>当线程因为偶尔的内存页失效或其他原因导致阻塞时, 这个额外的线程可以顶上, 从而保证 CPU 的利用率</strong>.</p> <p>对于 <strong>I/O 密集型的计算</strong>场景, 比如前面的例子中, 如果 CPU 计算和 I/O 操作的<strong>耗时是 1:1</strong>, 那么 2 个线程是最合适的. 如果 CPU 计算和 I/O 操作的<strong>耗时是 1:2</strong>, 那多少个线程合适呢? 是 3 个线程, 如下图所示: CPU 在 A, B, C 三个线程之间切换, 对于线程 A, 当 CPU 从 B, C 切换回来时, 线程 A 正好执行完 I/O 操作. 这样 CPU 和 I/O 设备的利用率都达到了 100%.</p> <p><img src="/img/6556668e05a6637c239b382b3e33b68d-20230731162452-9rhk5gh.png" alt="" title="三线程执行示意图"></p> <p>通过上面这个例子可以发现, 对于 <strong>I/O 密集型计算场景</strong>, 最佳的线程数是与程序中 CPU 计算和 I/O 操作的耗时比相关的, 可以总结出这样一个公式:</p> <blockquote><p>最佳线程数 = 1 + (I/O耗时 / CPU耗时)</p></blockquote> <p>令 R=I/O耗时 / CPU耗时, 综合上图, 可以这样理解: <strong>当线程 A 执行 IO 操作时, 另外 R 个线程正好执行完各自的 CPU 计算. 这样 CPU 的利用率就达到了 100%</strong> .</p> <p>不过上面这个公式是针对<strong>单核 CPU 的</strong>, 至于多核 CPU, 也很简单, 只需要<strong>等比扩大</strong>就可以了, 计算公式如下:</p> <blockquote><p>最佳线程数 = CPU 核数 * [ 1 + (I/O耗时 / CPU耗时)]</p></blockquote> <h5 id="总结-10"><a href="#总结-10" class="header-anchor">#</a> 总结</h5> <p>很多人都知道线程数不是越多越好, 但是设置多少是合适的, 却又拿不定主意. 其实只要把握住一条原则就可以了, 这条原则就是<strong>将硬件的性能发挥到极致</strong>. 上面针对 CPU 密集型和 I/O 密集型计算场景都给出了理论上的最佳公式, 这些公式背后的目标其实就是<strong>将硬件的性能发挥到极致</strong>.</p> <p>对于 I/O 密集型计算场景, I/O 耗时和 CPU 耗时的比值是一个关键参数, 不幸的是这个参数是未知的, 而且是动态变化的, 所以工程上要估算这个参数, 然后做各种不同场景下的压测来验证估计. 不过工程上, 原则还是<strong>将硬件的性能发挥到极致</strong>, 所以压测时, 需要重点关注 CPU, I/O 设备的利用率和性能指标(响应时间, 吞吐量)之间的关系.</p> <h4 id="_11-java线程-下-为什么局部变量是线程安全的-🍀"><a href="#_11-java线程-下-为什么局部变量是线程安全的-🍀" class="header-anchor">#</a> 11-Java线程(下):为什么局部变量是线程安全的?🍀</h4> <p>多个线程同时访问共享变量的时候, 会导致并发问题. 那在 Java 语言里, 是不是所有变量都是共享变量呢? 工作中我发现不少同学会给方法里面的局部变量设置同步, 显然这些同学并没有把共享变量搞清楚. 那 Java 方法里面的局部变量是否存在并发问题呢? 下面就先结合一个例子剖析下这个问题.</p> <p>比如, 下面代码里的 fibonacci() 这个方法, 会根据传入的参数 n, 返回 1 到 n 的斐波那契数列, 斐波那契数列类似这样:  1, 1, 2, 3, 5, 8, 13, 21, 34... 第 1 项和第 2 项是 1, 从第 3 项开始, 每一项都等于前两项之和. 在这个方法里面, 有个局部变量: 数组 r 用来保存数列的结果, 每次计算完一项, 都会更新数组 r 对应位置中的值. 可以思考这样一个问题, 当多个线程调用 fibonacci() 这个方法的时候, 数组 r 是否存在数据竞争(Data Race)呢?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 返回斐波那契数列</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建结果数组</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 初始化第一, 第二个数</span>
    r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// ①</span>
    <span class="token comment">// 计算 2..n</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> r<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>可以在大脑里模拟一下多个线程调用 fibonacci() 方法的情景, 假设多个线程执行到 ① 处, 多个线程都要对数组 r 的第 1 项和第 2 项赋值, 这里看上去感觉是存在数据竞争的, 不过感觉再次欺骗了你.</p> <p>其实很多人也是知道<strong>局部变量不存在数据竞争</strong>的, 但是至于原因嘛, 就说不清楚了.</p> <p>那它背后的原因到底是怎样的呢? 要弄清楚这个, 就需要一点编译原理的知识. 在 CPU 层面, 是没有方法概念的, CPU 的眼里, 只有一条条的指令. 编译程序, 负责把高级语言里的方法转换成一条条的指令. 所以可以站在编译器实现者的角度来思考 &quot;怎么完成方法到指令的转换&quot;.</p> <h5 id="方法是如何被执行的"><a href="#方法是如何被执行的" class="header-anchor">#</a> 方法是如何被执行的</h5> <p>高级语言里的普通语句, 例如上面的 <code>r[i] = r[i-2] + r[i-1];</code>​ 翻译成 CPU 的指令相对简单, 可方法的调用就比较复杂了. 例如下面这三行代码: 第 1 行, 声明一个 int 变量 a; 第 2 行, 调用方法 fibonacci(a); 第 3 行, 将 b 赋值给 c.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c <span class="token operator">=</span> b<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当调用 fibonacci(a) 的时候, CPU 要先找到方法 fibonacci() 的地址, 然后跳转到这个地址去执行代码, 最后 CPU 执行完方法 fibonacci() 之后, 要能够返回. 首先找到调用方法的下一条语句的地址: 也就是 <code>int[] c=b;</code>​ 的地址, 再跳转到这个地址去执行. 可以参考下面这个图再加深一下理解.</p> <p><img src="/img/961d3abf78f9e9cba87d1721042cc98f-20230731162452-napm5pp.png" alt="" title="方法的调用过程"></p> <p>到这里, 方法调用的过程想必你已经清楚了, 但是还有一个很重要的问题, &quot;CPU 去哪里找到调用方法的参数和返回地址?&quot; 如果你熟悉 CPU 的工作原理, 你应该会立刻想到: <strong>通过 CPU 的堆栈寄存器</strong>. CPU 支持一种栈结构, 栈你一定很熟悉了, 就像手枪的弹夹, 先入后出. 因为这个栈是和方法调用相关的, 因此经常被称为<strong>调用栈</strong>.</p> <p>例如, 有三个方法 A, B, C, 他们的调用关系是 A-&gt;B-&gt;C(A 调用 B, B 调用 C), 在运行时, 会构建出下面这样的调用栈. 每个方法在调用栈里都有自己的独立空间, 称为<strong>栈帧</strong>, 每个栈帧里都有对应方法需要的<strong>参数和返回地址</strong>. 当调用方法时, 会创建新的栈帧, 并压入调用栈; 当方法返回时, 对应的栈帧就会被自动弹出. 也就是说, <strong>栈帧和方法是同生共死的</strong>.</p> <p><img src="/img/a5174d867f41b2d77d3b351b011d4fff-20230731162452-6qbmt6a.png" alt="" title="调用栈结构"></p> <p>利用栈结构来支持方法调用这个方案非常普遍, 以至于 CPU 里内置了栈寄存器. 虽然各家编程语言定义的方法千奇百怪, 但是方法的内部执行原理却是出奇的一致: 都是<strong>靠栈结构解决</strong>的. Java 语言虽然是靠虚拟机解释执行的, 但是方法的调用也是利用栈结构解决的.</p> <h5 id="局部变量存哪里"><a href="#局部变量存哪里" class="header-anchor">#</a> 局部变量存哪里?</h5> <p>前面已经知道了方法间的调用在 CPU 眼里是怎么执行的, 但还有一个关键问题: <strong>方法内的局部变量存哪里</strong>?</p> <p>局部变量的作用域是方法内部, 也就是说当方法执行完, 局部变量就没用了, 局部变量应该和方法同生共死. 此时你应该会想到调用栈的栈帧, 调用栈的栈帧就是和方法同生共死的, 所以局部变量放到调用栈里那儿是相当的合理. 事实上, 的确是这样的, <mark><strong>局部变量就是放到了调用栈里</strong></mark>. 于是调用栈的结构就变成了下图这样.</p> <p><img src="/img/82523771c0a0eb804f7d4de7181a5756-20230731162452-3yuxdly.png" alt="" title="保护局部变量的调用栈结构"></p> <p>这个结论相信很多人都知道, 因为学 Java 语言的时候, 基本所有的教材都会告诉你 new 出来的对象是在堆里, 局部变量是在栈里, 只不过很多人并不清楚堆和栈的区别, 以及为什么要区分堆和栈. 现在你应该很清楚了, <strong>局部变量是和方法同生共死的, 一个变量如果想跨越方法的边界, 就必须创建在堆里</strong>.</p> <h5 id="调用栈与线程"><a href="#调用栈与线程" class="header-anchor">#</a> 调用栈与线程</h5> <p>两个线程可以同时用不同的参数调用相同的方法, 那调用栈和线程之间是什么关系呢? 答案是: <mark><strong>每个线程都有自己独立的调用栈</strong></mark>. 因为如果不是这样, 那两个线程就互相干扰了. 如下面这幅图所示, 线程 A, B, C 每个线程都有自己独立的调用栈.</p> <p><img src="/img/967e2ce66cb241d3610b3e150dc79bf7-20230731162452-kblwtlc.png" alt="" title="线程与调用栈的关系图"></p> <p>现在回过头来再看之前的问题: <strong>Java 方法里面的局部变量是否存在并发问题? 其实就是一点问题都没有. 因为每个线程都有自己的调用栈, 局部变量保存在线程各自的调用栈里面, 不会共享, 所以自然也就没有并发问题. 再次重申一遍: 没有共享, 就没有伤害</strong>.</p> <h5 id="线程封闭"><a href="#线程封闭" class="header-anchor">#</a> 线程封闭</h5> <p>方法里的局部变量, 因为不会和其他线程共享, 所以没有并发问题, 这个思路很好, 已经成为解决并发问题的一个重要技术, 同时还有个响当当的名字叫做<mark><strong>线程封闭</strong></mark>, 比较官方的解释是: <strong>仅在单线程内访问数据</strong>. 由于不存在共享, 所以即便不同步也不会有并发问题, 性能杠杠的.</p> <p>采用线程封闭技术的案例非常多, 例如从数据库连接池里获取的连接 Connection, 在 JDBC 规范里并没有要求这个 Connection 必须是线程安全的. <strong>数据库连接池通过线程封闭技术, 保证一个 Connection 一旦被一个线程获取之后, 在这个线程关闭 Connection 之前的这段时间里, 不会再分配给其他线程, 从而保证了 Connection 不会有并发问题</strong>.</p> <h4 id="_12-如何用面向对象思想写好并发程序"><a href="#_12-如何用面向对象思想写好并发程序" class="header-anchor">#</a> 12-如何用面向对象思想写好并发程序?</h4> <p>面向对象思想与并发编程有关系吗? 本来是没关系的, 它们分属两个不同的领域, 但是在 Java 语言里, 这两个领域被无情地融合在一起了, 好在融合的效果还是不错的: <strong>在 Java 语言里, 面向对象思想能够让并发编程变得更简单</strong>.</p> <p>那如何才能用面向对象思想写好并发程序呢? 结合我自己的工作经验来看, 我觉得你可以从<strong>封装共享变量, 识别共享变量间的约束条件和制定并发访问策略</strong>这三个方面下手.</p> <h5 id="_1-封装共享变量"><a href="#_1-封装共享变量" class="header-anchor">#</a> 1.封装共享变量</h5> <p>并发程序的一个核心问题, 不过是解决多线程同时访问共享变量的问题. 前面类比过球场门票的管理, 现实世界里门票管理的一个核心问题是: 所有观众只能通过规定的入口进入, 否则检票就形同虚设. 在编程世界这个问题也很重要, 编程领域里面对于共享变量的访问路径就类似于球场的入口, 必须严格控制. 好在有了面向对象思想, 对共享变量的访问路径可以轻松把控.</p> <p>面向对象思想里面有一个很重要的特性是<strong>封装</strong>, 封装的通俗解释就是<strong>将属性和实现细节封装在对象内部</strong>, 外界对象<strong>只能通过</strong>目标对象提供的<strong>公共方法来间接访问</strong>这些内部属性, 这和门票管理模型匹配度相当的高, 球场里的座位就是对象属性, 球场入口就是对象的公共方法. <strong>把共享变量作为对象的属性, 那对于共享变量的访问路径就是对象的公共方法, 所有入口都要安排检票程序就相当于前面提到的并发访问策略</strong>.</p> <p>利用面向对象思想写并发程序的思路, 其实就这么简单: <strong>将共享变量作为对象属性封装在内部, 对所有公共方法制定并发访问策略</strong>. 就拿很多统计程序都要用到计数器来说, 下面的计数器程序共享变量只有一个, 就是 value, 把它作为 Counter 类的属性, 并且将两个公共方法 get() 和 addOne() 声明为同步方法, 这样 Counter 类就成为一个线程安全的类了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> value<span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">++</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>当然, 实际工作中, 很多的场景都不会像计数器这么简单, 经常要面临的情况往往是有很多的共享变量, 例如, 信用卡账户有卡号, 姓名, 身份证, 信用额度, 已出账单, 未出账单等很多共享变量. 这么多的共享变量, 如果每一个都考虑它的并发安全问题, 那就累死了. 但其实仔细观察, 你会发现, 很多共享变量的值是不会变的, 例如信用卡账户的卡号, 姓名, 身份证. <strong>对于这些不会发生变化的共享变量, 建议用 final 关键字来修饰</strong>. 这样既能避免并发问题, 也能很明了地表明你的设计意图, 让后面接手你程序的兄弟知道, 你已经考虑过这些共享变量的并发安全问题了.</p> <h5 id="_2-识别共享变量间的约束条件"><a href="#_2-识别共享变量间的约束条件" class="header-anchor">#</a> 2.识别共享变量间的约束条件</h5> <p>识别共享变量间的约束条件非常重要. 因为<strong>这些约束条件, 决定了并发访问策略</strong>. 例如, 库存管理里面有个合理库存的概念, 库存量不能太高, 也不能太低, 它有一个上限和一个下限. 关于这些约束条件, 可以用下面的程序来模拟一下. 在类 SafeWM 中, 声明了两个成员变量 upper 和 lower, 分别代表库存上限和库存下限, 这两个变量用了 AtomicLong 这个原子类, 原子类是线程安全的, 所以这两个成员变量的 set 方法就不需要同步了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SafeWM</span> <span class="token punctuation">{</span>
    <span class="token comment">// 库存上限</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicLong</span> upper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 库存下限</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicLong</span> lower <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 设置库存上限</span>
    <span class="token keyword">void</span> <span class="token function">setUpper</span><span class="token punctuation">(</span><span class="token keyword">long</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>
        upper<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 设置库存下限</span>
    <span class="token keyword">void</span> <span class="token function">setLower</span><span class="token punctuation">(</span><span class="token keyword">long</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>
        lower<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 省略其他业务代码</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>虽说上面的代码是没有问题的, 但是忽视了一个约束条件, 就是<strong>库存下限要小于库存上限</strong>, 这个约束条件能够直接加到上面的 set 方法上吗? 先直接加一下看看效果(如下面代码所示). 在 setUpper() 和 setLower() 中增加了<strong>参数校验</strong>, 这乍看上去好像是对的, 但其实存在并发问题, <strong>问题在于存在竞态条件</strong>. 这里顺便插一句, 其实当看到代码里出现 if 语句的时候, 就应该立刻意识到可能存在竞态条件.</p> <p>假设库存的下限和上限分别是 (2,10), 线程 A 调用 setUpper(5) 将上限设置为 5, 线程 B 调用 setLower(7) 将下限设置为 7, 如果线程 A 和线程 B 完全同时执行, 你会发现线程 A 能够通过参数校验, 因为这个时候, 下限还没有被线程 B 设置, 还是 2, 而 5 &gt; 2; 线程 B 也能够通过参数校验, 因为这个时候, 上限还没有被线程 A 设置, 还是 10, 而 7 &lt; 10. 当线程 A 和线程 B 都通过参数校验后, 就把库存的下限和上限设置成 (7, 5) 了, 显然此时的结果是不符合<strong>库存下限要小于库存上限</strong>这个约束条件的.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SafeWM</span> <span class="token punctuation">{</span>
    <span class="token comment">// 库存上限</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicLong</span> upper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 库存下限</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicLong</span> lower <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 设置库存上限</span>
    <span class="token keyword">void</span> <span class="token function">setUpper</span><span class="token punctuation">(</span><span class="token keyword">long</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 检查参数合法性</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">&lt;</span> lower<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        upper<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 设置库存下限</span>
    <span class="token keyword">void</span> <span class="token function">setLower</span><span class="token punctuation">(</span><span class="token keyword">long</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 检查参数合法性</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">&gt;</span> upper<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        lower<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 省略其他业务代码</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>在没有识别出<strong>库存下限要小于库存上限</strong>这个约束条件之前, 制定的并发访问策略是利用原子类, 但是这个策略, 完全不能保证<strong>库存下限要小于库存上限</strong>这个约束条件. 所以在设计阶段, <strong>一定要识别出所有共享变量之间的约束条件, 如果约束条件识别不足, 很可能导致制定的并发访问策略南辕北辙</strong>.</p> <p><strong>共享变量之间的约束条件, 反映在代码里, 基本上都会有 if 语句, 所以一定要特别注意竞态条件</strong>.</p> <h5 id="_3-制定并发访问策略"><a href="#_3-制定并发访问策略" class="header-anchor">#</a> 3.制定并发访问策略</h5> <p>制定并发访问策略, 是一个非常复杂的事情. 应该说整个专栏都是在尝试搞定它. 不过从方案上来看, 无外乎就是以下 &quot;三件事&quot;.</p> <ol><li><strong>避免共享</strong>: 避免共享的技术主要是利用<strong>线程本地存储以及为每个任务分配独立的线程</strong>.</li> <li><strong>不变模式</strong>: 这个在 Java 领域应用的很少, 但在其他领域却有着广泛的应用, 例如 Actor 模式, CSP 模式以及函数式编程的基础都是不变模式.</li> <li><strong>管程及其他同步工具</strong>: Java 领域万能的解决方案是管程, 但是对于很多特定场景, 使用 Java 并发包提供的读写锁, 并发容器等同步工具会更好.</li></ol> <p>接下来第二模块会仔细讲解 Java 并发工具类以及他们的应用场景, 在第三模块还会讲解并发编程的设计模式, 这些都是和制定并发访问策略有关的.</p> <p>除了这些方案之外, 还有一些宏观的原则需要你了解. 这些宏观原则, 有助于写出 &quot;健壮&quot; 的并发程序. 这些原则主要有以下三条.</p> <ol><li><strong>优先使用成熟的工具类</strong>: Java SDK 并发包里提供了丰富的工具类, 基本上能满足日常的需要, 建议熟悉它们, 用好它们, 而不是自己再&quot;发明轮子&quot;, 毕竟并发工具类不是随随便便就能发明成功的.</li> <li><strong>迫不得已时才使用低级的同步原语</strong>: 低级的同步原语主要指的是 synchronized, Lock, Semaphore 等, 这些虽然感觉简单, 但实际上并没那么简单, 一定要小心使用.</li> <li><strong>避免过早优化</strong>: 安全第一, 并发程序首先要保证安全, 出现性能瓶颈后再优化. 在设计期和开发期, 很多人经常会情不自禁地预估性能的瓶颈, 并对此实施优化, 但残酷的现实却是: 性能瓶颈不是想预估就能预估的.</li></ol> <h4 id="_13-理论基础模块总结"><a href="#_13-理论基础模块总结" class="header-anchor">#</a> 13-理论基础模块总结</h4> <p>到这里, 专栏的第一模块-并发编程的理论基础已经讲解完了, 总共 12 篇,但 &quot;跳出来, 看全景&quot; 你会发现这 12 篇的内容基本上是一个&quot;串行的故事&quot;. 所以, 在学习过程中, 建议你从一个个单一的知识和技术中&quot;跳出来&quot;, 看全局, 搭建自己的并发编程知识体系.</p> <p><strong>那这个&quot;串行的故事&quot;是怎样的呢?</strong></p> <p>起源是一个硬件的核心矛盾: <strong>CPU 与内存, I/O 的速度差异, 系统软件(操作系统, 编译器)在解决这个核心矛盾的同时, 引入了可见性, 原子性和有序性问题, 这三个问题就是很多并发程序的 Bug 之源</strong>.</p> <p>那如何解决这三个问题呢? Java 语言自然有招儿, <strong>它提供了 Java 内存模型和互斥锁方案</strong>. 所以介绍了 Java 内存模型, 以应对可见性和有序性问题; 那另一个原子性问题该如何解决? 多方考量用好互斥锁才是关键.</p> <p>虽说互斥锁是解决并发问题的核心工具, 但它也可能会带来死锁问题, 所以介绍了死锁的产生原因以及解决方案; 同时还引出一个线程间协作的问题, 介绍了线程间的协作机制: 等待-通知.</p> <p>前面的部分更多地是站在微观的角度看待并发问题. 而后面则是换一个角度, 站在宏观的角度重新审视并发编程相关的概念和理论, 同时也是对前六篇文章的查漏补缺.</p> <p><strong>管程</strong>是 Java 并发编程技术的基础, 是解决并发问题的万能钥匙. 并发编程里两大核心问题-互斥和同步, 都是可以由管程来解决的. 所以学好管程, 就相当于掌握了一把并发编程的万能钥匙. 至此, 并发编程相关的问题, 理论上你都应该能找到问题所在, 并能给出理论上的解决方案了. 而后又介绍了<strong>线程相关的知识</strong>, 毕竟 Java 并发编程是要靠多线程来实现的, 所以有针对性地学习这部分知识也是很有必要的, 包括线程的生命周期, 如何计算合适的线程数以及线程内部是如何执行的.</p> <p>最后介绍了如何用面向对象思想写好并发程序, 因为在 Java 语言里, 面向对象思想能够让并发编程变得更简单.</p> <p><img src="/img/52e8424fdd7335dd01bfedc7294c7e8b-20230731162452-7pkca5x.png" alt=""></p> <p>经过这样一个简要的总结, 相信你此时对于并发编程相关的概念, 理论, 产生的背景以及它们背后的关系已经都有了一个相对全面的认识. 至于更深刻的认识和应用体验, 还是需要你 &quot;钻进去, 看本质&quot;, 加深对技术本身的认识, 拓展知识深度和广度.</p> <p>另外, 在每篇文章的最后, 我都附上了一个思考题, 这些思考题虽然大部分都很简单, 但是隐藏的问题却很容易让人忽略, 从而不经意间就引发了 Bug; 再加上留言区的一些热门评论, 所以我想着<strong>将这些隐藏的问题或者易混淆的问题, 做一个总结也是很有必要的</strong>.</p> <h3 id="并发工具类"><a href="#并发工具类" class="header-anchor">#</a> 并发工具类</h3> <h4 id="_14-lock和condition-上-隐藏在并发包中的管程"><a href="#_14-lock和condition-上-隐藏在并发包中的管程" class="header-anchor">#</a> 14-Lock和Condition(上)-隐藏在并发包中的管程</h4> <p>Java SDK 并发包内容很丰富, 包罗万象, 但是我觉得最核心的还是其<strong>对管程的实现</strong>. 因为理论上利用管程, 几乎可以实现并发包里所有的工具类. 前面提到过在并发编程领域, 有两大核心问题: 一个是<mark><strong>互斥</strong></mark>, 即同一时刻只允许一个线程访问共享资源; 另一个是<mark><strong>同步</strong></mark>, 即线程之间如何通信, 协作. 这两大问题, 管程都是能够解决的. <mark><strong>Java SDK 并发包通过 Lock 和 Condition 两个接口来实现管程, 其中 Lock 用于解决互斥问题, Condition 用于解决同步问题</strong></mark>.</p> <p>今天重点介绍 Lock 的使用, 在介绍 Lock 的使用之前, 有个问题需要首先思考一下: <strong>Java 语言本身提供的 synchronized 也是管程的一种实现, 既然 Java 从语言层面已经实现了管程了, 那为什么还要在 SDK 里提供另外一种实现呢</strong>? 难道 Java 标准委员会还能同意 &quot;重复造轮子&quot; 的方案? 很显然它们之间是有巨大区别的. 那区别在哪里呢? 如果能深入理解这个问题, 对你用好 Lock 帮助很大. 下面就一起来剖析一下这个问题.</p> <h5 id="再造管程的理由"><a href="#再造管程的理由" class="header-anchor">#</a> 再造管程的理由</h5> <p>你也许曾经听到过很多这方面的传说, 例如在 Java 的 1.5 版本中, synchronized 性能不如 SDK 里面的 Lock, 但 1.6 版本之后, synchronized 做了很多优化, 将性能追了上来, 所以 1.6 之后的版本又有人推荐使用 synchronized 了. 那性能是否可以成为 &quot;重复造轮子&quot; 的理由呢? 显然不能. 因为性能问题优化一下就可以了, 完全没必要 &quot;重复造轮子&quot;.</p> <p>到这里, 关于这个问题, 你是否能够想出一条理由来呢? 如果你细心的话, 也许能想到一点. 那就是前面在介绍死锁的时候, 提出了一个<strong>破坏不可抢占条件</strong>方案, 但是这个方案 synchronized 没有办法解决. 原因是 synchronized 申请资源的时候, 如果申请不到, 线程直接进入阻塞状态了, 而线程进入阻塞状态, 啥都干不了, 也释放不了线程已经占有的资源. 但一般希望的是:</p> <blockquote><p>对于 &quot;不可抢占&quot; 这个条件, 占用部分资源的线程进一步申请其他资源时, 如果申请不到, 可以主动释放它占有的资源, 这样不可抢占这个条件就破坏掉了.</p></blockquote> <p>如果重新设计一把互斥锁去解决这个问题, 那该怎么设计呢? 我觉得有三种方案.</p> <ol><li><mark><strong>能够响应中断</strong></mark>. synchronized 的问题是, 持有锁 A 后, 如果尝试获取锁 B 失败, 那么线程就进入阻塞状态, 一旦发生死锁, 就没有任何机会来唤醒阻塞的线程. 但如果<strong>阻塞状态的线程能够响应中断信号, 也就是说当给阻塞的线程发送中断信号的时候, 能够唤醒它, 那它就有机会释放曾经持有的锁 A</strong>. 这样就破坏了不可抢占条件了.</li> <li><mark><strong>支持超时</strong></mark>. 如果线程在一段时间之内没有获取到锁, 不是进入阻塞状态, 而是<strong>返回一个错误</strong>, 那这个线程也有机会释放曾经持有的锁. 这样也能破坏不可抢占条件.</li> <li><mark><strong>非阻塞地获取锁</strong></mark>. 如果尝试获取锁失败, 并不进入阻塞状态, 而是<strong>直接返回</strong>, 那这个线程也有机会释放曾经持有的锁. 这样也能破坏不可抢占条件.</li></ol> <p>这三种方案可以全面弥补 synchronized 的问题. 到这里相信你应该也能理解了, 这三个方案就是 &quot;重复造轮子&quot; 的主要原因, 体现在 API 上, <strong>就是 Lock 接口的三个方法</strong>. 详情如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 支持中断的 API</span>
<span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
<span class="token comment">// 支持超时的 API</span>
<span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
<span class="token comment">// 支持非阻塞获取锁的 API</span>
<span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h5 id="如何保证可见性"><a href="#如何保证可见性" class="header-anchor">#</a> 如何保证可见性</h5> <p>Java SDK 里面 Lock 的使用, 有一个经典的范例, 就是 <code>try{} finally{}</code>​, 需要重点关注的是在 finally 里面释放锁. 这个范例无需多解释, 看一下下面的代码就明白了. 但是有一点需要解释一下, 那就是<strong>可见性是怎么保证</strong>的. Java 里多线程的可见性是通过 Happens-Before 规则保证的, 而 synchronized 之所以能够保证可见性, 也是因为有一条 synchronized 相关的规则: synchronized 的解锁 Happens-Before 于后续对这个锁的加锁. <strong>那 Java SDK 里面 Lock 靠什么保证可见性呢</strong>? 例如在下面的代码中, 线程 T1 对 value 进行了 <code>+=1</code>​ 操作, 那后续的线程 T2 能够看到 value 的正确结果吗?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> rtl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取锁</span>
        rtl<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            value <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token comment">// 保证锁能释放</span>
            rtl<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>答案必须是肯定的. <strong>Java SDK 里面锁</strong>的实现非常复杂, 这里就不展开细说了, 但是原理还是需要简单介绍一下: 它是<mark><strong>利用了 volatile 相关的 Happens-Before 规则</strong></mark>. Java SDK 里面的 <strong>ReentrantLock, 内部持有一个 volatile 的成员变量 state, 获取锁的时候, 会读写 state 的值; 解锁的时候, 也会读写 state 的值(简化后的代码如下面所示)</strong> . 也就是说, 在执行 <code>value+=1</code>​ 之前, 程序先读写了一次 volatile 变量 state, 在执行 <code>value+=1</code>​ 之后, 又读写了一次 volatile 变量 state. 根据相关的 Happens-Before 规则:</p> <ol><li><strong>顺序性规则</strong>: 对于线程 T1, <code>value+=1</code>​ Happens-Before 释放锁的操作 unlock();</li> <li><strong>volatile 变量规则</strong>: 由于 state = 1 会先读取 state, 所以线程 T1 的 unlock() 操作 Happens-Before 线程 T2 的 lock() 操作;</li> <li><strong>传递性规则</strong>: 线程 T1 的 <code>value+=1</code>​ Happens-Before 线程 T2 的 lock() 操作.</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">SampleLock</span> <span class="token punctuation">{</span>
    <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span>

    <span class="token comment">// 加锁</span>
    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 省略代码无数</span>
        state <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 解锁</span>
    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 省略代码无数</span>
        state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>所以说后续线程 T2 能够看到 value 的正确结果. 如果你觉得理解起来还有点困难, 建议重温一下前面讲过的相关内容.</p> <h5 id="什么是可重入锁"><a href="#什么是可重入锁" class="header-anchor">#</a> 什么是可重入锁</h5> <p>如果你细心观察, 会发现创建的锁的具体类名是 ReentrantLock, 这个翻译过来叫<strong>可重入锁</strong>, 这个概念前面一直没有介绍过. <strong>所谓可重入锁, 顾名思义, 指的是线程可以重复获取同一把锁</strong>. 例如下面代码中, 当线程 T1 执行到 ① 处时, 已经获取到了锁 rtl , 当在 ① 处调用 get() 方法时, 会在 ② 再次对锁 rtl 执行加锁操作. 此时, 如果锁 rtl 是<strong>可重入</strong>的, 那么线程 T1 可以再次加锁成功; 如果锁 rtl 是不可重入的, 那么线程 T1 此时<strong>会被阻塞</strong>.</p> <p>除了可重入锁, 可能你还听说过可重入函数, 可重入函数怎么理解呢? 指的是线程可以重复调用? 显然不是, 所谓<strong>可重入函数, 指的是多个线程可以同时调用该函数</strong>, 每个线程都能得到正确结果; 同时在一个线程内支持线程切换, 无论被切换多少次, 结果都是正确的. 多线程可以同时执行, 还支持线程切换, 这意味着什么呢? 线程安全啊. 所以, <strong>可重入函数是线程安全的</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> rtl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取锁</span>
        rtl<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// ②</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token comment">// 保证锁能释放</span>
            rtl<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取锁</span>
        rtl<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            value <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ①</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token comment">// 保证锁能释放</span>
            rtl<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h5 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="header-anchor">#</a> 公平锁与非公平锁</h5> <p>在使用 ReentrantLock 的时候, 你会发现 ReentrantLock 这个类<strong>有两个构造函数</strong>, 一个是无参构造函数, 一个是传入 fair 参数的构造函数. <strong>fair 参数代表的是锁的公平策略, 如果传入 true 就表示需要构造一个公平锁, 反之则表示要构造一个非公平锁</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 无参构造函数: 默认非公平锁</span>
<span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 根据公平策略参数创建锁</span>
<span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span><span class="token punctuation">{</span>
    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在前面介绍过入口等待队列, 锁都对应着一个等待队列, 如果一个线程没有获得锁, 就会进入等待队列, 当有线程释放锁的时候, 就需要从等待队列中唤醒一个等待的线程. <strong>如果是公平锁, 唤醒的策略就是谁等待的时间长, 就唤醒谁, 很公平; 如果是非公平锁, 则不提供这个公平保证, 有可能等待时间短的线程反而先被唤醒</strong>.</p> <h5 id="用锁的最佳实践"><a href="#用锁的最佳实践" class="header-anchor">#</a> 用锁的最佳实践</h5> <p>你已经知道, 用锁虽然能解决很多并发问题, 但是风险也是挺高的. 可能会导致死锁, 也可能影响性能. 这方面有是否有相关的最佳实践呢? 有, 还很多. 但我觉得最值得推荐的是并发大师 Doug Lea《Java 并发编程: 设计原则与模式》一书中, 推荐的三个用锁的最佳实践, 它们分别是:</p> <blockquote><ol><li>永远只在更新对象的成员变量时加锁</li> <li>永远只在访问可变的成员变量时加锁</li> <li>永远不在调用其他对象的方法时加锁</li></ol></blockquote> <p>这三条规则, 前两条估计你一定会认同, 最后一条你可能会觉得过于严苛. 但是还是倾向于去遵守, <strong>因为调用其他对象的方法, 实在是太不安全了, 也许&quot;其他&quot;方法里面有线程 sleep() 的调用, 也可能会有奇慢无比的 I/O 操作, 这些都会严重影响性能</strong>. 更可怕的是, &quot;其他&quot; 类的方法可能也会加锁, 然后双重加锁就可能导致死锁.</p> <p>并发问题, 本来就难以诊断, 所以一定要让代码尽量安全, 尽量简单, 哪怕有一点可能会出问题, 都要努力避免.</p> <h4 id="_15-lock和condition-下-dubbo如何用管程实现异步转同步"><a href="#_15-lock和condition-下-dubbo如何用管程实现异步转同步" class="header-anchor">#</a> 15-Lock和Condition(下):Dubbo如何用管程实现异步转同步?</h4> <p>在上一节讲到 Java SDK 并发包里的 Lock 有别于 synchronized 隐式锁的三个特性: <mark><strong>能够响应中断, 支持超时和非阻塞地获取锁</strong></mark>. 那今天接着再来聊聊 Java SDK 并发包里的 Condition, <mark><strong>Condition 实现了管程模型里面的条件变量</strong></mark>.</p> <p>前面提到过 <strong>Java 语言内置的管程里只有一个条件变量, 而 Lock&amp;Condition 实现的管程是支持多个条件变量的, 这是二者的一个重要区别</strong>.</p> <p>在很多并发场景下, 支持多个条件变量能够让并发程序可读性更好, 实现起来也更容易. 例如, 实现一个阻塞队列, 就需要两个条件变量.</p> <p>**那如何利用两个条件变量快速实现阻塞队列呢? **</p> <p>一个阻塞队列, 需要两个条件变量, 一个是<strong>队列不空</strong>(空队列不允许出队), 另一个是<strong>队列不满</strong>(队列已满不允许入队), 这个例子前面详细说过, 这里就不再赘述. 相关的代码, 这里重新列了出来, 可以温故知新一下.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlockedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 条件变量: 队列不满  </span>
    <span class="token keyword">final</span> <span class="token class-name">Condition</span> notFull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 条件变量: 队列不空  </span>
    <span class="token keyword">final</span> <span class="token class-name">Condition</span> notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 入队</span>
    <span class="token keyword">void</span> <span class="token function">enq</span><span class="token punctuation">(</span><span class="token class-name">T</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>队列已满<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 等待队列不满</span>
                notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 省略入队操作...</span>
            <span class="token comment">// 入队后, 通知可出队</span>
            notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 出队</span>
    <span class="token keyword">void</span> <span class="token function">deq</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>队列已空<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 等待队列不空</span>
                notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 省略出队操作...</span>
            <span class="token comment">// 出队后, 通知可入队</span>
            notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><p>不过, 这里需要注意, Lock 和 Condition 实现的管程, <strong>线程等待和通知需要调用 await(), signal(), signalAll()</strong> , 它们的语义和 wait(), notify(), notifyAll() 是相同的. 但是不一样的是, <strong>Lock&amp;Condition 实现的管程里只能使用前面的 await(), signal(), signalAll()</strong> , 而后面的 wait(), notify(), notifyAll() 只有在 synchronized 实现的管程里才能使用. 如果一不小心在 Lock&amp;Condition 实现的管程里调用了 wait(), notify(), notifyAll(), 那程序可就彻底玩儿完了.</p> <p>Java SDK <strong>并发包里的 Lock 和 Condition 不过就是管程的一种实现</strong>而已, 管程你已经很熟悉了, 那 Lock 和 Condition 的使用自然是小菜一碟. 下面就来看看在知名项目 Dubbo 中, Lock 和 Condition 是怎么用的. 不过在开始介绍源码之前, 还先要介绍两个概念: 同步和异步.</p> <h5 id="同步与异步"><a href="#同步与异步" class="header-anchor">#</a> 同步与异步</h5> <p>最近几年, 异步编程大火. 那同步和异步的区别到底是什么呢? <strong>通俗点来讲就是调用方是否需要等待结果, 如果需要等待结果, 就是同步; 如果不需要等待结果, 就是异步</strong>.</p> <p>比如在下面的代码里, 有一个计算圆周率小数点后 100 万位的方法 <code>pai1M()</code>​, 这个方法可能需要执行俩礼拜, 如果调用 <code>pai1M()</code>​ 之后, 线程一直等着计算结果, 等俩礼拜之后结果返回, 就可以执行 <code>printf(&quot;hello world&quot;)</code>​ 了, 这个属于同步; 如果调用 <code>pai1M()</code>​ 之后, 线程不用等待计算结果, 立刻就可以执行 <code>printf(&quot;hello world&quot;)</code>​, 这个就属于异步.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 计算圆周率小说点后 100 万位 </span>
<span class="token class-name">String</span> <span class="token function">pai1M</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略代码无数</span>
<span class="token punctuation">}</span>
 
<span class="token function">pai1M</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>同步, 是 Java 代码默认的处理方式. 如果想让程序支持异步, 可以通过下面两种方式来实现:</p> <ol><li>调用方创建一个子线程, 在子线程中执行方法调用, 这种调用称为异步调用;</li> <li>方法实现的时候, 创建一个新的线程执行主要逻辑, 主线程直接 return, 这种方法一般称为异步方法.</li></ol> <h5 id="dubbo源码分析"><a href="#dubbo源码分析" class="header-anchor">#</a> Dubbo源码分析</h5> <p>其实在编程领域, 异步的场景还是挺多的, 比如 TCP 协议本身就是异步的, 工作中经常用到的 RPC 调用, <strong>在 TCP 协议层面, 发送完 RPC 请求后, 线程是不会等待 RPC 的响应结果的</strong>. 可能你会觉得奇怪, 平时工作中的 RPC 调用大多数都是同步的啊? 这是怎么回事呢?</p> <p>其实很简单, 一定是有人帮你做了异步转同步的事情. 例如目前知名的 RPC 框架 <mark><strong>Dubbo 就做了异步转同步的事情</strong></mark>, 那它是怎么做的呢? 下面就来分析一下 Dubbo 的相关源码.</p> <p>对于下面一个简单的 RPC 调用, 默认情况下 sayHello() 方法, 是个同步方法, 也就是说, 执行 service.sayHello(&quot;dubbo&quot;) 的时候, 线程会停下来等结果.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">DemoService</span> service <span class="token operator">=</span> 初始化部分省略
<span class="token class-name">String</span> message <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token string">&quot;dubbo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果此时将调用线程 dump 出来的话, 会是下图这个样子, 你会发现调用线程阻塞了, 线程状态是 <strong>TIMED_WAITING</strong>. 本来发送请求是<strong>异步</strong>的, 但是调用线程却<strong>阻塞</strong>了, 说明 Dubbo 帮做了异步转同步的事情. 通过调用栈, 能看到线程是阻塞在 DefaultFuture.get() 方法上, 所以可以推断: <strong>Dubbo 异步转同步的功能应该是通过 DefaultFuture 这个类实现的</strong>.</p> <p><img src="/img/84ac9b6ddd47c2a1590dc1e001c14358-20230731162452-4ikcfct.png" alt="" title="调用栈信息"></p> <p>不过为了理清前后关系, 还是有必要分析一下调用 DefaultFuture.get() 之前发生了什么. DubboInvoker 的 108 行调用了 DefaultFuture.get(), 这一行很关键, 这里稍微修改了一下列在了下面. 这一行先调用了 request(inv, timeout) 方法, 这个方法其实就是发送 RPC 请求, 之后通过调用 get() 方法等待 RPC 返回结果.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DubboInvoker</span> <span class="token punctuation">{</span>
    <span class="token class-name">Result</span> <span class="token function">doInvoke</span><span class="token punctuation">(</span><span class="token class-name">Invocation</span> inv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 下面这行就是源码中 108 行</span>
        <span class="token comment">// 为了便于展示, 做了修改</span>
        <span class="token keyword">return</span> currentClient<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>inv<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>DefaultFuture 这个类是很关键, 这里把相关的代码精简之后, 列到了下面. 不过在看代码之前, 还是有必要重复一下需求: <strong>当 RPC 返回结果之前, 阻塞调用线程, 让调用线程等待; 当 RPC 返回结果后, 唤醒调用线程, 让调用线程重新执行</strong>. 不知道你有没有似曾相识的感觉, 这不就是经典的等待-通知机制吗? 这个时候想必你的脑海里应该能够浮现出<strong>管程</strong>的解决方案了. 再来看看 Dubbo 是怎么实现的.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 创建锁与条件变量</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> done <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 调用方通过该方法等待结果</span>
<span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            done<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">long</span> cur <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> cur <span class="token operator">-</span> start <span class="token operator">&gt;</span> timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">returnFromResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// RPC 结果是否已经返回</span>
<span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> response <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// RPC 结果返回时调用该方法   </span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doReceived</span><span class="token punctuation">(</span><span class="token class-name">Response</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        response <span class="token operator">=</span> res<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>done <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            done<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><p>调用线程通过调用 get() 方法等待 RPC 返回结果, 这个方法里面, 你看到的都是熟悉的&quot;面孔&quot;: <strong>调用 lock() 获取锁, 在 finally 里面调用 unlock() 释放锁; 获取锁后, 通过经典的在循环中调用 await() 方法来实现等待</strong>.</p> <p>当 RPC 结果返回时, 会调用 doReceived() 方法, 这个方法里面, 调用 lock() 获取锁, 在 finally 里面调用 unlock() 释放锁, 获取锁后通过调用 signal() 来通知调用线程, 结果已经返回, 不用继续等待了.</p> <p>至此, Dubbo 里面的异步转同步的源码就分析完了, 有没有觉得还挺简单的? 最近这几年, 工作中需要异步处理的越来越多了, 其中有一个主要原因就是有些 API 本身就是异步 API. 例如 websocket 也是一个异步的通信协议, 如果基于这个协议实现一个简单的 RPC, 也会遇到异步转同步的问题. 现在很多公有云的 API 本身也是异步的, 例如创建云主机, 就是一个异步的 API, 调用虽然成功了, 但是云主机并没有创建成功, 你需要调用另外一个 API 去轮询云主机的状态. 如果你需要在项目内部封装创建云主机的 API, 你也会面临异步转同步的问题, 因为同步的 API 更易用.</p> <h4 id="_16-semaphore-如何快速实现一个限流器"><a href="#_16-semaphore-如何快速实现一个限流器" class="header-anchor">#</a> 16-Semaphore:如何快速实现一个限流器?</h4> <p>Semaphore, 现在普遍翻译为&quot;信号量&quot;, 以前也曾被翻译成&quot;信号灯&quot;, 因为类似现实生活里的红绿灯, 车辆能不能通行, 要看是不是绿灯. 同样, 在编程世界里, <strong>线程能不能执行, 也要看信号量是不是允许</strong>.</p> <p>信号量是由大名鼎鼎的计算机科学家迪杰斯特拉(Dijkstra)于 1965 年提出, 在这之后的 15 年, 信号量一直都是并发编程领域的终结者, 直到 1980 年管程被提出来, 才有了第二选择. 目前几乎所有支持并发编程的语言都支持信号量机制, 所以学好信号量还是很有必要的.</p> <p>下面首先介绍信号量模型, 之后介绍如何使用信号量, 最后再用信号量来实现一个<strong>限流器</strong>.</p> <h5 id="信号量模型"><a href="#信号量模型" class="header-anchor">#</a> 信号量模型</h5> <p>信号量模型还是很简单的, 可以简单概括为: <strong>一个计数器, 一个等待队列, 三个方法</strong>. 在信号量模型里, 计数器和等待队列对外是透明的, 所以只能通过信号量模型提供的三个方法来访问它们, 这三个方法分别是: <strong>init(), down() 和 up()</strong> . 可以结合下图来形象化地理解.</p> <p><img src="/img/1ee4f4d32ec49f4158c86909d74f5d16-20230731162452-kuozkyh.png" alt="" title="信号量模型图"></p> <p>这三个方法详细的语义具体如下所示.</p> <ul><li><strong>init(): 设置计数器的初始值</strong>.</li> <li><strong>down(): 计数器的值减 1; 如果此时计数器的值小于 0, 则当前线程将被阻塞, 否则当前线程可以继续执行.</strong></li> <li><strong>up(): 计数器的值加 1; 如果此时计数器的值小于或者等于 0, 则唤醒等待队列中的一个线程, 并将其从等待队列中移除.</strong></li></ul> <p>这里提到的 init(), down() 和 up() 三个方法都是<strong>原子性</strong>的, 并且这个原子性是由信号量模型的实现方保证的. 在 Java SDK 里面, 信号量模型是由 java.util.concurrent.Semaphore 实现的, Semaphore 这个类能够保证这三个方法都是原子操作.</p> <p>如果你觉得上面的描述有点绕的话, 可以参考下面这个代码化的信号量模型.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Semaphore</span><span class="token punctuation">{</span>
    <span class="token comment">// 计数器</span>
    <span class="token keyword">int</span> count<span class="token punctuation">;</span>
    <span class="token comment">// 等待队列</span>
    <span class="token class-name">Queue</span> queue<span class="token punctuation">;</span>
    <span class="token comment">// 初始化操作</span>
    <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">=</span>c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
    <span class="token keyword">void</span> <span class="token function">down</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 将当前线程插入等待队列</span>
            <span class="token comment">// 阻塞当前线程</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 移除等待队列中的某个线程 T</span>
            <span class="token comment">// 唤醒线程 T</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>这里再插一句, 信号量模型里面, down(), up() 这两个操作历史上最早称为 P 操作和 V 操作, 所以信号量模型也被<strong>称为 PV 原语</strong>. 另外, 还有些人喜欢用 semWait() 和 semSignal() 来称呼它们, 虽然叫法不同, 但是语义都是相同的. 在 Java SDK 并发包里, <strong>down() 和 up() 对应的则是 acquire() 和 release()</strong> .</p> <h5 id="如何使用信号量"><a href="#如何使用信号量" class="header-anchor">#</a> 如何使用信号量</h5> <p>通过上文, 你应该会发现信号量的模型还是很简单的, 那具体该如何使用呢? 其实想想红绿灯就可以了. 十字路口的红绿灯可以控制交通, 得益于它的一个关键规则: <strong>车辆在通过路口前必须先检查是否是绿灯, 只有绿灯才能通行</strong>. 这个规则和前面提到的锁规则是不是很类似?</p> <p>其实, 信号量的使用也是类似的. 这里还是用累加器的例子来说明信号量的使用. 在累加器的例子里面, count+=1 操作是个临界区, 只允许一个线程执行, 也就是说要保证互斥. 那这种情况用信号量怎么控制呢?</p> <p>其实很简单, 就像用互斥锁一样, 只需要<strong>在进入临界区之前执行一下 down() 操作, 退出临界区之前执行一下 up() 操作就可以了</strong>. 下面是 Java 代码的示例, acquire() 就是信号量里的 down() 操作, release() 就是信号量里的 up() 操作.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>
<span class="token comment">// 初始化信号量</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Semaphore</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 用信号量保证互斥  </span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    s<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        count <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        s<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>下面再来分析一下, <strong>信号量是如何保证互斥</strong>的. 假设两个线程 T1 和 T2 同时访问 addOne() 方法, 当它们同时调用 acquire() 的时候, 由于 acquire() 是一个<strong>原子操作</strong>, 所以只能有一个线程(假设 T1)把信号量里的计数器减为 0, 另外一个线程(T2)则是将计数器减为 -1. 对于线程 T1, 信号量里面的计数器的值是 0, 大于等于 0, 所以线程 T1 会继续执行; 对于线程 T2, 信号量里面的计数器的值是 -1, 小于 0, 按照信号量模型里对 down() 操作的描述, 线程 T2 将被阻塞. 所以此时只有线程 T1 会进入临界区执行 <code>count+=1;</code>​.</p> <p>当线程 T1 执行 release() 操作, 也就是 up() 操作的时候, 信号量里计数器的值是 -1, 加 1 之后的值是 0, 小于等于 0, 按照信号量模型里对 up() 操作的描述, <strong>此时等待队列中的 T2 将会被唤醒</strong>. 于是 T2 在 T1 执行完临界区代码之后才获得了进入临界区执行的机会, 从而保证了互斥性.</p> <h5 id="快速实现一个限流器"><a href="#快速实现一个限流器" class="header-anchor">#</a> 快速实现一个限流器</h5> <p>上面的例子用信号量实现了一个最简单的互斥锁功能. 估计你会觉得奇怪, 既然有 Java SDK 里面提供了 Lock, 为啥还要提供一个 Semaphore ? 其实实现一个互斥锁, 仅仅是 Semaphore 的部分功能, Semaphore 还有一个功能是 Lock 不容易实现的, 那就是: <mark><strong>Semaphore 可以允许多个线程访问一个临界区</strong></mark>.</p> <p>现实中还有这种需求? 有的. 比较常见的需求就是工作中遇到的<strong>各种池化资源, 例如连接池, 对象池, 线程池</strong>等等. 其中, 你可能最熟悉数据库连接池, 在同一时刻, 一定是允许多个线程同时使用连接池的, 当然<strong>每个连接在被释放前, 是不允许其他线程使用的</strong>.</p> <p>我也遇到过一个对象池的需求. 所谓对象池, 指的是一次性创建出 N 个对象, 之后所有的线程重复利用这 N 个对象, 当然对象在被释放前, 也是不允许其他线程使用的. 对象池, 可以用 List 保存实例对象, 这个很简单. 但关键是限流器的设计, 这里的限流, 指的是<strong>不允许多于 N 个线程同时进入临界区</strong>. 那如何快速实现一个这样的限流器呢? 这种场景, 就立刻就想到了信号量的解决方案.</p> <p>信号量的计数器, 在上面的例子中设置成了 1, 这个 1 表示只允许一个线程进入临界区, <strong>但如果把计数器的值设置成对象池里对象的个数 N, 就能完美解决对象池的限流问题</strong>了. 下面就是对象池的示例代码.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">ObjPool</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> pool<span class="token punctuation">;</span>
    <span class="token comment">// 用信号量实现限流器</span>
    <span class="token keyword">final</span> <span class="token class-name">Semaphore</span> sem<span class="token punctuation">;</span>

    <span class="token comment">// 构造函数</span>
    <span class="token class-name">ObjPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>
        pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            pool<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        sem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 利用对象池的对象, 调用 func</span>
    <span class="token class-name">R</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> func<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">T</span> t <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        sem<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            t <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            pool<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            sem<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 创建对象池</span>
<span class="token class-name">ObjPool</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjPool</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 通过对象池获取 t, 之后执行  </span>
pool<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>t <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> t<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>这里用一个 List来保存对象实例, 用 Semaphore 实现限流器. 关键的代码是 ObjPool 里面的 exec() 方法, 这个方法里面<strong>实现了限流的功能</strong>. 在这个方法里面, 首先调用 acquire() 方法(与之匹配的是在 finally 里面调用 release() 方法), 假设对象池的大小是 10, 信号量的计数器初始化为 10, 那么前 10 个线程调用 acquire() 方法, 都能继续执行, 相当于通过了信号灯, 而其他线程则会阻塞在 acquire() 方法上. 对于通过信号灯的线程, 为每个线程分配了一个对象 t(这个分配工作是通过 pool.remove(0) 实现的), 分配完之后会执行一个回调函数 func, 而函数的参数正是前面分配的对象 t ; 执行完回调函数之后, 它们就会释放对象(这个释放工作是通过 pool.add(t) 实现的), 同时调用 release() 方法来更新信号量的计数器. 如果此时信号量里计数器的值小于等于 0, 那么说明有线程在等待, 此时会自动唤醒等待的线程.</p> <p>简言之, 使用信号量, 可以轻松地实现一个限流器, 使用起来还是非常简单的.</p> <h4 id="_17-readwritelock-如何快速实现一个完备的缓存"><a href="#_17-readwritelock-如何快速实现一个完备的缓存" class="header-anchor">#</a> 17-ReadWriteLock:如何快速实现一个完备的缓存?</h4> <p>前面介绍了管程和信号量这两个同步原语在 Java 语言中的实现, 理论上用这两个同步原语中任何一个都可以解决所有的并发问题. 那 Java SDK 并发包里为什么还有很多其他的工具类呢? 原因很简单: <strong>分场景优化性能, 提升易用性</strong>.</p> <p>今天就介绍一种非常普遍的并发场景: <strong>读多写少场</strong>景. 实际工作中, 为了优化性能, 经常会使用缓存, 例如缓存元数据, 缓存基础数据等, 这就是一种典型的读多写少应用场景. <strong>缓存之所以能提升性能, 一个重要的条件就是缓存的数据一定是读多写少的</strong>, 例如元数据和基础数据基本上不会发生变化(写少), 但是使用它们的地方却很多(读多).</p> <p>针对读多写少这种并发场景, Java SDK 并发包提供了读写锁--ReadWriteLock, 非常容易使用, 并且性能很好.</p> <p>**那什么是读写锁呢? **</p> <p>读写锁, 并不是 Java 语言特有的, 而是一个广为使用的通用技术, 所有的读写锁都遵守以下三条基本原则:</p> <ol><li><strong>允许多个线程同时读共享变量;</strong></li> <li><strong>只允许一个线程写共享变量;</strong></li> <li><strong>如果一个写线程正在执行写操作, 此时禁止读线程读共享变量.</strong></li></ol> <p>读写锁与互斥锁的一个重要区别就是<strong>读写锁允许多个线程同时读共享变量</strong>, 而互斥锁是不允许的, 这是读写锁在读多写少场景下性能优于互斥锁的关键. 但<strong>读写锁的写操作是互斥的</strong>, 当一个线程在写共享变量的时候, 是不允许其他线程执行写操作和读操作.</p> <h5 id="快速实现一个缓存"><a href="#快速实现一个缓存" class="header-anchor">#</a> 快速实现一个缓存</h5> <p>下面就实践起来, <strong>用 ReadWriteLock 快速实现一个通用的缓存工具类</strong>.</p> <p>在下面的代码中, 声明了一个 <code>Cache&lt;K, V&gt;</code>​ 类, 其中类型参数 K 代表缓存里 key 的类型, V 代表缓存里 value 的类型. 缓存的数据保存在 Cache 类内部的 HashMap 里面, HashMap 不是线程安全的, 这里使用读写锁 ReadWriteLock 来保证其线程安全. ReadWriteLock 是一个接口, 它的实现类是 ReentrantReadWriteLock, 通过名字就能判断出来, 它是支持可重入的. 下面通过 rwl <strong>创建了一把读锁和一把写锁</strong>.</p> <p>Cache 这个工具类, 提供了两个方法, 一个是读缓存方法 get(), 另一个是写缓存方法 put(). 读缓存需要用到读锁, 读锁的使用和前面介绍的 Lock 的使用是相同的, 都是 <code>try{} finally{}</code>​ 这个编程范式. 写缓存则需要用到写锁, 写锁的使用和读锁是类似的. 这样看来, 读写锁的使用还是非常简单的.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">ReadWriteLock</span> rwl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 读锁</span>
    <span class="token keyword">final</span> <span class="token class-name">Lock</span> r <span class="token operator">=</span> rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 写锁</span>
    <span class="token keyword">final</span> <span class="token class-name">Lock</span> w <span class="token operator">=</span> rwl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 读缓存</span>
    <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        r<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 写缓存</span>
    <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Data</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>如果你曾经使用过缓存的话, 你应该知道<strong>使用缓存首先要解决缓存数据的初始化问题</strong>. 缓存数据的初始化, 可以采用一次性加载的方式, 也可以使用按需加载的方式.</p> <p>如果源头数据的数据量不大, 就可以采用一次性加载的方式, 这种方式最简单(可参考下图), 只需在应用启动的时候把源头数据查询出来, 依次调用类似上面示例代码中的 put() 方法就可以了.</p> <p><img src="/img/77f0efad68c07a85c439da5bd5c17ead-20230731162452-xihn7xa.png" alt="" title="缓存一次性加载示意图"></p> <p>如果源头数据量非常大, 那么就需要按需加载了, 按需加载也叫<strong>懒加载</strong>, 指的是只有当应用查询缓存, 并且数据不在缓存里的时候, 才触发加载源头相关数据进缓存的操作. 下面可以结合文中示意图看看如何利用 ReadWriteLock 来实现缓存的按需加载.</p> <p><img src="/img/e73d8698d413270f0e912827a0ec11d2-20230731162452-5rxpb8q.png" alt="" title="缓存按需加载示意图"></p> <h5 id="实现缓存的按需加载"><a href="#实现缓存的按需加载" class="header-anchor">#</a> 实现缓存的按需加载</h5> <p>文中下面的这段代码实现了按需加载的功能, 这里假设缓存的源头是数据库. 需要注意的是, 如果缓存中没有缓存目标对象, 那么就需要从数据库中加载, 然后写入缓存, 写缓存需要用到写锁, 所以在代码中的 ⑤ 处调用了 <code>w.lock()</code>​ 来获取写锁.</p> <p>另外, 还需要注意的是, 在获取写锁之后, 并没有直接去查询数据库, 而是在代码 ⑥⑦ 处, <strong>重新验证了一次缓存中是否存在, 再次验证如果还是不存在, 才去查询数据库并更新本地缓存</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">ReadWriteLock</span> rwl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">Lock</span> r <span class="token operator">=</span> rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">Lock</span> w <span class="token operator">=</span> rwl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">V</span> v <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// 读缓存</span>
        r<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// ①</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            v <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ②</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ③</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 缓存中存在, 返回</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// ④</span>
            <span class="token keyword">return</span> v<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 缓存中不存在, 查询数据库</span>
        w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// ⑤</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 再次验证</span>
            <span class="token comment">// 其他线程可能已经查询过数据库</span>
            v <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ⑥</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// ⑦</span>
                <span class="token comment">// 查询数据库</span>
                v <span class="token operator">=</span> 省略代码无数
                m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> v<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p>为什么要再次验证呢? 原因是在高并发的场景下, 有可能会有多线程竞争写锁. 假设缓存是空的, 没有缓存任何东西, 如果此时有三个线程 T1, T2 和 T3 同时调用 get() 方法, 并且参数 key 也是相同的. 那么它们会同时执行到代码 ⑤ 处, 但此时只有一个线程能够获得写锁, 假设是线程 T1, 线程 T1 获取写锁之后查询数据库并更新缓存, 最终释放写锁. 此时线程 T2 和 T3 会再有一个线程能够获取写锁, 假设是 T2, 如果不采用再次验证的方式, 此时 T2 会<strong>再次</strong>查询数据库. T2 释放写锁之后, T3 也会再次查询一次数据库. 而实际上线程 T1 已经把缓存的值设置好了, T2, T3 完全没有必要再次查询数据库. 所以<strong>再次验证的方式, 能够避免高并发场景下重复查询数据的问题</strong>.</p> <h5 id="读写锁的升级与降级"><a href="#读写锁的升级与降级" class="header-anchor">#</a> 读写锁的升级与降级</h5> <p>上面按需加载的示例代码中, 在 ① 处获取读锁, 在 ③ 处释放读锁, 那是否可以在 ② 处的下面增加验证缓存并更新缓存的逻辑呢? 详细的代码如下.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 读缓存</span>
r<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// ①</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    v <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ②</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 再次验证并更新缓存</span>
            <span class="token comment">// 省略详细代码</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// ③</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>这样看上去好像是没有问题的, 先是获取读锁, 然后再升级为写锁, 对此还有个专业的名字, 叫<strong>锁的升级</strong>. 可惜 ReadWriteLock 并不支持这种升级. 在上面的代码示例中, <strong>读锁还没有释放, 此时获取写锁, 会导致写锁永久等待, 最终导致相关线程都被阻塞, 永远也没有机会被唤醒. 锁的升级是不允许的, 这个一定要注意</strong>.</p> <p>不过, 虽然锁的升级是不允许的, 但是<strong>锁的降级却是允许</strong>的. 以下代码来源自 ReentrantReadWriteLock 的官方示例, 略做了改动. 你会发现在代码 ① 处, 获取读锁的时候线程还是持有写锁的, 这种锁的降级是支持的.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">CachedData</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> data<span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> cacheValid<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">ReadWriteLock</span> rwl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 读锁  </span>
    <span class="token keyword">final</span> <span class="token class-name">Lock</span> r <span class="token operator">=</span> rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 写锁</span>
    <span class="token keyword">final</span> <span class="token class-name">Lock</span> w <span class="token operator">=</span> rwl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">processCachedData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取读锁</span>
        r<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cacheValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 释放读锁, 因为不允许读锁的升级</span>
            r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 获取写锁</span>
            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 再次检查状态  </span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cacheValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    data <span class="token operator">=</span> xxx<span class="token punctuation">;</span>
                    cacheValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 释放写锁前, 降级为读锁</span>
                <span class="token comment">// 降级是可以的</span>
                r<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ①</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                <span class="token comment">// 释放写锁</span>
                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 此处仍然持有读锁</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token function">use</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><h5 id="总结-11"><a href="#总结-11" class="header-anchor">#</a> 总结</h5> <p>读写锁类似于 ReentrantLock, 也支持公平模式和非公平模式. 读锁和写锁都实现了 java.util.concurrent.locks.Lock 接口, 所以除了支持 lock() 方法外, tryLock(), lockInterruptibly() 等方法也都是支持的. 但是有一点需要注意, 那就是<strong>只有写锁支持条件变量, 读锁是不支持条件变量的</strong>, 读锁调用 newCondition() 会抛出 UnsupportedOperationException 异常.</p> <p>今天用 ReadWriteLock 实现了一个简单的缓存, 这个缓存虽然解决了缓存的初始化问题, 但是没有解决缓存数据与源头数据的同步问题, 这里的数据同步指的是保证缓存数据和源头数据的一致性. 解决数据同步问题的一个最简单的方案就是<strong>超时机制</strong>. 所谓超时机制指的是加载进缓存的数据不是长久有效的, 而是有时效的, 当缓存的数据超过时效, 也就是超时之后, 这条数据在缓存中就失效了. 而访问缓存中失效的数据, 会触发缓存重新从源头把数据加载进缓存.</p> <p>当然也可以在源头数据发生变化时, 快速反馈给缓存, 但这个就要依赖具体的场景了. 例如 MySQL 作为数据源头, 可以通过近实时地解析 binlog 来识别数据是否发生了变化, 如果发生了变化就将最新的数据推送给缓存. 另外, 还有一些方案采取的是数据库和缓存的双写方案.</p> <h4 id="_18-stampedlock-有没有比读写锁更快的锁"><a href="#_18-stampedlock-有没有比读写锁更快的锁" class="header-anchor">#</a> 18-StampedLock:有没有比读写锁更快的锁?</h4> <p>上一节介绍了读写锁, 学习完之后你应该已经知道 &quot;读写锁允许多个线程同时读共享变量, 适用于读多写少的场景&quot;. 那<strong>在读多写少的场景中, 还有没有更快的技术方案</strong>呢? 还真有, Java 在 1.8 这个版本里, 提供了一种叫 <strong>StampedLock</strong> 的锁, 它的性能就比读写锁还要好.</p> <p>下面就来介绍一下 StampedLock 的使用方法, 内部工作原理以及在使用过程中需要注意的事项.</p> <h5 id="stampedlock支持的三种锁模式"><a href="#stampedlock支持的三种锁模式" class="header-anchor">#</a> StampedLock支持的三种锁模式</h5> <p>先来看看在使用上 StampedLock 和上一节讲的 ReadWriteLock 有哪些区别.</p> <p>ReadWriteLock 支持两种模式: 一种是读锁, 一种是写锁. 而 StampedLock 支持三种模式, 分别是: <mark><strong>写锁</strong></mark>​<mark>,</mark> <mark><strong>悲观读锁</strong></mark>​<mark>和</mark>​<mark><strong>乐观读</strong></mark>. 其中, 写锁, 悲观读锁的语义和 ReadWriteLock 的写锁, 读锁的语义非常类似, <strong>允许多个线程同时获取悲观读锁, 但是只允许一个线程获取写锁, 写锁和悲观读锁是互斥的</strong>. 不同的是: <strong>StampedLock 里的写锁和悲观读锁加锁成功之后, 都会返回一个 stamp; 然后解锁的时候, 需要传入这个 stamp</strong>. 相关的示例代码如下.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">StampedLock</span> sl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StampedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取/释放悲观读锁示意代码</span>
<span class="token keyword">long</span> stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略业务相关代码</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    sl<span class="token punctuation">.</span><span class="token function">unlockRead</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取 / 释放写锁示意代码</span>
<span class="token keyword">long</span> stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略业务相关代码</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    sl<span class="token punctuation">.</span><span class="token function">unlockWrite</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>StampedLock 的性能之所以比 ReadWriteLock 还要好, 其关键是 StampedLock <strong>支持乐观读</strong>的方式. <strong>ReadWriteLock 支持多个线程同时读, 但是当多个线程同时读的时候, 所有的写操作会被阻塞; 而 StampedLock 提供的乐观读, 是允许一个线程获取写锁的, 也就是说不是所有的写操作都被阻塞</strong>.</p> <p>注意这里用的是 &quot;乐观读&quot; 这个词, 而不是 &quot;乐观读锁&quot;, 是要提醒你, <strong>乐观读这个操作是无锁的</strong>, 所以相比较 ReadWriteLock 的读锁, 乐观读的性能更好一些.</p> <p>文中下面这段代码是出自 Java SDK 官方示例, 并略做了修改. 在 distanceFromOrigin() 这个方法中, 首先通过调用 tryOptimisticRead() 获取了一个 stamp, 这里的 tryOptimisticRead() 就是前面提到的乐观读. 之后将共享变量 x 和 y 读入方法的局部变量中, 不过需要注意的是, 由于 tryOptimisticRead() 是无锁的, 所以共享变量 x 和 y 读入方法局部变量时, x 和 y 有可能被其他线程修改了. 因此最后读完之后, 还需要再次验证一下是否存在写操作, 这个验证操作是通过调用 validate(stamp) 来实现的.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">StampedLock</span> sl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StampedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 计算到原点的距离  </span>
    <span class="token keyword">int</span> <span class="token function">distanceFromOrigin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 乐观读</span>
        <span class="token keyword">long</span> stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">tryOptimisticRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 读入局部变量, </span>
        <span class="token comment">// 读的过程数据可能被修改</span>
        <span class="token keyword">int</span> curX <span class="token operator">=</span> x<span class="token punctuation">,</span> curY <span class="token operator">=</span> y<span class="token punctuation">;</span>
        <span class="token comment">// 判断执行读操作期间, </span>
        <span class="token comment">// 是否存在写操作, 如果存在, </span>
        <span class="token comment">// 则 sl.validate 返回 false</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sl<span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 升级为悲观读锁</span>
            stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                curX <span class="token operator">=</span> x<span class="token punctuation">;</span>
                curY <span class="token operator">=</span> y<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                <span class="token comment">// 释放悲观读锁</span>
                sl<span class="token punctuation">.</span><span class="token function">unlockRead</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>curX <span class="token operator">*</span> curX <span class="token operator">+</span> curY <span class="token operator">*</span> curY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>在上面这个代码示例中, <strong>如果执行乐观读操作的期间, 存在写操作, 会把乐观读升级为悲观读锁</strong>. 这个做法挺合理的, 否则就需要在一个循环里反复执行乐观读, 直到执行乐观读操作的期间没有写操作(只有这样才能保证 x 和 y 的正确性和一致性), 而循环读会浪费大量的 CPU. 升级为悲观读锁, 代码简练且不易出错, 建议你在具体实践时也采用这样的方法.</p> <h5 id="进一步理解乐观读"><a href="#进一步理解乐观读" class="header-anchor">#</a> 进一步理解乐观读</h5> <p>如果你曾经用过数据库的乐观锁, 可能会发现 StampedLock 的乐观读和数据库的乐观锁有异曲同工之妙. 的确是这样的, 就拿我个人来说, 我是先接触的数据库里的乐观锁, 然后才接触的 StampedLock, 我就觉得我前期数据库里乐观锁的学习对于后面理解 StampedLock 的乐观读有很大帮助, 所以这里有必要再介绍一下数据库里的乐观锁.</p> <p>还记得我第一次使用数据库乐观锁的场景是这样的: 在 ERP 的生产模块里, 会有多个人通过 ERP 系统提供的 UI 同时修改同一条生产订单, 那如何保证生产订单数据是并发安全的呢? 我采用的方案就是乐观锁.</p> <p>乐观锁的实现很简单, 在生产订单的表 product_doc 里增加了一个数值型版本号字段 version, 每次更新 product_doc 这个表的时候, 都将 version 字段加 1. 生产订单的 UI 在展示的时候, 需要查询数据库, 此时将这个 version 字段和其他业务字段一起返回给生产订单 UI. 假设用户查询的生产订单的 id=777, 那么 SQL 语句类似下面这样:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>select id<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">,</span> versionfrom product_docwhere id<span class="token operator">=</span><span class="token number">777</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>用户在生产订单 UI 执行保存操作的时候, 后台利用下面的 SQL 语句更新生产订单, 此处假设该条生产订单的 version=9.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>update product_doc set version<span class="token operator">=</span>version<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>where id<span class="token operator">=</span><span class="token number">777</span> and version<span class="token operator">=</span><span class="token number">9</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果这条 SQL 语句执行成功并且返回的条数等于 1, 那么说明从生产订单 UI 执行查询操作到执行保存操作期间, 没有其他人修改过这条数据. 因为如果这期间其他人修改过这条数据, <strong>那么版本号字段一定会大于 9</strong>.</p> <p>你会发现<strong>数据库里的乐观锁, 查询的时候需要把 version 字段查出来, 更新的时候要利用 version 字段做验证. 这个 version 字段就类似于 StampedLock 里面的 stamp</strong>. 这样对比着看会更容易理解 StampedLock 里乐观读的用法.</p> <h5 id="stampedlock使用注意事项"><a href="#stampedlock使用注意事项" class="header-anchor">#</a> StampedLock使用注意事项</h5> <p>对于读多写少的场景 StampedLock 性能很好, 简单的应用场景基本上可以替代 ReadWriteLock, 但是<strong>StampedLock 的功能仅仅是 ReadWriteLock 的子集</strong>, 在使用的时候, 还是有几个地方需要注意一下.</p> <p>StampedLock 在命名上并没有增加 Reentrant, 想必你已经猜测到 StampedLock 应该是不可重入的. 事实上, 的确是这样的, <mark><strong>StampedLock 不支持重入</strong></mark>. 这个是在使用中必须要特别注意的.</p> <p>另外, StampedLock 的<strong>悲观读锁, 写锁都不支持条件变量</strong>, 这个也需要注意.</p> <p>还有一点需要特别注意, 那就是: <strong>如果线程阻塞在 StampedLock 的 readLock() 或者 writeLock() 上时, 此时调用该阻塞线程的 interrupt() 方法, 会导致 CPU 飙升</strong>. 例如下面的代码中, 线程 T1 获取写锁之后将自己阻塞, 线程 T2 尝试获取悲观读锁, 也会阻塞; 如果此时调用线程 T2 的 interrupt() 方法来中断线程 T2 的话, 你会发现线程 T2 所在 CPU 会飙升到 100%.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">StampedLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StampedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Thread</span> <span class="token constant">T1</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取写锁</span>
    lock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 永远阻塞在此处, 不释放写锁</span>
    <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token constant">T1</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 保证 T1 获取写锁</span>
<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Thread</span> <span class="token constant">T2</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
        <span class="token comment">// 阻塞在悲观读锁</span>
        lock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token constant">T2</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 保证 T2 阻塞在读锁</span>
<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 中断线程 T2</span>
<span class="token comment">// 会导致线程 T2 所在 CPU 飙升</span>
<span class="token constant">T2</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token constant">T2</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>所以, <strong>使用 StampedLock 一定不要调用中断操作, 如果需要支持中断功能, 一定使用可中断的悲观读锁 readLockInterruptibly() 和写锁 writeLockInterruptibly()</strong> . 这个规则一定要记清楚.</p> <h5 id="总结-12"><a href="#总结-12" class="header-anchor">#</a> 总结</h5> <p>StampedLock 的使用看上去有点复杂, 但是如果能理解乐观锁背后的原理, 使用起来还是比较流畅的. 建议认真揣摩 Java 的官方示例, 这个示例基本上就是一个最佳实践. 把 Java 官方示例精简后, 形成下面的代码模板, 建议在实际工作中尽量按照这个模板来使用 StampedLock.</p> <p>StampedLock 读模板:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">StampedLock</span> sl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StampedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 乐观读</span>
<span class="token keyword">long</span> stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">tryOptimisticRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 读入方法局部变量</span>
<span class="token comment">// ......</span>
<span class="token comment">// 校验 stamp</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sl<span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 升级为悲观读锁</span>
    stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 读入方法局部变量</span>
        <span class="token comment">// .....</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 释放悲观读锁</span>
        sl<span class="token punctuation">.</span><span class="token function">unlockRead</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用方法局部变量执行业务操作</span>
<span class="token comment">// ......</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>StampedLock 写模板:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">long</span> stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 写共享变量</span>
    <span class="token comment">// ......</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    sl<span class="token punctuation">.</span><span class="token function">unlockWrite</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="_19-countdownlatch和cyclicbarrier-如何让多线程步调一致"><a href="#_19-countdownlatch和cyclicbarrier-如何让多线程步调一致" class="header-anchor">#</a> 19-CountDownLatch和CyclicBarrier:如何让多线程步调一致?</h4> <p>前几天老板突然匆匆忙忙过来, 说对账系统最近越来越慢了, 能不能快速优化一下. 我了解了对账系统的业务后, 发现还是挺简单的, 用户通过在线商城下单, 会生成电子订单, 保存在订单库; 之后物流会生成派送单给用户发货, 派送单保存在派送单库. 为了防止漏派送或者重复派送, 对账系统每天还会校验是否存在异常订单.</p> <p>对账系统的处理逻辑很简单, 可以参考下面的对账系统流程图. 目前对账系统的处理逻辑是<strong>首先查询订单, 然后查询派送单, 之后对比订单和派送单, 将差异写入差异库</strong>.</p> <p><img src="/img/6538041abca11f8ead4f8475614791f4-20230731162452-gsvk9gj.png" alt="" title="对账系统流程图"></p> <p>对账系统的代码抽象之后, 也很简单, 核心代码如下, 就是在一个单线程里面循环查询订单, 派送单, 然后执行对账, 最后将写入差异库.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">while</span><span class="token punctuation">(</span>存在未对账订单<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 查询未对账订单</span>
    pos <span class="token operator">=</span> <span class="token function">getPOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 查询派送单</span>
    dos <span class="token operator">=</span> <span class="token function">getDOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 执行对账操作</span>
    diff <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> dos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 差异写入差异库</span>
    <span class="token function">save</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h5 id="利用并行优化对账系统"><a href="#利用并行优化对账系统" class="header-anchor">#</a> 利用并行优化对账系统</h5> <p>老板要我优化性能, 那就首先要找到这个对账系统的瓶颈所在.</p> <p>目前的对账系统, 由于订单量和派送单量巨大, 所以查询未对账订单 getPOrders() 和查询派送单 getDOrders() 相对较慢, 那有没有办法快速优化一下呢? 目前对账系统是单线程执行的, 图形化后是下图这个样子. 对于串行化的系统, 优化性能首先想到的是能否<strong>利用多线程并行处理</strong>.</p> <p><img src="/img/88db20105d226f1ebac4dab19c5a412c-20230731162452-ku1jn1c.png" alt="" title="对账系统单线程执行示意图"></p> <p>所以, 这里应该能够看出来这个对账系统里的瓶颈: 查询未对账订单 getPOrders() 和查询派送单 getDOrders() 是否可以并行处理呢? 显然是可以的, 因为<strong>这两个操作并没有先后顺序的依赖</strong>. 这两个最耗时的操作并行之后, 执行过程如下图所示. 对比一下单线程的执行示意图, 你会发现同等时间里, 并行执行的吞吐量近乎单线程的 2 倍, 优化效果还是相对明显的.</p> <p><img src="/img/d7ed4c233ea2025c83d6ba85189846b4-20230731162452-c9k7ie5.png" alt="" title="对账系统并行执行示意图"></p> <p>思路有了, 下面再来看看如何用代码实现. 在下面的代码中, 创建了两个线程 T1 和 T2, 并行执行查询未对账订单 getPOrders() 和查询派送单 getDOrders() 这两个操作. 在主线程中执行对账操作 check() 和差异写入 save() 两个操作. 不过需要注意的是: <strong>主线程需要等待线程 T1 和 T2 执行完才能执行 check() 和 save() 这两个操作, 为此通过调用 T1.join() 和 T2.join() 来实现等待, 当 T1 和 T2 线程退出时, 调用 T1.join() 和 T2.join() 的主线程就会从阻塞态被唤醒, 从而执行之后的 check() 和 save()</strong> .</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>存在未对账订单<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 查询未对账订单</span>
    <span class="token class-name">Thread</span> <span class="token constant">T1</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        pos <span class="token operator">=</span> <span class="token function">getPOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token constant">T1</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 查询派送单</span>
    <span class="token class-name">Thread</span> <span class="token constant">T2</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        dos <span class="token operator">=</span> <span class="token function">getDOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token constant">T2</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 等待 T1, T2 结束</span>
    <span class="token constant">T1</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token constant">T2</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 执行对账操作</span>
    diff <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> dos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 差异写入差异库</span>
    <span class="token function">save</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h5 id="用countdownlatch实现线程等待"><a href="#用countdownlatch实现线程等待" class="header-anchor">#</a> 用CountDownLatch实现线程等待</h5> <p>经过上面的优化之后, 基本上可以跟老板汇报收工了, 但还是有点美中不足, 相信你也发现了, while 循环里面每次都会创建新的线程, 而创建线程可是个耗时的操作. 所以最好是创建出来的线程能够循环利用, 估计这时你已经想到线程池了, 是的, 线程池就能解决这个问题.</p> <p>而下面的代码就是用线程池优化后的: 首先创建了一个固定大小为 2 的线程池, 之后在 while 循环里重复利用. 一切看上去都很顺利, 但是有个问题好像无解了, 那就是主线程如何知道 getPOrders() 和 getDOrders() 这两个操作什么时候执行完. 前面主线程通过调用线程 T1 和 T2 的 join() 方法来等待线程 T1 和 T2 退出, 但是在线程池的方案里, 线程根本就不会退出, 所以 join() 方法已经失效了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 创建 2 个线程的线程池</span>
<span class="token class-name">Executor</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>存在未对账订单<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 查询未对账订单</span>
    executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        pos <span class="token operator">=</span> <span class="token function">getPOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 查询派送单</span>
    executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        dos <span class="token operator">=</span> <span class="token function">getDOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* ? ? 如何实现等待? ? */</span>

    <span class="token comment">// 执行对账操作</span>
    diff <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> dos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 差异写入差异库</span>
    <span class="token function">save</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>那如何解决这个问题呢? 可以开动脑筋想出很多办法, 最直接的办法是弄一个计数器, 初始值设置成 2, 当执行完 <code>pos = getPOrders();</code>​这个操作之后将计数器减 1, 执行完 <code>dos = getDOrders();</code>​ 之后也将计数器减 1, 在主线程里, 等待计数器等于 0; 当计数器等于 0 时, 说明这两个查询操作执行完了. 等待计数器等于 0 其实就是一个条件变量, 用管程实现起来也很简单.</p> <p>不过并不建议在实际项目中去实现上面的方案, 因为 Java 并发包里已经提供了实现类似功能的工具类: <strong>CountDownLatch</strong>, 直接使用就可以了. 下面的代码示例中, 在 while 循环里面, 首先创建了一个 CountDownLatch, 计数器的初始值等于 2, 之后在 <code>pos = getPOrders();</code>​ 和 <code>dos = getDOrders();</code>​ 两条语句的后面对计数器执行减 1 操作, 这个对计数器减 1 的操作是通过调用 <code>latch.countDown();</code>​ 来实现的. 在主线程中, 通过调用 <code>latch.await()</code>​ 来实现对计数器等于 0 的等待.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 创建 2 个线程的线程池</span>
<span class="token class-name">Executor</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>存在未对账订单<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 计数器初始化为 2</span>
    <span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 查询未对账订单</span>
    executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        pos <span class="token operator">=</span> <span class="token function">getPOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 查询派送单</span>
    executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        dos <span class="token operator">=</span> <span class="token function">getDOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 等待两个查询操作结束</span>
    latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 执行对账操作</span>
    diff <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> dos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 差异写入差异库</span>
    <span class="token function">save</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h5 id="进一步优化性能"><a href="#进一步优化性能" class="header-anchor">#</a> 进一步优化性能</h5> <p>经过上面的重重优化之后, 长出一口气, 终于可以交付了. 不过在交付之前还需要再次审视一番, 看看还有没有优化的余地, 仔细看还是有的.</p> <p>前面将 getPOrders() 和 getDOrders() 这两个查询操作并行了, 但这两个查询操作和对账操作 check(), save() 之间还是<strong>串行</strong>的. 很显然, 这两个查询操作和对账操作也是可以并行的, 也就是说, 在执行对账操作的时候, 可以同时去执行下一轮的查询操作, 这个过程可以形象化地表述为下面这幅示意图.</p> <p><img src="/img/18059955db59ee0af5c12dc2f29c1065-20230731162452-f5kqyyl.png" alt="" title="完全并行执行示意图"></p> <p>那接下来再来思考一下如何实现这步优化, 两次查询操作能够和对账操作并行, 对账操作还依赖查询操作的结果, 这明显有点生产者-消费者的意思, 两次查询操作是生产者, 对账操作是消费者. 既然是生产者-消费者模型, 那<strong>就需要有个队列, 来保存生产者生产的数据, 而消费者则从这个队列消费数据</strong>.</p> <p>不过针对对账这个项目, 我设计了两个队列, 并且两个队列的元素之间还有对应关系. 具体如下图所示, 订单查询操作将订单查询结果插入订单队列, 派送单查询操作将派送单插入派送单队列, 这两个队列的元素之间是有一一对应的关系的. 两个队列的好处是, <strong>对账操作可以每次从订单队列出一个元素, 从派送单队列出一个元素, 然后对这两个元素执行对账操作, 这样数据一定不会乱掉</strong>.</p> <p><img src="/img/32c71b1a66b0b4fbf70c65e447b5d44e-20230731162452-p3qbrxc.png" alt="" title="双队列示意图"></p> <p>下面再来看如何用双队列来实现完全的并行. 一个最直接的想法是: 一个线程 T1 执行订单的查询工作, 一个线程 T2 执行派送单的查询工作, 当线程 T1 和 T2 都各自生产完 1 条数据的时候, 通知线程 T3 执行对账操作. 这个想法虽看上去简单, 但其实还隐藏着一个条件, 那就是线程 T1 和线程 T2 的工作要步调一致, 不能一个跑得太快, 一个跑得太慢, 只有这样才能做到各自生产完 1 条数据的时候, 通知线程 T3.</p> <p>下面这幅图形象地描述了上面的意图: 线程 T1 和线程 T2 只有都生产完 1 条数据的时候, 才能一起向下执行, 也就是说, 线程 T1 和线程 T2 要互相等待, 步调要一致; 同时当线程 T1 和 T2 都生产完一条数据的时候, 还要能够通知线程 T3 执行对账操作.</p> <p><img src="/img/5d6b4f8132cca40ccea1b941f2bc0bcc-20230731162452-lua82p5.png" alt="" title="同步执行示意图"></p> <h5 id="用cyclicbarrier实现线程同步"><a href="#用cyclicbarrier实现线程同步" class="header-anchor">#</a> 用CyclicBarrier实现线程同步</h5> <p>下面就来实现上面提到的方案. 这个方案的难点有两个: <strong>一个是线程 T1 和 T2 要做到步调一致, 另一个是要能够通知到线程 T3</strong>.</p> <p>依然可以利用一个计数器来解决这两个难点, 计数器初始化为 2, 线程 T1 和 T2 生产完一条数据都将计数器减 1, 如果计数器大于 0 则线程 T1 或者 T2 等待. 如果计数器等于 0, 则通知线程 T3, 并唤醒等待的线程 T1 或者 T2, 与此同时将计数器重置为 2, 这样线程 T1 和线程 T2 生产下一条数据的时候就可以继续使用这个计数器了.</p> <p>同样, 还是建议不要在实际项目中这么做, 因为 Java 并发包里也已经提供了相关的工具类: <strong>CyclicBarrier</strong>. 在下面的代码中, 首先创建了一个计数器初始值为 2 的 CyclicBarrier, 需要注意的是创建 CyclicBarrier 的时候, <strong>还传入了一个回调函数, 当计数器减到 0 的时候, 会调用这个回调函数</strong>.</p> <p>线程 T1 负责查询订单, 当查出一条时, 调用 <code>barrier.await()</code>​ 来将计数器减 1, 同时等待计数器变成 0; 线程 T2 负责查询派送单, 当查出一条时, 也调用 <code>barrier.await()</code>​ 来将计数器减 1, 同时等待计数器变成 0; 当 T1 和 T2 都调用 <code>barrier.await()</code>​ 的时候, 计数器会减到 0, 此时 T1 和 T2 就可以执行下一条语句了, 同时会调用 barrier 的<strong>回调函数</strong>来执行对账操作.</p> <p>非常值得一提的是, CyclicBarrier 的<strong>计数器有自动重置</strong>的功能, 当减到 0 的时候, 会自动重置设置的初始值. 这个功能用起来实在是太方便了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 订单队列</span>
<span class="token class-name">Vector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">P</span><span class="token punctuation">&gt;</span></span> pos<span class="token punctuation">;</span>
<span class="token comment">// 派送单队列</span>
<span class="token class-name">Vector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">D</span><span class="token punctuation">&gt;</span></span> dos<span class="token punctuation">;</span>
<span class="token comment">// 执行回调的线程池 </span>
<span class="token class-name">Executor</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">final</span> <span class="token class-name">CyclicBarrier</span> barrier <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> check <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">P</span> p <span class="token operator">=</span> pos<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">D</span> d <span class="token operator">=</span> dos<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 执行对账操作</span>
    diff <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 差异写入差异库</span>
    <span class="token function">save</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> checkAll <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 循环查询订单库</span>
    <span class="token class-name">Thread</span> <span class="token constant">T1</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>存在未对账订单<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 查询订单库</span>
            pos<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">getPOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 等待</span>
            barrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token constant">T1</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 循环查询运单库</span>
    <span class="token class-name">Thread</span> <span class="token constant">T2</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>存在未对账订单<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 查询运单库</span>
            dos<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">getDOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 等待</span>
            barrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token constant">T2</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><h5 id="总结-13"><a href="#总结-13" class="header-anchor">#</a> 总结</h5> <p>CountDownLatch 和 CyclicBarrier 是 Java 并发包提供的两个非常易用的线程同步工具类, 这两个工具类用法的区别在这里还是有必要再强调一下: <mark><strong>CountDownLatch 主要用来解决一个线程等待多个线程的场景</strong></mark>, 可以类比旅游团团长要等待所有的游客到齐才能去下一个景点; 而 <mark><strong>CyclicBarrier 是一组线程之间互相等待</strong></mark>, 更像是几个驴友之间不离不弃. 除此之外 CountDownLatch 的计数器是不能循环利用的, 也就是说一旦计数器减到 0, 再有线程调用 await(), 该线程会直接通过. 但 <strong>CyclicBarrier 的计数器是可以循环利用的</strong>, 而且具备自动重置的功能, 一旦计数器减到 0 会自动重置到设置的初始值. 除此之外, CyclicBarrier 还可以设置<strong>回调函数</strong>, 可以说是功能丰富.</p> <h4 id="_20-并发容器-都有哪些-坑-需要我们填"><a href="#_20-并发容器-都有哪些-坑-需要我们填" class="header-anchor">#</a> 20-并发容器:都有哪些&quot;坑&quot;需要我们填?</h4> <p>Java 并发包有很大一部分内容都是关于<strong>并发容器</strong>的, 因此学习和搞懂这部分的内容很有必要.</p> <p>Java 1.5 之前提供的<strong>同步容器</strong>虽然也能保证线程安全, 但是性能很差, 而 Java 1.5 版本之后提供的并发容器在性能方面则做了很多优化, 并且容器的类型也更加丰富了. 下面就对比二者来学习这部分的内容.</p> <h5 id="同步容器及其注意事项"><a href="#同步容器及其注意事项" class="header-anchor">#</a> 同步容器及其注意事项</h5> <p>Java 中的容器主要可以分为四个大类, 分别是 List, Map, Set 和 Queue, 但并不是所有的 Java 容器都是线程安全的. 例如常用的 ArrayList, HashMap 就不是线程安全的. 在介绍线程安全的容器之前, 先思考这样一个问题: <strong>如何将非线程安全的容器变成线程安全的容器</strong>?</p> <p>前面讲过实现思路其实很简单, 只要把非线程安全的容器封装在对象内部, 然后控制好访问路径就可以了.</p> <p>下面就以 ArrayList 为例, 看看如何将它变成线程安全的. 在下面的代码中, SafeArrayList 内部持有一个 ArrayList 的实例 c, 所有访问 c 的方法都增加了 synchronized 关键字, 需要注意的是还增加了一个 addIfNotExist() 方法, 这个方法也是用 synchronized 来保证原子性的.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">SafeArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 封装 ArrayList</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 控制访问路径</span>
    <span class="token keyword">synchronized</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span> <span class="token keyword">int</span> idx<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span> <span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>
        c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">addIfNotExist</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>看到这里, 你可能会举一反三, 然后想到: 所有非线程安全的类是不是都可以用这种包装的方式来实现线程安全呢? 其实这一点不止你想到了, Java SDK 的开发人员也想到了, 所以他们在 Collections 这个类中还提供了一套完备的包装类, 比如下面的示例代码中, 分别把 ArrayList, HashSet 和 HashMap 包装成了线程安全的 List, Set 和 Map.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Set</span> set <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedSet</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Map</span> map <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>我们曾经多次强调, <mark><strong>组合操作需要注意竞态条件问题</strong></mark>, 例如上面提到的 addIfNotExist() 方法就包含组合操作. 组合操作往往隐藏着竞态条件问题, <strong>即便每个操作都能保证原子性, 也并不能保证组合操作的原子性</strong>, 这个一定要注意.</p> <p>在容器领域<strong>一个容易被忽视的 &quot;坑&quot; 是用迭代器遍历容器</strong>, 例如在下面的代码中, 通过迭代器遍历容器 list, 对每个元素调用 foo() 方法, 这就<strong>存在并发问题, 这些组合的操作不具备原子性</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Iterator</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>而正确做法是下面这样, <strong>锁住 list 之后再执行遍历操作</strong>. 如果查看 Collections 内部的包装类源码, 就会发现包装类的<strong>公共方法锁的是对象的 this, 其实就是这里的 list, 所以锁住 list 绝对是线程安全的</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">synchronized</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Iterator</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">foo</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>上面提到的这些经过包装后线程安全容器, 都是<strong>基于 synchronized 这个同步关键字实现</strong>的, 所以也被称为<strong>同步容器</strong>. Java 提供的同步容器还有 Vector, Stack 和 Hashtable, 这三个容器不是基于包装类实现的, 但同样是基于 synchronized 实现的, 对这三个容器的遍历, 同样要加锁保证互斥.</p> <h5 id="并发容器及其注意事项"><a href="#并发容器及其注意事项" class="header-anchor">#</a> 并发容器及其注意事项</h5> <p>Java 在 1.5 版本之前所谓的线程安全的容器, 主要指的就是<strong>同步容器</strong>. 不过同步容器有个最大的问题, 那就是<strong>性能差</strong>, 所有方法都用 synchronized 来保证互斥, 串行度太高了. 因此 Java 在 1.5 及之后版本提供了性能更高的容器, 一般称为<strong>并发容器</strong>.</p> <p>并发容器虽然数量非常多, 但依然是前面提到的四大类: <strong>List, Map, Set 和 Queue</strong>, 下面的并发容器关系图, 基本上把经常用的容器都覆盖到了.</p> <p><img src="/img/fe5edf1b8ed5c52011638c4a9208d7bf-20230731162452-z4x18y7.png" alt="" title="并发容器关系图"></p> <p>鉴于并发容器的数量太多, 再加上篇幅限制, 所以并不会一一详细介绍它们的用法, 只是把关键点介绍一下.</p> <h6 id="_1-list"><a href="#_1-list" class="header-anchor">#</a> (1)List</h6> <p>List 里面只有一个实现类就是 <strong>CopyOnWriteArrayList</strong>. CopyOnWrite, 顾名思义就是<strong>写的时候会将共享变量新复制一份出来, 这样做的好处是读操作完全无锁</strong>.</p> <p>那 CopyOnWriteArrayList 的实现原理是怎样的呢? 下面就来简单介绍一下</p> <p><strong>CopyOnWriteArrayList 内部维护了一个数组, 成员变量 array 就指向这个内部数组, 所有的读操作都是基于 array 进行的, 如下图所示, 迭代器 Iterator 遍历的就是 array 数组.</strong></p> <p><img src="/img/f321d4e4ea86f156a204a3a8c2ec0c5a-20230731162452-edx9gja.png" alt="" title="执行迭代的内部结构图"></p> <p>如果在遍历 array 的同时, 还有一个<strong>写操作</strong>, 例如增加元素, CopyOnWriteArrayList 是如何处理的呢? <strong>CopyOnWriteArrayList 会将 array 复制一份, 然后在新复制处理的数组上执行增加元素的操作, 执行完之后再将 array 指向这个新的数组</strong>. 通过下图可以看到, <strong>读写是可以并行的, 遍历操作一直都是基于原 array 执行, 而写操作则是基于新 array 进行</strong>.</p> <p><img src="/img/b5742b9895972d72e423147803259e4e-20230731162452-24mzbx2.png" alt="" title="执行增加元素的内部结构图"></p> <p>使用 CopyOnWriteArrayList 需要注意的 &quot;坑&quot; 主要有两个方面. 一个是应用场景, <strong>CopyOnWriteArrayList 仅适用于写操作非常少的场景, 而且能够容忍读写的短暂不一致</strong>. 例如上面的例子中, 写入的新元素并不能立刻被遍历到. 另一个需要注意的是, <strong>CopyOnWriteArrayList 迭代器是只读的, 不支持增删改</strong>. 因为迭代器遍历的仅仅是一个<strong>快照</strong>, 而对快照进行增删改是没有意义的.</p> <h6 id="_2-map"><a href="#_2-map" class="header-anchor">#</a> (2)Map</h6> <p>Map 接口的两个实现是 <strong>ConcurrentHashMap 和 ConcurrentSkipListMap</strong>, 它们从应用的角度来看, 主要区别在于 <strong>ConcurrentHashMap 的 key 是无序的, 而 ConcurrentSkipListMap 的 key 是有序的</strong>. 所以如果需要保证 key 的顺序, 就只能使用 ConcurrentSkipListMap.</p> <p>使用 ConcurrentHashMap 和 ConcurrentSkipListMap 需要注意的地方是, 它们的 key 和 value 都不能为空, 否则会抛出 <code>NullPointerException</code>​. 下面这个表格总结了 Map 相关的实现类对于 key 和 value 的要求, 可以对比学习.</p> <p><img src="/img/0cdabf41d8b79bc967a06fd5d1a098db-20230731162452-njzs6r6.png" alt=""></p> <p>ConcurrentSkipListMap 里面的 SkipList 本身就是一种数据结构, 中文一般都翻译为 &quot;跳表&quot;. 跳表插入, 删除, 查询操作平均的时间复杂度是 O(log n), 理论上和并发线程数没有关系, 所以在并发度非常高的情况下, 若对 ConcurrentHashMap 的性能还不满意, 可以尝试一下 ConcurrentSkipListMap.</p> <h6 id="_3-set"><a href="#_3-set" class="header-anchor">#</a> (3)Set</h6> <p>Set 接口的两个实现是 <strong>CopyOnWriteArraySet 和 ConcurrentSkipListSet</strong>, 使用场景可以参考前面讲述的 CopyOnWriteArrayList 和 ConcurrentSkipListMap, 它们的原理都是一样的, 这里就不再赘述了.</p> <h6 id="_4-queue"><a href="#_4-queue" class="header-anchor">#</a> (4)Queue</h6> <p>Java 并发包里面 Queue 这类并发容器是最复杂的, 可以从以下两个维度来分类. 一个维度是<strong>阻塞与非阻塞</strong>, 所谓阻塞指的是当队列已满时, 入队操作阻塞; 当队列已空时, 出队操作阻塞. 另一个维度是<strong>单端与双端</strong>, 单端指的是只能队尾入队, 队首出队; 而双端指的是队首队尾皆可入队出队. Java 并发包里<mark><strong>阻塞队列都用 Blocking 关键字标识, 单端队列使用 Queue 标识, 双端队列使用 Deque 标识</strong></mark>.</p> <p>这两个维度组合后, 可以将 Queue 细分为四大类, 分别是:</p> <p><strong>单端阻塞队列</strong>: 其实现有 <strong>ArrayBlockingQueue, LinkedBlockingQueue, SynchronousQueue, LinkedTransferQueue, PriorityBlockingQueue 和 DelayQueue</strong>. 内部一般会持有一个队列, 这个队列可以是<strong>数组</strong>(其实现是 ArrayBlockingQueue) 也可以是<strong>链表</strong>(其实现是 LinkedBlockingQueue); 甚至还可以不持有队列(其实现是 SynchronousQueue), 此时生产者线程的入队操作必须等待消费者线程的出队操作. 而 LinkedTransferQueue 融合 LinkedBlockingQueue 和 SynchronousQueue 的功能, 性能比 LinkedBlockingQueue 更好; PriorityBlockingQueue 支持按照优先级出队; DelayQueue 支持延时出队.</p> <p><img src="/img/3f332e1dc5817a7e2ef7bc09fe60ae0c-20230731162452-apm836d.png" alt="" title="单端阻塞队列示意图"></p> <p><strong>双端阻塞队列</strong>: 其实现是 <strong>LinkedBlockingDeque</strong>.</p> <p><img src="/img/f2061dda8c8f0d70648fb0b2a8cbb50c-20230731162452-arnju17.png" alt="" title="双端阻塞队列示意图"></p> <p><strong>单端非阻塞队列</strong>: 其实现是 <strong>ConcurrentLinkedQueue</strong>.</p> <p><strong>双端非阻塞队列</strong>: 其实现是 <strong>ConcurrentLinkedDeque</strong>.</p> <p>另外, 使用队列时, 需要格外注意队列<strong>是否支持有界</strong>(所谓有界指的是内部的队列是否有容量限制). 实际工作中, 一般都不建议使用无界的队列, 因为数据量大了之后很容易导致 OOM. 上面提到的这些 Queue 中, 只有 ArrayBlockingQueue 和 LinkedBlockingQueue 是支持有界的, 所以<strong>在使用其他无界队列时, 一定要充分考虑是否存在导致 OOM 的隐患</strong>.</p> <h5 id="总结-14"><a href="#总结-14" class="header-anchor">#</a> 总结</h5> <p>Java 并发容器的内容很多, 但鉴于篇幅有限, 只是对一些关键点进行了梳理和介绍.</p> <p>而在实际工作中, 不单要清楚每种容器的特性, 还要能<strong>选对容器, 这才是关键</strong>, 至于每种容器的用法, 用的时候看一下 API 说明就可以了, 这些容器的使用都不难. 在文中甚至都没有介绍 Java 容器的快速失败机制(Fail-Fast), 原因就在于当你选对容器的时候, 根本不会触发它.</p> <h4 id="_21-原子类-无锁工具类的典范"><a href="#_21-原子类-无锁工具类的典范" class="header-anchor">#</a> 21-原子类:无锁工具类的典范</h4> <p>前面多次提到一个累加器的例子, 示例代码如下. 在这个例子中, add10K() 这个方法不是线程安全的, 问题就出在变量 count 的可见性和 count+=1 的原子性上. 可见性问题可以用 volatile 来解决, 而原子性问题前面一直都是采用的<strong>互斥锁</strong>方案.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>idx<span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            count <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>其实对于简单的原子性问题, 还有一种<strong>无锁方案</strong>. Java SDK 并发包将这种无锁方案封装提炼之后, 实现了一系列的<strong>原子类</strong>. 不过, 在深入介绍原子类的实现之前, 先看看如何利用原子类解决累加器问题, 这样你会对原子类有个初步的认识.</p> <p>在下面的代码中, 将原来的 long 型变量 count 替换为了<strong>原子类 AtomicLong</strong>, 原来的 <code>count +=1</code>​ 替换成了 count.getAndIncrement(), 仅需要这两处简单的改动就能使 add10K() 方法变成<strong>线程安全的</strong>, 原子类的使用还是挺简单的.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token class-name">AtomicLong</span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>idx<span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>无锁方案相对互斥锁方案, 最大的好处就是<strong>性能</strong>. 互斥锁方案为了保证互斥性, 需要执行加锁, 解锁操作, 而加锁, 解锁操作本身就消耗性能; 同时拿不到锁的线程还会进入阻塞状态, 进而触发线程切换, 线程切换对性能的消耗也很大.  相比之下, <strong>无锁方案则完全没有加锁, 解锁的性能消耗, 同时还能保证互斥性</strong>, 既解决了问题, 又没有带来新的问题, 可谓绝佳方案. 那它是如何做到的呢?</p> <h5 id="无锁方案的实现原理"><a href="#无锁方案的实现原理" class="header-anchor">#</a> 无锁方案的实现原理</h5> <p>其实原子类性能高的秘密很简单, <strong>硬件支持</strong>而已. CPU 为了解决并发问题, 提供了 CAS 指令(CAS, 全称是 Compare And Swap, 即 &quot;比较并交换&quot;). CAS 指令包含 3 个参数: <mark><strong>共享变量的内存地址 A, 用于比较的值 B 和共享变量的新值 C; 并且只有当内存中地址 A 处的值等于 B 时, 才能将内存中地址 A 处的值更新为新值 C. 作为一条 CPU 指令, CAS 指令本身是能够保证原子性的</strong></mark>.</p> <p>可以通过下面 CAS 指令的模拟代码来理解 CAS 的工作原理. 在下面的模拟程序中有两个参数, 一个是期望值 expect, 另一个是需要写入的新值 newValue, <mark><strong>只有当目前 count 的值和期望值 expect 相等时, 才会将 count 更新为 newValue</strong></mark>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">SimulatedCAS</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> count<span class="token punctuation">;</span> 

    <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">cas</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 读目前 count 的值</span>
        <span class="token keyword">int</span> curValue <span class="token operator">=</span> count<span class="token punctuation">;</span>
        <span class="token comment">// 比较目前 count 值是否 &lt;mark&gt; 期望值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>curValue <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> expect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果是, 则更新 count 的值</span>
            count <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 返回写入前的值</span>
        <span class="token keyword">return</span> curValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>你仔细地再次思考一下这句话, &quot;<strong>只有当目前 count 的值和期望值 expect 相等时, 才会将 count 更新为 newValue.</strong> &quot; 要怎么理解这句话呢?</p> <p>对于前面提到的累加器的例子, <code>count += 1</code>​ 的一个核心问题是: 基于内存中 count 的当前值 A 计算出来的 <code>count+=1</code>​ 为 A+1, 在将 A+1 写入内存的时候, <strong>很可能此时内存中 count 已经被其他线程更新过了, 这样就会导致错误地覆盖其他线程写入的值</strong>. 也就是说, 只有当内存中 count 的值等于期望值 A 时, 才能将内存中 count 的值更新为计算结果 A+1, 这不就是 CAS 的语义吗!</p> <p><strong>使用 CAS 来解决并发问题, 一般都会伴随着自旋</strong>, 而所谓自旋, 其实就是循环尝试. 例实现一个线程安全的 <code>count += 1</code>​操作, &quot;CAS+ 自旋&quot; 的实现方案如下所示, 首先计算 <code>newValue = count+1</code>​, 如果 cas(count,newValue) 返回的值不等于 count, 则意味着线程在执行完代码 ① 处之后, 执行代码 ② 处之前, count 的值被其他线程更新过. 那此时该怎么处理呢? 可以采用<strong>自旋方案</strong>, 就像下面代码中展示的, 可以<strong>重新读 count 最新的值来计算 newValue 并尝试再次更新</strong>, 直到成功.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">SimulatedCAS</span> <span class="token punctuation">{</span>
    <span class="token keyword">volatile</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>

    <span class="token comment">// 实现 count+=1</span>
    <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            newValue <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// ①</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">!=</span> <span class="token function">cas</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//②</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 模拟实现 CAS, 仅用来帮助理解</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">cas</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 读目前 count 的值</span>
        <span class="token keyword">int</span> curValue <span class="token operator">=</span> count<span class="token punctuation">;</span>
        <span class="token comment">// 比较目前 count 值是否 &lt;mark&gt; 期望值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>curValue <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> expect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果是, 则更新 count 的值</span>
            count <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 返回写入前的值</span>
        <span class="token keyword">return</span> curValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>通过上面的示例代码, 想必你已经发现了, CAS 这种无锁方案, 完全没有加锁, 解锁操作, 即便两个线程完全同时执行 addOne() 方法, 也不会有线程被阻塞, 所以相对于互斥锁方案来说, 性能好了很多.</p> <p>但是在 CAS 方案中, 有一个问题可能会常被你忽略, 那<strong>就是 ABA 问题</strong>. 什么是 ABA 问题呢?</p> <p>前面提到 &quot;如果 cas(count,newValue) 返回的值<strong>不等于</strong> count, 意味着线程在执行完代码 ① 处之后, 执行代码 ② 处之前, count 的值被其他线程<strong>更新过</strong>&quot;, 那如果 cas(count,newValue) 返回的值<strong>等于</strong> count, 是否就能够认为 count 的值没有被其他线程<strong>更新过</strong>呢? 显然不是的, 假设 count 原本是 A, 线程 T1 在执行完代码 ① 处之后, 执行代码 ② 处之前, 有可能 count 被线程 T2 更新成了 B, 之后又被 T3 更新回了 A, 这样线程 T1 虽然看到的一直是 A, 但是其实已经被其他线程更新过了, 这就是 ABA 问题.</p> <p>可能大多数情况下并不关心 ABA 问题, 例如数值的原子递增, 但也不能所有情况下都不关心, 例如原子化的更新对象很可能就需要关心 ABA 问题, 因为两个 A 虽然相等, 但是第二个 A 的属性可能已经发生变化了. 所以在使用 CAS 方案的时候, <strong>一定要先 check 一下</strong>.</p> <h5 id="看java如何实现原子化的count-1"><a href="#看java如何实现原子化的count-1" class="header-anchor">#</a> 看Java如何实现原子化的count+=1</h5> <p>在本文开始部分, 使用原子类 AtomicLong 的 getAndIncrement() 方法替代了 <code>count += 1</code>​, 从而实现了线程安全. <strong>原子类 AtomicLong 的 getAndIncrement() 方法内部就是基于 CAS 实现的</strong>, 下面来看看 Java 是如何使用 CAS 来实现原子化的 <code>count += 1</code>​ 的.</p> <p>在 Java 1.8 版本中, getAndIncrement() 方法会转调 <strong>unsafe.getAndAddLong()</strong>  方法. 这里 this 和 valueOffset 两个参数可以<strong>唯一确定共享变量的内存地址</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>unsafe.getAndAddLong() 方法的源码如下, 该方法<strong>首先会在内存中读取共享变量的值, 之后循环调用 compareAndSwapLong() 方法来尝试设置共享变量的值, 直到成功为止</strong>. compareAndSwapLong() 是一个 native 方法, 只有当内存中共享变量的值等于 expected 时, 才会将共享变量的值更新为 x, 并且返回 true; 否则返回 fasle. compareAndSwapLong 的语义和 CAS 指令的语义的差别仅仅是返回值不同而已.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getAndAddLong</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">long</span> delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> v<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token comment">// 读取内存中的值</span>
        v <span class="token operator">=</span> <span class="token function">getLongVolatile</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> v<span class="token punctuation">,</span> v <span class="token operator">+</span> delta<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 原子性地将变量更新为 x</span>
<span class="token comment">// 条件是内存中的值等于 expected</span>
<span class="token comment">// 更新成功则返回 true</span>
<span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">long</span> expected<span class="token punctuation">,</span> <span class="token keyword">long</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>另外需要注意的是, <strong>getAndAddLong() 方法的实现, 基本上就是 CAS 使用的经典范例</strong>. 所以请再次体会下面这段抽象后的代码片段, 它在很多无锁程序中经常出现. Java 提供的原子类里面 CAS 一般被实现为 compareAndSet(), compareAndSet() 的语义和 CAS 指令的语义的差别仅仅是返回值不同而已, compareAndSet() 里面如果更新成功, 则会返回 true, 否则返回 false.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取当前值</span>
    oldV <span class="token operator">=</span> xxxx<span class="token punctuation">;</span>
    <span class="token comment">// 根据当前值计算新值</span>
    newV <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>oldV<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>oldV<span class="token punctuation">,</span> newV<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h5 id="原子类概览"><a href="#原子类概览" class="header-anchor">#</a> 原子类概览</h5> <p>Java SDK 并发包里提供的原子类内容很丰富, 可以将它们分为五个类别: <strong>原子化的基本数据类型, 原子化的对象引用类型, 原子化数组, 原子化对象属性更新器</strong>和<strong>原子化的累加器</strong>. 这五个类别提供的方法基本上是相似的, 并且每个类别都有若干原子类, 可以通过下面的原子类组成概览图来获得一个全局的印象. 下面详细解读这五个类别.</p> <p><img src="/img/7e1c4116189c825d8d93912b45bdf367-20230731162452-jppujwx.png" alt="" title="原子类组成概览图"></p> <h6 id="_1-原子化的基本数据类型"><a href="#_1-原子化的基本数据类型" class="header-anchor">#</a> (1)原子化的基本数据类型</h6> <p>相关实现有 AtomicBoolean, AtomicInteger 和 AtomicLong, 提供的方法主要有以下这些, 详情可以参考 SDK 的源代码, 都很简单, 这里就不详细介绍了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 原子化 i++</span>
<span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 原子化的 i--</span>
<span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 原子化的 ++i</span>
<span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 原子化的 --i</span>
<span class="token comment">// 当前值 +=delta, 返回 += 前的值</span>
<span class="token function">getAndAdd</span><span class="token punctuation">(</span>delta<span class="token punctuation">)</span> 
<span class="token comment">// 当前值 +=delta, 返回 += 后的值</span>
<span class="token function">addAndGet</span><span class="token punctuation">(</span>delta<span class="token punctuation">)</span>
<span class="token comment">//CAS 操作, 返回是否成功</span>
<span class="token function">compareAndSet</span><span class="token punctuation">(</span>expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span>
<span class="token comment">// 以下四个方法</span>
<span class="token comment">// 新值可以通过传入 func 函数来计算</span>
<span class="token function">getAndUpdate</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span>
<span class="token function">updateAndGet</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span>
<span class="token function">getAndAccumulate</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>func<span class="token punctuation">)</span>
<span class="token function">accumulateAndGet</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>func<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h6 id="_2-原子化的对象引用类型"><a href="#_2-原子化的对象引用类型" class="header-anchor">#</a> (2)原子化的对象引用类型</h6> <p>相关实现有 <strong>AtomicReference, AtomicStampedReference 和 AtomicMarkableReference</strong>, 利用它们可以实现<strong>对象引用的原子化更新</strong>. AtomicReference 提供的方法和原子化的基本数据类型差不多, 这里不再赘述. 不过需要注意的是, <strong>对象引用的更新需要重点关注 ABA 问题, AtomicStampedReference 和 AtomicMarkableReference 这两个原子类可以解决 ABA 问题</strong>.</p> <p>解决 ABA 问题的思路其实很简单, 增加一个<strong>版本号维度</strong>就可以了, 这个与前面介绍的乐观锁机制很类似, 每次执行 CAS 操作, 附加再更新一个版本号, 只要保证版本号是递增的, 那么即便 A 变成 B 之后再变回 A, 版本号也不会变回来(版本号递增的). AtomicStampedReference 实现的 CAS 方法就<strong>增加了版本号参数</strong>, 方法签名如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token class-name">V</span> expectedReference<span class="token punctuation">,</span> <span class="token class-name">V</span> newReference<span class="token punctuation">,</span> <span class="token keyword">int</span> expectedStamp<span class="token punctuation">,</span> <span class="token keyword">int</span> newStamp<span class="token punctuation">)</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>AtomicMarkableReference 的实现机制则更简单, 将版本号简化成了一个 Boolean 值, 方法签名如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token class-name">V</span> expectedReference<span class="token punctuation">,</span> <span class="token class-name">V</span> newReference<span class="token punctuation">,</span> <span class="token keyword">boolean</span> expectedMark<span class="token punctuation">,</span> <span class="token keyword">boolean</span> newMark<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h6 id="_3-原子化数组"><a href="#_3-原子化数组" class="header-anchor">#</a> (3)原子化数组</h6> <p>相关实现有 AtomicIntegerArray, AtomicLongArray 和 AtomicReferenceArray, 利用这些原子类, 可以原子化地更新数组里面的每一个元素. 这些类提供的方法和原子化的基本数据类型的区别仅仅是: 每个方法多了一个数组的索引参数, 所以这里也不再赘述了.</p> <h6 id="_4-原子化对象属性更新器"><a href="#_4-原子化对象属性更新器" class="header-anchor">#</a> (4)原子化对象属性更新器</h6> <p>相关实现有 AtomicIntegerFieldUpdater, AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater, 利用它们可以<strong>原子化地更新对象的属性, 这三个方法都是利用反射机制实现</strong>的, 创建更新器的方法如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span><span class="token class-name">AtomicXXXFieldUpdater</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token function">newUpdater</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> tclass<span class="token punctuation">,</span> <span class="token class-name">String</span> fieldName<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>需要注意的是, <strong>对象属性必须是 volatile 类型的, 只有这样才能保证可见性</strong>; 如果对象属性不是 volatile 类型的, newUpdater() 方法会抛出 IllegalArgumentException 这个运行时异常.</p> <p>你会发现 newUpdater() 的方法参数只有类的信息, 没有对象的引用, 而更新<strong>对象</strong>的属性, 一定需要对象的引用, 那这个参数是在哪里传入的呢? 是在<strong>原子操作的方法参数中传入</strong>的. 例如 compareAndSet() 这个原子操作, 相比原子化的基本数据类型多了一个对象引用 obj. 原子化对象属性更新器相关的方法, 相比原子化的基本数据类型仅仅是多了对象引用参数, 所以这里也不再赘述了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token class-name">T</span> obj<span class="token punctuation">,</span> <span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h6 id="_5-原子化的累加器"><a href="#_5-原子化的累加器" class="header-anchor">#</a> (5)原子化的累加器</h6> <p><strong>DoubleAccumulator, DoubleAdder, LongAccumulator 和 LongAdder</strong>, 这四个类仅仅用来执行<strong>累加</strong>操作, 相比原子化的基本数据类型, 速度更快, 但是不支持 compareAndSet() 方法. 如果仅仅需要累加操作, 使用原子化的累加器性能会更好.</p> <h5 id="总结-15"><a href="#总结-15" class="header-anchor">#</a> 总结</h5> <p>无锁方案相对于互斥锁方案, 优点非常多, 首先性能好, 其次是基本不会出现死锁问题(但可能出现饥饿和活锁问题, 因为自旋会反复重试). Java 提供的原子类大部分都实现了 compareAndSet() 方法, 基于 compareAndSet() 方法, 可以构建自己的无锁数据结构, 但是<strong>建议不要这样做, 这个工作最好还是让大师们去完成</strong>, 原因是无锁算法没想象的那么简单.</p> <p>Java 提供的原子类能够解决一些简单的原子性问题, 但你可能会发现, 上面所有原子类的方法都是针对<strong>一个共享变量</strong>的, 如果<strong>需要解决多个变量的原子性问题, 建议还是使用互斥锁方案</strong>. 原子类虽好, 但使用要慎之又慎.</p> <h4 id="_22-executor与线程池-如何创建正确的线程池"><a href="#_22-executor与线程池-如何创建正确的线程池" class="header-anchor">#</a> 22-Executor与线程池:如何创建正确的线程池?</h4> <p>虽然在 Java 语言中创建线程看上去就像创建一个对象一样简单, 只需要 new Thread() 就可以了, 但实际上创建线程远不是创建一个对象那么简单. 创建对象, 仅仅是在 JVM 的堆里分配一块内存而已; 而创建一个线程, 却需要调用操作系统内核的 API, 然后操作系统要为线程分配一系列的资源, 这个成本就很高了, 所以<strong>线程是一个重量级的对象, 应该避免频繁创建和销毁</strong>.</p> <p>那如何避免呢? 那就是<strong>线程池</strong>.</p> <p>线程池的需求是如此普遍, 所以 Java SDK 并发包自然也少不了它. 但是很多人在初次接触并发包里线程池相关的工具类时, 多少会都有点蒙, 不知道该从哪里入手, 我觉得根本原因在于线程池和一般意义上的池化资源是不同的. 一般意义上的池化资源, 都是下面这样, 当需要资源的时候就调用 acquire() 方法来申请资源, 用完之后就调用 release() 释放资源. 若带着这个固有模型来看并发包里线程池相关的工具类时, 会很遗憾地发现它们完全匹配不上, <strong>Java 提供的线程池里面压根就没有申请线程和释放线程的方法</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">XXXPool</span><span class="token punctuation">{</span>
    <span class="token comment">// 获取池化资源</span>
    <span class="token class-name">XXX</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 释放池化资源</span>
    <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token class-name">XXX</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h5 id="线程池是一种生产者-消费者模式"><a href="#线程池是一种生产者-消费者模式" class="header-anchor">#</a> 线程池是一种生产者-消费者模式</h5> <p>为什么线程池没有采用一般意义上池化资源的设计方法呢? 如果线程池采用一般意义上池化资源的设计方法, 应该是下面示例代码这样. 可以思考一下, 假设获取到一个空闲线程 T1, 然后该如何使用 T1 呢? 你期望的可能是这样: 通过调用 T1 的 execute() 方法, 传入一个 Runnable 对象来执行具体业务逻辑, 就像通过构造函数 Thread(Runnable target) 创建线程一样. 可惜的是, 你翻遍 Thread 对象的所有方法, 都不存在类似 execute(Runnable target) 这样的公共方法.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 采用一般意义上池化资源的设计方法</span>
<span class="token keyword">class</span> <span class="token class-name">ThreadPool</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取空闲线程</span>
    <span class="token class-name">Thread</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 释放线程</span>
    <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 期望的使用</span>
<span class="token class-name">ThreadPool</span> pool<span class="token punctuation">;</span> 
<span class="token class-name">Thread</span> <span class="token constant">T1</span> <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 传入 Runnable 对象</span>
<span class="token constant">T1</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 具体业务逻辑</span>
    <span class="token comment">// ......</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>所以线程池的设计, 没有办法直接采用一般意义上池化资源的设计方法. 那线程池该如何设计呢? 目前业界线程池的设计, 普遍采用的都是<mark><strong>生产者-消费者模式</strong></mark>. 线程池的<strong>使用方是生产者, 线程池本身是消费者</strong>. 在下面的示例代码中, 创建了一个非常简单的线程池 MyThreadPool, 可以通过它来理解线程池的工作原理.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 简化的线程池, 仅用来说明工作原理</span>
<span class="token keyword">class</span> <span class="token class-name">MyThreadPool</span> <span class="token punctuation">{</span>
    <span class="token comment">// 利用阻塞队列实现生产者-消费者模式</span>
    <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">;</span>
    <span class="token comment">// 保存内部工作线程</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">WorkerThread</span><span class="token punctuation">&gt;</span></span> threads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 构造方法</span>
    <span class="token class-name">MyThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> poolSize<span class="token punctuation">,</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>
        <span class="token comment">// 创建工作线程</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> idx <span class="token operator">&lt;</span> poolSize<span class="token punctuation">;</span> idx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">WorkerThread</span> work <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WorkerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            work<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            threads<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>work<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 提交任务</span>
    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        workQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 工作线程负责消费任务, 并执行任务</span>
    <span class="token keyword">class</span> <span class="token class-name">WorkerThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 循环取任务并执行</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// ①</span>
                <span class="token class-name">Runnable</span> task <span class="token operator">=</span> workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 使用示例
 **/</span>
<span class="token comment">// 创建有界阻塞队列</span>
<span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建线程池  </span>
<span class="token class-name">MyThreadPool</span> pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> workQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 提交任务  </span>
pool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><p>在 MyThreadPool 的内部, 维护了一个<strong>阻塞队列 workQueue 和一组工作线程, 工作线程的个数由构造函数中的 poolSize 来指定</strong>. 用户通过<strong>调用 execute() 方法来提交 Runnable 任务, execute() 方法的内部实现仅仅是将任务加入到 workQueue 中. MyThreadPool 内部维护的工作线程会消费 workQueue 中的任务并执行任务, 相关的代码就是代码 ① 处的 while 循环</strong>. 线程池主要的工作原理就这些, 是不是还挺简单的?</p> <h5 id="如何使用java中的线程池"><a href="#如何使用java中的线程池" class="header-anchor">#</a> 如何使用Java中的线程池</h5> <p>Java 并发包里提供的线程池, 远比上面的示例代码强大得多, 当然也复杂得多. Java 提供的线程池相关的工具类中, 最核心的是 <mark><strong>ThreadPoolExecutor</strong></mark>, 通过名字也能看出来, 它强调的是 <strong>Executor</strong>, 而不是一般意义上的池化资源.</p> <p>ThreadPoolExecutor 的构造函数非常复杂, 如下面代码所示, 这个最完备的构造函数有 7 个参数.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>
  <span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
  <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
  <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
  <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
  <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
  <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
  <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>下面一一介绍这些参数的意义, 可以<strong>把线程池类比为一个项目组, 而线程就是项目组的成员</strong>.</p> <ul><li><mark><strong>corePoolSize</strong></mark>: 表示线程池保有的<strong>最小线程数</strong>. 有些项目很闲, 但是也不能把人都撤了, 至少要留 corePoolSize 个人坚守阵地.</li> <li><mark><strong>maximumPoolSize</strong></mark>: 表示线程池创建的<strong>最大线程数</strong>. 当项目很忙时, 就需要加人, 但是也不能无限制地加, 最多就加到 maximumPoolSize 个人. 当项目闲下来时, 就要撤人了, 最多能撤到 corePoolSize 个人.</li> <li><mark><strong>keepAliveTime &amp; unit</strong></mark>: 上面提到项目根据忙闲来增减人员, 那在编程世界里, 如何定义忙和闲呢? 很简单, 一个线程如果在一段时间内, 都没有执行任务, 说明很闲, keepAliveTime 和 unit 就是用来定义这个 &quot;一段时间&quot; 的参数. 也就是说, 如果一个线程空闲了 <code>keepAliveTime &amp; unit</code>​ 这么久, 而且线程池的线程数大于 corePoolSize, 那么这个空闲的线程就要被回收了.</li> <li><mark><strong>workQueue</strong></mark>: 工作队列, 和上面示例代码的工作队列同义.</li> <li><mark><strong>threadFactory</strong></mark>: 通过这个参数可以<strong>自定义如何创建线程</strong>, 例如可以给线程指定一个有意义的名字.</li> <li><mark><strong>handler</strong></mark>: 通过这个参数可以<strong>自定义任务的拒绝策略</strong>. 如果线程池中所有的线程都在忙碌, 并且工作队列也满了(前提是工作队列是有界队列), 那么此时提交任务, 线程池就会拒绝接收. 至于拒绝的策略, 可以通过 handler 这个参数来指定. ThreadPoolExecutor 已经提供了以下 4 种策略.
<ul><li><strong>CallerRunsPolicy</strong>: 提交任务的线程自己去执行该任务.</li> <li><strong>AbortPolicy</strong>: 默认的拒绝策略, 会 throws RejectedExecutionException.</li> <li><strong>DiscardPolicy</strong>: 直接丢弃任务, 没有任何异常抛出.</li> <li><strong>DiscardOldestPolicy</strong>: 丢弃最老的任务, 其实就是把最早进入工作队列的任务丢弃, 然后把新任务加入到工作队列.</li></ul></li></ul> <p>Java 在 1.6 版本还增加了 allowCoreThreadTimeOut(boolean value) 方法, 它可以让所有线程都支持超时, 这意味着如果项目很闲, 就会将项目组的成员都撤走.</p> <h5 id="使用线程池要注意些什么"><a href="#使用线程池要注意些什么" class="header-anchor">#</a> 使用线程池要注意些什么</h5> <p>考虑到 ThreadPoolExecutor 的构造函数实在是有些复杂, 所以 Java 并发包里提供了一个<strong>线程池的静态工厂类 Executors</strong>, 利用 Executors 可以快速创建线程池. 不过目前大厂的编码规范中基本上都不建议使用 Executors 了, 所以这里就不再花篇幅介绍了.</p> <p>不建议使用 Executors 的最重要的原因是: <mark><strong>Executors 提供的很多方法默认使用的都是无界的 LinkedBlockingQueue, 高负载情境下, 无界队列很容易导致 OOM, 而 OOM 会导致所有请求都无法处理, 这是致命问题. 所以强烈建议使用有界队列</strong></mark>.</p> <p>使用有界队列, 当任务过多时, 线程池会触发执行拒绝策略, 线程池默认的拒绝策略会 throw RejectedExecutionException 这是个运行时异常, 对于运行时异常编译器并不强制 catch 它, 所以开发人员很容易忽略. 因此<strong>默认拒绝策略要慎重使用</strong>. 如果线程池处理的任务非常重要, 建议自定义自己的拒绝策略; 并且在实际工作中, 自定义的拒绝策略往往和降级策略配合使用.</p> <p>使用线程池, 还要注意异常处理的问题, 例如通过 ThreadPoolExecutor 对象的 execute() 方法提交任务时, 如果任务在执行的过程中出现运行时异常, 会导致执行任务的线程终止; 不过, 最致命的是任务虽然异常了, 但是却获取不到任何通知, 这会让你误以为任务都执行得很正常. 虽然线程池提供了很多用于异常处理的方法, 但是最稳妥和简单的方案还是捕获所有异常并按需处理, 可以参考下面的示例代码.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 业务逻辑</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 按需处理</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 按需处理</span>
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="_23-future-如何用多线程实现最优的-烧水泡茶-程序"><a href="#_23-future-如何用多线程实现最优的-烧水泡茶-程序" class="header-anchor">#</a> 23-Future:如何用多线程实现最优的&quot;烧水泡茶&quot;程序?</h4> <p>上一节详细介绍了如何创建正确的线程池, 那创建完线程池, 该如何使用呢? 上一节仅仅介绍了 ThreadPoolExecutor 的 <code>void execute(Runnable command)</code>​ 方法, 利用这个方法虽然<strong>可以提交任务, 但是却没有办法获取任务的执行结果(execute() 方法没有返回值)</strong> . 而很多场景下, 又都是需要获取任务的执行结果的. 那 ThreadPoolExecutor 是否提供了相关功能呢? 必须的, 这么重要的功能当然需要提供了.</p> <p>下面就来介绍一下<strong>使用 ThreadPoolExecutor 的时候, 如何获取任务执行结果</strong>.</p> <h5 id="如何获取任务执行结果"><a href="#如何获取任务执行结果" class="header-anchor">#</a> 如何获取任务执行结果</h5> <p>Java 通过 <strong>ThreadPoolExecutor 提供的 3 个 submit() 方法和 1 个 FutureTask 工具类来支持获得任务执行结果的需求</strong>. 下面先来介绍这 3 个 submit() 方法, 这 3 个方法的方法签名如下.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 提交 Runnable 任务</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 提交 Callable 任务</span>
<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 提交 Runnable 任务及结果引用  </span>
<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">T</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>你会发现它们的返回值都是 Future 接口, Future 接口有 5 个方法, 都列在下面了, 它们分别是<strong>取消任务的方法 cancel(), 判断任务是否已取消的方法 isCancelled(), 判断任务是否已结束的方法 isDone()<strong>​<strong><strong>以及</strong></strong> <strong>2 个获得任务执行结果的 get() 和 get(timeout, unit)</strong> , 其中最后一个 get(timeout, unit) 支持超时机制. 通过 Future 接口的这 5 个方法可以发现, <strong>提交的任务不但能够获取任务执行结果, 还可以取消任务</strong>. 不过需要注意的是: 这两个 get() 方法都是</strong>阻塞式</strong>的, 如果被调用的时候, 任务还没有执行完, 那么调用 get() 方法的线程会阻塞, 直到任务执行完才会被唤醒.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 取消任务</span>
<span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterruptIfRunning<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 判断任务是否已取消  </span>
<span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 判断任务是否已结束</span>
<span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获得任务执行结果</span>
<span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获得任务执行结果, 支持超时</span>
<span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这 3 个 submit() 方法之间的区别在于<strong>方法参数不同</strong>, 下面简要介绍一下.</p> <ol><li>提交 Runnable 任务 <code>submit(Runnable task)</code>​: 这个方法的参数是一个 <strong>Runnable 接口</strong>, Runnable 接口的 run() 方法是<strong>没有返回值</strong>的, 所以 <code>submit(Runnable task)</code>​ 这个方法返回的 <strong>Future 仅可以用来断言任务已经结束</strong>了, 类似于 Thread.join().</li> <li>提交 Callable 任务 <code>submit(Callable&lt;T&gt; task)</code>​: 这个方法的参数是一个 <strong>Callable 接口</strong>, 它只有一个 call() 方法, 并且这个方法是<strong>有返回值</strong>的, 所以这个方法返回的 Future 对象<strong>可以通过调用其 get() 方法来获取任务的执行结果</strong>.</li> <li>提交 Runnable 任务及结果引用 <code>submit(Runnable task, T result)</code>​: 这个方法很有意思, 假设这个方法返回的 Future 对象是 f, f.get() 的返回值就是传给 submit() 方法的参数 result. 这个方法该怎么用呢? 下面这段示例代码展示了它的经典用法. 需要注意的是 Runnable 接口的实现类 Task 声明了一个有参构造函数 <code>Task(Result r)</code>​, 创建 Task 对象的时候传入了 result 对象, 这样就能在类 Task 的 run() 方法中对 result 进行各种操作了. result 相当于主线程和子线程之间的桥梁, 通过它主子线程可以共享数据.</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建 Result 对象 r</span>
<span class="token class-name">Result</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
r<span class="token punctuation">.</span><span class="token function">setAAA</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 提交任务</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Result</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Result</span> fr <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 下面等式成立</span>
fr <span class="token operator">==</span> <span class="token operator">=</span> r<span class="token punctuation">;</span>
fr<span class="token punctuation">.</span><span class="token function">getAAA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>
fr<span class="token punctuation">.</span><span class="token function">getXXX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">=</span> x

<span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token class-name">Result</span> r<span class="token punctuation">;</span>

    <span class="token comment">// 通过构造函数传入 result</span>
    <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token class-name">Result</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>r <span class="token operator">=</span> r<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 可以操作 result</span>
        a <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">getAAA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        r<span class="token punctuation">.</span><span class="token function">setXXX</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>···</p> <p>下面再来介绍 <strong>FutureTask 工具类</strong>. 前面提到的 Future 是一个接口, 而 FutureTask 是一个实实在在的工具类, 这个工具类有两个构造函数, 它们的参数和前面介绍的 submit() 方法类似, 所以这里就不再赘述了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">FutureTask</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> callable<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">FutureTask</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> runnable<span class="token punctuation">,</span> <span class="token class-name">V</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>那如何使用 FutureTask 呢? 其实很简单, <strong>FutureTask 实现了 Runnable 和 Future 接口, 由于实现了 Runnable 接口, 所以可以将 FutureTask 对象作为任务提交给 ThreadPoolExecutor 去执行, 也可以直接被 Thread 执行; 又因为实现了 Future 接口, 所以也能用来获得任务的执行结果</strong>. 下面的示例代码是将 FutureTask 对象提交给 ThreadPoolExecutor 去执行.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 创建 FutureTask</span>
<span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建线程池</span>
<span class="token class-name">ExecutorService</span> es <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 提交 FutureTask </span>
es<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取计算结果</span>
<span class="token class-name">Integer</span> result <span class="token operator">=</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>FutureTask 对象直接被 Thread 执行的示例代码如下所示. 相信你已经发现了, <strong>利用 FutureTask 对象可以很容易获取子线程的执行结果</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 创建 FutureTask</span>
<span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建并启动线程</span>
<span class="token class-name">Thread</span> <span class="token constant">T1</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token constant">T1</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取计算结果</span>
<span class="token class-name">Integer</span> result <span class="token operator">=</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h5 id="实现最优的-烧水泡茶-程序"><a href="#实现最优的-烧水泡茶-程序" class="header-anchor">#</a> 实现最优的&quot;烧水泡茶&quot;程序</h5> <p>记得以前初中语文课文里有一篇著名数学家华罗庚先生的文章《统筹方法》, 这篇文章里介绍了一个烧水泡茶的例子, 文中提到最优的工序应该是下面这样:</p> <p><img src="/img/dfd8bd8b8389479a6509374b1a3d38ae-20230731162452-5nbart4.png" alt="" title="烧水泡茶最优工序"></p> <p>下面用程序来模拟一下这个最优工序. 前面曾经提到, 并发编程可以总结为三个核心问题: <strong>分工, 同步和互斥</strong>. 编写并发程序, 首先要做的就是分工, 所谓分工指的是如何高效地拆解任务并分配给线程. 对于烧水泡茶这个程序, 一种最优的分工方案可以是下图所示的这样: 用两个线程 T1 和 T2 来完成烧水泡茶程序, T1 负责洗水壶, 烧开水, 泡茶这三道工序, T2 负责洗茶壶, 洗茶杯, 拿茶叶三道工序, 其中 T1 在执行泡茶这道工序时需要等待 T2 完成拿茶叶的工序. 对于 T1 的这个等待动作, 你应该可以想出很多种办法, 例如 Thread.join(), CountDownLatch, 甚至阻塞队列都可以解决, 不过今天用 Future 特性来实现.</p> <p><img src="/img/4f95b782869f7e48ae4ded1ce5c1cddc-20230731162452-otyrhd4.png" alt="" title="烧水泡茶最优分工方案"></p> <p>下面的示例代码就是用这一章提到的 Future 特性来实现的. 首先创建了两个 FutureTask -- ft1 和 ft2, ft1 完成洗水壶, 烧开水, 泡茶的任务, ft2 完成洗茶壶, 洗茶杯, 拿茶叶的任务; 这里需要注意的是 ft1 这个任务在执行泡茶任务前, 需要等待 ft2 把茶叶拿来, 所以 ft1 内部需要引用 ft2, 并在执行泡茶之前, 调用 ft2 的 get() 方法实现等待.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 创建任务 T2 的 FutureTask</span>
<span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> ft2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">T2Task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建任务 T1 的 FutureTask</span>
<span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> ft1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">T1Task</span><span class="token punctuation">(</span>ft2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 线程 T1 执行任务 ft1</span>
<span class="token class-name">Thread</span> <span class="token constant">T1</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>ft1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token constant">T1</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 线程 T2 执行任务 ft2</span>
<span class="token class-name">Thread</span> <span class="token constant">T2</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>ft2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token constant">T2</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等待线程 T1 执行结果</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ft1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// T1Task 需要执行的任务: </span>
<span class="token comment">// 洗水壶, 烧开水, 泡茶</span>
<span class="token keyword">class</span> <span class="token class-name">T1Task</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> ft2<span class="token punctuation">;</span>

    <span class="token comment">// T1 任务需要 T2 任务的 FutureTask</span>
    <span class="token class-name">T1Task</span><span class="token punctuation">(</span><span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> ft2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>ft2 <span class="token operator">=</span> ft2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T1: 洗水壶...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T1: 烧开水...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取 T2 线程的茶叶  </span>
        <span class="token class-name">String</span> tf <span class="token operator">=</span> ft2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T1: 拿到茶叶:&quot;</span> <span class="token operator">+</span> tf<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T1: 泡茶...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">&quot; 上茶:&quot;</span> <span class="token operator">+</span> tf<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// T2Task 需要执行的任务:</span>
<span class="token comment">// 洗茶壶, 洗茶杯, 拿茶叶</span>
<span class="token keyword">class</span> <span class="token class-name">T2Task</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T2: 洗茶壶...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T2: 洗茶杯...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T2: 拿茶叶...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">&quot; 龙井 &quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 一次执行结果: </span>
<span class="token constant">T1</span><span class="token operator">:</span> 洗水壶<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">T2</span><span class="token operator">:</span> 洗茶壶<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">T1</span><span class="token operator">:</span> 烧开水<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">T2</span><span class="token operator">:</span> 洗茶杯<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">T2</span><span class="token operator">:</span> 拿茶叶<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">T1</span><span class="token operator">:</span> 拿到茶叶<span class="token operator">:</span> 龙井
<span class="token constant">T1</span><span class="token operator">:</span> 泡茶<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
上茶<span class="token operator">:</span> 龙井
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h5 id="总结-16"><a href="#总结-16" class="header-anchor">#</a> 总结</h5> <p>利用 Java 并发包提供的 Future 可以<strong>很容易获得异步任务的执行结果</strong>, 无论异步任务是通过线程池 ThreadPoolExecutor 执行的, 还是通过手工创建子线程来执行的. Future 可以类比为现实世界里的提货单, 比如去蛋糕店订生日蛋糕, 蛋糕店都是先给你一张提货单, 你拿到提货单之后, 没有必要一直在店里等着, 可以先去干点其他事, 比如看场电影; 等看完电影后, 基本上蛋糕也做好了, 然后你就可以凭提货单领蛋糕了.</p> <p>利用多线程可以快速将一些串行的任务并行化, 从而提高性能; 如果任务之间有依赖关系, 比如当前任务依赖前一个任务的执行结果, 这种问题基本上都可以用 Future 来解决. 在分析这种问题的过程中, 建议用有向图描述一下任务之间的依赖关系, 同时将线程的分工也做好, 类似于烧水泡茶最优分工方案那幅图. 对照图来写代码, 好处是更形象, 且不易出错.</p> <h4 id="_24-completablefuture-异步编程没那么难🍀"><a href="#_24-completablefuture-异步编程没那么难🍀" class="header-anchor">#</a> 24-CompletableFuture:异步编程没那么难🍀</h4> <p>前面不止一次提到, 用多线程优化性能, 其实不过就是将串行操作变成并行操作. 如果仔细观察, 还可以发现在串行转换成并行的过程中, 一定会涉及到<strong>异步化</strong>, 例如下面的示例代码, 现在是串行的, 为了提升性能, 得把它们并行化, 那具体实施起来该怎么做呢?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 以下两个方法都是耗时操作</span>
<span class="token function">doBizA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">doBizB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>还是挺简单的, 就像下面代码中这样, 创建两个子线程去执行就可以了. 你会发现下面的并行方案, 主线程无需等待 doBizA() 和 doBizB() 的执行结果, 也就是说 doBizA() 和 doBizB() 两个操作已经被异步化了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">doBizA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">doBizB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>异步化</strong>, 是并行方案得以实施的基础, 更深入地讲其实就是: <strong>利用多线程优化性能这个核心方案得以实施的基础</strong>. 看到这里, 相信你应该就能理解异步编程最近几年为什么会大火了, 因为优化性能是互联网大厂的一个核心需求啊. Java 在 1.8 版本提供了 <strong>CompletableFuture 来支持异步编程</strong>, CompletableFuture 有可能是你见过的最复杂的工具类了, 不过功能也着实让人感到震撼.</p> <h5 id="completablefuture的核心优势"><a href="#completablefuture的核心优势" class="header-anchor">#</a> CompletableFuture的核心优势</h5> <p>为了领略 CompletableFuture 异步编程的优势, 这里用 CompletableFuture 重新实现前面曾提及的烧水泡茶程序. 首先还是需要先完成分工方案, 在下面的程序中, 分了 3 个任务: 任务 1 负责洗水壶, 烧开水, 任务 2 负责洗茶壶, 洗茶杯和拿茶叶, 任务 3 负责泡茶. 其中任务 3 要等待任务 1 和任务 2 都完成后才能开始. 这个分工如下图所示.</p> <p><img src="/img/675bdf8b5e51a5c61f649171e4c0453c-20230731162452-ma8k7yn.png" alt="" title="烧水泡茶分工方案"></p> <p>下面是代码实现, 先略过 runAsync(), supplyAsync(), thenCombine() 这些不太熟悉的方法, 从大局上看, 你会发现:</p> <ol><li><strong>无需手工维护线程</strong>, 没有繁琐的手工维护线程的工作, 给任务分配线程的工作也不需要关注;</li> <li>语义更清晰, 例如 <code>f3 = f1.thenCombine(f2, ()-&gt;{})</code>​ 能够清晰地表述 &quot;任务 3 要等待任务 1 和任务 2 都完成后才能开始&quot;;</li> <li><strong>代码更简练并且专注于业务逻辑, 几乎所有代码都是业务逻辑相关的</strong>.</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 任务 1: 洗水壶 -&gt; 烧开水</span>
<span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> f1 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T1: 洗水壶...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T1: 烧开水...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 任务 2: 洗茶壶 -&gt; 洗茶杯 -&gt; 拿茶叶</span>
<span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> f2 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T2: 洗茶壶...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T2: 洗茶杯...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T2: 拿茶叶...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">&quot; 龙井 &quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 任务 3: 任务 1 和任务 2 完成后执行: 泡茶</span>
<span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> f3 <span class="token operator">=</span> f1<span class="token punctuation">.</span><span class="token function">thenCombine</span><span class="token punctuation">(</span>f2<span class="token punctuation">,</span> <span class="token punctuation">(</span>__<span class="token punctuation">,</span> tf<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T1: 拿到茶叶:&quot;</span> <span class="token operator">+</span> tf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T1: 泡茶...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">&quot; 上茶:&quot;</span> <span class="token operator">+</span> tf<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 等待任务 3 执行结果</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f3<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> sleep <span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        u<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 一次执行结果: </span>
<span class="token constant">T1</span><span class="token operator">:</span> 洗水壶<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">T2</span><span class="token operator">:</span> 洗茶壶<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">T1</span><span class="token operator">:</span> 烧开水<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">T2</span><span class="token operator">:</span> 洗茶杯<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">T2</span><span class="token operator">:</span> 拿茶叶<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">T1</span><span class="token operator">:</span> 拿到茶叶<span class="token operator">:</span> 龙井
<span class="token constant">T1</span><span class="token operator">:</span> 泡茶<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
上茶<span class="token operator">:</span> 龙井
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>领略 CompletableFuture 异步编程的优势之后, 下面详细介绍 CompletableFuture 的使用, 首先是如何创建 CompletableFuture 对象.</p> <h5 id="创建completablefuture对象"><a href="#创建completablefuture对象" class="header-anchor">#</a> 创建CompletableFuture对象</h5> <p>创建 CompletableFuture 对象主要靠下面代码中展示的这 4 个静态方法, 先看前两个. 在烧水泡茶的例子中, 已经使用了 <code>runAsync(Runnable runnable)</code>​ 和 <code>supplyAsync(Supplier&lt;U&gt; supplier)</code>​, 它们之间的区别是: <strong>Runnable 接口的 run() 方法没有返回值, 而 Supplier 接口的 get() 方法是有返回值的</strong>.</p> <p>前两个方法和后两个方法的区别在于: <strong>后两个方法可以指定线程池参数</strong>.</p> <p>默认情况下 CompletableFuture 会使用公共的 ForkJoinPool 线程池, 这个线程池默认创建的线程数是 CPU 的核数(也可以通过 <code>JVM option:-Djava.util.concurrent.ForkJoinPool.common.parallelism</code>​ 来设置 ForkJoinPool 线程池的线程数). 如果所有 CompletableFuture 共享一个线程池, 那么一旦有任务执行一些很慢的 I/O 操作, 就会导致线程池中所有线程都阻塞在 I/O 操作上, 从而造成线程饥饿, 进而影响整个系统的性能. 所以, 强烈建议要<strong>根据不同的业务类型创建不同的线程池, 以避免互相干扰</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 使用默认线程池</span>
<span class="token keyword">static</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> runnable<span class="token punctuation">)</span>
<span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> supplier<span class="token punctuation">)</span>
<span class="token comment">// 可以指定线程池  </span>
<span class="token keyword">static</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> runnable<span class="token punctuation">,</span> <span class="token class-name">Executor</span> executor<span class="token punctuation">)</span>
<span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> supplier<span class="token punctuation">,</span> <span class="token class-name">Executor</span> executor<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>创建完 CompletableFuture 对象之后, 会自动地异步执行 runnable.run() 方法或者 supplier.get() 方法</strong>, 对于一个异步操作, 需要关注两个问题: <strong>一个是异步操作什么时候结束, 另一个是如何获取异步操作的执行结果</strong>. 因为 CompletableFuture 类实现了 Future 接口, 所以这两个问题都可以通过 Future 接口来解决. 另外, CompletableFuture 类还实现了 CompletionStage 接口, 这个接口内容实在是太丰富了, 在 1.8 版本里有 40 个方法, 这些方法该如何理解呢?</p> <h5 id="如何理解completionstage接口"><a href="#如何理解completionstage接口" class="header-anchor">#</a> 如何理解CompletionStage接口</h5> <p>我觉得可以<strong>站在分工的角度类比一下工作流</strong>. 任务是有时序关系的, 比如有<strong>串行关系, 并行关系, 汇聚关系</strong>等. 这样说可能有点抽象, 这里还举前面烧水泡茶的例子, 其中洗水壶和烧开水就是串行关系, 洗水壶, 烧开水和洗茶壶, 洗茶杯这两组任务之间就是并行关系, 而烧开水, 拿茶叶和泡茶就是汇聚关系.</p> <p><img src="/img/cd90e09d864209195d2623c63420602d-20230731162452-aq4ty57.png" alt="" title="串行关系"></p> <p><img src="/img/0e01bc4362b9b677026dcf3e1ec8ba67-20230731162452-6ujeyya.png" alt="" title="并行关系"></p> <p><img src="/img/61727821e6993a508b7cac74c3500d29-20230731162452-d84fzb9.png" alt="" title="汇聚关系"></p> <p><strong>CompletionStage 接口可以清晰地描述任务之间的这种时序关系</strong>, 例如前面提到的 <code>f3 = f1.thenCombine(f2, ()-&gt;{})</code>​ 描述的就是一种汇聚关系. 烧水泡茶程序中的汇聚关系是一种 AND 聚合关系, 这里的 AND 指的是所有依赖的任务(烧开水和拿茶叶)都完成后才开始执行当前任务(泡茶). 既然有 AND 聚合关系, 那就一定还有 OR 聚合关系, <strong>所谓 OR 指的是依赖的任务只要有一个完成就可以执行当前任务</strong>.</p> <p>在编程领域, 还有一个绕不过去的山头, 那就是异常处理, CompletionStage 接口也可以<strong>方便地描述异常处理</strong>.</p> <p>下面就来一一介绍, CompletionStage 接口如何描述串行关系, AND 聚合关系, OR 聚合关系以及异常处理.</p> <h6 id="_1-描述串行关系"><a href="#_1-描述串行关系" class="header-anchor">#</a> (1)描述串行关系</h6> <p>CompletionStage 接口里面描述串行关系, 主要是 <strong>thenApply, thenAccept, thenRun 和 thenCompose</strong> 这四个系列的接口.</p> <p>thenApply 系列函数里参数 fn 的类型是接口 <code>Function&lt;T, R&gt;</code>​, 这个接口里与 CompletionStage 相关的方法是 <code>R apply(T t)</code>​, 这个方法既能接收参数也支持返回值, 所以 thenApply 系列方法返回的是<code>CompletionStage&lt;R&gt;</code>​.</p> <p>而 thenAccept 系列方法里参数 consumer 的类型是接口 <code>Consumer&lt;T&gt;</code>​, 这个接口里与 CompletionStage 相关的方法是 <code>void accept(T t)</code>​, 这个方法虽然支持参数, 但却不支持回值, 所以 thenAccept 系列方法返回的是 <code>CompletionStage&lt;Void&gt;</code>​.</p> <p>thenRun 系列方法里 action 的参数是 Runnable, 所以 action 既不能接收参数也不支持返回值, 所以 thenRun 系列方法返回的也是 <code>CompletionStage&lt;Void&gt;</code>​.</p> <p>这些方法里面 Async 代表的是异步执行 fn, consumer 或者 action. 其中, 需要注意的是 thenCompose 系列方法, 这个系列的方法会<strong>新创建出一个子流程, 最终结果和 thenApply 系列是相同的</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token function">thenApply</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token function">thenApplyAsync</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">thenAccept</span><span class="token punctuation">(</span>consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">thenAcceptAsync</span><span class="token punctuation">(</span>consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">thenRun</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">thenRunAsync</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token function">thenCompose</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token function">thenComposeAsync</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>通过下面的示例代码, 可以看一下 thenApply() 方法是如何使用的. 首先通过 supplyAsync() <strong>启动一个异步流程</strong>, 之后是两个串行操作, 整体看起来还是挺简单的. 不过虽然这是一个异步流程, 但任务 ①②③ 却是串行执行的,  ② 依赖 ① 的执行结果, ③ 依赖 ② 的执行结果.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> f0 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span>
                <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">)</span>      <span class="token comment">//①</span>
        <span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> s <span class="token operator">+</span> <span class="token string">&quot; QQ&quot;</span><span class="token punctuation">)</span>  <span class="token comment">//②</span>
        <span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">toUpperCase</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//③</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f0<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出结果</span>
<span class="token comment">// HELLO WORLD QQ</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h6 id="_2-描述and汇聚关系"><a href="#_2-描述and汇聚关系" class="header-anchor">#</a> (2)描述AND汇聚关系</h6> <p>CompletionStage 接口里面描述 AND 汇聚关系, 主要是 <strong>thenCombine, thenAcceptBoth 和 runAfterBoth</strong> 系列的接口, 这些接口的区别也是源自 fn, consumer, action 这三个核心参数不同. 它们的使用可以参考上面烧水泡茶的实现程序, 这里就不赘述了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token function">thenCombine</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token function">thenCombineAsync</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">thenAcceptBoth</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">thenAcceptBothAsync</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">runAfterBoth</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">runAfterBothAsync</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h6 id="_3-描述or汇聚关系"><a href="#_3-描述or汇聚关系" class="header-anchor">#</a> (3)描述OR汇聚关系</h6> <p>CompletionStage 接口里面描述 OR 汇聚关系, 主要是 <strong>applyToEither, acceptEither 和 runAfterEither</strong> 系列的接口, 这些接口的区别也是源自 fn, consumer, action 这三个核心参数不同.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">CompletionStage</span> <span class="token function">applyToEither</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span> <span class="token function">applyToEitherAsync</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span> <span class="token function">acceptEither</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span> <span class="token function">acceptEitherAsync</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span> <span class="token function">runAfterEither</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span> <span class="token function">runAfterEitherAsync</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>下面的示例代码展示了如何使用 applyToEither() 方法来描述一个 OR 汇聚关系.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> f1 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token function">getRandom</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> f2 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token function">getRandom</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> f3 <span class="token operator">=</span> f1<span class="token punctuation">.</span><span class="token function">applyToEither</span><span class="token punctuation">(</span>f2<span class="token punctuation">,</span> s <span class="token operator">-&gt;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f3<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h6 id="_4-异常处理"><a href="#_4-异常处理" class="header-anchor">#</a> (4)异常处理</h6> <p>虽然上面提到的 fn, consumer, action 它们的核心方法都<strong>不允许抛出可检查异常, 但是却无法限制它们抛出运行时异常</strong>, 例如下面的代码, 执行 <code>7/0</code>​ 就会出现除零错误这个运行时异常. 非异步编程里面, 可以使用 <code>try{} catch{}</code>​ 来捕获并处理异常, 那在异步编程里面, 异常该如何处理呢?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> f0 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span>
        <span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token number">7</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>r <span class="token operator">-&gt;</span> r <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f0<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>CompletionStage 接口提供的方案非常简单, 比 try{} catch{} 还要简单, 下面是相关的方法, 使用这些方法<strong>进行异常处理和串行操作是一样的, 都支持链式编程方式</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">CompletionStage</span> <span class="token function">exceptionally</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token function">whenComplete</span><span class="token punctuation">(</span>consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token function">whenCompleteAsync</span><span class="token punctuation">(</span>consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token function">handle</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token function">handleAsync</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>下面的示例代码展示了如何使用 exceptionally() 方法来处理异常, exceptionally() 的使用非常类似于  <code>try{} catch{}</code>​ 中的 catch{}, 但是由于支持链式编程方式, 所以相对更简单. 既然有 <code>try{} catch{}</code>​, 那就一定还有 <code>try{} finally{}</code>​, <strong>whenComplete() 和 handle() 系列方法</strong>就类似于 <code>try{} finally{}</code>​ 中的 finally{}, 无论是否发生异常都会执行 <strong>whenComplete() 中的回调函数</strong> consumer 和 handle() 中的回调函数 fn. whenComplete() 和 handle() 的区别在于 whenComplete() 不支持返回结果, 而 handle() 是支持返回结果的.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> 
  f0 <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span>
    <span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token number">7</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>r <span class="token operator">-&gt;</span> r <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">exceptionally</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f0<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h5 id="总结-17"><a href="#总结-17" class="header-anchor">#</a> 总结</h5> <p>曾经一提到异步编程, 大家脑海里都会随之浮现回调函数, 例如在 JavaScript 里面异步问题基本上都是靠回调函数来解决的, 回调函数在处理异常以及复杂的异步任务关系时往往力不从心, 对此业界还发明了个名词: <strong>回调地狱</strong>(Callback Hell). 应该说在前些年, 异步编程还是声名狼藉的.</p> <p>不过最近几年, 异步编程已经慢慢开始成熟, Java 语言也开始官方支持异步编程: 在 1.8 版本提供了 CompletableFuture, 在 Java 9 版本则提供了更加完备的 Flow API, 异步编程目前已经完全工业化. 因此, 学好异步编程还是很有必要的. CompletableFuture 已经能够满足简单的异步编程需求, 如果对异步编程感兴趣, 可以重点关注 RxJava 这个项目.</p> <h4 id="_25-completionservice-如何批量执行异步任务-🍀"><a href="#_25-completionservice-如何批量执行异步任务-🍀" class="header-anchor">#</a> 25-CompletionService:如何批量执行异步任务?🍀</h4> <p>思考一个问题: 小明要做一个询价应用, 这个应用需要从三个电商询价, 然后保存在自己的数据库里. 核心示例代码如下所示, 由于是串行的, 所以性能很慢, 试着优化一下吧.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 向电商 S1 询价, 并保存</span>
r1 <span class="token operator">=</span> <span class="token function">getPriceByS1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">save</span><span class="token punctuation">(</span>r1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 向电商 S2 询价, 并保存</span>
r2 <span class="token operator">=</span> <span class="token function">getPriceByS2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">save</span><span class="token punctuation">(</span>r2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 向电商 S3 询价, 并保存</span>
r3 <span class="token operator">=</span> <span class="token function">getPriceByS3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">save</span><span class="token punctuation">(</span>r3<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>如果采用 &quot;ThreadPoolExecutor + Future&quot; 的方案, 你的优化结果很可能是下面示例代码这样: 用三个线程异步执行询价, 通过三次调用 Future 的 get() 方法获取询价结果, 之后将询价结果保存在数据库中.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 创建线程池</span>
<span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 异步向电商 S1 询价</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> f1 <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">getPriceByS1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 异步向电商 S2 询价</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> f2 <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">getPriceByS2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 异步向电商 S3 询价</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> f3 <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">getPriceByS3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取电商 S1 报价并保存</span>
r <span class="token operator">=</span> f1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">save</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取电商 S2 报价并保存</span>
r <span class="token operator">=</span> f2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">save</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取电商 S3 报价并保存  </span>
r <span class="token operator">=</span> f3<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">save</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>上面的这个方案本身没有太大问题, 但是有个地方的处理需要注意, 那就是如果获取电商 S1 报价的耗时很长, 那么即便获取电商 S2 报价的耗时很短, 也无法让保存 S2 报价的操作先执行, 因为这个<strong>主线程都阻塞</strong>在了 <code>f1.get()</code>​ 操作上. 这点小瑕疵该如何解决呢?</p> <p>估计你已经想到了, 增加一个<strong>阻塞队列</strong>, 获取到 S1, S2, S3 的报价<strong>都进入阻塞队列</strong>, 然后<strong>在主线程中消费阻塞队列, 这样就能保证先获取到的报价先保存到数据库</strong>了. 下面的示例代码展示了如何利用阻塞队列实现先获取到的报价先保存到数据库.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 创建阻塞队列</span>
<span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> bq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 电商 S1 报价异步进入阻塞队列  </span>
executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> bq<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>f1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 电商 S2 报价异步进入阻塞队列  </span>
executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> bq<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>f2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 电商 S3 报价异步进入阻塞队列  </span>
executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> bq<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>f3<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 异步保存所有报价  </span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 从阻塞队列获取结果进行消费</span>
    <span class="token class-name">Integer</span> r <span class="token operator">=</span> bq<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">save</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h5 id="利用completionservice实现询价系统"><a href="#利用completionservice实现询价系统" class="header-anchor">#</a> 利用CompletionService实现询价系统</h5> <p>不过在实际项目中, 并不建议这样做, 因为 Java SDK 并发包里已经提供了设计精良的 <strong>CompletionService</strong>. 利用 CompletionService 不但能解决先获取到的报价先保存到数据库的问题, 而且还能让代码更简练.</p> <p><strong>CompletionService 的实现原理也是内部维护了一个阻塞队列, 当任务执行结束就把任务的执行结果加入到阻塞队列中, 不同的是 CompletionService 是把任务执行结果的 Future 对象加入到阻塞队列中</strong>, 而上面的示例代码是把任务最终的执行结果放入了阻塞队列中.</p> <p>**那到底该如何创建 CompletionService 呢? **</p> <p>CompletionService 接口的实现类是 <strong>ExecutorCompletionService</strong>, 这个实现类的构造方法有两个, 分别是:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ExecutorCompletionService</span><span class="token punctuation">(</span><span class="token class-name">Executor</span> executor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ExecutorCompletionService</span><span class="token punctuation">(</span><span class="token class-name">Executor</span> executor<span class="token punctuation">,</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Future</span><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> completionQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这两个构造方法都需要<strong>传入一个线程池</strong>, 如果不指定 completionQueue, 那么默认会使用无界的 LinkedBlockingQueue. <strong>任务执行结果的 Future 对象就是加入到 completionQueue 中</strong>.</p> <p>下面的示例代码完整地展示了如何利用 CompletionService 来实现高性能的询价系统. 其中没有指定 completionQueue, 因此默认使用无界的 LinkedBlockingQueue. 之后通过 CompletionService 接口提供的 submit() 方法提交了三个询价操作, <strong>这三个询价操作将会被 CompletionService 异步执行</strong>. 最后通过 CompletionService 接口提供的 take() 方法获取一个 Future 对象(前面提到过, 加入到阻塞队列中的是任务执行结果的 Future 对象), <strong>调用 Future 对象的 get() 方法就能返回询价操作的执行结果</strong>了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 创建线程池</span>
<span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建 CompletionService</span>
<span class="token class-name">CompletionService</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> cs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExecutorCompletionService</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 异步向电商 S1 询价</span>
cs<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">getPriceByS1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 异步向电商 S2 询价</span>
cs<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">getPriceByS2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 异步向电商 S3 询价</span>
cs<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">getPriceByS3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 将询价结果异步保存到数据库</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Integer</span> r <span class="token operator">=</span> cs<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">save</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h5 id="completionservice接口说明"><a href="#completionservice接口说明" class="header-anchor">#</a> CompletionService接口说明</h5> <p>下面详细地介绍一下 CompletionService 接口提供的方法, CompletionService 接口提供的方法有 5 个, 这 5 个方法的方法签名如下所示.</p> <p>其中, submit() 相关的方法有两个. 一个方法参数是 <code>Callable&lt;V&gt; task</code>​, 前面利用 CompletionService 实现询价系统的示例代码中, 提交任务就是用的它. 另外一个方法有两个参数, 分别是 <code>Runnable task</code>​ 和 <code>V result</code>​, 这个方法类似于 ThreadPoolExecutor 的 <code>&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</code>​, 这个方法前面已详细介绍过, 这里不再赘述.</p> <p>CompletionService 接口其余的 3 个方法, 都是和阻塞队列相关的, <strong>take(), poll() 都是从阻塞队列中获取并移除一个元素; 它们的区别在于如果阻塞队列是空的, 那么调用 take() 方法的线程会被阻塞, 而 poll() 方法会返回 null 值</strong>. <code>poll(long timeout, TimeUnit unit)</code>​ 方法支持以超时的方式获取并移除阻塞队列头部的一个元素, 如果等待了 timeout unit 时间, 阻塞队列还是空的, 那么该方法会返回 null 值.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">V</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h5 id="利用completionservice实现dubbo中的forking-cluster"><a href="#利用completionservice实现dubbo中的forking-cluster" class="header-anchor">#</a> 利用CompletionService实现Dubbo中的Forking Cluster</h5> <p>Dubbo 中有一种叫做 <strong>Forking 的集群模式</strong>, 这种集群模式下, 支持<strong>并行地调用多个查询服务, 只要有一个成功返回结果, 整个服务就可以返回了</strong>. 例如需要提供一个地址转坐标的服务, 为了保证该服务的高可用和性能, 可以并行地调用 3 个地图服务商的 API, 然后只要有 1 个正确返回了结果 r, 那么地址转坐标这个服务就可以直接返回 r 了. 这种集群模式可以容忍 2 个地图服务商服务异常, 但缺点是消耗的资源偏多.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">geocoder</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 并行执行以下 3 个查询服务,  </span>
    r1 <span class="token operator">=</span> <span class="token function">geocoderByS1</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    r2 <span class="token operator">=</span> <span class="token function">geocoderByS2</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    r3 <span class="token operator">=</span> <span class="token function">geocoderByS3</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 只要 r1,r2,r3 有一个返回</span>
    <span class="token comment">// 则返回</span>
    <span class="token keyword">return</span> r1 <span class="token operator">|</span> r2 <span class="token operator">|</span> r3<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>利用 CompletionService 可以快速实现 Forking 这种集群模式</strong>, 比如下面的示例代码就展示了具体是如何实现的. 首先创建了一个线程池 executor, 一个 CompletionService 对象 cs 和一个 <code>Future&lt;Integer&gt;</code>​ 类型的列表 futures, 每次通过调用 CompletionService 的 submit() 方法提交一个<strong>异步任务</strong>, 会返回一个 Future 对象, 把这些 Future 对象保存在列表 futures 中. 通过调用 <code>cs.take().get()</code>​, 能够拿到最快返回的任务执行结果, 只要拿到一个正确返回的结果, 就<strong>可以取消所有任务并且返回最终结果</strong>了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 创建线程池</span>
<span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建 CompletionService</span>
<span class="token class-name">CompletionService</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> cs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExecutorCompletionService</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 用于保存 Future 对象</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Future</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> futures <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 提交异步任务, 并保存 future 到 futures </span>
futures<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cs<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">geocoderByS1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
futures<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cs<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">geocoderByS2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
futures<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cs<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">geocoderByS3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取最快返回的任务执行结果</span>
<span class="token class-name">Integer</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 只要有一个成功返回, 则 break</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        r <span class="token operator">=</span> cs<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 简单地通过判空来检查是否成功返回</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token comment">// 取消所有任务</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">:</span> futures<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        f<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 返回结果</span>
<span class="token keyword">return</span> r<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><h5 id="总结-18"><a href="#总结-18" class="header-anchor">#</a> 总结</h5> <p><strong>当需要批量提交异步任务的时候建议使用 CompletionService. CompletionService 将线程池 Executor 和阻塞队列 BlockingQueue 的功能融合在了一起, 能够让批量异步任务的管理更简单. 除此之外, CompletionService 能够让异步任务的执行结果有序化, 先执行完的先进入阻塞队列, 利用这个特性, 可以轻松实现后续处理的有序性, 避免无谓的等待, 同时还可以快速实现诸如 Forking Cluster 这样的需求</strong>.</p> <p>CompletionService 的实现类 ExecutorCompletionService, 需要自己创建线程池, 虽看上去有些啰嗦, 但好处是可以让多个 ExecutorCompletionService 的线程池隔离, 这种隔离性能避免几个特别耗时的任务拖垮整个应用的风险.</p> <h4 id="_26-fork-join-单机版的mapreduce"><a href="#_26-fork-join-单机版的mapreduce" class="header-anchor">#</a> 26-Fork/Join:单机版的MapReduce</h4> <p>前面几篇文章介绍了线程池, Future, CompletableFuture 和 CompletionService, 仔细观察会发现这些工具类都是<strong>站在任务的视角</strong>来解决并发问题, 而不是纠缠在线程之间如何协作的细节上(比如线程之间如何实现等待, 通知等). <strong>对于简单的并行任务, 可以通过 &quot;线程池 +Future&quot; 的方案来解决; 如果任务之间有聚合关系, 无论是 AND 聚合还是 OR 聚合, 都可以通过 CompletableFuture 来解决; 而批量的并行任务, 则可以通过 CompletionService 来解决.</strong></p> <p>前面一直讲, 并发编程可以分为三个层面的问题, 分别是分工, 协作和互斥, 当关注于任务的时候, 会发现你的视角已经从并发编程的细节中跳出来了, 你应用的更多的是现实世界的思维模式, 类比的往往是现实世界里的分工, 所以我<strong>把线程池, Future, CompletableFuture 和 CompletionService 都列到了分工</strong>里面.</p> <p>下面用现实世界里的工作流程图描述了并发编程领域的简单并行任务, 聚合任务和批量并行任务, 辅以这些流程图, 相信你一定能将你的思维模式转换到现实世界里来.</p> <p><img src="/img/7bb80ebe35bcb7b1637e737943f32c02-20230731162452-zehx3uc.png" alt="" title="从上到下, 依次为简单并行任务, 聚合任务和批量并行任务示意图"></p> <p>上面提到的简单并行, 聚合, 批量并行这三种任务模型, 基本上能够覆盖日常工作中的并发场景了, 但还是不够全面, 因为还有一种 &quot;分治&quot; 的任务模型没有覆盖到. <strong>分治</strong>, 顾名思义, 即分而治之, 是一种解决复杂问题的思维方法和模式; 具体来讲, 指的是<strong>把一个复杂的问题分解成多个相似的子问题, 然后再把子问题分解成更小的子问题, 直到子问题简单到可以直接求解</strong>. 理论上来讲, 解决每一个问题都对应着一个任务, 所以对于问题的分治, 实际上就是对于任务的分治.</p> <p>分治思想在很多领域都有广泛的应用, 例如算法领域有分治算法(归并排序, 快速排序都属于分治算法, 二分法查找也是一种分治算法); 大数据领域知名的计算框架 <strong>MapReduce</strong> 背后的思想也是分治. 既然分治这种任务模型如此普遍, 那 Java 显然也需要支持, Java 并发包里提供了一种叫做 Fork/Join 的并行计算框架, 就是用来支持分治这种任务模型的.</p> <h5 id="分治任务模型"><a href="#分治任务模型" class="header-anchor">#</a> 分治任务模型</h5> <p>这里需要先深入了解一下分治任务模型, 分治任务模型可分为两个阶段: 一个阶段是<strong>任务分解</strong>, 也就是将任务迭代地分解为子任务, 直至子任务可以直接计算出结果; 另一个阶段是<strong>结果合并</strong>, 即逐层合并子任务的执行结果, 直至获得最终结果. 下图是一个简化的分治任务模型图.</p> <p><img src="/img/60ddb6b705384d40eda6d88e6eeb5a12-20230731162452-2ii2c72.png" alt="" title="简版分治任务模型图"></p> <p>在这个分治任务模型里, <strong>任务和分解后的子任务具有相似性, 这种相似性往往体现在任务和子任务的算法是相同的, 但是计算的数据规模是不同的</strong>. 具备这种相似性的问题, 往往都采用<strong>递归算法</strong>.</p> <h5 id="fork-join的使用"><a href="#fork-join的使用" class="header-anchor">#</a> Fork/Join的使用</h5> <p>Fork/Join 是一个并行计算的框架, 主要就是用来支持分治任务模型的, 这个计算框架里的 <strong>Fork 对应的是分治任务模型里的任务分解, Join 对应的是结果合并</strong>. Fork/Join 计算框架主要包含两部分, 一部分是<mark><strong>分治任务的线程池 ForkJoinPool</strong></mark>, 另一部分是<mark><strong>分治任务 ForkJoinTask</strong></mark>. 这两部分的关系类似于 ThreadPoolExecutor 和 Runnable 的关系, 都可以理解为提交任务到线程池, 只不过分治任务有自己独特类型 ForkJoinTask.</p> <p>ForkJoinTask 是一个抽象类, 它的方法有很多, <strong>最核心的是 fork() 方法和 join() 方法, 其中 fork() 方法会异步地执行一个子任务, 而 join() 方法则会阻塞当前线程来等待子任务的执行结果</strong>. ForkJoinTask 有两个子类--RecursiveAction 和 RecursiveTask, 通过名字就能知道, 它们都是用递归的方式来处理分治任务的. 这两个子类都定义了抽象方法 compute(), 不过区别是 <strong>RecursiveAction 定义的 compute() 没有返回值, 而 RecursiveTask 定义的 compute() 方法是有返回值的</strong>. 这两个子类也是抽象类, 在使用的时候, 需要定义子类去扩展.</p> <p>接下来就来实现一下, 看看如何用 Fork/Join 这个并行计算框架计算斐波那契数列(下面的代码源自 Java 官方示例). 首先需要<strong>创建一个分治任务线程池以及计算斐波那契数列的分治任务, 之后通过调用分治任务线程池的 invoke() 方法来启动分治任务</strong>. 由于计算斐波那契数列需要有返回值, 所以 Fibonacci 继承自 RecursiveTask. 分治任务 Fibonacci 需要实现 compute() 方法, 这个方法里面的逻辑和普通计算斐波那契数列非常类似, 区别之处在于计算 <code>Fibonacci(n - 1)</code>​ 使用了异步子任务, 这是通过 <code>f1.fork()</code>​ 这条语句实现的.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建分治任务线程池  </span>
    <span class="token class-name">ForkJoinPool</span> fjp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建分治任务</span>
    <span class="token class-name">Fibonacci</span> fib <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fibonacci</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 启动分治任务  </span>
    <span class="token class-name">Integer</span> result <span class="token operator">=</span> fjp<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>fib<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 输出结果  </span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 递归任务</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Fibonacci</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>

    <span class="token class-name">Fibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token class-name">Integer</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> n<span class="token punctuation">;</span>
        <span class="token class-name">Fibonacci</span> f1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 创建子任务  </span>
        f1<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Fibonacci</span> f2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 等待子任务结果, 并合并结果  </span>
        <span class="token keyword">return</span> f2<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> f1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h5 id="forkjoinpool工作原理"><a href="#forkjoinpool工作原理" class="header-anchor">#</a> ForkJoinPool工作原理</h5> <p>Fork/Join 并行计算的<strong>核心组件是 ForkJoinPool</strong>, 所以下面就来简单介绍一下 ForkJoinPool 的工作原理.</p> <p>通过专栏前面文章的学习, 应该已经知道 ThreadPoolExecutor 本质上是一个生产者-消费者模式的实现, 内部有一个任务队列, 这个任务队列是生产者和消费者通信的媒介; ThreadPoolExecutor 可以有多个工作线程, 但是这些工作线程都共享一个任务队列.</p> <p><strong>ForkJoinPool 本质上也是一个生产者-消费者的实现</strong>, 但是更加智能, 可以参考下面的 ForkJoinPool 工作原理图来理解其原理. <strong>ThreadPoolExecutor 内部只有一个任务队列, 而 ForkJoinPool 内部有多个任务队列, 当通过 ForkJoinPool 的 invoke() 或者 submit() 方法提交任务时, ForkJoinPool 根据一定的路由规则把任务提交到一个任务队列中, 如果任务在执行过程中会创建出子任务, 那么子任务会提交到工作线程对应的任务队列中</strong>.</p> <p>如果工作线程对应的任务队列空了, 是不是就没活儿干了呢? 不是的, ForkJoinPool 支持一种叫做 &quot;<strong>任务窃取</strong>&quot; 的机制, 如果工作线程空闲了, 那它可以 &quot;窃取&quot; 其他工作任务队列里的任务, 例如下图中, 线程 T2 对应的任务队列已经空了, 它可以 &quot;窃取&quot; 线程 T1 对应的任务队列的任务. 如此一来, 所有的工作线程都不会闲下来了.</p> <p>ForkJoinPool 中的任务队列采用的是<strong>双端队列</strong>, 工作线程正常获取任务和 &quot;窃取任务&quot; 分别是从任务队列不同的端消费, 这样能避免很多不必要的数据竞争. 这里介绍的仅仅是简化后的原理, ForkJoinPool 的实现远比这里介绍的复杂, 如果你感兴趣, 建议去看它的源码.</p> <p><img src="/img/d6861169089dd30df194cd99edfc40e0-20230731162452-04u5x6i.png" alt="" title="ForkJoinPool工作原理图"></p> <h5 id="模拟mapreduce统计单词数量"><a href="#模拟mapreduce统计单词数量" class="header-anchor">#</a> 模拟MapReduce统计单词数量</h5> <p>学习 MapReduce 有一个入门程序, 统计一个文件里面每个单词的数量, 下面来看看如何用 Fork/Join 并行计算框架来实现.</p> <p>可以先用二分法递归地将一个文件拆分成更小的文件, 直到文件里只有一行数据, 然后统计这一行数据里单词的数量, 最后再逐级汇总结果, 可以对照前面的简版分治任务模型图来理解这个过程.</p> <p>思路有了, 马上来实现. 下面的示例程序用一个字符串数组 <code>String[] fc</code>​ 来模拟文件内容, fc 里面的元素与文件里面的行数据一一对应. 关键的代码在 <code>compute()</code>​ 这个方法里面, 这是一个<strong>递归方法</strong>, 前半部分数据 fork 一个递归任务去处理(关键代码 mr1.fork()), 后半部分数据则在当前任务中递归处理(mr2.compute()).</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">void</span> main <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fc <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">,</span>
            <span class="token string">&quot;hello me&quot;</span><span class="token punctuation">,</span>
            <span class="token string">&quot;hello fork&quot;</span><span class="token punctuation">,</span>
            <span class="token string">&quot;hello join&quot;</span><span class="token punctuation">,</span>
            <span class="token string">&quot;fork join in world&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建 ForkJoin 线程池  </span>
    <span class="token class-name">ForkJoinPool</span> fjp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建任务  </span>
    <span class="token class-name">MR</span> mr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MR</span><span class="token punctuation">(</span>fc<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> fc<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 启动任务  </span>
    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> fjp<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>mr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 输出结果  </span>
    result<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token string">&quot;:&quot;</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// MR 模拟类</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MR</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fc<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> end<span class="token punctuation">;</span>

    <span class="token comment">// 构造函数</span>
    <span class="token function">MR</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fc<span class="token punctuation">,</span> <span class="token keyword">int</span> fr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>fc <span class="token operator">=</span> fc<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> fr<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> <span class="token keyword">to</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">calc</span><span class="token punctuation">(</span>fc<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token class-name">MR</span> mr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MR</span><span class="token punctuation">(</span>fc<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
            mr1<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">MR</span> mr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MR</span><span class="token punctuation">(</span>fc<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 计算子任务, 并返回合并的结果  </span>
            <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span>mr2<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mr1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 合并结果</span>
    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> r1<span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> r2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span>r1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 合并结果</span>
        r2<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">Long</span> c <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> c <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 统计单词数量</span>
    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token class-name">String</span> line<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 分割单词  </span>
        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> words <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;\\s+&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 统计单词数量  </span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> w <span class="token operator">:</span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Long</span> v <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br></div></div><h5 id="总结-19"><a href="#总结-19" class="header-anchor">#</a> 总结</h5> <p>Fork/Join 并行计算框架主要解决的是<strong>分治任务</strong>. 分治的核心思想是&quot;分而治之&quot;: 将一个大的任务拆分成小的子任务去解决, 然后再把子任务的结果聚合起来从而得到最终结果. 这个过程非常类似于大数据处理中的 MapReduce, 所以可以把 Fork/Join 看作单机版的 MapReduce.</p> <p>Fork/Join 并行计算框架的核心组件是 ForkJoinPool. <strong>ForkJoinPool 支持任务窃取机制, 能够让所有线程的工作量基本均衡, 不会出现有的线程很忙, 而有的线程很闲的状况, 所以性能很好</strong>. Java 1.8 提供的 Stream API 里面并行流也是以 ForkJoinPool 为基础的. <mark><strong>不过需要注意的是, 默认情况下所有的并行流计算都共享一个 ForkJoinPool, 这个共享的 ForkJoinPool 默认的线程数是 CPU 的核数; 如果所有的并行流计算都是 CPU 密集型计算的话, 完全没有问题, 但是如果存在 I/O 密集型的并行流计算, 那么很可能会因为一个很慢的 I/O 计算而拖慢整个系统的性能. 所以建议用不同的 ForkJoinPool 执行不同类型的计算任务</strong></mark>.</p> <h3 id="并发设计模式"><a href="#并发设计模式" class="header-anchor">#</a> 并发设计模式</h3> <h4 id="_28-immutability模式-如何利用不变性解决并发问题"><a href="#_28-immutability模式-如何利用不变性解决并发问题" class="header-anchor">#</a> 28-Immutability模式:如何利用不变性解决并发问题?</h4> <p>前面说过, &quot;多个线程同时<strong>读写</strong>同一共享变量存在并发问题&quot;, 这里的<strong>必要条件之一是读写, 如果只有读, 而没有写, 是没有并发问题的</strong>.</p> <p>解决并发问题, 其实最简单的办法就是<mark><strong>让共享变量只有读操作, 而没有写操作</strong></mark>. 这个办法如此重要, 以至于被上升到了一种解决并发问题的设计模式: <strong>不变性(Immutability)模式</strong>. 所谓<strong>不变性, 简单来讲, 就是对象一旦被创建之后, 状态就不再发生变化</strong>. 换句话说, 就是变量一旦被赋值, 就不允许修改了(没有写操作); 没有修改操作, 也就是保持了不变性.</p> <h5 id="快速实现具备不可变性的类"><a href="#快速实现具备不可变性的类" class="header-anchor">#</a> 快速实现具备不可变性的类</h5> <p>实现一个具备不可变性的类, 还是挺简单的. <mark><strong>将一个类所有的属性都设置成 final 的, 并且只允许存在只读方法, 那么这个类基本上就具备不可变性了</strong></mark>​<mark>. 更严格的做法是</mark>​<mark><strong>这个类本身也是 final 的</strong></mark>, 也就是不允许继承. 因为子类可以覆盖父类的方法, 有可能改变不可变性, 所以推荐在实际工作中, 使用这种更严格的做法.</p> <p>Java SDK 里很多类都具备不可变性, 只是由于它们的使用太简单, 最后反而被忽略了. 例如经常用到的 String 和 Long, Integer, Double 等基础类型的包装类都具备不可变性, 这些对象的线程安全性都是靠不可变性来保证的. 如果仔细翻看这些类的声明, 属性和方法, 你会发现它们都严格遵守不可变类的三点要求: <mark><strong>类和属性都是 final 的, 所有方法均是只读的</strong></mark>.</p> <p>看到这里你可能会疑惑, Java 的 String 方法也有类似字符替换操作, 怎么能说所有方法都是只读的呢? 结合 String 的源代码来解释一下这个问题, 下面的示例代码源自 Java 1.8 SDK, 略做了修改, 仅保留了关键属性 value[] 和 replace() 方法, 你会发现: <strong>String 这个类以及它的属性 value[] 都是 final 的; 而 replace() 方法的实现, 就的确没有修改 value[], 而是将替换后的字符串作为返回值返回了</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// 字符替换</span>
    <span class="token class-name">String</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token keyword">char</span> oldChar<span class="token punctuation">,</span> <span class="token keyword">char</span> newChar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 无需替换, 直接返回 this  </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldChar <span class="token operator">==</span> newChar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">int</span> len <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">/* avoid getfield opcode */</span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> val <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token comment">// 定位到需要替换的字符位置</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>val<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> oldChar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 未找到 oldChar, 无需替换</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 创建一个 buf[], 这是关键</span>
        <span class="token comment">// 用来保存替换后的字符串</span>
        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            buf<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">char</span> c <span class="token operator">=</span> val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> oldChar<span class="token punctuation">)</span> <span class="token operator">?</span> newChar <span class="token operator">:</span> c<span class="token punctuation">;</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 创建一个新的字符串返回</span>
        <span class="token comment">// 原字符串不会发生任何变化</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><p>通过分析 String 的实现, 你可能已经发现了, 如果<strong>具备不可变性的类, 需要提供类似修改的功能</strong>, 具体该怎么操作呢? 做法很简单, 那就是<mark><strong>创建一个新的不可变对象</strong></mark>, 这是与可变对象的一个重要区别, 可变对象往往是修改自己的属性.</p> <p>所有的修改操作都创建一个新的不可变对象, 你可能会有这种担心: <strong>是不是创建的对象太多了, 有点太浪费内存呢? 是的, 这样做的确有些浪费, 那如何解决呢</strong>?</p> <h5 id="利用享元模式避免创建重复对象"><a href="#利用享元模式避免创建重复对象" class="header-anchor">#</a> 利用享元模式避免创建重复对象</h5> <p>如果你熟悉面向对象相关的设计模式, 相信你一定能想到**享元模式(Flyweight Pattern). 利用享元模式可以减少创建对象的数量, 从而减少内存占用. **Java 语言里面 Long, Integer, Short, Byte 等这些基本数据类型的包装类都用到了享元模式.</p> <p>下面就以 Long 这个类作为例子, 看看它是如何利用享元模式来优化对象的创建的.</p> <p>享元模式本质上其实就是一个<strong>对象池</strong>, 利用享元模式创建对象的逻辑也很简单: <strong>创建之前, 首先去对象池里看看是不是存在; 如果已经存在, 就利用对象池里的对象; 如果不存在, 就会新创建一个对象, 并且把这个新创建出来的对象放进对象池里</strong>.</p> <p>Long 这个类并没有照搬享元模式, Long 内部维护了一<strong>个静态的对象池, 仅缓存了 [-128,127] 之间的数字</strong>, 这个对象池在 JVM 启动的时候就创建好了, 而且这个对象池一直都不会变化, 也就是说它是静态的. 之所以采用这样的设计, 是因为 Long 这个对象的状态共有 2^64 种, 实在太多, 不宜全部缓存, 而 [-128,127] 之间的数字利用率最高. 下面的示例代码出自 Java 1.8, valueOf() 方法就用到了 LongCache 这个缓存, 你可以结合着来加深理解.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Long</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">long</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> offset <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>
    <span class="token comment">// [-128,127] 直接的数字做了缓存</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&gt;=</span> <span class="token operator">-</span><span class="token number">128</span> <span class="token operator">&amp;&amp;</span> l <span class="token operator">&lt;=</span> <span class="token number">127</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">LongCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> l <span class="token operator">+</span> offset<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 缓存, 等价于对象池</span>
<span class="token comment">// 仅缓存 [-128,127] 直接的数字</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LongCache</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Long</span> cache<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">127</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p><mark><strong>前面提到 &quot;Integer 和 String 类型的对象不适合做锁&quot;, 其实基本上所有的基础类型的包装类都不适合做锁, 因为它们内部用到了享元模式, 这会导致看上去私有的锁, 其实是共有的</strong></mark>. 例如在下面代码中, 本意是 A 用锁 al, B 用锁 bl, 各自管理各自的, 互不影响. 但实际上 al 和 bl 是一个对象, 结果 A 和 B 共用的是一把锁.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token class-name">Long</span> al <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>al<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 省略代码无数</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token class-name">Long</span> bl <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>bl<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 省略代码无数</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h5 id="使用immutability模式的注意事项"><a href="#使用immutability模式的注意事项" class="header-anchor">#</a> 使用Immutability模式的注意事项</h5> <p>在使用 Immutability 模式的时候, 需要注意以下两点:</p> <ol><li><strong>对象的所有属性都是 final 的, 并不能保证不可变性</strong>;</li> <li><strong>不可变对象也需要正确发布</strong>.</li></ol> <p>在 Java 语言中, final 修饰的属性一旦被赋值, 就不可以再修改, 但是如果属性的类型是普通对象, 那么这个普通对象的属性是可以被修改的. 例如下面的代码中, Bar 的属性 foo 虽然是 final 的, 依然可以通过 setAge() 方法来设置 foo 的属性 age. 所以<strong>在使用 Immutability 模式的时候一定要确认保持不变性的边界在哪里, 是否要求属性对象也具备不可变性</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> name <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Foo</span> foo<span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        foo<span class="token punctuation">.</span>age <span class="token operator">=</span> a<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>下面再看看如何正确地发布不可变对象. 不可变对象虽然是线程安全的, <strong>但是并不意味着引用这些不可变对象的对象就是线程安全的</strong>. 例如在下面的代码中, Foo 具备不可变性, 线程安全, 但是类 Bar 并不是线程安全的, 类 Bar 中持有对 Foo 的引用 foo, 对 foo 这个引用的修改在多线程中并不能保证可见性和原子性.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Foo 线程安全</span>
<span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> name <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Bar 线程不安全</span>
<span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span>
    <span class="token class-name">Foo</span> foo<span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">setFoo</span><span class="token punctuation">(</span><span class="token class-name">Foo</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>foo <span class="token operator">=</span> f<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>如果你的程序仅仅需要 foo 保持可见性, 无需保证原子性, 那么可以将 foo 声明为 volatile 变量, 这样就能保证可见性. 如果你的程序需要保证原子性, 那么可以通过原子类来实现. 下面的示例代码是合理库存的原子化实现, 你应该很熟悉了, 其中就是用原子类解决了不可变对象引用的原子性问题.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SafeWM</span> <span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">WMRange</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> upper<span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> lower<span class="token punctuation">;</span>

        <span class="token class-name">WMRange</span><span class="token punctuation">(</span><span class="token keyword">int</span> upper<span class="token punctuation">,</span> <span class="token keyword">int</span> lower<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 省略构造函数实现</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">final</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">WMRange</span><span class="token punctuation">&gt;</span></span> rf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WMRange</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 设置库存上限</span>
    <span class="token keyword">void</span> <span class="token function">setUpper</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">WMRange</span> or <span class="token operator">=</span> rf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 检查参数合法性</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">&lt;</span> or<span class="token punctuation">.</span>lower<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">WMRange</span> nr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WMRange</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> or<span class="token punctuation">.</span>lower<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>rf<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>or<span class="token punctuation">,</span> nr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h5 id="总结-20"><a href="#总结-20" class="header-anchor">#</a> 总结</h5> <p>Java 语言里面的 String 和 Long, Integer, Double 等基础类型的包装类都具备不可变性, 这些对象的线程安全性都是靠不可变性来保证的. Immutability 模式是最简单的解决并发问题的方法, 当试图解决一个并发问题时, 可以尝试一下 Immutability 模式, 看是否能够快速解决.</p> <p><strong>具备不变性的对象, 只有一种状态, 这个状态由对象内部所有的不变属性共同决定</strong>. 其实还有一种更简单的不变性对象, 那就是<strong>无状态</strong>. 无状态对象内部没有属性, 只有方法. 除了无状态的对象, 你可能还听说过无状态的服务, 无状态的协议等等. 无状态有很多好处, 最核心的一点就是性能. 在多线程领域, 无状态对象没有线程安全问题, 无需同步处理, 自然性能很好; 在分布式领域, 无状态意味着可以无限地水平扩展, 所以分布式领域里面性能的瓶颈一定不是出在无状态的服务节点上.</p> <h4 id="_29-copy-on-write模式-不是延时策略的cow"><a href="#_29-copy-on-write模式-不是延时策略的cow" class="header-anchor">#</a> 29-Copy on Write模式:不是延时策略的COW</h4> <p>上一节讲到 Java 里 String 这个类在实现 replace() 方法的时候, 并没有更改原字符串里面 value[] 数组的内容, 而是创建了一个新字符串, 这种方法在解决不可变对象的修改问题时经常用到. 如果你深入地思考这个方法, 你会发现它本质上是一种 <strong>Copy-on-Write 方法</strong>. 所谓 Copy-on-Write, 经常被缩写为 COW 或者 CoW, 顾名思义就是<mark><strong>写时复制</strong></mark>.</p> <p><strong>不可变对象的写操作往往都是使用 Copy-on-Write 方法解决的, 当然 Copy-on-Write 的应用领域并不局限于 Immutability 模式</strong>. 下面先简单介绍一下 Copy-on-Write 的应用领域, 让你对它有个更全面的认识.</p> <h5 id="copy-on-write模式的应用领域"><a href="#copy-on-write模式的应用领域" class="header-anchor">#</a> Copy-on-Write模式的应用领域</h5> <p>前面介绍过 <strong>CopyOnWriteArrayList 和 CopyOnWriteArraySet</strong> 这两个 Copy-on-Write 容器, 它们背后的设计思想就是 Copy-on-Write; 通过 Copy-on-Write 这两个容器实现的<strong>读操作是无锁的, 由于无锁, 所以将读操作的性能发挥到了极致</strong>.</p> <p>除了 Java 这个领域, Copy-on-Write 在操作系统领域也有广泛的应用.</p> <p>我第一次接触 Copy-on-Write 其实就是在操作系统领域. 类 Unix 的操作系统中创建进程的 API 是 fork(), 传统的 fork() 函数会创建父进程的一个完整副本, 例如父进程的地址空间现在用到了 1G 的内存, 那么 fork() 子进程的时候要复制父进程整个进程的地址空间(占有 1G 内存)给子进程, 这个过程是很耗时的. 而 Linux 中的 fork() 函数就聪明得多了, fork() 子进程的时候, 并不复制整个进程的地址空间, 而是<strong>让父子进程共享同一个地址空间; 只用在父进程或者子进程需要写入的时候才会复制地址空间, 从而使父子进程拥有各自的地址空间</strong>.</p> <p>本质上来讲, 父子进程的地址空间以及数据都是要<strong>隔离</strong>的, 使用 Copy-on-Write 更多地体现的是一种<strong>延时策略, 只有在真正需要复制的时候才复制, 而不是提前复制好</strong>, 同时 Copy-on-Write 还支持按需复制, 所以 Copy-on-Write 在操作系统领域是能够提升性能的. 相比较而言, Java 提供的 Copy-on-Write 容器, 由于在修改的同时会复制整个容器, 所以在提升读操作性能的同时, <mark><strong>是以内存复制为代价的</strong></mark>. 这里你会发现, 同样是应用 Copy-on-Write, 不同的场景, 对性能的影响是不同的.</p> <p>在操作系统领域, 除了创建进程用到了 Copy-on-Write, 很多文件系统也同样用到了, 例如 Btrfs (B-Tree File System), aufs(advanced multi-layered unification filesystem)等.</p> <p>除了 Java 领域, 操作系统领域, 很多其他领域也都能看到 Copy-on-Write 的身影: Docker 容器镜像的设计是 Copy-on-Write, 甚至分布式源码管理系统 Git 背后的设计思想都有 Copy-on-Write.</p> <p>不过, <strong>Copy-on-Write 最大的应用领域还是在函数式编程领域</strong>. 函数式编程的基础是<strong>不可变性</strong>(Immutability), 所以函数式编程里面所有的修改操作都需要 Copy-on-Write 来解决. 你或许会有疑问, &quot;所有数据的修改都需要复制一份, 性能是不是会成为瓶颈呢?&quot; 你的担忧是有道理的, 之所以函数式编程早年间没有兴起, 性能绝对拖了后腿. 但是随着硬件性能的提升, 性能问题已经慢慢变得可以接受了. 而且, Copy-on-Write 也远不像 Java 里的 CopyOnWriteArrayList 那样笨: 整个数组都复制一遍. Copy-on-Write 也是可以按需复制的, 如果你感兴趣可以参考 Purely Functional Data Structures 这本书, 里面描述了各种具备不变性的数据结构的实现.</p> <p><strong>CopyOnWriteArrayList 和 CopyOnWriteArraySet 这两个 Copy-on-Write 容器在修改的时候会复制整个数组, 所以如果容器经常被修改或者这个数组本身就非常大的时候, 是不建议使用的</strong>. 反之, 如果是修改非常少, 数组数量也不大, 并且对读性能要求苛刻的场景, 使用 Copy-on-Write 容器效果就非常好了. 下面结合一个真实的案例来讲解一下.</p> <h5 id="一个真实案例"><a href="#一个真实案例" class="header-anchor">#</a> 一个真实案例</h5> <p>我曾经写过一个 RPC 框架, 有点类似 Dubbo, 服务提供方是多实例分布式部署的, 所以服务的客户端在调用 RPC 的时候, 会选定一个服务实例来调用, 这个选定的过程本质上就是在做负载均衡, 而做负载均衡的前提是客户端要有全部的路由信息. 例如在下图中, A 服务的提供方有 3 个实例, 分别是 192.168.1.1, 192.168.1.2 和 192.168.1.3, 客户端在调用目标服务 A 前, 首先需要做的是负载均衡, 也就是从这 3 个实例中选出 1 个来, 然后再通过 RPC 把请求发送选中的目标实例.</p> <p><img src="/img/42e5276fe9654cb99311a124876f71e6-20230731162452-wiffdm8.png" alt="" title="RPC 路由关系图"></p> <p>RPC 框架的一个核心任务就是维护服务的路由关系, 可以把服务的路由关系简化成下图所示的路由表. 当服务提供方上线或者下线的时候, 就需要更新客户端的这张路由表.</p> <p><img src="/img/d1e9b9471432d3ae4bc1e2909aa3fb47-20230731162452-6hskmaq.png" alt=""></p> <p>首先来分析一下如何用程序来实现. 每次 RPC 调用都需要通过负载均衡器来计算目标服务的 IP 和端口号, 而负载均衡器需要通过路由表获取接口的所有路由信息, 也就是说, <strong>每次 RPC 调用都需要访问路由表</strong>, 所以访问路由表这个操作的性能要求是很高的. 不过路由表对数据的一致性要求并不高, 一个服务提供方从上线到反馈到客户端的路由表里, 即便有 5 秒钟, 很多时候也都是能接受的(5 秒钟, 对于以纳秒作为时钟周期的 CPU 来说, 那何止是一万年, 所以路由表对一致性的要求并不高). 而且<strong>路由表是典型的读多写少类问题</strong>, 写操作的量相比于读操作, 可谓是沧海一粟, 少得可怜.</p> <p>通过以上分析, 你会发现一些关键词: 对读的性能要求很高, 读多写少, 弱一致性. 它们综合在一起, 你会想到什么呢? CopyOnWriteArrayList 和 CopyOnWriteArraySet 天生就适用这种场景啊. 所以下面的示例代码中, RouteTable 这个类内部通过 <code>ConcurrentHashMap&lt;String, CopyOnWriteArraySet&lt;Router&gt;&gt;</code>​ 这个数据结构来描述路由表, ConcurrentHashMap 的 Key 是接口名, Value 是路由集合, 这个路由集合是 CopyOnWriteArraySet.</p> <p>下面再来思考 Router 该如何设计, <strong>服务提供方的每一次上线, 下线都会更新路由信息</strong>, 这时候有两种选择. 一种是通过更新 Router 的一个状态位来标识, 如果这样做, 那么所有访问该状态位的地方都需要同步访问, 这样很影响性能. 另外一种就是采用 Immutability 模式, <strong>每次上线, 下线都创建新的 Router 对象或者删除对应的 Router 对象. 由于上线, 下线的频率很低, 所以后者是最好的选择</strong>.</p> <p>Router 的实现代码如下所示, 是一种典型 Immutability 模式的实现, 需要注意的是<strong>重写了 equals 方法</strong>, 这样 CopyOnWriteArraySet 的 add() 和 remove() 方法才能正常工作.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 路由信息</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Router</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> ip<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Integer</span> port<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> iface<span class="token punctuation">;</span>

    <span class="token comment">// 构造函数</span>
    <span class="token keyword">public</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token class-name">String</span> ip<span class="token punctuation">,</span> <span class="token class-name">Integer</span> port<span class="token punctuation">,</span> <span class="token class-name">String</span> iface<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>ip <span class="token operator">=</span> ip<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>port <span class="token operator">=</span> port<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>iface <span class="token operator">=</span> iface<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 重写 equals 方法</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Router</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Router</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Router</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span>
            <span class="token keyword">return</span> iface<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>iface<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> ip<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>ip<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> port<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 省略 hashCode 相关代码</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 路由表信息</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RouterTable</span> <span class="token punctuation">{</span>
    <span class="token comment">// Key: 接口名</span>
    <span class="token comment">// Value: 路由集合</span>
    <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">CopyOnWriteArraySet</span><span class="token punctuation">&lt;</span><span class="token class-name">Router</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> rt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 根据接口名获取路由表</span>
    <span class="token keyword">public</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Router</span><span class="token punctuation">&gt;</span></span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">String</span> iface<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> rt<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>iface<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 删除路由</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Router</span> router<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Router</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> rt<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>router<span class="token punctuation">.</span>iface<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>set <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>router<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 增加路由</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Router</span> router<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Router</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> rt<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>route<span class="token punctuation">.</span>iface<span class="token punctuation">,</span> r <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArraySet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>router<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br></div></div><h5 id="总结-21"><a href="#总结-21" class="header-anchor">#</a> 总结</h5> <p>目前 Copy-on-Write 在 Java 并发编程领域知名度不是很高, 很多人都在无意中把它忽视了, 但其实 Copy-on-Write 才是最简单的并发解决方案. 它是如此简单, 以至于 Java 中的基本数据类型 String, Integer, Long 等都是基于 Copy-on-Write 方案实现的.</p> <p><strong>Copy-on-Write 是一项非常通用的技术方案, 在很多领域都有着广泛的应用. 不过, 它也有缺点的, 那就是消耗内存, 每次修改都需要复制一个新的对象出来</strong>, 好在随着自动垃圾回收(GC)算法的成熟以及硬件的发展, 这种内存消耗已经渐渐可以接受了. 所以在实际工作中, 如果写操作非常少, 那你就可以尝试用一下 Copy-on-Write, 效果还是不错的.</p> <h4 id="_30-线程本地存储模式-没有共享-就没有伤害🍀"><a href="#_30-线程本地存储模式-没有共享-就没有伤害🍀" class="header-anchor">#</a> 30-线程本地存储模式:没有共享,就没有伤害🍀</h4> <p>民国年间某山东省主席参加某大学校庆演讲, 在篮球场看到十来个人穿着裤衩抢一个球, 观之实在不雅, 于是怒斥学校的总务处长贪污, 并且发话: &quot;多买几个球, 一人发一个, 省得你争我抢!&quot; 小时候听到这个段子只是觉得好玩, 今天再来看, 却别有一番滋味. 为什么呢? 因为其间蕴藏着解决并发问题的一个重要方法: <mark><strong>避免共享</strong></mark>.</p> <p>多个线程同时读写同一共享变量存在并发问题. 前面两节突破的是写, 没有写操作自然没有并发问题了. 其实还可以<strong>突破共享变量</strong>, 没有共享变量也不会有并发问题, 正所谓是<strong>没有共享, 就没有伤害</strong>.</p> <p>那如何避免共享呢? 思路其实很简单, 多个人争一个球总容易出矛盾, 那就每个人发一个球. 对应到并发编程领域, 就是<strong>每个线程都拥有自己的变量, 彼此之间不共享, 也就没有并发问题</strong>了.</p> <p>前面提到过<strong>线程封闭</strong>, 其本质上就是避免共享. 通过局部变量可以做到避免共享, 那还有没有其他方法可以做到呢? 有的, <strong>Java 语言提供的线程本地存储(ThreadLocal)就能够做到</strong>. 下面先看看 ThreadLocal 到底该如何使用.</p> <h5 id="threadlocal的使用方法"><a href="#threadlocal的使用方法" class="header-anchor">#</a> ThreadLocal的使用方法</h5> <p>下面这个<strong>静态类 ThreadId 会为每个线程分配一个唯一的线程 Id</strong>, 如果<strong>一个线程</strong>前后两次调用 ThreadId 的 get() 方法, 两次 get() 方法的返回值是相同的. 但如果是<strong>两个线程</strong>分别调用 ThreadId 的 get() 方法, 那么两个线程看到的 get() 方法的返回值是不同的. 若你是初次接触 ThreadLocal, 可能会觉得奇怪, 为什么<strong>相同线程调用 get() 方法结果就相同, 而不同线程调用 get() 方法结果就不同</strong>呢?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadId</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">AtomicLong</span> nextId <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 定义 ThreadLocal 变量</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> tl <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> nextId<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 此方法会为每个线程分配一个唯一的 Id</span>
    <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> tl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>能有这个奇怪的结果, 都是 ThreadLocal 的杰作, 不过在详细解释 ThreadLocal 的工作原理之前, 再看一个实际工作中可能遇到的例子来加深一下对 ThreadLocal 的理解. 你可能知道 SimpleDateFormat 不是线程安全的, 那如果需要在并发场景下使用它, 你该怎么办呢?</p> <p>其实有一个办法就是用 ThreadLocal 来解决, 下面的示例代码就是 <strong>ThreadLocal 解决方案</strong>的具体实现, 这段代码与前面 ThreadId 的代码高度相似, 同样地, 不同线程调用 SafeDateFormat 的 get() 方法将返回不同的 SimpleDateFormat 对象实例, <strong>由于不同线程并不共享 SimpleDateFormat, 所以就像局部变量一样, 是线程安全的</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SafeDateFormat</span> <span class="token punctuation">{</span>
    <span class="token comment">// 定义 ThreadLocal 变量</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DateFormat</span><span class="token punctuation">&gt;</span></span> tl <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span>
            <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token class-name">DateFormat</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> tl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 不同线程执行下面代码</span>
<span class="token comment">// 返回的 df 是不同的</span>
<span class="token class-name">DateFormat</span> df <span class="token operator">=</span> <span class="token class-name">SafeDateFormat</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>通过上面两个例子, 相信你对 ThreadLocal 的用法以及应用场景都了解了, 下面就来详细解释 ThreadLocal 的工作原理.</p> <h5 id="threadlocal的工作原理"><a href="#threadlocal的工作原理" class="header-anchor">#</a> ThreadLocal的工作原理</h5> <p>在解释 ThreadLocal 的工作原理之前, 先自己想想: 如果让你来实现 ThreadLocal 的功能, 你会怎么设计呢? <strong>ThreadLocal 的目标是让不同的线程有不同的变量 V, 那最直接的方法就是创建一个 Map, 它的 Key 是线程, Value 是每个线程拥有的变量 V, ThreadLocal 内部持有这样的一个 Map 就可以了</strong>. 你可以参考下面的示意图和示例代码来理解.</p> <p><img src="/img/6a8fd6021988dff01aabf3fdab6c6da2-20230731162452-6yrxlid.png" alt="" title="ThreadLocal 持有 Map 的示意图"></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">MyThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> locals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 获取线程变量  </span>
    <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> locals<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 设置线程变量</span>
    <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        locals<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>那 Java 的 ThreadLocal 是这么实现的吗? 这一次的设计思路和 Java 的实现差异很大. Java 的实现里面也有一个 Map, <strong>叫做 ThreadLocalMap, 不过持有 ThreadLocalMap 的不是 ThreadLocal, 而是 Thread</strong>. Thread 这个类内部有一个私有属性 threadLocals, 其类型就是 ThreadLocalMap, ThreadLocalMap 的 Key 是 ThreadLocal. 可以结合下面的示意图和精简之后的 Java 实现代码来理解.</p> <p><img src="/img/58df97ed0581cc8edaeaac43feda7573-20230731162452-odqyr2d.png" alt="" title="Thread 持有 ThreadLocalMap 的示意图"></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token comment">// 内部持有 ThreadLocalMap</span>
    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> threadLocals<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 首先获取线程持有的</span>
        <span class="token comment">//ThreadLocalMap</span>
        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span>
        <span class="token comment">// 在 ThreadLocalMap 中</span>
        <span class="token comment">// 查找变量</span>
        <span class="token class-name">Entry</span> e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{</span>
        <span class="token comment">// 内部是数组而不是 Map</span>
        <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>

        <span class="token comment">// 根据 ThreadLocal 查找 Entry</span>
        <span class="token class-name">Entry</span> <span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 省略查找逻辑</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//Entry 定义</span>
        <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
            <span class="token class-name">Object</span> value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>初看上去, 简易的设计方案和 Java 的实现仅仅是 Map 的持有方不同而已, 简易的设计里面 Map 属于 ThreadLocal, 而 Java 的实现里面 ThreadLocalMap 则是属于 Thread. 这两种方式哪种更合理呢? 很显然 Java 的实现更合理一些. <strong>在 Java 的实现方案里面, ThreadLocal 仅仅是一个代理工具类, 内部并不持有任何与线程相关的数据, 所有和线程相关的数据都存储在 Thread 里面</strong>, 这样的设计容易理解. 而从数据的亲缘性上来讲, ThreadLocalMap 属于 Thread 也更加合理.</p> <p>当然还有一个更加深层次的原因, 那就是<strong>不容易产生内存泄露</strong>. 在简易的设计方案中, ThreadLocal 持有的 Map 会持有 Thread 对象的引用, 这就意味着, <strong>只要 ThreadLocal 对象存在, 那么 Map 中的 Thread 对象就永远不会被回收</strong>. ThreadLocal 的生命周期往往都比线程要长, 所以这种设计方案很容易导致内存泄露. 而 Java 的实现中 Thread 持有 ThreadLocalMap, 而且 ThreadLocalMap 里对 ThreadLocal 的引用还是弱引用(WeakReference), <strong>所以只要 Thread 对象可以被回收, 那么 ThreadLocalMap 就能被回收</strong>. Java 的这种实现方案虽然看上去复杂一些, 但是更加安全.</p> <p>Java 的 ThreadLocal 实现应该称得上深思熟虑了, 不过即便如此深思熟虑, <strong>还是不能百分百地让程序员避免内存泄露, 例如在线程池中使用 ThreadLocal, 如果不谨慎就可能导致内存泄露</strong>.</p> <h5 id="threadlocal与内存泄露"><a href="#threadlocal与内存泄露" class="header-anchor">#</a> ThreadLocal与内存泄露</h5> <p>在线程池中使用 ThreadLocal 为什么可能导致内存泄露呢? 原因就出在<mark><strong>线程池</strong></mark>​<strong>中线程的存活时间太长, 往往都是和程序同生共死的, 这就意味着 Thread 持有的 ThreadLocalMap 一直都不会被回收, 再加上 ThreadLocalMap 中的 Entry 对 ThreadLocal 是弱引用(WeakReference), 所以只要 ThreadLocal 结束了自己的生命周期是可以被回收掉的. 但是 Entry 中的 Value 却是被 Entry 强引用的, 所以即便 Value 的生命周期结束了, Value 也是无法被回收的, 从而导致内存泄露</strong>.</p> <p>那在线程池中, 该如何正确使用 ThreadLocal 呢? 其实很简单, 既然 JVM 不能做到自动释放对 Value 的强引用, 那手动释放就可以了. 如何能做到手动释放呢? 估计你马上想到 <strong>try{}finally{} 方案</strong>了, 这个简直就是<strong>手动释放资源的利器</strong>. 示例的代码如下.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ExecutorService</span> es<span class="token punctuation">;</span>
<span class="token class-name">ThreadLocal</span> tl<span class="token punctuation">;</span>
es<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// ThreadLocal 增加变量</span>
    tl<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 省略业务逻辑代码</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 手动清理 ThreadLocal </span>
        tl<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h5 id="inheritablethreadlocal与继承性"><a href="#inheritablethreadlocal与继承性" class="header-anchor">#</a> InheritableThreadLocal与继承性</h5> <p><strong>通过 ThreadLocal 创建的线程变量, 其子线程是无法继承的</strong>. 也就是说<strong>在线程中通过 ThreadLocal 创建了线程变量 V, 而后该线程创建了子线程, 在子线程中是无法通过 ThreadLocal 来访问父线程的线程变量 V 的</strong>.</p> <p>如果需要子线程继承父线程的线程变量, 那该怎么办呢? 其实很简单, Java 提供了 InheritableThreadLocal 来支持这种特性, InheritableThreadLocal 是 ThreadLocal 子类, 所以用法和 ThreadLocal 相同, 这里就不多介绍了.</p> <p>不过, <strong>完全不建议在线程池中使用 InheritableThreadLocal</strong>, 不仅仅是因为它具有 ThreadLocal 相同的缺点-可能导致内存泄露, 更重要的原因是: 线程池中线程的创建是动态的, 很容易导致继承关系错乱, 如果业务逻辑依赖 InheritableThreadLocal, 那么很可能导致业务逻辑计算错误, 而这个错误往往比内存泄露更要命.</p> <h5 id="总结-22"><a href="#总结-22" class="header-anchor">#</a> 总结</h5> <p>线程本地存储模式本质上是一种避免共享的方案, 由于没有共享, 所以自然也就没有并发问题. 如果你需要在并发场景中使用一个线程不安全的工具类, 最简单的方案就是<strong>避免共享</strong>. 避免共享有两种方案, 一种方案是将这个工具类作为<strong>局部变量使用</strong>, 另外一种方案就是<strong>线程本地存储模式</strong>. 这两种方案, 局部变量方案的缺点是在高并发场景下会频繁创建对象, 而线程本地存储方案, 每个线程只需要创建一个工具类的实例, 所以不存在频繁创建对象的问题.</p> <p>线程本地存储模式是解决并发问题的常用方案, 所以 Java SDK 也提供了相应的实现: <strong>ThreadLocal</strong>. 通过上面的分析, 你应该能体会到 Java SDK 的实现已经是深思熟虑了, 不过即便如此, 仍不能尽善尽美, 例如<strong>在线程池中使用 ThreadLocal 仍可能导致内存泄漏</strong>, 所以使用 ThreadLocal 还是需要足够谨慎.</p> <h4 id="_31-guarded-suspension模式-等待唤醒机制的规范实现"><a href="#_31-guarded-suspension模式-等待唤醒机制的规范实现" class="header-anchor">#</a> 31-Guarded Suspension模式:等待唤醒机制的规范实现</h4> <p>前不久, 同事小灰工作中遇到一个问题, 他开发了一个 Web 项目: Web 版的文件浏览器, 通过它用户可以在浏览器里查看服务器上的目录和文件. 这个项目依赖运维部门提供的文件浏览服务, 而这个文件浏览服务只支持消息队列(MQ)方式接入. 消息队列在互联网大厂中用的非常多, 主要用作流量削峰和系统解耦. 在这种接入方式中, 发送消息和消费结果这两个操作之间是异步的, 可以参考下面的示意图来理解.</p> <p><img src="/img/7db95a5bd8218b3ee3bbd8f7c3722ec5-20230731162452-grlbooj.png" alt="" title="消息队列(MQ)示意图"></p> <p>在小灰的这个 Web 项目中, 用户通过浏览器发过来一个请求, 会被转换成一个异步消息发送给 MQ, 等 MQ 返回结果后, 再将这个结果返回至浏览器. 小灰同学的问题是: <strong>给 MQ 发送消息的线程是处理 Web 请求的线程 T1, 但消费 MQ 结果的线程并不是线程 T1, 那线程 T1 如何等待 MQ 的返回结果呢</strong>? 为便于理解这个场景, 我将其代码化了, 示例代码如下.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Message</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> id<span class="token punctuation">;</span>
    <span class="token class-name">String</span> content<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 该方法可以发送消息</span>
<span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">Message</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略相关代码</span>
<span class="token punctuation">}</span>

<span class="token comment">// MQ 消息返回后会调用该方法</span>
<span class="token comment">// 该方法的执行线程不同于</span>
<span class="token comment">// 发送消息的线程</span>
<span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token class-name">Message</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略相关代码</span>
<span class="token punctuation">}</span>

<span class="token comment">// 处理浏览器发来的请求</span>
<span class="token class-name">Respond</span> <span class="token function">handleWebReq</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建一消息</span>
    <span class="token class-name">Message</span> msg1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;{...}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 发送消息</span>
    <span class="token function">send</span><span class="token punctuation">(</span>msg1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如何等待 MQ 返回的消息呢? </span>
    <span class="token class-name">String</span> result <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>看到这里, 相信你一定有点似曾相识的感觉, 这不就是前面曾介绍过的<strong>异步转同步</strong>问题吗? 仔细分析, 的确是这样, 不过在那一节只是介绍了最终方案, 让你知其然, 但是并没有介绍这个方案是如何设计出来的, 今天再仔细聊聊这个问题, 让你知其所以然, 遇到类似问题也能自己设计出方案来.</p> <h5 id="guarded-suspension模式"><a href="#guarded-suspension模式" class="header-anchor">#</a> Guarded Suspension模式</h5> <p>上面小灰遇到的问题, 在现实世界里比比皆是, 只是大家一不小心就忽略了. 比如, 项目组团建要外出聚餐, 大家提前预订了一个包间, 然后兴冲冲地奔过去, 到那儿后大堂经理看了一眼包间, 发现服务员正在收拾, 就会告诉我们: &quot;您预订的包间服务员正在收拾, 请您稍等片刻.&quot; 过了一会, 大堂经理发现包间已经收拾完了, 于是马上带大家去包间就餐.</p> <p>大家等待包间收拾完的这个过程和小灰遇到的等待 MQ 返回消息本质上是一样的, 都是<strong>等待一个条件满足</strong>: 就餐需要等待包间收拾完, 小灰的程序里要等待 MQ 返回消息.</p> <p>来看看现实世界里是如何解决这类问题的呢? 现实世界里<strong>大堂经理这个角色</strong>很重要, 是否等待完全是由他来协调的. 通过类比, 相信你也一定有思路了: 程序里也需要这样一个大堂经理. 的确是这样, 那程序世界里的大堂经理该如何设计呢? 其实设计方案前人早就搞定了, 而且还将其总结成了一个设计模式: <strong>Guarded Suspension</strong>. 所谓 Guarded Suspension, 直译过来就是 &quot;保护性地暂停&quot;. 那下面就来看看, Guarded Suspension 模式是如何模拟大堂经理进行保护性地暂停的.</p> <p>下图就是 Guarded Suspension 模式的结构图, 非常简单, <strong>一个对象 GuardedObjec</strong>t, 内部有一个成员变量——受保护的对象, 以及两个成员方法 <code>get(Predicate&lt;T&gt; p)</code>​ 和 <code>onChanged(T obj)</code>​ 方法. 其中, 对象 GuardedObject 就是大堂经理, 受保护对象就是餐厅里面的包间; 受保护对象的 get() 方法对应的是就餐, 就餐的前提条件是包间已经收拾好了, 参数 p 就是用来描述这个前提条件的; 受保护对象的 onChanged() 方法对应的是服务员把包间收拾好了, 通过 onChanged() 方法可以 fire 一个事件, 而这个事件往往能改变前提条件 p 的计算结果. 下图中, 左侧的绿色线程就是需要就餐的顾客, 而右侧的蓝色线程就是收拾包间的服务员.</p> <p>​<img src="/img/df25930c41752d8e8991a758f3b87e33-20230731162452-y4m3t8w.png" alt="" title="Guarded Suspension 模式结构图">​</p> <p>GuardedObject 的内部实现非常简单, 是<strong>管程</strong>的一个经典用法, 可以参考下面的示例代码, 核心是: <strong>get() 方法通过条件变量的 await() 方法实现等待, onChanged() 方法通过条件变量的 signalAll() 方法实现唤醒功能</strong>. 逻辑还是很简单的, 所以这里就不再详细介绍了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">GuardedObject</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 受保护的对象</span>
    <span class="token class-name">T</span> obj<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">Condition</span> done <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> timeout <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token comment">// 获取受保护对象  </span>
    <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// MESA 管程推荐写法</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                done<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span>timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 返回非空的受保护对象</span>
        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 事件通知方法</span>
    <span class="token keyword">void</span> <span class="token function">onChanged</span><span class="token punctuation">(</span><span class="token class-name">T</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> obj<span class="token punctuation">;</span>
            done<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h5 id="扩展guarded-suspension模式"><a href="#扩展guarded-suspension模式" class="header-anchor">#</a> 扩展Guarded Suspension模式</h5> <p>上面介绍了 Guarded Suspension 模式及其实现, 这个模式能够模拟现实世界里大堂经理的角色, 那现在再来看看这个&quot;大堂经理&quot;能否解决小灰同学遇到的问题.</p> <p>Guarded Suspension 模式里 GuardedObject 有两个核心方法, 一个是 get() 方法, 一个是 onChanged() 方法. 很显然, 在处理 Web 请求的方法 handleWebReq() 中, 可以<strong>调用 GuardedObject 的 get() 方法来实现等待; 在 MQ 消息的消费方法 onMessage() 中, 可以调用 GuardedObject 的 onChanged() 方法来实现唤醒</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 处理浏览器发来的请求</span>
<span class="token class-name">Respond</span> <span class="token function">handleWebReq</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建一消息</span>
    <span class="token class-name">Message</span> msg1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 发送消息</span>
    <span class="token function">send</span><span class="token punctuation">(</span>msg1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 利用 GuardedObject 实现等待</span>
    <span class="token class-name">GuardedObject</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">&gt;</span></span> go <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GuardObjec</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Message</span> r <span class="token operator">=</span> go<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>t <span class="token operator">-&gt;</span> t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token class-name">Message</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如何找到匹配的 go? </span>
    <span class="token class-name">GuardedObject</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">&gt;</span></span> go <span class="token operator">=</span> <span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span>
    go<span class="token punctuation">.</span><span class="token function">onChanged</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>但是在实现的时候会遇到一个问题, handleWebReq() 里面创建了 GuardedObject 对象的实例 go, 并调用其 get() 方等待结果, 那在 onMessage() 方法中, 如何才能够找到匹配的 GuardedObject 对象呢? 这个过程类似服务员告诉大堂经理某某包间已经收拾好了, 大堂经理如何根据包间找到就餐的人. 现实世界里, 大堂经理的头脑中, 有包间和就餐人之间的关系图, 所以服务员说完之后大堂经理立刻就能把就餐人找出来.</p> <p>可以参考大堂经理识别就餐人的办法, 来扩展一下 Guarded Suspension 模式, 从而使它能够很方便地解决小灰同学的问题. 在小灰的程序中, <strong>每个发送到 MQ 的消息, 都有一个唯一性的属性 id</strong>, 所以可以<strong>维护一个 MQ 消息 id 和 GuardedObject 对象实例的关系, 这个关系可以类比大堂经理大脑里维护的包间和就餐人的关系</strong>.</p> <p>有了这个关系, 来看看具体如何实现. 下面的示例代码是扩展 Guarded Suspension 模式的实现, 扩展后的 GuardedObject 内部维护了一个 <strong>Map</strong>, 其 Key 是 MQ 消息 id, 而 Value 是 GuardedObject 对象实例, 同时增加了静态方法 create() 和 fireEvent(); create() 方法用来创建一个 GuardedObject 对象实例, 并根据 key 值将其加入到 Map 中, 而 fireEvent() 方法则是模拟的大堂经理根据包间找就餐人的逻辑.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">GuardedObject</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 受保护的对象</span>
    <span class="token class-name">T</span> obj<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">Condition</span> done <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> timeout <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token comment">// 保存所有 GuardedObject</span>
    <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">GuardedObject</span><span class="token punctuation">&gt;</span></span> <span class="token constant">GO_MAP</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 静态方法创建 GuardedObject</span>
    <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">GuardedObject</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">GuardedObject</span> go <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GuardedObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token constant">GO_MAP</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> go<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> go<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">fireEvent</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">T</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">GuardedObject</span> go <span class="token operator">=</span> <span class="token constant">GO_MAP</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>go <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            go<span class="token punctuation">.</span><span class="token function">onChanged</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 获取受保护对象  </span>
    <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// MESA 管程推荐写法</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                done<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span>timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 返回非空的受保护对象</span>
        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 事件通知方法</span>
    <span class="token keyword">void</span> <span class="token function">onChanged</span><span class="token punctuation">(</span><span class="token class-name">T</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> obj<span class="token punctuation">;</span>
            done<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><p>这样利用扩展后的 GuardedObject 来解决小灰同学的问题就很简单了, 具体代码如下所示.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 处理浏览器发来的请求</span>
<span class="token class-name">Respond</span> <span class="token function">handleWebReq</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> id <span class="token operator">=</span> 序号生成器<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建一消息</span>
    <span class="token class-name">Message</span> msg1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token string">&quot;{...}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建 GuardedObject 实例</span>
    <span class="token class-name">GuardedObject</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">&gt;</span></span> go <span class="token operator">=</span> <span class="token class-name">GuardedObject</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 发送消息</span>
    <span class="token function">send</span><span class="token punctuation">(</span>msg1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 等待 MQ 消息</span>
    <span class="token class-name">Message</span> r <span class="token operator">=</span> go<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>t <span class="token operator">-&gt;</span> t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token class-name">Message</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 唤醒等待的线程</span>
    <span class="token class-name">GuardedObject</span><span class="token punctuation">.</span><span class="token function">fireEvent</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>id<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h5 id="总结-23"><a href="#总结-23" class="header-anchor">#</a> 总结</h5> <p><strong>Guarded Suspension 模式本质上是一种等待唤醒机制的实现</strong>, 只不过 Guarded Suspension 模式将其规范化了. 规范化的好处是你无需重头思考如何实现, 也无需担心实现程序的可理解性问题, 同时也能避免一不小心写出个 Bug 来. 但 Guarded Suspension 模式在解决实际问题的时候, 往往还是需要扩展的, 扩展的方式有很多, 本节就直接对 GuardedObject 的功能进行了增强, <strong>Dubbo 中 DefaultFuture 这个类也是采用的这种方式</strong>, 可以对比着来看, 相信对 DefaultFuture 的实现原理会理解得更透彻. 当然也可以创建新的类来实现对 Guarded Suspension 模式的扩展.</p> <p>Guarded Suspension 模式也常被<strong>称作 Guarded Wait 模式</strong>, Spin Lock 模式(因为使用了 while 循环去等待), 这些名字都很形象, 不过它还有一个更形象的非官方名字: 多线程版本的 if. 单线程场景中, if 语句是不需要等待的, 因为在只有一个线程的条件下, 如果这个线程被阻塞, 那就没有其他活动线程了, 这意味着 if 判断条件的结果也不会发生变化了. 但是多线程场景中, 等待就变得有意义了, 这种场景下, if 判断条件的结果是可能发生变化的. 所以, 用 &quot;多线程版本的 if&quot; 来理解这个模式会更简单.</p> <h4 id="_32-balking模式-再谈线程安全的单例模式"><a href="#_32-balking模式-再谈线程安全的单例模式" class="header-anchor">#</a> 32-Balking模式:再谈线程安全的单例模式</h4> <p>上一节提到可以用 &quot;多线程版本的 if&quot; 来理解 Guarded Suspension 模式, 不同于单线程中的 if, 这个 &quot;多线程版本的 if&quot; 是<strong>需要等待</strong>的, 而且还很执着, 必须要等到条件为真. 但很显然这个世界, 不是所有场景都需要这么执着, 有时候还需要快速放弃.</p> <p>需要快速放弃的一个最常见的例子是各种<strong>编辑器提供的自动保存功能</strong>. 自动保存功能的实现逻辑一般都是隔一定时间自动执行存盘操作, 存盘操作的前提是文件做过修改, 如果文件没有执行过修改操作, 就需要快速放弃存盘操作. 下面的示例代码将自动保存功能代码化了, 很显然 AutoSaveEditor 这个类不是线程安全的, 因为对共享变量 changed 的读写没有使用同步, 那如何保证 AutoSaveEditor 的线程安全性呢?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">AutoSaveEditor</span> <span class="token punctuation">{</span>
    <span class="token comment">// 文件是否被修改过</span>
    <span class="token keyword">boolean</span> changed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 定时任务线程池</span>
    <span class="token class-name">ScheduledExecutorService</span> ses <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadScheduledExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 定时执行自动保存</span>
    <span class="token keyword">void</span> <span class="token function">startAutoSave</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ses<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">autoSave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 自动存盘操作</span>
    <span class="token keyword">void</span> <span class="token function">autoSave</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>changed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        changed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token comment">// 执行存盘操作</span>
        <span class="token comment">// 省略且实现</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">execSave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 编辑操作</span>
    <span class="token keyword">void</span> <span class="token function">edit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 省略编辑逻辑</span>
        changed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>解决这个问题相信你一定手到擒来了: 读写共享变量 changed 的方法 autoSave() 和 edit() 都加互斥锁就可以了. 这样做虽然简单, 但是性能很差, 原因是锁的范围太大了. 那可以将锁的范围缩小, 只在读写共享变量 changed 的地方加锁, 实现代码如下所示.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 自动存盘操作</span>
<span class="token keyword">void</span> <span class="token function">autoSave</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>changed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        changed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 执行存盘操作</span>
    <span class="token comment">// 省略且实现</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">execSave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 编辑操作</span>
<span class="token keyword">void</span> <span class="token function">edit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略编辑逻辑</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        changed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>如果深入地分析一下这个示例程序, 可以发现, 示例中的共享变量是一个<strong>状态变量</strong>, 业务逻辑依赖于这个状态变量的状态: 当状态满足某个条件时, 执行某个业务逻辑, 其本质其实不过就是一个 if 而已, 放到多线程场景里, 就是一种 &quot;多线程版本的 if&quot;. <strong>这种 &quot;多线程版本的 if&quot; 的应用场景还是很多的, 所以也有人把它总结成了一种设计模式, 叫做 Balking 模式</strong>.</p> <h5 id="balking模式的经典实现"><a href="#balking模式的经典实现" class="header-anchor">#</a> Balking模式的经典实现</h5> <p><strong>Balking 模式本质上是一种规范化地解决 &quot;多线程版本的 if&quot; 的方案</strong>, 对于上面自动保存的例子, 使用 Balking 模式规范化之后的写法如下所示, 可以发现仅仅是将 edit() 方法中对共享变量 changed 的赋值操作抽取到了 change() 中, 这样的好处是<strong>将并发处理逻辑和业务逻辑</strong>分开.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">boolean</span> changed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token comment">// 自动存盘操作</span>
<span class="token keyword">void</span> <span class="token function">autoSave</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>changed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        changed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 执行存盘操作</span>
    <span class="token comment">// 省略且实现</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">execSave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 编辑操作</span>
<span class="token keyword">void</span> <span class="token function">edit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略编辑逻辑</span>
    <span class="token function">change</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 改变状态</span>
<span class="token keyword">void</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        changed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h5 id="用volatile实现balking模式"><a href="#用volatile实现balking模式" class="header-anchor">#</a> 用volatile实现Balking模式</h5> <p>前面用 synchronized 实现了 Balking 模式, 这种实现方式最为稳妥, 建议实际工作中也使用这个方案. 不过在某些特定场景下, 也可以使用 volatile 来实现, 但<strong>使用 volatile 的前提是对原子性没有要求</strong>.</p> <p>前面有一个 RPC 框架路由表的案例, 在 RPC 框架中, 本地路由表是要和注册中心进行信息同步的, 应用启动的时候, 会将应用依赖服务的路由表从注册中心同步到本地路由表中, 如果应用重启的时候注册中心宕机, 那么会导致该应用依赖的服务均不可用, 因为找不到依赖服务的路由表. 为了防止这种极端情况出现, <strong>RPC 框架可以将本地路由表自动保存到本地文件中, 如果重启的时候注册中心宕机, 那么就从本地文件中恢复重启前的路由表</strong>. 这其实也是一种降级的方案.</p> <p>自动保存路由表和前面介绍的编辑器自动保存原理是一样的, 也可以用 Balking 模式实现, 不过这里采用 volatile 来实现, 实现的代码如下所示. 之所以可以采用 volatile 来实现, 是因为<strong>对共享变量 changed 和 rt 的写操作不存在原子性的要求</strong>, 而且采用 scheduleWithFixedDelay() 这种调度方式能保证同一时刻只有一个线程执行 autoSave() 方法.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 路由表信息</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RouterTable</span> <span class="token punctuation">{</span>
    <span class="token comment">// Key: 接口名</span>
    <span class="token comment">// Value: 路由集合</span>
    <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">CopyOnWriteArraySet</span><span class="token punctuation">&lt;</span><span class="token class-name">Router</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> rt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 路由表是否发生变化</span>
    <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> changed<span class="token punctuation">;</span>
    <span class="token comment">// 将路由表写入本地文件的线程池</span>
    <span class="token class-name">ScheduledExecutorService</span> ses <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadScheduledExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 启动定时任务</span>
    <span class="token comment">// 将变更后的路由表写入本地文件</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">startLocalSaver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ses<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">autoSave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 保存路由表到本地文件</span>
    <span class="token keyword">void</span> <span class="token function">autoSave</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>changed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        changed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token comment">// 将路由表写入本地文件</span>
        <span class="token comment">// 省略其方法实现</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">save2Local</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 删除路由</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Router</span> router<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Router</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> rt<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>router<span class="token punctuation">.</span>iface<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>set <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>router<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 路由表已发生变化</span>
            changed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 增加路由</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Router</span> router<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Router</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> rt<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>route<span class="token punctuation">.</span>iface<span class="token punctuation">,</span> r <span class="token operator">-&gt;</span>
                <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArraySet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>router<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 路由表已发生变化</span>
        changed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><p>Balking 模式有一个非常典型的应用场景就是<strong>单次初始化</strong>, 下面的示例代码是它的实现. 这个实现方案中, 将 init() 声明为一个同步方法, <strong>这样同一个时刻就只有一个线程能够执行 init() 方法</strong>; init() 方法在第一次执行完时会将 inited 设置为 true, 这样后续执行 init() 方法的线程就不会再执行 doInit() 了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">InitTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> inited <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>inited<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 省略 doInit 的实现</span>
        <span class="token function">doInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        inited <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>线程安全的单例模式本质上其实也是单次初始化, 所以可以用 Balking 模式来实现线程安全的单例模式</strong>, 下面的示例代码是其实现. 这个实现虽然功能上没有问题, 但是性能却很差, 因为互斥锁 synchronized 将 getInstance() 方法串行化了, 那有没有办法可以优化一下它的性能呢?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span>
    <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>

    <span class="token comment">// 构造方法私有化  </span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 获取实例(单例)</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>办法当然是有的, 那就是经典的<strong>双重检查</strong>(Double Check)方案, 下面的示例代码是其详细实现. 在双重检查方案中, 一旦 Singleton 对象被成功创建之后, 就不会执行 synchronized(Singleton.class){} 相关的代码, 也就是说, 此时 getInstance() 方法的执行路径是<strong>无锁</strong>的, 从而解决了性能问题. 不过需要注意的是, 这个方案中<strong>使用了 volatile 来禁止编译优化</strong>, 其原因前面也提到过. 至于获取锁后的二次检查, 则是出于对安全性负责.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>

    <span class="token comment">// 构造方法私有化  </span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 获取实例(单例)</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 第一次检查</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            synchronize <span class="token punctuation">{</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token comment">// 获取锁后二次检查</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h5 id="总结-24"><a href="#总结-24" class="header-anchor">#</a> 总结</h5> <p>Balking 模式和 Guarded Suspension 模式从实现上看似乎没有多大的关系, Balking 模式只需要用互斥锁就能解决, 而 Guarded Suspension 模式则要用到管程这种高级的并发原语; 但是从应用的角度来看, 它们解决的都是 &quot;线程安全的 if&quot; 语义, 不同之处在于, Guarded Suspension 模式会等待 if 条件为真, 而 Balking 模式不会等待.</p> <p>Balking 模式的经典实现是使用<strong>互斥锁</strong>, 可以使用 Java 语言内置 synchronized, 也可以使用 SDK 提供 Lock; 如果对互斥锁的性能不满意, 可以尝试采用 volatile 方案, 不过使用 volatile 方案需要更加谨慎.</p> <p>当然也可以尝试使用双重检查方案来优化性能, 双重检查中的第一次检查, 完全是出于对性能的考量: <strong>避免执行加锁操作, 因为加锁操作很耗时. 而加锁之后的二次检查, 则是出于对安全性负责</strong>. 双重检查方案在优化加锁性能方面经常用到.</p> <h4 id="_33-thread-per-message模式-最简单实用的分工方法"><a href="#_33-thread-per-message模式-最简单实用的分工方法" class="header-anchor">#</a> 33-Thread-Per-Message模式:最简单实用的分工方法</h4> <p>前面曾经把并发编程领域的问题总结为三个核心问题: <strong>分工, 同步和互斥</strong>. 其中, 同步和互斥相关问题更多地源自微观, 而分工问题则是源自宏观. 解决问题往往都是从宏观入手, 在编程领域, 软件的设计过程也是先从概要设计开始, 而后才进行详细设计. 同样, <strong>解决并发编程问题, 首要问题也是解决宏观的分工问题</strong>.</p> <p>并发编程领域里, <strong>解决分工问题也有一系列的设计模式, 比较常用的主要有 Thread-Per-Message 模式, Worker Thread 模式, 生产者-消费者模式等等</strong>. 今天重点介绍 Thread-Per-Message 模式.</p> <h5 id="如何理解thread-per-message模式"><a href="#如何理解thread-per-message模式" class="header-anchor">#</a> 如何理解Thread-Per-Message模式</h5> <p>现实世界里, 很多事情都需要委托他人办理, 一方面受限于自己的能力, 总有很多搞不定的事, 比如教育小朋友, 搞不定怎么办呢? 只能委托学校老师了; 另一方面受限于时间, 比如忙着写 Bug, 哪有时间买别墅呢? 只能委托房产中介了. <strong>委托他人代办有一个非常大的好处, 那就是可以专心做自己的事</strong>了.</p> <p>在编程领域也有很多类似的需求, 比如写一个 HTTP Server, 很显然只能在主线程中接收请求, 而不能处理 HTTP 请求, 因为如果在主线程中处理 HTTP 请求的话, 那同一时间只能处理一个请求, 太慢了! 怎么办呢? 可以利用代办的思路, <strong>创建一个子线程, 委托子线程去处理 HTTP 请求</strong>.</p> <p>这种委托他人办理的方式, 在并发编程领域被总结为一种设计模式, 叫做 <strong>Thread-Per-Message 模式</strong>, 简言之就是<strong>为每个任务分配一个独立的线程. 这是一种最简单的分工方法, 实现起来也非常简单</strong>.</p> <h5 id="用thread实现thread-per-message模式"><a href="#用thread实现thread-per-message模式" class="header-anchor">#</a> 用Thread实现Thread-Per-Message模式</h5> <p>Thread-Per-Message 模式的一个最经典的应用场景是<strong>网络编程里服务端的实现</strong>, 服务端为每个客户端请求创建一个独立的线程, 当线程处理完请求后, 自动销毁, 这是一种最简单的并发处理网络请求的方法.</p> <p>网络编程里最简单的程序当数 echo 程序了, echo 程序的服务端会原封不动地将客户端的请求发送回客户端. 例如, 客户端发送 TCP 请求 &quot;Hello World&quot;, 那么服务端也会返回 &quot;Hello World&quot;.</p> <p>下面就以 echo 程序的服务端为例, 介绍如何实现 Thread-Per-Message 模式.</p> <p>在 Java 中, 实现 echo 程序的服务端还是很简单的. 只需要 30 行代码就能够实现, 示例代码如下, 为每个请求都创建了一个 Java 线程.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">ServerSocketChannel</span> ssc <span class="token operator">=</span> <span class="token class-name">ServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 处理请求    </span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 接收请求</span>
        <span class="token class-name">SocketChannel</span> sc <span class="token operator">=</span> ssc<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 每个请求都创建一个线程</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 读 Socket</span>
                <span class="token class-name">ByteBuffer</span> rb <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                sc<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 模拟处理请求</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 写 Socket</span>
                <span class="token class-name">ByteBuffer</span> wb <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ByteBuffer</span><span class="token punctuation">)</span> rb<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                sc<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>wb<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 关闭 Socket</span>
                sc<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UncheckedIOException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    ssc<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>如果你熟悉网络编程, 相信你一定会提出一个很尖锐的问题: 上面这个 echo 服务的实现方案是<strong>不具备可行性</strong>的. 原因在于 Java 中的线程是一个重量级的对象, 创建成本很高, 一方面创建线程比较耗时, 另一方面线程占用的内存也比较大. 所以, <strong>为每个请求创建一个新的线程并不适合高并发场景</strong>.</p> <p>于是, 你开始质疑 Thread-Per-Message 模式, 而且开始重新思索解决方案, 这时候很可能你会想到 Java 提供的<strong>线程池</strong>. 这个思路没有问题, 但是引入线程池难免会增加复杂度. 其实完全可以换一个角度来思考这个问题, 语言, 工具, 框架本身应该是帮助大家更敏捷地实现方案的, 而不是用来否定方案的, Thread-Per-Message 模式作为一种最简单的分工方案, Java 语言支持不了, 显然是 Java 语言本身的问题.</p> <p>Java 语言里, <mark><strong>Java 线程是和操作系统线程一一对应的, 这种做法本质上是将 Java 线程的调度权完全委托给操作系统, 而操作系统在这方面非常成熟, 所以这种做法的好处是稳定, 可靠, 但是也继承了操作系统线程的缺点: 创建成本高</strong></mark>. 为了解决这个缺点, Java 并发包里提供了线程池等工具类. 这个思路在很长一段时间里都是很稳妥的方案, 但是这个方案并不是唯一的方案.</p> <p>业界还有另外一种方案, 叫做<mark><strong>轻量级线程</strong></mark>. 这个方案在 Java 领域知名度并不高, 但是在其他编程语言里却叫得很响, 例如 Go 语言, Lua 语言里的协程, 本质上就是一种轻量级的线程. <strong>轻量级的线程, 创建的成本很低, 基本上和创建一个普通对象的成本相似; 并且创建的速度和内存占用相比操作系统线程至少有一个数量级的提升, 所以基于轻量级线程实现 Thread-Per-Message 模式就完全没有问题了</strong>.</p> <p>Java 语言目前也已经意识到轻量级线程的重要性了, OpenJDK 有个 Loom 项目, 就是要解决 Java 语言的轻量级线程问题, 在这个项目中, 轻量级线程被叫 <strong>Fiber</strong>. 下面就来看看基于 Fiber 如何实现 Thread-Per-Message 模式.</p> <h5 id="用fiber实现thread-per-message模式"><a href="#用fiber实现thread-per-message模式" class="header-anchor">#</a> 用Fiber实现Thread-Per-Message模式</h5> <p>Loom 项目在设计轻量级线程时, 充分考量了当前 Java 线程的使用方式, 采取的是尽量兼容的态度, 所以使用上还是挺简单的. 用 Fiber 实现 echo 服务的示例代码如下所示, 对比 Thread 的实现, 你会发现改动量非常小, 只需要把新建线程的操作换成 <code>Fiber.schedule(()-&gt;{})</code>​ 就可以了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">ServerSocketChannel</span> ssc <span class="token operator">=</span> <span class="token class-name">ServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 处理请求</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 接收请求</span>
        <span class="token keyword">final</span> <span class="token class-name">SocketChannel</span> sc <span class="token operator">=</span> serverSocketChannel<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Fiber</span><span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 读 Socket</span>
                <span class="token class-name">ByteBuffer</span> rb <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                sc<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 模拟处理请求</span>
                <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token number">2000</span> <span class="token operator">*</span> <span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 写 Socket</span>
                <span class="token class-name">ByteBuffer</span> wb <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ByteBuffer</span><span class="token punctuation">)</span> rb<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                sc<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>wb<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 关闭 Socket</span>
                sc<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UncheckedIOException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token comment">// while</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    ssc<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>那使用 Fiber 实现的 echo 服务是否能够达到预期的效果呢? 可以在 Linux 环境下做一个简单的实验, 步骤如下:</p> <ol><li>首先通过 <code>ulimit -u 512</code> 将用户能创建的最大进程数(包括线程)设置为 512;</li> <li>启动 Fiber 实现的 echo 程序;</li> <li>利用压测工具 ab 进行压测: <code>ab -r -c 20000 -n 200000 http:// 测试机 IP 地址:8080/</code>​</li></ol> <p>压测执行结果如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Concurrency</span> <span class="token class-name">Level</span><span class="token operator">:</span>      <span class="token number">20000</span>
<span class="token class-name">Time</span> taken <span class="token keyword">for</span> tests<span class="token operator">:</span>   <span class="token number">67.718</span> seconds
<span class="token class-name">Complete</span> requests<span class="token operator">:</span>      <span class="token number">200000</span>
<span class="token class-name">Failed</span> requests<span class="token operator">:</span>        <span class="token number">0</span>
<span class="token class-name">Write</span> errors<span class="token operator">:</span>           <span class="token number">0</span>
<span class="token class-name">Non</span><span class="token operator">-</span><span class="token number">2</span>xx responses<span class="token operator">:</span>      <span class="token number">200000</span>
<span class="token class-name">Total</span> transferred<span class="token operator">:</span>      <span class="token number">16400000</span> bytes
<span class="token constant">HTML</span> transferred<span class="token operator">:</span>       <span class="token number">0</span> bytes
<span class="token class-name">Requests</span> per second<span class="token operator">:</span>    <span class="token number">2953.41</span> <span class="token punctuation">[</span>#<span class="token operator">/</span>sec<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean<span class="token punctuation">)</span>
<span class="token class-name">Time</span> per request<span class="token operator">:</span>       <span class="token number">6771.844</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean<span class="token punctuation">)</span>
<span class="token class-name">Time</span> per request<span class="token operator">:</span>       <span class="token number">0.339</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean<span class="token punctuation">,</span> across all concurrent requests<span class="token punctuation">)</span>
<span class="token class-name">Transfer</span> rate<span class="token operator">:</span>          <span class="token number">236.50</span> <span class="token punctuation">[</span><span class="token class-name">Kbytes</span><span class="token operator">/</span>sec<span class="token punctuation">]</span> received
 
<span class="token class-name">Connection</span> <span class="token class-name">Times</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span>
              min  mean<span class="token punctuation">[</span><span class="token operator">+</span><span class="token operator">/</span><span class="token operator">-</span>sd<span class="token punctuation">]</span> median   max
<span class="token class-name">Connect</span><span class="token operator">:</span>        <span class="token number">0</span>  <span class="token number">557</span> <span class="token number">3541.6</span>      <span class="token number">1</span>   <span class="token number">63127</span>
<span class="token class-name">Processing</span><span class="token operator">:</span>  <span class="token number">2000</span> <span class="token number">2010</span>  <span class="token number">31.8</span>   <span class="token number">2003</span>    <span class="token number">2615</span>
<span class="token class-name">Waiting</span><span class="token operator">:</span>     <span class="token number">1986</span> <span class="token number">2008</span>  <span class="token number">30.9</span>   <span class="token number">2002</span>    <span class="token number">2615</span>
<span class="token class-name">Total</span><span class="token operator">:</span>       <span class="token number">2000</span> <span class="token number">2567</span> <span class="token number">3543.9</span>   <span class="token number">2004</span>   <span class="token number">65293</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>可以发现即便在 20000 并发下, 该程序依然能够良好运行. 同等条件下, Thread 实现的 echo 程序 512 并发都抗不过去, 直接就 OOM 了.</p> <p>如果通过 Linux 命令 <code>top -Hp pid</code>​ 查看 Fiber 实现的 echo 程序的进程信息, 可以看到该进程<strong>仅仅创建了 16(不同 CPU 核数结果会不同)个操作系统线程</strong>.</p> <p><img src="/img/ca0e7ae68c8bd73ac0f7d2e48645688e-20230731162452-shjq6f1.png" alt=""></p> <p>如果你对 Loom 项目感兴趣, 可以下载源代码自己构建, 构建方法可以参 考<a href="https://wiki.openjdk.java.net/display/loom/Main" target="_blank" rel="noopener noreferrer">Project Loom 的相关资料<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, 不过需要注意的是构建之前一定要把代码分支切换到 Fibers.</p> <h5 id="总结-25"><a href="#总结-25" class="header-anchor">#</a> 总结</h5> <p>并发编程领域的分工问题, 指的是<strong>如何高效地拆解任务并分配给线程</strong>. 前面在并发工具类模块中已经介绍了不少解决分工问题的工具类, 例如 Future, CompletableFuture, CompletionService, Fork/Join 计算框架等, 这些工具类都能很好地解决特定应用场景的问题, 所以这些工具类曾经是 Java 语言引以为傲的. 不过这些工具类都继承了 Java 语言的老毛病: 太复杂.</p> <p>如果你一直从事 Java 开发, 估计你已经习以为常了, 习惯性地认为这个复杂度是正常的. 不过这个世界时刻都在变化, <strong>曾经正常的复杂度, 现在看来也许就已经没有必要了</strong>, 例如 Thread-Per-Message 模式如果使用线程池方案就会增加复杂度.</p> <p><strong>Thread-Per-Message 模式在 Java 领域并不是那么知名, 根本原因在于 Java 语言里的线程是一个重量级的对象, 为每一个任务创建一个线程成本太高, 尤其是在高并发领域, 基本就不具备可行性</strong>. 不过这个背景条件目前正在发生巨变, Java 语言未来一定会提供轻量级线程, 这样基于轻量级线程实现 Thread-Per-Message 模式就是一个非常靠谱的选择.</p> <p>当然, 对于一些并发度没那么高的异步场景, 例如定时任务, 采用 Thread-Per-Message 模式是完全没有问题的. 实际工作中, 我就见过完全基于 Thread-Per-Message 模式实现的分布式调度框架, 这个框架为每个定时任务都分配了一个独立的线程.</p> <h4 id="_34-worker-thread模式-如何避免重复创建线程"><a href="#_34-worker-thread模式-如何避免重复创建线程" class="header-anchor">#</a> 34-Worker Thread模式:如何避免重复创建线程?</h4> <p>上一节介绍了一种最简单的分工模式--Thread-Per-Message 模式, 对应到现实世界, 其实就是<strong>委托代</strong>办. 这种分工模式如果用 Java Thread 实现, 频繁地创建, 销毁线程非常影响性能, 同时无限制地创建线程还可能导致 OOM, 所以在 Java 领域使用场景就受限了.</p> <p><strong>要想有效避免线程的频繁创建, 销毁以及 OOM 问题, 就不得不提今天要细聊的, 也是 Java 领域使用最多的 Worker Thread 模式</strong>.</p> <h5 id="worker-thread模式及其实现"><a href="#worker-thread模式及其实现" class="header-anchor">#</a> Worker Thread模式及其实现</h5> <p>Worker Thread 模式可以类比现实世界里<strong>车间的工作模式</strong>: 车间里的工人, 有活儿了, 大家一起干, 没活儿了就聊聊天等着. 可以参考下面的示意图, Worker Thread 模式中 <strong>Worker Thread 对应到现实世界里, 其实指的就是车间里的工人</strong>. 不过这里需要注意的是, 车间里的工人数量往往是确定的.</p> <p><img src="/img/76a0c1ac82a6ea20a6a17e1e3df57ab4-20230731162452-zvji9l4.png" alt="" title="车间工作示意图"></p> <p>那在编程领域该如何模拟车间的这种工作模式呢? 或者说如何去实现 Worker Thread 模式呢? 通过上面的图, 很容易就能想到用阻塞队列做任务池, 然后创建固定数量的线程消费阻塞队列中的任务. 其实你仔细想会发现, 这个方案就是 Java 语言提供<strong>的线程池</strong>.</p> <p>线程池有很多优点, 例如能够避免重复创建, 销毁线程, 同时能够限制创建线程的上限等等. 上一节用 Java 的 Thread 实现 Thread-Per-Message 模式难以应对高并发场景, 原因就在于频繁创建, 销毁 Java 线程的成本有点高, 而且无限制地创建线程还可能导致应用 OOM. 线程池, 则恰好能解决这些问题.</p> <p>还是以 echo 程序为例, 看看如何用线程池来实现.</p> <p>下面的示例代码是用线程池实现的 echo 服务端, 相比于 Thread-Per-Message 模式的实现, 改动非常少, 仅仅是创建了一个最多线程数为 500 的线程池 es, 然后通过 es.execute() 方法将请求处理的任务提交给线程池处理.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ExecutorService</span> es <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">final</span> <span class="token class-name">ServerSocketChannel</span> ssc <span class="token operator">=</span> <span class="token class-name">ServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>
                <span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 处理请求  </span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 接收请求</span>
        <span class="token class-name">SocketChannel</span> sc <span class="token operator">=</span> ssc<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将请求处理任务提交给线程池</span>
        es<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 读 Socket</span>
                <span class="token class-name">ByteBuffer</span> rb <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                sc<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 模拟处理请求</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 写 Socket</span>
                <span class="token class-name">ByteBuffer</span> wb <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ByteBuffer</span><span class="token punctuation">)</span> rb<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                sc<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>wb<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 关闭 Socket</span>
                sc<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UncheckedIOException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    ssc<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    es<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h5 id="正确地创建线程池"><a href="#正确地创建线程池" class="header-anchor">#</a> 正确地创建线程池</h5> <p>Java 的线程池既能够避免无限制地<strong>创建线程</strong>导致 OOM, 也能避免无限制地<strong>接收任务</strong>导致 OOM. 只不过后者经常容易被忽略, 例如在上面的实现中, 就被忽略了. 所以强烈建议<strong>用创建有界的队列来接收任务</strong>.</p> <p>当请求量大于有界队列的容量时, 就需要合理地拒绝请求. 如何合理地拒绝呢? 这需要结合具体的业务场景来制定, 即便线程池默认的拒绝策略能够满足需求, 也同样建议<strong>在创建线程池时, 清晰地指明拒绝策略</strong>.</p> <p>同时, 为了便于调试和诊断问题, 强烈建议<strong>在实际工作中给线程赋予一个业务相关的名字</strong>.</p> <p>综合以上这三点建议, echo 程序中创建线程可以使用下面的示例代码.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ExecutorService</span> es <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>
        <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span>
        <span class="token number">60L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span>
        <span class="token comment">// 注意要创建有界队列</span>
        <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token comment">// 建议根据业务需求实现 ThreadFactory</span>
        r <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token string">&quot;echo-&quot;</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token comment">// 建议根据业务需求实现 RejectedExecutionHandler</span>
        <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h5 id="避免线程死锁"><a href="#避免线程死锁" class="header-anchor">#</a> 避免线程死锁</h5> <p>使用线程池过程中, 还要注意一种<strong>线程死锁</strong>的场景. 如果提交到相同线程池的任务<strong>不是相互独立</strong>的, 而是有依赖关系的, 那么就有可能导致线程死锁. 实际工作中, 我就亲历过这种线程死锁的场景. 具体现象是<strong>应用每运行一段时间偶尔就会处于无响应的状态, 监控数据看上去一切都正常, 但是实际上已经不能正常工作了</strong>.</p> <p>这个出问题的应用, 相关的逻辑精简之后, 如下图所示, 该应用将一个大型的计算任务分成两个阶段, 第一个阶段的任务会等待第二阶段的子任务完成. 在这个应用里, 每一个阶段都使用了线程池, 而且两个阶段使用的还是同一个线程池.</p> <p><img src="/img/50b6956dde6fd5ecbba1fb650adb504b-20230731162452-e98vrzk.png" alt="" title="应用业务逻辑示意图"></p> <p>可以用下面的示例代码来模拟该应用, 如果执行下面的这段代码, 会发现它永远执行不到最后一行. 执行过程中没有任何异常, 但是应用已经停止响应了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//L1, L2 阶段共用的线程池</span>
<span class="token class-name">ExecutorService</span> es <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//L1 阶段的闭锁    </span>
<span class="token class-name">CountDownLatch</span> l1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;L1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 执行 L1 阶段任务</span>
    es<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">//L2 阶段的闭锁 </span>
        <span class="token class-name">CountDownLatch</span> l2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 执行 L2 阶段子任务</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            es<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;L2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                l2<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 等待 L2 阶段任务执行完</span>
        l2<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        l1<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 等着 L1 阶段任务执行完</span>
l1<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>当应用出现类似问题时, 首选的诊断方法是查看线程栈. 下图是上面示例代码停止响应后的线程栈, 你会发现线程池中的两个线程全部都阻塞在 <code>l2.await();</code> 这行代码上了, 也就是说, 线程池里所有的线程都在等待 L2 阶段的任务执行完, 那 L2 阶段的子任务什么时候能够执行完呢? 永远都没那一天了, 为什么呢? 因为线程池里的线程都阻塞了, 没有空闲的线程执行 L2 阶段的任务了.</p> <p><img src="/img/0e30a3d840da72fac3301a96069679f5-20230731162452-su2l37r.png" alt=""></p> <p>原因找到了, 那如何解决就简单了, 最简单粗暴的办法就是将线程池的最大线程数调大, 如果能够确定任务的数量不是非常多的话, 这个办法也是可行的, 否则这个办法就行不通了. 其实<strong>这种问题通用的解决方案是为不同的任务创建不同的线程池</strong>. 对于上面的这个应用, L1 阶段的任务和 L2 阶段的任务如果各自都有自己的线程池, 就不会出现这种问题了.</p> <p>最后再次强调一下: <mark><strong>提交到相同线程池中的任务一定是相互独立的, 否则就一定要慎重</strong></mark>.</p> <h5 id="总结-26"><a href="#总结-26" class="header-anchor">#</a> 总结</h5> <p>解决并发编程里的分工问题, 最好的办法是和现实世界做对比. 对比现实世界构建编程领域的模型, 能够让模型更容易理解. 上一篇介绍的 Thread-Per-Message 模式, 类似于现实世界里的委托他人办理, 而今天介绍的 <strong>Worker Thread 模式则类似于车间里工人的工作模式</strong>. 如果你在设计阶段, 发现对业务模型建模之后, 模型非常类似于车间的工作模式, 那基本上就能确定可以在实现阶段采用 Worker Thread 模式来实现.</p> <p>Worker Thread 模式和 Thread-Per-Message 模式的区别有哪些呢? 从现实世界的角度看, 委托代办人做事, 往往是和代办人直接沟通的; 对应到编程领域, 其实现也是主线程直接创建了一个子线程, 主子线程之间是可以直接通信的. 而车间工人的工作方式则是完全围绕任务展开的, 一个具体的任务被哪个工人执行, 预先是无法知道的; 对应到编程领域, 则是<strong>主线程提交任务到线程池, 但主线程并不关心任务被哪个线程执行</strong>.</p> <p>Worker Thread 模式能避免线程频繁创建, 销毁的问题, 而且能够限制线程的最大数量. Java 语言里可以直接使用线程池来实现 Worker Thread 模式, 线程池是一个非常基础和优秀的工具类, 甚至有些大厂的编码规范都不允许用 new Thread() 来创建线程的, 必须使用线程池.</p> <h4 id="_35-两阶段终止模式-如何优雅地终止线程"><a href="#_35-两阶段终止模式-如何优雅地终止线程" class="header-anchor">#</a> 35-两阶段终止模式:如何优雅地终止线程?</h4> <p>前面两节讲述的内容, 从纯技术的角度看, 都是<strong>启动</strong>多线程去执行一个异步任务. 既启动, 那又该如何终止呢? 今天就从技术的角度聊聊如何优雅地<strong>终止</strong>线程, 正所谓有始有终.</p> <p>前面讲过: <strong>线程执行完或者出现异常就会进入终止状态</strong>. 这样看, 终止一个线程看上去很简单啊! 一个线程执行完自己的任务, 自己进入终止状态, 这的确很简单. 不过今天谈到的 &quot;优雅地终止线程&quot;, 不是自己终止自己, 而是<strong>在一个线程 T1 中, 终止线程 T2</strong>; 这里所谓的 &quot;优雅&quot;, 指的是给 T2 一个机会料理后事, 而不是被一剑封喉.</p> <p>Java 语言的 Thread 类中曾经提供了一个 stop() 方法, 用来终止线程, 可是早已不建议使用了, 原因是这个方法用的就是一剑封喉的做法, 被终止的线程没有机会料理后事.</p> <p>既然不建议使用 stop() 方法, 那在 Java 又该如何优雅地终止线程呢?</p> <h5 id="如何理解两阶段终止模式"><a href="#如何理解两阶段终止模式" class="header-anchor">#</a> 如何理解两阶段终止模式</h5> <p>前辈们经过认真对比分析, 已经总结出了一套成熟的方案, 叫做<strong>两阶段终止模式</strong>. 顾名思义, 就是将终止过程分成两个阶段, 其中<strong>第一个阶段主要是线程 T1 向线程 T2 发送终止指令, 而第二阶段则是线程 T2 响应终止指令</strong>.</p> <p><img src="/img/e1f684fd4f8dfba9a0df3c73ead0260b-20230731162452-2e47eyl.png" alt="" title="两阶段终止模式示意图"></p> <p>那在 Java 里, 终止指令是什么呢? 这个要从 Java 线程的状态转换过程说起. 前面提到过 Java 线程的状态转换图, 如下图所示.</p> <p><img src="/img/14d5ebdae35bc89ddc07820d3b187cd7-20230731162452-19bhbc1.png" alt="" title="Java 中的线程状态转换图"></p> <p>从这个图里会发现, Java 线程<strong>进入终止状态的前提是线程进入 RUNNABLE 状态</strong>, 而实际上线程也可能处在休眠状态, 也就是说, 要想终止一个线程, <strong>首先要把线程的状态从休眠状态转换到 RUNNABLE 状</strong>态. 如何做到呢? 这个要靠 Java Thread 类提供的 <strong>interrupt() 方法</strong>, 它可以<strong>将休眠状态的线程转换到 RUNNABLE 状态</strong>.</p> <p>线程转换到 RUNNABLE 状态之后, 如何再将其终止呢? RUNNABLE 状态转换到终止状态, 优雅的方式是让 Java 线程自己执行完 run() 方法, 所以一般采用的方法是<strong>设置一个标志位</strong>, 然后线程会在合适的时机检查这个标志位, 如果发现符合终止条件, 则自动退出 run() 方法. 这个过程其实就是前面提到的第二阶段: <strong>响应终止指令</strong>.</p> <p>综合上面这两点, 能总结出终止指令, 其实包括两方面内容: <strong>interrupt() 方法</strong>和<strong>线程终止的标志位</strong>.</p> <p>理解了两阶段终止模式之后, 下面看一个实际工作中的案例.</p> <h5 id="用两阶段终止模式终止监控操作"><a href="#用两阶段终止模式终止监控操作" class="header-anchor">#</a> 用两阶段终止模式终止监控操作</h5> <p>实际工作中, 有些监控系统需要<strong>动态地采集一些数据</strong>, 一般都是监控系统发送采集指令给被监控系统的监控代理, 监控代理接收到指令之后, 从监控目标收集数据, 然后回传给监控系统, 详细过程如下图所示. 出于对性能的考虑(有些监控项对系统性能影响很大, 所以不能一直持续监控), 动态采集功能一般都会有终止操作.</p> <p><img src="/img/f3479d3b3f76316e94401923f6864375-20230731162452-0gev21b.png" alt="" title="动态采集功能示意图"></p> <p>下面的示例代码是<strong>监控代理</strong>简化之后的实现, start() 方法会启动一个新的线程 rptThread 来执行监控数据采集和回传的功能, stop() 方法需要优雅地终止线程 rptThread, 那 stop() 相关功能该如何实现呢?</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> started <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 采集线程</span>
    <span class="token class-name">Thread</span> rptThread<span class="token punctuation">;</span>

    <span class="token comment">// 启动采集功能</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 不允许同时启动多个采集线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>started<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        started <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        rptThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 省略采集, 回传实现</span>
                <span class="token function">report</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 每隔两秒钟采集, 回传一次数据</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 执行到此处说明线程马上终止</span>
            started <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        rptThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 终止采集功能</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如何实现? </span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>按照两阶段终止模式, 首先需要做的就是将线程 rptThread 状态转换到 RUNNABLE, 做法很简单, 只需要在调用 <code>rptThread.interrupt()</code>​ 就可以了. 线程 rptThread 的状态转换到 RUNNABLE 之后, 如何优雅地终止呢? 下面的示例代码中, 选择的标志位是线程的中断状态: <code>Thread.currentThread().isInterrupted()</code>​, 需要注意的是, 在捕获 Thread.sleep() 的中断异常之后, 通过 <code>Thread.currentThread().interrupt()</code>​ 重新设置了线程的中断状态, <strong>因为 JVM 的异常处理会清除线程的中断状态</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> started <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 采集线程</span>
    <span class="token class-name">Thread</span> rptThread<span class="token punctuation">;</span>

    <span class="token comment">// 启动采集功能</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 不允许同时启动多个采集线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>started<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        started <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        rptThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 省略采集, 回传实现</span>
                <span class="token function">report</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 每隔两秒钟采集, 回传一次数据</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 重新设置线程中断状态</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 执行到此处说明线程马上终止</span>
            started <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        rptThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 终止采集功能</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        rptThread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>上面的示例代码的确能够解决当前的问题, 但是建议在实际工作中<strong>谨慎使用</strong>. 原因在于很可能在线程的 run() 方法中调用第三方类库提供的方法, 而没有办法保证第三方类库正确处理了线程的中断异常, 例如第三方类库在捕获到 Thread.sleep() 方法抛出的中断异常后, 没有重新设置线程的中断状态, 那么就会导致线程不能够正常终止. 所以强烈建议<strong>设置自己的线程终止标志位</strong>, 例如在下面的代码中, 使用 <strong>isTerminated</strong> 作为线程终止标志位, 此时无论是否正确处理了线程的中断异常, 都不会影响线程优雅地终止.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token punctuation">{</span>
    <span class="token comment">// 线程终止标志位</span>
    <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> terminated <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> started <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 采集线程</span>
    <span class="token class-name">Thread</span> rptThread<span class="token punctuation">;</span>

    <span class="token comment">// 启动采集功能</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 不允许同时启动多个采集线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>started<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        started <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        terminated <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        rptThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>terminated<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 省略采集, 回传实现</span>
                <span class="token function">report</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 每隔两秒钟采集, 回传一次数据</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 重新设置线程中断状态</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 执行到此处说明线程马上终止</span>
            started <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        rptThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 终止采集功能</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 设置中断标志位</span>
        terminated <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token comment">// 中断线程 rptThread</span>
        rptThread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><h5 id="如何优雅地终止线程池"><a href="#如何优雅地终止线程池" class="header-anchor">#</a> 如何优雅地终止线程池</h5> <p>Java 领域用的最多的还是线程池, 而不是手动地创建线程. 那该如何优雅地终止线程池呢?</p> <p>线程池提供了两个方法: <strong>shutdown()</strong> <strong><strong>和</strong></strong> <strong>shutdownNow()</strong> . 这两个方法有什么区别呢? 要了解它们的区别, 就先需要了解线程池的实现原理.</p> <p>前面曾经讲过, Java 线程池是生产者-消费者模式的一种实现, 提交给线程池的任务, 首先是进入一个阻塞队列中, 之后线程池中的线程从阻塞队列中取出任务执行.</p> <p><strong>shutdown() 方法是一种很保守的关闭线程池的方法. 线程池执行 shutdown() 后, 就会拒绝接收新的任务, 但是会等待线程池中正在执行的任务和已经进入阻塞队列的任务都执行完之后才最终关闭线程池</strong>.</p> <p>而 shutdownNow() 方法, 相对就激进一些了, 线程池执行 shutdownNow() 后, <strong>会拒绝接收新的任务, 同时还会中断线程池中正在执行的任务</strong>, 已经进入阻塞队列的任务也被剥夺了执行的机会, 不过这些被剥夺执行机会的任务会作为 shutdownNow() 方法的返回值返回. 因为 shutdownNow() 方法会中断正在执行的线程, 所以提交到线程池的任务, 如果需要优雅地结束, 就需要正确地处理线程中断.</p> <p>如果提交到线程池的任务不允许取消, 那就不能使用 shutdownNow() 方法终止线程池. 不过, 如果提交到线程池的任务允许后续以补偿的方式重新执行, 也是可以使用 shutdownNow() 方法终止线程池的.</p> <p>其实分析完 shutdown() 和 shutdownNow() 方法你会发现, 它们实质上使用的也是<strong>两阶段终止模式</strong>, 只是终止指令的范围不同而已, 前者只影响阻塞队列接收任务, 后者范围扩大到线程池中所有的任务.</p> <h5 id="总结-27"><a href="#总结-27" class="header-anchor">#</a> 总结</h5> <p>两阶段终止模式是一种应用很广泛的并发设计模式, 在 Java 语言中使用两阶段终止模式来优雅地终止线程, 需要注意两个关键点: 一个是仅检查终止标志位是不够的, 因为线程的状态可能处于休眠态; 另一个是仅检查线程的中断状态也是不够的, 因为依赖的第三方类库很可能没有正确处理中断异常.</p> <p>当使用 Java 的线程池来管理线程的时候, 需要依赖线程池提供的 shutdown() 和 shutdownNow() 方法来终止线程池. 不过在使用时需要注意它们的应用场景, 尤其是在使用 shutdownNow() 的时候, 一定要谨慎.</p> <h4 id="_36-生产者-消费者模式-用流水线思想提高效率"><a href="#_36-生产者-消费者模式-用流水线思想提高效率" class="header-anchor">#</a> 36-生产者-消费者模式:用流水线思想提高效率</h4> <p>前面讲到, Worker Thread 模式类比的是工厂里车间工人的工作模式. 但其实在现实世界, 工厂里还有一种流水线的工作模式, 类比到编程领域, 就是<strong>生产者-消费者模式</strong>.</p> <p>生产者-消费者模式在编程领域的应用也非常广泛, 前面曾经提到, Java 线程池本质上就是用生产者-消费者模式实现的, 所以每当使用线程池的时候, 其实就是在应用生产者-消费者模式.</p> <p>当然, 除了在线程池中的应用, 为了提升性能, 并发编程领域很多地方也都用到了生产者-消费者模式, 例如 Log4j2 中异步 Appender 内部也用到了生产者-消费者模式. 所以今天就来深入地聊聊生产者-消费者模式, 看看它具体有哪些优点, 以及如何提升系统的性能.</p> <h5 id="生产者-消费者模式的优点"><a href="#生产者-消费者模式的优点" class="header-anchor">#</a> 生产者-消费者模式的优点</h5> <p><strong>生产者-消费者模式的核心是一个任务队列, 生产者线程生产任务, 并将任务添加到任务队列中, 而消费者线程从任务队列中获取任务并执行</strong>. 下面是生产者-消费者模式的一个示意图, 你可以结合它来理解.</p> <p><img src="/img/e201c3f38d774c5ba72bc108963fb6fa-20230731162452-rh0x3lf.png" alt="" title="生产者-消费者模式示意图"></p> <p>从架构设计的角度来看, 生产者-消费者模式有一个很重要的优点, 就是<strong>解耦</strong>. 解耦对于大型系统的设计非常重要, 而解耦的一个关键就是组件之间的依赖关系和通信方式必须受限. 在生产者-消费者模式中, 生产者和消费者没有任何依赖关系, 它们彼此之间的通信只能通过任务队列, 所以<strong>生产者-消费者模式是一个不错的解耦方案</strong>.</p> <p>除了架构设计上的优点之外, 生产者-消费者模式还有一个重要的优点就是<strong>支持异步, 并且能够平衡生产者和消费者的速度差异</strong>. 生产者线程只需要将任务添加到任务队列而无需等待任务被消费者线程执行完, 也就是说任务的生产和消费是异步的, 这是与传统的方法之间调用的本质区别, 传统的方法之间调用是同步的.</p> <p>你或许会有这样的疑问, 异步化处理最简单的方式就是创建一个新的线程去处理, 那中间增加一个 &quot;<strong>任务队列</strong>&quot; 究竟有什么用呢? 我觉得主要还是用于<strong>平衡生产者和消费者的速度差异</strong>. 假设生产者的速率很慢, 而消费者的速率很高, 比如是 1:3, 如果生产者有 3 个线程, 采用创建新的线程的方式, 那么会创建 3 个子线程, 而采用生产者-消费者模式, 消费线程只需要 1 个就可以了. Java 语言里, Java 线程和操作系统线程是一一对应的, 线程创建得太多, 会增加上下文切换的成本, 所以 Java 线程不是越多越好, 适量即可. 而<strong>生产者-消费者模式恰好能支持你用适量的线程</strong>.</p> <h5 id="支持批量执行以提升性能"><a href="#支持批量执行以提升性能" class="header-anchor">#</a> 支持批量执行以提升性能</h5> <p>前面讲过轻量级的线程, 如果使用轻量级线程, 就没有必要平衡生产者和消费者的速度差异了, 因为轻量级线程本身就是廉价的, 那是否意味着生产者-消费者模式在性能优化方面就无用武之地了呢? 当然不是, 有一类并发场景应用生产者-消费者模式就有奇效, 那就是<strong>批量执行</strong>任务.</p> <p>例如要在数据库里 INSERT 1000 条数据, 有两种方案: 第一种方案是用 1000 个线程并发执行, 每个线程 INSERT 一条数据; 第二种方案是用 1 个线程, 执行一个批量的 SQL, 一次性把 1000 条数据 INSERT 进去. 这两种方案, 显然是第二种方案效率更高, 其实这样的应用场景就是上面提到的批量执行场景.</p> <p>前面提到一个监控系统动态采集的案例, 其实最终回传的监控数据还是要存入数据库的(如下图). 但被监控系统往往有很多, 如果每一条回传数据都直接 INSERT 到数据库, 那么这个方案就是上面提到的第一种方案: 每个线程 INSERT 一条数据. 很显然, 更好的方案是批量执行 SQL, 那如何实现呢? 这就要用到生产者-消费者模式了.</p> <p><img src="/img/ae2d3497e4ad366615ec1b50f118357e-20230731162452-t3o5aqr.png" alt="" title="动态采集功能示意图"></p> <p>利用生产者-消费者模式实现批量执行 SQL 非常简单: 将原来直接 INSERT 数据到数据库的线程作为生产者线程, 生产者线程只需将数据添加到任务队列, 然后消费者线程负责将任务从任务队列中<strong>批量取出并批量执行</strong>.</p> <p>在下面的示例代码中, 创建了 5 个消费者线程负责批量执行 SQL, 这 5 个消费者线程以 <code>while(true){ }</code>​ 循环方式批量地获取任务并批量地执行. 需要注意的是, 从任务队列中获取批量任务的方法 pollTasks() 中, 首先是以阻塞方式获取任务队列中的一条任务, 而后则是以非阻塞的方式获取任务; 之所以首先采用阻塞方式, 是因为如果任务队列中没有任务, 这样的方式能够避免无谓的循环.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 任务队列</span>
<span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Task</span><span class="token punctuation">&gt;</span></span> bq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 启动 5 个消费者线程</span>
<span class="token comment">// 执行批量任务  </span>
<span class="token keyword">void</span> start <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ExecutorService</span> es <span class="token operator">=</span> xecutors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        es<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 获取批量任务</span>
                    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Task</span><span class="token punctuation">&gt;</span></span> ts <span class="token operator">=</span> <span class="token function">pollTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 执行批量任务</span>
                    <span class="token function">execTasks</span><span class="token punctuation">(</span>ts<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 从任务队列中获取批量任务</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Task</span><span class="token punctuation">&gt;</span></span> pollTasks <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Task</span><span class="token punctuation">&gt;</span></span> ts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 阻塞式获取一条任务</span>
    <span class="token class-name">Task</span> t <span class="token operator">=</span> bq<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ts<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 非阻塞式获取一条任务</span>
        t <span class="token operator">=</span> bq<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ts<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 批量执行任务</span>
<span class="token function">execTasks</span><span class="token punctuation">(</span><span class="token class-name">List</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">Task</span> <span class="token punctuation">&gt;</span></span> ts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略具体代码无数</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><h5 id="支持分阶段提交以提升性能"><a href="#支持分阶段提交以提升性能" class="header-anchor">#</a> 支持分阶段提交以提升性能</h5> <p>利用生产者-消费者模式还可以轻松地支持一种<strong>分阶段提交</strong>的应用场景. 大家知道写文件如果同步刷盘性能会很慢, 所以对于不是很重要的数据, 往往采用异步刷盘的方式. 我曾经参与过一个项目, 其中的日志组件是自己实现的, 采用的就是异步刷盘方式, 刷盘的时机是:</p> <ol><li>ERROR 级别的日志需要立即刷盘;</li> <li>数据积累到 500 条需要立即刷盘;</li> <li>存在未刷盘数据, 且 5 秒钟内未曾刷盘, 需要立即刷盘.</li></ol> <p>这个日志组件的异步刷盘操作本质上其实就是一种<strong>分阶段提交</strong>. 下面具体看看用生产者-消费者模式如何实现. 在下面的示例代码中, 可以通过调用 <code>info()</code>​ 和 <code>error()</code>​ 方法写入日志, 这两个方法都是创建了一个日志任务 LogMsg, 并添加到阻塞队列中, 调用 <code>info()</code>​ 和 <code>error()</code>​ 方法的线程是生产者; 而真正将日志写入文件的是消费者线程, 在 Logger 这个类中, 只创建了 1 个消费者线程, 在这个消费者线程中, 会根据刷盘规则执行刷盘操作, 逻辑很简单, 这里就不赘述了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>
    <span class="token comment">// 任务队列  </span>
    <span class="token keyword">final</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LogMsg</span><span class="token punctuation">&gt;</span></span> bq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//flush 批量  </span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> batchSize <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>
    <span class="token comment">// 只需要一个线程写日志</span>
    <span class="token class-name">ExecutorService</span> es <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 启动写日志线程</span>
    <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token class-name">File</span><span class="token punctuation">.</span><span class="token function">createTempFile</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;.log&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">FileWriter</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>es<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 未刷盘日志数量</span>
                <span class="token keyword">int</span> curIdx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">long</span> preFT <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">LogMsg</span> log <span class="token operator">=</span> bq<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 写日志</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>log <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>log<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token operator">++</span>curIdx<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">// 如果不存在未刷盘数据, 则无需刷盘</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>curIdx <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">continue</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">// 根据规则刷盘</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>log <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> log<span class="token punctuation">.</span>level <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token constant">LEVEL</span><span class="token punctuation">.</span><span class="token constant">ERROR</span> 
                            <span class="token operator">||</span> curIdx <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> batchSize <span class="token operator">||</span>
                            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> preFT <span class="token operator">&gt;</span> <span class="token number">5000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        curIdx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                        preFT <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    writer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 写 INFO 级别日志</span>
    <span class="token keyword">void</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        bq<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LogMsg</span><span class="token punctuation">(</span>
                <span class="token constant">LEVEL</span><span class="token punctuation">.</span><span class="token constant">INFO</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 写 ERROR 级别日志</span>
    <span class="token keyword">void</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        bq<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LogMsg</span><span class="token punctuation">(</span>
                <span class="token constant">LEVEL</span><span class="token punctuation">.</span><span class="token constant">ERROR</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 日志级别</span>
<span class="token keyword">enum</span> <span class="token class-name">LEVEL</span> <span class="token punctuation">{</span>
    <span class="token constant">INFO</span><span class="token punctuation">,</span> <span class="token constant">ERROR</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">LogMsg</span> <span class="token punctuation">{</span>
    <span class="token class-name">LEVEL</span> level<span class="token punctuation">;</span>
    <span class="token class-name">String</span> msg<span class="token punctuation">;</span>

    <span class="token comment">// 省略构造函数实现</span>
    <span class="token class-name">LogMsg</span><span class="token punctuation">(</span><span class="token class-name">LEVEL</span> lvl<span class="token punctuation">,</span> <span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 省略 toString() 实现</span>
    <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br></div></div><h5 id="总结-28"><a href="#总结-28" class="header-anchor">#</a> 总结</h5> <p>Java 语言提供的线程池本身就是一种生产者-消费者模式的实现, 但是线程池中的线程每次只能从任务队列中消费一个任务来执行, 对于大部分并发场景这种策略都没有问题. 但是有些场景还是需要自己来实现, 例如需要批量执行以及分阶段提交的场景.</p> <p>生产者-消费者模式在分布式计算中的应用也非常广泛. 在分布式场景下, 可以借助分布式消息队列(MQ)来实现生产者-消费者模式. MQ 一般都会支持两种消息模型, 一种是点对点模型, 一种是发布订阅模型. 这两种模型的区别在于, 点对点模型里一个消息只会被一个消费者消费, 和 Java 的线程池非常类似(Java 线程池的任务也只会被一个线程执行); 而发布订阅模型里一个消息会被多个消费者消费, 本质上是一种消息的广播, 在多线程编程领域, 可以结合观察者模式实现广播功能.</p> <h3 id="案例分析"><a href="#案例分析" class="header-anchor">#</a> 案例分析</h3> <h4 id="_38-案例分析-高性能限流器guava-ratelimiter"><a href="#_38-案例分析-高性能限流器guava-ratelimiter" class="header-anchor">#</a> 38-案例分析:高性能限流器Guava RateLimiter</h4> <p>从今天开始, 就进入案例分析模块了. 这个模块将分析四个经典的开源框架, 看看它们是如何处理并发问题的, 通过这四个案例的学习, 相信你会对如何解决并发问题有个更深入的认识.</p> <p>首先来看看 <strong>Guava RateLimiter 是如何解决高并发场景下的限流问题的</strong>. Guava 是 Google 开源的 Java 类库, 提供了一个工具类 RateLimiter. 先来看看 RateLimiter 的使用, 让你对限流有个感官的印象. 假设有一个线程池, 它每秒只能处理两个任务, 如果提交的任务过快, 可能导致系统不稳定, 这个时候就需要用到限流.</p> <p>在下面的示例代码中, 创建了一个流速为 2 个请求/秒的限流器, 这里的流速该怎么理解呢? 直观地看, 2 个请求/秒指的是每秒最多允许 2 个请求通过限流器, 其实在 Guava 中, 流速还有更深一层的意思: 是一种匀速的概念, 2 个请求/秒等价于 1 个请求/ 500 毫秒.</p> <p>在向线程池提交任务之前, 调用 <code>acquire()</code>​ 方法就能起到<strong>限流</strong>的作用. 通过示例代码的执行结果, 任务提交到线程池的时间间隔基本上稳定在 500 毫秒.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 限流器流速: 2 个请求 / 秒</span>
<span class="token class-name">RateLimiter</span> limiter <span class="token operator">=</span> <span class="token class-name">RateLimiter</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 执行任务的线程池</span>
<span class="token class-name">ExecutorService</span> es <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 记录上一次执行时间</span>
prev <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 测试执行 20 次</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 限流器限流</span>
    limiter<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 提交任务异步执行</span>
    es<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> cur <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印时间间隔: 毫秒</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cur <span class="token operator">-</span> prev<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000_000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        prev <span class="token operator">=</span> cur<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code>输出结果<span class="token operator">:</span> 
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">500</span>
<span class="token number">499</span>
<span class="token number">499</span>
<span class="token number">500</span>
<span class="token number">499</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h5 id="经典限流算法-令牌桶算法"><a href="#经典限流算法-令牌桶算法" class="header-anchor">#</a> 经典限流算法:令牌桶算法</h5> <p>Guava 的限流器使用上还是很简单的, 那它是如何实现的呢? Guava 采用的是<mark><strong>令牌桶算法</strong></mark>, 其<strong>核心是要想通过限流器, 必须拿到令牌</strong>. 也就是说, 只要能够限制发放令牌的速率, 那么就能控制流速了. 令牌桶算法的详细描述如下:</p> <ol><li><strong>令牌以固定的速率添加到令牌桶中, 假设限流的速率是 r/ 秒, 则令牌每 1/r 秒会添加一个</strong>;</li> <li><strong>假设令牌桶的容量是 b, 如果令牌桶已满, 则新的令牌会被丢弃</strong>;</li> <li><strong>请求能够通过限流器的前提是令牌桶中有令牌</strong>.</li></ol> <p>这个算法中, 限流的速率 r 还是比较容易理解的, 但令牌桶的容量 b 该怎么理解呢? b 其实是 burst 的简写, 意义是<mark><strong>限流器允许的最大突发流量</strong></mark>. 比如 b=10, 而且令牌桶中的令牌已满, 此时限流器允许 10 个请求同时通过限流器, 当然只是突发流量而已, 这 10 个请求会带走 10 个令牌, 所以<strong>后续的流量只能按照速率 r 通过限流器</strong>.</p> <p>令牌桶这个算法, 如何用 Java 实现呢? 很可能你的直觉会告诉你生产者-消费者模式: 一个生产者线程定时向阻塞队列中添加令牌, 而试图通过限流器的线程则作为消费者线程, 只有从阻塞队列中获取到令牌, 才允许通过限流器.</p> <p>这个算法看上去非常完美, 而且实现起来非常简单, 如果并发量不大, 这个实现并没有什么问题. 可实际情况却是使用限流的场景大部分都是高并发场景, 而且系统压力已经临近极限了, 此时这个实现就有问题了. 问题就出在定时器上, 在高并发场景下, 当系统压力已经临近极限的时候, 定时器的精度误差会非常大, 同时定时器本身会创建调度线程, 也会对系统的性能产生影响.</p> <p>那还有什么好的实现方式呢? 当然有, Guava 的实现就<strong>没有使用定时器</strong>, 下面就来看看它是如何实现的.</p> <h5 id="guava如何实现令牌桶算法"><a href="#guava如何实现令牌桶算法" class="header-anchor">#</a> Guava如何实现令牌桶算法</h5> <p>Guava 实现令牌桶算法, 用了一个很简单的办法, 其关键是<strong>记录并动态计算下一令牌发放的时间</strong>. 下面以一个最简单的场景来介绍该算法的执行过程. 假设令牌桶的容量为 b=1, 限流速率 r = 1 个请求/秒, 如下图所示, 如果当前令牌桶中没有令牌, 下一个令牌的发放时间是在第 3 秒, 而在第 2 秒的时候有一个线程 T1 请求令牌, 此时该如何处理呢?</p> <p><img src="/img/1e37008a81dc1878d832df5c40ce9de1-20230731162452-cu7xjew.png" alt="" title="线程 T1 请求令牌示意图"></p> <p>对于这个请求令牌的线程而言, 很显然需要等待 1 秒, 因为 1 秒以后(第 3 秒)它就能拿到令牌了. 此时需要注意的是, 下一个令牌发放的时间也要增加 1 秒, 为什么呢? 因为第 3 秒发放的令牌已经被线程 T1 预占了. 处理之后如下图所示.</p> <p><img src="/img/1e43287d99cc0ecdf18a7cad5519f058-20230731162452-kz12562.png" alt="" title="线程 T1 请求结束示意图"></p> <p>假设 T1 在预占了第 3 秒的令牌之后, 马上又有一个线程 T2 请求令牌, 如下图所示.</p> <p><img src="/img/8f4e10b4ca1782cf3b961c32aaa0f42b-20230731162452-elynm1l.png" alt="" title="线程 T2 请求令牌示意图"></p> <p>很显然, 由于下一个令牌产生的时间是第 4 秒, 所以线程 T2 要等待两秒的时间, 才能获取到令牌, 同时由于 T2 预占了第 4 秒的令牌, 所以下一令牌产生时间还要增加 1 秒, 完全处理之后, 如下图所示.</p> <p><img src="/img/e70d6ba0ef51fe90749f9236778e5baa-20230731162452-vdudhwy.png" alt="" title="线程 T2 请求结束示意图"></p> <p>上面线程 T1, T2 都是在<strong>下一令牌产生时间之前</strong>请求令牌, 如果线程在<strong>下一令牌产生时间之后</strong>请求令牌会如何呢? 假设在线程 T1 请求令牌之后的 5 秒, 也就是第 7 秒, 线程 T3 请求令牌, 如下图所示.</p> <p><img src="/img/97fa907bb3b8fd42285b0bff9c7bd54d-20230731162452-pf1nj2u.png" alt="" title="线程 T3 请求令牌示意图"></p> <p>由于在第 5 秒已经产生了一个令牌, 所以此时线程 T3 可以直接拿到令牌, 而无需等待. 在第 7 秒, 实际上限流器能够产生 3 个令牌, 第 5, 6, 7 秒各产生一个令牌. 由于假设令牌桶的容量是 1, 所以第 6, 7 秒产生的令牌就丢弃了, 其实等价地也可以认为是保留的第 7 秒的令牌, 丢弃的第 5, 6 秒的令牌, 也就是说第 7 秒的令牌被线程 T3 占有了, 于是下一令牌的的产生时间应该是第 8 秒, 如下图所示.</p> <p><img src="/img/c20d810c7c85d61c091caa6f2b3bed2b-20230731162452-tv90sqy.png" alt="" title="线程 T3 请求结束示意图"></p> <p>通过上面简要地分析, 你会发现, <strong>只需要记录一个下一令牌产生的时间, 并动态更新它, 就能够轻松完成限流功能</strong>. 可以将上面的这个算法代码化, 示例代码如下所示, 依然假设令牌桶的容量是 1. 关键 是<strong>reserve() 方法</strong>, 这个方法会<strong>为请求令牌的线程预分配令牌, 同时返回该线程能够获取令牌的时间</strong>. 其实现逻辑就是上面提到的: 如果线程请求令牌的时间在下一令牌产生时间之后, 那么该线程立刻就能够获取令牌; 反之, 如果请求时间在下一令牌产生时间之前, 那么该线程是在下一令牌产生的时间获取令牌. 由于此时下一令牌已经被该线程预占, 所以下一令牌产生的时间需要加上 1 秒.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">SimpleLimiter</span> <span class="token punctuation">{</span>
    <span class="token comment">// 下一令牌产生时间</span>
    <span class="token keyword">long</span> next <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 发放令牌间隔: 纳秒</span>
    <span class="token keyword">long</span> interval <span class="token operator">=</span> <span class="token number">1000_000_000</span><span class="token punctuation">;</span>

    <span class="token comment">// 预占令牌, 返回能够获取令牌的时间</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">reserve</span><span class="token punctuation">(</span><span class="token keyword">long</span> now<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 请求时间在下一令牌产生时间之后</span>
        <span class="token comment">// 重新计算下一令牌产生时间</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">&gt;</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 将下一令牌产生时间重置为当前时间</span>
            next <span class="token operator">=</span> now<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 能够获取令牌的时间</span>
        <span class="token keyword">long</span> at <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token comment">// 设置下一令牌产生时间</span>
        next <span class="token operator">+=</span> interval<span class="token punctuation">;</span>
        <span class="token comment">// 返回线程需要等待的时间</span>
        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>at<span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 申请令牌</span>
    <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 申请令牌时的时间</span>
        <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 预占令牌</span>
        <span class="token keyword">long</span> at <span class="token operator">=</span> <span class="token function">reserve</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> waitTime <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>at <span class="token operator">-</span> now<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 按照条件等待</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>waitTime <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">NANOSECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><p>如果令牌桶的容量大于 1, 又该如何处理呢? 按照令牌桶算法, 令牌要首先从令牌桶中出, 所以需要按需计算令牌桶中的数量, 当有线程请求令牌时, 先从令牌桶中出. 具体的代码实现如下所示. 增加了一个 <strong>resync() 方法</strong>, 在这个方法中, 如果线程请求令牌的时间在下一令牌产生时间之后, 会重新计算令牌桶中的令牌数, <strong>新产生的令牌的计算公式是: (now-next)/interval</strong>, 可对照上面的示意图来理解. reserve() 方法中, 则增加了先从令牌桶中出令牌的逻辑, 不过需要注意的是, <strong>如果令牌是从令牌桶中出的, 那么 next 就无需增加一个 interval 了</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">SimpleLimiter</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当前令牌桶中的令牌数量</span>
    <span class="token keyword">long</span> storedPermits <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 令牌桶的容量</span>
    <span class="token keyword">long</span> maxPermits <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token comment">// 下一令牌产生时间</span>
    <span class="token keyword">long</span> next <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 发放令牌间隔: 纳秒</span>
    <span class="token keyword">long</span> interval <span class="token operator">=</span> <span class="token number">1000_000_000</span><span class="token punctuation">;</span>

    <span class="token comment">// 请求时间在下一令牌产生时间之后, 则</span>
    <span class="token comment">// 1. 重新计算令牌桶中的令牌数</span>
    <span class="token comment">// 2. 将下一个令牌发放时间重置为当前时间</span>
    <span class="token keyword">void</span> <span class="token function">resync</span><span class="token punctuation">(</span><span class="token keyword">long</span> now<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">&gt;</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 新产生的令牌数</span>
            <span class="token keyword">long</span> newPermits <span class="token operator">=</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> next<span class="token punctuation">)</span> <span class="token operator">/</span> interval<span class="token punctuation">;</span>
            <span class="token comment">// 新令牌增加到令牌桶</span>
            storedPermits <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>maxPermits<span class="token punctuation">,</span> storedPermits <span class="token operator">+</span> newPermits<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 将下一个令牌发放时间重置为当前时间</span>
            next <span class="token operator">=</span> now<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 预占令牌, 返回能够获取令牌的时间</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">reserve</span><span class="token punctuation">(</span><span class="token keyword">long</span> now<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resync</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 能够获取令牌的时间</span>
        <span class="token keyword">long</span> at <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token comment">// 令牌桶中能提供的令牌</span>
        <span class="token keyword">long</span> fb <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> storedPermits<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 令牌净需求: 首先减掉令牌桶中的令牌</span>
        <span class="token keyword">long</span> nr <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> fb<span class="token punctuation">;</span>
        <span class="token comment">// 重新计算下一令牌产生时间</span>
        next <span class="token operator">=</span> next <span class="token operator">+</span> nr <span class="token operator">*</span> interval<span class="token punctuation">;</span>
        <span class="token comment">// 重新计算令牌桶中的令牌</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>storedPermits <span class="token operator">-=</span> fb<span class="token punctuation">;</span>
        <span class="token keyword">return</span> at<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 申请令牌</span>
    <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 申请令牌时的时间</span>
        <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 预占令牌</span>
        <span class="token keyword">long</span> at <span class="token operator">=</span> <span class="token function">reserve</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> waitTime <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>at <span class="token operator">-</span> now<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 按照条件等待</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>waitTime <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">NANOSECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br></div></div><h5 id="总结-29"><a href="#总结-29" class="header-anchor">#</a> 总结</h5> <p>经典的限流算法有两个, 一个是<strong>令牌桶算法(Token Bucket)</strong> , 另一个是<strong>漏桶算法(Leaky Bucket)</strong> . 令牌桶算法是定时向令牌桶发送令牌, 请求能够从令牌桶中拿到令牌, 然后才能通过限流器; 而漏桶算法里, 请求就像水一样注入漏桶, 漏桶会按照一定的速率自动将水漏掉, 只有漏桶里还能注入水的时候, 请求才能通过限流器. 令牌桶算法和漏桶算法很像一个硬币的正反面, 所以可以参考令牌桶算法的实现来实现漏桶算法.</p> <p>上面介绍了 Guava 是如何实现令牌桶算法的, 示例代码是对 Guava RateLimiter 的简化, Guava RateLimiter 扩展了标准的令牌桶算法, 比如还能支持预热功能. 对于按需加载的缓存来说, 预热后缓存能支持 5 万 TPS 的并发, 但是在预热前 5 万 TPS 的并发直接就把缓存击垮了, 所以如果需要给该缓存限流, 限流器也需要支持预热功能, 在初始阶段, 限制的流速 r 很小, 但是动态增长的. 预热功能的实现非常复杂, Guava 构建了一个积分函数来解决这个问题, 如果你感兴趣, 可以继续深入研究.</p> <h4 id="_39-案例分析-二-高性能网络应用框架netty"><a href="#_39-案例分析-二-高性能网络应用框架netty" class="header-anchor">#</a> 39-案例分析(二):高性能网络应用框架Netty</h4> <p>Netty 是一个高性能网络应用框架, 应用非常普遍, 目前在 Java 领域里, Netty 基本上成为网络程序的标配了. Netty 框架功能丰富, 也非常复杂, 今天主要分析 Netty 框架中的线程模型, 而<strong>线程模型直接影响着网络程序的性能</strong>.</p> <p>在介绍 Netty 的线程模型之前, 首先需要把问题搞清楚, 了解网络编程性能的瓶颈在哪里, 然后再看 Netty 的线程模型是如何解决这个问题的.</p> <h5 id="网络编程性能的瓶颈"><a href="#网络编程性能的瓶颈" class="header-anchor">#</a> 网络编程性能的瓶颈</h5> <p>前面写过一个简单的网络程序 echo, 采用的是阻塞式 I/O(BIO). BIO 模型里, 所有 read() 操作和 write() 操作都会<strong>阻塞当前线程</strong>的, 如果客户端已经和服务端建立了一个连接, 而迟迟不发送数据, 那么服务端的 read() 操作会一直阻塞, 所以<strong>使用 BIO 模型, 一般都会为每个 socket 分配一个独立的线程</strong>, 这样就不会因为线程阻塞在一个 socket 上而影响对其他 socket 的读写. BIO 的线程模型如下图所示, 每一个 socket 都对应一个独立的线程; 为了避免频繁创建, 消耗线程, 可以采用线程池, 但是 socket 和线程之间的对应关系并不会变化.</p> <p>​<img src="/img/dc1d37a4a6e770f9b05196b2c86be40f-20230731162452-bvixg6m.png" alt="" title="BIO 的线程模型">​</p> <p>BIO 这种线程模型<strong>适用于 socket 连接不是很多</strong>的场景; 但是现在的互联网场景, 往往需要服务器能够支撑十万甚至百万连接, 而创建十万甚至上百万个线程显然并不现实, 所以 BIO 线程模型无法解决百万连接的问题. 如果仔细观察, 你会发现互联网场景中, 虽然连接多, <strong>但是每个连接上的请求并不频繁</strong>, 所以线程大部分时间都在等待 I/O 就绪. 也就是说线程大部分时间都阻塞在那里, 这完全是浪费, 如果能够解决这个问题, 那就不需要这么多线程了.</p> <p>顺着这个思路, 可以将线程模型优化为下图这个样子, <strong>可以用一个线程来处理多个连接</strong>, 这样线程的利用率就上来了, 同时所需的线程数量也跟着降下来了. 这个思路很好, 可是使用 BIO 相关的 API 是无法实现的, 这是为什么呢? 因为 BIO 相关的 socket 读写操作都是<strong>阻塞式</strong>的, 而一旦调用了阻塞式 API, 在 I/O 就绪前, 调用线程会一直阻塞, 也就无法处理其他的 socket 连接了.</p> <p>​<img src="/img/0b42103a8b1f9bb7930091ab269ce56c-20230731162452-ammcbuo.png" alt="" title="理想的线程模型图">​</p> <p>好在 Java 里还提供了非阻塞式(NIO)API, <strong>利用非阻塞式 API 就能够实现一个线程处理多个连接了</strong>. 那具体如何实现呢? 现在普遍都是<strong>采用 Reactor 模式</strong>, 包括 Netty 的实现. 所以, 要想理解 Netty 的实现, 接下来我们就需要先了解一下 Reactor 模式.</p> <h5 id="reactor模式"><a href="#reactor模式" class="header-anchor">#</a> Reactor模式</h5> <p>下面是 Reactor 模式的类结构图, 其中 Handle 指的是 I/O 句柄, 在 Java 网络编程里, 它本质上就是一个网络连接. Event Handler 很容易理解, 就是一个事件处理器, 其中 handle_event() 方法处理 I/O 事件, 也就是每个 Event Handler 处理一个 I/O Handle; get_handle() 方法可以返回这个 I/O 的 Handle. Synchronous Event Demultiplexer 可以理解为操作系统提供的 I/O 多路复用 API, 例如 POSIX 标准里的 select() 以及 Linux 里面的 epoll().</p> <p><img src="/img/78d19ce7b7bb310cbb5a26446062c6fc-20230731162452-6vhkh10.png" alt="" title="Reactor 模式类结构图"></p> <p>Reactor 模式的核心自然是 <strong>Reactor 这个类</strong>, 其中 register_handler() 和 remove_handler() 这两个方法可以注册和删除一个事件处理器; <strong>handle_events() 方式是核心</strong>, 也是 Reactor 模式的发动机, 这个方法的核心逻辑如下: 首先通过同步事件多路选择器提供的 select() 方法监听网络事件, 当有网络事件就绪后, 就遍历事件处理器来处理该网络事件. 由于网络事件是源源不断的, 所以在主程序中启动 Reactor 模式, 需要以 <code>while(true){}</code>​ 的方式调用 handle_events() 方法.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token class-name">Reactor</span><span class="token operator">::</span><span class="token function">handle_events</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 通过同步事件多路选择器提供的</span>
    <span class="token comment">//select() 方法监听网络事件</span>
    <span class="token function">select</span><span class="token punctuation">(</span>handlers<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 处理网络事件</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>h in handlers<span class="token punctuation">)</span><span class="token punctuation">{</span>
        h<span class="token punctuation">.</span><span class="token function">handle_event</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 在主程序中启动事件循环</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">handle_events</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h5 id="netty中的线程模型"><a href="#netty中的线程模型" class="header-anchor">#</a> Netty中的线程模型</h5> <p>Netty 的实现虽然参考了 Reactor 模式, 但是并没有完全照搬, <strong>Netty 中最核心的概念是事件循环(EventLoop)</strong> , 其实也就是 Reactor 模式中的 Reactor, <strong>负责监听网络事件并调用事件处理器进行处理</strong>. 在 4.x 版本的 Netty 中, 网络连接和 EventLoop 是稳定的多对 1 关系, 而 EventLoop 和 Java 线程是 1 对 1 关系, 这里的稳定指的是关系一旦确定就不再发生变化. 也就是<strong>说一个网络连接只会对应唯一的一个 EventLoop, 而一个 EventLoop 也只会对应到一个 Java 线程, 所以一个网络连接只会对应到一个 Java 线程</strong>.</p> <p>一个网络连接对应到一个 Java 线程上, 有什么好处呢? 最大的好处就是对于一个网络连接的事件处理是单线程的, 这样就<strong>避免了各种并发问题</strong>.</p> <p>Netty 中的线程模型可以参考下图, 这个图和前面提到的理想的线程模型图非常相似, 核心目标都是用一个线程处理多个网络连接.</p> <p><img src="/img/a2178bbe275aff26662fc96142ceed36-20230731162452-36h31zj.png" alt="" title="Netty 中的线程模型"></p> <p>Netty 中还有一个核心概念是 <strong>EventLoopGroup</strong>, 顾名思义, 一个 EventLoopGroup 由一组 EventLoop 组成. 实际使用中, 一般都会创建两个 EventLoopGroup, <strong>一个称为 bossGroup, 一个称为 workerGroup</strong>. 为什么会有两个 EventLoopGroup 呢?</p> <p>这个和 socket 处理网络请求的机制有关, socket 处理 TCP 网络<strong>连接请求</strong>, 是在一个独立的 socket 中, 每当有一个 TCP 连接成功建立, 都会<strong>创建一个新的 socket</strong>, 之后对 TCP <strong>连接的读写都是由新创建处理的 socket 完成的</strong>. 也就是说<strong>处理 TCP 连接请求和读写请求是通过两个不同的 socket 完成的</strong>. 上面在讨论网络请求的时候, 为了简化模型, 只是讨论了读写请求, 而没有讨论连接请求.</p> <p><strong>在 Netty 中,</strong> <mark><strong>bossGroup 就用来处理连接请求的, 而 workerGroup 是用来处理读写请求的</strong></mark>. bossGroup 处理完连接请求后, 会将这个连接<strong>提交给 workerGroup 来处理</strong>,  workerGroup 里面有多个 EventLoop, 那新的连接会交给哪个 EventLoop 来处理呢? 这就需要一个负载均衡算法, Netty 中目前使用的是<strong>轮询算法</strong>.</p> <p>下面用 Netty 重新实现以下 echo 程序的服务端, 近距离感受一下 Netty.</p> <h5 id="用netty实现echo程序服务端"><a href="#用netty实现echo程序服务端" class="header-anchor">#</a> 用Netty实现Echo程序服务端</h5> <p>下面的示例代码基于 Netty 实现了 echo 程序服务端: 首先创建了一个事件处理器(等同于 Reactor 模式中的事件处理器), 然后创建了 bossGroup 和 workerGroup, 再之后创建并初始化了 ServerBootstrap, 代码还是很简单的, 不过有两个地方需要注意一下.</p> <p>第一个, 如果 NettybossGroup <strong>只监听一个端口</strong>, 那 bossGroup 只需要 1 个 EventLoop 就可以了, 多了纯属浪费.</p> <p>第二个, 默认情况下, <strong>Netty 会创建 &quot;2*CPU 核数&quot; 个 EventLoop</strong>, 由于网络连接与 EventLoop 有稳定的关系, 所以事件处理器在处理网络事件的时候是不能有阻塞操作的, 否则很容易导致请求大面积超时. 如果实在无法避免使用阻塞操作, 那可以通过线程池来异步处理.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 事件处理器</span>
<span class="token keyword">final</span> <span class="token class-name">EchoServerHandler</span> serverHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EchoServerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//boss 线程组  </span>
<span class="token class-name">EventLoopGroup</span> bossGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//worker 线程组  </span>
<span class="token class-name">EventLoopGroup</span> workerGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token class-name">ServerBootstrap</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>bossGroup<span class="token punctuation">,</span> workerGroup<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>serverHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//bind 服务端端口  </span>
    <span class="token class-name">ChannelFuture</span> f <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token number">9090</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    f<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">closeFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token comment">// 终止工作线程组</span>
    workerGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 终止 boss 线程组</span>
    bossGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//socket 连接处理器</span>
<span class="token keyword">class</span> <span class="token class-name">EchoServerHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理读事件  </span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ctx<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 处理读完成事件</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelReadComplete</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ctx<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 处理异常事件</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exceptionCaught</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cause<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ctx<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><h5 id="总结-30"><a href="#总结-30" class="header-anchor">#</a> 总结</h5> <p>Netty 是一个款优秀的网络编程框架, 性能非常好, 为了实现高性能的目标, Netty 做了很多优化, 例如优化了 ByteBuffer, 支持零拷贝等等, 和并发编程相关的就是它的线程模型了. Netty 的线程模型设计得很精巧, 每个网络连接都关联到了一个线程上, 这样做的好处是: 对于一个网络连接, 读写操作都是单线程执行的, 从而避免了并发程序的各种问题.</p> <h4 id="_40-案例分析-三-高性能队列disruptor"><a href="#_40-案例分析-三-高性能队列disruptor" class="header-anchor">#</a> 40-案例分析(三):高性能队列Disruptor</h4> <p>前面介绍过 Java SDK 提供了 2 个有界队列: ArrayBlockingQueue 和 LinkedBlockingQueue, 它们都是基于 ReentrantLock 实现的, 在高并发场景下, 锁的效率并不高, 那有没有更好的替代品呢? 有, 今天就介绍一种性能更高的有界队列: <strong>Disruptor</strong>.</p> <p><strong>Disruptor 是一款高性能的有界内存队列</strong>, 目前应用非常广泛, Log4j2, Spring Messaging, HBase, Storm 都用到了 Disruptor, 那 Disruptor 的性能为什么这么高呢? Disruptor 项目团队曾经写过一篇论文, 详细解释了其原因, 可以总结为如下:</p> <ol><li>内存分配更加合理, 使用 <strong>RingBuffer</strong> 数据结构, 数组元素在初始化时一次性全部创建, 提升缓存命中率; 对象循环利用, 避免频繁 GC.</li> <li>能够避免伪共享, 提升缓存利用率.</li> <li>采用<strong>无锁算法</strong>, 避免频繁加锁, 解锁的性能消耗.</li> <li>支持<strong>批量消费</strong>, 消费者可以无锁方式消费多个消息.</li></ol> <p>其中, 前三点涉及到的知识比较多, 所以今天重点讲解前三点, 不过在详细介绍这些知识之前, 先来聊聊 Disruptor 如何使用, 好让你先对 Disruptor 有个感官的认识.</p> <p>下面的代码出自官方示例, 这里略做了一些修改, 相较而言, Disruptor 的使用比 Java SDK 提供 BlockingQueue 要复杂一些, 但是总体思路还是一致的, 其大致情况如下:</p> <ul><li>在 Disruptor 中, <strong>生产者生产的对象(也就是消费者消费的对象)称为 Event, 使用 Disruptor 必须自定义 Event</strong>, 例如示例代码的自定义 Event 是 LongEvent;</li> <li>构建 Disruptor 对象除了要指定队列大小外, 还需要传入一个 <strong>EventFactory</strong>, 示例代码中传入的是<code>LongEvent::new</code>​;</li> <li><strong>消费 Disruptor 中的 Event 需要通过 handleEventsWith() 方法注册一个事件处理器, 发布 Event 则需要通过 publishEvent() 方法</strong>.</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 自定义 Event</span>
<span class="token keyword">class</span> <span class="token class-name">LongEvent</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> value<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">long</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 指定 RingBuffer 大小,</span>
<span class="token comment">// 必须是 2 的 N 次方</span>
<span class="token keyword">int</span> bufferSize <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>

<span class="token comment">// 构建 Disruptor</span>
<span class="token class-name">Disruptor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LongEvent</span><span class="token punctuation">&gt;</span></span> disruptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Disruptor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>
        <span class="token class-name">LongEvent</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">,</span>
        bufferSize<span class="token punctuation">,</span>
        <span class="token class-name">DaemonThreadFactory</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 注册事件处理器</span>
disruptor<span class="token punctuation">.</span><span class="token function">handleEventsWith</span><span class="token punctuation">(</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> sequence<span class="token punctuation">,</span> endOfBatch<span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;E: &quot;</span> <span class="token operator">+</span> event<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 启动 Disruptor</span>
disruptor<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取 RingBuffer</span>
<span class="token class-name">RingBuffer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LongEvent</span><span class="token punctuation">&gt;</span></span> ringBuffer <span class="token operator">=</span> disruptor<span class="token punctuation">.</span><span class="token function">getRingBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 生产 Event</span>
<span class="token class-name">ByteBuffer</span> bb <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token boolean">true</span><span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bb<span class="token punctuation">.</span><span class="token function">putLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 生产者生产消息</span>
    ringBuffer<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> sequence<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
                    event<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><h5 id="ringbuffer如何提升性能"><a href="#ringbuffer如何提升性能" class="header-anchor">#</a> RingBuffer如何提升性能</h5> <p>Java SDK 中 ArrayBlockingQueue 使用<strong>数组</strong>作为底层的数据存储, 而 Disruptor 是使用 <strong>RingBuffer</strong> 作为数据存储. RingBuffer 本质上也是数组, 所以仅仅将数据存储从数组换成 RingBuffer 并不能提升性能, 但是 Disruptor 在 RingBuffer 的基础上还做了很多优化, 其中一项优化就是和<strong>内存分配</strong>有关的.</p> <p>在介绍这项优化之前, 需要先了解一下程序的局部性原理. 简单来讲, <strong>程序的局部性原理指的是在一段时间内程序的执行会限定在一个局部范围内</strong>. 这里的 &quot;局部性&quot; 可以从两个方面来理解, 一个是时间局部性, 另一个是空间局部性. <strong>时间局部性</strong>指的是程序中的某条指令一旦被执行, 不久之后这条指令很可能再次被执行; 如果某条数据被访问, 不久之后这条数据很可能再次被访问. 而<strong>空间局部性</strong>是指某块内存一旦被访问, 不久之后这块内存附近的内存也很可能被访问.</p> <p>CPU 的缓存就利用了程序的局部性原理: CPU 从内存中加载数据 X 时, 会将数据 X 缓存在高速缓存 Cache 中, 实际上 CPU 缓存 X 的同时, 还缓存了 X 周围的数据, 因为根据程序具备局部性原理, X 周围的数据也很有可能被访问. 从另外一个角度来看, 如果程序能够很好地体现出局部性原理, 也就能更好地利用 CPU 的缓存, 从而提升程序的性能. Disruptor 在设计 RingBuffer 的时候就充分考虑了这个问题, 下面就对比着 ArrayBlockingQueue 来分析一下.</p> <p>首先是 ArrayBlockingQueue. 生产者线程向 ArrayBlockingQueue 增加一个元素, 每次增加元素 E 之前, 都需要创建一个对象 E, 如下图所示, ArrayBlockingQueue 内部有 6 个元素, 这 6 个元素都是由生产者线程创建的, 由于创建这些元素的时间基本上是离散的, 所以<strong>这些元素的内存地址大概率也不是连续</strong>的.</p> <p><img src="/img/84d6e8357b51c15316082da59a790a39-20230731162452-5spvmm0.png" alt="" title="ArrayBlockingQueue 内部结构图"></p> <p>下面再看看 Disruptor 是如何处理的. Disruptor 内部的 RingBuffer 也是用数组实现的, <mark><strong>但是这个数组中的所有元素在初始化时是一次性全部创建的, 所以这些元素的内存地址大概率是连续的</strong></mark>, 相关的代码如下所示.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bufferSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// entries[] 就是 RingBuffer 内部的数组</span>
    <span class="token comment">// eventFactory 就是前面示例代码中传入的 LongEvent::new</span>
    entries<span class="token punctuation">[</span><span class="token constant">BUFFER_PAD</span> <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> eventFactory<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Disruptor 内部 RingBuffer 的结构可以简化成下图, 那问题来了, 数组中所有元素内存地址连续能提升性能吗? 能! 为什么呢? <strong>因为消费者线程在消费的时候, 是遵循空间局部性原理的, 消费完第 1 个元素, 很快就会消费第 2 个元素; 当消费第 1 个元素 E1 的时候, CPU 会把内存中 E1 后面的数据也加载进 Cache, 如果 E1 和 E2 在内存中的地址是连续的, 那么 E2 也就会被加载进 Cache 中, 然后当消费第 2 个元素的时候, 由于 E2 已经在 Cache 中了, 所以就不需要从内存中加载了, 这样就能大大提升性能</strong>.</p> <p><img src="/img/cc8d72e6c1e319b3b9e555de3c5caaa9-20230731162452-q83hk2j.png" alt="" title="Disruptor 内部 RingBuffer 结构图"></p> <p>除此之外, 在 Disruptor 中, 生产者线程通过 publishEvent() 发布 Event 的时候, 并不是创建一个新的 Event, 而是通过 event.set() 方法修改 Event, 也就是说 RingBuffer 创建的 Event 是可以<strong>循环利用</strong>的, 这样还能避免频繁创建, 删除 Event 导致的频繁 GC 问题.</p> <h5 id="如何避免-伪共享"><a href="#如何避免-伪共享" class="header-anchor">#</a> 如何避免&quot;伪共享&quot;</h5> <p>高效利用 Cache, 能够大大提升性能, 所以要努力构建能够<strong>高效利用 Cache 的内存结构</strong>. 而从另外一个角度看, 努力避免不能高效利用 Cache 的内存结构也同样重要.</p> <p>有一种叫做 &quot;伪共享(False sharing)&quot; 的内存布局就会使 Cache 失效, 那什么是 &quot;伪共享&quot; 呢?</p> <p>伪共享和 CPU 内部的 Cache 有关, Cache 内部是按照<strong>缓存行</strong>(Cache Line)管理的, 缓存行的大小通常是 64 个字节; CPU 从内存中加载数据 X, 会同时加载 X 后面(64-size(X))个字节的数据. 下面的示例代码出自 Java SDK 的 ArrayBlockingQueue, 其内部维护了 4 个成员变量, 分别是队列数组 items, 出队索引 takeIndex, 入队索引 putIndex 以及队列中的元素总数 count.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/** 队列数组 */</span>
<span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>
<span class="token comment">/** 出队索引 */</span>
<span class="token keyword">int</span> takeIndex<span class="token punctuation">;</span>
<span class="token comment">/** 入队索引 */</span>
<span class="token keyword">int</span> putIndex<span class="token punctuation">;</span>
<span class="token comment">/** 队列中元素总数 */</span>
<span class="token keyword">int</span> count<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>当 CPU 从内存中加载 takeIndex 的时候, 会同时将 putIndex 以及 count 都加载进 Cache. 下图是某个时刻 CPU 中 Cache 的状况, 为了简化, 缓存行中仅列出了 takeIndex 和 putIndex.</p> <p><img src="/img/ce695c16357fe49d3328775b2078d810-20230731162452-1ix6sno.png" alt="" title="CPU 缓存示意图"></p> <p>假设线程 A 运行在 CPU-1 上, 执行入队操作, 入队操作会修改 putIndex, 而修改 putIndex 会导致其所在的所有核上的缓存行均失效; 此时假设运行在 CPU-2 上的线程执行出队操作, 出队操作需要读取 takeIndex, 由于 takeIndex 所在的缓存行<strong>已经失效</strong>, 所以 CPU-2 必须从内存中重新读取. 入队操作本不会修改 takeIndex, 但是由于 takeIndex 和 putIndex 共享的是一个缓存行, 就导致出队操作不能很好地利用 Cache, 这其实就是<strong>伪共享</strong>. 简单来讲, <strong>伪共享指的是由于共享缓存行导致缓存无效的场景</strong>.</p> <p>ArrayBlockingQueue 的入队和出队操作是用锁来保证互斥的, 所以入队和出队不会同时发生. 如果允许入队和出队同时发生, 那就会导致线程 A 和线程 B 争用同一个缓存行, 这样也会导致性能问题. 所以为了更好地利用缓存, 必须避免伪共享, 那如何避免呢?</p> <p><img src="/img/0b1b0428a2fc16e33291633e95e8819b-20230731162452-bysb6jx.png" alt="" title="CPU 缓存失效示意图"></p> <p>方案很简单, <mark><strong>每个变量独占一个缓存行, 不共享缓存行</strong></mark>就可以了, 具体技术是<strong>缓存行填充</strong>. 比如想让 takeIndex 独占一个缓存行, 可以在 takeIndex 的前后各填充 56 个字节, 这样就一定能保证 takeIndex 独占一个缓存行. 下面的示例代码出自 Disruptor, <strong>Sequence 对象中的 value 属性就能避免伪共享, 因为这个属性前后都填充了 56 个字节</strong>. Disruptor 中很多对象, 例如 RingBuffer, RingBuffer 内部的数组都用到了这种填充技术来避免伪共享.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 前: 填充 56 字节</span>
<span class="token keyword">class</span> <span class="token class-name">LhsPadding</span><span class="token punctuation">{</span>
    <span class="token keyword">long</span> p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">,</span> p4<span class="token punctuation">,</span> p5<span class="token punctuation">,</span> p6<span class="token punctuation">,</span> p7<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Value</span> <span class="token keyword">extends</span> <span class="token class-name">LhsPadding</span><span class="token punctuation">{</span>
    <span class="token keyword">volatile</span> <span class="token keyword">long</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 后: 填充 56 字节</span>
<span class="token keyword">class</span> <span class="token class-name">RhsPadding</span> <span class="token keyword">extends</span> <span class="token class-name">Value</span><span class="token punctuation">{</span>
    <span class="token keyword">long</span> p9<span class="token punctuation">,</span> p10<span class="token punctuation">,</span> p11<span class="token punctuation">,</span> p12<span class="token punctuation">,</span> p13<span class="token punctuation">,</span> p14<span class="token punctuation">,</span> p15<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Sequence</span> <span class="token keyword">extends</span> <span class="token class-name">RhsPadding</span><span class="token punctuation">{</span>
  <span class="token comment">// 省略实现</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h5 id="disruptor中的无锁算法"><a href="#disruptor中的无锁算法" class="header-anchor">#</a> Disruptor中的无锁算法</h5> <p>ArrayBlockingQueue 是利用管程实现的, 中规中矩, 生产, 消费操作都需要加锁, 实现起来简单, 但是性能并不十分理想. Disruptor 采用的是无锁算法, 很复杂, 但是核心无非是生产和消费两个操作. Disruptor 中最复杂的是入队操作, 所以重点来看看入队操作是如何实现的.</p> <p>对于入队操作, 最关键的要求是<strong>不能覆盖没有消费的元素</strong>; 对于出队操作, 最关键的要求是<strong>不能读取没有写入的元素</strong>, 所以 Disruptor 中也一定会维护类似出队索引和入队索引这样两个关键变量. Disruptor 中的 RingBuffer 维护了入队索引, 但是并没有维护出队索引, 这是因为在 Disruptor 中多个消费者可以同时消费, 每个消费者都会有一个出队索引, 所以 RingBuffer 的出队索引是所有消费者里面<strong>最小的那一个</strong>.</p> <p>下面是 Disruptor 生产者入队操作的核心代码, 看上去很复杂, 其实逻辑很简单: 如果没有足够的空余位置, 就出让 CPU 使用权, 然后重新计算; 反之则用 CAS 设置入队索引.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 生产者获取 n 个写入位置</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token comment">//cursor 类似于入队索引, 指的是上次生产到这里</span>
    current <span class="token operator">=</span> cursor<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 目标是在生产 n 个</span>
    next <span class="token operator">=</span> current <span class="token operator">+</span> n<span class="token punctuation">;</span>
    <span class="token comment">// 减掉一个循环</span>
    <span class="token keyword">long</span> wrapPoint <span class="token operator">=</span> next <span class="token operator">-</span> bufferSize<span class="token punctuation">;</span>
    <span class="token comment">// 获取上一次的最小消费位置</span>
    <span class="token keyword">long</span> cachedGatingSequence <span class="token operator">=</span> gatingSequenceCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 没有足够的空余位置</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>wrapPoint <span class="token operator">&gt;</span> cachedGatingSequence <span class="token operator">||</span> cachedGatingSequence <span class="token operator">&gt;</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 重新计算所有消费者里面的最小值位置</span>
        <span class="token keyword">long</span> gatingSequence <span class="token operator">=</span> <span class="token class-name">Util</span><span class="token punctuation">.</span><span class="token function">getMinimumSequence</span><span class="token punctuation">(</span>gatingSequences<span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 仍然没有足够的空余位置, 出让 CPU 使用权, 重新执行下一循环</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>wrapPoint <span class="token operator">&gt;</span> gatingSequence<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 从新设置上一次的最小消费位置</span>
        gatingSequenceCache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>gatingSequence<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cursor<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取写入位置成功, 跳出循环</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h5 id="总结-31"><a href="#总结-31" class="header-anchor">#</a> 总结</h5> <p>Disruptor 在优化并发性能方面可谓是做到了极致, 优化的思路大体是两个方面, <strong>一个是利用无锁算法避免锁的争用, 另外一个则是将硬件(CPU)的性能发挥到极致</strong>. 尤其是后者, 在 Java 领域基本上属于经典之作了.</p> <p>发挥硬件的能力一般是 C 这种面向硬件的语言常干的事儿, C 语言领域经常通过调整内存布局优化内存占用, 而 Java 领域则用的很少, 原因在于 Java 可以智能地优化内存布局, 内存布局对 Java 程序员的透明的. 这种智能的优化大部分场景是很友好的, 但是如果想通过填充方式避免伪共享就必须绕过这种优化, 关于这方面 Disruptor 提供了经典的实现, 你可以参考.</p> <h4 id="_41-案例分析-四-高性能数据库连接池hikaricp"><a href="#_41-案例分析-四-高性能数据库连接池hikaricp" class="header-anchor">#</a> 41-案例分析(四):高性能数据库连接池HiKariCP</h4> <p>实际工作中, 总会难免和数据库打交道; 只要和数据库打交道, 就免不了使用数据库连接池. 业界知名的数据库连接池有不少, 例如 c3p0, DBCP, Tomcat JDBC Connection Pool, Druid 等, 不过最近大火的是 HiKariCP.</p> <p><strong>HiKariCP 号称是业界跑得最快的数据库连接池</strong>, 这两年发展得顺风顺水, 尤其是 Springboot 2.0 将其作为<strong>默认数据库连接池</strong>后, 江湖一哥的地位已是毋庸置疑了. 那它为什么那么快呢? 今天就重点聊聊这个话题.</p> <h5 id="什么是数据库连接池"><a href="#什么是数据库连接池" class="header-anchor">#</a> 什么是数据库连接池</h5> <p>在详细分析 HiKariCP 高性能之前, 有必要先简单介绍一下什么是数据库连接池. 本质上, 数据库连接池和线程池一样, 都属于<strong>池化资源</strong>, 作用都是<strong>避免重量级资源的频繁创建和销毁, 对于数据库连接池来说, 也就是避免数据库连接频繁创建和销毁</strong>. 如下图所示, 服务端会在<strong>运行期持有一定数量的数据库连接, 当需要执行 SQL 时, 并不是直接创建一个数据库连接, 而是从连接池中获取一个; 当 SQL 执行完, 也并不是将数据库连接真的关掉, 而是将其归还到连接池中</strong>.</p> <p><img src="/img/4e6a5f30f0a40628f5abd1690328c9da-20230731162452-rkvwrks.png" alt="" title="数据库连接池示意图"></p> <p>在实际工作中, 都是使用各种持久化框架来完成数据库的增删改查, 基本上不会直接和数据库连接池打交道, 为了能更好地理解数据库连接池的工作原理, 下面的示例代码并没有使用任何框架, 而是原生地使用 HiKariCP. 执行数据库操作基本上是一系列规范化的步骤:</p> <ol><li>通过数据源获取一个数据库连接;</li> <li>创建 Statement;</li> <li>执行 SQL;</li> <li>通过 ResultSet 获取 SQL 执行结果;</li> <li>释放 ResultSet;</li> <li>释放 Statement;</li> <li>释放数据库连接.</li></ol> <p>下面的示例代码, 通过 <code>ds.getConnection()</code>​ 获取一个<strong>数据库连接</strong>时, 其实是向数据库连接池<strong>申请</strong>一个数据库连接, 而不是创建一个新的数据库连接. 同样, 通过 <code>conn.close()</code>​ 释放一个数据库连接时, 也不是直接将连接关闭, 而是将连接<strong>归还</strong>给数据库连接池.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 数据库连接池配置</span>
<span class="token class-name">HikariConfig</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HikariConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
config<span class="token punctuation">.</span><span class="token function">setMinimumIdle</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
config<span class="token punctuation">.</span><span class="token function">setMaximumPoolSize</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
config<span class="token punctuation">.</span><span class="token function">setConnectionTestQuery</span><span class="token punctuation">(</span><span class="token string">&quot;SELECT 1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
config<span class="token punctuation">.</span><span class="token function">setDataSourceClassName</span><span class="token punctuation">(</span><span class="token string">&quot;org.h2.jdbcx.JdbcDataSource&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
config<span class="token punctuation">.</span><span class="token function">addDataSourceProperty</span><span class="token punctuation">(</span><span class="token string">&quot;url&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;jdbc:h2:mem:test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建数据源</span>
<span class="token class-name">DataSource</span> ds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HikariDataSource</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token class-name">Statement</span> stmt <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token class-name">ResultSet</span> rs <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取数据库连接</span>
    conn <span class="token operator">=</span> ds<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建 Statement </span>
    stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 执行 SQL</span>
    rs <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token string">&quot;select * from abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取结果</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> id <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ......</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token comment">// 关闭 ResultSet</span>
    <span class="token function">close</span><span class="token punctuation">(</span>rs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 关闭 Statement </span>
    <span class="token function">close</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 关闭 Connection</span>
    <span class="token function">close</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 关闭资源</span>
<span class="token keyword">void</span> close <span class="token punctuation">(</span><span class="token class-name">AutoCloseable</span> rs<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            rs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><p><a href="https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole" target="_blank" rel="noopener noreferrer">HiKariCP 官方网站<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>解释了其性能之所以如此之高的秘密. 微观上 HiKariCP 程序编译出的字节码执行效率更高, 站在字节码的角度去优化 Java 代码, HiKariCP 的作者对性能的执着可见一斑, 不过遗憾的是他并没有详细解释都做了哪些优化. 而宏观上主要是和<strong>两个数据结构</strong>有关, 一个是 <strong>FastList</strong>, 另一个是 <strong>ConcurrentBag</strong>. 下面来看看它们是如何提升 HiKariCP 的性能的.</p> <h5 id="fastlist解决了哪些性能问题"><a href="#fastlist解决了哪些性能问题" class="header-anchor">#</a> FastList解决了哪些性能问题</h5> <p>按照规范步骤, 执行完数据库操作之后, 需要依次关闭 ResultSet, Statement, Connection, 但是总有粗心的同学只是关闭了 Connection, 而忘了关闭 ResultSet 和 Statement. 为了解决这种问题, 最好的办法是当关闭 Connection 时, 能够<strong>自动关闭 Statemen</strong>t. 为了达到这个目标, Connection 就需要跟踪创建的 Statement, 最简单的办法就是将创建的 Statement 保存在数组 ArrayList 里, 这样当关闭 Connection 的时候, 就可以依次将数组中的所有 Statement 关闭.</p> <p>HiKariCP 觉得用 ArrayList 还是太慢, 当通过 <code>conn.createStatement()</code> 创建一个 Statement 时, 需要调用 ArrayList 的 add() 方法加入到 ArrayList 中, 这个是没有问题的; 但是当通过 <code>stmt.close()</code> 关闭 Statement 的时候, 需要调用 ArrayList 的 remove() 方法来将其从 ArrayList 中删除, 这里是有优化余地的.</p> <p>假设一个 Connection 依次创建 6 个 Statement, 分别是 S1, S2, S3, S4, S5, S6, 按照正常的编码习惯, 关闭 Statement 的顺序一般是逆序的, 关闭的顺序是: S6, S5, S4, S3, S2, S1, 而 ArrayList 的 remove(Object o) 方法是顺序遍历查找, 逆序删除而顺序查找, 这样的查找效率就太慢了. 如何优化呢? 很简单, 优化成逆序查找就可以了.</p> <p>​<img src="/img/27c29fa3eeeee1cb1efc2b9a763c2810-20230731162452-whwjv0q.png" alt="" title="逆序删除示意图">​</p> <p>HiKariCP 中的 FastList 相对于 ArrayList 的一个优化点就是将 <code>remove(Object element)</code>​ 方法的<strong>查找顺序变成了逆序查找</strong>. 除此之外, FastList 还有另一个优化点, 是 <code>get(int index)</code>​ 方法没有对 index 参数进行越界检查, HiKariCP 能保证<strong>不会越界</strong>, 所以不用每次都进行越界检查.</p> <p>整体来看, FastList 的优化点还是很简单的. 下面再来聊聊 HiKariCP 中的另外一个数据结构 ConcurrentBag, 看看它又是如何提升性能的.</p> <h5 id="concurrentbag解决了哪些性能问题"><a href="#concurrentbag解决了哪些性能问题" class="header-anchor">#</a> ConcurrentBag解决了哪些性能问题</h5> <p>如果自己来实现一个数据库连接池, 最简单的办法就是用<strong>两个阻塞队列</strong>来实现, 一个<strong>用于保存空闲数据库连接的队列 idle, 另一个用于保存忙碌数据库连接的队列 busy; 获取连接时将空闲的数据库连接从 idle 队列移动到 busy 队列, 而关闭连接时将数据库连接从 busy 移动到 idle</strong>. 这种方案将并发问题委托给了阻塞队列, 实现简单, 但是性能并不是很理想. 因为 Java SDK 中的阻塞队列是用<strong>锁</strong>实现的, 而高并发场景下锁的争用对性能影响很大.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 忙碌队列</span>
<span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Connection</span><span class="token punctuation">&gt;</span></span> busy<span class="token punctuation">;</span>
<span class="token comment">// 空闲队列</span>
<span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Connection</span><span class="token punctuation">&gt;</span></span> idle<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>HiKariCP 并没有使用 Java SDK 中的阻塞队列, 而是自己实现了一个<strong>叫做 ConcurrentBag 的并发容器</strong>. ConcurrentBag 的设计最初源自 <code>C#</code>​, 它的一个核心设计是<strong>使用 ThreadLocal 避免部分并发问题</strong>, 不过 HiKariCP 中的 ConcurrentBag 并没有完全参考 C# 的实现, 下面来看看它是如何实现的.</p> <p>ConcurrentBag 中最关键的属性有 4 个, 分别是: <strong>用于存储所有的数据库连接的共享队列 sharedList, 线程本地存储 threadList, 等待数据库连接的线程数 waiters 以及分配数据库连接的工具 handoffQueue</strong>. 其中, handoffQueue 用的是 Java SDK 提供的 SynchronousQueue, SynchronousQueue 主要用于线程之间传递数据.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 用于存储所有的数据库连接</span>
<span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> sharedList<span class="token punctuation">;</span>
<span class="token comment">// 线程本地存储中的数据库连接</span>
<span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> threadList<span class="token punctuation">;</span>
<span class="token comment">// 等待数据库连接的线程数</span>
<span class="token class-name">AtomicInteger</span> waiters<span class="token punctuation">;</span>
<span class="token comment">// 分配数据库连接的工具</span>
<span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> handoffQueue<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>当线程池创建了一个数据库连接时, 通过调用 ConcurrentBag 的 add() 方法加入到 ConcurrentBag 中, 下面是 add() 方法的具体实现, 逻辑很简单, 就是将这个连接加入到共享队列 sharedList 中, 如果此时有线程在等待数据库连接, 那么就通过 handoffQueue 将这个连接分配给等待的线程.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 将空闲连接添加到队列</span>
<span class="token keyword">void</span> add <span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">T</span> bagEntry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 加入共享队列</span>
    sharedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>bagEntry<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果有等待连接的线程, </span>
    <span class="token comment">// 则通过 handoffQueue 直接分配给等待的线程</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>waiters<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span>
            <span class="token operator">&amp;&amp;</span> bagEntry<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">STATE_NOT_IN_USE</span>
            <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>handoffQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>bagEntry<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>通过 ConcurrentBag 提供的 borrow() 方法, <strong>可以获取一个空闲的数据库连接</strong>, borrow() 的主要逻辑是:</p> <ol><li>首先查看线程本地存储是否有空闲连接, 如果有, 则返回一个空闲的连接;</li> <li>如果线程本地存储中无空闲连接, 则从共享队列中获取.</li> <li>如果共享队列中也没有空闲的连接, 则请求线程需要等待.</li></ol> <p>需要注意的是, 线程本地存储中的连接是可以被其他线程窃取的, 所以需要用 CAS 方法防止重复分配. 在共享队列中获取空闲连接, 也采用了 CAS 方法防止重复分配.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">T</span> <span class="token function">borrow</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">TimeUnit</span> timeUnit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先查看线程本地存储是否有空闲连接</span>
    <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> threadList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token class-name">Object</span> entry <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">T</span> bagEntry <span class="token operator">=</span> weakThreadLocals <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> entry<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> entry<span class="token punctuation">;</span>
        <span class="token comment">// 线程本地存储中的连接也可以被窃取, </span>
        <span class="token comment">// 所以需要用 CAS 方法防止重复分配</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>bagEntry <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> bagEntry<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token constant">STATE_NOT_IN_USE</span><span class="token punctuation">,</span> <span class="token constant">STATE_IN_USE</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> bagEntry<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 线程本地存储中无空闲连接, 则从共享队列中获取</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> waiting <span class="token operator">=</span> waiters<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">T</span> bagEntry <span class="token operator">:</span> sharedList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果共享队列中有空闲连接, 则返回</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>bagEntry<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token constant">STATE_NOT_IN_USE</span><span class="token punctuation">,</span> <span class="token constant">STATE_IN_USE</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> bagEntry<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 共享队列中没有连接, 则需要等待</span>
        timeout <span class="token operator">=</span> timeUnit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            <span class="token keyword">final</span> <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token function">currentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">final</span> <span class="token class-name">T</span> bagEntry <span class="token operator">=</span> handoffQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>timeout<span class="token punctuation">,</span> <span class="token constant">NANOSECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>bagEntry <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> bagEntry<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token constant">STATE_NOT_IN_USE</span><span class="token punctuation">,</span> <span class="token constant">STATE_IN_USE</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> bagEntry<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 重新计算等待时间</span>
            timeout <span class="token operator">-=</span> <span class="token function">elapsedNanos</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>timeout <span class="token operator">&gt;</span> <span class="token number">10_000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 超时没有获取到连接, 返回 null</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        waiters<span class="token punctuation">.</span><span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><p><strong>释放连接需要调用 ConcurrentBag 提供的 requite() 方法</strong>, 该方法的逻辑很简单, 首先将数据库连接状态更改为 STATE_NOT_IN_USE, 之后查看是否存在等待线程, 如果有, 则分配给等待线程; 如果没有, 则将该数据库连接保存到线程本地存储里.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 释放连接</span>
<span class="token keyword">void</span> <span class="token function">requite</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">T</span> bagEntry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 更新连接状态</span>
    bagEntry<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token constant">STATE_NOT_IN_USE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果有等待的线程, 则直接分配给线程, 无需进入任何队列</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> waiters<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>bagEntry<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">STATE_NOT_IN_USE</span>
                <span class="token operator">||</span> handoffQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>bagEntry<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0xff</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token constant">MICROSECONDS</span><span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果没有等待的线程, 则进入线程本地存储</span>
    <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> threadLocalList <span class="token operator">=</span> threadList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>threadLocalList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        threadLocalList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>weakThreadLocals
                <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>bagEntry<span class="token punctuation">)</span>
                <span class="token operator">:</span> bagEntry<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h5 id="总结-32"><a href="#总结-32" class="header-anchor">#</a> 总结</h5> <p>HiKariCP 中的 FastList 和 ConcurrentBag 这两个数据结构使用得非常巧妙, 虽然实现起来并不复杂, 但是对于性能的提升非常明显, 根本原因在于这两个数据结构适用于数据库连接池这个特定的场景. <strong>FastList 适用于逆序删除场景; 而 ConcurrentBag 通过 ThreadLocal 做一次预分配, 避免直接竞争共享资源, 非常适合池化资源的分配</strong>.</p> <p>在实际工作中遇到的并发问题千差万别, 这时选择合适的并发数据结构就非常重要了. 当然能选对的前提是对特定场景的并发特性有深入的了解, 只有了解到无谓的性能消耗在哪里, 才能对症下药.</p> <h3 id="其他并发模型"><a href="#其他并发模型" class="header-anchor">#</a> 其他并发模型</h3> <h4 id="_42-actor模型-面向对象原生的并发模型"><a href="#_42-actor模型-面向对象原生的并发模型" class="header-anchor">#</a> 42-Actor模型:面向对象原生的并发模型</h4> <p>按照面向对象编程的理论, 对象之间通信需要依靠<strong>消息</strong>, 而实际上, 像 C++, Java 这些面向对象的语言, 对象之间通信, 依靠的是<strong>对象方法</strong>. 对象方法和过程语言里的函数本质上没有区别, 有入参, 有出参, 思维方式很相似, 使用起来都很简单. 那面向对象理论里的消息是否就等价于面向对象语言里的对象方法呢? 很长一段时间里, 我都以为对象方法是面向对象理论中消息的一种实现, 直到接触到 Actor 模型, 才明白消息压根不是这个实现法.</p> <h5 id="hello-actor模型"><a href="#hello-actor模型" class="header-anchor">#</a> Hello Actor模型</h5> <p>Actor 模型本质上是一种<strong>计算模型</strong>, 基本的计算单元称为 Actor, 换言之, <strong>在 Actor 模型中, 所有的计算都是在 Actor 中执行的</strong>. 在面向对象编程里面, 一切都是对象; <strong>在 Actor 模型里, 一切都是 Actor, 并且 Actor 之间是完全隔离的, 不会共享任何变量</strong>.</p> <p>当看到 &quot;不共享任何变量&quot; 的时候, 相信你一定会眼前一亮, 并发问题的根源就在于共享变量, 而 Actor 模型中 Actor 之间不共享变量, 那用 Actor 模型解决并发问题, 一定是相当顺手. 的确是这样, 所以很多人就把 Actor 模型定义为一种<strong>并发计算模型</strong>. 其实 Actor 模型早在 1973 年就被提出来了, 只是直到最近几年才被广泛关注, 一个主要原因就在于它是解决并发问题的利器, 而最近几年随着多核处理器的发展, 并发问题被推到了风口浪尖上.</p> <p><strong>但是 Java 语言本身并不支持 Actor 模型</strong>, 所以如果想在 Java 语言里使用 Actor 模型, 就需要借助第三方类库, 目前能完备地支持 Actor 模型而且比较成熟的类库就是 <strong>Akka</strong> 了. 在详细介绍 Actor 模型之前, 就先基于 Akka 写一个 Hello World 程序, 让你对 Actor 模型先有个感官的印象.</p> <p>在下面的示例代码中, 首先创建了一个 ActorSystem(Actor 不能脱离 ActorSystem 存在); 之后创建了一个 HelloActor, Akka 中创建 Actor 并不是 new 一个对象出来, 而是通过调用 system.actorOf() 方法创建的, 该方法返回的是 ActorRef, 而不是 HelloActor; 最后通过调用 ActorRef 的 tell() 方法给 HelloActor 发送了一条消息 &quot;Actor&quot;.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 该 Actor 当收到消息 message 后, </span>
<span class="token comment">// 会打印 Hello message</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">HelloActor</span> <span class="token keyword">extends</span> <span class="token class-name">UntypedActor</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onReceive</span><span class="token punctuation">(</span><span class="token class-name">Object</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello &quot;</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建 Actor 系统</span>
    <span class="token class-name">ActorSystem</span> system <span class="token operator">=</span> <span class="token class-name">ActorSystem</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">&quot;HelloSystem&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建 HelloActor</span>
    <span class="token class-name">ActorRef</span> helloActor <span class="token operator">=</span> system<span class="token punctuation">.</span><span class="token function">actorOf</span><span class="token punctuation">(</span><span class="token class-name">Props</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">HelloActor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 发送消息给 HelloActor</span>
    helloActor<span class="token punctuation">.</span><span class="token function">tell</span><span class="token punctuation">(</span><span class="token string">&quot;Actor&quot;</span><span class="token punctuation">,</span> <span class="token class-name">ActorRef</span><span class="token punctuation">.</span><span class="token function">noSender</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>通过这个例子, 你会发现 Actor 模型和面向对象编程契合度非常高, <strong>完全可以用 Actor 类比面向对象编程里面的对象, 而且 Actor 之间的通信方式完美地遵守了消息机制, 而不是通过对象方法来实现对象之间的通信</strong>. 那 Actor 中的消息机制和面向对象语言里的对象方法有什么区别呢?</p> <h5 id="消息和对象方法的区别"><a href="#消息和对象方法的区别" class="header-anchor">#</a> 消息和对象方法的区别</h5> <p>在没有计算机的时代, 异地的朋友往往是通过写信来交流感情的, 但信件发出去之后, 也许会在寄送过程中弄丢了, 也有可能寄到后, 对方一直没有时间写回信...这个时候都可以让邮局 &quot;背个锅&quot;, 不过无论如何, 也不过是重写一封, 生活继续.</p> <p>Actor 中的消息机制, 就可以类比这现实世界里的写信. <strong>Actor 内部有一个邮箱(Mailbox), 接收到的消息都是先放到邮箱里, 如果邮箱里有积压的消息, 那么新收到的消息就不会马上得到处理, 也正是因为 Actor 使用单线程处理消息, 所以不会出现并发问题</strong>. 你可以把 Actor 内部的工作模式想象成只有一个消费者线程的生产者-消费者模式.</p> <p>所以, 在 Actor 模型里, 发送消息仅仅是把消息发出去而已, 接收消息的 Actor 在接收到消息后, 也不一定会立即处理, 也就是说 <strong>Actor 中的消息机制完全是异步的</strong>. 而<strong>调用对象方法</strong>, 实际上是<strong>同步</strong>的, 对象方法 return 之前, 调用方会一直等待.</p> <p>除此之外, <strong>调用对象方法</strong>, 需要持有对象的引用, <strong>所有的对象必须在同一个进程中</strong>. 而在 Actor 中发送消息, 类似于现实中的写信, 只需要知道对方的地址就可以, <strong>发送消息和接收消息的 Actor 可以不在一个进程中, 也可以不在同一台机器上</strong>. 因此, Actor 模型<strong>不但适用于并发计算, 还适用于分布式计算</strong>.</p> <h5 id="actor的规范化定义"><a href="#actor的规范化定义" class="header-anchor">#</a> Actor的规范化定义</h5> <p>通过上面的介绍, 相信你应该已经对 Actor 有一个感官印象了, 下面再来看看 Actor 规范化的定义是什么样的. Actor 是一种基础的计算单元, 具体来讲包括三部分能力, 分别是:</p> <ol><li><strong>处理能力, 处理接收到的消息</strong>.</li> <li><strong>存储能力, Actor 可以存储自己的内部状态, 并且内部状态在不同 Actor 之间是绝对隔离的</strong>.</li> <li><strong>通信能力, Actor 可以和其他 Actor 之间通信</strong>.</li></ol> <p>当一个 Actor 接收的一条消息之后, 这个 Actor 可以做以下三件事:</p> <ol><li>创建更多的 Actor;</li> <li>发消息给其他 Actor;</li> <li>确定如何处理下一条消息.</li></ol> <p>其中前两条还是很好理解的, 就是最后一条, 该如何去理解呢? 前面说过 Actor 具备存储能力, 它有自己的内部状态, 所以也可以把 Actor 看作一个<strong>状态机</strong>, 把 Actor <strong>处理消息看作是触发状态机的状态变化</strong>; 而状态机的变化往往要基于上一个状态, 触发状态机发生变化的时刻, 上一个状态必须是确定的, 所以确定如何处理下一条消息, 本质上不过是改变内部状态.</p> <p>在多线程里面, 由于可能存在竞态条件, 所以根据当前状态确定如何处理下一条消息还是有难度的, 需要使用各种同步工具, 但在 Actor 模型里, 由于是<strong>单线程处理, 所以就不存在竞态条件问题</strong>了.</p> <h5 id="用actor实现累加器"><a href="#用actor实现累加器" class="header-anchor">#</a> 用Actor实现累加器</h5> <p>支持并发的累加器可能是最简单并且有代表性的并发问题了, 可以基于互斥锁方案实现, 也可以基于原子类实现, 但今天要尝试用 Actor 来实现.</p> <p>在下面的示例代码中, CounterActor 内部持有累计值 counter, 当 CounterActor 接收到一个数值型的消息 message 时, 就将累计值 counter += message; 但如果是其他类型的消息, 则打印当前累计值 counter. 在 main() 方法中, 启动了 4 个线程来执行累加操作. 整个程序没有锁, 也没有 CAS, 但是程序是线程安全的.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 累加器</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CounterActor</span> <span class="token keyword">extends</span> <span class="token class-name">UntypedActor</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onReceive</span><span class="token punctuation">(</span><span class="token class-name">Object</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果接收到的消息是数字类型, 执行累加操作, </span>
        <span class="token comment">// 否则打印 counter 的值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>message <span class="token keyword">instanceof</span> <span class="token class-name">Number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            counter <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Number</span><span class="token punctuation">)</span> message<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建 Actor 系统</span>
    <span class="token class-name">ActorSystem</span> system <span class="token operator">=</span> <span class="token class-name">ActorSystem</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">&quot;HelloSystem&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//4 个线程生产消息</span>
    <span class="token class-name">ExecutorService</span> es <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建 CounterActor </span>
    <span class="token class-name">ActorRef</span> counterActor <span class="token operator">=</span> system<span class="token punctuation">.</span><span class="token function">actorOf</span><span class="token punctuation">(</span><span class="token class-name">Props</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">CounterActor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 生产 4*100000 个消息 </span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        es<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                counterActor<span class="token punctuation">.</span><span class="token function">tell</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">ActorRef</span><span class="token punctuation">.</span><span class="token function">noSender</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 关闭线程池</span>
    es<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 等待 CounterActor 处理完所有消息</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 打印结果</span>
    counterActor<span class="token punctuation">.</span><span class="token function">tell</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> <span class="token class-name">ActorRef</span><span class="token punctuation">.</span><span class="token function">noSender</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 关闭 Actor 系统</span>
    system<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><h5 id="总结-33"><a href="#总结-33" class="header-anchor">#</a> 总结</h5> <p><strong>Actor 模型是一种非常简单的计算模型, 其中 Actor 是最基本的计算单元, Actor 之间是通过消息进行通信</strong>. Actor 与面向对象编程(OOP)中的对象匹配度非常高, 在面向对象编程里, 系统由类似于生物细胞那样的对象构成, 对象之间也是通过消息进行通信, 所以在面向对象语言里使用 Actor 模型基本上不会有违和感.</p> <p>在 Java 领域, 除了可以使用 Akka 来支持 Actor 模型外, 还可以使用 Vert.x, 不过相对来说 Vert.x 更像是 Actor 模型的隐式实现, 对应关系不像 Akka 那样明显, 不过本质上也是一种 Actor 模型.</p> <p>Actor 可以创建新的 Actor, 这些 Actor 最终会呈现出一个树状结构, 非常像现实世界里的组织结构, 所以利用 Actor 模型来对程序进行建模, 和现实世界的匹配度非常高. Actor 模型和现实世界一样都是异步模型, 理论上不保证消息百分百送达, 也不保证消息送达的顺序和发送的顺序是一致的, 甚至无法保证消息会被百分百处理. 虽然实现 Actor 模型的厂商都在试图解决这些问题, 但遗憾的是解决得并不完美, 所以使用 Actor 模型也是有成本的.</p> <h4 id="_43-软件事务内存-借鉴数据库的并发经验"><a href="#_43-软件事务内存-借鉴数据库的并发经验" class="header-anchor">#</a> 43-软件事务内存:借鉴数据库的并发经验</h4> <p>很多同学反馈说, 工作了挺长时间但是没有机会接触并发编程, 实际上很多人天天都在写并发程序, 只不过并发相关的问题都被类似 Tomcat 这样的 Web 服务器以及 MySQL 这样的数据库解决了. 尤其是数据库, 在解决并发问题方面, 可谓成绩斐然, 它的<strong>事务机制非常简单易用</strong>, 能甩 Java 里面的锁, 原子类十条街. 技术无边界, 很显然要借鉴一下.</p> <p>其实很多编程语言都有从数据库的事务管理中获得灵感, 并且总结出了一个新的并发解决方案: <strong>软件事务内存(Software Transactional Memory, 简称 STM)</strong> . 传统的数据库事务, 支持 4 个特性: 原子性(Atomicity), 一致性(Consistency), 隔离性(Isolation)和持久性(Durability), 也就是大家常说的 ACID, STM 由于不涉及到持久化, 所以只支持 ACI.</p> <p>STM 的使用很简单, 下面以经典的转账操作为例, 看看用 STM 该如何实现.</p> <h5 id="用stm实现转账"><a href="#用stm实现转账" class="header-anchor">#</a> 用STM实现转账</h5> <p>前面曾经讲到并发转账的例子, 示例代码如下. 简单地使用 synchronized 将 transfer() 方法变成同步方法并不能解决并发问题, 因为还存在死锁问题.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">UnsafeAccount</span> <span class="token punctuation">{</span>
    <span class="token comment">// 余额</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> balance<span class="token punctuation">;</span>

    <span class="token comment">// 构造函数</span>
    <span class="token keyword">public</span> <span class="token class-name">UnsafeAccount</span><span class="token punctuation">(</span><span class="token keyword">long</span> balance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">=</span> balance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 转账</span>
    <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">UnsafeAccount</span> target<span class="token punctuation">,</span> <span class="token keyword">long</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">&gt;</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>
            target<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>该转账操作若使用数据库事务就会非常简单, 如下面的示例代码所示. 如果所有 SQL 都正常执行, 则通过 commit() 方法提交事务; 如果 SQL 在执行过程中有异常, 则通过 rollback() 方法回滚事务. 数据库保证在并发情况下不会有死锁, 而且还能保证前面说的原子性, 一致性, 隔离性和持久性, 也就是 ACID.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取数据库连接</span>
    conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置手动提交事务</span>
    conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 执行转账 SQL</span>
    <span class="token comment">// ......</span>
    <span class="token comment">// 提交事务</span>
    conn<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 出现异常回滚事务</span>
    conn<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>那如果用 STM 又该如何实现呢? Java 语言并不支持 STM, 不过可以借助第三方的类库来支持, <a href="https://github.com/pveentjer/Multiverse" target="_blank" rel="noopener noreferrer">Multiverse<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 就是个不错的选择. 下面的示例代码就是借助 Multiverse 实现了线程安全的转账操作, 相比较上面线程不安全的 UnsafeAccount, 其改动并不大, 仅仅是将余额的类型从 long 变成了 TxnLong , 将转账的操作放到了 <code>atomic(()-&gt;{})</code>​ 中.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>
    <span class="token comment">// 余额</span>
    <span class="token keyword">private</span> <span class="token class-name">TxnLong</span> balance<span class="token punctuation">;</span>

    <span class="token comment">// 构造函数</span>
    <span class="token keyword">public</span> <span class="token class-name">Account</span><span class="token punctuation">(</span><span class="token keyword">long</span> balance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">=</span> <span class="token class-name">StmUtils</span><span class="token punctuation">.</span><span class="token function">newTxnLong</span><span class="token punctuation">(</span>balance<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 转账</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> <span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 原子化操作</span>
        <span class="token function">atomic</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">.</span><span class="token function">decrement</span><span class="token punctuation">(</span>amt<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">to</span><span class="token punctuation">.</span>balance<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span>amt<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>一个关键的 atomic() 方法就把并发问题解决了, 这个方案看上去比传统的方案的确简单了很多, 那它是如何实现的呢? 数据库事务发展了几十年了, 目前被广泛使用的是 <strong>MVCC</strong>(全称是 Multi-Version Concurrency Control), 也就是<strong>多版本并发控制</strong>.</p> <p>MVCC 可以简单地理解为数据库事务在开启的时候, 会给数据库打一个快照, <strong>以后所有的读写都是基于这个快照的</strong>. 当提交事务的时候, 如果所有读写过的数据在该事务执行期间没有发生过变化, 那么就可以提交; 如果发生了变化, 说明该事务和有其他事务读写的数据冲突了, 这个时候是不可以提交的.</p> <p>为了记录数据是否发生了变化, 可以给每条数据<strong>增加一个版本号</strong>, 这样每次成功修改数据都会增加版本号的值. MVCC 的工作原理与乐观锁非常相似. 有不少 STM 的实现方案都是基于 MVCC 的, 例如知名的 Clojure STM.</p> <p>下面就用最简单的代码基于 MVCC 实现一个简版的 STM, 这样你会对 STM 以及 MVCC 的工作原理有更深入的认识.</p> <h5 id="自己实现stm"><a href="#自己实现stm" class="header-anchor">#</a> 自己实现STM</h5> <p>首先要做的, 就是让 Java 中的对象有<strong>版本号</strong>, 在下面的示例代码中, VersionedRef 这个类的作用就是将对象 value 包装成带版本号的对象. 按照 MVCC 理论, <strong>数据的每一次修改都对应着一个唯一的版本号</strong>, 所以不存在仅仅改变 value 或者 version 的情况, 用不变性模式就可以很好地解决这个问题, 所以 VersionedRef 这个类被设计成了不可变的.</p> <p>所有对数据的读写操作, 一定是在一个事务里面, TxnRef 这个类负责完成事务内的读写操作, 读写操作委托给了接口 Txn, Txn 代表的是读写操作所在的当前事务,  内部持有的 curRef 代表的是系统中的最新值.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 带版本号的对象引用</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">VersionedRef</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">T</span> value<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">long</span> version<span class="token punctuation">;</span>

    <span class="token comment">// 构造方法</span>
    <span class="token keyword">public</span> <span class="token class-name">VersionedRef</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">,</span> <span class="token keyword">long</span> version<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>version <span class="token operator">=</span> version<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 支持事务的引用</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TxnRef</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 当前数据, 带版本号</span>
    <span class="token keyword">volatile</span> <span class="token class-name">VersionedRef</span> curRef<span class="token punctuation">;</span>

    <span class="token comment">// 构造方法</span>
    <span class="token keyword">public</span> <span class="token class-name">TxnRef</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>curRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VersionedRef</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 获取当前事务中的数据</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token class-name">Txn</span> txn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> txn<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 在当前事务中设置数据</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">,</span> <span class="token class-name">Txn</span> txn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        txn<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>STMTxn <strong>是 Txn 最关键的一个实现类</strong>, 事务内对于数据的读写, 都是通过它来完成的. STMTxn 内部有两个 Map: inTxnMap, 用于保存当前事务中所有读写的数据的快照; writeMap, 用于保存当前事务需要写入的数据. 每个事务都有一个唯一的事务 ID txnId, 这个 txnId 是全局递增的.</p> <p>STMTxn 有三个核心方法, 分别是读数据的 get() 方法, 写数据的 set() 方法和提交事务的 commit() 方法. 其中, get() 方法将要读取数据作为快照放入 inTxnMap, 同时保证每次读取的数据都是一个版本. set() 方法会将要写入的数据放入 writeMap, 但如果写入的数据没被读取过, 也会将其放入 inTxnMap.</p> <p>至于 commit() 方法, 为了简化实现, 使用了互斥锁, 所以事务的提交是串行的. commit() 方法的实现很简单, 首先检查 inTxnMap 中的数据是否发生过变化, 如果没有发生变化, 那么就将 writeMap 中的数据写入(这里的写入其实就是 TxnRef 内部持有的 curRef); 如果发生过变化, 那么就不能将 writeMap 中的数据写入了.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 事务接口</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Txn</span> <span class="token punctuation">{</span>
    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">TxnRef</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> ref<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">TxnRef</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> ref<span class="token punctuation">,</span> <span class="token class-name">T</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//STM 事务实现类</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">STMTxn</span> <span class="token keyword">implements</span> <span class="token class-name">Txn</span> <span class="token punctuation">{</span>
    <span class="token comment">// 事务 ID 生成器</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">AtomicLong</span> txnSeq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 当前事务所有的相关数据</span>
    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TxnRef</span><span class="token punctuation">,</span> <span class="token class-name">VersionedRef</span><span class="token punctuation">&gt;</span></span> inTxnMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 当前事务所有需要修改的数据</span>
    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TxnRef</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> writeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 当前事务 ID</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> txnId<span class="token punctuation">;</span>

    <span class="token comment">// 构造函数, 自动生成当前事务 ID</span>
    <span class="token class-name">STMTxn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        txnId <span class="token operator">=</span> txnSeq<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 获取当前事务中的数据</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">TxnRef</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将需要读取的数据, 加入 inTxnMap</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inTxnMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            inTxnMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> ref<span class="token punctuation">.</span>curRef<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> inTxnMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 在当前事务中修改数据</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">TxnRef</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> ref<span class="token punctuation">,</span> <span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将需要修改的数据, 加入 inTxnMap</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inTxnMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            inTxnMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> ref<span class="token punctuation">.</span>curRef<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        writeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 提交事务</span>
    <span class="token keyword">boolean</span> <span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token constant">STM</span><span class="token punctuation">.</span>commitLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 是否校验通过</span>
            <span class="token keyword">boolean</span> isValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token comment">// 校验所有读过的数据是否发生过变化</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TxnRef</span><span class="token punctuation">,</span> <span class="token class-name">VersionedRef</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> inTxnMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">VersionedRef</span> curRef <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>curRef<span class="token punctuation">;</span>
                <span class="token class-name">VersionedRef</span> readRef <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 通过版本号来验证数据是否发生过变化</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>curRef<span class="token punctuation">.</span>version <span class="token operator">!=</span> readRef<span class="token punctuation">.</span>version<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    isValid <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 如果校验通过, 则所有更改生效</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>isValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                writeMap<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                    k<span class="token punctuation">.</span>curRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VersionedRef</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> txnId<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> isValid<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br></div></div><p>下面来模拟实现 Multiverse 中的原子化操作 atomic(). atomic() 方法中使用了类似于 CAS 的操作, 如果事务提交失败, 那么就重新创建一个新的事务, 重新执行.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TxnRunnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Txn</span> txn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// STM</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">STM</span> <span class="token punctuation">{</span>
    <span class="token comment">// 私有化构造方法</span>
    <span class="token keyword">private</span> <span class="token function">STM</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 提交数据需要用到的全局锁  </span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> commitLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 原子化提交方法</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> atomic <span class="token punctuation">(</span><span class="token class-name">TxnRunnable</span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">boolean</span> committed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果没有提交成功, 则一直重试</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>committed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 创建新的事务</span>
                <span class="token class-name">STMTxn</span> txn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">STMTxn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 执行业务逻辑</span>
                action<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>txn<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 提交事务</span>
                committed <span class="token operator">=</span> txn<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>就这样自己实现了 STM, 并完成了线程安全的转账操作, 使用方法和 Multiverse 差不多, 这里就不赘述了, 具体代码如下面所示.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>
    <span class="token comment">// 余额</span>
    <span class="token keyword">private</span> <span class="token class-name">TxnRef</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> balance<span class="token punctuation">;</span>

    <span class="token comment">// 构造方法</span>
    <span class="token keyword">public</span> <span class="token class-name">Account</span><span class="token punctuation">(</span><span class="token keyword">int</span> balance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TxnRef</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>balance<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 转账操作</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token constant">STM</span><span class="token punctuation">.</span><span class="token function">atomic</span><span class="token punctuation">(</span><span class="token punctuation">(</span>txn<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">Integer</span> from <span class="token operator">=</span> balance<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>txn<span class="token punctuation">)</span><span class="token punctuation">;</span>
            balance<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>from <span class="token operator">-</span> amt<span class="token punctuation">,</span> txn<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Integer</span> <span class="token keyword">to</span> <span class="token operator">=</span> target<span class="token punctuation">.</span>balance<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>txn<span class="token punctuation">)</span><span class="token punctuation">;</span>
            target<span class="token punctuation">.</span>balance<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token keyword">to</span> <span class="token operator">+</span> amt<span class="token punctuation">,</span> txn<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h5 id="总结-34"><a href="#总结-34" class="header-anchor">#</a> 总结</h5> <p>STM 借鉴的是数据库的经验, 数据库虽然复杂, 但仅仅存储数据, 而编程语言除了有共享变量之外, 还会执行各种 I/O 操作, 很显然 I/O 操作是很难支持回滚的. 所以, STM 也不是万能的. <strong>目前支持 STM 的编程语言主要是函数式语言, 函数式语言里的数据天生具备不可变性, 利用这种不可变性实现 STM 相对来说更简单</strong>.</p> <h4 id="_44-协程-更轻量级的线程"><a href="#_44-协程-更轻量级的线程" class="header-anchor">#</a> 44-协程:更轻量级的线程</h4> <p>Java 语言里解决并发问题靠的是多线程, 但<strong>线程是个重量级的对象, 不能频繁创建, 销毁, 而且线程切换的成本也很高</strong>, 为了解决这些问题, Java SDK 提供了线程池. 然而用好线程池并不容易, Java 围绕线程池提供了很多工具类, 这些工具类学起来也不容易. 那有没有更好的解决方案呢? Java 语言里目前还没有, 但是其他语言里有, 这个方案就是<strong>协程</strong>(Coroutine).</p> <p><mark>可以把</mark>​<mark><strong>协程</strong></mark>​<mark>简单地理解</mark>​<mark><strong>为一种轻量级的线程</strong></mark>. <strong>从操作系统的角度来看,</strong> <mark><strong>线程是在内核态中调度的, 而协程是在用户态调度的</strong></mark>​ <strong>, 所以相对于线程来说, 协程切换的成本更低. 协程虽然也有自己的栈, 但是相比线程栈要小得多, 典型的线程栈大小差不多有 1M, 而协程栈的大小往往只有几 K 或者几十 K. 所以, 无论是从时间维度还是空间维度来看, 协程都比线程轻量得多</strong>.</p> <p>支持协程的语言还是挺多的, 例如 Golang, Python, Lua, Kotlin 等都支持协程. 下面就以 Golang 为代表, 看看协程是如何在 Golang 中使用的.</p> <h5 id="golang中的协程"><a href="#golang中的协程" class="header-anchor">#</a> Golang中的协程</h5> <p>在 Golang 中创建协程非常简单, 在下面的示例代码中, 要让 hello() 方法在一个<strong>新的协程</strong>中执行, 只需要 <code>go hello(&quot;World&quot;)</code>​ 这一行代码就搞定了. 可以对比着想想在 Java 里是如何&quot;辛勤&quot;地创建线程和线程池的吧, 我的感觉一直都是: 每次写完 Golang 的代码, 就再也不想写 Java 代码了.</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span>msg <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello &quot;</span> <span class="token operator">+</span> msg<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在新的协程中执行 hello 方法</span>
	<span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token string">&quot;World&quot;</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Run in main&quot;</span><span class="token punctuation">)</span>
    <span class="token comment">// 等待 100 毫秒让协程执行结束</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>前面介绍过, 利用协程能够很好地实现 Thread-Per-Message 模式. Thread-Per-Message 模式非常简单, 其实越是简单的模式, 功能上就越稳定, 可理解性也越好.</p> <p>下面的示例代码是用 Golang 实现的 echo 程序的服务端, 用的是 Thread-Per-Message 模式, 为每个成功建立连接的 socket 分配一个协程, 相比 Java 线程池的实现方案, Golang 中协程的方案更简单.</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;log&quot;</span>
	<span class="token string">&quot;net&quot;</span>
<span class="token punctuation">)</span>
 
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 监听本地 9090 端口</span>
	socket<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">&quot;tcp&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;127.0.0.1:9090&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		log<span class="token punctuation">.</span><span class="token function">Panicln</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">defer</span> socket<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
        <span class="token comment">// 处理连接请求  </span>
		conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> socket<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			log<span class="token punctuation">.</span><span class="token function">Panicln</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 处理已经成功建立连接的请求</span>
		<span class="token keyword">go</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 处理已经成功建立连接的请求</span>
<span class="token keyword">func</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span>conn net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>
        <span class="token comment">// 读取请求数据</span>
		size<span class="token punctuation">,</span> err <span class="token operator">:=</span> conn<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 回写相应数据  </span>
		conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><h5 id="利用协程实现同步"><a href="#利用协程实现同步" class="header-anchor">#</a> 利用协程实现同步</h5> <p>其实协程并不仅限于实现 Thread-Per-Message 模式, 它还可以<strong>将异步模式转换为同步模式</strong>. 异步编程虽然近几年取得了长足发展, 但是异步的思维模式对于普通人来讲毕竟是有难度的, 只有线性的思维模式才是适合所有人的. 而线性的思维模式反映到编程世界, 就是同步.</p> <p>在 Java 里使用多线程并发地处理 I/O, 基本上用的都是<strong>异步非阻塞模型</strong>, 这种模型的异步主要是<strong>靠注册回调函数</strong>实现的, 那能否都使用同步处理呢? 显然是不能的. 因为<strong>同步意味着等待, 而线程等待, 本质上就是一种严重的浪费</strong>. 不过对于协程来说, 等待的成本就没有那么高了, 所以基于协程实现<strong>同步非阻塞</strong>是一个可行的方案.</p> <p>OpenResty 里实现的 cosocket 就是一种同步非阻塞方案, 借助 cosocket 可以用线性的思维模式来编写非阻塞的程序. 下面的示例代码是用 cosocket 实现的 socket 程序的客户端, 建立连接, 发送请求, 读取响应所有的操作都是同步的, 由于 cosocket 本身是非阻塞的, 所以这些操作虽然是同步的, 但是并不会阻塞.</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token operator">--</span> 创建 socket
local sock <span class="token operator">=</span> ngx<span class="token punctuation">.</span>socket<span class="token punctuation">.</span><span class="token function">tcp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">--</span> 设置 socket 超时时间
sock<span class="token punctuation">:</span><span class="token function">settimeouts</span><span class="token punctuation">(</span>connect_timeout<span class="token punctuation">,</span> send_timeout<span class="token punctuation">,</span> read_timeout<span class="token punctuation">)</span>
<span class="token operator">--</span> 连接到目标地址
local ok<span class="token punctuation">,</span> err <span class="token operator">=</span> sock<span class="token punctuation">:</span><span class="token function">connect</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span>
<span class="token keyword">if</span> not ok then
<span class="token operator">-</span>  <span class="token operator">--</span> 省略异常处理
end
<span class="token operator">--</span> 发送请求
local bytes<span class="token punctuation">,</span> err <span class="token operator">=</span> sock<span class="token punctuation">:</span><span class="token function">send</span><span class="token punctuation">(</span>request_data<span class="token punctuation">)</span>
<span class="token keyword">if</span> not bytes then
  <span class="token operator">--</span> 省略异常处理
end
<span class="token operator">--</span> 读取响应
local line<span class="token punctuation">,</span> err <span class="token operator">=</span> sock<span class="token punctuation">:</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err then
  <span class="token operator">--</span> 省略异常处理
end
<span class="token operator">--</span> 关闭 socket
sock<span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   
<span class="token operator">--</span> 处理读取到的数据 line
<span class="token function">handle</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h5 id="结构化并发编程"><a href="#结构化并发编程" class="header-anchor">#</a> 结构化并发编程</h5> <p>Golang 中的 go 语句让协程用起来太简单了, 但是这种简单也蕴藏着风险. 要深入了解这个风险是什么, 就需要先了解一下 goto 语句的前世今生.</p> <p>一般来说, 各种各样的编程语言书籍中都会谈到不建议使用 goto 语句, 原因是 goto 语句会让程序变得混乱. 那为什么 goto 语句会让程序变得混乱呢? 混乱具体指的又是什么呢? 其实所谓的<strong>混乱指的是代码的书写顺序和执行顺序不一致</strong>. 代码的书写顺序, 代表的是我们的思维过程, 如果思维的过程与代码执行的顺序不一致, 那就会干扰我们对代码的理解. 我们的思维是线性的, 傻傻地一条道儿跑到黑, 而 goto 语句太灵活, 随时可以穿越时空, 实在是太&quot;混乱&quot;了.</p> <p>首先发现 goto 语句是 &quot;毒药&quot; 的人是著名的计算机科学家艾兹格·迪科斯彻(Edsger Dijkstra), 同时他还提出了结构化程序设计. 在结构化程序设计中, 可以使用三种基本控制结构来代替 goto, 这三种基本的控制结构就是今天我们广泛使用的<strong>顺序结构</strong>, <strong>选择结构</strong>和<strong>循环结构</strong>.</p> <p>这三种基本的控制结构奠定了今天高级语言的基础, 如果仔细观察这三种结构, 你会发现它们的<strong>入口和出口只有一个</strong>, 这意味它们是可组合的, 而且组合起来一定是线性的, 整体来看, 代码的书写顺序和执行顺序也是一致的.</p> <p>以前写的并发程序, 是否违背了结构化程序设计呢? 这个问题以前并没有被关注, 但是最近两年, 随着并发编程的快速发展, 已经开始有人关注了, 而且剑指 Golang 中的 go 语句, 指其为 &quot;毒药&quot;, 类比的是 goto 语句. 详情可以参考<a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/" target="_blank" rel="noopener noreferrer">相关的文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. Golang 中的 go 语句不过是快速创建协程的方法而已, 这篇文章本质上并不仅仅在批判 Golang 中的 go 语句, 而是在批判开启新的线程(或者协程)异步执行这种粗糙的做法, 违背了结构化程序设计, Java 语言其实也在其列.</p> <p>当开启一个新的线程时, 程序会并行地出现两个分支, 主线程一个分支, 子线程一个分支, 这两个分支很多情况下都是天各一方, 永不相见. 而结构化的程序, 可以有分支, 但是最终一定要汇聚, 不能有多个出口, 因为只有这样它们组合起来才是线性的.</p> <h5 id="总结-35"><a href="#总结-35" class="header-anchor">#</a> 总结</h5> <p>最近几年支持协程的开发语言越来越多了, Java OpenSDK 中 Loom 项目的目标就是支持协程, 相信不久的将来, Java 程序员也可以使用协程来解决并发问题了.</p> <p>计算机里很多面向开发人员的技术, 大多数都是在解决一个问题: <strong>易用性</strong>. 协程作为一项并发编程技术, 本质上也不过是解决并发工具的易用性问题而已. 对于易用性, 我觉得最重要的就是<strong>要适应我们的思维模式</strong>, 在工作的前几年, 我并没有怎么关注它, 但是最近几年思维模式已成为我重点关注的对象. 因为思维模式对工作的很多方面都会产生影响, 例如质量.</p> <h3 id="结束语"><a href="#结束语" class="header-anchor">#</a> 结束语</h3> <h4 id="结束语-十年之后-初心依旧"><a href="#结束语-十年之后-初心依旧" class="header-anchor">#</a> 结束语-十年之后,初心依旧</h4> <p>我曾经搞过 5 年的 ERP, 其间我是很想在这条路上一直走下去, 但在这个行业摸爬滚打了几年之后, 我发现这个行业里懂业务比懂技术更重要. 于是为了提高业务水平, 我就去搞注册会计师了; 但在我还没有搞定它的时候, 我突然发现自己竟然失业了. 这个时候我才意识到, 选择拼搏于细分行业里的夕阳产业, 是多么愚蠢. **选择, 永远比努力更重要. **</p> <p>可笑的是我们选择的, 往往不是期望的那样. 后来我阴错阳差去了一家央企, 传统观点认为这里和养老院是对门儿, 可实际上, 在 &quot;养老院对门儿&quot; 的这三年多, 是我成长最快的三年, 包括技术. 这三年属于被&quot;骂&quot;的最多的三年, 做的东西被同行&quot;骂&quot;, 汇报被领导&quot;骂&quot;, 被&quot;骂&quot;的多了, 渐渐就意识到自己的问题了. <mark><strong>找到自己的问题, 才是最重要的</strong></mark>​ <strong>.</strong></p> <p>一哥们儿曾有过一段经典的总结: 所有的失败都可以归结为 &quot;<mark><strong>错估了形势, 低估了敌人, 高估了自己</strong></mark>&quot;. 人, 总是高估了自己, 显然, 我也是. 很多时候, 我也会一不小心就高估了自己, 而且还一点都意识不到. 感谢佛家经典《金刚经》, 虽说到现在我也没有把它抄完, 但是抄到不到一半的时候, 我已经深深认识到自己是多么的浅薄与狂妄了. <strong>驱除虚妄, 才能进步.</strong></p> <p>搞技术的瓶颈在哪里呢? 每个人资质, 机遇不同, 其实没有必要强求. 我也曾经兴趣广泛, 大学时还买过全英文的《Intel 微处理器》, 搬了几次家, 都没舍得扔, 前两年终于扔掉了, 纯粹是浪费时间和空间. 有时我们得承认, 不是随便一个领域我们都能干得很深入的, 实际场景和资质都很重要. <mark><strong>拿不动的东西越早放弃越好, 做了减法, 才能做加法, 生也有涯, 该放就放</strong></mark>​ <strong>.</strong></p> <p>工作十年, 很多人已经在不同的轨道上了, 有些人选择了做管理, 有些人选择了创业, 只有很少的人在搞技术. 十年, 很多面具下的脸都已千疮百孔, 有些人摘下面具很丑, 有些人摘下面具很怪, 只有很少的人摘下面具你还认得. 事实证明, 你不认得的, 基本都已落马; 你还认得的, 基本都混得不错. 正所谓, 路遥知马力, 日久见人心. **简单做人, 挺好. **</p> <p>‍</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/20.开发/2000.Java/300.并发/400.Java并发编程实战(极客时间)🌸.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/5b787a/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">ThreadLocal</div></a> <a href="/pages/b4d461/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">文件操作</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/5b787a/" class="prev">ThreadLocal</a></span> <span class="next"><a href="/pages/b4d461/">文件操作</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/67.690dd59b.js" defer></script>
  </body>
</html>
