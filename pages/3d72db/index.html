<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java内存模型与线程实现🌼 | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/88.12d88449.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/4f30b9/" class="sidebar-link">Java基础</a></li><li><a href="/pages/795eca/" class="sidebar-link">类与继承</a></li><li><a href="/pages/c69152/" class="sidebar-link">抽象类与接口</a></li><li><a href="/pages/d71abb/" class="sidebar-link">内部类</a></li><li><a href="/pages/f06dca/" class="sidebar-link">枚举类</a></li><li><a href="/pages/259f57/" class="sidebar-link">常用类</a></li><li><a href="/pages/84b03b/" class="sidebar-link">关键字</a></li><li><a href="/pages/31b87b/" class="sidebar-link">注解</a></li><li><a href="/pages/f81c0d/" class="sidebar-link">异常</a></li><li><a href="/pages/ae7746/" class="sidebar-link">泛型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>容器类</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/0c88ac/" class="sidebar-link">集合容器类基础</a></li><li><a href="/pages/f805ed/" class="sidebar-link">List与Queue类</a></li><li><a href="/pages/d24b60/" class="sidebar-link">Map与Set类</a></li><li><a href="/pages/54e5d3/" class="sidebar-link">并发容器类</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/67d70f/" class="sidebar-link">多线程基础</a></li><li><a href="/pages/ffc8f7/" class="sidebar-link">Java内置锁</a></li><li><a href="/pages/c43494/" class="sidebar-link">AQS</a></li><li><a href="/pages/eb5b61/" class="sidebar-link">显式锁ReentrantLock</a></li><li><a href="/pages/eb8cbc/" class="sidebar-link">线程协作与JUC组件</a></li><li><a href="/pages/23c79a/" class="sidebar-link">Atomic原子变量与Unsafe类与CAS</a></li><li><a href="/pages/9d6ed4/" class="sidebar-link">线程池与定时任务</a></li><li><a href="/pages/5b787a/" class="sidebar-link">ThreadLocal</a></li><li><a href="/pages/db53d1/" class="sidebar-link">Java并发编程实战(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>IO</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b4d461/" class="sidebar-link">文件操作</a></li><li><a href="/pages/1b9d6c/" class="sidebar-link">IO流操作</a></li><li><a href="/pages/076a47/" class="sidebar-link">Java网络IO模型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>高级特性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d76905/" class="sidebar-link">Lambda表达式</a></li><li><a href="/pages/f7f0e6/" class="sidebar-link">流Stream</a></li><li><a href="/pages/7cc40a/" class="sidebar-link">反射</a></li><li><a href="/pages/945326/" class="sidebar-link">代理</a></li><li><a href="/pages/7fd9b4/" class="sidebar-link">Javaagent</a></li><li><a href="/pages/a3cee0/" class="sidebar-link">Guava</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>JVM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d308f6/" class="sidebar-link">走进JVM🌼</a></li><li><a href="/pages/be0269/" class="sidebar-link">JVM内存区域与对象解析🌼</a></li><li><a href="/pages/48d1be/" class="sidebar-link">垃圾收集器与内存分配策略🌼</a></li><li><a href="/pages/3a4c8a/" class="sidebar-link">JVM性能监控与故障处理工具🌼</a></li><li><a href="/pages/106680/" class="sidebar-link">调优案例分析与实战🌼</a></li><li><a href="/pages/16a914/" class="sidebar-link">类文件结构🌼</a></li><li><a href="/pages/ea287c/" class="sidebar-link">虚拟机类加载机制🌼</a></li><li><a href="/pages/6367b0/" class="sidebar-link">虚拟机字节码执行引擎🌼</a></li><li><a href="/pages/c6c210/" class="sidebar-link">类加载及执行子系统的案例与实战🌼</a></li><li><a href="/pages/deb8b7/" class="sidebar-link">前端编译与优化🌼</a></li><li><a href="/pages/1f8f72/" class="sidebar-link">后端编译与优化🌼</a></li><li><a href="/pages/3d72db/" aria-current="page" class="active sidebar-link">Java内存模型与线程实现🌼</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/ed086e/" class="sidebar-link">线程安全与内置锁优化🌼</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/56b9dd/" class="sidebar-link">Java性能问题定位分析</a></li><li><a href="/pages/939bf8/" class="sidebar-link">杂记</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>开发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>软件设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/a5f6fe/" class="sidebar-link">设计基础理论</a></li><li><a href="/pages/3b245c/" class="sidebar-link">设计模式之美(极客时间)🌟</a></li><li><a href="/pages/661fa4/" class="sidebar-link">领域驱动设计(DDD)</a></li><li><a href="/pages/856368/" class="sidebar-link">DDD实战课(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d3fbd2/" class="sidebar-link">数据库基础</a></li><li><a href="/pages/691fc3/" class="sidebar-link">数据库系统原理</a></li><li><a href="/pages/50f6b7/" class="sidebar-link">MySQL基础必知必会</a></li><li><a href="/pages/fe297e/" class="sidebar-link">MySQL特性</a></li><li><a href="/pages/07bdb6/" class="sidebar-link">MySQL索引🌟</a></li><li><a href="/pages/984715/" class="sidebar-link">MySQL锁🌟</a></li><li><a href="/pages/53b588/" class="sidebar-link">MySQL事务🌟</a></li><li><a href="/pages/becc59/" class="sidebar-link">MySQL高级特性</a></li><li><a href="/pages/056463/" class="sidebar-link">MySQL基础架构与存储引擎🌟</a></li><li><a href="/pages/63b46e/" class="sidebar-link">MySQL架构优化与运维</a></li><li><a href="/pages/9995e5/" class="sidebar-link">MySQL优化</a></li><li><a href="/pages/c1c2f6/" class="sidebar-link">MySQL架构</a></li><li><a href="/pages/8e8e0a/" class="sidebar-link">MySQL设计规范</a></li><li><a href="/pages/0219aa/" class="sidebar-link">MySQL运维</a></li><li><a href="/pages/e288c0/" class="sidebar-link">MySQL中间件</a></li><li><a href="/pages/c6cafa/" class="sidebar-link">MySQL实战45讲(极客时间)🌟</a></li><li><a href="/pages/4a6106/" class="sidebar-link">数据库LeetCode题目</a></li><li><a href="/pages/2827f1/" class="sidebar-link">数据库综合问题</a></li><li><a href="/pages/c616d5/" class="sidebar-link">MongoDB</a></li><li><a href="/pages/075e71/" class="sidebar-link">ClickHouse</a></li><li><a href="/pages/d74f6d/" class="sidebar-link">Doris</a></li><li><a href="/pages/b6bad9/" class="sidebar-link">HBase</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Spring</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bd8eb8/" class="sidebar-link">Spring Boot基础</a></li><li><a href="/pages/d0d797/" class="sidebar-link">Spring Boot应用整合</a></li><li><a href="/pages/314cdc/" class="sidebar-link">Spring MVC基础</a></li><li><a href="/pages/80de47/" class="sidebar-link">Spring AOP基础</a></li><li><a href="/pages/f0d4d6/" class="sidebar-link">Spring事务基础</a></li><li><a href="/pages/db6afe/" class="sidebar-link">Spring IOC源码分析-概览</a></li><li><a href="/pages/672e98/" class="sidebar-link">Spring IOC源码分析-getBean()</a></li><li><a href="/pages/695b90/" class="sidebar-link">Spring IOC源码分析-createBean()</a></li><li><a href="/pages/f89bcf/" class="sidebar-link">Spring AOP源码分析</a></li><li><a href="/pages/3b52f4/" class="sidebar-link">Spring事务源码分析</a></li><li><a href="/pages/186902/" class="sidebar-link">Spring Boot源码分析</a></li><li><a href="/pages/16bd1c/" class="sidebar-link">Spring MVC源码分析</a></li><li><a href="/pages/3d0c1f/" class="sidebar-link">Spring Cloud</a></li><li><a href="/pages/d56156/" class="sidebar-link">Spring编程常见错误50例(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>MyBatis</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bb032d/" class="sidebar-link">基础</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>工具与环境</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c9cb6e/" class="sidebar-link">Arthas</a></li><li><a href="/pages/3172bb/" class="sidebar-link">Maven</a></li><li><a href="/pages/37f79a/" class="sidebar-link">Git</a></li><li><a href="/pages/db9f99/" class="sidebar-link">环境搭建与部署</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c725f5/" class="sidebar-link">测试基础</a></li><li><a href="/pages/7893a4/" class="sidebar-link">单元测试</a></li><li><a href="/pages/af9f25/" class="sidebar-link">压力测试</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>代码质量</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ec2b81/" class="sidebar-link">代码整洁之道</a></li><li><a href="/pages/474cdf/" class="sidebar-link">阿里巴巴编程规范</a></li><li><a href="/pages/c47e15/" class="sidebar-link">代码之丑(极客时间)🌸</a></li><li><a href="/pages/4d4606/" class="sidebar-link">Java业务开发常见错误100例(极客时间)🌸</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/develop/#开发" data-v-06970110>开发</a></li><li data-v-06970110><a href="/develop/#Java" data-v-06970110>Java</a></li><li data-v-06970110><a href="/develop/#JVM" data-v-06970110>JVM</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">Java内存模型与线程实现🌼<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_50-java内存模型与线程实现🌼"><a href="#_50-java内存模型与线程实现🌼" class="header-anchor">#</a> 50.Java内存模型与线程实现🌼</h1> <p>本节对应《深入理解 Java 虚拟机》的第十二章</p> <p>并发处理的广泛应用是 Amdahl 定律代替摩尔定律成为计算机性能发展源动力的根本原因, 也是人类压榨计算机运算能力的最有力武器.</p> <h4 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h4> <p>多任务处理在现代计算机操作系统中几乎已是一项必备的功能了. 在许多场景下, 让计算机同时去做几件事情, 不仅是因为计算机的运算能力强大了, 还有一个很重要的原因是计算机的运算速度与它的存储和通信子系统的速度差距太大, 大量的时间都花费在磁盘 I/O, 网络通信或者数据库访问上. 如果不希望处理器在大部分时间里都处于等待其他资源的空闲状态, 就必须使用一些手段去把处理器的运算能力 &quot;压榨&quot; 出来, 否则就会造成很大的性能浪费, 而让计算机同时处理几项任务则是最容易想到, 也被证明是非常有效的 &quot;压榨&quot; 手段.</p> <p>除了充分利用计算机处理器的能力外, 一个服务端要同时对多个客户端提供服务, 则是另一个更具体的并发应用场景. 衡量一个服务性能的高低好坏, <strong>每秒事务处理数</strong>(Transactions Per Second, TPS)是重要的指标之一, 它代表着一秒内服务端平均能响应的请求总数, 而 TPS 值与程序的并发能力又有非常密切的关系. 对于计算量相同的任务, 程序线程并发协调得越有条不紊, 效率自然就会越高; 反之, 线程之间频繁争用数据, 互相阻塞甚至死锁, 将会大大降低程序的并发能力.</p> <p>服务端的应用是 Java 最擅长的领域之一, 这个领域的应用占了 Java 应用中最大的一块份额, 不过如何写好并发应用程序却又是服务端程序开发的难点之一, 处理好并发方面的问题通常需要更多的编码经验来支持. 幸好 Java 语言和虚拟机提供了许多工具, 把并发编程的门槛降低了不少. 各种中间件服务器, 各类框架也都努力地替程序员隐藏尽可能多的线程并发细节, 使得程序员在编码时能更关注业务逻辑, 而不是花费大部分时间去关注此服务会同时被多少人调用, 如何处理数据争用, 协调硬件资源. 但是无论语言, 中间件和框架再如何先进, 开发人员都不应期望它们能独立完成所有并发处理的事情, 了解并发的内幕仍然是成为一个高级程序员不可缺少的课程.</p> <p>&quot;高效并发&quot; 是本书讲解 Java 虚拟机的最后一个部分, 将会向读者<strong>介绍虚拟机如何实现多线程, 多线程之间由于共享和竞争数据而导致的一系列问题及解决方案</strong>.</p> <h4 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="header-anchor">#</a> 硬件的效率与一致性</h4> <h5 id="_1-基础"><a href="#_1-基础" class="header-anchor">#</a> 1.基础</h5> <p>在正式讲解 Java 虚拟机并发相关的知识之前, 先花费一点时间去<strong>了解一下物理计算机中的并发问题</strong>. 物理机遇到的并发问题与虚拟机中的情况有很多相似之处, 物理机对并发的处理方案对虚拟机的实现也有相当大的参考意义.</p> <p>现代计算机基于<strong>冯诺依曼</strong>模型, 计算机在运行时, 先从<strong>内存</strong>中取出<strong>第一条指令</strong>, 通过控制器的译码, 按指令的要求, 从<strong>存储器</strong>中取出数据进行指定的运算和逻辑操作, 然后再按地址把结果送到<strong>内存</strong>中去. 接下来再取出第二条指令, 在控制器的指挥下完成规定操作. 依此进行下去直至遇到停止指令.</p> <h5 id="_2-多cpu架构"><a href="#_2-多cpu架构" class="header-anchor">#</a> 2.多CPU架构</h5> <h6 id="_1-架构组成"><a href="#_1-架构组成" class="header-anchor">#</a> (1)架构组成</h6> <p>计算机通常有多个 CPU.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220601222903643.png" alt=""></p> <p>这个架构组成大致如下:</p> <ul><li><strong>多核 CPU</strong>: 一个 CPU 除了处理器之外还包括寄存器, L1 L2 L3 缓存这些存储设备, 浮点运算单元, 整数运算单元等一些辅助运算设备以及内部总线等. <strong>一个多核 CPU 也就是一个 CPU 上有多个处理器核心</strong>, 这样有什么好处呢? 比如在一台计算机上运行一个<strong>多线程</strong>的程序, 因为<strong>是一个进程里的线程</strong>, 所以需要一些<strong>共享一些存储变量</strong>, 如果这台计算机都是单核单线程 CPU 的话, 那这个程序的不同线程需要经常在 CPU 之间的<strong>外部总线</strong>上通信, 同时还要处理<strong>不同 CPU 之间</strong>不同缓存导致数据不一致的问题. 在这种场景下<strong>单 CPU 多核的架构</strong>就能发挥很大的优势, 通信都在<strong>内部总线</strong>, <strong>共用同一个缓存</strong>.</li> <li><strong>CPU 寄存器</strong>: 每个 CPU 都包含<strong>一系列的寄存器</strong>, 它们是 CPU 内内存的基础. CPU <strong>在寄存器上执行操作的速度远大于在主存上执行的速度</strong>. 这是因为 <strong>CPU 访问寄存器的速度远大于主内存</strong>.</li> <li><strong>CPU 缓存</strong>: 即<strong>高速缓冲存储器</strong>, 是位于 CPU 与<strong>主内存</strong>间的一种容量较小但<strong>速度很高的存储器</strong>. 由于 CPU 的速度远<strong>高于</strong>主内存, CPU 直接从内存中存取数据要<strong>等待一定时间周期</strong>, Cache 中保存着 CPU 刚用过或循环使用的<strong>一部分数据</strong>, 当 CPU 再次使用该部分数据时可从 <strong>Cache</strong> 中<strong>直接调用</strong>, 减少 CPU 的等待时间, 提高了系统的效率. 一般有<strong>一级</strong> Cache(L1 Cache), <strong>二级</strong> Cache(L2 Cache), <strong>三级</strong> Cache(L3 Cache) 缓存.</li> <li><strong>内存</strong>: 所有 CPU 都能访问主存. 主存通常比 CPU 中的缓存大得多. 内存需要通过<strong>总线</strong>与 CPU 进行通信, 速度是比较慢的.</li></ul> <p>假如只有一个 CPU 而需要运行多个进程, 就意味着要经常进行进程<strong>上下文切换</strong>. 单 CPU 即便是<strong>多核</strong>的, 也只是多个<strong>处理器核心</strong>, 其他设备都是<strong>共用</strong>的, 所以多个<strong>进程</strong>就必然要经常进行进程上下文切换, 代价很高.</p> <h6 id="_2-cpu读取存储器数据过程"><a href="#_2-cpu读取存储器数据过程" class="header-anchor">#</a> (2)CPU读取存储器数据过程</h6> <p>CPU 从不同地方读数据过程与复杂度是不同的.</p> <ul><li>CPU 要取<strong>寄存器 XX</strong> 的值, 只需要一步: <strong>直接读取</strong>.</li> <li>CPU 要<strong>取 L1 cache</strong> 的某个值, 需要 1-3 步(或者更多): 把 cache 行<strong>锁住</strong>, 把某个数据拿来, 解锁, 如果没锁住就慢了.</li> <li>CPU 要<strong>取 L2 cache</strong> 的某个值, 先要到 L1 cache 里取, L1 当中不存在, 在 L2 里, L2 开始加锁, 加锁以后, 把 L2 里的数据复制到 L1, 再执行读 L1 的过程, 上面的 3 步, 再解锁.</li> <li>CPU <strong>取 L3 cache</strong> 的也是一样, 只不过先由 L3 复制到 L2, 从 L2 复制到 L1, 从 L1 到 CPU.</li> <li>CPU <strong>取内存</strong>中的值则最复杂: 通知内存控制器<strong>占用总线带宽</strong>, 通知内存加锁, 发起内存读请求, 等待回应, 回应数据保存到 L3(如果没有就到 L2), 再从 L3/L2 到 L1, 再从 L1 到 CPU, 之后解除总线锁定. 比如需要<strong>读取变量</strong> age 的值, 也就是从内存复制到 L3 再到 L2 再到 L1 最后到寄存器. 从 CPU 同步数据到内存则是相反的流程.</li></ul> <p>CPU 读写速度: <mark><strong>寄存器 &gt; L1 &gt; L2 &gt; L3 &gt; 内存条</strong></mark>.</p> <h5 id="_3-多线程存在的问题"><a href="#_3-多线程存在的问题" class="header-anchor">#</a> 3.多线程存在的问题</h5> <h6 id="_1-缓存一致性问题"><a href="#_1-缓存一致性问题" class="header-anchor">#</a> (1)缓存一致性问题</h6> <p>&quot;让计算机并发执行若干个运算任务&quot; 与 &quot;更充分地利用计算机处理器的效能&quot; 之间的因果关系, 看起来理所当然, 实际上它们之间的关系并没有想象中那么简单, 其中一个重要的复杂性的来源是绝大多数的运算任务都不可能只靠处理器 &quot;计算&quot; 就能完成. <strong>处理器至少要与内存交互</strong>, 如读取运算数据, 存储运算结果等, 这个 I/O 操作就是很难消除的(无法仅靠寄存器来完成所有运算任务). <strong>由于计算机的存储设备与处理器的运算速度有着几个数量级的差距, 所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存(Cache)来作为内存与处理器之间的缓冲: 将运算需要使用的数据复制到缓存中, 让运算能快速进行, 当运算结束后再从缓存同步回内存之中, 这样处理器就无须等待缓慢的内存读写了</strong>.</p> <p><mark><strong>基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾, 但是也为计算机系统带来更高的复杂度, 它引入了一个新的问题: 缓存一致性(Cache Coherence). 在多路处理器系统中, 每个处理器都有自己的高速缓存, 而它们又共享同一主内存(Main Memory), 这种系统称为共享内存多核系统</strong></mark>), 如图 12-1 所示.</p> <p><img src="/img/image-20240720132026-d1xpkje.png" alt="image" title="图12-1 处理器, 高速缓存, 主内存间的交互关系"></p> <p>当多个处理器的运算任务都涉及<strong>同一块主内存</strong>区域时, 将可能导致<strong>各自的缓存数据不一致</strong>的情况, 比如两个 CPU 都需要对主内存中的变量 <code>age = 1</code>​ 值进行 +1 操作, 此时两个 CPU 都会从主内存中复制一份 age 值到 L3, 再到 L2, 再到 L1 最后到寄存器进行 +1 操作. 也就是两个 CPU 中都有 age 变量的副本, 当 CPU1 执行 +1 之后, 同步回主内存, 此时 <code>age = 2</code>​; 由于 CPU2 里面的缓存的 age 值也是 1, 因此 CPU2 处理完后 age 也等于 2, 此时再同步到主内存中, 最后 <code>age = 2</code>​, 这就与 age 加两次等于 3 的结果不一致.</p> <p><mark><strong>当多个处理器的运算任务都涉及同一块主内存区域时, 将可能导致各自的缓存数据不一致</strong></mark>. 如果真的发生这种情况, 那同步回到主内存时该<strong>以谁的缓存数据为准呢</strong>? 为了解决一致性的问题, <strong>需要各个处理器访问缓存时都遵循一些协议, 在读写时要根据协议来进行操作, 这类协议有 MSI, MESI</strong>(Illinois Protocol), MOSI, Synapse, Firefly 及 Dragon Protocol 等. 从本章开始, 将会频繁见到 &quot;<mark><strong>内存模型</strong></mark>&quot; 一词, 它可以理解为<mark><strong>在特定的操作协议下, 对特定的内存或高速缓存进行读写访问的过程抽象</strong></mark>. 不同架构的物理机器可以拥有不一样的内存模型, 而 Java 虚拟机也有自己的内存模型, 并且与这里介绍的内存访问操作及硬件的缓存访问操作具有高度的可类比性.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220601222957802.png" alt=""></p> <h6 id="_2-指令重排序问题"><a href="#_2-指令重排序问题" class="header-anchor">#</a> (2)指令重排序问题</h6> <p>除了增加高速缓存之外, 为了使处理器内部的运算单元能尽量被充分利用, 处理器可能会<strong>对输入代码进行乱序执行(Out-Of-Order Execution)优化</strong>, 处理器会在计算之后将乱序执行的结果重组, 保证该结果与顺序执行的结果是一致的, 但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致, 因此如果存在一个计算任务依赖另外一个计算任务的中间结果, 那么其顺序性并不能靠代码的先后顺序来保证.</p> <p>因此, 如果存在一个计算任务<strong>依赖</strong>另一个计算任务的<strong>中间结果</strong>, 那么其顺序性并不能靠代码的先后顺序来保证. 与处理器的乱序执行优化类似, Java 虚拟机的<strong>即时编译器</strong>中也有类似的<strong>指令重排序(Instruction Reorder)优化</strong>.</p> <h4 id="java内存模型-jmm"><a href="#java内存模型-jmm" class="header-anchor">#</a> Java内存模型(JMM)</h4> <p>《Java 虚拟机规范》 中层试图定义一种 &quot;<strong>Java 内存模型</strong>&quot;(Java Memory Model, JMM)来<strong>屏蔽各种硬件和操作系统的内存访问差异, 以实现让 Java 程序在各种平台下都能达到一致的内存访问效果</strong>. 在此之前, 主流程序语言(如 C 和 C++ 等)直接使用物理硬件和操作系统的内存模型. 因此, 由于不同平台上内存模型的差异, 有可能导致程序在一套平台上并发完全正常, 而在另外一套平台上并发访问却经常出错, 所以在某些场景下必须针对不同的平台来编写程序.</p> <p>定义 Java 内存模型并非一件容易的事情, 这个模型必须定义得足够严谨, 才能让 Java 的并发内存访问操作不会产生歧义; 但是也必须定义得足够宽松, 使得虚拟机的实现能有足够的自由空间去利用硬件的各种特性(寄存器, 高速缓存和指令集中某些特有的指令)来获取更好的执行速度. 经过长时间的验证和修补, 直至 JDK 5(实现了 JSR-133)发布后, Java 内存模型才终于成熟, 完善起来了.</p> <h5 id="_1-主内存与工作内存"><a href="#_1-主内存与工作内存" class="header-anchor">#</a> 1.主内存与工作内存</h5> <p>CPU 中<strong>寄存器</strong>的读写速度比<strong>内存</strong>快几个数量级, 为解决这种<strong>速度矛盾</strong>, 在它们之间加入了<strong>高速缓存</strong>(一般有多级), 因此很多时候寄存器是直接从<strong>缓存</strong>中读取缓存数据的. 但是<strong>主内存</strong>中才是存放各种数据的主要位置, 因此加入<strong>高速缓存</strong>带来了一个新问题: <strong>缓存一致性问题</strong>. 如果多个缓存<strong>共享同一块主内存</strong>区域, 那么多个缓存的数据可能会不一致.</p> <p><mark><strong>Java 内存模型(Java Memory Model 简称 JMM)的主要目的是定义程序中各种变量的访问规则, 即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节</strong></mark>. 此处的变量(Variables)与 Java 编程中所说的变量有所区别, 它包括了实例字段, 静态字段和构成数组对象的元素, 但是不包括局部变量与方法参数, 因为后者是线程私有的, 不会被共享, 自然就不会存在竞争问题. 为了获得更好的执行效能, Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互, 也没有限制即时编译器是否要进行调整代码执行顺序这类优化措施.</p> <p><mark><strong>Java 内存模型</strong></mark>是一种<strong>抽象</strong>的概念, <strong>并不真实存在</strong>, 它描述了<strong>一组规则或规范</strong>, 它定义了程序中各个变量(包括实例字段, 静态字段和构成数组对象的元素)的<strong>访问方式</strong>.</p> <p><mark><strong>主内存</strong></mark>主要存储的是 Java <strong>实例对象</strong>, 所有<strong>线程创建的实例对象都存放在主内存中</strong>, 不管该实例对象是成员变量还是方法中的本地变量(也称局部变量), 当然也包括了共享的类信息, 常量, 静态变量.</p> <p><mark><strong>工作内存</strong></mark>主要存储<strong>当前方法</strong>的所有<strong>本地变量信息</strong>(工作内存中<strong>存储着主内存中的变量</strong>​<mark><strong>副本拷贝</strong></mark>), 每个线程只能访问自己的<strong>工作内存</strong>, 即线程中的本地变量对其它线程是<strong>不可见</strong>的, 就算是两个线程执行的是同一段代码, 它们也会各自在自己的工作内存中创建属于<strong>当前线程的本地变量</strong>, 当然也包括了字节码行号指示器, 相关 Native 方法的信息. 注意由于工作内存是每个线程的私有数据, 线程间<strong>无法相互访问</strong>工作内存, 因此<strong>存储在工作内存的数据不存在线程安全问题</strong>. 根据 JVM 虚拟机规范主内存与工作内存的数据存储类型以及操作方式, 对于一个实例对象中的成员方法而言, 如果方法中包含<strong>本地变量</strong>是<strong>基本数据类型</strong>(boolean, byte, short, char, int, long, float, double), 将<strong>直接存储在工作内存的</strong>​<mark><strong>帧栈</strong></mark>​<strong>结构</strong>中, 但倘若<strong>本地变量</strong>是<strong>引用类型</strong>, 那么该<strong>变量的引用会存储在工作内存的</strong>​<mark><strong>帧栈</strong></mark>中, 而<strong>对象实例将存储在主内存</strong>(共享数据区域, 堆)中.</p> <p><mark><strong>Java 内存模型规定了所有的变量都存储在主内存(Main Memory)中(此处的主内存与介绍物理硬件时提到的主内存名字一样, 两者也可以类比, 但物理上它仅是虚拟机内存的一部分). 每条线程还有自己的工作内存(Working Memory, 可与前面讲的处理器高速缓存类比), 线程的工作内存中保存了被该线程使用的变量的主内存副本, 线程对变量的所有操作(读取, 赋值等)都必须在工作内存中进行, 而不能直接读写主内存中的数据. 不同的线程之间也无法直接访问对方工作内存中的变量, 线程间变量值的传递均需要通过主内存来完成</strong></mark>. 线程, 主内存, 工作内存三者的交互关系如图 12-2 所示, 注意与图 12-1 进行对比.</p> <p><img src="/img/image-20240720152203-53jgc81.png" alt="image" title="图12-2 线程, 主内存, 工作内存三者的交互关系(请与图12-1对比)"></p> <p>基于 <strong>JMM 规范</strong>的线程的工作内存与主内存之间的交互过程如下:</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220601223205007.png" alt=""></p> <p>但对于<strong>实例对象</strong>的成员变量, 不管它是基本数据类型或者包装类型(Integer, Double等)还是引用类型, 都会被存储到<strong>堆区</strong>. 至于 <strong>static 变量</strong>以及类本身相关信息将会存储在<strong>主内存</strong>中. 需要注意的是, 在主内存中的<strong>实例对象</strong>可以被多线程共享, 倘若两个线程同时调用了同一个对象的同一个方法, 那么两条线程会将要操作的数据拷贝一份到自己的工作内存中, 执行完成操作后<strong>才刷新到主内存</strong>.</p> <blockquote><p>为什么存在线程安全问题?</p></blockquote> <p>由于是共享数据区域, <strong>多个线程对同一个变量进行访问可能会发生线程安全问题</strong>. 在当前的 Java 内存模型下, 线程可以把变量保存<strong>本地内存</strong>(比如机器的<strong>寄存器</strong>)中, <strong>而不是直接在主存</strong>中进行读写. 这就可能造成一个线程在主存中修改了一个变量的值, 而另外一个线程还继续使用它在寄存器中的变量值的拷贝, 造成<strong>数据的不一致</strong>.</p> <blockquote><p>为什么要有Java内存模型?</p></blockquote> <p>Java <strong>内存模型</strong>试图屏蔽各种<strong>硬件和操作系统的内存访问差异</strong>, 以实现让 Java 程序在各种平台下都能达到<strong>一致的内存访问效果</strong>.</p> <h5 id="_2-jmm与jvm模型的联系"><a href="#_2-jmm与jvm模型的联系" class="header-anchor">#</a> 2.JMM与JVM模型的联系</h5> <p>JMM 与 JVM 内存区域的<strong>划分是不同的概念层次</strong>. <strong>JMM 描述的是一组规则</strong>, 通过<strong>这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式</strong>, JMM 围绕<strong>原子性, 有序性, 可见性</strong>展开.</p> <p>这里所讲的主内存, 工作内存 Java 内存区域中的 Java 堆, 栈, 方法区等并不是同一个层次的对内存的划分, <strong>这两者基本上是没有任何关系的</strong>. 如果两者一定要勉强对应起来, 那么从变量, 主内存, 工作内存的定义来看, <strong>主内存主要对应于 Java 堆中的对象实例数据部分, 而工作内存则对应于虚拟机栈中的部分区域</strong>. 从更基础的层次上说, <strong>主内存直接对应于物理硬件的内存</strong>, 而为了获取更好的运行速度, 虚拟机(或者是硬件, 操作系统本身的优化措施)可能会让工作内存优先存储于寄存器和高速缓存中, 因为<strong>程序运行时主要访问的是工作内存</strong>.</p> <p>JMM 是为了屏蔽不同硬件平台的差异而做的一种规范化模型. JVM 内存模型则是为了便于更好的管理, 使用内存而设计的架构模型.</p> <h5 id="_3-jmm与硬件内存架构的关系"><a href="#_3-jmm与硬件内存架构的关系" class="header-anchor">#</a> 3.JMM与硬件内存架构的关系</h5> <p>JMM 模型跟 CPU 缓存模型结构类似, 是基于 CPU 缓存模型建立的, JMM 模型屏蔽了不同计算机底层架构的区别. 但 <strong>JMM 模型与硬件内存架构并不完全一致</strong>.</p> <p><strong>硬件内存</strong>有实际的寄存器, 缓存内存, 主内存概念, 并<strong>没有工作内存</strong>(线程私有数据区域)和主内存(堆内存)之分. 工作内存通常映射到<strong>高速缓存或者寄存器</strong>中.</p> <p>JMM 对内存的划分对硬件内存并没有任何影响, 因为 JMM 只是一种<strong>抽象的概念, 是一组规则</strong>, 并不实际存在, 不管是<strong>工作内存的数据还是主内存的数据</strong>, 对于计算机硬件来说都会存储在计算机<strong>主内存</strong>中, 当然也有可能存储到 <strong>CPU 缓存或者寄存器中</strong>, 因此 JMM 模型和计算机硬件内存架构是一个相互交叉的关系, 是一种<strong>抽象概念划分与真实物理硬件</strong>的交叉. (JVM 的内存区域划分也是同样的道理).</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220601223247394.png" alt="image-20220601223247394"></p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220601223336723.png" alt=""></p> <h5 id="_4-内存间交互操作"><a href="#_4-内存间交互操作" class="header-anchor">#</a> 4.内存间交互操作</h5> <h6 id="_1-内存间交互的8个操作"><a href="#_1-内存间交互的8个操作" class="header-anchor">#</a> (1)内存间交互的8个操作</h6> <p>由于 <strong>JVM</strong> 运行程序的实体是<strong>线程</strong>, 而每个线程创建时 JVM 都会为其创建一个<strong>工作内存</strong>用于存储<strong>线程私有</strong>的数据, 线程与主内存中的变量操作必须通过<strong>工作内存</strong>间接完成. 主要过程是将变量从主内存拷贝的每个线程各自的工作内存空间, 然后对变量进行操作, 操作完成后再将变量<strong>写回</strong>主内存.</p> <p><strong>关于主内存与工作内存之间具体的交互协议, 即一个变量如何从主内存拷贝到工作内存, 如何从工作内存同步回主内存这一类的实现细节</strong>, Java 内存模型中定义了以下 8 种操作来完成. 如下图所示, 箭头<strong>绕了一圈</strong>.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220601223409654.png" alt=""></p> <ul><li><strong>lock(锁定)</strong> : 作用于主内存的变量, 它<strong>把一个变量标识为一条线程独占的状态</strong>.</li> <li><strong>unlock(解锁)</strong> : 作用于主内存的变量, 它<strong>把一个处于锁定状态的变量释放出来</strong>, 释放后的变量才可以被其他线程锁定.</li> <li><strong>read(读取)</strong> : 作用于主内存的变量, 它<strong>把一个变量的值从主内存传输到线程的工作内存中</strong>, 以便随后的 load 动作使用.</li> <li><strong>load(载入)</strong> : 作用于工作内存的变量, 它<strong>把 read 操作从主内存中得到的变量值放入工作内存的变量副本中</strong>.</li> <li><strong>use(使用)</strong> : 作用于工作内存的变量, 它把工作内存中一个变量的值传递给执行引擎, 每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作.</li> <li><strong>assign(赋值)</strong> : 作用于工作内存的变量, 它把一个从执行引擎接收的值赋给工作内存的变量, 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作.</li> <li><strong>store(存储)</strong> : 作用于工作内存的变量, 它<strong>把工作内存中一个变量的值传送到主内存中</strong>, 以便随后的 write 操作使用.</li> <li><strong>write(写入)</strong> : 作用于主内存的变量, 它<strong>把 store 操作从工作内存中得到的变量的值放入主内存的变量中</strong>.</li></ul> <p><strong>如果要把一个变量从主内存拷贝到工作内存, 那就要按顺序执行 read 和 load 操作, 如果要把变量从工作内存同步回主内存, 就要按顺序执行 store 和 write 操作</strong>. 注意, <mark><strong>Java 内存模型只要求上述两个操作必须按顺序执行, 但不要求是连续执行</strong></mark>. 也就是<strong>说 read 与 load 之间, store 与 write 之间是可插入其他指令的, 如对主内存中的变量 a, b 进行访问时, 一种可能出现的顺序是 read a, read b, load b, load a</strong>.</p> <h6 id="_2-同步规则"><a href="#_2-同步规则" class="header-anchor">#</a> (2)同步规则</h6> <p>除此之外, Java 内存模型还规定了在执行上述 8 种基本操作时必须满足如下<strong>同步规则</strong>:</p> <ul><li>不允许 read 和 load, store 和 write 操作之一单独出现, 即<strong>不允许一个变量从主内存读取了但工作内存不接受, 或者工作内存发起回写了但主内存不接受的情况出现</strong>.</li> <li>不允许一个线程丢弃它最近的 assign 操作, 即<strong>变量在工作内存中改变了之后必须把该变化同步回主内存</strong>.</li> <li>不允许一个线程无原因地(没有发生过任何 assign 操作)把数据从线程的工作内存同步回主内存中.</li> <li>一个新的变量只能在主内存中 &quot;诞生&quot;, 不允许在工作内存中直接使用一个未被初始化(load 或 assign)的变量, 换句话说就是<strong>对一个变量实施 use, store 操作之前, 必须先执行 assign 和 load 操作</strong>.</li> <li>一个变量在同一个时刻只允许一条线程对其进行 lock 操作, 但 lock 操作可以被同一条线程重复执行多次, 多次执行 lock 后, 只有执行相同次数的 unlock 操作, 变量才会被解锁.</li> <li>如果对一个变量执行 lock 操作, 那将会清空工作内存中此变量的值, 在执行引擎使用这个变量前, 需要重新执行 load 或 assign 操作以初始化变量的值.</li> <li>如果一个变量事先没有被 lock 操作锁定, 那就不允许对它执行 unlock 操作, 也不允许去 unlock 一个被其他线程锁定的变量.</li> <li>对一个变量执行 unlock 操作之前, 必须先把此变量同步回主内存中(执行 store, write 操作).</li></ul> <p><strong>这 8 种内存访问操作以及上述规则限定</strong>, 再加上稍后会介绍的专门针对 volatile 的一些特殊规定, 就已经能准确地描述出 Java 程序中哪些内存访问操作在并发下才是安全的. 这种定义相当严谨, 但也是极为烦琐, 实践起来更是无比麻烦. 可能部分读者阅读到这里已经对多线程开发产生恐惧感了, 后来 Java 设计团队大概也意识到了这个问题, 将 Java 内存模型的操作简化为 read, write, lock 和 unlock 四种, 但这只是语言描述上的等价化简, Java 内存模型的基础设计并未改变, 即使是这四操作种, 对于普通用户来说阅读使用起来仍然并不方便. 不过读者对此无须过分担忧, 除了进行虚拟机开发的团队外, 大概没有其他开发人员会以这种方式来思考并发问题, 大家只需要理解 Java 内存模型的定义即可. 后面将介绍这种定义的一个等效判断原则--<mark><strong>先行发生原则, 用来确定一个操作在并发环境下是否安全的</strong></mark>.</p> <h5 id="_5-可见性-原子性与有序性问题"><a href="#_5-可见性-原子性与有序性问题" class="header-anchor">#</a> 5.可见性,原子性与有序性问题</h5> <p>介绍完 Java 内存模型的相关操作和规则后, 再整体回顾一下这个模型的特征. <mark><strong>Java 内存模型是围绕着在并发过程中如何处理原子性, 可见性和有序性这三个特征来建立的</strong></mark>. <strong>可见性, 原子性和有序性也是并发编程必须考虑的问题</strong>, 这里先描述这几个问题, 然后再讨论 JMM 模型是<strong>如何解决</strong>这些问题的.</p> <h6 id="_1-可见性"><a href="#_1-可见性" class="header-anchor">#</a> (1)可见性</h6> <p><mark><strong>可见性就是指当一个线程修改了共享变量的值时, 其他线程能够立即得知这个修改</strong></mark>.</p> <p>对于<strong>单线程环境</strong>, 可见性的概念是不存在的, 因为任何一个操作中修改了某个变量的值, 后续的操作中都能读取这个变量值, 并且是修改过的新值.</p> <p>在<strong>多线程环境</strong>中, 由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的, 这就可能存在一个线程 A 修改了共享变量 x 的值, 还<strong>未写回主内存</strong>时, 另外一个线程 B 又对主内存中同一个共享变量 x 进行操作, 但此时 A 线程工作内存中共享变量 x 对线程 B 来说<strong>并不可见</strong>, 这种<strong>工作内存与主内存同步延迟现象就造成了可见性问题</strong>, 另外指令重排以及编译器优化也可能导致可见性问题. 无论是编译器优化还是处理器优化的重排现象, 在多线程环境下, 确实会导致程序乱序执行的问题, 从而也就导致可见性问题.</p> <blockquote><p>可见性问题示例</p></blockquote> <p>看一段多线程的代码.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileVisibility</span> <span class="token punctuation">{</span>
    <span class="token comment">// 全局变量</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程 &quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; 修改 flag.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 死循环</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程: &quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;发现flag变化.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">VolatileVisibility</span> sample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VolatileVisibility</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> threadA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            sample<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;threadA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> threadB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// 刷新flag为true</span>
            sample<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;threadB&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 先开启B线程</span>
        threadA<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 再开启B线程</span>
        threadB<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;当前变量值: &quot;</span> <span class="token operator">+</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><p>这里定义了一个普通的全局变量 flag = false. 然后开启线程 A 首先进入死循环, 然后开启线程 B 对 flag 进行刷新. 执行结果如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>线程 threadB 修改flag<span class="token punctuation">.</span>
当前变量值<span class="token operator">:</span> <span class="token boolean">true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可以看到<strong>线程 B 成功修改了 flag 的值, 但是线程 A 依然在死循环中</strong>. 下面分析一下这个流程.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220601223644287.png" alt="image-20220601223644287"></p> <ol><li>主内存 flag = false. 线程 A 通过 read 与 load 操作将 flag 的值<strong>从主内存读出并复制到一个线程 A 的工作内存</strong>中. 此时线程 A 的工作内存有 flag 的<strong>副本为 false</strong>.</li> <li>然后线程 A 通过 while 循环持续监听 flag 的变化, 如果 flag 变为 true 则退出循环. 线程 A 的 CPU 使用其工作内存中的 flag 值用了 use 操作.</li> <li>之后线程 B 采用同样的方式<strong>将 flag 的副本复制到其工作内存中</strong>, 然后 CPU 对 flag 值进行<strong>修改</strong>.</li> <li>线程 B 修改完成后, 通过 assign 操作将 flag 的值<strong>写到其工作内存</strong>中, 此时 flag = true.</li> <li>等到合适的时机, flag 的值通过 store 与 write 操作同步回主内存. 此时主内存中 flag = true.</li> <li>由于线程 B 是通过<strong>普通写的方式将 flag 写回主内存</strong>, 所以线程 A 不会实时<strong>嗅探</strong> flag 的变化, 线程 A 一直使用的是其工作内存中的 flag 的<strong>副本</strong>, 也就是 false, 所以线程 A 会一直死循环.</li></ol> <blockquote><p>如何解决可见性问题?</p></blockquote> <p><strong>Java 内存模型是通过在变量修改后将新值同步回主内存, 在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的, 无论是普通变量还是 volatile 变量都是如此</strong>. 普通变量与 volatile 变量的区别是, <strong>volatile 的特殊规则保证了新值能立即同步到主内存, 以及每次使用前立即从主内存刷新</strong>. 因此可以说 volatile 保证了多线程操作时变量的可见性, 而普通变量则不能保证这一点.</p> <p>主要有三种解决可见性问题的方式:</p> <ul><li><mark><strong>volatile</strong></mark>​ <strong>: volatile 关键字可以保证可见性</strong>. 当一个共享变量被 volatile 修饰时, 它会保证<strong>修改的值立即被其他的线程看到</strong>, 即修改的值<strong>立即更新到主存</strong>中, 当其他线程需要读取时, 会<strong>去主内存中读取新的值</strong>并放入工作内存中. 这是轻量级的做法.</li> <li><mark><strong>synchronized 与显示锁</strong></mark>: 可以保证任一时刻只有一个线程能访问共享资源, 并保证在其<strong>释放锁之前</strong>将修改的变量<strong>刷新到内存</strong>中.</li> <li><mark><strong>final</strong></mark>: 即时编译器在 final 写操作后, 会插入<strong>内存屏障</strong>, 来禁止重排序, 保证可见性.</li></ul> <h6 id="_2-原子性"><a href="#_2-原子性" class="header-anchor">#</a> (2)原子性</h6> <p><strong>原子性指的是一个操作是不可中断</strong>的, 一个操作一旦开始就不会被其他线程影响.</p> <p><strong>由 Java 内存模型来直接保证的原子性变量操作包括 read, load, assign, use, store 和 write 这六个</strong>, 所以大致可以认为, <strong>基本数据类型的访问, 读写都是具备原子性的</strong>.</p> <blockquote><p>原子性问题示例</p></blockquote> <p>原子性问题实例: 有一个<strong>错误认识</strong>就是, <strong>int</strong> 等<strong>基本数据类型</strong>在多线程环境中<strong>不会</strong>出现线程安全问题. 下面的 cnt 属于 int 类型变量, 1000 个线程对它进行自增操作之后, 得到的值为 999997 而不是 1000000.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileAtomicExample</span> <span class="token punctuation">{</span>

    <span class="token comment">// 注意这里加了volatile保证可见性</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">VolatileAtomicExample</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VolatileAtomicExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 不是原子操作</span>
                    example<span class="token punctuation">.</span>cnt<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>这是因为 <strong>cnt++ 并不是原子操作</strong>. 在多线程环境下, 有可能线程 A 将 cnt 读取到工作内存中, 此时其他线程可能已经将 cnt 增大了很多, 而线程 A 依然对过期的 cnt 进行自加, 然后<strong>重新刷新到主存</strong>中, 最终导致了 cnt 的结果不合预期而小于 1000000.</p> <blockquote><p>原因解析</p></blockquote> <p>为啥? 这里将<strong>内存间的交互操作</strong>简化为 3 个: <strong>load, assign, store</strong>.</p> <p>load, assign, store 这<strong>一系列操作整体上来看不具备原子性</strong>, 那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存, T2 依然可以读入旧值. 可以看出, 这两个线程虽然执行了两次自增运算, 但是主内存中 cnt 的值最后为 1 而不是 2. 对 int 类型读写操作只是说明 load, assign, store 这些<mark><strong>单个操作具备原子性</strong></mark>​<mark>,</mark> <mark><strong>组合在一起不一定具有原子性</strong></mark>.</p> <p>上述的例子可以用下面的图来解释. 注意这里 cnt 变量加了 volatile <strong>保证可见性</strong>. 开始执行的时候, cnt = 0 被多个线程加载到其工作内存中(这里只画了 2 个线程). 然后线程内部各自对 cnt 进行<strong>自增操作</strong>, 其值变成 1. 但线程 1 首先完成自增后, 需要将其值写入到主内存中. 由于 cnt 加了 volatile 关键字, 所以这里遵循缓存一致性协议, 根据 MESI 协议, 这里需要锁定缓存行, 因此 cnt 的状态被置为 <strong>M(Modified)</strong> . 根据缓存一致性协议, 其他线程的工作内存中的 cnt 的值被置为 <strong>I(Invalid) 无效状态</strong>. 所以这里线程 1 中的 cnt 能被写入到主内存, 而线程 2(或者还有其他线程)对 cnt 值的修改就<strong>变成无效的而不会写到主内存中</strong>了, 所以线程 2 中自增的循环就<strong>白费</strong>了一次. 到最后就可能有很多这样的情况出现, 使得最后 cnt 的值并不是期望的 1000000. <strong>所以 volatile 关键字仅能保证可见性, 多线程下也不能保证原子性, 也就不能保证线程安全</strong>.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220601223705420.png" alt="image-20220601223705420"></p> <blockquote><p>如何解决原子性问题?</p></blockquote> <p>可以通过 <mark><strong>synchronized 和 Lock</strong></mark> 的加锁操作来实现<strong>原子性</strong>. 因为加锁能够保证任一时刻只有一个线程访问<strong>资源</strong>.</p> <p>还可以使用 <strong>AtomicInteger</strong> 等原子类型替换 int 来实现<strong>原子性</strong>, 也就是让几个内存间的交互执行完其他线程才能进行. 使用 <strong>AtomicInteger</strong> 重写之前线程不安全的代码之后得到以下线程安全实现:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">AtomicInteger</span> cnt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cnt<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> cnt<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h6 id="_3-有序性"><a href="#_3-有序性" class="header-anchor">#</a> (3)有序性</h6> <p>Java 内存模型的有序性在前面讲解 volatile 时也比较详细地讨论过了, Java 程序中天然的有序性可以总结为一句话: <mark><strong>如果在本线程内观察, 所有的操作都是有序的; 如果在一个线程中观察另一个线程, 所有的操作都是无序的</strong></mark>. <strong>前半句是指 &quot;线程内似表现为串行的语义&quot;(Within-Thread As-If-Serial Semantics), 后半句是指 &quot;指令重排序&quot; 现象和 &quot;工作内存与主内存同步延迟&quot; 现象</strong>.</p> <p>在 Java 内存模型中, <strong>允许</strong>编译器和处理器对指令进行<strong>重排序</strong>, 重排序过程不会影响到单线程程序的执行, 却会影响到<strong>多线程并发执行的正确性</strong>.</p> <blockquote><p>如何解决有序性问题?</p></blockquote> <p><mark><strong>Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性</strong></mark>.</p> <ul><li><mark><strong>volatile</strong></mark>: 通过添加<strong>内存屏障</strong>的方式来<strong>禁止指令重排</strong>, 即重排序时不能把后面的指令放到内存屏障之前.</li> <li><mark><strong>synchronized 与显示锁</strong></mark>: 保证每个时刻<strong>只有一个线程</strong>执行同步代码, 相当于是让<strong>线程顺序执行</strong>同步代码, 自然就保证了有序性.</li></ul> <p>介绍完并发中三种重要的特性, 读者是否发现 synchronized 关键字在需要这三种特性的时候都可以作为其中一种的解决方案? 看起来很 &quot;万能&quot; 吧? 的确, 绝大部分并发控制操作都能使用 synchronized 来完成. synchronized 的 &quot;万能&quot; 也间接造就了它被程序员滥用的局面, 越 &quot;万能&quot; 的并发控制, 通常会伴随着越大的性能影响, 关于这一点将在下一章讲解虚拟机锁优化时再细谈.</p> <h5 id="_6-先行发生原则"><a href="#_6-先行发生原则" class="header-anchor">#</a> 6.先行发生原则</h5> <p>如果 Java 内存模型中所有的有序性都仅靠 volatile 和 synchronized 来完成, 那么有很多操作都将会变得非常啰嗦, 但是在编写 Java 并发代码的时候并没有察觉到这一点, 这是因为 Java 语言中有一个 &quot;<mark><strong>先行发生</strong></mark>&quot;(Happens-Before)的原则. 这个原则非常重要, <strong>它是判断数据是否存在竞争, 线程是否安全的非常有用的手段</strong>. 依赖这个原则, 可以通过几条简单规则一揽子解决<strong>并发环境下两个操作之间是否可能存在冲突</strong>的所有问题, 而不需要陷入 Java 内存模型苦涩难懂的定义之中.</p> <p>现在就来看看 &quot;先行发生&quot; 原则指的是什么. <mark><strong>先行发生是 Java 内存模型中定义的两项操作之间的偏序关系, 比如说操作 A 先行发生于操作 B, 其实就是说在发生操作 B 之前, 操作 A 产生的影响能被操作 B 观察到, &quot;影响&quot; 包括修改了内存中共享变量的值, 发送了消息, 调用了方法等</strong></mark>. 这句话不难理解, 但它意味着什么呢? 可以举个例子来说明一下. 如代码清单 12-8 所示的这三条伪代码.</p> <blockquote><p>代码清单12-8 先行发生原则示例1</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 以下操作在线程 A 中执行</span>
i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">// 以下操作在线程 B 中执行</span>
j <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token comment">// 以下操作在线程 C 中执行</span>
i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>假设线程 A 中的操作 &quot;<code>i = 1</code>​&quot; 先行发生于线程 B 的操作 &quot;<code>j = i</code>​&quot;, 那就可以确定<strong>在线程 B 的操作执行后, 变量 j 的值一定是等于 1</strong>, 得出这个结论的依据有两个: 一是根据先行发生原则, &quot;<code>i = 1</code>​&quot; 的结果可以被观察到; 二是线程 C 还没登场, 线程 A 操作结束之后没有其他线程会修改变量 i 的值. 现在再来考虑线程 C, 依然保持线程 A 和 B 之间的先行发生关系, 而 C 出现在线程 A 和 B 的操作之间, 但是 C 与 B 没有先行发生关系, 那 j 的值会是多少呢? 答案是<strong>不确定</strong>! 1 和 2 都有可能, 因为线程 C 对变量 i 的影响可能会被线程 B 观察到, 也可能不会, <strong>这时候线程 B 就存在读取到过期数据的风险, 不具备多线程安全性</strong>.</p> <p>下面是 <strong>Java 内存模型下一些 &quot;天然的&quot; 先行发生关系, 这些先行发生关系无须任何同步器协助就已经存在, 可以在编码中直接使用</strong>. 如果两个操作之间的关系不在此列, 并且无法从下列规则推导出来, 则它们就没有顺序性保障, 虚拟机可以对它们随意地进行重排序.</p> <ul><li><strong>程序次序规则</strong>: <strong>在一个线程内, 按照控制流顺序, 书写在前面的操作先行发生于书写在后面的操作</strong>. 注意, 这里说的是控制流顺序而不是程序代码顺序, 因为要考虑分支, 循环等结构.</li> <li><strong>管程锁定规则</strong>: <strong>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</strong>. 这里必须强调的是 &quot;同一个锁&quot;, 而 &quot;后面&quot; 是指时间上的先后.</li> <li><strong>volatile 变量规则</strong>: 对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作, 这里的 &quot;后面&quot; 同样是指时间上的先后.</li> <li><strong>线程启动规则</strong>: Thread 对象的 start() 方法先行发生于此线程的每一个动作.</li> <li><strong>线程终止规则</strong>: 线程中的所有操作都先行发生于对此线程的终止检测, 可以通过 <code>Thread::join()</code>​ 方法是否结束, <code>Thread::isAlive()</code>​ 的返回值等手段检测线程是否已经终止执行.</li> <li><strong>线程中断规则</strong>: 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生, 可以通过 <code>Thread::interrupted()</code>​ 方法检测到是否有中断发生.</li> <li><strong>对象终结规则</strong>: 一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始.</li> <li><strong>传递性</strong>: 如果操作 A 先行发生于操作 B, 操作 B 先行发生于操作 C, 那就可以得出操作 A 先行发生于操作 C 的结论.</li></ul> <p>Java 语言无须任何同步手段保障就能成立的先行发生规则有且只有上面这些, 下面演示一下如何<strong>使用这些规则去判定操作间是否具备顺序性, 对于读写共享变量的操作来说, 就是线程是否安全</strong>. 读者还可以从下面这个例子中感受一下 &quot;时间上的先后顺序&quot; 与 &quot;先行发生&quot; 之间有什么不同. 演示例子如代码清单 12-9 所示.</p> <blockquote><p>代码清单12-9 先行发生原则示例2</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

pubilc <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>代码清单 12-9 中显示的是一组再普通不过的 getter/setter 方法, 假设存在线程 A 和 B, 线程 A 先(时间上的先后)调用了 setValue(1), 然后线程 B 调用了同一个对象的 getValue(), 那么线程 B 收到的返回值是什么?</p> <p>依次分析一下先行发生原则中的各项规则. 由于两个方法分别由线程 A 和 B 调用, 不在一个线程中, 所以程序次序规则在这里不适用; 由于没有同步块, 自然就不会发生 lock 和 unlock 操作, 所以管程锁定规则不适用; 由于 value 变量没有被 volatile 关键字修饰, 所以 volatile 变量规则不适用; 后面的线程启动, 终止, 中断规则和对象终结规则也和这里完全没有关系. 因为没有一个适用的先行发生规则, 所以最后一条传递性也无从谈起, 因此可以判定, 尽管线程 A 在操作时间上先于线程 B, 但是无法确定线程 B 中 getValue() 方法的返回结果, 换句话说, 这里面的操作<strong>不是线程安全</strong>的.</p> <p>那怎么修复这个问题呢? 至少有两种比较简单的方案可以选择: 要么把 getter/setter 方法都定义为 synchronized 方法, 这样就可以套用管程锁定规则; 要么把 value 定义为 volatile 变量, <strong>由于 setter 方法对 value 的修改不依赖 value 的原值, 满足 volatile 关键字使用场景, 这样就可以套用 volatile 变量规则来实现先行发生关系</strong>.</p> <p>通过上面的例子, 可以得出结论: <strong>一个操作 &quot;时间上的先发生&quot; 不代表这个操作会是 &quot;先行发生&quot;</strong> . 那如果一个操作 &quot;先行发生&quot;, 是否就能推导出这个操作必定是 &quot;时间上的先发生&quot; 呢? 很遗憾, 这个推论也是不成立的. 一个典型的例子就是多次提到的 &quot;指令重排序&quot;, 演示例子如代码清单 12-10 所示.</p> <blockquote><p>代码清单12-10 先行发生原则示例3</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 以下操作在同一个线程中执行</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>代码清单 12-10 所示的两条赋值语句在同一个线程之中, 根据程序次序规则, &quot;<code>int i = 1</code>​&quot; 的操作先行发生于 &quot;<code>int j = 2</code>​&quot;, 但是 &quot;<code>int j = 2</code>​&quot; 的代码完全<strong>可能先被处理器执行</strong>, 这并不影响先行发生原则的正确性, 因为在这条线程之中没有办法感知到这一点.</p> <p>上面两个例子综合起来证明了一个结论: <mark><strong>时间先后顺序与先行发生原则之间基本没有因果关系, 所以衡量并发安全问题的时候不要受时间顺序的干扰, 一切必须以先行发生原则为准</strong></mark>.</p> <h4 id="指令重排序"><a href="#指令重排序" class="header-anchor">#</a> 指令重排序</h4> <h5 id="_1-概述"><a href="#_1-概述" class="header-anchor">#</a> 1.概述</h5> <p>重排序是指编译器或处理器为了优化程序性能而对指令序列进行排序的一种手段.</p> <p>为了<strong>提高性能</strong>, <strong>编译器和处理器</strong>常常会对程序<strong>指令进行重排序</strong>. JVM 的<strong>即时编译器</strong>中也有类似的指令重排序(Instruction Reorder)优化. JVM 能根据<strong>处理器特性</strong>(CPU 多级缓存系统, 多核处理器等)适当的对机器指令进行重排序, <strong>使机器指令能更符合 CPU 的执行特性, 最大限度的发挥机器性能</strong>.</p> <blockquote><p>重排序发生的场景</p></blockquote> <p>重排序可能在下面<strong>三种场景下出现</strong>:</p> <ol><li><strong>编译器优化的重排序</strong>. 编译器在不改变单线程程序语义的前提下, 可以重新安排语句的执行顺序. 简单理解就是可能会对代码的结构进行重排序.</li> <li><strong>指令级并行(CPU运行时)的重排序</strong>. 现代处理器采用了<strong>指令级并行技术</strong>(Instruction-Level Parallelism, ILP)来将多条指令重叠执行. 如果不存在数据依赖性, 处理器可以改变语句对应机器指令的执行顺序.</li> <li><strong>内存系统的重排序</strong>. 由于处理器使用缓存和读/写缓冲区, 这使得<strong>加载和存储</strong>操作看上去可能是在乱序执行.</li></ol> <p>下图为从源码到最终执行的指令序列示意图.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220601223747940.png" alt=""></p> <blockquote><p>重排序示例</p></blockquote> <p>如下所示, 在 cnt++ 之后还有其他操作, 但这里的其他操作与当前的 cnt++ 无关.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 不是原子操作</span>
        example<span class="token punctuation">.</span>cnt<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token comment">// 其他操作</span>
        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在之前的例子中, 由于 cnt 有 volatile 关键字进行修饰, 所以当线程 1 根据缓存一致性协议将 cnt 的值置为 M(Modified) 的时候, 会把线程 2 中的 cnt 的值置为无效. 当线程 2 进行下一次循环时, 需要从主内存再次读取最新的 cnt 的值, 然而线程 1 此时有可能并未将 cnt 的值同步回内存, 所以线程 2 就需要<strong>进行等待</strong>. 为了<strong>提升效率</strong>, 在遵守 as-if-serial 语义的原则下, CPU 在这里可以进行<strong>指令重排序</strong>, 让后面的操作先执行, 等到 cnt 的值 ready 后再去读取最新的值. 这就用到了指令重排序.</p> <h5 id="_2-重排序导致的可见性问题"><a href="#_2-重排序导致的可见性问题" class="header-anchor">#</a> 2.重排序导致的可见性问题</h5> <blockquote><p>重排序导致问题示例</p></blockquote> <p><strong>(1) 编译器重排序</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 优化前</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a1 <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b1 <span class="token operator">=</span> y <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a2 <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b2 <span class="token operator">=</span> y <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">// 优化后</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a1 <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a2 <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b1 <span class="token operator">=</span> y <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b2 <span class="token operator">=</span> y <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>CPU 只读一次</strong> x 和 y 的值. 不需反复读取<strong>寄存器</strong>来<strong>交替 x 和 y 值</strong>.</p> <p><strong>(2) 处理器重排序</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">// 处理器A执行</span>
a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
x <span class="token operator">=</span> b<span class="token punctuation">;</span>
<span class="token comment">// 处理器B执行</span>
b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
y <span class="token operator">=</span> a<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>处理器 A 读 b = 0, 处理器 B 读 a = 0. A1 写 a = 1 先写到处理器 A 的工作内存中, 此时主内存中 a = 0. 如果这时处理器 B 从主内存中读 a, 读到的将是 0. 可能会出现 x, y 都是 0.</p> <p>这说明<strong>重排序都可能会导致多线程程序出现内存可见性问题</strong>.</p> <h5 id="_3-重排序的规则"><a href="#_3-重排序的规则" class="header-anchor">#</a> 3.重排序的规则</h5> <blockquote><p>数据依赖性</p></blockquote> <p>如果两个操作访问<strong>同一个变量</strong>, 且这两个操作中有一个为<strong>写操作</strong>, 此时这两个操作之间就存在<strong>数据依赖性</strong>. 数据依赖分下列三种类型:</p> <table><thead><tr><th style="text-align:center;">名称</th> <th style="text-align:center;">代码示例</th> <th style="text-align:center;">说明</th></tr></thead> <tbody><tr><td style="text-align:center;"><strong>写后读</strong></td> <td style="text-align:center;">a = 1; b = a;</td> <td style="text-align:center;">写一个变量之后, 再读这个变量.</td></tr> <tr><td style="text-align:center;"><strong>写后写</strong></td> <td style="text-align:center;">a = 1; a = 2;</td> <td style="text-align:center;">写一个变量之后, 再写这个变量.</td></tr> <tr><td style="text-align:center;"><strong>读后写</strong></td> <td style="text-align:center;">a = b; b = 1;</td> <td style="text-align:center;">读一个变量之后, 再写这个变量.</td></tr></tbody></table> <p>上面三种情况其实就是只要对这两个操作的执行顺序进行重排序, 程序的执行结果<strong>将会被改变</strong>.</p> <p>编译器和处理器在重排序时, 会<strong>遵守数据依赖性</strong>, 编译器和处理器<strong>不会对存在数据依赖关系</strong>的两个操作的进行重排序. 注意, 这里所说的数据依赖性仅针对<strong>单个处理器</strong>中执行的指令序列和单个线程中执行的操作, 不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑.</p> <blockquote><p>重排序的规则</p></blockquote> <p>虽然可以做优化, 但重排序也需要遵守一定<strong>规则</strong>:</p> <ul><li><strong>1. 重排序操作不会对存在数据依赖关系的操作进行重排序</strong>. 比如: a = 1; b = a; 这个指令序列, 由于第二个操作依赖于第一个操作, 所以在编译时和处理器运行时这两个操作不会被重排序.</li> <li><strong>2. 不管怎么重排序, 单线程下程序的执行结果不能被改变</strong>. 这也叫 <strong>as-if-serial 语义</strong>.</li></ul> <h5 id="_4-as-if-serial语义"><a href="#_4-as-if-serial语义" class="header-anchor">#</a> 4.as-if-serial语义</h5> <p><strong>指令重排序</strong>必须遵守 <strong>as-if-serial 语义</strong>. as-if-serial 语义是指: <strong>不管怎么重排序</strong>(编译器和处理器为了提高并行度), (<strong>单线程</strong>)程序的执行结果<strong>不能被改变</strong>.</p> <p>为了遵守 as-if-serial 语义, 编译器和处理器<strong>不会对存在数据依赖关系的操作做重排序</strong>, 因为这种重排序会改变执行结果. 但如果操作之间<strong>不存在</strong>数据依赖关系, 这些操作就可能被编译器和处理器<strong>重排序</strong>. 比如下面计算圆面积的代码示例:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">double</span> pi  <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>    <span class="token comment">// A</span>
<span class="token keyword">double</span> r   <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>     <span class="token comment">// B</span>
<span class="token keyword">double</span> area <span class="token operator">=</span> pi <span class="token operator">*</span> r <span class="token operator">*</span> r<span class="token punctuation">;</span> <span class="token comment">// C</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面三个操作的<strong>数据依赖关系</strong>如下图所示:</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220601223825498.png" alt=""></p> <p>如上图所示, <strong>A 和 C</strong> 之间存在数据依赖关系, 同时 <strong>B 和 C</strong> 之间也存在数据依赖关系. 因此在最终执行的指令序列中, C 不能被重排序到 A 和 B 的前面(因为这样程序的结果将会被改变). 但 <strong>A 和 B 之间没有</strong>数据依赖关系, 编译器和处理器<strong>可以重排序 A 和 B</strong> 之间的执行顺序. 下图是该程序的两种执行顺序:</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220601223853583.png" alt=""></p> <p>这里 A happens-before B, 但实际执行时 B 却可以<strong>排在 A 之前执行</strong>(看上面的重排序后的执行顺序). 如果 A happens-before B, JMM 并不要求 A 一定要在 B 之前执行. JMM 仅仅要求前一个操作(执行的结果)对后一个操作可见, 且前一个操作按顺序排在第二个操作之前. 这里操作 A 的执行结果不需要对操作 B 可见; 而且重排序操作 A 和操作 B 后的执行结果, 与操作 A 和操作 B 按 happens-before 顺序执行的结果一致. 在这种情况下,  JMM 允许这种重排序.</p> <p>在计算机中, 软件技术和硬件技术有一个共同的目标: <strong>在不改变程序执行结果的前提下, 尽可能的开发并行度</strong>. 编译器和处理器遵从这一目标, 从 happens-before 的定义可以看出, JMM 同样遵从这一目标.</p> <h5 id="_5-解决指令重排序导致的可见性问题"><a href="#_5-解决指令重排序导致的可见性问题" class="header-anchor">#</a> 5.解决指令重排序导致的可见性问题</h5> <ul><li>对于<strong>编译器重排序</strong>, JMM 的编译器重排序规则会<strong>禁止特定类型</strong>的编译器重排序(不是所有的编译器重排序都要禁止).</li> <li>对于<strong>处理器重排序</strong>, JMM 的处理器重排序规则会要求 Java 编译器在<strong>生成指令序列时, 插入特定类型的内存屏障指令</strong>, 通过内存屏障指令来禁止特定类型的处理器重排序(不是所有的处理器重排序都要禁止), v<strong>olatile</strong> 关键字就是通过<strong>加入内存屏障实现的禁止指令重排序</strong>.</li></ul> <blockquote><p>还有没有什么方法可以禁止指令重排序?</p></blockquote> <p>禁止指令重排序其实只需要加<strong>内存屏障</strong>就行了. 上述的加锁, volatile, final 等都会加上内存屏障, 如果不用这些, 还可以<strong>自己手动在代码中加内存屏障</strong>. 可以利用 <strong>Unsafe</strong> 类中的 <strong>loadFence(), storeFence()</strong>  等方法.</p> <h4 id="volatile"><a href="#volatile" class="header-anchor">#</a> volatile</h4> <p><strong>关键字 volatile 可以说是 Java 虚拟机提供的最轻量级的同步机制</strong>, 但是它并不容易被正确, 完整地理解, 以至于许多程序员都习惯去避免使用它, 遇到需要处理多线程数据竞争问题的时候一律使用 synchronized 来进行同步. 了解 volatile 变量的语义对后面理解多线程操作的其他特性很有意义, 在本节中将多花费一些篇幅介绍 volatile 到底意味着什么.</p> <p><strong>Java 内存模型为 volatile 专门定义了一些特殊的访问规则</strong>, 在介绍这些比较拗口的规则定义之前, 先用一些不那么正式, 但通俗易懂的语言来介绍一下这个关键字的作用.</p> <p>volatile 关键字有如下两个语义:</p> <ul><li><strong>保证可见性</strong>: 保证被 volatile 修饰的共享变量<strong>对所有线程是可见</strong>的, 也就是当一个线程修改了一个被 volatile 修饰共享变量的值, 新值总是可以被其他线程立即得知. <strong>对 volatile 变量的修改, 修改之后, 马上同步回主内存, 而对其读则每次必须从主内存进行刷新读</strong>.</li> <li><strong>禁止指令重排序优化</strong>.</li></ul> <h5 id="_1-volatile的语义-用处"><a href="#_1-volatile的语义-用处" class="header-anchor">#</a> 1.volatile的语义(用处)</h5> <h6 id="_1-volatile保证可见性"><a href="#_1-volatile保证可见性" class="header-anchor">#</a> (1)volatile保证可见性</h6> <p>对 <strong>volatile 变量</strong>的修改操作<strong>其他线程是能够立即感知</strong>到的. 将一个共享变量声明为 volatile 后, 当<strong>写</strong>一个 volatile 变量时, JMM 会把该线程对应的<strong>工作内存</strong>中的变量<strong>强制刷新到主内存</strong>中去, 这个写会操作会导致其他线程中的<strong>缓存无效</strong>. 其他线程的每次进行<strong>读操作时</strong>会强制要求线程去<strong>主内存读取最新的数据</strong>. 这样就保证了可见性.</p> <p><img src="https://nano-note.oss-cn-beijing.aliyuncs.com/images/image-20220601224010107.png" alt=""></p> <p>当一个变量被定义成 volatile 之后, 它将具备两项特性: <mark><strong>第一项是保证此变量对所有线程的可见性, 这里的 &quot;可见性&quot; 是指当一条线程修改了这个变量的值, 新值对于其他线程来说是可以立即得知的</strong></mark>. 而普通变量并不能做到这一点, 普通变量的值<strong>在线程间传递时均需要通过主内存来完成</strong>. 比如, 线程 A 修改一个普通变量的值, 然后向主内存进行回写, 另外一条线程 B 在线程 A 回写完成了之后再对主内存进行读取操作, 新变量值才会对线程 B 可见.</p> <p>关于 volatile 变量的可见性, 经常会被开发人员误解, 他们会误以为下面的描述是正确的: &quot;volatile 变量对所有线程是立即可见的, 对 volatile 变量所有的写操作都能立刻反映到其他线程之中. 换句话说, volatile 变量在各个线程中是一致的, 所以基于 volatile 变量的运算在并发下是线程安全的&quot;. 这句话的论据部分并没有错, 但是由其论据并不能得出 &quot;基于 volatile 变量的运算在并发下是线程安全的&quot; 这样的结论. volatile 变量在各个线程的工作内存中是不存在一致性问题的(从物理存储的角度看, 各个线程的工作内存中 volatile 变量也可以存在不一致的情况, 但由于每次使用之前都要先刷新, 执行引擎看不到不一致的情况, 因此可以认为不存在一致性问题), 但是 <mark><strong>Java 里面的运算操作符并非原子操作, 这导致 volatile 变量的运算在并发下一样是不安全的</strong></mark>, 可以通过一段简单的演示来说明原因, 请看代码清单 12-1 中演示的例子.</p> <blockquote><p>代码清单12-1 volatile的运算</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * volatile 变量自增运算测试
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> race <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        race<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">THREADS_COUNT</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span><span class="token punctuation">[</span><span class="token punctuation">]</span> threads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">[</span><span class="token constant">THREADS_COUNT</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">THREADS_COUNT</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 等待所有累加线程都结束</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">activeCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>race<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>这段代码发起了 20 个线程, 每个线程对 race 变量进行 10000 次自增操作, 如果这段代码能够正确并发的话, 最后输出的结果应该是 200000. 读者运行完这段代码之后, 并不会获得期望的结果, 而且会发现每次运行程序, 输出的结果都不一样, 都是一个小于 200000 的数字. 这是为什么呢?</p> <p>问题就出在自增运算 &quot;race++&quot; 之中, 用 Javap 反编译这段代码后会得到代码清单 12-2 所示, 发现只有一行代码的 increase() 方法在 Class 文件中是<strong>由 4 条字节码指令构成</strong>(return 指令不是由 race++ 产生的, 这条指令可以不计算), 从字节码层面上已经很容易分析出并发失败的原因了: <mark><strong>当 getstatic 指令把 race 的值取到操作栈顶时, volatile 关键字保证了 race 的值在此时是正确的, 但是在执行 iconst_1, iadd 这些指令的时候, 其他线程可能已经把 race 的值改变了, 而操作栈顶的值就变成了过期的数据, 所以 putstatic 指令执行后就可能把较小的 race 值同步回主内存之中</strong></mark>.</p> <blockquote><p>代码清单12-2 VolatileTest的字节码</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Code</span><span class="token operator">:</span>
        <span class="token class-name">Stack</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">Locals</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Args_size</span><span class="token operator">=</span><span class="token number">0</span>
        <span class="token number">0</span><span class="token operator">:</span>   getstatic       #<span class="token number">13</span><span class="token punctuation">;</span> <span class="token comment">//Field race:I</span>
        <span class="token number">3</span><span class="token operator">:</span>   iconst_1
        <span class="token number">4</span><span class="token operator">:</span>   iadd
        <span class="token number">5</span><span class="token operator">:</span>   putstatic       #<span class="token number">13</span><span class="token punctuation">;</span> <span class="token comment">//Field race:I</span>
        <span class="token number">8</span><span class="token operator">:</span>   <span class="token keyword">return</span>
    <span class="token class-name">LineNumberTable</span><span class="token operator">:</span>
        line <span class="token number">14</span><span class="token operator">:</span> <span class="token number">0</span>
        line <span class="token number">15</span><span class="token operator">:</span> <span class="token number">8</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>实事求是地说, 这里使用字节码来分析并发问题仍然是不严谨的, 因为<mark><strong>即使编译出来只有一条字节码指令, 也并不意味执行这条指令就是一个原子操作</strong></mark>. 一条字节码指令在解释执行时, 解释器要运行许多行代码才能实现它的语义. 如果是编译执行, <strong>一条字节码指令也可能转化成若干条本地机器码指令</strong>. 此处使用 <code>-XX: +PrintAssembly</code>​ 参数输出反汇编来分析才会更加严谨一些, 但是考虑到读者阅读的方便性, 并且字节码已经能很好地说明问题, 所以此处使用字节码来解释.</p> <p>由于 volatile 变量<strong>只能保证可见性</strong>, 在不符合以下两条规则的运算场景中, <strong>仍然要通过加锁(使用 synchronized, java.util.concurrent 中的锁或原子类)来保证原子性</strong>:</p> <ul><li><strong>运算结果并不依赖变量的当前值, 或者能够确保只有单一的线程修改变量的值</strong>.</li> <li><strong>变量不需要与其他的状态变量共同参与不变约束</strong>.</li></ul> <p>而在像代码清单 12-3 所示的这类场景中就很适合使用 volatile 变量来控制并发, 当 shutdown() 方法被调用时, 能保证所有线程中执行的 doWork() 方法都立即停下来.</p> <blockquote><p>代码清单12-3 volatile的使用场景1</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">volatile</span> <span class="token keyword">boolean</span> shutdownRequested<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    shutdownRequested <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里只是读取, 读取的时候一定是最新的值; 而且只有一个线程成功会改这个值(这里不是持续计算的操作), </span>
    <span class="token comment">// 改了之后读到的都是最新的值了</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>shutdownRequested<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 代码的业务逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>对于下面的例子, 如果给 flag 加上 volatile 关键字, 那么就能保证线程 B 将 flag 修改完成并同步回主内存的时候, 线程 A 能够嗅探到 flag 值的变化, 并重新从主内存取值, 使得线程 A 可以退出死循环.</p> <blockquote><p>代码清单12-4 volatile的使用场景2</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NanoVolatileVisibilitySample</span> <span class="token punctuation">{</span>

    <span class="token comment">// 全局变量(加上volatile修饰)</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程 &quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; 修改 flag.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 死循环</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程: &quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;发现flag变化.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">NanoVolatileVisibilitySample</span> sample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NanoVolatileVisibilitySample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> threadA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            sample<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;threadA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> threadB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// 刷新flag为true</span>
            sample<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;threadB&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 先开启B线程</span>
        threadA<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 再开启B线程</span>
        threadB<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;当前变量值: &quot;</span> <span class="token operator">+</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><p>运行结果:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>线程 threadB 修改flag<span class="token punctuation">.</span>
线程 threadA 发现flag变化<span class="token punctuation">.</span>
当前变量值<span class="token operator">:</span> <span class="token boolean">true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>从测试结果(对比 可见性 示例中的结果)就可以看出 volatile 保证了可见性.</p> <h6 id="_2-volatile禁止重排序优化"><a href="#_2-volatile禁止重排序优化" class="header-anchor">#</a> (2)volatile禁止重排序优化</h6> <p><mark><strong>使用 volatile 变量的第二个语义是禁止指令重排序优化</strong></mark>, <strong>普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果, 而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致</strong>. 因为在同一个线程的方法执行过程中无法感知到这点, 这就是 Java 内存模型中描述的所谓 &quot;线程内表现为串行的语义&quot;.</p> <p>上面描述仍然比较拗口难明, 还是继续通过一个例子来看看<strong>为何指令重排序会干扰程序的并发执行</strong>. 演示程序如代码清单 12-4 所示.</p> <blockquote><p>代码清单12-4 指令重排序</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Map</span> configOptions<span class="token punctuation">;</span>
<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> configText<span class="token punctuation">;</span>
<span class="token comment">// 此变量必须定义为 volatile</span>
<span class="token keyword">volatile</span> <span class="token keyword">boolean</span> initialized <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token comment">// 假设以下代码在线程 A 中执行</span>
<span class="token comment">// 模拟读取配置信息, 当读取完成后</span>
<span class="token comment">// 将 initialized 设置为 true,通知其他线程配置可用</span>
configOptions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
configText <span class="token operator">=</span> <span class="token function">readConfigFile</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">processConfigOptions</span><span class="token punctuation">(</span>configText<span class="token punctuation">,</span> configOptions<span class="token punctuation">)</span><span class="token punctuation">;</span>
initialized <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token comment">// 假设以下代码在线程 B 中执行</span>
<span class="token comment">// 等待 initialized 为 true, 代表线程 A 已经把配置信息初始化完成</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>initialized<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用线程 A 中初始化好的配置信息</span>
<span class="token function">doSomethingWithConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>代码清单 12-4 中所示的程序是一段伪代码, 其中描述的场景是开发中常见配置读取过程, 只是在处理配置文件时一般不会出现并发, 所以没有察觉这会有问题.</p> <p>试想一下, 如果定义 initialized 变量时没有使用 volatile 修饰, 就可能会由于指令重排序的优化, 导致位于线程 A 中最后一条代码 &quot;<code>initialized = true</code>​&quot; <strong>被提前执行</strong>(这里虽然使用 Java 作为伪代码, 但所指的重排序优化是机器级的优化操作, 提前执行是指这条语句对应的汇编代码被提前执行), 这样在线程 B 中使用配置信息的代码就可能出现错误, 而 volatile 关键字则可以避免此类情况的发生.</p> <p>指令重排序是并发编程中最容易导致开发人员产生疑惑的地方之一, 除了上面伪代码的例子之外, 再举一个可以实际操作运行的例子来<strong>分析 volatile 关键字是如何禁止指令重排序优化</strong>的.</p> <p>代码清单 12-5 所示是一段<strong>标准的双锁检测(Double Check Lock, DCL)单例代码</strong>, 可以观察加入 volatile 和未加入 volatile 关键字时所生成的汇编代码的差别.</p> <blockquote><p>代码清单12-5 DCL单例模式</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>编译后, 这段代码对 instance 变量赋值的部分如代码清单 12-6 所示.</p> <blockquote><p>代码清单12-6 对instance变量赋值</p></blockquote> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>0x01a3de0f: mov    $0x3375cdb0,%esi     ;...beb0cd75 33
                                        ;   {oop('Singleton')}
0x01a3de14: mov    %eax,0x150(%esi)     ;...89865001 0000
0x01a3de1a: shr    $0x9,%esi            ;...c1ee09
0x01a3de1d: movb   $0x0,0x1104800(%esi) ;...c6860048 100100
0x01a3de24: lock addl $0x0,(%esp)       ;...f0830424 00
                                        ;*putstatic instance
                                        ; - Singleton::getInstance@24
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>通过对比发现, <strong>关键变化在于有 volatile 修饰的变量</strong>, 赋值后(前面 <code>mov%eax, 0x150(%esi)</code>​ 这句便是赋值操作)多执行了一个 &quot;<code>lock addl$0x0, (%esp)</code>​&quot; 操作, 这个操作的作用相当于一个<mark><strong>内存屏障</strong></mark>(Memory Barrier 或 Memory Fence, <mark><strong>指重排序时不能把后面的指令重排序到内存屏障之前的位置</strong></mark>, 注意不要与前面介绍的垃圾收集器用于捕获变量访问的内存屏障互相混淆), <strong>只有一个处理器访问内存时, 并不需要内存屏障; 但如果有两个或更多处理器访问同一块内存, 且其中有一个在观测另一个, 就需要内存屏障来保证一致性了</strong>.</p> <p>这句指令中的 &quot;<code>addl$0x0, (%esp)</code>​&quot;(把 ESP 寄存器的值加 0)显然是一个空操作, 之所以用这个空操作而不是空操作专用指令 nop, 是因为 IA32 手册规定 lock 前缀不允许配合 nop 指令使用. 这里的关键在于 lock 前缀, 查询 IA32 手册可知, 它的作用是将本处理器的缓存写入了内存, 该写入动作也会引起别的处理器或者别的内核无效化(Invalidate)其缓存, 这种操作相当于对缓存中的变量做了一次前面介绍 Java 内存模式中所说的 &quot;store 和 write&quot; 操作. <strong>所以通过这样一个空操作, 可让前面 volatile 变量的修改对其他处理器立即可见</strong>.</p> <p>那为何说它禁止指令重排序呢? 从硬件架构上讲, 指令重排序是指处理器采用了允许将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理. 但并不是说指令任意重排, 处理器必须能正确处理指令依赖情况保障程序能得出正确的执行结果. 譬如指令 1 把地址 A 中的值加 10, 指令 2 把地址 A 中的值乘以 2, 指令 3 把地址 B 中的值减去 3, 这时指令 1 和指令 2 是<strong>有依赖的, 它们之间的顺序不能重排</strong>——<code>(A + 10) * 2</code>​ 与 <code>A * 2 + 10</code>​ 显然不相等, 但<strong>指令 3 可以重排到指令 1, 2 之前或者中间</strong>, 只要保证处理器执行后面依赖到 A, B 值的操作时能获取正确的 A 和 B 值即可. 所以<strong>在同一个处理器中, 重排序过的代码看起来依然是有序的</strong>. 因此, <code>lock addl$0x0, (%esp)</code>​ 指令把修改同步到内存时, 意味着所有之前的操作都已经执行完成, 这样便形成了 &quot;指令重排序无法越过内存屏障&quot; 的效果.</p> <p>解决了 volatile 的语义问题, 再来看看在众多保障并发安全的工具中选用 <strong>volatile 的意义</strong>---它能让代码比使用其他的同步工具更快吗? 在某些情况下, volatile 的同步机制的性能确实要优于锁(使用 synchronized 关键字或 java.util.concurrent 包里面的锁), 但是由于虚拟机对锁实行的许多消除和优化, 使得很难确切地说 volatile 就会比 synchronized 快上多少. 如果让 volatile 自己与自己比较, 那可以确定一个原则: <mark><strong>volatile 变量读操作的性能消耗与普通变量几乎没有什么差别, 但是写操作则可能会慢上一些, 因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行</strong></mark>. 不过即便如此, 大多数场景下 volatile 的总开销仍然要比锁来得更低. <strong>在 volatile 与锁中选择的唯一判断依据仅仅是 volatile 的语义能否满足使用场景的需求</strong>.</p> <p>本节的最后, 再回头来<strong>看看 Java 内存模型中对 volatile 变量定义的特殊规则的定义</strong>. 假定 T 表示一个线程, V 和 W 分别表示两个 volatile 型变量, 那么在进行 read, load, use, assign, store 和 write 操作时需要满足如下规则:</p> <ul><li>只有当线程 T 对变量 V 执行的前一个动作是 load 的时候, 线程 T 才能对变量 V 执行 use 动作; 并且, 只有当线程 T 对变量 V 执行的后一个动作是 use 的时候, 线程 T 才能对变量 V 执行 load 动作. 线程 T 对变量 V 的 use 动作可以认为是和线程 T 对变量 V 的 load, read 动作相关联的, 必须连续且一起出现. <strong>这条规则要求在工作内存中, 每次使用 V 前都必须先从主内存刷新最新的值, 用于保证能看见其他线程对变量 V 所做的修改</strong>.</li> <li>只有当线程 T 对变量 V 执行的前一个动作是 assign 的时候, 线程 T 才能对变量 V 执行 store 动作; 并且, 只有当线程 T 对变量 V 执行的后一个动作是 store 的时候, 线程 T 才能对变量 V 执行 assign 动作. 线程 T 对变量 V 的 assign 动作可以认为是和线程 T 对变量 V 的 store, write 动作相关联的, 必须连续且一起出现. <strong>这条规则要求在工作内存中, 每次修改 V 后都必须立刻同步回主内存中, 用于保证其他线程可以看到自己对变量 V 所做的修改</strong>.</li> <li>假定动作 A 是线程 T 对变量 V 实施的 use 或 assign 动作, 假定动作 F 是和动作 A 相关联的 load 或 store 动作, 假定动作 P 是和动作 F 相应的对变量 V 的 read 或 write 动作; 与此类似, 假定动作 B 是线程 T 对变量 W 实施的 use 或 assign 动作, 假定动作 G 是和动作 B 相关联的 load 或 store 动作, 假定动作 Q 是和动作 G 相应的对变量 W 的 read 或 write 动作. 如果 A 先于 B, 那么 P 先于 Q. <strong>这条规则要求 volatile 修饰的变量不会被指令重排序优化, 从而保证代码的执行顺序与程序的顺序相同</strong>.</li></ul> <h5 id="_2-volatile无法保证原子性"><a href="#_2-volatile无法保证原子性" class="header-anchor">#</a> 2.volatile无法保证原子性</h5> <p>参考 (2)原子性问题 可知, 对于 cnt++ 这种<strong>复合</strong>操作, 即使用 volatile 对 cnt 进行修饰, 也<strong>无法保证原子性</strong>, 多线程操作仍存在安全性问题. 解决方案就是使用并发包中的原子操作类, 通过<strong>循环 CAS</strong> 地方式来保证 cnt++ 操作的原子性.</p> <p>使用 synchronized 可以保证线程安全, 由于 synchronized 本身也具备与 volatile <strong>相同的特性</strong>, 即可见性, 因此在这样种情况下就完全可以省去 volatile 修饰变量.</p> <h5 id="_3-synchronized和volatile的区别"><a href="#_3-synchronized和volatile的区别" class="header-anchor">#</a> 3.synchronized和volatile的区别</h5> <ul><li>volatile 是告诉 JVM 当前变量在寄存器(工作内存)中的值是不确定的, 需要<strong>从主存</strong>中读取; synchronized 则是用于并发资源访问控制.</li> <li><strong>使用上</strong>: volatile 仅能作用于<strong>变量</strong>; synchronized 则可以使用在<strong>变量, 方法, 类</strong>上.</li> <li><strong>阻塞上</strong>: <strong>多线程访问 volatile 关键字不会发生阻塞, 而 synchronized 关键字可能会发生阻塞</strong>.</li> <li><strong>功能上</strong>: volatile 关键字主要用于保证变量在多个线程之间的<strong>可见性</strong>, 不能保证数据的<strong>原子性</strong>. 而 synchronized 关键字解决的是多个线程之间访问资源的同步问题, <strong>可见性与原子性都能保证</strong>.</li></ul> <h5 id="_4-拓展问题"><a href="#_4-拓展问题" class="header-anchor">#</a> 4.拓展问题</h5> <blockquote><p>volatile与CAS的大量使用会有啥问题?</p></blockquote> <p>可能会导致<strong>总线风暴</strong>问题. volatile 引入的 <strong>MESI</strong> 缓存一致性协议需要不断的从<strong>主内存嗅探</strong>和 CAS 不断循环无效交互导致<strong>总线带宽达到峰值</strong>.</p> <p>解决办法: <strong>部分</strong> volatile 和 CAS 使用 synchronized. volatile 与 synchronize 同时使用的场景: <strong>单例模式</strong>.</p> <h4 id="内存屏障"><a href="#内存屏障" class="header-anchor">#</a> 内存屏障</h4> <p><strong>内存屏障</strong>又称内存栅栏, 是一个 <strong>CPU 指令</strong>.</p> <p>内存屏障的作用:</p> <ul><li><strong>强制刷出各种 CPU 的缓存数据</strong>, 因此任何 CPU 上的线程都能读取到这些数据的最新版本(<strong>解决可见性问题</strong>).</li> <li><strong>禁止</strong>指令重排序(<strong>解决重排序问题</strong>).</li></ul> <p>所以 <strong>volatile 变量正是通过内存屏障实现其在内存中的语义, 即可见性和禁止重排优化</strong>.</p> <p><strong>处理器提供内存屏障指令</strong>主要有:</p> <ul><li><strong>写内存屏障指令</strong>(Store Memory Barrier): 处理器将存储缓存值<strong>写回主存</strong>(阻塞方式).</li> <li><strong>读内存屏障指令</strong>(Load Memory Barrier): 处理器处理<strong>失效队列</strong>(阻塞方式).</li></ul> <p>在 volatile <strong>读前插</strong>读屏障, <strong>写后插</strong>写屏障, <strong>避免 CPU 重排序</strong>导致的问题, 实现多线程之间数据的<strong>可见性</strong>.</p> <p><strong>屏障类型</strong>:</p> <table><thead><tr><th style="text-align:center;">屏障类型</th> <th style="text-align:center;">指令实例</th> <th style="text-align:left;">说明</th></tr></thead> <tbody><tr><td style="text-align:center;">LoadLoad Barriers</td> <td style="text-align:center;">Load1;LoadLoad;Load2</td> <td style="text-align:left;">确保 Load1 数据的装载先于 Load2 及所有后续指令的装载</td></tr> <tr><td style="text-align:center;">StoreStore Barriers</td> <td style="text-align:center;">Store1;StoreStore;Store2</td> <td style="text-align:left;">确保 Store1 数据对其他处理器可见(刷新到内存),先于 Store2 及所有后续存储指令的存储</td></tr> <tr><td style="text-align:center;">LoadStore Barriers</td> <td style="text-align:center;">Load1;LoadStore;Store2</td> <td style="text-align:left;">确保 Load1 数据的装载先于 Store2 及所有后续存储指令刷新到内存</td></tr> <tr><td style="text-align:center;">StoreLoad Barriers</td> <td style="text-align:center;">Store1;StoreLoad;Load2</td> <td style="text-align:left;">确保 Store1 数据对其他处理器可见(刷新到内存),先于 Load2 及所有后续装载指令的装载</td></tr></tbody></table> <p><strong>StoreLoad</strong> 开销最大. 万能屏障, 兼具其它三种内存屏障功能. 执行时, 处理器通常要把写缓冲区中的数据<strong>全部刷新的内存中</strong>.</p> <p>对于处理器来说, <strong>内存屏障</strong>会导致 <strong>CPU 缓存的刷新</strong>, 刷新时会遵循缓存一致性协议.</p> <ul><li><strong>Synchronized</strong>: <strong>解锁时</strong>, JVM 会强制<strong>刷新 CPU 缓存</strong>, 导致当前线程更改, 对其他线程可见.</li> <li><strong>volatile</strong>: 标记 volatile 的字段, 在<strong>写</strong>操作时, 会强制<strong>刷新 CPU 缓存</strong>, 每次读取都是<strong>直接读内存</strong>.</li> <li><strong>final</strong>: 即时编译器在 final 写操作后, 会插入<strong>内存屏障</strong>, 来禁止重排序, 保证可见性.</li></ul> <p>Java 中可以通过 Unsafe 类的方法实现内存屏障(参考 Unsafe实现内存屏障).</p> <h4 id="java与线程"><a href="#java与线程" class="header-anchor">#</a> Java与线程</h4> <p>并发不一定要依赖多线程(如 PHP 中很常见的多进程并发), 但是在 Java 里面谈论并发, 基本上都与线程脱不开关系. 既然本书探讨的是 Java 虚拟机的特性, 那讲到 Java 线程, 就从 Java 线程在虚拟机中的实现开始讲起.</p> <h5 id="_1-线程的实现"><a href="#_1-线程的实现" class="header-anchor">#</a> 1.线程的实现</h5> <p><strong>线程是比进程更轻量级的调度执行单位</strong>, 线程的引入, 可以把一个进程的资源分配和执行调度分开, 各个线程既可以共享进程资源(内存地址, 文件 I/O 等), 又可以独立调度. 目前<strong>线程是 Java 里面进行处理器资源调度的最基本单位</strong>, 不过如果日后 Loom 项目能成功为 Java 引入<strong>纤程</strong>(Fiber)的话, 可能就会改变这一点.</p> <p>主流的操作系统都提供了线程实现, Java 语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理, 每个已经调用过 start() 方法且还未结束的 java.lang.Thread 类的实例就代表着一个线程. 可以注意到 Thread 类与大部分的 Java 类库 API 有着显著差别, 它的<strong>所有关键方法都被声明为 Native</strong>. 在 Java 类库 API 中, 一个 Native 方法往往就意味着这个方法没有使用或无法使用平台无关的手段来实现(当然也可能是为了执行效率而使用 Native 方法, 不过通常最高效率的手段也就是平台相关的手段). 正因为这个原因, 本节的标题被定为 &quot;线程的实现&quot; 而不是 &quot;Java 线程的实现&quot;, 在稍后介绍的实现方式中, 也先把 Java 的技术背景放下, <strong>以一个通用的应用程序的角度来看看线程是如何实现的</strong>.</p> <blockquote><p>实现线程的方式</p></blockquote> <p>实现线程主要有三种方式: <mark><strong>使用内核线程实现(1: 1实现), 使用用户线程实现(1: N 实现), 使用用户线程加轻量级进程混合实现(N: M 实现)</strong></mark> .</p> <h6 id="_1-内核线程实现"><a href="#_1-内核线程实现" class="header-anchor">#</a> (1)内核线程实现</h6> <p>使用内核线程实现的方式也被称为 <code>1: 1</code>​ 实现. <strong>内核线程(Kernel-Level Thread, KLT)就是直接由操作系统内核(Kernel, 下称内核)支持的线程, 这种线程由内核来完成线程切换, 内核通过操纵调度器(Scheduler)对线程进行调度, 并负责将线程的任务映射到各个处理器上</strong>. 每个内核线程可以视为内核的一个分身, 这样操作系统就有能力同时处理多件事情, 支持多线程的内核就称为<strong>多线程内核</strong>(Multi-Threads Kernel).</p> <p><strong>程序一般不会直接使用内核线程</strong>, 而是使用内核线程的一种高级接口---<strong>轻量级进程</strong>(Light Weight Process, LWP), 轻量级进程就是通常意义上所讲的线程, <strong>由于每个轻量级进程都由一个内核线程支持, 因此只有先支持内核线程, 才能有轻量级进程</strong>. 这种轻量级进程与内核线程之间 <code>1: 1</code>​ 的关系称为一对一的线程模型, 如图 12-3 所示.</p> <p><img src="/img/Image00221-20240302133505-jvehu11.jpg" alt="" title="图12-3　轻量级进程与内核线程之间1: 1的关系"></p> <p>由于内核线程的支持, 每个轻量级进程都成为一个独立的调度单元, 即使其中某一个轻量级进程在系统调用中被阻塞了, 也不会影响整个进程继续工作. 轻量级进程也具有它的局限性: <strong>首先, 由于是基于内核线程实现的, 所以各种线程操作, 如创建, 析构及同步, 都需要进行系统调用. 而系统调用的代价相对较高, 需要在用户态(User Mode)和内核态(Kernel Mode)中来回切换. 其次, 每个轻量级进程都需要有一个内核线程的支持, 因此轻量级进程要消耗一定的内核资源(如内核线程的栈空间), 因此一个系统支持轻量级进程的数量是有限的</strong>.</p> <h6 id="_2-用户线程实现"><a href="#_2-用户线程实现" class="header-anchor">#</a> (2)用户线程实现</h6> <p>使用<strong>用户线程</strong>实现的方式被称为 <code>1: N</code>​ 实现. 广义上来讲, 一个线程只要不是内核线程, 都可以认为是用户线程(User Thread, UT)的一种, 因此从这个定义上看, 轻量级进程也属于用户线程, 但轻量级进程的实现始终是建立在内核之上的, 许多操作都要进行系统调用, 因此效率会受到限制, 并不具备通常意义上的用户线程的优点.</p> <p><img src="/img/Image00222-20240302133505-nkgoni7.jpg" alt="" title="图12-4 进程与用户线程之间1: N 的关系"></p> <p>而狭义上的用户线程指的是完全建立在用户空间的线程库上, 系统内核不能感知到用户线程的存在及如何实现的. <strong>用户线程的建立, 同步, 销毁和调度完全在用户态中完成, 不需要内核的帮助</strong>. 如果程序实现得当, 这种线程不需要切换到内核态, 因此操作可以是非常快速且低消耗的, 也能够支持规模更大的线程数量, 部分高性能数据库中的多线程就是由用户线程实现的. 这种<strong>进程与用户线程之间 1: N 的关系称为一对多的线程模型</strong>, 如图 12-4 所示.</p> <p>用户线程的优势在于不需要系统内核支援, 劣势也在于没有系统内核的支援, 所有的线程操作都需要由用户程序自己去处理. 线程的创建, 销毁, 切换和调度都是用户必须考虑的问题, 而且由于操作系统只把处理器资源分配到进程, 那诸如 &quot;阻塞如何处理&quot;, &quot;多处理器系统中如何将线程映射到其他处理器上&quot; 这类问题解决起来将会异常困难, 甚至有些是不可能实现的. 因为使用用户线程实现的程序通常都比较复杂, <strong>除了有明确的需求外(譬如以前在不支持多线程的操作系统中的多线程程序, 需要支持大规模线程数量的应用), 一般的应用程序都不倾向使用用户线程</strong>. Java, Ruby 等语言都曾经使用过用户线程, 最终又都放弃了使用它. 但是近年来许多新的, 以高并发为卖点的编程语言又普遍支持了用户线程, 譬如 Golang, Erlang 等, 使得用户线程的使用率有所回升.</p> <h6 id="_3-混合实现"><a href="#_3-混合实现" class="header-anchor">#</a> (3)混合实现</h6> <p>线程除了依赖内核线程实现和完全由用户程序自己实现之外, 还有一种<strong>将内核线程与用户线程一起使用的实现方式</strong>, 被称为 <code>N: M</code>​ 实现. 在这种混合实现下, 既<strong>存在用户线程, 也存在轻量级进程</strong>. 用户线程还是完全建立在用户空间中, 因此用户线程的创建, 切换, 析构等操作依然廉价, 并且可以支持大规模的用户线程并发. 而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁, 这样可以使用内核提供的线程调度功能及处理器映射, 并且用户线程的系统调用要通过轻量级进程来完成, 这大大降低了整个进程被完全阻塞的风险. 在这种混合模式中, 用户线程与轻量级进程的数量比是不定的, 是 N: M 的关系, 如图 12-5 所示, 这种就是<strong>多对多的线程模型</strong>.</p> <p><img src="/img/Image00223-20240302133505-n4gwhj3.jpg" alt="" title="图12-5　用户线程与轻量级进程之间 M: N 的关系"></p> <p>许多 UNIX 系列的操作系统, 如 Solaris, HP-UX 等都提供了 M: N 的线程模型实现. 在这些操作系统上的应用也相对更容易应用 M: N 的线程模型.</p> <h6 id="_4-java线程的实现"><a href="#_4-java线程的实现" class="header-anchor">#</a> (4)Java线程的实现</h6> <p>Java 线程如何实现并不受 Java 虚拟机规范的约束, 这是一个与具体虚拟机相关的话题. Java 线程在早期的 Classic 虚拟机上(JDK 1.2 以前), 是基于一种被称为 &quot;绿色线程&quot;(Green Threads)的用户线程实现的, 但从 JDK 1.3 起, &quot;主流&quot; 平台上的 &quot;主流&quot; 商用 Java 虚拟机的线程模型普遍都被替换为<strong>基于操作系统原生线程模型</strong>来实现, 即<strong>采用 1: 1 的线程模型</strong>.</p> <p><strong>以 HotSpot 为例, 它的</strong>​<mark><strong>每一个 Java 线程都是直接映射到一个操作系统原生线程</strong></mark>​<strong>来实现的, 而且中间没有额外的间接结构, 所以 HotSpot 自己是不会去干涉线程调度的(可以设置线程优先级给操作系统提供调度建议), 全权交给底下的操作系统去处理, 所以何时冻结或唤醒线程, 该给线程分配多少处理器执行时间, 该把线程安排给哪个处理器核心去执行等, 都是由操作系统完成的, 也都是由操作系统全权决定的.</strong></p> <p>操作系统支持怎样的线程模型, 在很大程度上会影响上面的 Java 虚拟机的线程是怎样映射的, 这一点在不同的平台上很难达成一致, 因此《Java 虚拟机规范》中才不去限定 Java 线程需要使用哪种线程模型来实现. 线程模型只对线程的并发规模和操作成本产生影响, 对 Java 程序的编码和运行过程来说, 这些差异都是完全透明的.</p> <h5 id="_2-java线程调度"><a href="#_2-java线程调度" class="header-anchor">#</a> 2.Java线程调度</h5> <p><strong>线程调度是指系统为线程分配处理器使用权的过程</strong>, 调度主要方式有两种, 分别是<strong>协同式</strong>(Cooperative Threads-Scheduling)线程调度和<strong>抢占式</strong>(Preemptive Threads-Scheduling)线程调度.</p> <p>如果使用协同式调度的多线程系统, 线程的执行时间由线程本身来控制, 线程把自己的工作执行完了之后, 要主动通知系统切换到另外一个线程上去. 协同式多线程的最大好处是实现简单, 而且由于线程要把自己的事情干完后才会进行线程切换, 切换操作对线程自己是可知的, 所以一般没有什么线程同步的问题. Lua 语言中的 &quot;协同例程&quot; 就是这类实现. 它的坏处也很明显: 线程执行时间不可控制, 甚至如果一个线程的代码编写有问题, 一直不告知系统进行线程切换, 那么程序就会一直阻塞在那里. 很久以前的 Windows 3.x 系统就是使用协同式来实现多进程多任务的, 那是相当不稳定的, 只要有一个进程坚持不让出处理器执行时间, 就可能会导致整个系统崩溃.</p> <p>如果使用<strong>抢占式调度的多线程系统, 那么每个线程将由系统来分配执行时间, 线程的切换不由线程本身来决定</strong>. 譬如在 Java 中, 有 <code>Thread::yield()</code>​ 方法可以主动让出执行时间, 但是如果想要主动获取执行时间, 线程本身是没有什么办法的. 在这种实现线程调度的方式下, 线程的执行时间是系统可控的, 也不会有一个线程导致整个进程甚至整个系统阻塞的问题. <mark><strong>Java 使用的线程调度方式就是抢占式调度</strong></mark>. 与前面所说的 Windows 3.x 的例子相对, 在 Windows 9x/NT 内核中就是使用抢占式来实现多进程的, 当一个进程出了问题, 还可以使用任务管理器把这个进程杀掉, 而不至于导致系统崩溃.</p> <p>虽然说 Java 线程调度是系统自动完成的, 但是仍然可以 &quot;建议&quot; 操作系统给某些线程多分配一点执行时间, 另外的一些线程则可以少分配一点, 这项操作是通过设置线程优先级来完成的. Java 语言一共设置了 10 个级别的线程优先级(Thread.MIN_PRIORITY 至 Thread.MAX_PRIORITY). <strong>在两个线程同时处于 Ready 状态时, 优先级越高的线程越容易被系统选择执行</strong>.</p> <p>不过, 线程优先级并不是一项稳定的调节手段, 很显然因为主流虚拟机上的 Java 线程是被映射到系统的原生线程上来实现的, 所以线程调度最终还是由操作系统说了算. 尽管现代的操作系统基本都提供线程优先级的概念, 但是并不见得能与 Java 线程的优先级一一对应, 如 Solaris 中线程有 2147483648(2 的 31 次幂)种优先级, 但 Windows 中就只有七种优先级. 如果操作系统的优先级比 Java 线程优先级更多, 那问题还比较好处理, 中间留出一点空位就是了, 但对于比 Java 线程优先级少的系统, 就不得不出现几个线程优先级对应到同一个操作系统优先级的情况了. 表 12-1 显示了 Java 线程优先级与 Windows 线程优先级之间的对应关系, Windows 平台的虚拟机中使用了除 THREAD_PRIORITY_IDLE 之外的其余 6 种线程优先级, 因此在 Windows 下设置线程优先级为 1 和 2, 3 和 4, 6 和 7, 8 和 9 的效果是完全相同的.</p> <blockquote><p>表12-1 Java 线程优先级与 Windows 线程优先级之间的对应关系</p></blockquote> <p><img src="/img/Image00224-20240302133505-4tvanhr.jpg" alt=""></p> <p><img src="/img/Image00225-20240302133505-4oz7hhl.jpg" alt=""></p> <p>线程优先级并不是一项稳定的调节手段, 这不仅仅体现在某些操作系统上不同的优先级实际会变得相同这一点上, 还有其他情况让我们不能过于依赖线程优先级: <strong>优先级可能会被系统自行改变</strong>, 例如在 Windows 系统中存在一个叫 &quot;优先级推进器&quot; 的功能(Priority Boosting, 当然它可以被关掉), 大致作用是当系统发现一个线程被执行得特别频繁时, 可能会越过线程优先级去为它分配执行时间, 从而减少因为线程频繁切换而带来的性能损耗. 因此, 并不能在程序中通过优先级来完全准确判断一组状态都为 Ready 的线程将会先执行哪一个.</p> <h4 id="java与协程"><a href="#java与协程" class="header-anchor">#</a> Java与协程</h4> <p>在 Java 时代的早期, Java 语言抽象出来隐藏了各种操作系统线程差异性的统一线程接口, 这曾经是它区别于其他编程语言的一大优势. 在此基础上, 涌现过无数多线程的应用与框架, 譬如在网页访问时, HTTP 请求可以直接与 Servlet API 中的一条处理线程绑定在一起, 以 &quot;一对一服务&quot; 的方式处理由浏览器发来的信息. 语言与框架已经自动屏蔽了相当多同步和并发的复杂性, 对于普通开发者而言, 几乎不需要专门针对多线程进行学习训练就能完成一般的并发任务. 时至今日, 这种便捷的并发编程方式和同步的机制依然在有效地运作着, 但是在某些场景下, 却也已经显现出了疲态.</p> <h5 id="_1-内核线程的局限性"><a href="#_1-内核线程的局限性" class="header-anchor">#</a> 1.内核线程的局限性</h5> <p>笔者可以通过一个具体场景来<strong>解释目前 Java 线程面临的困境</strong>. 今天对 Web 应用的服务要求, 不论是在请求数量上还是在复杂度上, 与十多年前相比已不可同日而语, 这一方面是源于业务量的增长, 另一方面来自于为了应对业务复杂化而不断进行的服务细分. 现代 B/S 系统中一次对外部业务请求的响应, 往往需要分布在不同机器上的大量服务共同协作来实现, 这种服务细分的架构在减少单个服务复杂度, 增加复用性的同时, 也不可避免地增加了服务的数量, 缩短了留给每个服务的响应时间. <strong>这要求每一个服务都必须在极短的时间内完成计算, 这样组合多个服务的总耗时才不会太长; 也要求每一个服务提供者都要能同时处理数量更庞大的请求, 这样才不会出现请求由于某个服务被阻塞而出现等待</strong>.</p> <p>Java 目前的并发编程机制就与上述架构趋势产生了一些矛盾, <code>1: 1</code>​ 的内核线程模型是如今 Java 虚拟机线程实现的主流选择, 但是这种<mark><strong>映射到操作系统上的线程天然的缺陷是切换, 调度成本高昂, 系统能容纳的线程数量也很有限</strong></mark>. 以前处理一个请求可以允许花费很长时间在单体应用中, 具有这种线程切换的成本也是无伤大雅的, 但现在在每个请求本身的执行时间变得很短, 数量变得很多的前提下, <strong>用户线程切换的开销甚至可能会接近用于计算本身的开销</strong>, 这就会造成严重的浪费.</p> <p>传统的 Java Web 服务器的<strong>线程池的容量通常在几十个到两百之间</strong>, 当程序员把数以百万计的请求往线程池里面灌时, 系统即使能处理得过来, 但其中的切换损耗也是相当可观的. 现实的需求在迫使 Java 去研究新的解决方案, 同大家又开始怀念以前绿色线程的种种好处, 绿色线程已随着 Classic 虚拟机的消失而被尘封到历史之中, 它还会有重现天日的一天吗?</p> <h5 id="_2-协程的复苏"><a href="#_2-协程的复苏" class="header-anchor">#</a> 2.协程的复苏</h5> <p>经过前面对不同线程实现方式的铺垫介绍, 已经明白了各种线程实现方式的优缺点, 所以多数读者看到 &quot;因为映射到了系统的内核线程中, 所以切换调度成本会比较高昂&quot; 时并不会觉得有什么问题, 但相信还是有一部分治学特别严谨的读者会提问: <strong>为什么内核线程调度切换起来成本就要更高</strong>?</p> <p><mark><strong>内核线程的调度成本主要来自于用户态与核心态之间的状态转换, 而这两种状态转换的开销主要来自于响应中断, 保护和恢复执行现场的成本</strong></mark>. 请读者试想以下场景, 假设发生了这样一次线程切换:</p> <div class="language-ziti1 line-numbers-mode"><pre class="language-text"><code>线程 A -&gt; 系统中断 -&gt; 线程 B
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>处理器要去执行线程 A 的程序代码时, 并不是仅有代码程序就能跑得起来, 程序是数据与代码的组合体, 代码执行时还必须要有<strong>上下文数据</strong>的支撑. 而这里说的 &quot;上下文&quot;, <strong>以程序员的角度来看, 是方法调用过程中的各种局部的变量与资源; 以线程的角度来看, 是方法的调用栈中存储的各类信息; 而以操作系统和硬件的角度来看, 则是存储在内存, 缓存和寄存器中的一个个具体数值</strong>. 物理硬件的各种存储设备和寄存器是被操作系统内所有线程共享的资源, 当中断发生, 从线程 A 切换到线程 B 去执行之前, <strong>操作系统首先要把线程 A 的上下文数据妥善保管好, 然后把寄存器, 内存分页等恢复到线程 B 挂起时候的状态, 这样线程 B 被重新激活后才能仿佛从来没有被挂起过</strong>. 这种保护和恢复现场的工作, 免不了涉及一系列数据在各种寄存器, 缓存中的来回拷贝, 当然不可能是一种轻量级的操作.</p> <p>如果说内核线程的切换开销是来自于保护和恢复现场的成本, 那如果改为采用用户线程, 这部分开销就能够省略掉吗? 答案是 &quot;<strong>不能</strong>&quot;. 但一旦把<strong>保护, 恢复现场及调度的工作从操作系统交到程序员手上</strong>, 那就可以打开脑洞, 通过玩出很多新的花样来缩减这些开销.</p> <p>有一些古老的操作系统(譬如 DOS)是单人单工作业形式的, 天生就不支持多线程, 自然也不会有多个调用栈这样的基础设施. 而早在那样的蛮荒时代, 就已经出现了今天被称为栈纠缠(Stack Twine)的, <strong>由用户自己模拟多线程, 自己保护恢复现场的工作模式</strong>. 其<mark><strong>大致的原理是通过在内存里划出一片额外空间来模拟调用栈, 只要其他 &quot;线程&quot; 中方法压栈, 退栈时遵守规则, 不破坏这片空间即可, 这样多段代码执行时就会像相互缠绕着一样, 非常形象</strong></mark>.</p> <p>到后来, 操作系统开始提供多线程的支持, 靠应用自己模拟多线程的做法自然是变少了许多, 但也并没有完全消失, 而是演化为用户线程继续存在. 由于最初多数的<strong>用户线程是被设计成协同式调度</strong>(Cooperative Scheduling)的, 所以它有了一个别名--&quot;<mark><strong>协程</strong></mark>&quot;(Coroutine). 又由于这时候的<strong>协程会完整地做调用栈的保护, 恢复工作, 所以今天也被称为 &quot;有栈协程&quot;</strong> (Stackfull Coroutine), 起这样的名字是为了便于跟后来的 &quot;无栈协程&quot;(Stackless Coroutine)区分开. 无栈协程不是本节的主角, 不过还是可以简单提一下它的典型应用, 即各种语言中的 await, async, yield 这类关键字. 无栈协程本质上是一种有限状态机, 状态保存在闭包里, 自然比有栈协程恢复调用栈要轻量得多, 但功能也相对更有限.</p> <p><mark><strong>协程的主要优势是轻量, 无论是有栈协程还是无栈协程, 都要比传统内核线程要轻量得多</strong></mark>. 如果进行量化的话, 那么如果不显式设置 <code>-Xss</code>​ 或 <code>-XX: ThreadStackSize</code>​, 则在 64 位 Linux 上 HotSpot 的线程栈容量默认是1MB, 此外内核数据结构(Kernel Data Structures)还会额外消耗 16KB 内存. 与之相对的, 一个协程的栈通常在几百个字节到几 KB 之间, 所以 Java 虚拟机里线程池容量达到两百就已经不算小了, 而很多支持协程的应用中, <strong>同时并存的协程数量可数以十万计</strong>.</p> <p>协程当然也有它的局限, <strong>需要在应用层面实现的内容(调用栈, 调度器这些)特别多</strong>, 这个缺点就不赘述了. 除此之外, 协程在最初, 甚至在今天很多语言和框架中会被设计成协同式调度, 这样在语言运行平台或者框架上的调度器就可以做得非常简单. 不过有不少资料上显示, 既然取了 &quot;协程&quot; 这样的名字, 它们之间就一定以协同调度的方式工作. 笔者并没有查证到这种 &quot;规定&quot; 的出处, 只能说这种提法在今天太过狭隘了, 非协同式, 可自定义调度的协程的例子并不少见, 而协同调度的优点与不足在 12.4.2 节已经介绍过.</p> <p>具体到 Java 语言, 还会有一些别的限制, 譬如 HotSpot 这样的虚拟机, Java 调用栈跟本地调用栈是做在一起的. 如果在协程中调用了本地方法, 还能否正常切换协程而不影响整个线程? 另外, 如果协程中遇传统的线程同步措施会怎样? 譬如 Kotlin 提供的协程实现, 一旦遭遇 synchronize 关键字, 那挂起来的仍将是整个线程.</p> <h5 id="_3-java的解决方案"><a href="#_3-java的解决方案" class="header-anchor">#</a> 3.Java的解决方案</h5> <p>对于有栈协程, 有一种特例实现名为<strong>纤程</strong>(Fiber), 这个词最早是来自微软公司, 后来微软还推出过系统层面的纤程包来方便应用做现场保存, 恢复和纤程调度. OpenJDK 在 2018 年创建了 <strong>Loom 项目</strong>, 这是 Java 用来应对本节开篇所列场景的官方解决方案, 根据目前公开的信息, 如无意外, 日后该项目为 Java 语言引入的, 与现在线程模型平行的新并发编程机制中应该也会采用 &quot;纤程&quot; 这个名字, 不过这显然跟微软是没有任何关系的. 从 Oracle 官方对 &quot;什么是纤程&quot; 的解释里可以看出, 它就<strong>是一种典型的有栈协程</strong>, 如图 12-11 所示.</p> <p><img src="/img/Image00227-20240302133505-6hu407n.jpg" alt="" title="图12-7　JVMLS 2018大会上 Oracle 对纤程的介绍"></p> <p><strong>Loom 项目背后的意图是重新提供对用户线程的支持</strong>, 但与过去的绿色线程不同, 这些新功能不是为了取代当前基于操作系统的线程实现, 而是<strong>会有两个并发编程模型在 Java 虚拟机中并存, 可以在程序中同时使用</strong>. 新模型有意地保持了与目前线程模型相似的 API 设计, 它们甚至可以拥有一个共同的基类, 这样现有的代码就不需要为了使用纤程而进行过多改动, 甚至不需要知道背后采用了哪个并发编程模型. Loom 团队在 JVMLS 2018 大会上公布了他们对 Jetty 基于纤程改造后的测试结果, 同样在 5000QPS 的压力下, 以容量为 400 的线程池的传统模式和每个请求配以一个纤程的新并发处理模式进行对比, 前者的请求响应延迟在 10000 至 20000 毫秒之间, 而后者的延迟普遍在 200 毫秒以下, 具体结果如图 12-8 所示.</p> <p><img src="/img/Image00228-20240302133505-yp5gzgh.jpg" alt="" title="图12-8　Jetty 在新并发模型下的压力测试"></p> <p>在新并发模型下, 一段使用纤程并发的代码会被分为两部分--<strong>执行过程(Continuation)和调度器(Scheduler). 执行过程主要用于维护执行现场, 保护, 恢复上下文状态, 而调度器则负责编排所有要执行的代码的顺序</strong>. 将调度程序与执行过程分离的好处是, 用户可以选择自行控制其中的一个或者多个, 而且 Java 中现有的调度器也可以被直接重用. 事实上, Loom 中默认的调度器就是原来已存在的用于任务分解的 Fork/Join 池(JDK 7 中加入的 ForkJoinPool).</p> <p>Loom 项目目前仍然在进行当中, 还没有明确的发布日期, 上面介绍的内容日后都有被改动的可能. 如果现在就想尝试协程, 那可以在项目中使用 Quasar 协程库, 这是一个不依赖 Java 虚拟机的独立实现的协程库. 不依赖虚拟机来实现协程是完全可能的, Kotlin 语言的协程就已经证明了这一点. Quasar 的实现原理是字节码注入, 在字节码层面对当前被调用函数中的所有局部变量进行保存和恢复. 这种不依赖 Java 虚拟机的现场保护虽然能够工作, 但很影响性能, 对即时编译器的干扰也非常大, 而且必须要求用户手动标注每一个函数是否会在协程上下文被调用, 这些都是未来 Loom 项目要解决的问题.</p> <p>‍</p> <h4 id="本章小结"><a href="#本章小结" class="header-anchor">#</a> 本章小结</h4> <p>本章了解了虚拟机 Java 内存模型的结构及操作, 并且讲解了原子性, 可见性, 有序性在 Java 内存模型中的体现, 介绍了先行发生原则的规则及使用. 另外, 还了解了线程在 Java 语言之中是如何实现的, 以及代表 Java 未来多线程发展的新并发模型的工作原理.</p> <p>关于 &quot;高效并发&quot; 这个话题, 在本章中主要介绍了虚拟机如何实现 &quot;并发&quot;, 在下一章中, 主要关注点将是<strong>虚拟机如何实现 &quot;高效&quot;, 以及虚拟机对编写的并发代码提供了什么样的优化手段</strong>.</p> <p>‍</p> <p>‍</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/20.开发/2000.Java/600.JVM/50.Java内存模型与线程实现🌼.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/1f8f72/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">后端编译与优化🌼</div></a> <a href="/pages/ed086e/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">线程安全与内置锁优化🌼</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/1f8f72/" class="prev">后端编译与优化🌼</a></span> <span class="next"><a href="/pages/ed086e/">线程安全与内置锁优化🌼</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/88.12d88449.js" defer></script>
  </body>
</html>
