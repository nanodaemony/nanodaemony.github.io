<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端编译与优化🌼 | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/86.44ba2100.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/4f30b9/" class="sidebar-link">Java基础</a></li><li><a href="/pages/795eca/" class="sidebar-link">类与继承</a></li><li><a href="/pages/c69152/" class="sidebar-link">抽象类与接口</a></li><li><a href="/pages/d71abb/" class="sidebar-link">内部类</a></li><li><a href="/pages/f06dca/" class="sidebar-link">枚举类</a></li><li><a href="/pages/259f57/" class="sidebar-link">常用类</a></li><li><a href="/pages/84b03b/" class="sidebar-link">关键字</a></li><li><a href="/pages/31b87b/" class="sidebar-link">注解</a></li><li><a href="/pages/f81c0d/" class="sidebar-link">异常</a></li><li><a href="/pages/ae7746/" class="sidebar-link">泛型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>容器类</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/0c88ac/" class="sidebar-link">集合容器类基础</a></li><li><a href="/pages/f805ed/" class="sidebar-link">List与Queue类</a></li><li><a href="/pages/d24b60/" class="sidebar-link">Map与Set类</a></li><li><a href="/pages/54e5d3/" class="sidebar-link">并发容器类</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/67d70f/" class="sidebar-link">多线程基础</a></li><li><a href="/pages/ffc8f7/" class="sidebar-link">Java内置锁</a></li><li><a href="/pages/c43494/" class="sidebar-link">AQS</a></li><li><a href="/pages/eb5b61/" class="sidebar-link">显式锁ReentrantLock</a></li><li><a href="/pages/eb8cbc/" class="sidebar-link">线程协作与JUC组件</a></li><li><a href="/pages/23c79a/" class="sidebar-link">Atomic原子变量与Unsafe类与CAS</a></li><li><a href="/pages/9d6ed4/" class="sidebar-link">线程池与定时任务</a></li><li><a href="/pages/5b787a/" class="sidebar-link">ThreadLocal</a></li><li><a href="/pages/db53d1/" class="sidebar-link">Java并发编程实战(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>IO</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b4d461/" class="sidebar-link">文件操作</a></li><li><a href="/pages/1b9d6c/" class="sidebar-link">IO流操作</a></li><li><a href="/pages/076a47/" class="sidebar-link">Java网络IO模型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>高级特性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d76905/" class="sidebar-link">Lambda表达式</a></li><li><a href="/pages/f7f0e6/" class="sidebar-link">流Stream</a></li><li><a href="/pages/7cc40a/" class="sidebar-link">反射</a></li><li><a href="/pages/945326/" class="sidebar-link">代理</a></li><li><a href="/pages/7fd9b4/" class="sidebar-link">Javaagent</a></li><li><a href="/pages/a3cee0/" class="sidebar-link">Guava</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>JVM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d308f6/" class="sidebar-link">走进JVM🌼</a></li><li><a href="/pages/be0269/" class="sidebar-link">JVM内存区域与对象解析🌼</a></li><li><a href="/pages/48d1be/" class="sidebar-link">垃圾收集器与内存分配策略🌼</a></li><li><a href="/pages/3a4c8a/" class="sidebar-link">JVM性能监控与故障处理工具🌼</a></li><li><a href="/pages/106680/" class="sidebar-link">调优案例分析与实战🌼</a></li><li><a href="/pages/16a914/" class="sidebar-link">类文件结构🌼</a></li><li><a href="/pages/ea287c/" class="sidebar-link">虚拟机类加载机制🌼</a></li><li><a href="/pages/6367b0/" class="sidebar-link">虚拟机字节码执行引擎🌼</a></li><li><a href="/pages/c6c210/" class="sidebar-link">类加载及执行子系统的案例与实战🌼</a></li><li><a href="/pages/deb8b7/" aria-current="page" class="active sidebar-link">前端编译与优化🌼</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/1f8f72/" class="sidebar-link">后端编译与优化🌼</a></li><li><a href="/pages/3d72db/" class="sidebar-link">Java内存模型与线程实现🌼</a></li><li><a href="/pages/ed086e/" class="sidebar-link">线程安全与内置锁优化🌼</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/56b9dd/" class="sidebar-link">Java性能问题定位分析</a></li><li><a href="/pages/939bf8/" class="sidebar-link">杂记</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>开发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>软件设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/a5f6fe/" class="sidebar-link">设计基础理论</a></li><li><a href="/pages/3b245c/" class="sidebar-link">设计模式之美(极客时间)🌟</a></li><li><a href="/pages/661fa4/" class="sidebar-link">领域驱动设计(DDD)</a></li><li><a href="/pages/856368/" class="sidebar-link">DDD实战课(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d3fbd2/" class="sidebar-link">数据库基础</a></li><li><a href="/pages/691fc3/" class="sidebar-link">数据库系统原理</a></li><li><a href="/pages/50f6b7/" class="sidebar-link">MySQL基础必知必会</a></li><li><a href="/pages/fe297e/" class="sidebar-link">MySQL特性</a></li><li><a href="/pages/07bdb6/" class="sidebar-link">MySQL索引🌟</a></li><li><a href="/pages/984715/" class="sidebar-link">MySQL锁🌟</a></li><li><a href="/pages/53b588/" class="sidebar-link">MySQL事务🌟</a></li><li><a href="/pages/becc59/" class="sidebar-link">MySQL高级特性</a></li><li><a href="/pages/056463/" class="sidebar-link">MySQL基础架构与存储引擎🌟</a></li><li><a href="/pages/63b46e/" class="sidebar-link">MySQL架构优化与运维</a></li><li><a href="/pages/9995e5/" class="sidebar-link">MySQL优化</a></li><li><a href="/pages/c1c2f6/" class="sidebar-link">MySQL架构</a></li><li><a href="/pages/8e8e0a/" class="sidebar-link">MySQL设计规范</a></li><li><a href="/pages/0219aa/" class="sidebar-link">MySQL运维</a></li><li><a href="/pages/e288c0/" class="sidebar-link">MySQL中间件</a></li><li><a href="/pages/c6cafa/" class="sidebar-link">MySQL实战45讲(极客时间)🌟</a></li><li><a href="/pages/4a6106/" class="sidebar-link">数据库LeetCode题目</a></li><li><a href="/pages/2827f1/" class="sidebar-link">数据库综合问题</a></li><li><a href="/pages/c616d5/" class="sidebar-link">MongoDB</a></li><li><a href="/pages/075e71/" class="sidebar-link">ClickHouse</a></li><li><a href="/pages/d74f6d/" class="sidebar-link">Doris</a></li><li><a href="/pages/b6bad9/" class="sidebar-link">HBase</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Spring</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bd8eb8/" class="sidebar-link">Spring Boot基础</a></li><li><a href="/pages/d0d797/" class="sidebar-link">Spring Boot应用整合</a></li><li><a href="/pages/314cdc/" class="sidebar-link">Spring MVC基础</a></li><li><a href="/pages/80de47/" class="sidebar-link">Spring AOP基础</a></li><li><a href="/pages/f0d4d6/" class="sidebar-link">Spring事务基础</a></li><li><a href="/pages/db6afe/" class="sidebar-link">Spring IOC源码分析-概览</a></li><li><a href="/pages/672e98/" class="sidebar-link">Spring IOC源码分析-getBean()</a></li><li><a href="/pages/695b90/" class="sidebar-link">Spring IOC源码分析-createBean()</a></li><li><a href="/pages/f89bcf/" class="sidebar-link">Spring AOP源码分析</a></li><li><a href="/pages/3b52f4/" class="sidebar-link">Spring事务源码分析</a></li><li><a href="/pages/186902/" class="sidebar-link">Spring Boot源码分析</a></li><li><a href="/pages/16bd1c/" class="sidebar-link">Spring MVC源码分析</a></li><li><a href="/pages/3d0c1f/" class="sidebar-link">Spring Cloud</a></li><li><a href="/pages/d56156/" class="sidebar-link">Spring编程常见错误50例(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>MyBatis</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bb032d/" class="sidebar-link">基础</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>工具与环境</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c9cb6e/" class="sidebar-link">Arthas</a></li><li><a href="/pages/3172bb/" class="sidebar-link">Maven</a></li><li><a href="/pages/37f79a/" class="sidebar-link">Git</a></li><li><a href="/pages/db9f99/" class="sidebar-link">环境搭建与部署</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c725f5/" class="sidebar-link">测试基础</a></li><li><a href="/pages/7893a4/" class="sidebar-link">单元测试</a></li><li><a href="/pages/af9f25/" class="sidebar-link">压力测试</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>代码质量</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ec2b81/" class="sidebar-link">代码整洁之道</a></li><li><a href="/pages/474cdf/" class="sidebar-link">阿里巴巴编程规范</a></li><li><a href="/pages/c47e15/" class="sidebar-link">代码之丑(极客时间)🌸</a></li><li><a href="/pages/4d4606/" class="sidebar-link">Java业务开发常见错误100例(极客时间)🌸</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/develop/#开发" data-v-06970110>开发</a></li><li data-v-06970110><a href="/develop/#Java" data-v-06970110>Java</a></li><li data-v-06970110><a href="/develop/#JVM" data-v-06970110>JVM</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">前端编译与优化🌼<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_40-前端编译与优化🌼"><a href="#_40-前端编译与优化🌼" class="header-anchor">#</a> 40.前端编译与优化🌼</h1> <p>本节对应《深入理解 Java 虚拟机》的第十章</p> <p>从计算机程序出现的第一天起, 对效率的追逐就是程序员天生的坚定信仰, 这个过程犹如一场没有终点, 永不停歇的  F1 方程式竞赛, 程序员是车手, 技术平台则是在赛道上飞驰的赛车.</p> <h4 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h4> <p>在 Java 技术下谈 &quot;编译期&quot; 而没有具体上下文语境的话, 其实是一句很含糊的表述, 因为它可能是指一个<strong>前端编译器</strong>(叫 &quot;编译器的前端&quot; 更准确一些)把 <code>*.java</code>​ 文件转变成 <code>*.class</code>​ 文件的过程; 也可能是指 Java 虚拟机的<strong>即时编译器</strong>(常称 JIT 编译器, Just In Time Compiler)<strong>运行期把字节码转变成本地机器码的过程</strong>; 还可能是指使用<strong>静态的提前编译器</strong>(常称 AOT 编译器, Ahead Of Time Compiler)<strong>直接把程序编译成与目标机器指令集相关的二进制代码的过程</strong>.</p> <blockquote><p>三类编译过程及其编译器产品</p></blockquote> <p>下面列举了这 3 类编译过程里一些比较有代表性的编译器产品:</p> <ul><li><mark><strong>前端编译器</strong></mark>: JDK 的 <strong>Javac</strong>, Eclipse JDT 中的增量式编译器(ECJ).</li> <li><mark><strong>即时编译器</strong></mark>: HotSpot 虚拟机的 <strong>C1, C2 编译器, Graal 编译器</strong>.</li> <li><mark><strong>提前编译器</strong></mark>: JDK 的 Jaotc, GNU Compiler for the Java(GCJ).</li></ul> <p>这 3 类过程中最符合普通程序员对 Java 程序编译认知的应该是第一类, 本章标题中的 &quot;前端&quot; 指的也是这种由前端编译器完成的编译行为. 在本章后续的讨论里, 提到的全部 &quot;编译期&quot; 和 &quot;编译器&quot; 都仅限于<strong>第一类编译过程</strong>, 所以会把第二, 三类编译过程留到第 11 章中去讨论. 限制了 &quot;<strong>编译期</strong>&quot; 的范围后, 对于 &quot;优化&quot; 二字的定义也需要放宽一些, 因为 <strong>Javac 这类前端编译器对代码的运行效率几乎没有任何优化措施可言</strong>, 哪怕是编译器真的采取了优化措施也不会产生什么实质的效果. 因为 Java 虚拟机设计团队选择把<strong>对性能的优化全部集中到运行期的即时编译器中</strong>, 这样可以让那些不是由 Javac 产生的 Class 文件(如 JRuby, Groovy 等语言的 Class 文件)也同样能享受到编译器优化措施所带来的性能红利. 但是, 如果把 &quot;优化&quot; 的定义放宽, 把对开发阶段的优化也计算进来的话, Javac 确实是做了许多针对 Java 语言编码过程的优化措施来降低程序员的编码复杂度, 提高编码效率. 相当多新生的 Java 语法特性, 都是靠编译器的 &quot;语法糖&quot; 来实现, 而不是依赖字节码或者 Java 虚拟机的底层改进来支持. 可以这样认为, <mark><strong>Java 中即时编译器在运行期的优化过程, 支撑了程序执行效率的不断提升; 而前端编译器在编译期的优化过程, 则是支撑着程序员的编码效率和语言使用者的幸福感的提高</strong></mark>.</p> <h4 id="javac编译器"><a href="#javac编译器" class="header-anchor">#</a> Javac编译器</h4> <p>分析源码是了解一项技术的实现内幕最彻底的手段, Javac 编译器不像 HotSpot 虚拟机那样使用 C++ 语言(包含少量 C 语言)实现, 它本身就是一个<strong>由 Java 语言编写的程序</strong>, 这为了解它的编译过程带来了很大的便利.</p> <h5 id="_1-javac的源码与调试"><a href="#_1-javac的源码与调试" class="header-anchor">#</a> 1.Javac的源码与调试</h5> <p>在 JDK 6 以前, Javac 并不属于标准 Java SE API 的一部分, 它实现代码单独存放在 tools.jar 中, 要在程序中使用的话就必须把这个库放到类路径上. 在 JDK 6 发布时通过了 JSR 199 编译器 API 的提案, 使得 Javac 编译器的实现代码晋升成为标准 Java 类库之一, 它的源码就改为放在 <code>JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac</code>​ 中. 到了 JDK 9 时, 整个 JDK 所有的 Java 类库都采用<strong>模块化</strong>进行重构划分, Javac 编译器就被挪到了 jdk.compiler 模块(路径为: <code>JDK_SRC_HOME/src/jdk.compiler/share/classes/com/sun/tools/javac</code>​)里面. 虽然程序代码的内容基本没有变化, 但由于本节的主题是源码解析, 不可避免地会涉及大量的路径和包名, 这就要选定 JDK 版本来讨论了, 本次将会以 <strong>JDK 9 之前的代码结构</strong>来进行讲解.</p> <p>Javac 编译器除了 JDK 自身的标准类库外, 就只引用了 <code>JDK_SRC_HOME/langtools/src/share/classes/com/sun/*</code>​ 里面的代码, 所以代码编译环境建立时基本无须处理依赖关系, 相当简单便捷. 以 Eclipse IDE 作为开发工具为例, 先建立一个名为 &quot;Compiler_javac&quot; 的 Java 工程, 然后把 <code>JDK_SRC_HOME/langtools/src/share/classes/com/sun/*</code>​ 目录下的源文件全部复制到工程的源码目录中, 如图 10-1 所示.</p> <p><img src="/img/Image00189-20240302133505-1mrlexk.jpg" alt="" title="图10-1　Eclipse 中的 Javac 工程"></p> <p>导入代码期间, 源码文件 &quot;AnnotationProxyMaker.java&quot; 可能会提示 &quot;Access Restriction&quot;, 被 Eclipse 拒绝编译, 如图 10-2 所示.</p> <p><img src="/img/Image00190-20240302133505-kkh7emn.jpg" alt="" title="图10-2　AnnotationProxyMaker 被拒绝编译"></p> <p>这是由于 Eclipse 为了避免开发人员引用非标准 Java 类库可能导致的兼容性问题, 在 &quot;JRE System Library&quot; 设置中默认包含了一系列的代码访问规则(Access Rules), 如果代码中引用了这些访问规则所禁止引用的类, 就会提示这个错误. 可以通过添加一条允许访问 JAR 包中所有类的访问规则来解决该问题, 如图 10-3 所示.</p> <p><img src="/img/Image00191-20240302133505-j51t1uf.jpg" alt="" title="图10-3　设置访问规则"></p> <p>导入了 Javac 的源码后, 就可以运行 com.sun.tools.javac.Main 的 main() 方法来执行编译了, 可以使用的参数与命令行中使用的 Javac 命令没有任何区别, 编译的文件与参数在 Eclipse 的 &quot;Debug Configurations&quot; 面板中的 &quot;Arguments&quot; 页签中指定.</p> <p>《Java 虚拟机规范》中严格定义了 Class 文件格式的各种细节, 可是对如何把 Java 源码编译为 Class 文件却描述得相当宽松. 规范里尽管有专门的一章名为 &quot;Compiling for the Java Virtual Machine&quot;, 但这章也仅仅是以举例的形式来介绍怎样的 Java 代码应该被转换为怎样的字节码, 并没有使用编译原理中常用的描述工具(如文法, 生成式等)来对 Java 源码编译过程加以约束. 这是给了 Java 前端编译器较大的实现灵活性, 但也导致 <strong>Class 文件编译过程在某种程度上是与具体的 JDK 或编译器实现相关的</strong>, 譬如在一些极端情况下, 可能会出现某些代码在 Javac 编译器可以编译, 但是 ECJ 编译器就不可以编译的问题(反过来也有可能, 后文中将会给出一些这样的例子).</p> <p>从 Javac 代码的总体结构来看, <strong>编译过程大致可以分为 1 个准备过程和 3 个处理过程</strong>, 它们分别如下所示.</p> <p>(1) <strong>准备过程</strong>: 初始化插入式注解处理器.</p> <p>(2) <strong>解析与填充符号表过程</strong>, 包括:</p> <ul><li><strong>词法, 语法分析</strong>. 将源代码的字符流转变为标记集合, 构造出抽象语法树.</li> <li><strong>填充符号表</strong>. 产生符号地址和符号信息.</li></ul> <p>(3) <strong>插入式注解处理器的注解处理过程</strong>: 插入式注解处理器的执行阶段, 本章的实战部分会设计一个插入式注解处理器来影响 Javac 的编译行为.</p> <p>(4) <strong>分析与字节码生成过程</strong>, 包括:</p> <ul><li>标注检查. 对语法的静态信息进行检查.</li> <li><strong>数据流及控制流分析</strong>. 对程序动态运行过程进行检查.</li> <li><strong>解语法糖</strong>. 将简化代码编写的语法糖还原为原有的形式.</li> <li><strong>字节码生成</strong>. 将前面各个步骤所生成的信息转化成字节码.</li></ul> <p>上述 3 个处理过程里, 执行插入式注解时又可能会产生新的符号, <strong>如果有新的符号产生, 就必须转回到之前的解析</strong>, 填充符号表的过程中重新处理这些新符号, 从总体来看, 三者之间的关系与交互顺序如图 10-4 所示. 因此, Javac 编译器的<strong>编译过程</strong>大致可分为 3 个步骤.</p> <p><img src="/img/Image00192-20240302133505-ya1nv52.jpg" alt="" title="图10-4　Javac 的编译过程"></p> <p>可以把上述处理过程对应到代码中, Javac 编译动作的入口是 com.sun.tools.javac.main.<strong>JavaCompiler</strong> 类, 上述 3 个过程的代码逻辑集中在这个类的 compile() 和 compile2() 方法里, 其中主体代码如图 10-5 所示, 整个编译过程主要的处理由图中标注的 8 个方法来完成.</p> <p><img src="/img/Image00193-20240302133505-4pu79e0.jpg" alt="" title="图10-5　Javac 编译过程的主体代码"></p> <p>接下来, 将对照 Javac 的源代码, 逐项讲解上述过程. 下面就介绍的是<mark><strong>进行 Java 编译到生成 class 文件整个流程会发生什么</strong></mark>.</p> <h5 id="_2-解析与填充符号表"><a href="#_2-解析与填充符号表" class="header-anchor">#</a> 2.解析与填充符号表</h5> <p>解析过程由图 10-5 中的 parseFiles() 方法(图 10-5 中的过程 1.1)来完成, <strong>解析过程包括了经典程序编译原理中的词法分析和语法分析两个步骤</strong>.</p> <h6 id="_1-词法和语法分析"><a href="#_1-词法和语法分析" class="header-anchor">#</a> (1)词法和语法分析</h6> <p><strong>词法分析是将源代码的字符流转变为标记(Token)集合的过程</strong>, 单个字符是程序编写时的最小元素, 但标记才是编译时的最小元素. 关键字, 变量名, 字面量, 运算符都可以作为标记, 如 &quot;<code>int a = b + 2</code>​&quot; 这句代码中就包含了 6 个标记, 分别是 int, a, =, b, +, 2, 虽然关键字 int 由 3 个字符构成, 但是它只是一个独立的标记, 不可以再拆分. 在 Javac 的源码中, 词法分析过程由 <code>com.sun.tools.javac.parser.Scanner</code>​ 类来实现.</p> <p><strong>语法分析是根据标记序列构造抽象语法树的过程</strong>, 抽象语法树(Abstract Syntax Tree, AST)是一种用来描述程序代码语法结构的树形表示方式, 抽象语法树的每一个节点都代表着程序代码中的一个语法结构(Syntax Construct), 例如包, 类型, 修饰符, 运算符, 接口, 返回值甚至连代码注释等都可以是一种特定的语法结构.</p> <p>图 10-6 是 Eclipse AST View 插件分析出来的某段代码的抽象语法树视图. 在 Javac 的源码中, 语法分析过程由 com.sun.tools.javac.parser.<strong>Parser</strong> 类实现, 这个阶段产出的抽象语法树是以 com.sun.tools.javac.tree.<strong>JCTree</strong> 类表示的.</p> <p>经过词法和语法分析生成语法树以后, 编译器就不会再对源码字符流进行操作了, 后续的操作都建立在<strong>抽象语法树</strong>之上.</p> <p><img src="/img/Image00194-20240302133505-as0ephs.jpg" alt="" title="图10-6　抽象语法树结构视图"></p> <h6 id="_2-填充符号表"><a href="#_2-填充符号表" class="header-anchor">#</a> (2)填充符号表</h6> <p>完成了语法分析和词法分析之后, 下一个阶段是<strong>对符号表进行填充的过程</strong>, 也就是图 10-5 中 <strong>enterTrees()</strong>  方法(图 10-5 中注释的过程 1.2)要做的事情. <strong>符号表(Symbol Table)是由一组符号地址和符号信息构成的数据结构, 可以把它类比想象成哈希表中键值对的存储形式(实际上符号表不一定是哈希表实现, 可以是有序符号表, 树状符号表, 栈结构符号表等各种形式)</strong> . 符号表中所登记的信息在编译的不同阶段都要被用到. 譬如在语义分析的过程中, 符号表所登记的内容将用于语义检查(如检查一个名字的使用和原先的声明是否一致)和产生中间代码, 在目标代码生成阶段, 当对符号名进行地址分配时, 符号表是地址分配的直接依据.</p> <p>在 Javac 源代码中, 填充符号表的过程由 <code>com.sun.tools.javac.comp.Enter</code>​ 类实现, 该过程的产出物是一个待处理列表, 其中包含了每一个编译单元的抽象语法树的顶级节点, 以及 packageinfo.java(如果存在的话)的顶级节点.</p> <h5 id="_3-注解处理器"><a href="#_3-注解处理器" class="header-anchor">#</a> 3.注解处理器</h5> <p>JDK 5 之后, Java 语言提供了对<strong>注解</strong>(Annotations)的支持, 注解在设计上原本是与普通的 Java 代码一样, 都只会在程序运行期间发挥作用的. 但在 JDK 6 中又提出并通过了 JSR-269 提案, 该提案设计了一组被称为 &quot;插入式注解处理器&quot; 的标准 API, 可以提前至编译期对代码中的特定注解进行处理, 从而影响到前端编译器的工作过程. <strong>可以把插入式注解处理器看作是一组编译器的插件, 当这些插件工作时, 允许读取, 修改, 添加抽象语法树中的任意元素</strong>. 如果这些插件在处理注解期间对语法树进行过修改, 编译器将回到解析及填充符号表的过程重新处理, 直到所有插入式注解处理器都没有再对语法树进行修改为止, 每一次循环过程称为一个轮次(Round), 这也就对应着图 10-4 的那个回环过程.</p> <p><strong>有了编译器注解处理的标准 API 后, 程序员的代码才有可能干涉编译器的行为, 由于语法树中的任意元素, 甚至包括代码注释都可以在插件中被访问到, 所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间. 只要有足够的创意, 程序员能使用插入式注解处理器来实现许多原本只能在编码中由人工完成的事情</strong>. 譬如 Java 著名的编码效率工具 Lombok, 它可以<strong>通过注解来实现自动产生 getter/setter 方法, 进行空置检查, 生成受查异常表, 产生 equals() 和 hashCode() 方法</strong>, 等等, 帮助开发人员消除 Java 的冗长代码, 这些都是依赖插入式注解处理器来实现的, 本章最后会设计一个如何使用插入式注解处理器的简单实战.</p> <p>在 Javac 源码中, 插入式注解处理器的初始化过程是在 initPorcessAnnotations() 方法中完成的, 而它的执行过程则是在 processAnnotations() 方法中完成. 这个方法会判断是否还有新的注解处理器需要执行, 如果有的话, 通过 com.sun.tools.javac.processing.JavacProcessingEnvironment 类的 doProcessing() 方法来生成一个新的 JavaCompiler 对象, 对编译的后续步骤进行处理.</p> <h5 id="_4-语义分析与字节码生成"><a href="#_4-语义分析与字节码生成" class="header-anchor">#</a> 4.语义分析与字节码生成</h5> <p>经过语法分析之后, 编译器获得了程序代码的抽象语法树表示, 抽象语法树能够表示一个结构正确的源程序, 但<strong>无法保证源程序的语义是符合逻辑的</strong>. 而<strong>语义分析的主要任务则是对结构上正确的源程序进行上下文相关性质的检查</strong>, 譬如进行类型检查, 控制流检查, 数据流检查, 等等. 举个简单的例子, 假设有如下 3 个变量定义语句:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> b <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>后续可能出现的赋值运算:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> d <span class="token operator">=</span> a <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token keyword">int</span> d <span class="token operator">=</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token keyword">char</span> d <span class="token operator">=</span> a <span class="token operator">+</span> c<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>后续代码中如果出现了如上 3 种赋值运算的话, 那它们都能构成结构正确的抽象语法树, 但是只有第一种的写法在语义上是没有错误的, 能够通过检查和编译. 其余两种在 Java 语言中是不合逻辑的, 无法编译(是否合乎语义逻辑必须限定在具体的语言与具体的上下文环境之中才有意义. 如在 C 语言中, a, b, c 的上下文定义不变, 第二, 三种写法都是可以被正确编译的). 大家编码时经常能<strong>在 IDE 中看到由红线标注的错误提示, 其中绝大部分都是来源于语义分析阶段的检查结果</strong>.</p> <h6 id="_1-标注检查"><a href="#_1-标注检查" class="header-anchor">#</a> (1)标注检查</h6> <p>Javac 在编译过程中, 语义分析过程可分为<strong>标注检查和数据及控制流分析</strong>两个步骤, 分别由图 10-5 的 attribute() 和 flow() 方法(分别对应图 10-5 中的过程 3.1 和过程 3.2)完成.</p> <p><strong>标注检查步骤要检查的内容包括诸如变量使用前是否已被声明, 变量与赋值之间的数据类型是否能够匹配</strong>, 等等, 刚才 3 个变量定义的例子就属于标注检查的处理范畴. 在标注检查中, 还会顺便进行一个称为常量折叠(Constant Folding)的代码优化, 这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行). 如果在 Java 代码中写下如下所示的变量定义:</p> <p><img src="/img/Image00195-20240302133505-rch85ey.jpg" alt="" title="图10-7　常量折叠"></p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>则在抽象语法树上仍然能看到字面量 &quot;1&quot;, &quot;2&quot; 和操作符 &quot;+&quot; 号, 但是在经过常量折叠优化之后, 它们将会被<strong>折叠</strong>为字面量 &quot;3&quot;, 如图 10-7 所示, 这个插入式表达式(Infix Expression)的值已经在语法树上标注出来了(ConstantExpressionValue: 3). 由于编译期间进行了常量折叠, 所以在代码里面定义 &quot;a = 1 + 2&quot; 比起直接定义 &quot;a = 3&quot; 来, 并不会增加程序运行期哪怕仅仅一个处理器时钟周期的处理工作量.</p> <p>标注检查步骤在 Javac 源码中的实现类是 com.sun.tools.javac.comp.Attr 类和 com.sun.tools.javac.comp.Check 类.</p> <h6 id="_2-数据及控制流分析"><a href="#_2-数据及控制流分析" class="header-anchor">#</a> (2)数据及控制流分析</h6> <p><strong>数据流分析和控制流分析是对程序上下文逻辑更进一步的验证, 它可以检查出诸如程序局部变量在使用前是否有赋值, 方法的每条路径是否都有返回值, 是否所有的受查异常都被正确处理了等问题</strong>. 编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上可以看作是一致的, 但校验范围会有所区别, 有一些校验项只有在编译期或运行期才能进行. 下面举一个关于 final 修饰符的数据及控制流分析的例子, 见代码清单 10-1 所示.</p> <blockquote><p>代码清单10-1 final语义校验示例</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 方法一带有 final 修饰</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token keyword">var</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// do something</span>
<span class="token punctuation">}</span>

<span class="token comment">// 方法二没有 final 修饰</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token keyword">var</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// do something</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在这两个 foo() 方法中, 一个方法的参数和局部变量定义使用了 final 修饰符, 另外一个则没有, 在代码编写时程序肯定会受到 final 修饰符的影响, 不能再改变 arg 和 var 变量的值, 但是如果观察这两段代码编译出来的字节码, 会发现它们是没有任何一点区别的, 每条指令, 甚至每个字节都一模一样. 通过第 6 章对 Class 文件结构的讲解已经知道, 局部变量与类的字段(实例变量, 类变量)的存储是有显著差别的, 局部变量在常量池中并没有 CONSTANT_Fieldref_info 的符号引用, 自然就不可能存储有访问标志(access_flags)的信息, 甚至可能连变量名称都不一定会被保留下来(这取决于编译时的编译器的参数选项), 自然在 Class 文件中就不可能知道一个局部变量是不是被声明为 final 了. 因此, <strong>可以肯定地推断出把局部变量声明为 final, 对运行期是完全没有影响的</strong>, 变量的不变性仅仅由 Javac 编译器在编译期间来保障, 这就是一个只能在编译期而不能在运行期中检查的例子. 在 Javac 的源码中, 数据及控制流分析的入口是图 10-5 中的 flow() 方法(图 10-5 中的过程 3.2), 具体操作由 com.sun.tools.javac.comp.Flow 类来完成.</p> <h6 id="_3-解语法糖"><a href="#_3-解语法糖" class="header-anchor">#</a> (3)解语法糖</h6> <p><strong>语法糖</strong>(Syntactic Sugar) 指的是在计算机语言中添加的某种语法, 这种语法对语言的编译结果和功能并没有实际影响, 但是却能<strong>更方便程序员使用该语言</strong>. 通常来说使用语法糖能够减少代码量, 增加程序的可读性, 从而减少程序代码出错的机会.</p> <p>Java 中最常见的语法糖包括了前面提到过的泛型(其他语言中泛型并不一定都是语法糖实现, 如 <code>C#</code>​ 的泛型就是直接由 CLR 支持的), 变长参数, 自动装箱拆箱, 等等, <mark><strong>Java 虚拟机运行时并不直接支持这些语法, 它们在编译阶段被还原回原始的基础语法结构, 这个过程就称为解语法糖</strong></mark>. Java 的这些语法糖是如何实现的, 被分解后会是什么样子, 都将在(Java语法糖)中详细讲述.</p> <p>在 Javac 的源码中, 解语法糖的过程由 <strong>desugar()</strong>  方法触发, 在 com.sun.tools.javac.comp.TransTypes 类和 com.sun.tools.javac.comp.Lower 类中完成.</p> <h6 id="_4-字节码生成"><a href="#_4-字节码生成" class="header-anchor">#</a> (4)字节码生成</h6> <p>字节码生成是 Javac 编译过程的最后一个阶段, 在 Javac 源码里面由 com.sun.tools.javac.jvm.<strong>Gen</strong> 类来完成. <strong>字节码生成阶段不仅仅是把前面各个步骤所生成的信息(语法树, 符号表)转化成字节码指令写到磁盘中, 编译器还进行了少量的代码添加和转换工作</strong>.</p> <p>例如前文多次登场的实例构造器 <code>&lt;init&gt;()</code>​ 方法和类构造器 <code>&lt;clinit&gt;()</code>​ 方法就是在这个阶段被<strong>添加到语法树</strong>之中的. 请注意这里的实例构造器并不等同于默认构造函数, 如果用户代码中没有提供任何构造函数, 那编译器将会<strong>添加一个没有参数的, 可访问性</strong>(<code>public, protected, private 或 &lt;package&gt;</code>​)与当前类型一致的<strong>默认构造函数</strong>, 这个工作在填充符号表阶段中就已经完成. <code>&lt;init&gt;()</code>​ 和 <code>&lt;clinit&gt;()</code>​ 这两个构造器的产生实际上是一种代码收敛的过程, 编译器会把语句块(对于实例构造器而言是 &quot;<code>{}</code>​&quot; 块, 对于类构造器而言是 &quot;<code>static{}</code>​&quot; 块), 变量初始化(实例变量和类变量), 调用父类的实例构造器(仅仅是实例构造器, <code>&lt;clinit&gt;()</code>​ 方法中无须调用父类的 <code>&lt;clinit&gt;()</code>​ 方法, Java 虚拟机会自动保证父类构造器的正确执行, 但在 <code>&lt;clinit&gt;()</code>​ 方法中经常会生成调用 java.lang.Object 的 <code>&lt;init&gt;()</code>​ 方法的代码)等操作收敛到 <code>&lt;init&gt;()</code>​ 和 <code>&lt;clinit&gt;()</code>​ 方法之中, 并且保证无论源码中出现的顺序如何, 都一定是按先执行父类的实例构造器, 然后初始化变量, 最后执行语句块的顺序进行, 上面所述的动作由 <code>Gen::normalizeDefs()</code>​ 方法来实现. 除了生成构造器以外, 还有其他的一些代码替换工作用于优化程序某些逻辑的实现方式, 如把字符串的加操作替换为 StringBuffer 或 StringBuilder(取决于目标代码的版本是否大于或等于 JDK 5)的 append() 操作, 等等.</p> <p>完成了对语法树的遍历和调整之后, 就会把填充了所有所需信息的符号表交到 com.sun.tools.javac.jvm.ClassWriter 类手上, 由这个类的 <strong>writeClass() 方法输出字节码, 生成最终的 Class 文件, 到此整个编译过程宣告结束</strong>.</p> <h4 id="java语法糖的味道"><a href="#java语法糖的味道" class="header-anchor">#</a> Java语法糖的味道</h4> <p>几乎所有的编程语言都或多或少提供过一些语法糖来方便程序员的代码开发, 这些语法糖虽然不会提供实质性的功能改进, 但是它们或能<strong>提高效率, 或能提升语法的严谨性, 或能减少编码出错的机会</strong>. 现在也有一种观点认为语法糖并不一定都是有益的, 大量添加和使用含糖的语法, 容易让程序员产生依赖, 无法看清语法糖的糖衣背后, 程序代码的真实面目. 语法糖是 javac 编译器提供的.</p> <p>总而言之, <strong>语法糖可以看作是前端编译器实现的一些 &quot;小把戏&quot;, 这些 &quot;小把戏&quot; 可能会使效率得到 &quot;大提升&quot;</strong> , 但也应该去了解这些 &quot;小把戏&quot; 背后的真实面貌, 那样才能利用好它们, 而不是被它们所迷惑.</p> <h5 id="_1-泛型"><a href="#_1-泛型" class="header-anchor">#</a> 1.泛型</h5> <p>泛型的本质是<strong>参数化类型</strong>(Parameterized Type)或者<strong>参数化多态</strong>(Parametric Polymorphism)的应用, 即可以将操作的数据类型指定为方法签名中的一种特殊参数, 这种参数类型能够用在类, 接口和方法的创建中, 分别构成<strong>泛型类, 泛型接口和泛型方法</strong>. 泛型让程序员能够针对泛化的数据类型编写相同的算法, 这极大地增强了编程语言的类型系统及抽象能力.</p> <h6 id="_1-java与c-的泛型"><a href="#_1-java与c-的泛型" class="header-anchor">#</a> (1)Java与C#的泛型</h6> <p>Java 选择的泛型实现方式叫作 &quot;<strong>类型擦除式泛型</strong>&quot; (Type Erasure Generics), <strong>它只在程序源码中存在, 在编译后的字节码文件中, 全部泛型都被替换为原来的裸类型(Raw Type, 稍后会讲解裸类型具体是什么)了, 并且在相应的地方插入了强制转型代码</strong>, 因此对于<strong>运行期</strong>的 Java 语言来说, <code>ArrayList&lt;int&gt;</code>​ 与 <code>ArrayList&lt;String&gt;</code>​ 其实是同一个类型, 由此可以想象 &quot;类型擦除&quot; 这个名字的含义和来源, 这也是为什么会把 Java 泛型安排在语法糖里介绍的原因.</p> <p>Java 的泛型确实在实际使用中会有一些限制, 如果读者是一名 C# 开发人员, 可能很难想象代码清单 10-2 中的 Java 代码都是不合法的.</p> <blockquote><p>代码清单10-2 Java中不支持的泛型用法</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TypeErasureGenerics</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token class-name">Object</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token keyword">instanceof</span> <span class="token class-name">E</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 不合法, 无法对泛型进行实例判断</span>
            <span class="token comment">// ...</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">E</span> newItem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">E</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 不合法, 无法使用泛型创建对象</span>
        <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> itemArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 不合法, 无法使用泛型创建数组</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>上面这些是 Java 泛型在编码阶段产生的不良影响, 如果说这种使用层次上的差别还可以通过多写几行代码, 方法中多加一两个类型参数来解决的话, 性能上的差距则是难以用编码弥补的. <code>C#2.0</code>​ 引入了泛型之后, 带来的显著优势之一便是对比起 Java 在执行性能上的提高, 因为在使用平台提供的容器类型(如 <code>List&lt;T&gt;, Dictionary&lt;TKey, TValue&gt;</code>​)时, 无须像 Java 里那样不厌其烦地拆箱和装箱, 如果在 Java 中要避免这种损失, 就必须构造一个与数据类型相关的容器类(譬如 IntFloatHashMap 这样的容器). 显然, 这除了引入更多代码造成复杂度提高, 复用性降低之外, 更是丧失了泛型本身的存在价值.</p> <p>Java 的类型擦除式泛型无论在使用效果上还是运行效率上, 几乎是全面落后于 <code>C#</code>​ 的具现化式泛型, 而它的唯一优势是在于实现这种泛型的影响范围上: 擦除式泛型的实现几乎只需要在 Javac 编译器上做出改进即可, 不需要改动字节码, 不需要改动 Java 虚拟机, 也保证了以前没有使用泛型的库可以直接运行在 Java 5.0 之上. 但这种听起来节省工作量甚至可以说是有偷工减料嫌疑的优势就显得非常短视, 真的能在当年 Java 实现泛型的利弊权衡中胜出吗? 答案的确是它胜出了, 但必须在那时的泛型历史背景中去考虑不同实现方式带来的代价.</p> <h6 id="_2-泛型的历史背景"><a href="#_2-泛型的历史背景" class="header-anchor">#</a> (2)泛型的历史背景</h6> <p>泛型思想早在 C++ 语言的模板(Template)功能中就开始生根发芽, 而在 Java 中加入泛型的首次尝试是出现在 1996 年. Martin Odersky(后来 Scala 语言的缔造者)当时是德国卡尔斯鲁厄大学编程理论的教授, 他想设计一门能够支持函数式编程的程序语言, 又不想从头把编程语言的所有功能都再做一遍, 所以就注意到了刚刚发布一年的 Java, 并在它上面实现了函数式编程的 3 大特性: 泛型, 高阶函数和模式匹配, 形成了 Scala 语言的前身 Pizza 语言.</p> <p>举个例子, 在没有泛型的时代, 由于 Java 中的数组是支持协变(Covariant)的, 对应的集合类也可以存入不同类型的元素, 类似于代码清单 10-3 这样的代码尽管不提倡, 但是完全可以正常编译成 Class 文件.</p> <blockquote><p>代码清单10-3 以下代码可正常编译为Class</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>                     <span class="token comment">// 编译期不会有问题, 运行时会报错</span>

<span class="token class-name">ArrayList</span> things <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
things<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 编译, 运行时都不会报错</span>
things<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>为了保证这些编译出来的 Class 文件可以在 Java 5.0 引入泛型之后继续运行, 设计者面前大体上有两条路可以选择:</p> <p>(1) <strong>需要泛型化的类型(主要是容器类型), 以前有的就保持不变, 然后平行地加一套泛型化版本的新类型</strong>.</p> <p>(2) <strong>直接把已有的类型泛型化, 即让所有需要泛型化的已有类型都原地泛型化, 不添加任何平行于已有类型的泛型版</strong>.</p> <p>在这个分叉路口, <code>C#</code>​ 走了第一条路, 添加了一组 System.Collections.Generic 的新容器, 以前的 System.Collections 以及 System.Collections.Specialized 容器类型继续存在. <code>C#</code>​ 的开发人员很快就接受了新的容器, 倒也没出现过什么不适应的问题, 唯一的不适大概是许多 <code>.NET</code>​ 自身的标准库已经把老容器类型当作方法的返回值或者参数使用, 这些方法至今还保持着原来的老样子.</p> <p>但如果相同的选择出现在 Java 中就很可能不会是相同的结果了, 要知道当时 <code>.NET</code>​ 才问世两年, 而 Java 已经有快十年的历史了, 再加上各自流行程度的不同, 两者遗留代码的规模根本不在同一个数量级上. 而且更大的问题是 Java 并不是没有做过第一条路那样的技术决策, 在 JDK 1.2 时, 遗留代码规模尚小, Java 就引入过新的集合类, 并且保留了旧集合类不动. 这导致了直到现在标准类库中还有 Vector(老)和 ArrayList(新), 有 Hashtable(老)和 HashMap(新)等两套容器代码并存, 如果当时再摆弄出像 Vector(老), ArrayList(新), <code>Vector&lt;T&gt;</code>​(老但有泛型), <code>ArrayList&lt;T&gt;</code>​(新且有泛型)这样的容器集合, 可能叫骂声会比今天听到的更响更大.</p> <p>到了这里, 相信读者已经能稍微理解为什么当时 Java 只能选择第二条路了. 下面就来看看当时做的类型擦除式泛型的实现时到底哪里偷懒了, 又带来了怎样的缺陷.</p> <h6 id="_3-类型擦除"><a href="#_3-类型擦除" class="header-anchor">#</a> (3)类型擦除</h6> <p>继续以 ArrayList 为例来介绍 Java 泛型的<strong>类型擦除具体是如何实现的</strong>. 由于 Java 选择了第二条路, 直接<strong>把已有的类型泛型化</strong>. 要让所有需要泛型化的已有类型, 譬如 ArrayList, 原地泛型化后变成了 <code>ArrayList&lt;T&gt;</code>​, 而且保证以前直接用 ArrayList 的代码在泛型新版本里必须还能继续用这同一个容器, 这就必须让所有泛型化的实例类型, 譬如 <code>ArrayList&lt;Integer&gt;, ArrayList&lt;String&gt;</code>​ 这些全部自动成为 ArrayList 的子类型才能可以, 否则类型转换就是不安全的. 由此就引出了 &quot;裸类型&quot;(Raw Type)的概念, <strong>裸类型应被视为所有该类型泛型化实例的共同父类型(Super Type)</strong> , 只有这样, 像代码清单 10-4 中的赋值才是被系统允许的从子类到父类的安全转型.</p> <blockquote><p>代码清单10-4 裸类型赋值</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> ilist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> slist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ArrayList</span> list<span class="token punctuation">;</span> <span class="token comment">// 裸类型</span>
list <span class="token operator">=</span> ilist<span class="token punctuation">;</span>
list <span class="token operator">=</span> slist<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>接下来的问题是该<strong>如何实现裸类型</strong>. 这里又有了两种选择: 一种是在运行期由 Java 虚拟机来自动地, 真实地构造出 <code>ArrayList&lt;Integer&gt;</code>​ 这样的类型, 并且自动实现从 <code>ArrayList&lt;Integer&gt;</code>​ 派生自 ArrayList 的继承关系来满足裸类型的定义; 另外一种是索性简单粗暴地直接在编译时把 <code>ArrayList&lt;Integer&gt;</code>​ 还原回 ArrayList, 只在元素访问, 修改时自动插入一些强制类型转换和检查指令, 这样看起来也是能满足需要, 这两个选择的最终结果大家已经都知道了. 代码清单 10-5 是一段简单的 Java 泛型例子, 可以看一下它<strong>编译后</strong>的实际样子是怎样的.</p> <blockquote><p>代码清单10-5 泛型擦除前的例子</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;你好&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;how are you?&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;吃了没? &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;how are you?&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>把这段 Java 代码编译成 Class 文件, 然后再用字节码反编译工具进行反编译后, 将会发现<strong>泛型都不见了</strong>, 程序又变回了 Java 泛型出现之前的写法, <strong>泛型类型都变回了裸类型</strong>, 只在元素访问时插入了从 Object 到 String 的<strong>强制转型代码</strong>, 如代码清单 10-6 所示.</p> <blockquote><p>代码清单10-6 泛型擦除后的例子</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Map</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;你好&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;how are you?&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;吃了没? &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 强制类型转换</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;how are you?&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>类型擦除带来的缺陷前面已经提到过一些, 为了系统性地讲述, 在此再举 3 个例子, 把前面与 <code>C#</code>​ 对比时简要提及的擦除式泛型的缺陷做更具体的说明.</p> <p>首先, 使用擦除法实现泛型直接导致了对原始类型(Primitive Types)数据的支持又成了新的麻烦, 譬如将代码清单 10-2 稍微修改一下, 变成代码清单 10-7 这个样子.</p> <blockquote><p>代码清单10-7 原始类型的泛型(目前的Java不支持)</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span> ilist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">long</span><span class="token punctuation">&gt;</span></span> llist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">long</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ArrayList</span> list<span class="token punctuation">;</span>
list <span class="token operator">=</span> ilist<span class="token punctuation">;</span>
list <span class="token operator">=</span> llist<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这种情况下, 一旦把泛型信息擦除后, 到要插入强制转型代码的地方就没办法往下做了, 因为不支持 int, long 与 Object 之间的强制转型. 当时 Java 给出的解决方案一如既往的简单粗暴: 既然没法转换那就索性<strong>别支持原生类型的泛型</strong>了吧, 大家都用 <code>ArrayList&lt;Integer&gt;, ArrayList&lt;Long&gt;</code>​, 反正都做了自动的强制类型转换, 遇到原生类型时把装箱, 拆箱也自动做了得了. 这个决定后面导致了<strong>无数构造包装类和装箱, 拆箱的开销</strong>, 成为 Java 泛型慢的重要原因, 也成为今天 Valhalla 项目要重点解决的问题之一.</p> <p>第二, <strong>运行期无法取到泛型类型信息, 会让一些代码变得相当啰嗦</strong>, 譬如代码清单 10-2 中罗列的几种 Java 不支持的泛型用法, 都是由于<strong>运行期 Java 虚拟机无法取得泛型类型而导致</strong>的. 像代码清单 10-8 这样, 去写一个泛型版本的从 List 到数组的转换方法, 由于不能从 List 中取得参数化类型 T, 所以不得不从一个额外参数中再传入一个数组的组件类型进去, 实属无奈.</p> <blockquote><p>代码清单10-8 不得不加入的类型参数</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">convert</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> componentType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token class-name">Array</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>componentType<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>最后, 笔者认为通过擦除法来实现泛型, 还<strong>丧失了一些面向对象思想应有的优雅</strong>, 带来了一些模棱两可的模糊状况, 例如代码清单 10-9 的例子.</p> <blockquote><p>代码清单10-9 当泛型遇见重载1</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTypes</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;invoke method(List&lt;String&gt; list)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;invoke method(List&lt;Integer&gt; list)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>思考一下上面这段代码是否正确, 能否编译执行? 这段代码是<strong>不能被编译</strong>的, 因为参数 <code>List&lt;Integer&gt;</code>​ 和 <code>List&lt;String&gt;</code>​ <mark><strong>编译之后都被擦除了, 变成了同一种的裸类型 List, 类型擦除导致这两个方法的特征签名变得一模一样, 所以无法编译通过</strong></mark>. 初步看来, 无法重载的原因已经找到了, 但是真的就是如此吗? 其实这个例子中<strong>泛型擦除成相同的裸类型只是无法重载的其中一部分原因</strong>, 请再接着看一看代码清单 10-10 中的内容.</p> <blockquote><p>代码清单10-10 当泛型遇见重载2(必须用JDK6的Javac才能编译成功)</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTypes</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;invoke method(List&lt;String&gt; list)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;invoke method(List&lt;Integer&gt; list)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">method</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">method</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>执行结果:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>invoke <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span>
invoke <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>代码清单 10-9 与代码清单 10-10 的差别, 是两个 method() 方法添加了不同的返回值, 由于这两个返回值的加入, 方法重载居然成功了, 即这段代码可以被编译和执行了. 这是对 Java 语言中返回值不参与重载选择的基本认知的挑战吗?</p> <p>代码清单 10-10 中的重载当然不是根据返回值来确定的, 之所以这次能编译和执行成功, 是因为两个 method() 方法加入了不同的返回值后才能共存在一个 Class 文件之中. 前面介绍 Class 文件方法表(method_info)的数据结构时曾经提到过, <strong>方法重载要求方法具备不同的特征签名, 返回值并不包含在方法的特征签名中, 所以返回值不参与重载选择, 但是在 Class 文件格式之中, 只要描述符不是完全一致的两个方法就可以共存</strong>. 也就是说两个方法如果有相同的名称和特征签名, 但返回值不同, 那它们也是可以合法地共存于一个 Class 文件中的.</p> <p>由于 Java 泛型的引入, 各种场景(虚拟机解析, 反射等)下的方法调用都可能对原有的基础产生影响并带来新的需求, 如在泛型类中如何获取传入的参数化类型等. 所以 JCP 组织对《Java 虚拟机规范》做出了相应的修改, 引入了诸如 Signature, LocalVariableTypeTable 等新的属性用于解决伴随泛型而来的参数类型的识别问题, Signature 是其中最重要的一项属性, 它的作用就是存储一个方法在字节码层面的特征签名, 这个属性中保存的参数类型并不是原生类型, 而是包括了参数化类型的信息. 修改后的虚拟机规范要求所有能识别 49.0 以上版本的 Class 文件的虚拟机都要能正确地识别 Signature 参数.</p> <p>从上面的例子中可以看到擦除法对实际编码带来的不良影响, 由于 <code>List&lt;String&gt;</code>​ 和 <code>List&lt;Integer&gt;</code>​ 擦除后是<strong>同一个类型</strong>, 只能添加两个并不需要实际使用到的返回值才能完成重载, 这是一种毫无优雅和美感可言的解决方案, 并且存在一定语意上的混乱, 譬如上面脚注中提到的, 必须用 JDK 6 的 Javac 才能编译成功, 其他版本或者是 ECJ 编译器都有可能拒绝编译.</p> <p>另外, 从 Signature 属性的出现还可以得出结论, 擦除法所谓的擦除, 仅仅是<strong>对方法的 Code 属性中的字节码进行擦除, 实际上元数据中还是保留了泛型信息</strong>, 这也是在编码时能通过反射手段取得参数化类型的根本依据.</p> <h6 id="_4-值类型与未来的泛型"><a href="#_4-值类型与未来的泛型" class="header-anchor">#</a> (4)值类型与未来的泛型</h6> <p>在 2014 年, 刚好是 Java 泛型出现的十年之后, Oracle 建立了一个名为 <strong>Valhalla</strong> 的语言改进项目, 希望改进 Java 语言留下的各种缺陷(解决泛型的缺陷就是项目主要目标其中之一). 本节内容很可能在将来会发生变动, 请多加注意.</p> <p>在 Valhalla 项目中规划了<strong>几种不同的新泛型实现方案</strong>, 被称为 Model 1 到 Model 3, 在这些新的泛型设计中, 泛型类型有可能被具现化, 也有可能继续维持类型擦除以保持兼容(取决于采用哪种实现方案), 即使是继续采用类型擦除的方案, 泛型的参数化类型也可以选择不被完全地擦除掉, 而是相对完整地记录在 Class 文件中, 能够在运行期被使用, 也可以指定编译器默认要擦除哪些类型. 相对于使用不同方式实现泛型, 目前比较明确的是未来的 Java 应该会提供 &quot;值类型&quot; (Value Type)的语言层面的支持.</p> <p>说起值类型, 这点也是 <code>C#</code>​ 用户攻讦 Java 语言的常用武器之一, <code>C#</code>​ 并没有 Java 意义上的原生数据类型, 在 <code>C#</code>​ 中使用的 int, bool, double 关键字其实是对应了一系列在 <code>.NET</code>​ 框架中预定义好的结构体(Struct), 如 Int32, Boolean, Double 等. 在 <code>C#</code>​ 中开发人员也可以定义自己值类型, 只要继承于 ValueType 类型即可, 而 ValueType 也是统一基类 Object 的子类, 所以并不会遇到 Java 那样 int 不自动装箱就无法转型为 Object 的尴尬.</p> <p>值类型可以与引用类型一样, 具有构造函数, 方法或是属性字段, 等等, 而它与引用类型的区别在于它在赋值的时候通常是整体复制, 而不是像引用类型那样传递引用的. 更为关键的是, 值类型的实例很容易实现分配在方法的调用栈上的, 这意味着值类型会随着当前方法的退出而自动释放, 不会给垃圾收集子系统带来任何压力.</p> <p>在 Valhalla 项目中, Java 的值类型方案被称为 &quot;内联类型&quot;, 计划通过一个新的关键字 inline 来定义, 字节码层面也有专门与原生类型对应的以 Q 开头的新的操作码(譬如 iload 对应 qload)来支撑. 现在的预览版可以通过一个特制的解释器来保证这些未来可能加入的字节码指令能够被执行, 要即时编译的话, 现在只支持 C2 编译器. 即时编译器场景中是使用逃逸分析优化(见第 11 章)来处理内联类型的, 通过编码时标注以及内联类实例所具备的不可变性, 可以很好地解决逃逸分析面对传统引用类型时难以判断(没有足够的信息, 或者没有足够的时间做全程序分析)对象是否逃逸的问题.</p> <h5 id="_2-自动装箱-拆箱与遍历循环"><a href="#_2-自动装箱-拆箱与遍历循环" class="header-anchor">#</a> 2.自动装箱,拆箱与遍历循环</h5> <p>就纯技术的角度而论, 自动装箱, 自动拆箱与遍历循环(for-each 循环)这些语法糖, 无论是实现复杂度上还是其中蕴含的思想上都不能和泛型相提并论, 两者涉及的难度和深度都有很大差距. 专门拿出一节来讲解它们只是因为这些是 Java 语言里面被使用最多的语法糖. 下面通过代码清单 10-11 和代码清单 10-12 中所示的代码来看看这些语法糖在编译后会发生什么样的变化.</p> <blockquote><p>代码清单10-11 自动装箱, 拆箱与遍历循环</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>代码清单10-12 自动装箱, 拆箱与遍历循环编译之后</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
        <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> 
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Iterator</span> localIterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> localIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span>localIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>代码清单 10-11 中一共包含了<strong>泛型, 自动装箱, 自动拆箱, 遍历循环与变长参数</strong> 5 种语法糖, 代码清单 10-12 则展示了它们在编译前后发生的变化. 泛型就不必说了, 自动装箱, 拆箱在编译之后被转化成了对应的<strong>包装和还原方法</strong>, 如本例中的 Integer.valueOf() 与 Integer.intValue() 方法, 而遍历循环则是把代码还原成了<strong>迭代器</strong>的实现, 这也是为何遍历循环需要被遍历的类实现 Iterable 接口的原因. 最后再看看变长参数, 它在调用的时候变成了一个数组类型的参数, 在变长参数出现之前, 程序员的确也就是使用数组来完成类似功能的.</p> <h5 id="_3-条件编译"><a href="#_3-条件编译" class="header-anchor">#</a> 3.条件编译</h5> <p>许多程序设计语言都提供了条件编译的途径, 如 C, C++ 中使用预处理器指示符(<code>#ifdef</code>​)来完成条件编译. C, C++ 的预处理器最初的任务是解决编译时的代码依赖关系(如极为常用的 <code>#include</code>​ 预处理命令), 而在 Java 语言之中并没有使用预处理器, 因为 Java 语言天然的编译方式(编译器并非一个个地编译 Java 文件, 而是<strong>将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译</strong>, 因此各个文件之间能够互相提供符号信息)就无须使用到预处理器. <strong>那 Java 语言是否有办法实现条件编译呢</strong>?</p> <p>Java 语言当然<strong>也可以进行条件编译</strong>, 方法就是使用条件为常量的 if 语句. 如代码清单 10-14 所示, 该代码中的 if 语句不同于其他 Java 代码, 它在编译阶段就会被 &quot;运行&quot;, 生成的字节码之中只包括分支为 true 的一条语句, 并不会包含 if 语句及另外一个分支的语句.</p> <blockquote><p>代码清单10-14 Java语言的条件编译示例</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;block 1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;block 2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>该代码编译后 Class 文件的反编译结果:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;block 1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>只能使用条件为常量的 if 语句才能达到上述效果, 如果使用常量与其他带有条件判断能力的语句搭配, 则可能在控制流分析中提示错误, 被拒绝编译</strong>, 如代码清单 10-15 所示的代码就会被编译器拒绝编译.</p> <blockquote><p>代码清单10-15 不能使用其他条件语句来完成条件编译</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 编译器将会提示“Unreachable code”</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>Java 语言中条件编译的实现, 也是 Java 语言的一颗语法糖, 根据布尔常量值的真假, 编译器将会把分支中不成立的代码块消除掉, 这一工作将在编译器解除语法糖阶段</strong>(com.sun.tools.javac.comp.Lower 类中)完成. 由于这种条件编译的实现方式使用了 if 语句, 所以它必须遵循最基本的 Java 语法, 只能写在方法体内部, 因此它<strong>只能实现语句基本块(Block)级别的条件编译</strong>, 而没有办法实现根据条件调整整个 Java 类的结构.</p> <p>除了本节中介绍的泛型, 自动装箱, 自动拆箱, 遍历循环, 变长参数和条件编译之外, Java 语言还有不少其他的语法糖, 如内部类, 枚举类, 断言语句, 数值字面量, 对枚举和字符串的 switch 支持, try 语句中定义和关闭资源(这 3 个从 JDK 7 开始支持), Lambda 表达式(从 JDK 8 开始支持, Lambda 不能算是单纯的语法糖, 但在前端编译器中做了大量的转换工作), 等等, 读者可以通过跟踪 Javac 源码, 反编译 Class 文件等方式了解它们的本质实现, 囿于篇幅, 就不再一一介绍了.</p> <h4 id="实战-插入式注解处理器"><a href="#实战-插入式注解处理器" class="header-anchor">#</a> 实战:插入式注解处理器</h4> <p>Java 的编译优化部分在本书中并没有像前面两部分那样设置独立的, 整章篇幅的实战, 因为大家开发程序, 考虑的主要还是程序会如何运行, 较少会涉及针对程序编译的特殊需求. 也正因如此, 在 JDK 的编译子系统里面, 暴露给用户直接控制的功能相对很少, 除了第 11 章会介绍的虚拟机即时编译的若干相关参数以外, 就只有使用 JSR-296 中定义的插入式注解处理器 API 来对 Java 编译子系统的行为施加影响.</p> <p>但是笔者丝毫不认为相对于前两部分介绍的内存管理子系统和字节码执行子系统, 编译子系统就不那么重要了. 一套编程语言中编译子系统的优劣, 很大程度上决定了程序运行性能的好坏和编码效率的高低, 尤其在 Java 语言中, 运行期即时编译与虚拟机执行子系统非常紧密地互相依赖, 配合运作(第 11 章将主要讲解这方面的内容). <strong>了解 JDK 如何编译和优化代码, 有助于写出适合 Java 虚拟机自优化的程序</strong>. 话题说远了, 下面回到实战中来, 看看<strong>插入式注解处理器 API 能实现什么功能</strong>.</p> <h5 id="_1-实战目标"><a href="#_1-实战目标" class="header-anchor">#</a> 1.实战目标</h5> <p>通过阅读 Javac 编译器的源码, 可以知道前端编译器在把 Java 程序源码编译为字节码的时候, 会对 Java 程序<strong>源码做各方面的检查校验</strong>. 这些校验主要是以程序 &quot;写得对不对&quot; 为出发点, 虽然也会产生一些警告和提示类的信息, 但总体来讲还是较少去校验程序 &quot;写得好不好&quot;. 有鉴于此, 业界出现了<strong>许多针对程序 &quot;写得好不好&quot; 的辅助校验工具</strong>, 如 CheckStyle, FindBug, Klocwork 等. 这些代码校验工具有一些是基于 Java 的源码进行校验, 有一些是通过扫描字节码来完成, 在本节的实战中, 将会<strong>使用注解处理器 API 来编写一款拥有自己编码风格的校验工具: NameCheckProcessor</strong>.</p> <p>当然, 由于实战都是为了学习和演示技术原理, 而且篇幅所限, 不可能做出一款能媲美 CheckStyle 等工具的产品来, 所以 NameCheckProcessor 的目标也仅定为对 Java 程序命名进行检查. 根据《Java 语言规范》中 6.8 节的要求, Java 程序命名推荐(而不是强制)应当符合下列格式的书写规范.</p> <ul><li>类(或接口): 符合驼式命名法, 首字母大写.</li> <li>方法: 符合驼式命名法, 首字母小写.</li> <li>字段: (1) 类或实例变量. 符合驼式命名法, 首字母小写. (2) 常量. 要求全部由大写字母或下划线构成, 并且第一个字符不能是下划线.</li></ul> <p>上文提到的驼式命名法(Camel Case Name), 正如它的名称所表示的那样, 是指混合使用大小写字母来分割构成变量或函数的名字, 犹如驼峰一般, 这是当前 Java 语言中主流的命名规范, <strong>实战目标就是为 Javac 编译器添加一个额外的功能, 在编译程序时检查程序名是否符合上述对类(或接口), 方法, 字段的命名要求</strong>.</p> <h5 id="_2-代码实现"><a href="#_2-代码实现" class="header-anchor">#</a> 2.代码实现</h5> <p>要通过注解处理器 API 实现一个编译器插件, 首先需要了解这组 API 的一些基本知识. 实现注解处理器的代码需要继承抽象类 javax.annotation.processing.<strong>AbstractProcessor</strong>, 这个抽象类中只有一个子类必须实现的抽象方法: &quot;<code>process()</code>​&quot;, 它是 Javac 编译器在执行注解处理器代码时要调用的过程, 可以从这个方法的第一个参数 &quot;annotations&quot; 中获取到此注解处理器所要处理的注解集合, 从第二个参数 &quot;roundEnv&quot; 中访问到当前这个轮次(Round)中的抽象语法树节点, 每个语法树节点在这里都表示为一个 Element. 在 javax.lang.model.ElementKind 中定义了 18 类 Element, 已经包括了 Java 代码中可能出现的全部元素, 如: &quot;包(PACKAGE), 枚举(ENUM), 类(CLASS), 注解(ANNOTATION_TYPE), 接口(INTERFACE), 枚举值(ENUM_CONSTANT), 字段(FIELD), 参数(PARAMETER), 本地变量(LOCAL_VARIABLE), 异常(EXCEPTION_PARAMETER), 方法(METHOD), 构造函数(CONSTRUCTOR), 静态语句块(STATIC_INIT, 即 <code>static{}</code>​ 块), 实例语句块(INSTANCE_INIT, 即 <code>{}</code>​ 块), 参数化类型(TYPE_PARAMETER, 泛型尖括号内的类型), 资源变量(RESOURCE_VARIABLE, try-resource 中定义的变量), 模块(MODULE)和未定义的其他语法树节点(OTHER)&quot;. 除了 process() 方法的传入参数之外, 还有一个很重要的实例变量 &quot;processingEnv&quot;, 它是 AbstractProcessor 中的一个 protected 变量, 在注解处理器初始化的时候(init() 方法执行的时候)创建, 继承了 AbstractProcessor 的注解处理器代码可以直接访问它. 它代表了注解处理器框架提供的一个上下文环境, 要创建新的代码, 向编译器输出信息, 获取其他工具类等都需要用到这个实例变量.</p> <p>注解处理器除了 process() 方法及其参数之外, 还有两个经常配合着使用的注解, 分别是:  <strong>@SupportedAnnotationTypes 和 @SupportedSourceVersion</strong>, 前者代表了这个注解处理器对哪些注解感兴趣, 可以使用星号 &quot;<code>*</code>​&quot; 作为通配符代表对所有的注解都感兴趣, 后者指出这个注解处理器可以处理哪些版本的 Java 代码.</p> <p>每一个注解处理器在运行时都是<strong>单例</strong>的, 如果不需要改变或添加抽象语法树中的内容, process() 方法就可以返回一个值为 false 的布尔值, 通知编译器这个轮次中的代码未发生变化, 无须构造新的 JavaCompiler 实例, 在这次实战的注解处理器中只对程序命名进行检查, 不需要改变语法树的内容, 因此 process() 方法的返回值一律都是 false.</p> <p>关于注解处理器的 API, 就简单介绍这些, 对这个领域有兴趣的读者可以阅读相关的帮助文档. 来看看注解处理器 NameCheckProcessor 的具体代码, 如代码清单 10-16 所示.</p> <blockquote><p>代码清单10-16 注解处理器NameCheckProcessor</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 可以用&quot;*&quot;表示支持所有 Annotations</span>
<span class="token annotation punctuation">@SupportedAnnotationTypes</span><span class="token punctuation">(</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span>
<span class="token comment">// 只支持 JDK 6的 Java 代码</span>
<span class="token annotation punctuation">@SupportedSourceVersion</span><span class="token punctuation">(</span><span class="token class-name">SourceVersion</span><span class="token punctuation">.</span><span class="token constant">RELEASE_6</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NameCheckProcessor</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProcessor</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">NameChecker</span> nameChecker<span class="token punctuation">;</span>

    <span class="token comment">/**
     * 初始化名称检查插件
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">ProcessingEnvironment</span> processingEnv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>processingEnv<span class="token punctuation">)</span><span class="token punctuation">;</span>
        nameChecker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NameChecker</span><span class="token punctuation">(</span>processingEnv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 对输入的语法树的各个节点进行名称检查
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">TypeElement</span><span class="token punctuation">&gt;</span></span> annotations<span class="token punctuation">,</span> <span class="token class-name">RoundEnvironment</span> roundEnv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>roundEnv<span class="token punctuation">.</span><span class="token function">processingOver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Element</span> element <span class="token operator">:</span> roundEnv<span class="token punctuation">.</span><span class="token function">getRootElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                nameChecker<span class="token punctuation">.</span><span class="token function">checkNames</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>从代码清单 10-16 中可以看到 NameCheckProcessor 能处理基于 JDK 6 的源码, 它不限于特定的注解, 对任何代码都 &quot;感兴趣&quot;, 而在 process() 方法中是把当前轮次中的每一个 RootElement 传递到一个名为 NameChecker 的检查器中执行名称检查逻辑, NameChecker 的代码如代码清单 10-17 所示.</p> <blockquote><p>代码清单10-17 命名检查器NameChecker</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * 程序名称规范的编译器插件: &lt;br&gt;
 * 如果程序命名不合规范, 将会输出一个编译器的 WARNING 信息
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NameChecker</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Messager</span> messager<span class="token punctuation">;</span>

    <span class="token class-name">NameCheckScanner</span> nameCheckScanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NameCheckScanner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">NameChecker</span><span class="token punctuation">(</span><span class="token class-name">ProcessingEnvironment</span> processsingEnv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>messager <span class="token operator">=</span> processsingEnv<span class="token punctuation">.</span><span class="token function">getMessager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 对 Java 程序命名进行检查, 根据《Java 语言规范》第三版第6.8节的要求, Java 程序命名应当符合下列格式: 
     *
     * &lt;ul&gt;
     * &lt;li&gt; 类或接口: 符合驼式命名法, 首字母大写. 
     * &lt;li&gt; 方法: 符合驼式命名法, 首字母小写. 
     * &lt;li&gt; 字段: 
     * &lt;ul&gt;
     * &lt;li&gt; 类, 实例变量: 符合驼式命名法, 首字母小写. 
     * &lt;li&gt; 常量: 要求全部大写. 
     * &lt;/ul&gt;
     * &lt;/ul&gt;
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">checkNames</span><span class="token punctuation">(</span><span class="token class-name">Element</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nameCheckScanner<span class="token punctuation">.</span><span class="token function">scan</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 名称检查器实现类, 继承了 JDK 6中新提供的 ElementScanner6&lt;br&gt;
     * 将会以 Visitor 模式访问抽象语法树中的元素
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">NameCheckScanner</span> <span class="token keyword">extends</span> <span class="token class-name">ElementScanner6</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">,</span> <span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

        <span class="token comment">/**
         * 此方法用于检查 Java 类
         */</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">Void</span> <span class="token function">visitType</span><span class="token punctuation">(</span><span class="token class-name">TypeElement</span> e<span class="token punctuation">,</span> <span class="token class-name">Void</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">scan</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getTypeParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">checkCamelCase</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitType</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">/**
         * 检查方法命名是否合法
         */</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">Void</span> <span class="token function">visitExecutable</span><span class="token punctuation">(</span><span class="token class-name">ExecutableElement</span> e<span class="token punctuation">,</span> <span class="token class-name">Void</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getKind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">METHOD</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Name</span> name <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">contentEquals</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getEnclosingElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    messager<span class="token punctuation">.</span><span class="token function">printMessage</span><span class="token punctuation">(</span><span class="token constant">WARNING</span><span class="token punctuation">,</span> <span class="token string">&quot;一个普通方法 “&quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot;”不应当与类名重复, 避免与构造函数产生混淆&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">checkCamelCase</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitExecutable</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">/**
         * 检查变量命名是否合法
         */</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">Void</span> <span class="token function">visitVariable</span><span class="token punctuation">(</span><span class="token class-name">VariableElement</span> e<span class="token punctuation">,</span> <span class="token class-name">Void</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果这个 Variable 是枚举或常量, 则按大写命名检查, 否则按照驼式命名法规则检查</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getKind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">ENUM_CONSTANT</span> <span class="token operator">||</span> e<span class="token punctuation">.</span><span class="token function">getConstantValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token function">heuristicallyConstant</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">checkAllCaps</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                <span class="token function">checkCamelCase</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">/**
         * 判断一个变量是否是常量
         */</span>
        <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">heuristicallyConstant</span><span class="token punctuation">(</span><span class="token class-name">VariableElement</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getEnclosingElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getKind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token constant">INTERFACE</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getKind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token constant">FIELD</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">containsAll</span><span class="token punctuation">(</span><span class="token class-name">EnumSet</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token constant">PUBLIC</span><span class="token punctuation">,</span> <span class="token constant">STATIC</span><span class="token punctuation">,</span> <span class="token constant">FINAL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">/**
         * 检查传入的 Element 是否符合驼式命名法, 如果不符合, 则输出警告信息
         */</span>
        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">checkCamelCase</span><span class="token punctuation">(</span><span class="token class-name">Element</span> e<span class="token punctuation">,</span> <span class="token keyword">boolean</span> initialCaps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> name <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">boolean</span> previousUpper <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">boolean</span> conventional <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> firstCodePoint <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">isUpperCase</span><span class="token punctuation">(</span>firstCodePoint<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                previousUpper <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>initialCaps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    messager<span class="token punctuation">.</span><span class="token function">printMessage</span><span class="token punctuation">(</span><span class="token constant">WARNING</span><span class="token punctuation">,</span> <span class="token string">&quot;名称“&quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot;”应当以小写字母开头&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">isLowerCase</span><span class="token punctuation">(</span>firstCodePoint<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCaps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    messager<span class="token punctuation">.</span><span class="token function">printMessage</span><span class="token punctuation">(</span><span class="token constant">WARNING</span><span class="token punctuation">,</span> <span class="token string">&quot;名称“&quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot;”应当以大写字母开头&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span>
                conventional <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>conventional<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> cp <span class="token operator">=</span> firstCodePoint<span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">charCount</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> name<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">charCount</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    cp <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">isUpperCase</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>previousUpper<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            conventional <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        previousUpper <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span>
                        previousUpper <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>conventional<span class="token punctuation">)</span>
                messager<span class="token punctuation">.</span><span class="token function">printMessage</span><span class="token punctuation">(</span><span class="token constant">WARNING</span><span class="token punctuation">,</span> <span class="token string">&quot;名称“&quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot;”应当符合驼式命名法(Camel Case Names)&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">/**
         * 大写命名检查, 要求第一个字母必须是大写的英文字母, 其余部分可以是下划线或大写字母
         */</span>
        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">checkAllCaps</span><span class="token punctuation">(</span><span class="token class-name">Element</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> name <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">boolean</span> conventional <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> firstCodePoint <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">isUpperCase</span><span class="token punctuation">(</span>firstCodePoint<span class="token punctuation">)</span><span class="token punctuation">)</span>
                conventional <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">boolean</span> previousUnderscore <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> cp <span class="token operator">=</span> firstCodePoint<span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">charCount</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> name<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">charCount</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    cp <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>cp <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token char">'_'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>previousUnderscore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            conventional <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        previousUnderscore <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        previousUnderscore <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">isUpperCase</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">isDigit</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            conventional <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>conventional<span class="token punctuation">)</span>
                messager<span class="token punctuation">.</span><span class="token function">printMessage</span><span class="token punctuation">(</span><span class="token constant">WARNING</span><span class="token punctuation">,</span> <span class="token string">&quot;常量“&quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot;”应当全部以大写字母或下划线命名, 并且以字母开头&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br><span class="line-number">141</span><br><span class="line-number">142</span><br><span class="line-number">143</span><br><span class="line-number">144</span><br><span class="line-number">145</span><br><span class="line-number">146</span><br><span class="line-number">147</span><br><span class="line-number">148</span><br><span class="line-number">149</span><br><span class="line-number">150</span><br><span class="line-number">151</span><br><span class="line-number">152</span><br><span class="line-number">153</span><br><span class="line-number">154</span><br><span class="line-number">155</span><br><span class="line-number">156</span><br><span class="line-number">157</span><br><span class="line-number">158</span><br><span class="line-number">159</span><br><span class="line-number">160</span><br><span class="line-number">161</span><br><span class="line-number">162</span><br><span class="line-number">163</span><br><span class="line-number">164</span><br><span class="line-number">165</span><br><span class="line-number">166</span><br><span class="line-number">167</span><br></div></div><p>NameChecker 的代码看起来有点长, 但实际上注释占了很大一部分, 而且即使算上注释也不到 190 行. 它通过一个继承于 javax.lang.model.util.ElementScanner6 的 NameCheckScanner 类, 以 Visitor 模式来完成对语法树的遍历, 分别执行 visitType(), visitVariable() 和 visitExecutable() 方法来访问类, 字段和方法, 这 3 个 <code>visit*()</code>​ 方法<strong>对各自的命名规则做相应的检查</strong>, checkCamelCase() 与 checkAllCaps() 方法则用于实现驼式命名法和全大写命名规则的检查.</p> <p>整个注解处理器只需 NameCheckProcessor 和 NameChecker 两个类就可以全部完成, 为了验证实战成果, 代码清单 10-18 中提供了一段命名规范的 &quot;反面教材&quot; 代码, 其中的每一个类, 方法及字段的命名都存在问题, 但是使用普通的 Javac 编译这段代码时不会提示任意一条警告信息.</p> <blockquote><p>代码清单10-18 包含了多处不规范命名的代码样例</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BADLY_NAMED_CODE</span> <span class="token punctuation">{</span>

    <span class="token keyword">enum</span> colors <span class="token punctuation">{</span>
        red<span class="token punctuation">,</span> blue<span class="token punctuation">,</span> green<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _FORTY_TWO <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token constant">NOT_A_CONSTANT</span> <span class="token operator">=</span> _FORTY_TWO<span class="token punctuation">;</span>

    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">BADLY_NAMED_CODE</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">NOTcamelCASEmethodNAME</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h5 id="_3-运行与测试"><a href="#_3-运行与测试" class="header-anchor">#</a> 3.运行与测试</h5> <p>可以通过 Javac 命令的 &quot;<code>-processor</code>​&quot; 参数来执行编译时需要附带的注解处理器, 如果<strong>有多个注解处理器的话, 用逗号分隔</strong>. 还可以使用 <code>-XprintRounds</code>​ 和 <code>-XprintProcessorInfo</code>​ 参数来查看注解处理器运作的详细信息, 本次实战中的 NameCheckProcessor 的<strong>编译及执行过程</strong>如代码清单 10-19 所示.</p> <blockquote><p>代码清单10-19 注解处理器的运行过程</p></blockquote> <div class="language-c line-numbers-mode"><pre class="language-c"><code>D<span class="token operator">:</span>\src<span class="token operator">&gt;</span>javac org<span class="token operator">/</span>fenixsoft<span class="token operator">/</span>compile<span class="token operator">/</span>NameChecker<span class="token punctuation">.</span>java

D<span class="token operator">:</span>\src<span class="token operator">&gt;</span>javac org<span class="token operator">/</span>fenixsoft<span class="token operator">/</span>compile<span class="token operator">/</span>NameCheckProcessor<span class="token punctuation">.</span>java

D<span class="token operator">:</span>\src<span class="token operator">&gt;</span>javac <span class="token operator">-</span>processor org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>compile<span class="token punctuation">.</span>NameCheckProcessor org<span class="token operator">/</span>fenixsoft<span class="token operator">/</span>compile<span class="token operator">/</span>BADLY_NAMED_CODE<span class="token punctuation">.</span>java

org\fenixsoft\compile\BADLY_NAMED_CODE<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">3</span><span class="token operator">:</span> 警告<span class="token operator">:</span> 名称“BADLY_NAMED_CODE”应当符合驼式命名法<span class="token punctuation">(</span>Camel Case Names<span class="token punctuation">)</span>
public class BADLY_NAMED_CODE <span class="token punctuation">{</span>
       <span class="token operator">^</span>
org\fenixsoft\compile\BADLY_NAMED_CODE<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">5</span><span class="token operator">:</span> 警告<span class="token operator">:</span> 名称“colors”应当以大写字母开头
        <span class="token keyword">enum</span> <span class="token class-name">colors</span> <span class="token punctuation">{</span>
        <span class="token operator">^</span>
org\fenixsoft\compile\BADLY_NAMED_CODE<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">6</span><span class="token operator">:</span> 警告<span class="token operator">:</span> 常量“red”应当全部以大写字母或下划线命名<span class="token punctuation">,</span> 并且以字母开头
                red<span class="token punctuation">,</span> blue<span class="token punctuation">,</span> green<span class="token punctuation">;</span>
                <span class="token operator">^</span>
org\fenixsoft\compile\BADLY_NAMED_CODE<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">6</span><span class="token operator">:</span> 警告<span class="token operator">:</span> 常量“blue”应当全部以大写字母或下划线命名<span class="token punctuation">,</span> 并且以字母开头
                red<span class="token punctuation">,</span> blue<span class="token punctuation">,</span> green<span class="token punctuation">;</span>
                     <span class="token operator">^</span>
org\fenixsoft\compile\BADLY_NAMED_CODE<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">6</span><span class="token operator">:</span> 警告<span class="token operator">:</span> 常量“green”应当全部以大写字母或下划线命名<span class="token punctuation">,</span> 并且以字母开头
                red<span class="token punctuation">,</span> blue<span class="token punctuation">,</span> green<span class="token punctuation">;</span>
                           <span class="token operator">^</span>
org\fenixsoft\compile\BADLY_NAMED_CODE<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">9</span><span class="token operator">:</span> 警告<span class="token operator">:</span> 常量“_FORTY_TWO”应当全部以大写字母或下划线命名<span class="token punctuation">,</span> 并且以字母开头
        <span class="token keyword">static</span> final <span class="token keyword">int</span> _FORTY_TWO <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
                         <span class="token operator">^</span>
org\fenixsoft\compile\BADLY_NAMED_CODE<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">11</span><span class="token operator">:</span> 警告<span class="token operator">:</span> 名称“NOT_A_CONSTANT”应当以小写字母开头
        public <span class="token keyword">static</span> <span class="token keyword">int</span> NOT_A_CONSTANT <span class="token operator">=</span> _FORTY_TWO<span class="token punctuation">;</span>
                          <span class="token operator">^</span>
org\fenixsoft\compile\BADLY_NAMED_CODE<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">13</span><span class="token operator">:</span> 警告<span class="token operator">:</span> 名称“Test”应当以小写字母开头
        protected <span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                       <span class="token operator">^</span>
org\fenixsoft\compile\BADLY_NAMED_CODE<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">17</span><span class="token operator">:</span> 警告<span class="token operator">:</span> 名称“NOTcamelCASEmethodNAME”应当以小写字母开头
        public <span class="token keyword">void</span> <span class="token function">NOTcamelCASEmethodNAME</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token operator">^</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><h5 id="_4-其他应用案例"><a href="#_4-其他应用案例" class="header-anchor">#</a> 4.其他应用案例</h5> <p>NameCheckProcessor 的实战例子只演示了 JSR-269 嵌入式注解处理 API 其中的一部分功能, 基于这组 API 支持的比较有名的项目还有用于校验 Hibernate 标签使用正确性的 Hibernate Validator Annotation Processor(本质上与 NameCheckProcessor 所做的事情差不多), 自动为字段生成 getter 和 setter 方法等辅助内容的 <mark><strong>Lombok</strong></mark> (<strong>根据已有元素生成新的语法树元素</strong>)等, 读者有兴趣的话可以参考它们官方站点的相关内容.</p> <p>‍</p> <h4 id="本章小结"><a href="#本章小结" class="header-anchor">#</a> 本章小结</h4> <p>本章从 Javac 编译器源码实现的层次上学习了 Java 源代码编译为字节码的过程, 分析了 Java 语言中泛型, 主动装箱拆箱, 条件编译等多种语法糖的前因后果, 并实战练习了如何使用插入式注解处理器来完成一个检查程序命名规范的编译器插件. 如本章概述中所说的, 在前端编译器中, &quot;优化&quot; 手段主要用于提升程序的编码效率, 之所以把 Javac 这类将 Java 代码转变为字节码的编译器称作 &quot;前端编译器&quot;, 是因为<strong>它只完成了从程序到抽象语法树或中间字节码的生成</strong>, 而在此之后, 还有一组内置于 Java 虚拟机内部的 &quot;后端编译器&quot; 来<strong>完成代码优化以及从字节码生成本地机器码的过程</strong>, 即前面多次提到的<strong>即时编译器或提前编译器</strong>, 这个后端编译器的编译速度及编译结果质量高低, 是衡量 Java 虚拟机性能最重要的一个指标. 在第 11 章中, 将会一探后端编译器的运作和优化过程.</p> <p>‍</p> <p>‍</p> <p>‍</p> <p>‍</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/20.开发/2000.Java/600.JVM/40.前端编译与优化🌼.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/c6c210/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">类加载及执行子系统的案例与实战🌼</div></a> <a href="/pages/1f8f72/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">后端编译与优化🌼</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/c6c210/" class="prev">类加载及执行子系统的案例与实战🌼</a></span> <span class="next"><a href="/pages/1f8f72/">后端编译与优化🌼</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/86.44ba2100.js" defer></script>
  </body>
</html>
