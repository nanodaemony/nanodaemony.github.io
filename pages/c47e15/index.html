<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>代码之丑(极客时间)🌸 | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/140.c5c375d3.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/93.6bf5fb66.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Java</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/4f30b9/" class="sidebar-link">Java基础</a></li><li><a href="/pages/795eca/" class="sidebar-link">类与继承</a></li><li><a href="/pages/c69152/" class="sidebar-link">抽象类与接口</a></li><li><a href="/pages/d71abb/" class="sidebar-link">内部类</a></li><li><a href="/pages/f06dca/" class="sidebar-link">枚举类</a></li><li><a href="/pages/259f57/" class="sidebar-link">常用类</a></li><li><a href="/pages/84b03b/" class="sidebar-link">关键字</a></li><li><a href="/pages/31b87b/" class="sidebar-link">注解</a></li><li><a href="/pages/f81c0d/" class="sidebar-link">异常</a></li><li><a href="/pages/ae7746/" class="sidebar-link">泛型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>容器类</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/0c88ac/" class="sidebar-link">集合容器类基础</a></li><li><a href="/pages/f805ed/" class="sidebar-link">List与Queue类</a></li><li><a href="/pages/d24b60/" class="sidebar-link">Map与Set类</a></li><li><a href="/pages/54e5d3/" class="sidebar-link">并发容器类</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/67d70f/" class="sidebar-link">多线程基础</a></li><li><a href="/pages/ffc8f7/" class="sidebar-link">Java内置锁</a></li><li><a href="/pages/c43494/" class="sidebar-link">AQS</a></li><li><a href="/pages/eb5b61/" class="sidebar-link">显式锁ReentrantLock</a></li><li><a href="/pages/eb8cbc/" class="sidebar-link">线程协作与JUC组件</a></li><li><a href="/pages/23c79a/" class="sidebar-link">Atomic原子变量与Unsafe类与CAS</a></li><li><a href="/pages/9d6ed4/" class="sidebar-link">线程池与定时任务</a></li><li><a href="/pages/5b787a/" class="sidebar-link">ThreadLocal</a></li><li><a href="/pages/db53d1/" class="sidebar-link">Java并发编程实战(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>IO</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b4d461/" class="sidebar-link">文件操作</a></li><li><a href="/pages/1b9d6c/" class="sidebar-link">IO流操作</a></li><li><a href="/pages/076a47/" class="sidebar-link">Java网络IO模型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>高级特性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d76905/" class="sidebar-link">Lambda表达式</a></li><li><a href="/pages/f7f0e6/" class="sidebar-link">流Stream</a></li><li><a href="/pages/7cc40a/" class="sidebar-link">反射</a></li><li><a href="/pages/945326/" class="sidebar-link">代理</a></li><li><a href="/pages/7fd9b4/" class="sidebar-link">Javaagent</a></li><li><a href="/pages/a3cee0/" class="sidebar-link">Guava</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>JVM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d308f6/" class="sidebar-link">走进JVM🌼</a></li><li><a href="/pages/be0269/" class="sidebar-link">JVM内存区域与对象解析🌼</a></li><li><a href="/pages/48d1be/" class="sidebar-link">垃圾收集器与内存分配策略🌼</a></li><li><a href="/pages/3a4c8a/" class="sidebar-link">JVM性能监控与故障处理工具🌼</a></li><li><a href="/pages/106680/" class="sidebar-link">调优案例分析与实战🌼</a></li><li><a href="/pages/16a914/" class="sidebar-link">类文件结构🌼</a></li><li><a href="/pages/ea287c/" class="sidebar-link">虚拟机类加载机制🌼</a></li><li><a href="/pages/6367b0/" class="sidebar-link">虚拟机字节码执行引擎🌼</a></li><li><a href="/pages/c6c210/" class="sidebar-link">类加载及执行子系统的案例与实战🌼</a></li><li><a href="/pages/deb8b7/" class="sidebar-link">前端编译与优化🌼</a></li><li><a href="/pages/1f8f72/" class="sidebar-link">后端编译与优化🌼</a></li><li><a href="/pages/3d72db/" class="sidebar-link">Java内存模型与线程实现🌼</a></li><li><a href="/pages/ed086e/" class="sidebar-link">线程安全与内置锁优化🌼</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/56b9dd/" class="sidebar-link">Java性能问题定位分析</a></li><li><a href="/pages/939bf8/" class="sidebar-link">杂记</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>开发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>软件设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/a5f6fe/" class="sidebar-link">设计基础理论</a></li><li><a href="/pages/3b245c/" class="sidebar-link">设计模式之美(极客时间)🌟</a></li><li><a href="/pages/661fa4/" class="sidebar-link">领域驱动设计(DDD)</a></li><li><a href="/pages/856368/" class="sidebar-link">DDD实战课(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d3fbd2/" class="sidebar-link">数据库基础</a></li><li><a href="/pages/691fc3/" class="sidebar-link">数据库系统原理</a></li><li><a href="/pages/50f6b7/" class="sidebar-link">MySQL基础必知必会</a></li><li><a href="/pages/fe297e/" class="sidebar-link">MySQL特性</a></li><li><a href="/pages/07bdb6/" class="sidebar-link">MySQL索引🌟</a></li><li><a href="/pages/984715/" class="sidebar-link">MySQL锁🌟</a></li><li><a href="/pages/53b588/" class="sidebar-link">MySQL事务🌟</a></li><li><a href="/pages/becc59/" class="sidebar-link">MySQL高级特性</a></li><li><a href="/pages/056463/" class="sidebar-link">MySQL基础架构与存储引擎🌟</a></li><li><a href="/pages/63b46e/" class="sidebar-link">MySQL架构优化与运维</a></li><li><a href="/pages/9995e5/" class="sidebar-link">MySQL优化</a></li><li><a href="/pages/c1c2f6/" class="sidebar-link">MySQL架构</a></li><li><a href="/pages/8e8e0a/" class="sidebar-link">MySQL设计规范</a></li><li><a href="/pages/0219aa/" class="sidebar-link">MySQL运维</a></li><li><a href="/pages/e288c0/" class="sidebar-link">MySQL中间件</a></li><li><a href="/pages/c6cafa/" class="sidebar-link">MySQL实战45讲(极客时间)🌟</a></li><li><a href="/pages/4a6106/" class="sidebar-link">数据库LeetCode题目</a></li><li><a href="/pages/2827f1/" class="sidebar-link">数据库综合问题</a></li><li><a href="/pages/c616d5/" class="sidebar-link">MongoDB</a></li><li><a href="/pages/075e71/" class="sidebar-link">ClickHouse</a></li><li><a href="/pages/d74f6d/" class="sidebar-link">Doris</a></li><li><a href="/pages/b6bad9/" class="sidebar-link">HBase</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Spring</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bd8eb8/" class="sidebar-link">Spring Boot基础</a></li><li><a href="/pages/d0d797/" class="sidebar-link">Spring Boot应用整合</a></li><li><a href="/pages/314cdc/" class="sidebar-link">Spring MVC基础</a></li><li><a href="/pages/80de47/" class="sidebar-link">Spring AOP基础</a></li><li><a href="/pages/f0d4d6/" class="sidebar-link">Spring事务基础</a></li><li><a href="/pages/db6afe/" class="sidebar-link">Spring IOC源码分析-概览</a></li><li><a href="/pages/672e98/" class="sidebar-link">Spring IOC源码分析-getBean()</a></li><li><a href="/pages/695b90/" class="sidebar-link">Spring IOC源码分析-createBean()</a></li><li><a href="/pages/f89bcf/" class="sidebar-link">Spring AOP源码分析</a></li><li><a href="/pages/3b52f4/" class="sidebar-link">Spring事务源码分析</a></li><li><a href="/pages/186902/" class="sidebar-link">Spring Boot源码分析</a></li><li><a href="/pages/16bd1c/" class="sidebar-link">Spring MVC源码分析</a></li><li><a href="/pages/3d0c1f/" class="sidebar-link">Spring Cloud</a></li><li><a href="/pages/d56156/" class="sidebar-link">Spring编程常见错误50例(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>MyBatis</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bb032d/" class="sidebar-link">基础</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>工具与环境</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c9cb6e/" class="sidebar-link">Arthas</a></li><li><a href="/pages/3172bb/" class="sidebar-link">Maven</a></li><li><a href="/pages/37f79a/" class="sidebar-link">Git</a></li><li><a href="/pages/db9f99/" class="sidebar-link">环境搭建与部署</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c725f5/" class="sidebar-link">测试基础</a></li><li><a href="/pages/7893a4/" class="sidebar-link">单元测试</a></li><li><a href="/pages/af9f25/" class="sidebar-link">压力测试</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>代码质量</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ec2b81/" class="sidebar-link">代码整洁之道</a></li><li><a href="/pages/474cdf/" class="sidebar-link">阿里巴巴编程规范</a></li><li><a href="/pages/c47e15/" aria-current="page" class="active sidebar-link">代码之丑(极客时间)🌸</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/4d4606/" class="sidebar-link">Java业务开发常见错误100例(极客时间)🌸</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/develop/#开发" data-v-06970110>开发</a></li><li data-v-06970110><a href="/develop/#开发" data-v-06970110>开发</a></li><li data-v-06970110><a href="/develop/#代码质量" data-v-06970110>代码质量</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">代码之丑(极客时间)🌸<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_730-代码之丑-极客时间-🌸"><a href="#_730-代码之丑-极客时间-🌸" class="header-anchor">#</a> 730.代码之丑(极客时间)🌸</h1> <h4 id="从-丑-代码出发"><a href="#从-丑-代码出发" class="header-anchor">#</a> 从&quot;丑&quot;代码出发</h4> <p>无论懂得多少道理, 程序员依然要回归到写代码的本职工作上. 所以, 这次我准备和你从代码的坏味道出发, 一起探讨如何写代码.</p> <h5 id="_1-千里之堤毁于蚁穴"><a href="#_1-千里之堤毁于蚁穴" class="header-anchor">#</a> 1.千里之堤毁于蚁穴</h5> <p>为什么要讲这个话题, 先从一次代码评审讲起. 在一次代码评审中, 有这样一段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">approve</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> bookId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    book<span class="token punctuation">.</span><span class="token function">setReviewStatus</span><span class="token punctuation">(</span><span class="token class-name">ReviewStatus</span><span class="token punctuation">.</span><span class="token constant">APPROVED</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这是在一个服务类里面写的, 它的主要逻辑就是从仓库中找出一个作品, 然后将它的状态设置为审核通过, 再将它存回去. 前后的代码都属于常规的代码, 但是设置作品评审状态的代码引起了我的注意, 于是有了下面这段对话.</p> <blockquote><p>我: 这个地方为什么要这么写?</p> <p>同事: 我要将作品的审核状态设置为审核通过.</p> <p>我: 这个我知道, 但为什么要在这里写 setter 呢?</p> <p>同事: 你的意思是?</p> <p>我: 这个审核的状态是作品的一个内部状态, 为什么服务需要知道它呢? 也就是说这里通过 setter, 将一个类的内部行为暴露了出来, 这是一种破坏封装的做法.</p></blockquote> <p>同事被我说动了, 于是这段代码变成了下面这个样子:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">approve</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> bookId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    book<span class="token punctuation">.</span><span class="token function">approve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>之所以注意到这段代码, 完全是因为这里用到了 setter. 在我看来, setter 就是一个坏味道, 每次一看到 setter, 我就会警觉起来.</p> <p><strong>setter 的出现, 是对于封装的破坏, 它把一个类内部的实现细节暴露了出来</strong>. 面向对象的封装, <strong>关键点是行为</strong>, 而使用 setter 多半只是做了<strong>数据的聚合</strong>, 缺少了行为的设计, 这段代码改写后的 approve() 函数, 就是这里缺少的行为.</p> <p>再扩展一步, <strong>setter 通常还意味着变化</strong>, 而我在《软件设计之美》中讲函数式编程时也说过, <strong>一个好的设计应该尽可能追求不变性</strong>. 所以, setter 也是一个提示符, 告诉我们这个地方的设计可能有问题.</p> <p>一个小小的 setter, 背后却隐藏着这么多的问题. 而所有这些问题, 都会让代码在未来的日子变得更加不可维护, 这就是软件团队陷入泥潭的开始.</p> <p>写代码有两个维度: 正确性和可维护性, 不要只关注正确性. 能把代码写对, 是每个程序员的必备技能, <mark><strong>但能够把代码写得更具可维护性, 这是一个程序员从业余迈向职业的第一步</strong></mark>.</p> <h5 id="_2-将坏味道重构为整洁代码"><a href="#_2-将坏味道重构为整洁代码" class="header-anchor">#</a> 2.将坏味道重构为整洁代码</h5> <p>或许你也认同代码要有可维护性, 也看了很多书, 比如《程序设计实践》《代码整洁之道》等等, 这些无一不是经典中的经典. 不过, 回到真实的工作中, 我发现了一个无情的事实: **程序员们大多会认同这些书上的观点, 但每个人对于这些观点的理解却是千差万别的. **</p> <p>比如书上说: &quot;命名是要有意义的&quot;, 但什么样的命名才算是有意义的呢? 有的人只理解到不用 xyz 命名, 虽然他起出了自认为有意义的名字, 但这些名字依然是难以理解的. 事实上, 大部分程序员在真实世界中面对的代码, 就是这样难懂的代码.</p> <p>这是因为, <strong>很多人虽然知道正面的代码是什么样子, 却不知道反面的代码是什么样子</strong>. 这些反面代码, Martin Fowler 在《重构》这本书中给起了一个好名字, <strong>代码的坏味道</strong>(Bad Smell). 推荐那些想要提高自己编程水平的人读《重构》, 如果时间比较少, 就去读第三章 &quot;代码的坏味道&quot;.</p> <p>不过, 《重构》中的 &quot;代码的坏味道&quot; 意图虽好, 但却需要一个人对于整洁代码有着深厚的理解, 才能识别出这些坏味道. 否则, 即使你知道有哪些坏味道, 但真正有坏味道的代码出现在你面前时, 你仍然无法认得它.</p> <p>比如, <strong>可以看看 Info, Data, Manager 是不是代码库经常使用的词汇, 而它们往往是命名没有经过仔细思考的地方</strong>. 在很多人眼中, 这些代码是没有问题的. 正因如此, 才有很多坏味道的代码才堂而皇之地留在你的眼皮底下.</p> <p>所以, 我才想做一个讲坏味道的专栏, 把最常见的坏味道直接用代码形式展现出来. 在这个专栏里, 我给你的都是即学即用的 &quot;坏味道&quot;, 我不仅会告诉你典型的坏味道是什么, 而且也能让你在实际的编程过程中发现它们. 比如前面那个例子里面的 setter, 只要它一出现, 就需要立即警觉起来.</p> <p>这里也整理了一份 &quot;坏味道自查表&quot;, 把一些明显的 &quot;坏味道&quot; 信号列了出来, 可以和自己的代码做对比.</p> <p><img src="/img/98bd14a45a14f459cc24b4cd8c332b84-20230729224950-fmeil21.png" alt=""></p> <p>除了列出来哪些代码有坏味道之外, 还会讲支撑这些 &quot;坏味道&quot; 之所以为 &quot;坏味道&quot; 的原因, 比如说: <strong>长方法和大类之所以为坏味道, 因为它们都违背了单一职责的原则</strong>.</p> <p>有坏味道的代码需要经过重构才能长成新的样子, 在这个专栏里, 也会提到一些重构的手法, 比如, 改名(Rename), 提取方法(Extract Method)等等. 在今天, 拜许多能力强大的 IDE 所赐, 重构已经变得越来越自动化, 《重构》里的很多手法已经成为了 IDE 中的一个选项.</p> <p>我还想给你一个安全提示, 即便 IDE 功能再强大, 也不要忘了<strong>重构的重要根基: 测试</strong>. 即便像 Java 这样, IDE 功能已经非常强大了, 依然会有一些像反射之类的场景可能会从自动化重构的鼻子底下溜走. 所以, <strong>重构一段代码之前, 最好能够给它写下测试, 确保改动前后的代码, 功能上是一致的</strong>.</p> <p>我叫郑晔, 一个写代码超过二十年的程序员, 做过与软件开发的各种工作: 编代码, 带团队, 做咨询, 写开源. 正如前面所说, 我已经在极客时间平台上写了两个专栏, 分享我在软件开发中的各种思考. 这次会带你进入到我的基本功里, 帮你一起写好代码.</p> <h4 id="缺乏业务含义的命名-如何精准命名"><a href="#缺乏业务含义的命名-如何精准命名" class="header-anchor">#</a> 缺乏业务含义的命名:如何精准命名?</h4> <p>讲写代码的书通常都会从命名开始讲, 《程序设计实践》如此, 《代码整洁之道》亦然. 所以这个讲代码坏味道的专栏, 也遵循传统, 从命名开始讲.</p> <p>不过, 也许你会说: &quot;我知道, 命名不就是不能用 abcxyz 命名, 名字要有意义嘛, 这有什么好讲的.&quot; 然而, 即便懂得了名字要有意义这个道理, 很多程序员依然无法从命名的泥潭中挣脱出来.</p> <h5 id="_1-不精准的命名"><a href="#_1-不精准的命名" class="header-anchor">#</a> 1.不精准的命名</h5> <p>先来看一段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">processChapter</span><span class="token punctuation">(</span><span class="token keyword">long</span> chapterId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Chapter</span> chapter <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>repository<span class="token punctuation">.</span><span class="token function">findByChapterId</span><span class="token punctuation">(</span>chapterId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>chapter <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Unknown chapter [&quot;</span> <span class="token operator">+</span> chapterId <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    chapter<span class="token punctuation">.</span><span class="token function">setTranslationState</span><span class="token punctuation">(</span><span class="token class-name">TranslationState</span><span class="token punctuation">.</span><span class="token constant">TRANSLATING</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>repository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>chapter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这是一段看上去还挺正常的代码, 甚至以很多团队的标准来看, 这段代码写得还不错. 但如果我问你, 这段代码是做什么的. 你就需要调动全部注意力, 去认真阅读这段代码, 找出其中的逻辑. 经过阅读发现, 这段代码做的就是把一个章节的翻译状态改成翻译中.</p> <p>问题来了, <strong>为什么需要阅读这段代码的细节才能知道这段代码是做什么的</strong>?</p> <p>问题就出在<strong>函数名</strong>上. 这个函数的名字叫 processChapter(处理章节), 这个函数确实是在处理章节, 但这个名字太过宽泛. 如果说 &quot;将章节的翻译状态改成翻译中&quot; 叫做处理章节, 那么 &quot;将章节的翻译状态改成翻译完&quot; 是不是也叫处理章节呢? &quot;修改章节内容&quot; 是不是也叫处理章节呢? 换句话说, <strong>如果各种场景都能够叫处理章节, 那么处理章节就是一个过于宽泛的名字, 没有错, 但不精准</strong>.</p> <p>这就是一类典型的命名问题, 从表面上看, 这个名字是有含义的, 但实际上, 它并<strong>不能有效地反映这段代码的含义</strong>. 如果说我在做的是一个信息处理系统, 就根本无法判断, 我做的是一个电商平台, 还是一个图书管理系统, 从沟通的角度看, 这就不是一个有效的沟通. 要想理解它, 需要消耗大量认知成本, 无论是时间, 还是精力.</p> <p><strong>命名过于宽泛, 不能精准描述, 这是很多代码在命名上存在的严重问题, 也是代码难以理解的根源所在</strong>.</p> <p>或许这么说你的印象还是不深刻, 来看看下面这些词是不是经常出现在你的代码里: <strong>data, info, flag, process, handle, build, maintain, manage, modify</strong> 等等. 这些名字都属于典型的<strong>过于宽泛的名字</strong>, 当这些名字出现在你的代码里, 多半是写代码的人当时没有想好用什么名字, 就开始写代码了. 只要稍微仔细想想, 类似的名字你一定还能想出不少来.</p> <p>回到前面那段代码上, 如果它不叫 &quot;处理章节&quot;, 那应该叫什么呢? 首先, <mark><strong>命名要能够描述出这段代码在做的事情</strong></mark>. 这段代码在做的事情就是 &quot;将章节修改为翻译中&quot;. 那是不是它就应该叫 changeChapterToTranlsating 呢?</p> <p>不可否认, 相比于 &quot;处理章节&quot;, changeChapterToTranlsating 这个名字已经进了一步, 然而它也不算是一个好名字, 因为它<strong>更多的是在描述这段代码在做的细节</strong>. 之所以要将一段代码封装起来, 一个重要的原因就是, 我们不想知道那么多的细节. 如果把细节平铺开来, 那本质上和直接阅读代码细节差别并不大.</p> <p>所以, <mark><strong>一个好的名字应该描述意图, 而非细节</strong></mark>​ <strong>.</strong></p> <p>就这段代码而言, 为什么要把翻译状态修改成翻译中, 这一定是有原因的, 也就是<strong>意图</strong>. 具体到这里的业务, 把翻译状态修改成翻译中, 是因为在这里开启了一个翻译的过程. 所以这段函数应该命名 <strong>startTranslation</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">startTranslation</span><span class="token punctuation">(</span><span class="token keyword">long</span> chapterId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Chapter</span> chapter <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>repository<span class="token punctuation">.</span><span class="token function">findByChapterId</span><span class="token punctuation">(</span>chapterId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>chapter <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Unknown chapter [&quot;</span> <span class="token operator">+</span> chapterId <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    chapter<span class="token punctuation">.</span><span class="token function">setTranslationState</span><span class="token punctuation">(</span><span class="token class-name">TranslationState</span><span class="token punctuation">.</span><span class="token constant">TRANSLATING</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>repository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>chapter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>用技术术语命名再来看一段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Book</span><span class="token punctuation">&gt;</span></span> bookList <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">getBooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>可以说这是一段常见得不能再常见的代码了, 但这段代码却隐藏另外一个典型得不能再典型的问题: **用技术术语命名. **</p> <p>这个 bookList 变量之所以叫 bookList, 原因就是它声明的类型是 List. 这种命名在代码中几乎是随处可见的, 比如 xxxMap, xxxSet.</p> <p>这是一种不费脑子的命名方式, 但这种命名却会带来很多问题, 因为它是一种<strong>基于实现细节的命名方式</strong>.</p> <p>编程有一个重要的原则是面向接口编程, 这个原则从另外一个角度理解, 就是不要面向实现编程, <strong>因为接口是稳定的, 而实现是易变的</strong>. 虽然在大多数人的理解里, 这个原则是针对类型的, 但在命名上, 也应该遵循同样的原则. 为什么? 举个例子就知道了.</p> <p>比如, 如果现在需要的是一个不重复的作品集合, 也就是需要把这个变量的类型从 List 改成 Set. 变量类型一定会改, 但变量名你会改吗? 这还真不一定, 一旦出现遗忘, 就会出现一个奇特的现象, 一个叫 bookList 的变量, 它的类型是一个 Set. 这样一个新的混淆就此产生了.</p> <p>那有什么更好的名字吗? 只需要一个更面向意图的名字. 其实在这段代码里真正要表达的是拿到了一堆书, 所以这个名字可以命名成 books.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Book</span><span class="token punctuation">&gt;</span></span> books <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">getBooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>也许你发现了, 这个名字其实更简单, 但从表意的程度上来说, 它却是一个更有效的名字.</p> <p>虽然这里只是以变量为例说明了以技术术语命名存在的问题, 事实上, <strong>在实际的代码中, 技术名词的出现,</strong> <strong>往往就代表着它缺少了一个应有的模型.</strong></p> <p>比如, 在业务代码里如果直接出现了 Redis:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Book</span> <span class="token function">getByIsbn</span><span class="token punctuation">(</span><span class="token class-name">String</span> isbn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Book</span> cachedBook <span class="token operator">=</span> redisBookStore<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>isbn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cachedBook <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> cachedBook<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token class-name">Book</span> book <span class="token operator">=</span> <span class="token function">doGetByIsbn</span><span class="token punctuation">(</span>isbn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    redisBookStore<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>isbn<span class="token punctuation">,</span> book<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> book<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>通常来说, 这里真正需要的是一个<strong>缓存</strong>. Redis 是缓存这个模型的一个实现:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Book</span> <span class="token function">getByIsbn</span><span class="token punctuation">(</span><span class="token class-name">String</span> isbn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Book</span> cachedBook <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>isbn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cachedBook <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> cachedBook<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token class-name">Book</span> book <span class="token operator">=</span> <span class="token function">doGetByIsbn</span><span class="token punctuation">(</span>isbn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>isbn<span class="token punctuation">,</span> book<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> book<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>再进一步, 缓存这个概念其实也是一个技术术语, 从某种意义上说, 它也不应该出现在业务代码中. 这方面做得比较好的是 Spring. 使用 Spring 框架时, 如果需要缓存, 通常是加上一个 Annotation(注解):</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Cacheable</span><span class="token punctuation">(</span><span class="token string">&quot;books&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Book</span> <span class="token function">getByIsbn</span><span class="token punctuation">(</span><span class="token class-name">String</span> isbn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>程序员之所以喜欢用技术名词去命名, 一方面是因为这是大家习惯的语言, 另一方面也是因为程序员学习写代码, 很大程度上是参考别人的代码, 而行业里面优秀的代码常常是一些开源项目, 而这些开源项目往往是技术类的项目. <strong>在一个技术类的项目中, 这些技术术语其实就是它的业务语言. 但对于业务项目, 这个说法就必须重新审视了.</strong></p> <p>如果这个部分的代码确实就是处理一些技术, 使用技术术语无可厚非, 但如果是在处理业务, 就要尽可能把技术术语隔离开来.</p> <h5 id="_2-用业务语言写代码"><a href="#_2-用业务语言写代码" class="header-anchor">#</a> 2.用业务语言写代码</h5> <p>无论是不精准的命名也好, 技术名词也罢, 归根结底, 体现的是同一个问题: <strong>对业务理解不到位</strong>.</p> <p>我在《10x 程序员工作法》专栏中曾经说过, <strong>编写可维护的代码要使用业务语言</strong>. 怎么才知道自己的命名是否用的是业务语言呢? 一种简单的做法就是, 把这个词讲给产品经理, 看他知不知道是怎么回事.</p> <p>从团队的角度看, 让每个人根据自己的理解来命名, 确实就有可能出现千奇百怪的名字, 所以一个良好的团队实践是, <strong>建立团队的词汇表</strong>, 让团队成员有信息可以参考.</p> <p>团队对于业务有了共同理解, 也许就可以发现一些更高级的坏味道, 比如说下面这个函数声明:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">approveChapter</span><span class="token punctuation">(</span><span class="token keyword">long</span> chapterId<span class="token punctuation">,</span> <span class="token keyword">long</span> userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个函数的意图是, 确认章节内容审核通过. 这里有一个问题, chapterId 是审核章节的 ID, 这个没问题, 但 userId 是什么呢? 了解了一下背景才知道, 之所以这里要有一个 userId, 是因为这里需要记录一下审核人的信息, 这个 userId 就是审核人的 userId.</p> <p>通过业务的分析会发现, 这个 userId 并不是一个好的命名, 因为它还需要更多的解释, 更好的命名是 <strong>reviewerUserId</strong>, 之所以起这个名字, 因为这个用户在这个场景下扮演的角色是<strong>审核人</strong>(Reviewer).</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">approveChapter</span><span class="token punctuation">(</span><span class="token keyword">long</span> chapterId<span class="token punctuation">,</span> <span class="token keyword">long</span> reviewerUserId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>从某种意义上来说, 这个坏味道也是一种不精准的命名, 但它不是那种一眼可见的坏味道, <strong>而是需要在业务层面上再进行讨论</strong>, 所以它是一种更高级的坏味道.</p> <p>我初入职场的时候, 有一次为一个名字陷入了沉思, 一个工作经验丰富的同事对此的评价是: 你开始进阶了. 确实, <strong>能够意识到自己的命名有问题, 是程序员进阶的第一步</strong>.</p> <h5 id="_3-总结时刻"><a href="#_3-总结时刻" class="header-anchor">#</a> 3.总结时刻</h5> <p>今天讲了两个典型的命名坏味道:</p> <ol><li>不精准的命名;</li> <li>用技术术语命名.</li></ol> <p>命名是软件开发中两件难事之一(另一个难事是缓存失效), 不好的命名本质上会增加认知成本, 同样也增加了后来人(包括我们自己)维护代码的成本.</p> <p><mark><strong>好的命名要体现出这段代码在做的事情, 而无需展开代码了解其中的细节, 这是最低的要求. 再进一步, 好的命名要准确地体现意图, 而不是实现细节. 更高的要求是, 用业务语言写代码.</strong></mark></p> <p>如果今天的内容你只能记住一件事, 那请记住: <mark><strong>好的命名, 是体现业务含义的命名</strong></mark>.</p> <p>至此, 已经对命名有了一个更深入的认识. 下一讲来说说国外那些经典的讲编码的书都不曾覆盖到的一个话题: 英文命名.</p> <h4 id="乱用英语-站在中国人的视角来看英文命名"><a href="#乱用英语-站在中国人的视角来看英文命名" class="header-anchor">#</a> 乱用英语:站在中国人的视角来看英文命名</h4> <p>上一讲讲了两种常见的命名的坏味道, 这一讲的话题还是命名, 只不过这个主题是国外那些经典编程书籍所不曾涵盖的话题: 英语命名.</p> <p>现在主流的程序设计语言都是以英语为基础的, 且不说欧美人设计的各种语言, 就连日本人设计的 Ruby, 巴西人设计的 Lua, 各种语法采用的也全都是英语. 所以想要成为一个优秀的程序员, 会用英语写代码是必要的.</p> <p>这里并不是说, 程序员的英语一定要多好, 但<strong>最低限度的要求是写出来的代码要像是在用英语表达</strong>.</p> <p>来看看有哪些可能会不经意间忽略的坏味道.</p> <h5 id="_1-违反语法规则的命名"><a href="#_1-违反语法规则的命名" class="header-anchor">#</a> 1.违反语法规则的命名</h5> <p>来看一段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">completedTranslate</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ChapterId</span><span class="token punctuation">&gt;</span></span> chapterIds<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Chapter</span><span class="token punctuation">&gt;</span></span> chapters <span class="token operator">=</span> repository<span class="token punctuation">.</span><span class="token function">findByChapterIdIn</span><span class="token punctuation">(</span>chapterIds<span class="token punctuation">)</span><span class="token punctuation">;</span>
    chapters<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">Chapter</span><span class="token operator">::</span><span class="token function">completedTranslate</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    repository<span class="token punctuation">.</span><span class="token function">saveAll</span><span class="token punctuation">(</span>chapters<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>初看之下, 这段代码写得还不错, 它要做的是将一些章节的信息标记为翻译完成. 似乎函数名也能反映这个意思, 但仔细一看就会发现问题.</p> <p>因为 completedTranslate 并不是一个正常的英语函数名. 从这个名字能看出, 作者想表达的是 &quot;完成翻译&quot;, 因为是已经翻译完了, 所以他用了完成时的 completed, 而翻译是 translate. 这个函数名就成了 completedTranslate. 由此可以看到, 作者已经很用心了, 但遗憾的是, 这个名字还是起错了.</p> <p>一般来说, 常见的命名规则是: <mark><strong>类名是一个名词, 表示一个对象, 而方法名则是一个动词, 或者是动宾短语, 表示一个动作</strong></mark>.</p> <p>以此为标准衡量这个名字, completedTranslate 并不是一个有效的动宾结构. 如果把这个名字改成动宾结构, 只要把 &quot;完成&quot; 译为 complete, &quot;翻译&quot; 用成它的名词形式 translation 就可以了. 所以这个函数名可以改成 completeTranslation:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">completeTranslation</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ChapterId</span><span class="token punctuation">&gt;</span></span> chapterIds<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Chapter</span><span class="token punctuation">&gt;</span></span> chapters <span class="token operator">=</span> repository<span class="token punctuation">.</span><span class="token function">findByChapterIdIn</span><span class="token punctuation">(</span>chapterIds<span class="token punctuation">)</span><span class="token punctuation">;</span>
    chapters<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">Chapter</span><span class="token operator">::</span><span class="token function">completeTranslation</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    repository<span class="token punctuation">.</span><span class="token function">saveAll</span><span class="token punctuation">(</span>chapters<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这并不是一个复杂的坏味道, 但这种坏味道在代码中却时常可以见到, 比如一个函数名是 retranslation, 其表达的意图是重新翻译, <strong>但作为函数名, 它应该是一个动词</strong>, 所以正确的命名应该是 retranslate.</p> <p>其实, 只要懂得最基本的命名要求, 知道最基本的英语规则, 就完全能够发现这里的坏味道. 比如判断函数名里的动词是不是动词, 宾语是不是一个名词? 这并不需要英语有多么好. 自己实在拿不准的时候, 就把这个词放到字典网站中查一下, 确保别用错词性就好.</p> <h5 id="_2-不准确的英语词汇"><a href="#_2-不准确的英语词汇" class="header-anchor">#</a> 2.不准确的英语词汇</h5> <p>有一次, 我们要实现一个章节审核的功能, 一个同事先定义出了审核的状态:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">ChapterAuditStatus</span> <span class="token punctuation">{</span>
    <span class="token constant">PENDING</span><span class="token punctuation">,</span>
    <span class="token constant">APPROVED</span><span class="token punctuation">,</span>
    <span class="token constant">REJECTED</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>你觉得这段代码有问题吗? 如果看不出来, 一点都不奇怪. 如果审核作为关键字去字典网站上搜索, 确实会得到 audit 这个词. 所以, 审核状态写成 AuditStatus 简直是再正常不过的事情了.</p> <p>然而, 看到这个词的时候, 我的第一反应就是这个词好像不太对. 因为之前我实现了一个作品审核的功能, 不过我写的定义是这样的:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">BookReviewStatus</span> <span class="token punctuation">{</span>
    <span class="token constant">PENDING</span><span class="token punctuation">,</span>
    <span class="token constant">APPROVED</span><span class="token punctuation">,</span>
    <span class="token constant">REJECTED</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>抛开前缀不看, 同样是审核, 一个用了 audit, 一个用了 review. 这显然是一种不一致. 本着代码一致性的考虑, 我希望这两个定义应该采用同样的词汇.</p> <p>于是, 我把 audit 和 review 同时放到了搜索引擎里查了一下. 原来 audit 会有更官方的味道, 更合适的翻译应该是审计, 而 review 则有更多核查的意思, 二者相比, review 更适合这里的场景. 于是, 章节的审核状态也统一使用了 review:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">ChapterReviewStatus</span> <span class="token punctuation">{</span>
    <span class="token constant">PENDING</span><span class="token punctuation">,</span>
    <span class="token constant">APPROVED</span><span class="token punctuation">,</span>
    <span class="token constant">REJECTED</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>相比之下, 这个坏味道是一个高级的坏味道, 英语单词用得不准确. 但这个问题确实是国内程序员不得不面对的一个尴尬的问题, 我们的英语可能没有那么好, 体会不到不同单词之间的差异.</p> <p>很多人习惯的做法就是把中文的词扔到字典网站, 然后从诸多返回的结果中找一个自己看着顺眼的, 而这也往往是很多问题出现的根源. 这样写出来的程序看起来就像一个外国人在说中文, 虽然你知道他在说的意思, 但总觉得哪里怪怪的.</p> <p><strong>在这种情况下, 最好的解决方案还是建立起一个业务词汇表, 千万不要臆想.</strong>  一般情况下, 都可以去和业务方谈, 共同确定一个词汇表, 包含业务术语的中英文表达. 这样在写代码的时候, 就可以参考这个词汇表给变量和函数命名.</p> <p>下面是一个词汇表的示例, 从这个词汇表中不难看出: 一方面, 词汇表给出的都是业务术语, 同时也给出了在特定业务场景下的含义; 另一方面, 它也给出了相应的英文, 省得费劲心思去思考. 当遇到了一个词汇表中没有的术语怎么办呢? 那就需要找出这个术语相应的解释, 然后补充到术语表里.</p> <p><img src="/img/6e58254a89a7e9a9569d17ad446659f0-20230729224950-bjifpad.png" alt=""></p> <p>建立词汇表的另一个关键点就是, <strong>用集体智慧, 而非个体智慧</strong>. 一个人的英语可能没那么好, 但一群人总会找出一个合适的说法. 我在《软件设计之美》里讲到领域驱动设计时, 曾经讲过通用语言, 其实业务词汇表也应该是构建通用语言的一部分成果.</p> <h5 id="_3-英语单词的拼写错误"><a href="#_3-英语单词的拼写错误" class="header-anchor">#</a> 3.英语单词的拼写错误</h5> <p>再给你看一段曾经让我迷惑不已的代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuerySort</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">SortBy</span> sortBy<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">SortFiled</span> sortFiled<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>初看这段代码时, 我还想表扬代码的作者, 他知道把查询的排序做一个封装, 比起那些把字符串传来传去的做法要好很多.</p> <p>但仔细看一下代码, 我脑子里就冒出了一系列问号. sortFiled 是啥? 排序文件吗? 为啥用的还是过去式? 归档?</p> <p>被这段代码搞晕的我只好打开提交历史, 找出这段代码的作者, 向他求教.</p> <blockquote><p>我: 这个字段是啥意思?</p> <p>同事: 这是排序的字段啊.</p> <p>我: 排序的字段?</p> <p>同事: 你看, 这个查询排序类有两个字段, 一个是排序的方式, 升序还是降序, 另一个就是排序的字段.</p> <p>我: 字段这个单词是这么拼吗?</p> <p>同事: 不是吗? 哦! 是 field, 拼错了, 拼错了.</p></blockquote> <p>是他把单词拼错了.</p> <p>其实, 偶尔的拼写错误是不可避免的, 这就像写文章的时候, 出现错别字也是难免的. 之所以要在这个专栏中把拼写错误作为一种独立的坏味道, 是因为在很多国内程序员写的程序中, 见到的拼写错误比例是偏高的.</p> <p>在这个故事里面, 我都已经当面指出了问题, 这个同事甚至都没有第一时间意识到自己的拼写是错误的, 这其实说明了一种尴尬的现状: **很多程序员对英语的感觉并没有那么强. **</p> <p>事实上, 这个同事不止一次在代码里出现拼写错误了, 一些拼写错误是很直白的, 一眼就能看出来, 所以通常在代码评审的时候就能发现问题. 这次的拼写错误刚好形成了另外一个有含义的单词, 所以, 我也被困住了.</p> <p>对今天的程序员来说, 工具已经很进步了, <strong>像 IntelliJ IDEA 这样的 IDE 可以提示代码里有拼写错误(typo)</strong> , 不少支持插件的工具也都有自己的拼写检查插件, 比如 Visual Studio Code 就有自己的拼写检查插件. 在这些工具的帮助之下, 只要稍微注意一下, 就可以修正很多这样低级的错误.</p> <h5 id="_4-总结时刻"><a href="#_4-总结时刻" class="header-anchor">#</a> 4.总结时刻</h5> <p>今天讲了几个英语使用不当造成的坏味道:</p> <ol><li><strong>违反语法规则的命名;</strong></li> <li><strong>不准确的英语词汇;</strong></li> <li><strong>英语单词的拼写错误.</strong></li></ol> <p>这是国内程序员因为语言关系而造成的坏味道, 英语是目前软件开发行业的通用语言, 一个程序员要想写好程序, 要对程序中用到的英语有一个基本的感觉, 能够发现代码中的这些坏味道.</p> <p>其实, 还有一些常见的与语言相关的坏味道, 因为比较初级, 放在这里给你提个醒, 比如:</p> <ol><li>使用拼音进行命名;</li> <li>使用不恰当的单词简写(比如, 多个单词的首字母, 或者写单词其中的一部分).</li></ol> <p>本节还讨论了如何从实践层面上更好地规避这些坏味道:</p> <ol><li><strong>制定代码规范, 比如, 类名要用名词, 函数名要用动词或动宾短语;</strong></li> <li>要建立团队的词汇表;</li> <li>要经常进行代码评审.</li></ol> <p>命名之所以如此重要, 因为它是一切代码的基础. 就像写文章一样, 一个错别字满天飞的文章, 很难让人相信它会是一篇好的文章, 所以命名的重要性是如何强调都不为过的.</p> <p>如果今天的内容你只能记住一件事, 那请记住: **编写符合英语语法规则的代码. **</p> <h4 id="重复代码-简单需求到处修改-怎么办"><a href="#重复代码-简单需求到处修改-怎么办" class="header-anchor">#</a> 重复代码:简单需求到处修改,怎么办?</h4> <p>前面两讲讨论了命名中的坏味道. 今天来讨论另外一个常见的坏味道: <strong>重复代码</strong>.</p> <p>很多初级程序员写代码依然规避不了复制粘贴, 基本的做法就是把一段代码复制过来, 改动几个地方, 跑一下没有太大问题就万事大吉了. 殊不知, 这种做法就是在给未来挖坑.</p> <p>通常情况下, <strong>只要这些复制代码其中有一点逻辑要修改, 就意味着所有复制粘贴的地方都要修改</strong>. 所以在实际的项目中, 常常看见这样的情况: 明明是一个简单的需求, 却需要改很多的地方, 需要花费很长的时间, 结果无论是项目经理, 还是产品经理, 对进度都很不满意. 只要少改了一处, 就意味着留下一处潜在的问题. 问题会在不经意间爆发出来, 让人陷入难堪的境地.</p> <p>复制粘贴是最容易产生重复代码的地方, 所以一个最直白的建议就是, 不要使用复制粘贴. <mark><strong>真正应该做的是, 先提取出函数, 然后, 在需要的地方调用这个函数</strong></mark>​ <strong>.</strong></p> <p>其实, 复制粘贴的重复代码是相对容易发现的, 但有一些代码是有类似的结构, 这也是重复代码, 有些人对这类坏味道却视而不见.</p> <h5 id="_1-重复的结构"><a href="#_1-重复的结构" class="header-anchor">#</a> 1.重复的结构</h5> <p>看一下下面的几段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Task</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendBook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>service<span class="token punctuation">.</span><span class="token function">sendBook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>notification<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SendFailure</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Task</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendChapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>service<span class="token punctuation">.</span><span class="token function">sendChapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>notification<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SendFailure</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Task</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">startTranslation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>service<span class="token punctuation">.</span><span class="token function">startTranslation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>notification<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SendFailure</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>这三段函数业务的背景是: 一个系统要把作品的相关信息发送给翻译引擎. 所以结合着代码, 就不难理解它们的含义, sendBook 是把作品信息发出去, sendChapter 就是把章节发送出去, 而 startTranslation 则是启动翻译.</p> <p>这几个业务都是以后台的方式在执行, 所以它们的函数签名上增加了一个 Task 的 Annotation, 表明它们是任务调度的入口. 然后实际的代码执行放到了对应的业务方法上, 也就是 service 里面的方法.</p> <p>这三个函数可能在许多人看来已经写得很简洁了, 但是这段代码的结构上却是有重复的, 请把注意力放到 catch 语句里.</p> <p>之所以要做一次捕获(catch), 是为了防止系统出问题无人发觉. 捕获到异常后, 把出错的信息通过即时通讯工具发给相关人等, 代码里的 notification.send 就是发通知的入口. 相比于原来的业务逻辑, 这个逻辑是后来加上的, 所以这段代码的作者不厌其烦地在每一处修改了代码.</p> <p>可以看到, 虽然这三个函数调用的业务代码不同, 但它们的结构是一致的, 其基本流程可以理解为:</p> <ol><li>调用业务函数;</li> <li>如果出错, 发通知.</li></ol> <p>当你能够发现结构上的重复, 就可以把这个结构提取出来. 从面向对象的设计来说, 就是提出一个接口, 就像下面这样:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">executeTask</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Runnable</span> runnable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        runnable<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>notification<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SendFailure</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>有了这个结构, 前面几个函数就可以用它来改写了. 对于支持函数式编程的程序设计语言来说, 可以用语言提供的便利写法简化代码的编写, 像下面的代码就是用了 Java 里的方法引用(Method Reference):</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Task</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendBook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">executeTask</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>service<span class="token operator">::</span><span class="token function">sendBook</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Task</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendChapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">executeTask</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>service<span class="token operator">::</span><span class="token function">sendChapter</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Task</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">startTranslation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">executeTask</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>service<span class="token operator">::</span><span class="token function">startTranslation</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>经过这个例子的改写, 如果再有一些通用的结构调整, 比如在任务执行前后要加上一些日志信息, 这样的改动就可以放到 executeTask 这个函数里, 而不用四处去改写了.</p> <p>这个例子并不复杂, 关键点在于, <strong>能不能发现结构上的重复</strong>. 因为相比于直接复制的代码, 结构上的重复看上去会有一些迷惑性. 比如在这个例子里, 发送作品信息, 发送章节, 启动翻译看起来是三件不同的事, 很难让人一下反应过来它也是重复代码.</p> <p>一般来说, 参数是名词, 而函数调用, 是动词. 传统的程序设计教育中, 对于名词是极度重视的, 但必须认识到一点, 动词也扮演着重要的角色, 尤其是在函数式编程兴起之后. 那就需要知道, 动词不同时, 并不代表没有重复代码产生.</p> <p>理解到这一点, 就容易发现结构上的相似之处. 比如在上面的例子中, 发送作品信息, 发送章节, 启动翻译之所以看上去是三件不同的事, 只是因为它们的动词不同, 但是除了这几个动词之外的其它部分是相同的, 所以它们在结构上是重复的.</p> <h5 id="_2-做真正的选择"><a href="#_2-做真正的选择" class="header-anchor">#</a> 2.做真正的选择</h5> <p>再来看一段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">isEditor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    service<span class="token punctuation">.</span><span class="token function">editChapter</span><span class="token punctuation">(</span>chapterId<span class="token punctuation">,</span> title<span class="token punctuation">,</span> content<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    service<span class="token punctuation">.</span><span class="token function">editChapter</span><span class="token punctuation">(</span>chapterId<span class="token punctuation">,</span> title<span class="token punctuation">,</span> content<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这是一段对章节内容进行编辑的代码. 这里有一个业务逻辑, 章节只有在审核通过之后, 才能去做后续的处理, 比如, 章节的翻译. 所以这里的 editChapter 方法最后那个参数表示是否审核通过.</p> <p>在这段代码里面, 目前的处理逻辑是, 如果这个章节是由作者来编辑的, 那么这个章节是需要审核的, 如果这个章节是由编辑来编辑的, 那么审核就直接通过了, 因为编辑本身同时也是审核人. 不过这里的业务逻辑不是重点, 只是帮助你理解这段代码.</p> <p>问题来了, 这个 if 选择的到底是什么呢?</p> <p>相信你和我一样, 第一眼看到这段代码的感觉一定是, if 选择的一定是两段不同的业务处理. 但只要稍微看一下, 就会发现, if 和 else 两段代码几乎是一模一样的. 在经过仔细地 &quot;找茬&quot; 之后, 才能发现, 原来是最后一个参数不一样.</p> <p>只有参数不同, 是不是和前面说的重复代码是如出一辙的? 没错, 这其实也是一种重复代码.</p> <p>只不过, 这种重复代码通常情况下是作者自己写出来的, 而不是粘贴出来的. 因为作者在写这段代码时, **脑子只想到 if 语句判断之后要做什么, 而没有想到这个 if 语句判断的到底是什么. **但这段代码客观上也造就了重复.</p> <p>写代码要有表达性. 把意图准确地表达出来, 是写代码过程中非常重要的一环. 显然, 这里的 if 判断区分的是参数, 而非动作. 所以可以把这段代码稍微调整一下, 会让代码看上去更容易理解:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">boolean</span> approved <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">isEditor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
service<span class="token punctuation">.</span><span class="token function">editChapter</span><span class="token punctuation">(</span>chapterId<span class="token punctuation">,</span> title<span class="token punctuation">,</span> content<span class="token punctuation">,</span> approved<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>请注意, 这里把 user.isEditor() 判断的结果赋值给了一个 approved 的变量, 而不是直接作为一个参数传给 editChapter, 这么做也是为了<strong>提高这段代码的可读性</strong>. 因为 editChapter 最后一个参数表示的是这个章节是否审核通过. 通过引入 approved 变量, 可以清楚地看到, 一个章节审核是否通过的判断条件是 &quot;用户是否是一个编辑&quot;, 这种写法会让代码更清晰.</p> <p>如果将来审核通过的条件改变了, 变化的点全都在 approved 的这个变量的赋值上面. 如果你追求更有表达性的做法, 甚至可以提取一个函数出来, 这样, 就把变化都放到这个函数里了, 就像下面这样:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">boolean</span> approved <span class="token operator">=</span> <span class="token function">isApproved</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
service<span class="token punctuation">.</span><span class="token function">editChapter</span><span class="token punctuation">(</span>chapterId<span class="token punctuation">,</span> title<span class="token punctuation">,</span> content<span class="token punctuation">,</span> approved<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isApproved</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> user<span class="token punctuation">.</span><span class="token function">isEditor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>为了说明问题, 我特意选择了一段简单的代码, if 语句的代码块里只有一个语句. 在实际的工作中, if 语句没有有效地去选择目标是经常出现的, 有的是参数列表比较长, 有的是在 if 的代码块里有多个语句.</p> <p>所以, <strong>只要看到 if 语句出现, 而且 if 和 else 的代码块长得又比较像, 多半就是出现了这个坏味道.</strong></p> <p>重复是一个泥潭, 对于程序员来说, 时刻提醒自己不要重复是至关重要的. 在软件开发里, 有一个重要的原则叫做 Don't Repeat Yourself(不要重复自己, 简称 <strong>DRY</strong>), 经典的叙述在《程序员修炼之道》中.</p> <blockquote><p>在一个系统中, 每一处知识都必须有单一, 明确, 权威地表述.</p> <p>Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.</p></blockquote> <p><strong>写代码要想做到 DRY, 一个关键点是能够发现重复</strong>. 发现重复, 一种是在泥潭中挣扎后, 被动地发现, 还有一种是提升自己识别能力, 主动地发现重复. 这种主动识别的能力, 其实背后要有对软件设计更好的理解, 尤其是对分离关注点的理解.</p> <h5 id="_3-总结时刻-2"><a href="#_3-总结时刻-2" class="header-anchor">#</a> 3.总结时刻</h5> <p>这一讲讲到重复代码, 讲到了几个典型的坏味道:</p> <ol><li><strong>复制粘贴的代码;</strong></li> <li><strong>结构重复的代码;</strong></li> <li><strong>if 和 else 代码块中的语句高度类似.</strong></li></ol> <p>很多重复代码的产生通常都是从程序员偷懒开始的, 而这些程序员的借口都是为了快, 却为后续工作埋下更多地隐患, 真正的 &quot;欲速而不达&quot;.</p> <p>复制粘贴的代码和结构重复的代码, 虽然从观感上有所差异, 但本质上都是重复, 只不过, 一个是名词的微调, 一个是动词的微调. 程序员千万不要复制粘贴, <strong>如果需要复制粘贴, 首先应该做的是提取一个新的函数出来, 把公共的部分先统一掉.</strong></p> <p>if 和 else 的代码块中的语句高度类似, 通常是程序员不经意造成的, 但这也是对于写代码没有高标准要求的结果. 让 if 语句做真正的选择, 是提高代码表达准确性的重要一步.</p> <p>作为一个精进中的程序员, 一定要把 DRY 原则记在心中, 时时刻刻保持对 &quot;重复&quot; 的敏感度, 把各种重复降到最低.</p> <p>如果今天的内容你只能记住一件事, 那请记住: <strong>不要重复自己, 不要复制粘贴</strong>.</p> <h4 id="长函数-为什么你总是不可避免地写出长函数"><a href="#长函数-为什么你总是不可避免地写出长函数" class="header-anchor">#</a> 长函数:为什么你总是不可避免地写出长函数?</h4> <p>只要一提到长函数, 无论是去被迫理解一个长函数的含义, 还是要在一个长函数中, 小心翼翼地找出需要的逻辑, 按照需求微调一下, 几乎所有程序员都会有不愉悦的回忆. 可以这么说, 没有人喜欢长函数, 但在实际工作中, 却不得不去与各种长函数打交道.</p> <p>不知道你在实际工作中遇到最长的函数有多长, 几百上千行的函数肯定是不足以称霸的. 在我的职业生涯中, 经常是我以为自己够见多识广了, 但只要新接触到一个有悠久历史的代码库, 就总会有突破认知的长函数出现.</p> <p>为了统一认识, 先讨论一下多长的函数算是长函数, 来看一个案例.</p> <h5 id="_1-多长的函数才算-长"><a href="#_1-多长的函数才算-长" class="header-anchor">#</a> 1.多长的函数才算&quot;长&quot;?</h5> <p>有一次, 我在一个团队做分享, 讲怎么把一个长函数重构成小函数. 现场演示之后, 我问了大家一个问题: 在你心目中, 多长的函数才算长呢?</p> <p>一个现场听众很认真地思考了一下, 给出了一个答案: 100 行. 我很尴尬地看了一下自己刚刚重构掉的两个函数, 最长的一个都不到 100 行. 换言之, 以他的标准来看, 这个函数根本就不是长函数, 根本就没有必要重构.</p> <p><strong>对于函数长度容忍度高, 这是导致长函数产生的关键点</strong>.</p> <p>如果一个人认为 100 行代码不算长, 那在他眼中, 很多代码根本就是没有问题的, 也就更谈不上看到更多问题了, 这其实是一个观察尺度的问题. 这就好比, 没有电子显微镜之前, 人们很难理解疾病的原理, 因为看不到病毒, 就不可能理解病毒可以致病这个道理.</p> <p><strong>一个好的程序员面对代码库时要有不同尺度的观察能力, 看设计时, 要能够高屋建瓴, 看代码时, 要能细致入微</strong>.</p> <p>这里的要点就是, 看具体代码时, 一定要能够看到细微之处. &quot;任务分解&quot; 的关键点就是将任务拆解得越小越好, 这个观点对代码同样适用. 随着对代码长度容忍度的降低, 对代码细节的感知力就会逐渐提升, 才能看到那些原本所谓细枝末节的地方隐藏的各种问题.</p> <p>回到具体的工作中, &quot;越小越好&quot; 是一个追求的目标, 不过, 没有一个具体的数字, 就没办法约束所有人的行为. 所以, 通常情况下, 还是要定义出一个代码行数的上限, 以保证所有人都可以按照这个标准执行.</p> <p>我自己写代码的习惯是这样的. 像 Python, Ruby 这样表达能力比较强的动态语言, 大多数情况下, 一行代码(one-liner program)可以解决很多问题, 所以, 我对自己的要求大约是 5 行左右, 并且能够用一行代码解决的问题, 就尽量会用一行代码解决; 而像 Java 这样表达能力稍弱的静态类型语言, 我也争取在 10 行代码之内解决问题.</p> <p>当然, 这是我对自己的要求, 在实际的项目中, 可能不是每个人都能做到这一点, 所以, 我给了一个更为宽松的限制, 在自己的标准上翻了番, 也就是 20 行.</p> <p>这不是一个说说就算的标准, 应该把它变成一个可执行的标准. 比如在 Java 中, 可以把代码行的约束加到 CheckStyle 的配置文件中, 就像下面这样:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token operator">&lt;</span><span class="token keyword">module</span> <span class="token namespace">name</span><span class="token operator">=</span><span class="token string">&quot;MethodLength&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">&quot;tokens&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;METHOD_DEF&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">&quot;max&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;20&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">&quot;countEmpty&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;false&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">module</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这样在提交代码之前, 执行本地的构建脚本, 就可以把长函数检测出来.</p> <p>即便是以 20 行为上限, 这也已经超过很多人的认知, 具体的函数行数可以结合团队的实际情况来制定, 但我非常不建议把这个数字放得很大, 就像前面说的那样, 如果放到 100 行, 这个数字基本上是没有太多意义的, 对团队也起不到什么约束作用.</p> <p>之所以要先讨论多长的函数算是长函数, 是因为如果不能认识到代码行的标准应该很低, 那么在接下来的讨论中, 有些代码示例可能在你看来, 就根本不需要调整了.</p> <h5 id="_2-长函数的产生"><a href="#_2-长函数的产生" class="header-anchor">#</a> 2.长函数的产生</h5> <p>不过, 限制函数长度, 是一种简单粗暴的解决方案. 最重要的是要知道, 长函数本身是一个结果, 如果不理解长函数产生的原因, 还是很难写出整洁的代码. 接下来就来看看长函数是怎么产生的.</p> <blockquote><p>平铺直叙</p></blockquote> <p>有一种最常见的原因会把代码写长, 那就是写代码平铺直叙, 把自己想到的一点点罗列出来. 比如下面这段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">executeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ObjectMapper</span> mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">CloseableHttpClient</span> client <span class="token operator">=</span> <span class="token class-name">HttpClients</span><span class="token punctuation">.</span><span class="token function">createDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Chapter</span><span class="token punctuation">&gt;</span></span> chapters <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>chapterService<span class="token punctuation">.</span><span class="token function">getUntranslatedChapters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Chapter</span> chapter <span class="token operator">:</span> chapters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Send Chapter</span>
        <span class="token class-name">SendChapterRequest</span> sendChapterRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SendChapterRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sendChapterRequest<span class="token punctuation">.</span><span class="token function">setTitle</span><span class="token punctuation">(</span>chapter<span class="token punctuation">.</span><span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sendChapterRequest<span class="token punctuation">.</span><span class="token function">setContent</span><span class="token punctuation">(</span>chapter<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">HttpPost</span> sendChapterPost <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpPost</span><span class="token punctuation">(</span>sendChapterUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">CloseableHttpResponse</span> sendChapterHttpResponse <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> chapterId <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> sendChapterRequestText <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>sendChapterRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>
            sendChapterPost<span class="token punctuation">.</span><span class="token function">setEntity</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringEntity</span><span class="token punctuation">(</span>sendChapterRequestText<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            sendChapterHttpResponse <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>sendChapterPost<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">HttpEntity</span> sendChapterEntity <span class="token operator">=</span> sendChapterPost<span class="token punctuation">.</span><span class="token function">getEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">SendChapterResponse</span> sendChapterResponse <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>sendChapterEntity<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                                                       <span class="token class-name">SendChapterResponse</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            chapterId <span class="token operator">=</span> sendChapterResponse<span class="token punctuation">.</span><span class="token function">getChapterId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>sendChapterHttpResponse <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    sendChapterHttpResponse<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// ignore</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Translate Chapter</span>
        <span class="token class-name">HttpPost</span> translateChapterPost <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpPost</span><span class="token punctuation">(</span>translateChapterUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">CloseableHttpResponse</span> translateChapterHttpResponse <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">TranslateChapterRequest</span> translateChapterRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TranslateChapterRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            translateChapterRequest<span class="token punctuation">.</span><span class="token function">setChapterId</span><span class="token punctuation">(</span>chapterId<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">String</span> translateChapterRequestText <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>translateChapterRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>
            translateChapterPost<span class="token punctuation">.</span><span class="token function">setEntity</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringEntity</span><span class="token punctuation">(</span>translateChapterRequestText<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            translateChapterHttpResponse <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>translateChapterPost<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">HttpEntity</span> translateChapterEntity <span class="token operator">=</span> translateChapterHttpResponse<span class="token punctuation">.</span><span class="token function">getEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">TranslateChapterResponse</span> translateChapterResponse <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>
                translateChapterEntity<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">TranslateChapterResponse</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>translateChapterResponse<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">&quot;Fail to start translate: {}&quot;</span><span class="token punctuation">,</span> chapterId<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>translateChapterHttpResponse <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    translateChapterHttpResponse<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// ignore</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br></div></div><p>这段代码的逻辑是, 把没有翻译过的章节发到翻译引擎, 然后启动翻译过程. 在这里翻译引擎是另外一个服务, 需要通过 HTTP 的形式向它发送请求. 相对而言, 这段代码还算直白, 当知道了上面所说的逻辑, 是很容易看懂这段代码的.</p> <p>这段代码之所以很长, 主要原因就是<strong>把前面所说的逻辑全部平铺直叙地摆在那里</strong>了, 这里既有业务处理的逻辑, 比如, 把章节发送给翻译引擎, 然后, 启动翻译过程; 又有处理的细节, 比如把对象转成 JSON, 然后, 通过 HTTP 客户端发送出去.</p> <p>从这段代码中, 可以看到平铺直叙的代码存在的两个典型问题:</p> <ol><li><strong>把多个业务处理流程放在一个函数里实现</strong>;</li> <li><strong>把不同层面的细节放到一个函数里实现</strong>.</li></ol> <p>这里发送章节和启动翻译是两个过程, 显然, 这是可以放到两个不同的函数中去实现的, 所以只要做一下提取函数, 就可以把这个看似庞大的函数拆开, 而拆出来的几个函数规模都会小很多, 像下面这样:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">executeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ObjectMapper</span> mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">CloseableHttpClient</span> client <span class="token operator">=</span> <span class="token class-name">HttpClients</span><span class="token punctuation">.</span><span class="token function">createDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Chapter</span><span class="token punctuation">&gt;</span></span> chapters <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>chapterService<span class="token punctuation">.</span><span class="token function">getUntranslatedChapters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Chapter</span> chapter <span class="token operator">:</span> chapters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> chapterId <span class="token operator">=</span> <span class="token function">sendChapter</span><span class="token punctuation">(</span>mapper<span class="token punctuation">,</span> client<span class="token punctuation">,</span> chapter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">translateChapter</span><span class="token punctuation">(</span>mapper<span class="token punctuation">,</span> client<span class="token punctuation">,</span> chapterId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>拆出来的部分, 实际上就是把对象打包发送的过程, 以发送章节为例, 先来看拆出来的发送章节部分:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">sendChapter</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">ObjectMapper</span> mapper<span class="token punctuation">,</span>
                           <span class="token keyword">final</span> <span class="token class-name">CloseableHttpClient</span> client<span class="token punctuation">,</span>
                           <span class="token keyword">final</span> <span class="token class-name">Chapter</span> chapter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">SendChapterRequest</span> request <span class="token operator">=</span> <span class="token function">asSendChapterRequest</span><span class="token punctuation">(</span>chapter<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">CloseableHttpResponse</span> response <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> chapterId <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token class-name">HttpPost</span> post <span class="token operator">=</span> <span class="token function">sendChapterRequest</span><span class="token punctuation">(</span>mapper<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>
        response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>post<span class="token punctuation">)</span><span class="token punctuation">;</span>
        chapterId <span class="token operator">=</span> <span class="token function">asChapterId</span><span class="token punctuation">(</span>mapper<span class="token punctuation">,</span> post<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>response <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                response<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// ignore</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> chapterId<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token class-name">HttpPost</span> <span class="token function">sendChapterRequest</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">ObjectMapper</span> mapper<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">SendChapterRequest</span> sendChapterRequest<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">JsonProcessingException</span><span class="token punctuation">,</span> <span class="token class-name">UnsupportedEncodingException</span> <span class="token punctuation">{</span>
    <span class="token class-name">HttpPost</span> post <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpPost</span><span class="token punctuation">(</span>sendChapterUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> requestText <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>sendChapterRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>
    post<span class="token punctuation">.</span><span class="token function">setEntity</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringEntity</span><span class="token punctuation">(</span>requestText<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> post<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">asChapterId</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">ObjectMapper</span> mapper<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">HttpPost</span> sendChapterPost<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> chapterId<span class="token punctuation">;</span>
    <span class="token class-name">HttpEntity</span> entity <span class="token operator">=</span> sendChapterPost<span class="token punctuation">.</span><span class="token function">getEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">SendChapterResponse</span> response <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>entity<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">SendChapterResponse</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    chapterId <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getChapterId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> chapterId<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token class-name">SendChapterRequest</span> <span class="token function">asSendChapterRequest</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Chapter</span> chapter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">SendChapterRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SendChapterRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    request<span class="token punctuation">.</span><span class="token function">setTitle</span><span class="token punctuation">(</span>chapter<span class="token punctuation">.</span><span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    request<span class="token punctuation">.</span><span class="token function">setContent</span><span class="token punctuation">(</span>chapter<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> request<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><p>当然, 这个代码还算不上已经处理得很整洁了, 但至少同之前相比, 已经简洁了一些. 只用了最简单的<strong>提取函数</strong>这个重构手法, 就把一个大函数拆分成了若干的小函数.</p> <p>顺便说一下, <strong>长函数往往还隐含着一个命名问题</strong>. 如果你看修改后的 sendChapter, 其中的变量命名明显比之前要短, 理解的成本也相应地会降低. 因为变量都是在这个短小的上下文里, 也就不会产生那么多的命名冲突, 变量名当然就可以写短一些.</p> <p><strong>平铺直叙的代码, 一个关键点就是没有把不同的东西分解出来</strong>. 如果用设计的眼光衡量这段代码, 这就是 &quot;分离关注点&quot; 没有做好, 把不同层面的东西混在了一起, 既有不同业务混在一起, 也有不同层次的处理混在了一起. <strong>关注点越多越好, 粒度越小越好.</strong></p> <blockquote><p>一次加一点</p></blockquote> <p>有时一段代码一开始的时候并不长, 就像下面这段代码, 它根据返回的错误进行相应地错误处理:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>code <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token number">400</span> <span class="token operator">||</span> code <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token number">401</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 做一些错误处理</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>然后, 新的需求来了, 增加了新的错误码, 它就变成了这个样子:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>code <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token number">400</span> <span class="token operator">||</span> code <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token number">401</span> <span class="token operator">||</span> code <span class="token operator">==</span> <span class="token number">402</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 做一些错误处理</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>一个有生命力的项目经常会延续很长时间, 于是这段代码有很多次被修改的机会, 日积月累, 它就成了让人不忍直视的代码, 比如:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>code <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token number">400</span> <span class="token operator">||</span> code <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token number">401</span> <span class="token operator">||</span> code <span class="token generics"><span class="token punctuation">&lt;</span>mark<span class="token punctuation">&gt;</span></span> <span class="token number">402</span> <span class="token operator">||</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">||</span> code <span class="token operator">&lt;</span><span class="token operator">/</span>mark<span class="token operator">&gt;</span> <span class="token number">500</span> <span class="token operator">||</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">||</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">||</span> code <span class="token operator">==</span> <span class="token number">10000</span> <span class="token operator">||</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 做一些错误处理</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>后来人看到这段代码就想骂人了. 当他从版本控制的历史中找到这些代码的作者, 去询问这些处理的来龙去脉时, 每个人其实都很委屈, 他们当时也没做太多, 只是加了一个判断条件而已.</p> <p><strong>任何代码都经不起这种无意识的累积, 每个人都没做错, 但最终的结果很糟糕.</strong>  对抗这种逐渐糟糕腐坏的代码, 需要知道 &quot;童子军军规&quot;:</p> <blockquote><p>让营地比你来时更干净. —— 童子军军规</p></blockquote> <p>Robert Martin 把它借鉴到了编程领域, 简言之, 我们应该看看自己对于代码的改动是不是让原有的代码变得更糟糕了, 如果是, 那就改进它. 但这一切的前提是, 要能看出自己的代码是不是让原有的代码变得糟糕了, 所以学习代码的坏味道还是很有必要的.</p> <h5 id="_3-总结时刻-3"><a href="#_3-总结时刻-3" class="header-anchor">#</a> 3.总结时刻</h5> <p>今天讲了程序员最深恶痛绝的坏味道: 长函数. 没有人愿意去阅读长函数, 但许多人又会不经意间写出长函数.</p> <p>毫无疑问, 长函数是一个坏味道. 对于团队而言, 一个关键点是要定义出长函数的标准. 不过, 过于宽泛的标准是没有意义的, 想要有效地控制函数规模, 几十行的函数已经是标准的上限了, 这个标准越低越好.</p> <p>还分析了长函数产生的原因:</p> <ol><li>有人把代码平铺直叙地摊在那里;</li> <li>有人只是每次增加了一点点.</li></ol> <p>其中, 平铺直叙是把函数写长最常见的原因. 之所以会把代码平摊在那里, 一方面是把多个业务写到了一起, 另一方面是把不同层次的代码写到了一起. 究其根因, 那是 &quot;分离关注点&quot; 没有做好.</p> <p>每次增加一点点, 是另外一个让代码变长的原因, 应对它的主要办法就是要坚守 &quot;童子军军规&quot;, 但其背后更深层次的支撑就是要对坏味道有着深刻的认识.</p> <p>如果今天的内容你只能记住一件事, 那请记住: <strong>把函数写短, 越短越好</strong>.</p> <h4 id="大类-如何避免写出难以理解的大类"><a href="#大类-如何避免写出难以理解的大类" class="header-anchor">#</a> 大类:如何避免写出难以理解的大类?</h4> <p>一听到大类, 估计你的眼前已经浮现出一片无边无际的代码了. 类之所以成为了大类, 一种表现形式就是上节讲到的长函数, 一个类只要有几个长函数, 那它就肯定是一眼望不到边了.</p> <p>大类还有一种表现形式, 类里面有<strong>特别多的字段和函数</strong>, 也许每个函数都不大, 但架不住数量众多, 这也足以让这个类在大类中占有一席之地. 这一讲, 我们就主要来说说这种形式的大类.</p> <h5 id="_1-分模块的程序"><a href="#_1-分模块的程序" class="header-anchor">#</a> 1.分模块的程序</h5> <p>先来问一个问题, 为什么不把所有的代码都写到一个文件里?</p> <p>你可能会觉得这个问题很傻, 心里想: 除了像练习之类的特定场景, 谁会在一个正经的项目上把代码写到一个文件里啊? 没错, 确实没有人这么做, 但你思考过原因吗? 把代码都写到一个文件里, 问题在哪里呢?</p> <p>事实是, 把代码写到一个文件里, 一方面, 相同的功能模块没有办法复用; 另一方面, 也是更关键的, 把代码都写到一个文件里, 其复杂度会超出一个人能够掌握的认知范围. 简言之, **一个人理解的东西是有限的, 没有人能同时面对所有细节. **</p> <p>人类面对复杂事物给出的解决方案是分而治之. 所以, 几乎各种程序设计语言都有自己的模块划分方案, 从最初的按照文件划分, 到后来, 使用面向对象方案按照类进行划分, 本质上, 它们都是一种模块划分的方式. 这样, 人们面对的就不再是细节, 而是模块, <strong>模块的数量显然会比细节数量少, 人们的理解成本就降低</strong>了.</p> <p>对程序进行模块划分, 本质上就是在把问题进行分解, 而这种做法的背后原因, 就是人类的认知能力是有限的.</p> <p>理解了这一点, 再回过头来看大类这个坏味道, 就知道问题出在哪了. <strong>如果一个类里面的内容太多, 它就会超过一个人的理解范畴, 顾此失彼就</strong>​******在**<strong><strong>​</strong>所难免了.</strong></p> <p>按照这个思路, 解决大类的方法也就随之而来了, 就是<strong>把大类拆成若干个小类</strong>. 你可能会想, 这我也知道, 问题是, 怎么拆呢?</p> <h5 id="_2-大类的产生"><a href="#_2-大类的产生" class="header-anchor">#</a> 2.大类的产生</h5> <p>想要理解怎么拆分一个大类, 需要知道, 这些类是怎么变成这么大的.</p> <blockquote><p>职责不单一</p></blockquote> <p>最容易产生大类的原因在于<strong>职责的不单一</strong>. 先来看一段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> userId<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> nickname<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> phoneNumber<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">AuthorType</span> authorType<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">ReviewStatus</span> authorReviewStatus<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">EditorType</span> editorType<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>这个 User 类拥有着一个大类的典型特征, 其中包含着一大堆的字段. 面对这样一个类时, 第一个问题就是, 这个类里的字段都是必需的吗?</p> <p>来稍微仔细地看一下这个类, 用户 ID(userId), 姓名(name), 昵称(nickname) 之类应该是一个用户的基本信息, 后面的邮箱(email), 电话号码(phoneNumber) 也算是和用户相关联的. 今天的很多应用都提供使用邮箱或电话号码登录的方式, 所以这个信息放在这里, 也算是可以理解.</p> <p>再往后看, 作者类型(authorType), 这里表示作者是签约作者还是普通作者, 签约作者可以设置作品的付费信息, 而普通作者不能. 后面的字段是作者审核状态(authorReviewStatus), 就是说, 作者成为签约作者, 需要有一个申请审核的过程, 这个状态就是审核的状态.</p> <p>再往后, 又出现了一个编辑类型(editorType), 编辑可以是主编, 也可以是小编, 他们的权限是不一样的.</p> <p>这还不是这个 User 类的全部. 但即便只看这些内容, 也足以发现一些问题了.</p> <p>首先, 普通的用户既不是作者, 也不是编辑. 作者和编辑这些相关的字段, 对普通用户来说, 都是没有意义的. 其次, 对于那些成为了作者的用户, 编辑的信息意义也不大, 因为作者是不能成为编辑的, 反之亦然, 编辑也不会成为作者, 作者信息对成为编辑的用户也是没有意义的.</p> <p>在这个类的设计里面, 总有一些信息对一部分人是没有意义, 但这些信息对于另一部分人来说又是必需的. 之所以会出现这样的状况, 关键点就在于, 这里只有 &quot;一个&quot; 用户类.</p> <p>普通用户, 作者, 编辑, 这是三种不同角色, 来自不同诉求的业务方关心的是不同的内容. 只是因为它们都是这个系统的用户, 就把它们都放到用户类里, 造成的结果就是, 任何业务方的需求变动, 都会让这个类反复修改. 这种做法实际上是<strong>违反了单一职责原则</strong>.</p> <p>单一职责原则是衡量软件设计好坏的一把简单而有效的尺子, 通常来说, 很多类之所以巨大, 大部分原因都是违反了单一职责原则. <strong>而想要破解 &quot;大类&quot; 的谜题, 关键就是能够把不同的职责拆分开来</strong>.</p> <p>回到这个类上, 其实前面已经分析了, 虽然这是一个类, 但它把不同角色关心的东西都放在了一起, 所以它变得如此庞大. 只要把不同的信息拆分开来, 问题也就迎刃而解了. 下面就是把不同角色拆分出来的结果:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> userId<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> nickname<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> phoneNumber<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Author</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> userId<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">AuthorType</span> authorType<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">ReviewStatus</span> authorReviewStatus<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Editor</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> userId<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">EditorType</span> editorType<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>这里拆分出了 Author 和 Editor 两个类, 把与作者和编辑相关的字段分别移到了这两个类里面. 在这两个类里面分别有一个 userId 字段, 用以识别这个角色是和哪个用户相关. 这个大 User 类就这样被分解了.</p> <blockquote><p>字段未分组</p></blockquote> <p>大类的产生往往还有一个常见的原因, 就是<strong>字段未分组</strong>.</p> <p>有时候, 我们会觉得有一些字段确实都是属于某个类, 结果就是, 这个类还是很大. 比如看一下上面拆分的结果, 那个新的 User 类:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> userId<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> nickname<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> phoneNumber<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>前面分析过, 这些字段应该都算用户信息的一部分. 但即便相比于原来的 User 类小了许多, 这个类依然也不算是一个小类, 原因就是, 这个类里面的字段<strong>并不属于同一种类型的信息</strong>. 比如, userId, name, nickname 几项, 算是用户的基本信息, 而 email, phoneNumber 这些则属于用户的联系方式.</p> <p>从需求上看, 基本信息是那种一旦确定就不怎么会改变的内容, 而联系方式则会根据实际情况调整, 比如, 绑定各种社交媒体的账号. 所以, 如果把这些信息都放到一个类里面, 这个类的稳定程度就要差一些. 所以可以根据这个理解, 把 User 类的字段分个组, 把不同的信息放到不同的类里面.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> userId<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> nickname<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Contact</span> contact<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Contact</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> phoneNumber<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>这里引入了一个 Contact 类(也就是联系方式), 把 email 和 phoneNumber 放了进去, 后面再有任何关于联系方式的调整就都可以放在这个类里面. 经过这次调整, 把不同的信息重新组合了一下, 但每个类都比原来要小.</p> <p>对比一下, 如果说前后两次拆分有什么不同, 那就是: <strong>前面是根据职责, 拆分出了不同的实体, 后面是将字段做了分组, 用类把不同的信息分别做了封装</strong>.</p> <p>或许你已经发现了, <strong>所谓</strong>​******的**<strong><strong>​</strong>将大类拆解成小类, 本质上在做的工作是一个设计工作</strong>. 分解的依据其实是单一职责这个重要的设计原则. 没错, 很多人写代码写不好, 其实是缺乏软件设计的功底, 不能有效地把各种模型识别出来. 所以, 想要写好代码, 还是要好好学学软件设计的.</p> <p>关于大类的讨论差不多就接近尾声了, 但有些人心中会升起一些疑问: 如果把大类都拆成小类, 类的数量就会增多, 那人们理解的成本是不是也会增加呢?</p> <p>其实, 这也是很多人不拆分大类的借口.</p> <p>在这个问题上, 程序设计语言早就已经有了很好的解决方案, 所以会看到在各种程序设计语言中, 有诸如包, 命名空间之类的机制, 将各种类组合在一起. 在不需要展开细节时, 面对的是一个类的集合. 再进一步, 还有各种程序库把这些打包出来的东西再进一步打包, 让我们只要面对简单的接口, 而不必关心各种细节.</p> <p>如此层层封装, 软件不就是这样构建出来的吗?</p> <h5 id="_3-总结时刻-4"><a href="#_3-总结时刻-4" class="header-anchor">#</a> 3.总结时刻</h5> <p>应对大类的解决方案, 主要是将大类拆分成小类. 需要认识到, 模块拆分, 本质上是帮助人们降低理解成本的一种方式.</p> <p>两种产生大类的原因:</p> <ol><li>职责不单一;</li> <li>字段未分组.</li></ol> <p>无论是哪种原因, 想要有效地对类进行拆分, 需要对不同内容的变动原因进行分析, 而支撑我们来做这种分析的就是单一职责原则. 将大类拆分成小类, 本质上在做的是设计工作, 所以想要写好代码, 程序员需要学好软件设计.</p> <p>如果今天的内容你只能记住一件事, 那请记住: <strong>把类写小, 越小越好</strong>.</p> <h4 id="长参数列表-如何处理不同类型的长参数"><a href="#长参数列表-如何处理不同类型的长参数" class="header-anchor">#</a> 长参数列表:如何处理不同类型的长参数?</h4> <p>函数为什么要有参数呢? 不同函数之间需要共享信息, 于是才有了参数传递.</p> <p>其实, 函数间共享信息的方式不止一种, 除了参数列表, 最常见的一种方式是全局变量. 但全局变量会带来太多意想不到的问题, 所以在初学编程的时候, 老师就会告诉我们, 不要使用全局变量. 从程序设计语言发展的过程中, 也可以看到, 取消全局变量已经成为了大势所趋.</p> <p>但函数之间还是要传递信息的, 既然不能用全局变量, 参数就成了最好的选择, 于是只要想到有什么信息要传给一个函数, 就自然而然地把它加到参数列表中, 参数列表也就越来越长了.</p> <p>那么, 长参数列表有啥问题呢? 这个问题其实在上一讲已经说过了, 人脑能够掌握的内容有限, 一旦参数列表变得很长, 作为普通人, 就很难对这些内容进行把控了.</p> <p>那接下来就具体看看, 有哪些方法可以减少参数的数量.</p> <h5 id="_1-聚沙成塔"><a href="#_1-聚沙成塔" class="header-anchor">#</a> 1.聚沙成塔</h5> <p>来看一段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createBook</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">String</span> title<span class="token punctuation">,</span>
                       <span class="token keyword">final</span> <span class="token class-name">String</span> introduction<span class="token punctuation">,</span>
                       <span class="token keyword">final</span> <span class="token class-name">URL</span> coverUrl<span class="token punctuation">,</span>
                       <span class="token keyword">final</span> <span class="token class-name">BookType</span> type<span class="token punctuation">,</span>
                       <span class="token keyword">final</span> <span class="token class-name">BookChannel</span> channel<span class="token punctuation">,</span>
                       <span class="token keyword">final</span> <span class="token class-name">String</span> protagonists<span class="token punctuation">,</span>
                       <span class="token keyword">final</span> <span class="token class-name">String</span> tags<span class="token punctuation">,</span>
                       <span class="token keyword">final</span> <span class="token keyword">boolean</span> completed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token class-name">Book</span> book <span class="token operator">=</span> <span class="token class-name">Book</span><span class="token punctuation">.</span>builder
        <span class="token punctuation">.</span><span class="token function">title</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">introduction</span><span class="token punctuation">(</span>introduction<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">coverUrl</span><span class="token punctuation">(</span>coverUrl<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">protagonists</span><span class="token punctuation">(</span>protagonists<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">tags</span><span class="token punctuation">(</span>tags<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">completed</span><span class="token punctuation">(</span>completed<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>repository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>这是一个创建作品的函数, 可以看到, 这个函数的参数列表里, 包含了一部作品所要拥有的各种信息, 比如: 作品标题, 作品简介, 封面 URL, 作品类型, 作品归属的频道, 主角姓名, 作品标签, 作品是否已经完结等等.</p> <p>如果阅读这段代码, 只是想理解它的逻辑, 或许会觉得这个函数的参数列表还挺合理, 它把创建一部作品所需的各种信息都传给了函数, 这是大部分人面对一段代码时理解问题的角度. 不过虽然这样写代码容易让人理解, 但这不足以让你发现问题.</p> <p>比如, 如果现在要在作品里增加一项信息, 表明这部作品是否是签约作品, 也就是这部作品是否可以收费, 那该怎么办?</p> <p>顺着前面的思路, 很自然地就会想到给这个函数增加一个参数. 但正如在讲 &quot;长函数&quot; 那节课里说到的, 很多问题都是这样, 每次只增加一点点, 累积起来, 便不忍直视了.</p> <p>如果有了 &quot;坏味道&quot; 的视角, 就会看到这里面的问题: 这个函数的参数列表太长了. 怎么解决这个问题呢?</p> <p>这里所有的参数其实都是和作品相关的, 也就是说<strong>所有的参数都是创建作品所必需</strong>的. 所以可以做的就是<strong>将这些参数封装成一个类, 一个创建作品的参数类</strong>:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NewBookParamters</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> title<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> introduction<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">URL</span> coverUrl<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">BookType</span> type<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">BookChannel</span> channel<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> protagonists<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> tags<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> completed<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>这样一来, 这个函数参数列表就只剩下一个参数了, 一个长参数列表就消除了:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createBook</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">NewBookParamters</span> parameters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里你看到了一个典型的消除长参数列表的重构手法: <mark><strong>将参数列表封装成对象</strong></mark>.</p> <p>或许你还有个疑问, 只是把一个参数列表封装成一个类, 然后用到这些参数的时候, 还需要把它们一个个取出来, 这会不会是多此一举呢? 就像这样:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createBook</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">NewBookParamters</span> parameters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token class-name">Book</span> book <span class="token operator">=</span> <span class="token class-name">Book</span><span class="token punctuation">.</span>builder
        <span class="token punctuation">.</span><span class="token function">title</span><span class="token punctuation">(</span>parameters<span class="token punctuation">.</span><span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">introduction</span><span class="token punctuation">(</span>parameters<span class="token punctuation">.</span><span class="token function">getIntroduction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">coverUrl</span><span class="token punctuation">(</span>parameters<span class="token punctuation">.</span><span class="token function">getCoverUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span>parameters<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>parameters<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">protagonists</span><span class="token punctuation">(</span>parameters<span class="token punctuation">.</span><span class="token function">getProtagonists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">tags</span><span class="token punctuation">(</span>parameters<span class="token punctuation">.</span><span class="token function">getTags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">completed</span><span class="token punctuation">(</span>parameters<span class="token punctuation">.</span><span class="token function">isCompleted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>repository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>如果你也有这样的想法, 那说明一件事: 你还没有形成对软件设计的理解. 这里并不是简单地把参数封装成类, 站在设计的角度, 这里引入的是一个新的模型. <strong>一个模型的封装应该是以行为为基础的.</strong></p> <p>之前没有这个模型, 所以想不到它应该有什么行为, 现在模型产生了, 它就应该有自己配套的行为, 那这个模型的行为是什么呢? 从上面的代码不难看出, 它的<strong>行为应该是构建一个作品对象出来</strong>. 理解了这一点, 代码就可以进一步调整了:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NewBookParamters</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> title<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> introduction<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">URL</span> coverUrl<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">BookType</span> type<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">BookChannel</span> channel<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> protagonists<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> tags<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> completed<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Book</span> <span class="token function">newBook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Book</span><span class="token punctuation">.</span>builder
            <span class="token punctuation">.</span><span class="token function">title</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">introduction</span><span class="token punctuation">(</span>introduction<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">coverUrl</span><span class="token punctuation">(</span>coverUrl<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">protagonists</span><span class="token punctuation">(</span>protagonists<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">tags</span><span class="token punctuation">(</span>tags<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">completed</span><span class="token punctuation">(</span>completed<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>创建作品的函数就得到了极大的简化:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createBook</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">NewBookParamters</span> parameters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token class-name">Book</span> book <span class="token operator">=</span> parameters<span class="token punctuation">.</span><span class="token function">newBook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>repository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这里讨论消除长参数列表的一种方法, 将参数列表封装成类. 还记得前面提到的 &quot;如何扩展需求&quot; 这个问题吗? 如果需求扩展, 需要增加创建作品所需的内容, 那这个参数列表就是不变的, 相对来说, 它就是稳定的.</p> <h5 id="_2-动静分离"><a href="#_2-动静分离" class="header-anchor">#</a> 2.动静分离</h5> <p>把长参数列表封装成一个类, 这能解决大部分的长参数列表, 但并不等于所有的长参数列表都应该用这种方式解决, 因为不是所有情况下, 参数都属于一个类.</p> <p>再来看一段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getChapters</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> bookId<span class="token punctuation">,</span>
                        <span class="token keyword">final</span> <span class="token class-name">HttpClient</span> httpClient<span class="token punctuation">,</span>
                        <span class="token keyword">final</span> <span class="token class-name">ChapterProcessor</span> processor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">HttpUriRequest</span> request <span class="token operator">=</span> <span class="token function">createChapterRequest</span><span class="token punctuation">(</span>bookId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">HttpResponse</span> response <span class="token operator">=</span> httpClient<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Chapter</span><span class="token punctuation">&gt;</span></span> chapters <span class="token operator">=</span> <span class="token function">toChapters</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
    processor<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span>chapters<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这个函数的作用是根据作品 ID 获取其对应的章节信息. 如果单纯以参数个数论, 这个函数的参数数量并不算多.</p> <p>如果只是看这个函数, 可能很难发现直接的问题. 即便我们认为有问题, 也可以用一个类把这个函数的参数都封装起来. 不过, 秉承我在这个专栏里讨论的一贯原则, 绝对的数量并不是关键点, 参数列表也应该是越少越好. 针对这个函数, 需要稍微分析一下这几个参数.</p> <p>在这几个参数里面, 每次传进来的 bookId 都是不一样的, 是随着请求的不同而改变的. <strong>但 httpClient 和 processor 两个参数都是一样的, 因为它们都有相同的逻辑, 没有什么变化</strong>.</p> <p>换言之, bookId 的变化频率同 httpClient 和 processor 这两个参数的变化频率是不同的. 一边是每次都变, 另一边是不变的.</p> <p>不同的数据变动方向也是不同的关注点. 这里表现出来的就是典型的<strong>动数据</strong>(bookId)和<strong>静数据</strong>(httpClient 和 processor), 它们是不同的关注点, 应该分离开来.</p> <p>具体到这个场景下, <strong>静态不变的数据完全可以成为这个函数所在类的一个字段, 而只将每次变动的东西作为参数传递就可以了</strong>. 按照这个思路, 代码可以改成这个样子:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getChapters</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> bookId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">HttpUriRequest</span> request <span class="token operator">=</span> <span class="token function">createChapterRequest</span><span class="token punctuation">(</span>bookId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">HttpResponse</span> response <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>httpClient<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Chapter</span><span class="token punctuation">&gt;</span></span> chapters <span class="token operator">=</span> <span class="token function">toChapters</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>processor<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span>chapters<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这个坏味道其实是一个软件设计问题, 代码缺乏应有的结构, 所以原本应该属于静态结构的部分却以动态参数的方式传来传去, 无形之中拉长了参数列表.</p> <p>这个例子也给了我们一个提示, 长参数列表固然可以用一个类进行封装, 但能够封装出这个类的前提条件是: **这些参数属于一个类, 有相同的变化原因. **</p> <p>如果函数的参数有不同的变化频率, 就要视情况而定了. 对于静态的部分, 前面已经看到了, 它可以成为软件结构的一部分, 而如果有多个变化频率, 还可以封装出多个参数类来.</p> <h5 id="_3-告别标记"><a href="#_3-告别标记" class="header-anchor">#</a> 3.告别标记</h5> <p>再来看一个例子:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">editChapter</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> chapterId<span class="token punctuation">,</span>
                        <span class="token keyword">final</span> <span class="token class-name">String</span> title<span class="token punctuation">,</span>
                        <span class="token keyword">final</span> <span class="token class-name">String</span> content<span class="token punctuation">,</span>
                        <span class="token keyword">final</span> <span class="token keyword">boolean</span> apporved<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这是在前面 &quot;重复代码&quot; 那一讲里提到过的一个函数, 这几个参数分别表示, 待修改章节的 ID, 标题和内容, 最后一个参数表示这次修改是否直接审核通过.</p> <p>前面几个参数是修改一个章节的必要信息, 而这里的重点就在最后这个参数上.</p> <p>之所以要有这么个参数, 从业务上说, 如果是作者进行编辑, 之后要经过审核, 而如果编辑来编辑的, 那审核就直接通过, 因为编辑本身扮演了审核人的角色. 所以, 你发现了, 这个参数实际上是一个<strong>标记</strong>, 标志着接下来的处理流程会有不同.</p> <p>使用标记参数, 是程序员初学编程时常用的一种手法, 不过, 正是因为这种手法实在是太好用了, 造成的结果就是代码里面彩旗(flag)飘飘, 各种标记满天飞. 不仅变量里有标记, 参数里也有. 很多长参数列表其中就包含了各种标记参数. 这也是很多代码产生混乱的一个重要原因.</p> <p>在实际的代码中, 必须小心翼翼地判断各个标记当前的值, 才能做好处理.</p> <p><strong>解决标记参数, 一种简单的方式就是, 将标记参数代表的不同路径拆分出来</strong>. 回到这段代码上, 这里的一个函数可以拆分成两个函数, 一个函数负责 &quot;普通的编辑&quot;, 另一个负责 &quot;可以直接审核通过的编辑&quot;.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 普通的编辑, 需要审核</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">editChapter</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> chapterId<span class="token punctuation">,</span>
                        <span class="token keyword">final</span> <span class="token class-name">String</span> title<span class="token punctuation">,</span>
                        <span class="token keyword">final</span> <span class="token class-name">String</span> content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token comment">// 直接审核通过的编辑</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">editChapterWithApproval</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> chapterId<span class="token punctuation">,</span>
                                    <span class="token keyword">final</span> <span class="token class-name">String</span> title<span class="token punctuation">,</span>
                                    <span class="token keyword">final</span> <span class="token class-name">String</span> content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>标记参数在代码中存在的形式很多, 有的是布尔值的形式, 有的是以枚举值的形式, 还有的就是直接的字符串或者整数. 无论哪种形式, 都可以通过拆分函数的方式将它们拆开. <strong>在重构中, 这种手法叫做移除标记参数(Remove Flag Argument).</strong></p> <p>最近这三节讲了长函数, 大类和长参数列表三种不同的坏味道, 但在阐述了对于这些坏味道的理解之后, 仔细想想这些坏味道, 其实背后都是一件事: <strong>应该编写 &quot;短小&quot; 的代码.</strong></p> <p>这是由人类理解复杂问题的能力决定的, 只有短小的代码, 才能有更好地把握, 而要写出短小的代码, 需要能够 &quot;分离关注点&quot;.</p> <h5 id="_4-总结时刻-2"><a href="#_4-总结时刻-2" class="header-anchor">#</a> 4.总结时刻</h5> <p>应对长参数列表主要的方式就是<strong>减少参数的数量</strong>, 一种最直接的方式就是将参数列表封装成一个类. 但并不是说所有的情况都能封装成类来解决, 还要分析是否所有的参数都有相同的变动频率.</p> <ol><li>变化频率相同, 则封装成一个类.</li> <li>变化频率不同的话:</li> <li>静态不变的, 可以成为软件结构的一部分;</li> <li>多个变化频率的, 可以封装成几个类.</li></ol> <p>除此之外, 参数列表中经常会出现标记参数, 这是参数列表变长的另一个重要原因. 对于这种标记参数, 一种解决方案就是根据这些标记参数, 将函数拆分成多个函数.</p> <p>如果今天的内容你只能记住一件事, 那请记住: <strong>减小参数列表, 越小越好</strong>.</p> <h4 id="滥用控制语句-出现控制结构-多半是错误的提示"><a href="#滥用控制语句-出现控制结构-多半是错误的提示" class="header-anchor">#</a> 滥用控制语句:出现控制结构,多半是错误的提示</h4> <p>前面几讲已经讲了不少的坏味道, 比如长函数, 大类等. 对于有一定从业经验的程序员来说, 即便不能对这些坏味道有一个很清楚的个人认知, 但至少一说出来, 通常都知道是怎么回事.</p> <p>但这节要讲的坏味道对于很多人来说, 可能就有点挑战了. 这并不是说内容有多难, 相反, 大部分人对这些内容简直太熟悉了. 所以, 当我把它们以坏味道的方式呈现出来时, 这会极大地挑战很多人的认知.</p> <p>这个坏味道就是<strong>滥用控制语句</strong>, 也就是你熟悉的 if, for 等等, 这个坏味道非常典型, 但很多人每天都用它们, 却对问题毫无感知. 今天就先从一个你容易接受的坏味道开始, 说一说使用控制语句时, 问题到底出在哪.</p> <h5 id="_1-嵌套的代码"><a href="#_1-嵌套的代码" class="header-anchor">#</a> 1.嵌套的代码</h5> <p>看一张让我印象极其深刻的图, 看了之后你就知道我要讲的这个坏味道是什么了.</p> <p><img src="/img/b68a67051ad9e4fe54f7c9259e6e3c27-20230729224950-9e1tzt6.png" alt=""></p> <p>相信不少同学在网上见过这张图, 接下来就来讨论<strong>嵌套的代码</strong>.</p> <p>考虑到篇幅, 就不用这么震撼的代码做案例了, 还是从规模小一点的代码开始讨论:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">distributeEpubs</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> bookId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Epub</span><span class="token punctuation">&gt;</span></span> epubs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEpubsByBookId</span><span class="token punctuation">(</span>bookId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Epub</span> epub <span class="token operator">:</span> epubs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>epub<span class="token punctuation">.</span><span class="token function">isValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">boolean</span> registered <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerIsbn</span><span class="token punctuation">(</span>epub<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>registered<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">sendEpub</span><span class="token punctuation">(</span>epub<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>这是一段做 EPUB 分发的代码, EPUB 是一种电子书格式. 在这里, 根据作品 ID 找到要分发的 EPUB, 然后检查 EPUB 的有效性. 对于有效的 EPUB, 要为它注册 ISBN 信息, 注册成功之后, 将这个 EPUB 发送出去.</p> <p>代码逻辑并不是特别复杂, 只不过, 在这段代码中, 看到了多层的缩进, for 循环一层, 里面有两个 if , 又多加了两层. 即便不是特别复杂的代码, 也有这么多的缩进, 可想而知, 如果逻辑再复杂一点, 缩进会成什么样子.</p> <p>这段代码之所以会写成这个样子, 其实就是在讲 &quot;长函数&quot; 那节课里所说的: &quot;<strong>平铺直叙地写代码</strong>&quot;. 这段代码的作者只是按照需求一步一步地把代码实现出来了. 从实现功能的角度来说, 这段代码肯定没错, 但问题在于, 在把功能实现之后, 他停了下来, 而没有把代码重新整理一下. 那就来将它整理成应有的样子.</p> <p>既然不喜欢缩进特别多的代码, 那就要<strong>消除缩进</strong>. 具体到这段代码, 一个着手点是 for 循环, 因为通常来说, for 循环处理的是一个集合, 而循环里面处理的是这个集合中的一个元素. 所以可以<strong>把循环中的内容提取成一个函数</strong>, 让这个函数只处理一个元素, 就像下面这样:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">distributeEpubs</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> bookId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Epub</span><span class="token punctuation">&gt;</span></span> epubs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEpubsByBookId</span><span class="token punctuation">(</span>bookId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Epub</span> epub <span class="token operator">:</span> epubs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">distributeEpub</span><span class="token punctuation">(</span>epub<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">distributeEpub</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Epub</span> epub<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>epub<span class="token punctuation">.</span><span class="token function">isValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">boolean</span> registered <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerIsbn</span><span class="token punctuation">(</span>epub<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>registered<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">sendEpub</span><span class="token punctuation">(</span>epub<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>这里已经有了一次拆分, 分解出来 distributeEpub 函数每次只处理一个元素. 拆分出来的两个函数在缩进的问题上, 就改善了一点.</p> <p>第一个函数 distributeEpubs 只有一层缩进, 这是一个正常函数应有的样子, 不过第二个函数 distributeEpub 则还有多层缩进, 可以继续处理一下.</p> <h5 id="_2-if和else"><a href="#_2-if和else" class="header-anchor">#</a> 2.if和else</h5> <p>在 distributeEpub 里, 造成缩进的原因是 if 语句. 通常来说, if 语句造成的缩进, 很多时候都是在检查某个先决条件, 只有条件通过时, 才继续执行后续的代码. 这样的代码<strong>可以使用卫语句(guard clause)来解决, 也就是设置单独的检查条件, 不满足这个检查条件时, 立刻从函数中返回</strong>.</p> <p>这是一种典型的重构手法: <mark><strong>以卫语句取代嵌套的条件表达式</strong></mark>​ <strong>(Replace Nested Conditional with Guard Clauses)</strong> .</p> <p>来看看改进后的 distributeEpub 函数:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">distributeEpub</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Epub</span> epub<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>epub<span class="token punctuation">.</span><span class="token function">isValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">boolean</span> registered <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerIsbn</span><span class="token punctuation">(</span>epub<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>registered<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">sendEpub</span><span class="token punctuation">(</span>epub<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>改造后的 distributeEpub 就没有了嵌套, 也就没有那么多层的缩进了. 你可能已经发现了, 经过改造之后, 代码里只有一层的缩进 <strong>.</strong>  当代码里只有一层缩进时, 代码的复杂度就大大降低了, 理解成本和出现问题之后定位的成本也随之大幅度降低.</p> <p>其实, <strong>else 也是一种坏味道, 这是挑战很多程序员认知的</strong>. 在大多数人印象中, if 和 else 是亲如一家的整体, 它们几乎是比翼齐飞的. 那么, else 可以不写吗? 可以. 来看看下面的代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getEpubPrice</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> highQuality<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span> chapterSequence<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> price <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>highQuality <span class="token operator">&amp;&amp;</span> chapterSequence <span class="token operator">&gt;</span> <span class="token constant">START_CHARGING_SEQUENCE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        price <span class="token operator">=</span> <span class="token number">4.99</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sequenceNumber <span class="token operator">&gt;</span> <span class="token constant">START_CHARGING_SEQUENCE</span>
            <span class="token operator">&amp;&amp;</span> sequenceNumber <span class="token operator">&lt;=</span> <span class="token constant">FURTHER_CHARGING_SEQUENCE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        price <span class="token operator">=</span> <span class="token number">1.99</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sequenceNumber <span class="token operator">&gt;</span> <span class="token constant">FURTHER_CHARGING_SEQUENCE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        price <span class="token operator">=</span> <span class="token number">2.99</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        price <span class="token operator">=</span> <span class="token number">0.99</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> price<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>这是一个根据 EPUB 信息进行定价的函数, 它的定价逻辑正如代码中所示.</p> <p>就这段代码而言, 如果想不使用 else, 一个简单的处理手法就是让每个逻辑提前返回, 这和前面提到的卫语句的解决方案如出一辙:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getEpubPrice</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> highQuality<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span> chapterSequence<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>highQuality <span class="token operator">&amp;&amp;</span> chapterSequence <span class="token operator">&gt;</span> <span class="token constant">START_CHARGING_SEQUENCE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">4.99</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>sequenceNumber <span class="token operator">&gt;</span> <span class="token constant">START_CHARGING_SEQUENCE</span>
            <span class="token operator">&amp;&amp;</span> sequenceNumber <span class="token operator">&lt;=</span> <span class="token constant">FURTHER_CHARGING_SEQUENCE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1.99</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sequenceNumber <span class="token operator">&gt;</span> <span class="token constant">FURTHER_CHARGING_SEQUENCE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">2.99</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0.99</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>对于这种逻辑上还比较简单的代码, 这么改造还是比较容易的, 而对于一些更为复杂的代码, 也许就要用到多态来改进代码了. 不过在实际项目中, 大部分代码逻辑都是逐渐变得复杂的, 所以最好在它还比较简单时, 就把坏味道消灭掉. 这才是最理想的做法.</p> <p>无论是嵌套的代码, 还是 else 语句, 之所以要把它们视为坏味道, 本质上都在追求简单, 因为一段代码的分支过多, 其复杂度就会大幅度增加. 人脑能够理解的复杂度是有限的, 分支过多的代码一定是会超过这个理解范围.</p> <p>在软件开发中, 有一个衡量代码复杂度常用的标准, 叫做圈复杂度(Cyclomatic complexity, 简称 CC), 圈复杂度越高, 代码越复杂, 理解和维护的成本就越高. 在圈复杂度的判定中, 循环和选择语句占有重要的地位. 圈复杂度可以使用工具来检查, 比如在 Java 世界中, 有很多可以检查圈复杂度的工具, 之前提到过的 Checkstyle 就可以做圈复杂度的检查, 可以限制最大的圈复杂度, 当圈复杂度大于某个值的时候, 就会报错.</p> <p>只要能够消除嵌套, 消除 else, 代码的圈复杂度就不会很高, 理解和维护的成本自然也就会随之降低.</p> <h5 id="_3-重复的switch"><a href="#_3-重复的switch" class="header-anchor">#</a> 3.重复的Switch</h5> <p>来看两段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getBookPrice</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">User</span> user<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">Book</span> book<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> price <span class="token operator">=</span> book<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">UserLevel</span><span class="token punctuation">.</span><span class="token constant">SILVER</span><span class="token operator">:</span>
            <span class="token keyword">return</span> price <span class="token operator">*</span> <span class="token number">0.9</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">UserLevel</span><span class="token punctuation">.</span><span class="token constant">GOLD</span><span class="token operator">:</span>
            <span class="token keyword">return</span> price <span class="token operator">*</span> <span class="token number">0.8</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">UserLevel</span><span class="token punctuation">.</span><span class="token constant">PLATINUM</span><span class="token operator">:</span>
            <span class="token keyword">return</span> price <span class="token operator">*</span> <span class="token number">0.75</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">return</span> price<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getEpubPrice</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">User</span> user<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">Epub</span> epub<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> price <span class="token operator">=</span> epub<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">UserLevel</span><span class="token punctuation">.</span><span class="token constant">SILVER</span><span class="token operator">:</span>
            <span class="token keyword">return</span> price <span class="token operator">*</span> <span class="token number">0.95</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">UserLevel</span><span class="token punctuation">.</span><span class="token constant">GOLD</span><span class="token operator">:</span>
            <span class="token keyword">return</span> price <span class="token operator">*</span> <span class="token number">0.85</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">UserLevel</span><span class="token punctuation">.</span><span class="token constant">PLATINUM</span><span class="token operator">:</span>
            <span class="token keyword">return</span> price <span class="token operator">*</span> <span class="token number">0.8</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">return</span> price<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>这两段代码, 分别计算了用户在网站上购买作品在线阅读所支付的价格, 以及购买 EPUB 格式电子书所支付的价格. 其中, 用户实际支付的价格会根据用户在系统中的用户级别有所差异, 级别越高, 折扣就越高.</p> <p>显然, 这两个函数里出现了类似的代码, 其中最类似的部分就是 switch, 都是根据用户级别进行判断. 事实上, 这并不是仅有的根据用户级别进行判断的代码, 各种需要区分用户级别的场景中都有类似的代码, 而这也是一种典型的坏味道: <strong>重复的 switch(Repeated Switch)</strong> .</p> <p>之所以会出现重复的 switch, 通常都是<strong>缺少了一个模型</strong>. 所以, 应对这种坏味道, 重构的手法是: <strong>以多态取代条件表达式(Relace Conditional with Polymorphism)</strong> . 具体到这里的代码, 可以引入一个 UserLevel 的模型, 将 switch 消除掉:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">UserLevel</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> <span class="token function">getBookPrice</span><span class="token punctuation">(</span><span class="token class-name">Book</span> book<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">double</span> <span class="token function">getEpubPrice</span><span class="token punctuation">(</span><span class="token class-name">Epub</span> epub<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">RegularUserLevel</span> <span class="token keyword">implements</span> <span class="token class-name">UserLevel</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getBookPrice</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Book</span> book<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> book<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getEpubPrice</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Epub</span> epub<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> epub<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">GoldUserLevel</span> <span class="token keyword">implements</span> <span class="token class-name">UserLevel</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getBookPrice</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Book</span> book<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> book<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.8</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getEpubPrice</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Epub</span> epub<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> epub<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.85</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">SilverUserLevel</span> <span class="token keyword">implements</span> <span class="token class-name">UserLevel</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getBookPrice</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Book</span> book<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> book<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.9</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getEpubPrice</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Epub</span> epub<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> epub<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.85</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">PlatinumUserLevel</span> <span class="token keyword">implements</span> <span class="token class-name">UserLevel</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getBookPrice</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Book</span> book<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> book<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.75</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getEpubPrice</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Epub</span> epub<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> epub<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.8</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><p>有了这个基础, 前面的代码就可以把 switch 去掉了:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getBookPrice</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">User</span> user<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">Book</span> book<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">UserLevel</span> level <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">getUserLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> level<span class="token punctuation">.</span><span class="token function">getBookPrice</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getEpubPrice</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">User</span> user<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">Epub</span> epub<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">UserLevel</span> level <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">getUserLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> level<span class="token punctuation">.</span><span class="token function">getEpubPrice</span><span class="token punctuation">(</span>epub<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>其实, 关于控制语句还有一个坏味道, 那就是<strong>循环语句</strong>. 没错, 循环本身就是一个坏味道, 但讲解它还需要一些知识的铺垫, 所以会把它放到后面讲 &quot;落后的代码风格&quot; 时再来讲解. 这里只要知道循环语句也是一个坏味道就够了.</p> <h5 id="_4-总结时刻-3"><a href="#_4-总结时刻-3" class="header-anchor">#</a> 4.总结时刻</h5> <p>今天讲了程序员们最熟悉的控制语句: 选择语句和循环语句. 遗憾的是, 这些语句今天都成了坏味道的高发地带, 以各种形态呈现在我们面前:</p> <ol><li>嵌套的代码;</li> <li>else 语句;</li> <li>重复的 switch;</li> <li>循环语句.</li></ol> <p>嵌套的代码也好, else 语句也罢, 二者真正的问题在于, <strong>它们会使代码变得复杂</strong>, 超出人脑所能理解的范畴. 可以通过提取单个元素操作, 降低循环语句的复杂度, 而用卫语句来简化条件表达式的编写, 降低选择语句的复杂度. 一个衡量代码复杂度的标准是圈复杂度, 可以通过工具检查一段代码的圈复杂度.</p> <p>重复的 switch 本质上是缺少了一个模型, 可以使用多态取代条件表达式, 引入缺少的模型, 消除重复的 switch.</p> <p>如果今天的内容你只能记住一件事, 那请记住: **循环和选择语句, 可能都是坏味道. **</p> <h4 id="缺乏封装-如何应对火车代码和基本类型偏执问题"><a href="#缺乏封装-如何应对火车代码和基本类型偏执问题" class="header-anchor">#</a> 缺乏封装:如何应对火车代码和基本类型偏执问题?</h4> <p>上一讲讲的是控制语句体现出的坏味道, 它们不是一种坏味道, 而是一类坏味道. 这一讲再来讲一类代码的坏味道: 缺乏封装.</p> <p>在程序设计中, 一个重要的观念就是<strong>封装</strong>, 将零散的代码封装成一个又一个可复用的模块. 任何一个程序员都会认同封装的价值, 但具体到写代码时, 每个人对于封装的理解程度却天差地别, 造成的结果就是: 写代码的人认为自己提供了封装, 但实际上, 我们还是看到许多的代码散落在那里.</p> <p>这一讲就来看看, 那些被封装遗忘的角落.</p> <h5 id="_1-火车残骸"><a href="#_1-火车残骸" class="header-anchor">#</a> 1.火车残骸</h5> <p>先从一段代码开始:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> name <span class="token operator">=</span> book<span class="token punctuation">.</span><span class="token function">getAuthor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这段代码表达的是 &quot;获得一部作品作者的名字&quot;. 作品里有作者信息, 想要获得作者的名字, 通过 &quot;作者&quot; 找到 &quot;作者姓名&quot;, 这就是很多人凭借直觉写出的代码, 不过它是有问题的.</p> <p>如果你没看出这段代码的问题, 说明你可能对封装缺乏理解.</p> <p>想一想, 如果你想写出上面这段代码, 是不是必须得<strong>先了解 Book 和 Author 这两个类的实现细节</strong>? 也就是说, 必须得知道, 作者的姓名是存储在作品的作者字段里的. 这时就要注意了: <mark><strong>当必须得先了解一个类的细节, 才能写出代码时, 这只能说明一件事, 这个封装是失败的</strong></mark>.</p> <p>这段代码只是用来说明这种类型坏味道是什么样的, 在实际工作中, 这种在一行代码中有连续多个方法调用的情况屡见不鲜, 数量上总会不断突破你的认知.</p> <p>《重构》中给这种坏味道起的名字叫<strong>过长的消息链(Message Chains)</strong> , 而有人则给它起了一个更为夸张的名字: 火车残骸(Train Wreck), 形容这样的代码像火车残骸一般, 断得一节一节的.</p> <p>解决这种代码的重构手法叫<strong>隐藏委托关系(Hide Delegate)</strong> , 说得更直白一些就是, 把这种调用封装起来:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Book</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getAuthorName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>author<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token class-name">String</span> name <span class="token operator">=</span> book<span class="token punctuation">.</span><span class="token function">getAuthorName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>前面说过, 火车残骸这种坏味道的产生是缺乏对于封装的理解, 因为封装这件事并不是很多程序员编码习惯的一部分, 他们对封装的理解停留在数据结构加算法的层面上.</p> <p>在学习数据结构时, 我们所编写的代码都是拿到各种细节直接操作, 但那是在做编程练习, 并不是工程上的编码方式. 但很多人把这种编码习惯带到了工作中.</p> <p>比如, 有人编写一个新的类, 第一步是写出这个类要用到的字段, 然后就是给这些字段生成相应的 getter, 也就是各种 getXXX. 很多语言或框架提供的约定就是基于这种 getter 的, 就像 Java 里的 JavaBean, 所以相应的配套工具也很方便. 现在写出一个 getter 往往是 IDE 中一个快捷键的操作, 甚至不需要自己手工敲代码.</p> <p>诸如此类种种因素叠加, <strong>让暴露细节这种事越来越容易, 封装反而成了稀缺品</strong>.</p> <p>**要想摆脱初级程序员的水平, 就要先从少暴露细节开始. **声明完一个类的字段之后, 请停下生成 getter 的手, 转而让大脑开始工作, 思考这个类应该提供的行为.</p> <p>在软件行业中, 有一个编程的指导原则几乎就是针对这个坏味道的, 叫做<strong>迪米特法则</strong>(Law of Demeter), 这个原则是这样说的:</p> <ol><li><strong>每个单元对其它单元只拥有有限的知识, 而且这些单元是与当前单元有紧密联系的</strong>;</li> <li><strong>每个单元只能与其朋友交谈, 不与陌生人交谈</strong>;</li> <li><strong>只与自己最直接的朋友交谈</strong>.</li></ol> <p>这个原则需要思考, 哪些算是直接的朋友, 哪些算是陌生人. 火车残骸般的代码显然就是没有考虑这些问题而直接写出来的代码.</p> <p>或许你会说, 按照迪米特法则这样写代码, 会不会让代码里有太多简单封装的方法?</p> <p>确实有可能, 不过这也是单独解决这一个坏味道可能带来的结果. 正如前面所说, 这种代码的出现, 根本的问题是缺乏对封装的理解, 而一个好的封装是需要基于行为的, 所以如果把视角再提升一个角度, 应该考虑的问题是类应该提供哪些行为, 而非简简单单地把数据换一种形式呈现出来.</p> <p>最后, 还有一个问题要提醒一下. 有些内部 DSL 的表现形式也是连续的方法调用, 但 DSL 是声明性的, 是在说做什么(What), 而这里的坏味道是在说怎么做(How), 二者的抽象级别是不同的, 不要混在一起.</p> <h5 id="_2-基本类型偏执"><a href="#_2-基本类型偏执" class="header-anchor">#</a> 2.基本类型偏执</h5> <p>再来看一段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getEpubPrice</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> highQuality<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span> chapterSequence<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这是上一讲用过的一个函数声明, 根据章节信息获取 EPUB(一种电子书的格式) 的价格. 也许你会问, 这是一个看上去非常清晰的代码, 难道这里也有坏味道吗?</p> <p>没错, 有. 问题就出在<strong>返回值的类型上</strong>, 也就是价格的类型上.</p> <p>在数据库中存储价格的时候, 就是用一个浮点数, 这里用 double 可以保证计算的精度, 这样的设计有什么问题吗?</p> <p>确实, 这就是很多人使用基本类型(Primitive)作为变量类型思考的角度. 但实际上, <strong>这种采用基本类型的设计缺少了一个模型</strong>.</p> <p>虽然价格本身是用浮点数在存储, 但<strong>价格和浮点数本身并不是同一个概念</strong>, 有着不同的行为需求. 比如, 一般情况下, 要求商品价格是大于 0 的, 但 double 类型本身是没有这种限制的.</p> <p>就以 &quot;价格大于 0&quot; 这个需求为例, 如果使用 double 类型会怎么限制呢? 通常会这样写:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>price <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Price should be positive&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>问题是, 如果使用 double 作为类型, 那要在使用的地方都保证价格的正确性, 像这样的价格校验就应该是使用的地方到处写的.</p> <p>如果补齐这里缺失的模型, 可以<strong>引入一个 Price 类型, 这样的校验就可以放在初始化时进行</strong>:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Price</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> price<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Price</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">double</span> price<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>price <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Price should be positive&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> price<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>这种引入一个模型封装基本类型的重构手法, 叫做<strong>以对象取代基本类型(Replace Primitive with Object)</strong> . 一旦有了这个模型, 还可以再进一步, 比如, 如果想要让价格在对外呈现时只有两位, 在没有 Price 类的时候, 这样的逻辑就会散落代码的各处, 事实上, 代码里很多重复的逻辑就是这样产生的. 而现在可以在 Price 类里提供一个方法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getDisplayPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">BigDecimal</span> decimal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">return</span> decimal<span class="token punctuation">.</span><span class="token function">setScale</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span><span class="token constant">ROUND_HALF_UP</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>其实, 使用基本类型和使用继承出现的问题是异曲同工的. 大部分程序员都学过这样一个设计原则: 组合优于继承, 也就是说, 不要写出这样的代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Books</span> <span class="token keyword">extends</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Book</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>而应该写成组合的样子, 也就是:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Books</span>  <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Book</span><span class="token punctuation">&gt;</span></span> books<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>之所以有人把 Books 写成了继承, 因为在代码作者眼中, Books 就是一个书的集合; 而有人用 double 做价格的类型, 因为在他看来, 价格就是一个 double. 这里的误区就在于, <strong>一些程序员只看到了模型的相同之处, 却忽略了差异的地方</strong>. Books 可能不需要提供 List 的所有方法, 价格的取值范围与 double 也有所差异.</p> <p>但是, Books 的问题相对来说容易规避, 因为产生了一个新的模型, 有通用的设计原则帮助判断这个模型构建得是否恰当, 而价格的问题却不容易规避, 因为这里没有产生新的模型, 也就不容易发现这里潜藏着问题.</p> <p>这种以基本类型为模型的坏味道称为<strong>基本类型偏执</strong>(Primitive Obsession). 这里说的基本类型, 不限于程序设计语言提供的各种基本类型, 像字符串也是一个产生这种坏味道的地方.</p> <p>这一讲讲到的坏味道都是关于封装的. 不过正如开头所说, 封装是一个人人都懂的道理, 但具体到代码上, 就千差万别了.</p> <p><strong>封装之所以有难度, 主要在于它是一个构建模型的过程</strong>, 而很多程序员写程序, 只是用着极其粗粒度的理解写着完成功能的代码, 根本没有构建模型的意识; 还有一些人以为划分了模块就叫封装, 所才会看到这些坏味道的滋生.</p> <p>这里给出的坏味道, 其实也是在挑战一些人对于编程的认知: 那些习以为常的代码居然成了坏味道. 而这只是一个信号, 一个起点, 告诉你这段代码存在问题, 但真正要写好代码, 还是需要你对软件设计有着深入的学习.</p> <h5 id="_3-总结时刻-5"><a href="#_3-总结时刻-5" class="header-anchor">#</a> 3.总结时刻</h5> <p>这一讲讨论的是与封装有关的坏味道:</p> <ol><li>过长的消息链, 或者叫火车残骸;</li> <li>基本类型偏执.</li></ol> <p>火车残骸的代码就是连续的函数调用, 它反映的问题就是把实现细节暴露了出去, <strong>缺乏应有的封装</strong>. 重构的手法是隐藏委托关系, 实际就是做封装. 软件行业有一个编程指导原则, 叫迪米特法则, 可以作为日常工作的指导, 规避这种坏味道的出现.</p> <p>基本类型偏执就是用各种基本类型作为模型到处传递, 这种情况下通常是<strong>缺少了一个模型</strong>. 解决它, 常用的重构手法是以对象取代基本类型, 也就是提供一个模型代替原来的基本类型. 基本类型偏执不局限于程序设计语言提供的基本类型, 字符串也是这种坏味道产生的重要原因, 再延伸一点, 集合类型也是.</p> <p>这两种与封装有关的坏味道, 背后体现的是对构建模型了解不足, 其实也是很多程序员在软件设计上的欠缺. 想成为一个更好的程序员, 学习软件设计是不可或缺的.</p> <p>如果今天的内容你只能记住一件事, 那请记住: <strong>构建模型, 封装散落的代码</strong>.</p> <h4 id="可变的数据-不要让你的代码-失控"><a href="#可变的数据-不要让你的代码-失控" class="header-anchor">#</a> 可变的数据:不要让你的代码&quot;失控&quot;</h4> <p>最近几讲讨论的坏味道挑战了很多人的编程习惯, 明明很习惯的编码方式, 如今却成了坏味道. 这一讲再来说一类这样的坏味道: 可变的数据.</p> <p>对于程序, 最朴素的一种认知是 &quot;程序 = 数据结构 + 算法&quot;, 所以, 数据几乎是软件开发最核心的一个组成部分. 在一些人的认知中, 所谓做软件, 就是一系列的 CRUD 操作, 也就是对数据进行增删改查. 再具体一点, 写代码就把各种数据拿来, 然后改来改去. 学习编程时, 首先学会的, 也是给变量赋值, 写出类似 <code>a = b + 1</code>​之类的代码.</p> <p>改数据, 几乎已经成了很多程序员写代码的标准做法. 然而这种做法也带来了很多的问题. 这一讲还是从一段问题代码开始.</p> <h5 id="_1-满天飞的setter"><a href="#_1-满天飞的setter" class="header-anchor">#</a> 1.满天飞的Setter</h5> <p>还记得在开篇词里提到过的一个坏味道吗? 复习一下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">approve</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> bookId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    book<span class="token punctuation">.</span><span class="token function">setReviewStatus</span><span class="token punctuation">(</span><span class="token class-name">ReviewStatus</span><span class="token punctuation">.</span><span class="token constant">APPROVED</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这是一段对作品进行审核的代码, 通过 bookId, 找到对应的作品, 接下来将审核状态设置成了审核通过.</p> <p>我当时之所以注意到这段代码, 就是因为这里用了 setter. <strong>setter 往往是缺乏封装的一种做法</strong>. 对于缺乏封装的坏味道, 很多人在写代码时, 写完字段就会利用 IDE 生成 getter, 实际情况往往是, 生成 getter 的同时, setter 也生成了出来.</p> <p><strong>setter 同 getter 一样, 反映的都是对细节的暴露</strong>. 这就意味着, 你不仅可以读到一个对象的数据, 还可以修改一个对象的数据. <strong>相比于读数据, 修改是一个更危险的操作</strong>. 可变的数据会带来许多问题, 简言之, 你不知道数据会在哪里被何人以什么方式修改, 造成的结果是, 别人的修改会让你的代码崩溃. 与之相伴的还有各种衍生出来的问题, 最常见的就是常说的并发问题.</p> <p>可变的数据是可怕, 但是, <strong>比可变的数据更可怕的是不可控的变化</strong>, 而暴露 setter 就是这种不可控的变化. 把各种实现细节完全交给对这个类不了解的使用者去修改, 没有人会知道他会怎么改, 所以这种修改完全是不可控的.</p> <p><strong>缺乏封装再加上不可控的变化, 在我个人心目中, setter 几乎是排名第一的坏味道</strong>.</p> <p>在开篇词里, 针对代码给出的调整方案是, 用一个函数替代了 setter, 也就是把它用行为封装了起来:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">approve</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> bookId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// book.approve();</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>通过在 Book 类里引入了一个 approve 函数, 将审核状态封装了起来.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Book</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">approve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>reviewStatus <span class="token operator">=</span> <span class="token class-name">ReviewStatus</span><span class="token punctuation">.</span><span class="token constant">APPROVED</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>作为这个类的使用者, 你并不需要知道这个类到底是怎么实现的. 更重要的是, 这里的变化变得<strong>可控</strong>了. 虽然审核状态这个字段还是会修改, 但所有的修改都要通过几个函数作为入口. 有任何业务上的调整, 都会发生在<strong>类的内部</strong>, 只要保证接口行为不变, 就不会影响到其它的代码.</p> <p>setter 破坏了封装, 相信你对这点已经有了一定的理解. 不过, 有时候你会说, 这个 setter 只是用在初始化过程中, 而并不需要在使用的过程去调用, 就像下面这样:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Book</span> book <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Book</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
book<span class="token punctuation">.</span><span class="token function">setBookId</span><span class="token punctuation">(</span>bookId<span class="token punctuation">)</span><span class="token punctuation">;</span>
book<span class="token punctuation">.</span><span class="token function">setTitle</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span>
book<span class="token punctuation">.</span><span class="token function">setIntroduction</span><span class="token punctuation">(</span>introduction<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>实际上, 对于这种只在初始化中使用的代码, 压根没有必要以 setter 的形式存在, 真正需要的是一个<strong>有参数</strong>的构造函数:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Book</span> book <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Book</span><span class="token punctuation">(</span>bookId<span class="token punctuation">,</span> title<span class="token punctuation">,</span> introduction<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>消除 setter , 有一种专门的重构手法, 叫做<strong>移除设值函数(Remove Setting Method)</strong> . 总而言之, setter 是完全没有必要存在的.</p> <p>在今天的软件开发中, 人们为了简化代码的编写做出了各种努力, 用 IDE 生成的代码是一种, 还有一种常见的做法就是通过工具和框架生成相应代码的. 在 Java 世界中, Lombok 就是这样的一种程序库, 它可以在编译的过程中生成相应的代码, 而我们需要做的, 只是在代码上加上对应的 Annotation. 它最大的优点是不碍眼, 也就是不会产生大量可以看见的代码. 因为它的代码是在编译阶段生成的, 所以那些生成的代码在源码级别上是不存在的. 下面就是一个例子:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Getter</span>
<span class="token annotation punctuation">@Setter</span>
<span class="token keyword">class</span> <span class="token class-name">Book</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">BookId</span> bookId<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> title<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> introduction<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这里的 @Getter 表示为这个类的字段生成 getter, 相应地, @Setter 表示生成 setter. 也是因为这些 Annotation 的存在, 让代码看上去清爽了不少. 所以像 Lombok 这样的程序库赢得了许多人的喜爱.</p> <p>不过我想说的是, 不写 setter 的代码并不代表没有 setter. 因为 @Setter 的存在, 其它代码还是可以调用这个类的 setter, 存在的问题并不会改变. 所以一个更好的做法是禁用 @Setter. 下面是 lombok.config 的配置, 通过它就可以禁用 @Setter 了:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>lombok<span class="token punctuation">.</span>setter<span class="token punctuation">.</span>flagUsage <span class="token operator">=</span> error
lombok<span class="token punctuation">.</span>data<span class="token punctuation">.</span>flagUsage <span class="token operator">=</span> error
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>你或许注意到了, 这里除了 @Setter, 还禁用了 @Data, 这是 Lombok 中另外一个 Annotation, 表示的是同时生成 getter 和 setter. 既然禁用 @Setter 是为了防止生成 setter, 当然也要禁用 @Data 了.</p> <h5 id="_2-可变的数据"><a href="#_2-可变的数据" class="header-anchor">#</a> 2.可变的数据</h5> <p>这里反对使用 setter, 一个重要的原因就是它暴露了数据, 前面说过, <strong>暴露数据造成的问题就在于数据的修改, 进而导致出现难以预料的 Bug</strong>. 在上面的代码中, 把 setter 封装成一个个的函数, 实际上是把不可控的修改限制在一个有限的范围内.</p> <p>这个思路再进一步的话, 如果数据压根不让修改, 犯下各种低级错误的机会就进一步降低了. 没错, 在这种思路下, <strong>可变数据(Mutable Data)就成了一种坏味道</strong>, 这是 Martin Fowler 在新版《重构》里增加的坏味道, 它反映着整个行业对于编程的新理解.</p> <p>这种想法源自函数式编程这种编程范式. <strong>在函数式编程中, 数据是建立在不改变的基础上的, 如果需要更新, 就产生一份新的数据副本, 而旧有的数据保持不变</strong>. 随着函数式编程在软件开发领域中的地位不断提高, 人们对于不变性的理解也越发深刻, 不变性有效地解决了可变数据产生的各种问题.</p> <p>所以, Martin Fowler 在《重构》第二版里新增了可变数据作为一种坏味道, 这其实反映了行业的理解也是在逐渐推进的. 不过, Martin Fowler 对于可变数据给出的解决方案, 基本上是限制对于数据的更新, 降低其风险, 这与前面提到的对 setter 的封装如出一辙.</p> <p>**解决可变数据, 还有一个解决方案是编写不变类. **</p> <p>函数式编程不变性的关键点就是设计不变类. Java 中的 String 类就是一个不变类, 比如, 如果把字符串中的一个字符替换成另一个字符, String 类给出的函数签名是这样的:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token keyword">char</span> oldChar<span class="token punctuation">,</span> <span class="token keyword">char</span> newChar<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其含义是, 这里的替换并不是在原有字符串上进行修改, 而是<strong>产生了一个新的字符串</strong>.</p> <p>那么, 在实际工作中, 怎么设计不变类呢? 要做到以下三点:</p> <ol><li><strong>所有的字段只在构造函数中初始化;</strong></li> <li><strong>所有的方法都是纯函数;</strong></li> <li><strong>如果需要有改变, 返回一个新的对象, 而不是修改已有字段.</strong></li></ol> <p>回过头来看之前改动的 &quot;用构造函数消除 setter&quot; 的代码, 其实就是朝着这个方向在迈进. 如果按照这个思路改造前面提到的 approve 函数, 同样也可以:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Book</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">approve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Book</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token class-name">ReviewStatus</span><span class="token punctuation">.</span><span class="token constant">APPROVED</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这里创建出了一个 &quot;其它参数和原有 book 对象一模一样, 只是审核状态变成了 APPROVED&quot; 的对象.</p> <p>在 JDK 的演化中, 可以看到一个很明显的趋势, 新增的类越来越多地采用了不变类的设计, 比如, 用来表示时间的类. 原来的 Date 类里面还有各种 setter, 而新增的 LocalDateTime 则一旦初始化就不会再修改了. 如果要操作这个对象, 则会产生一个新的对象:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">LocalDateTime</span> twoDaysLater <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">plusDays</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>就目前的开发状态而言, 想要完全消除可变数据是很难做到的, 但可以尽可能地编写一些不变类.</p> <p>一个更实用的做法是, <strong>区分类的性质</strong>. 最核心的对象分成两种, 实体和值对象. <strong>实体对象要限制数据变化, 而值对象就要设计成不变类</strong>.</p> <p>如果还想进一步提升自己对于不变性的理解, 可以回到函数式编程这个编程范式的本质, 它其实是对程序中的赋值进行了约束. 基于这样的理解, <strong>连赋值本身其实都会被归入到坏味道的提示, 这才是真正挑战很多人编程习惯的一点</strong>.</p> <p>越来越多的语言中开始引入值类型, 也就是初始化之后便不再改变的值, 比如 Java 的 Valhalla 项目, 更有甚者, 像 Rust 这样的语言中, 缺省都是值类型, 而如果需要一个可以赋值的变量, 反而要去专门的声明.</p> <p>Martin Fowler 在《重构》中还提到一个与数据相关的坏味道: <strong>全局数据(Global Data)</strong> . 如果你能够理解可变数据是一种坏味道, 全局数据也就很容易理解了, 它们处理手法基本上是类似的.</p> <h5 id="_3-总结时刻-6"><a href="#_3-总结时刻-6" class="header-anchor">#</a> 3.总结时刻</h5> <p>今天又讲了一类与很多人编程习惯不符的坏味道: 可变的数据.</p> <p>可变数据最直白的体现就是各种 setter. setter 一方面破坏了封装, 另一方面它会带来不可控的修改, 给代码增添许多问题. 解决它的一种方式就是<strong>移除设值函数(Remove Setting Method)</strong> , 将变化限制在一定的范围之内.</p> <p><strong>可变数据</strong>是《重构》第二版新增的坏味道, 这其实反映了软件开发行业的一种进步, 它背后的思想是函数式编程所体现的不变性. 解决可变数据, 一种方式是限制其变化, 另一种方式是编写不变类.</p> <p>在实践中, 完全消除可变数据是很有挑战的. 所以一个实际的做法是, 区分类的性质. <strong>值对象就要设计成不变类, 实体类则要限制数据变化</strong>.</p> <p>函数式编程的本质是对于赋值进行了约束, 甚至可以把赋值作为一种坏味道的提示. 很多编程语言都引入了值类型, 而让变量成为次优选项.</p> <p>如果今天的内容你只能记住一件事, 那请记住: <strong>限制可变的数据</strong>.</p> <h4 id="变量声明与赋值分离-普通的变量声明-怎么也有坏味道"><a href="#变量声明与赋值分离-普通的变量声明-怎么也有坏味道" class="header-anchor">#</a> 变量声明与赋值分离:普通的变量声明,怎么也有坏味道?</h4> <p>已经用连续几讲的篇幅在挑战很多人固有的编程习惯了, 从各种控制语句, 到 getter 和 setter, 甚至连直接使用基本类型都已经成了坏味道, 这一讲再来挑战一个很多人习以为常的编程习惯: 变量的声明与赋值.</p> <p>我估计有人已经露出了惊讶的表情. 你可能会想: 要说前面几种坏味道可能确实是编码没有做好, 该封装没封装, 该返回没返回, 一个变量声明怎么还会有坏味道啊? 难道是变量声明都不让用了吗?</p> <p>诚然, 变量声明是写程序不可或缺的一部分, 我并不打算让你戒掉变量声明, 严格地说, 是要把变量初始化这件事做好.</p> <h5 id="_1-变量的初始化"><a href="#_1-变量的初始化" class="header-anchor">#</a> 1.变量的初始化</h5> <p>先来看一段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">EpubStatus</span> status <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token class-name">CreateEpubResponse</span> response <span class="token operator">=</span> <span class="token function">createEpub</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">201</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    status <span class="token operator">=</span> <span class="token class-name">EpubStatus</span><span class="token punctuation">.</span><span class="token constant">CREATED</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    status <span class="token operator">=</span> <span class="token class-name">EpubStatus</span><span class="token punctuation">.</span><span class="token constant">TO_CREATE</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这段代码在做的事情是向另外一个服务发请求创建 EPUB(一种电子书格式), 如果创建成功, 返回值是 HTTP 的 201, 也就表示创建成功, 然后就把状态置为 CREATED; 而如果没有成功, 则把状态置为 TO_CREATE. 后面对于 TO_CREATE 状态的作品, 还需要再次尝试创建.</p> <p>这里暂且把是否要写 else 放下, 这是在前面已经讨论过的一个坏味道.</p> <p>这次的重点在 status 这个变量上, 虽然 status 这个变量在声明的时候, 就赋上了一个 null 值, 但实际上, 这个值并没有起到任何作用, 因为 status 的变量值, 其实是在经过后续处理之后, 才有了真正的值. 换言之, 从语义上说, <strong>第一行的变量初始化其实是没有用的, 这是一次假的初始化</strong>.</p> <p>按照通常的理解, 一个变量的初始化是分成了声明和赋值两个部分, 而这里要说的就是, <strong>变量初始化最好一次性完成</strong>. 这段代码里的变量赋值是在声明很久之后才完成的, 也就是说, 变量初始化没有一次性完成.</p> <p><strong>这种代码真正的问题就是不清晰, 变量初始化与业务处理混在在一起</strong>. 通常来说, 这种代码后面紧接着就是一大堆更复杂的业务处理. 当代码混在一起的时候, 必须小心翼翼地从一堆业务逻辑里抽丝剥茧, 才能把逻辑理清, 知道变量到底是怎么初始化的. 很多代码难读, 一个重要的原因就是把不同层面的代码混在了一起.</p> <p>这种代码在实际的代码库中出现的频率非常高, 只不过, 它会以各种变形的方式呈现出来. 有的变量甚至是在相隔很远的地方才做了真正的赋值, 完成了初始化, 这中间已经夹杂了很多的业务代码在其中, 进一步增加了理解的复杂度.</p> <p>所以, 编程时要有一个基本原则: <mark><strong>变量一次性完成初始化</strong></mark>.</p> <p>有了这个理解, 可以这样来修改上面这段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">CreateEpubResponse</span> response <span class="token operator">=</span> <span class="token function">createEpub</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">final</span> <span class="token class-name">EpubStatus</span> status <span class="token operator">=</span> <span class="token function">toEpubStatus</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span> <span class="token class-name">EpubStatus</span> <span class="token function">toEpubStatus</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">CreateEpubResponse</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">201</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">EpubStatus</span><span class="token punctuation">.</span><span class="token constant">CREATED</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token class-name">EpubStatus</span><span class="token punctuation">.</span><span class="token constant">TO_CREATE</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在这段改进的代码中, 提取出了一个函数, 将 response 转成对应的内部的 EPUB 状态.</p> <p>其实, 很多人之所以这样写代码, 一个重要的原因是很多人的编程习惯是从 C 语言来的. C 语言在早期的版本中, 一个函数用到的变量必须在整个函数的一开始就声明出来.</p> <p>在 C 语言诞生的年代, 当时计算机能力有限内存小, 编译器技术也处于刚刚起步的阶段, 把变量放在前面声明出来, 有助于减小编译器编写的难度. 到了 C++ 产生的年代, 这个限制就逐步放开了, 所以 C++ 程序是支持变量随用随声明的. 对于今天的大多数程序设计语言来说, 这个限制早就不存在了, 但很多人的编程习惯却留在了那个古老的年代.</p> <p>还有一点不知道你注意到了没有, 在新的变量声明中, 加上了 final, 在 Java 的语义中, 一个变量加上了 final, 也就意味着这个<strong>变量不能再次赋值</strong>.</p> <p>上一讲讲了可变的数据会带来怎样的影响, 其中的一个结论是, 尽可能编写不变的代码. 这里其实是这个话题的延伸, <strong>尽可能使用不变的量</strong>.</p> <p>如果能够按照使用场景做一个区分, 把变量初始化与业务处理分开, 会发现在很多情况下, 变量只在初始化完成之后赋值, 就足以满足需求了, 在一段代码中, 需要使用可变量的场景并不多.</p> <p>这个原则其实可以推广一下, <mark><strong>在能够使用 final 的地方尽量使用 final, 限制变量的赋值</strong></mark>.</p> <p>这里说的 &quot;能够使用&quot;, 不仅包括普通的变量声明, 还包含参数声明, 还有类字段的声明, 甚至还可以包括类和方法的声明. 当然这里改进的考量主要还是在变量上. 可以尝试着调整自己现有的代码, 给变量声明都加上 final, 就会发现许多值得改进的代码.</p> <p>对于 Java 程序员来说, 还有一个特殊的场景, 就是异常处理的场景, 强迫你把变量的声明与初始化分开, 就像下面这段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">InputStream</span> is <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>is <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>之所以要把 InputStream 变量 is 单独声明, 是为了能够在 finanlly 块里面访问到. 其实这段代码写成这样, 一个重要的原因是 Java 早期的版本只能写成这样, 而如果采用 Java 7 之后的版本, 采用 <strong>try-with-resource</strong> 的写法, 代码就可以更简洁了:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">InputStream</span> is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这样一来, InputStream 变量的初始化就一次性完成了, 我们的原则就统一了, 不需要在这种特殊的场景下纠结了.</p> <h5 id="_2-集合初始化"><a href="#_2-集合初始化" class="header-anchor">#</a> 2.集合初始化</h5> <p>接下来看一段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Permission</span><span class="token punctuation">&gt;</span></span> permissions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
permissions<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Permission</span><span class="token punctuation">.</span><span class="token constant">BOOK_READ</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
permissions<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Permission</span><span class="token punctuation">.</span><span class="token constant">BOOK_WRITE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

check<span class="token punctuation">.</span><span class="token function">grantTo</span><span class="token punctuation">(</span><span class="token class-name">Role</span><span class="token punctuation">.</span><span class="token constant">AUTHOR</span><span class="token punctuation">,</span> permissions<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这是一段给作者赋予作品读写权限的代码, 逻辑比较简单, 但这段代码中也存在一些坏味道. 把注意力放在 permissions 这个集合上. 之所以要声明这样一个 List, 是因为 grantTo 方法要用到一个 List 作为参数.</p> <p>来看这个 List 是怎样生成的. 这里先给 permission 初始化成了一个 ArrayList, 这个时候, permissions 虽然存在了, 但我们并不会把它传给 grantTo 方法, 它还不能直接使用, 因为它还缺少必要的信息. 然后将 BOOK_READ 和 BOOK_WRITE 两个枚举对象添加了进去, 这样这个 permissions 对象才是真正需要的那个对象.</p> <p>这种代码是非常常见的, 声明一个集合, 然后调用一堆添加的方法, 将所需的对象添加进去.</p> <p>不难发现, 其实 permissions 对象一开始的变量声明, 并没有完成这个集合真正的初始化, 只有当集合所需的对象添加完毕之后, 这个集合才是它应有的样子. 换言之, 只有添加了元素的集合才是需要的.</p> <p>这样解释这段代码, 你是不是就发现了, 这和前面所说的变量先声明后赋值, 本质上是一回事, 都是从一个变量的声明到初始化成一个可用的状态, 中间隔了太远的距离.</p> <p>之所以很多人习惯这么写, 一个原因就是在早期的 Java 版本中, 没有提供很好的集合初始化的方法. 像这种代码, 也是很多动态语言的支持者调侃 Java 啰嗦的一个靶子.</p> <p>现如今, Java 在这方面早已经改进了许多, 各种程序库已经提供了一步到位的写法, 先来看看 Java 9 之后的写法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Permission</span><span class="token punctuation">&gt;</span></span> permissions <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>
    <span class="token class-name">Permission</span><span class="token punctuation">.</span><span class="token constant">BOOK_READ</span><span class="token punctuation">,</span>
    <span class="token class-name">Permission</span><span class="token punctuation">.</span><span class="token constant">BOOK_WRITE</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

check<span class="token punctuation">.</span><span class="token function">grantTo</span><span class="token punctuation">(</span><span class="token class-name">Role</span><span class="token punctuation">.</span><span class="token constant">AUTHOR</span><span class="token punctuation">,</span> permissions<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>如果你的项目还没有升级 Java 9 之后的版本, 使用 Guava(Google 提供的一个 Java 库)也是可以做成类似的效果:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Permission</span><span class="token punctuation">&gt;</span></span> permissions <span class="token operator">=</span> <span class="token class-name">ImmutableList</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>
    <span class="token class-name">Permission</span><span class="token punctuation">.</span><span class="token constant">BOOK_READ</span><span class="token punctuation">,</span>
    <span class="token class-name">Permission</span><span class="token punctuation">.</span><span class="token constant">BOOK_WRITE</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

check<span class="token punctuation">.</span><span class="token function">grantTo</span><span class="token punctuation">(</span><span class="token class-name">Role</span><span class="token punctuation">.</span><span class="token constant">AUTHOR</span><span class="token punctuation">,</span> permissions<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>经过改进, 这段代码是不是看上去就清爽多了!</p> <p>不知道你注意到没有, 第二段代码里的 List 用的是一个 <strong>ImmutableList</strong>, 也就是一个不可变的 List, 实际上, 查看第一段代码的实现就会发现, 它也是一个不变的 List. 这是什么意思呢? 也就是说, <strong>这个 List 一旦创建好了, 就是不能修改了, 对应的实现就是各种添加, 删除之类的方法全部都禁用了</strong>.</p> <p>初看起来, 这是限制了我们的能力, 但对比一下代码就不难发现, 很多时候, 对于一个集合的使用, 除了声明时添加元素之外, 后续就只是把它当作一个只读的集合. 所以在很多情况下, 一个不变集合就够用了.</p> <p>其实, 这段代码, 相对来说还是比较清晰的, 稍微再复杂一些的, 集合的声明和添加元素之间隔了很远, 不注意的话, 甚至不觉得它们是在完成一次初始化.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Locale</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token constant">CODE_MAPPING</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//...</span>

<span class="token keyword">static</span> <span class="token punctuation">{</span>
    <span class="token constant">CODE_MAPPING</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token constant">LOCALE</span><span class="token punctuation">.</span><span class="token constant">ENGLISH</span><span class="token punctuation">,</span> <span class="token string">&quot;EN&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token constant">CODE_MAPPING</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token constant">LOCALE</span><span class="token punctuation">.</span><span class="token constant">CHINESE</span><span class="token punctuation">,</span> <span class="token string">&quot;CH&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这是一个传输时的映射方案, 将不同的语言版本映射为不同的代码. 这里 CODE_MAPPING 是一个类的 static 变量, 而这个类的声明里还有其它一些变量. 所以隔了很远之后, 才有一个 static 块向这个集合添加元素.</p> <p>如果能够用<strong>一次性声明的方式, 这个单独的 static 块就是不需要</strong>的:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Locale</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token constant">CODE_MAPPING</span> <span class="token operator">=</span> <span class="token class-name">ImmutableMap</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>
    <span class="token constant">LOCALE</span><span class="token punctuation">.</span><span class="token constant">ENGLISH</span><span class="token punctuation">,</span> <span class="token string">&quot;EN&quot;</span><span class="token punctuation">,</span>
    <span class="token constant">LOCALE</span><span class="token punctuation">.</span><span class="token constant">CHINESE</span><span class="token punctuation">,</span> <span class="token string">&quot;CH&quot;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>对比改造前后的代码, 二者之间还有一个更关键的区别: <strong>前面的代码是命令式的代码, 而后面的代码是声明式的代码</strong>.</p> <p>命令式的代码, 就是告诉你 &quot;怎么做&quot; 的代码, 就像改造前的代码, 声明一个集合, 然后添加一个元素, 再添加一个元素. 而声明式的代码, 是告诉你 &quot;做什么&quot; 的代码, 改造后就是, 我要一个包含了这两个元素的集合.</p> <p>声明式的代码体现的意图, 是更高层面的抽象, 把意图和实现分开, 从某种意义上来说, 也是一种分离关注点.</p> <p>所以, <strong>用声明式的标准来看代码, 是一个发现代码坏味道的重要参考</strong>.</p> <p>无论是变量的声明与赋值分离, 还是初始化一个集合的分步骤, 其实反映的都是不同时代编程风格的烙印. 变量的声明是 C 早期的编程风格, 异常处理是 Java 早期的风格, 而集合声明也体现出不同版本 Java 的影子.</p> <p><strong>学习编程不仅仅是要学习实现功能, 编程的风格也要与时俱进.</strong></p> <h5 id="_3-总结时刻-7"><a href="#_3-总结时刻-7" class="header-anchor">#</a> 3.总结时刻</h5> <p>今天继续挑战着很多人习惯的编程方式, 讲了变量初始化带来的问题. 变量的初始化包含变量的声明和赋值两个部分, 一个编程的原则是 &quot;<strong>变量要一次性完成初始化</strong>&quot;.</p> <p>这就衍生出一个坏味道: <strong>变量的声明和赋值是分离的</strong>. 二者分离带来的问题就是, 把赋值的过程与业务处理混杂在一起. <strong>发现变量声明与赋值分离一个做法就是在声明前面加上 final, 用 &quot;不变性&quot; 约束代</strong>码.</p> <p>如果今天的内容你只能记住一件事, 那请记住: <strong>一次性完成变量的初始化</strong>.</p> <h4 id="依赖混乱-你可能还没发现问题-代码就已经无法挽救了"><a href="#依赖混乱-你可能还没发现问题-代码就已经无法挽救了" class="header-anchor">#</a> 依赖混乱:你可能还没发现问题,代码就已经无法挽救了</h4> <p>前面在讲 &quot;大类&quot; 这个坏味道的时候曾经说过, 为了避免同时面对所有细节, 需要把程序进行拆分, 分解成一个又一个的小模块. 但随之而来的问题就是, <strong>需要把这些拆分出来的模块按照一定的规则重新组装在一起, 这就是依赖的缘起</strong>.</p> <p>一个模块要依赖另外一个模块完成完整的业务功能, 而到底怎么去依赖, 这里就很容易产生问题.</p> <h5 id="_1-缺少防腐层"><a href="#_1-缺少防腐层" class="header-anchor">#</a> 1.缺少防腐层</h5> <p>还是先来看一段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/books&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">NewBookResponse</span> <span class="token function">createBook</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">NewBookRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>service<span class="token punctuation">.</span><span class="token function">createBook</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这段代码是创建一部作品的入口, 也就是说, 它提供了一个 REST 服务, 只要对 /books 这个地址发出一个 POST 请求, 就可以创建一部作品出来. 那这段代码有问题吗?</p> <p>按照一般代码的分层逻辑, 一个 Resource (有的团队称之为 Controller)调用一个 Service, 这符合大多数人的编程习惯, 所以看起来, 这段代码简直是正常得不能再正常了, 这能有什么问题?</p> <p>从 Resource 调用 Service, 这几乎是行业里的标准做法, 是没有问题的, 但问题出在<strong>传递的参数</strong>上. 请问, 这个 NewBookRequest 的参数类应该属于哪一层, 是 resource 层, 还是 service 层呢?</p> <p>一般来说, <strong>既然它是一个请求参数, 通常要承载着诸如参数校验和对象转换的职责</strong>, 按照通常的理解, 它应该属于 resource 层. 如果这个理解是正确的, 问题就来了, 它为什么会传递给 service 层呢?</p> <p>按照通常的架构设计原则, service 层属于核心业务, 而 resource 层属于接口. 二者相较而言, 核心业务的重要程度更高一些, 所以它的稳定程度也应该更高一些. 同样的业务, 可以用 REST 的方式对外提供, 也可以用 RPC 的方式对外提供.</p> <p>说到这, 你就会发现一个问题, NewBookRequest 这个本来应该属于接口层的参数, 现在成了核心业务的一部分, 也就是说, 即便将来提供了 RPC 的接口, 它也要知道 REST 的接口长什么样子, 显然这是有问题的.</p> <p>既然 NewBookRequest 属于 resource 层是有问题的, 那假设它属于 service 层呢? 正如我前面所说, 一般请求都要承担对象校验和转化的工作. 如果说这个类属于 service 层, 但它用在了 resource 的接口上, 作为 resource 的接口, 它会承载一些校验和对象转换的角色, 而 service 层的参数是不需要关心这些的. 如果 NewBookRequest 属于 service 层, 那校验和对象转换的职责到底由谁来完成呢?</p> <p>还有更关键的一点是, <strong>有时候 service 层的参数和 resource 层的参数并不是严格地一一对应</strong>. 比如, 创建作品时, 需要一个识别作者身份的用户 ID, 而这个参数并不是通过客户端发起的请求参数带过来, 而是根据用户登录信息进行识别的. 所以, 用 service 层的参数做 resource 层的参数, 就存在差异的参数如何处理的问题.</p> <p>你有没有发现, 我们突然陷入了一种两难的境地, **如此一个简单的参数, 放到哪个层里都有问题. **</p> <p>那这个问题该如何解呢? 其实, 之所以这么纠结, 一个关键点在于, 我们<strong>缺少了一个模型</strong>.</p> <p>NewBookRequest 之所以弄得如此 &quot;里外不是人&quot;, 主要就是因为它只能扮演一个层中的模型, 所以只要<strong>再引入一个模型就可以破解这个问题</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">NewBookParameter</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">NewBookRequest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">NewBookParameters</span> <span class="token function">toNewBookRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/books&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">NewBookResponse</span> <span class="token function">createBook</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">NewBookRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>service<span class="token punctuation">.</span><span class="token function">createBook</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">toNewBookParameter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>这里引入了一个 NewBookParameter 类, 把它当作 service 层创建作品的入口, 而在 resource 中, 将 NewBookRequest 这个请求类的对象转换成了 NewBookParameter 对象, 然后传到 service 层.</p> <p>在这个结构中, NewBookParameter 属于 service 层, 而 NewBookRequest 属于 resource 层, 二者相互独立, 之前纠结的问题也就不复存在了.</p> <p>现在理解了, 通过增加一个模型, 就破解了依赖关系上的纠结.</p> <p>也许你会说, 虽然它们成了两个类, 但它们两个应该长得一模一样. 这算不算是一种重复呢? 但我的问题是, 它们两个为什么要一样呢? 有了两层不同的参数, 就可以<strong>给不同层次上的模型以不同的约定</strong>了.</p> <p>比如, 对于 resource 层的请求对象, 因为它的主要作用是传输, 所以, 一般来说, <strong>约定请求对象的字段主要是基本类型</strong>. 而 service 的参数对象, 因为它已经是核心业务的一部分, 就需要<strong>全部转化为业务对象</strong>. 举个例子, 比如, 同样表示价格, 在请求对象中, 可以是一个 double 类型, <strong>而在业务参数对象中, 它应该是 Price 类型</strong>.</p> <p>再来解决 resource 层参数和 service 层参数不一致的情况, 现在二者分开了, 那就很清楚地知道, 其实就是在业务参数对象构造的时候, 传入必需的参数即可.</p> <p>比如, 如果需要传入 userId, 可以这么做:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">NewBookRequest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">NewBookParameters</span> <span class="token function">toNewBookRequest</span><span class="token punctuation">(</span><span class="token keyword">long</span> userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/books&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">NewBookResponse</span> <span class="token function">createBook</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">NewBookRequest</span> request<span class="token punctuation">,</span> 
        <span class="token keyword">final</span> <span class="token class-name">Authentication</span> authentication<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> userId <span class="token operator">=</span> <span class="token function">getUserIdentity</span><span class="token punctuation">(</span>authentication<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>service<span class="token punctuation">.</span><span class="token function">createBook</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">toNewBookParameter</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>我们之所以能注意到这个坏味道, 就是从依赖关系入手发现的问题. 我当初注意到这段代码, 因为我团队内部的约定是, 所有的请求对象都属于 resource 层, 但在这段代码里, service 层出现了 resource 层的对象, 它背离了我们对依赖关系设计的约定, 所以这个问题就浮出了水面.</p> <p>实际上, 这个问题也是一个典型的软件设计问题: <strong>缺少防腐层</strong>. 很多人初见这个例子, 可能压根想不到它与防腐层的关系, 那只不过是因为你对这种结构太熟悉了. 其实, <strong>resource 层就是外部请求和核心业务之间的防腐层</strong>. 只要理解了这一点, 就能理解这里要多构建出一个业务参数对象的意义了. 那下面这段代码, 想必你也能轻易地发现问题:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Entity</span>
<span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;user&quot;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@JsonIgnoreProperties</span><span class="token punctuation">(</span>ignoreUnknown <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这是一个 User 类的声明, 它有 @Entity 这个 Anntation, 表示它是一个<strong>业务实体</strong>的对象, 但它的上面还出现了 @JsonIgnoreProperties, 这是就是处理 JSON 的一个 Annotation. JSON 会在哪用到, 通常都是在传输中. 业务实体和传输对象应该具备的特质在同一个类中出现, 显然这也是没有构建好防腐层的结果, <strong>把两个职责混在了一起</strong>.</p> <h5 id="_2-业务代码里的具体实现"><a href="#_2-业务代码里的具体实现" class="header-anchor">#</a> 2.业务代码里的具体实现</h5> <p>再来看一段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Task</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendBook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>service<span class="token punctuation">.</span><span class="token function">sendBook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>feishuSender<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SendFailure</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这是在 &quot;重复代码&quot; 那一讲中提到的一个发送作品信息的函数, 这里的重点在于, 一旦发送过程出了问题, 要通过即时通信工具发送给相关人等, 以防系统出现问题无人发觉. 只不过, 这里给出的是它最初的样子, 也就是通过飞书进行消息发送.</p> <p>因为需求是通过飞书发送, 所以这里就写了飞书发送. 这看上去简直是一个合理得不能再合理的做法了.</p> <p>但是, 请稍等! 这是一种符合直觉的做法, 然而它却<strong>不符合设计原则, 它违反了依赖倒置原则</strong>.</p> <p>简单回顾一下依赖倒置原则:</p> <blockquote><p>高层模块不应依赖于低层模块, 二者应依赖于抽象.</p> <p>High-level modules should not depend on low-level modules. Both should depend on abstractions.</p></blockquote> <blockquote><p>抽象不应依赖于细节, 细节应依赖于抽象.</p> <p>Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.</p></blockquote> <p>我之所以会注意到这段代码, 因为<strong>在一段业务处理中出现了一个具体的实现</strong>, 也就是这里的 feishuSender.</p> <p>你需要知道, <mark><strong>业务代码中任何与业务无关的东西都是潜在的坏味道</strong></mark>.</p> <p>在这里, 飞书肯定不是业务的一部分, 它只是<strong>当前选择的一个具体实现</strong>. 换言之, 是否选择飞书, 与团队当前的状态是相关的, 如果哪一天团队切换即时通信软件, 这个实现就需要换掉. 但团队是不可能切换业务的, 一旦切换, 那就是一个完全不同的系统了.</p> <p><strong>识别一个东西是业务的一部分, 还是一个可以替换的实现, 不妨问问自己, 如果不用它, 是否还有其它的选择?</strong></p> <p>就像这里, 飞书是可以被其它即时通信软件替换的. 另外, 常见的中间件, 比如, Kafka, Redis, MongoDB 等等, 通常也都是一个具体的实现, 其它中间件都可以把它替换掉. 所以它们在业务代码里出现, 那一定就是一个坏味道了.</p> <p>既然已经知道了这些具体的东西是一种坏味道, 那该怎么解决呢? 可以引入一个<strong>模型</strong>, 也就是这个具体实现所要扮演的角色, <strong>通过它, 将业务和具体的实现隔离开来</strong>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">FailureSender</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">SendFailure</span> failure<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">FeishuFailureSenderS</span> <span class="token keyword">implements</span> <span class="token class-name">FailureSender</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这里通过引入一个 FailureSender, <strong>业务层只依赖于这个 FailureSender 的接口就好</strong>, 而具体的飞书实现可以通过依赖注入的方式注入进去.</p> <p>依赖关系是软件开发中非常重要的一个东西, 然而很多程序员在写代码的时候, 由于开发习惯的原因, 常常会忽略掉依赖关系这件事本身. 现在已经有一些工具, 可以保证在写代码的时候, 不会出现严重破坏依赖关系的情况, 比如, 像前面那种 service 层调用 resource 层的代码.</p> <p>在 Java 世界里, 就可以用 ArchUnit 来保证这一切. 看名字就不难发现, 它是把这种架构层面的检查做成了单元测试, 下面就是这样的一个单元测试:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">should_follow_arch_rule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">JavaClasses</span> clazz <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassFileImporter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">importPackages</span><span class="token punctuation">(</span><span class="token string">&quot;...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ArchRule</span> rule <span class="token operator">=</span> <span class="token function">layeredArchitecture</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">layer</span><span class="token punctuation">(</span><span class="token string">&quot;Resource&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">definedBy</span><span class="token punctuation">(</span><span class="token string">&quot;..resource..&quot;</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">layer</span><span class="token punctuation">(</span><span class="token string">&quot;Service&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">definedBy</span><span class="token punctuation">(</span><span class="token string">&quot;..service..&quot;</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">whereLayer</span><span class="token punctuation">(</span><span class="token string">&quot;Resource&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mayNotBeAccessedByAnyLayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">whereLayer</span><span class="token punctuation">(</span><span class="token string">&quot;Service&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mayOnlyBeAccessedByLayers</span><span class="token punctuation">(</span><span class="token string">&quot;Resource&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    rule<span class="token punctuation">.</span><span class="token function">check</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在这里定义了两个层, 分别是 Resource 层和 Service 层, 而且要求 Resource 层的代码不能被其它层访问, 而 Service 层的代码只能由 Resource 层方法访问. 这就是<strong>架构规则</strong>, 一旦代码里有违反这个架构规则的代码, 这个测试就会失败, 问题也就会暴露出来.</p> <h5 id="_3-总结时刻-8"><a href="#_3-总结时刻-8" class="header-anchor">#</a> 3.总结时刻</h5> <p>今天讲了由于代码依赖关系而产生的坏味道, <strong>一种是缺少防腐层, 导致不同代码糅合在一起, 一种是在业务代码中出现了具体的实现类</strong>.</p> <p>缺少防腐层, 会让请求对象传导到业务代码中, 造成了业务与外部接口的耦合, 也就是业务依赖了一个外部通信协议. 一般来说, 业务的稳定性要比外部接口高, 这种反向的依赖就会让业务一直无法稳定下来, 继而在日后带来更多的问题. 解决方案自然就是引入一个防腐层, 将业务和接口隔离开来.</p> <p>业务代码中出现具体的实现类, 实际上是违反了依赖倒置原则. 因为违反了依赖倒置原则, 业务代码也就不可避免地受到具体实现的影响, 也就造成了业务代码的不稳定. 识别一段代码是否属于业务, 不妨问一下, 看把它换成其它的东西, 是否影响业务. <strong>解决这种坏味道就是引入一个模型, 将业务与具体的实现隔离开来</strong>.</p> <p>如果今天的内容你只能记住一件事, 那请记住: <strong>代码应该向着稳定的方向依赖</strong>.</p> <h4 id="不一致的代码-为什么你的代码总被吐槽难懂"><a href="#不一致的代码-为什么你的代码总被吐槽难懂" class="header-anchor">#</a> 不一致的代码:为什么你的代码总被吐槽难懂?</h4> <p>大多数程序员都是在一个团队中工作, 对于一个团队而言, 一致性是非常重要的一件事. <strong>因为不一致会造成认知上的负担, 在一个系统中, 做类似的事情, 却有不同的做法, 或者起到类似作用的事物, 却有不同的名字, 这会让人产生困惑</strong>. 所以, 即便是不甚理想的标准, 也比百花齐放要好.</p> <p>大部分程序员对于一致性本身的重要性是有认知的. 但通常来说, 大家理解的一致性都表现在比较大的方面, 比如, 数据库访问是叫 DAO 还是叫 Mapper, 抑或是 Repository, 在一个团队内, 这是有统一标准的, 但编码的层面上, 要求往往就不是那么细致了. 所以才会看到在代码细节上呈现出了各种不一致. 还是从一段具体的代码来分析问题.</p> <h5 id="_1-命名中的不一致"><a href="#_1-命名中的不一致" class="header-anchor">#</a> 1.命名中的不一致</h5> <p>有一次, 我在代码评审中看到了这样一段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">enum</span> <span class="token class-name">DistributionChannel</span> <span class="token punctuation">{</span>
    <span class="token constant">WEBSITE</span><span class="token punctuation">,</span>
    <span class="token constant">KINDLE_ONLY</span><span class="token punctuation">,</span>
    <span class="token constant">AL</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这段代码使用标记作品的分发渠道, 从这段代码的内容上, 可以看到, 目前的分发渠道包括网站(WEBSITE), 只在 Kindle(KINDLE_ONLY), 还是全渠道(ALL).</p> <p>面对这段代码, 我有些疑惑, 于是我提了一个问题:</p> <blockquote><p>我: 这里的 WEBSITE 和 KINDLE_ONLY 分别表示的是什么?</p> <p>同事: WEBSITE 表示作品只会在我们自己的网站发布, KINDLE_ONLY 表示这部作品只会在 Kindle 的电子书商店里上架.</p> <p>我: 二者是不是都表示只在单独一个渠道发布?</p> <p>同事: 是啊!</p> <p>我: 既然二者都有只在一个平台上架发布的含义, 为什么不都叫 XXX 或者 XXX_ONLY?</p> <p>同事: 呃, 你说得有道理.</p></blockquote> <p>我之所以会注意到这里的问题, 一个主要的原因就是, 在这里 WEBSITE 和 KINDLE_ONLY 两个名字的不一致.</p> <p>按照我对一致性的理解, 表示<strong>类似含义的代码应该有一致的名字</strong>, 比如, 很多团队里都会把业务写到服务层, 各种服务的命名也通常都是 XXXService, 像 BookService, ChapterService 等等. 而<strong>一旦出现了不一致的名字, 通常都表示不同的含义</strong>, 比如, 对于那些非业务入口的业务组件, 它们的名字就会不一样, 会更符合其具体业务行为, 像 BookSender, 它表示将作品发送到翻译引擎.</p> <p>一般来说, 枚举值表示的含义应该都有一致的业务含义, 一旦出现不同就需要确定不同的点到底在哪里, 这就是我提问的缘由.</p> <p>显然, 这段代码的作者给这两个枚举值命名时, 只是分别考虑了它应该起什么名字, 却忽略了这个枚举值在整体中扮演的角色.</p> <p>理解这一点, 改动是很容易, 后来代码被统一成了一个形式:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">enum</span> <span class="token class-name">DistributionChannel</span> <span class="token punctuation">{</span>
    <span class="token constant">WEBSITE</span><span class="token punctuation">,</span>
    <span class="token constant">KINDLE</span><span class="token punctuation">,</span>
    <span class="token constant">AL</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h5 id="方案中的不一致"><a href="#方案中的不一致" class="header-anchor">#</a> 方案中的不一致</h5> <p>还是在一次代码评审中, 我看到了这样一段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">nowTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">DateFormat</span> format <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Date</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> format<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这是一段生成时间戳的代码, 当一个系统向另外一个系统发送请求时, 需要带一个时间戳过去, 这里就是把这个时间戳按照一定格式转成了字符串类型, 主要就是传输用, 便于另外的系统进行识别, 也方便在开发过程中进行调试.</p> <p>先声明一下, 这段代码本身的实现是没有问题的. 它甚至考虑到了 SimpleDateFormat 这个类本身存在的多线程问题, 所以它每次去创建了一个新的 SimpleDateFormat 对象.</p> <p>那为什么还说它是有问题的呢? <strong>因为这种写法是 Java 8 之前的写法</strong>. 在很长的一段时间里, Java 的日期时间解决方案一直是一个备受争议的设计, 它的问题很多, 有的是概念容易让人混淆(比如: Date 和 Calendar 什么情况下该用哪个), 有的是接口设计的不直观(比如: Date 的 setMonth 参数是从 0 到 11), 有的是实现容易造成问题(比如: 前面提到的 SimpleDateFormat 需要考虑多线程并发的问题, 需要每次构建一个新的对象出来).</p> <p>这种乱象存在了很长时间, 有很多人都在尝试解决这个问题(比如 Joda Time). 从 Java 8 开始, Java 官方的 SDK 借鉴了各种程序库, 引入了<strong>全新的日期时间解决方案. 这套解决方案与原有的解决方案是完全独立的, 也就是说, 使用这套全新的解决方案完全可以应对所有工作</strong>.</p> <p>我们现在的这个项目是一个全新的项目, 使用的版本是 Java 11, 这就意味着完全可以使用这套从 Java 8 引入的日期时间解决方案. 所以<strong>在项目里的约定就是所有的日期时间类型就是使用这套新的解决方案</strong>.</p> <p>现在你可能已经知道我说的问题在哪里了, 在这个项目里, 我们的要求是使用新的日期时间解决方案, 而这里的 SimpleDateFormat 和 Date 是旧解决方案的一部分. 所以, 虽然这段代码本身的实现是没有问题的, 然而放在项目整体中, 这却是一个坏味道, 因为<strong>它没有和其它的部分保持一致</strong>.</p> <p>后来, 同事用新的解决方案改写了原来的代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">nowTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">LocalDateTime</span> now <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> now<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>之所以会出现这样的问题, 主要是因为一个项目中, <strong>应对同一个问题出现了多个解决方案, 如果没有一个统一的约定, 项目成员会根据自己写代码时的感觉随机选择一个方案, 这样的结果就是出现方案上的不一致</strong>.</p> <p>为什么一个项目中会出现多个解决方案呢? 一个原因就是时间. 随着时间流逝, 人们会意识到原有解决方案存在的各种问题, 于是有人就会提出新的解决方案, 像这里提到的 Java 日期时间的解决方案, 就是 JDK 本身随时间演化造成的. 有的项目时间比较长, 也会出现类似的问题, 尤其是像 C/C++ 这种自造轮子的重灾区.</p> <p>有时, 程序员也会因为自己的原因引入不一致. 比如, 在代码中<strong>引入做同一件事情类似的程序库</strong>. 像判断字符串是否为空或空字符串, Java 里常用的程序库就有 Guava 和 Apache 的 Commons Lang, 它们能做类似的事情, 所以程序员也会根据自己的熟悉程度选择其中之一来用, 造成代码中出现不一致.</p> <p>这两个程序库是很多程序库的基础, 经常因为引入了其它程序库, 相应的依赖就出现在我们的代码中. 所以必须约定, 哪种做法是在项目中的标准做法, 以防出现各自为战的现象. 比如, 在我的团队中, 就选择 Guava 作为基础库, 因为相对来说, 它的风格更现代, 所以团队就约定类似的操作<strong>都以 Guava 为准</strong>.</p> <h5 id="_2-代码中的不一致"><a href="#_2-代码中的不一致" class="header-anchor">#</a> 2.代码中的不一致</h5> <p>再来看一段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createBook</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BookId</span><span class="token punctuation">&gt;</span></span> bookIds<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Book</span><span class="token punctuation">&gt;</span></span> books <span class="token operator">=</span> bookService<span class="token punctuation">.</span><span class="token function">getApprovedBook</span><span class="token punctuation">(</span>bookIds<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">CreateBookParameter</span> parameter <span class="token operator">=</span> <span class="token function">toCreateBookParameter</span><span class="token punctuation">(</span>books<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">HttpPost</span> post <span class="token operator">=</span> <span class="token function">createBookHttpRequest</span><span class="token punctuation">(</span>parameter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    httpClient<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>post<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这是一段在翻译引擎中创建作品的代码. 首先根据要处理的作品 ID 获取其中已经审核通过的作品, 然后发送一个 HTTP 请求在翻译引擎中创建出这个作品.</p> <p>这么短的一段代码有什么问题吗? 问题就在于这段代码中的不一致. 你可能会想: &quot;不一致? 不一致体现在哪里呢?&quot; 答案就是, <strong>这些代码不是一个层次的代码</strong>.</p> <p>通过了解这段代码的背景, 你可能已经看出一些端倪了. 首先是获取审核通过的作品, 这是一个<strong>业务动作</strong>, 接下来的三行其实是在做一件事, 也就是发送创建作品的请求. 具体到代码上, 这三行代码分别是创建请求的参数, 根据参数创建请求, 最后, 再把请求发送出去. 这三行代码合起来完成了一个发送创建作品请求这么一件事, 而这件事才是一个完整的业务动作.</p> <p>所以说这个函数里的代码并不在一个层次上, 有的是业务动作, 有的是业务动作的细节. 理解了这一点, 就可以把这些业务细节的代码提取到一个函数里:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createBook</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BookId</span><span class="token punctuation">&gt;</span></span> bookIds<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Book</span><span class="token punctuation">&gt;</span></span> books <span class="token operator">=</span> bookService<span class="token punctuation">.</span><span class="token function">getApprovedBook</span><span class="token punctuation">(</span>bookIds<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">createRemoteBook</span><span class="token punctuation">(</span>books<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">createRemoteBook</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Book</span><span class="token punctuation">&gt;</span></span> books<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token class-name">CreateBookParameter</span> parameter <span class="token operator">=</span> <span class="token function">toCreateBookParameter</span><span class="token punctuation">(</span>books<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">HttpPost</span> post <span class="token operator">=</span> <span class="token function">createBookHttpRequest</span><span class="token punctuation">(</span>parameter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    httpClient<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>post<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>从结果上看, 原来的函数(createBook)里面全都是<strong>业务动作</strong>, 而提取出来的函数(createRemoteBook)则都是<strong>业务动作的细节</strong>, 各自的语句都是在一个层次上了.</p> <p>一旦将不同的关注点分解出来, 还可以进一步调整代码的结构. 像前面拆分出来的这个方法, 我们已经知道它的作用是发出一个请求去创建作品, 本质上并不属于这个业务类的一部分. 所以还可以通过引入一个新的模型, 将这个部分调整出去:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createBook</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BookId</span><span class="token punctuation">&gt;</span></span> bookIds<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Book</span><span class="token punctuation">&gt;</span></span> books <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>bookService<span class="token punctuation">.</span><span class="token function">getApprovedBook</span><span class="token punctuation">(</span>bookIds<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>translationEngine<span class="token punctuation">.</span><span class="token function">createBook</span><span class="token punctuation">(</span>books<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">TranslationEngine</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createBook</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Book</span><span class="token punctuation">&gt;</span></span> books<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token class-name">CreateBookParameter</span> parameter <span class="token operator">=</span> <span class="token function">toCreateBookParameter</span><span class="token punctuation">(</span>books<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">HttpPost</span> post <span class="token operator">=</span> <span class="token function">createBookHttpRequest</span><span class="token punctuation">(</span>parameter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        httpClient<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>post<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ..</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>我估计, 这段代码的调整, 超出了很多人对于 &quot;代码应该怎么写&quot; 的认知范围. 一说到分层, 大多数人想到的只是模型的分层, 很少有人会想到在函数的语句中也要分层. 各种层次的代码混在一起, 许多问题也就随之而来了, 最典型莫过于之前讲过的长函数.</p> <p>从本质上说, 我们在做的依然是模型的分层, 只不过, 这次的出发点是函数的语句. 这也是我一直强调的 &quot;分离关注点, 越小越好&quot; 的意义所在. 观察代码的粒度足够小, 很多问题自然就会暴露出来.</p> <p>这里顺便说一个与测试相关的话题, 程序员开始写测试时, 有一个典型的问题: 如何测试一个私有方法. 有人建议用一些特殊能力(比如反射)去测试. 我给这个问题的答案是, <strong>不要测私有方法</strong>.</p> <p>之所以有测试私有方法的需求, 一个重要的原因就是分离关注点没有做好, 把不同层次的代码混在了一起. 前面这段代码, 如果要测试前面那个 createRemoteBook 方法还是有一定难度的, 但调整之后, 引入了 TranslationEngine 这个类, 这个方法就变成了一个公开方法, 就可以按照一个公开方法去测试了, 所有的问题迎刃而解.</p> <p><strong>很多程序员纠结的技术问题, 其实是一个软件设计问题</strong>, 不要通过奇技淫巧去解决一个本来不应该被解决的问题.</p> <h5 id="_3-总结时刻-9"><a href="#_3-总结时刻-9" class="header-anchor">#</a> 3.总结时刻</h5> <p>今天讲了因为不一致导致的一些问题, 对于一个团队来说, 一致是非常重要的, 是降低集体认知成本的重要方式. 我们分别见识了:</p> <ol><li><strong>命名中的不一致;</strong></li> <li><strong>方案中的不一致;</strong></li> <li><strong>代码中的不一致.</strong></li></ol> <p>类似含义的代码应该有类似的命名, 不一致的命名表示不同的含义, 需要给出一个有效的解释.</p> <p><strong>方案中的不一致, 一方面是由于代码长期演化造成的, 另一方面是项目中存在完成同样功能的程序库. 无论是哪种原因, 都需要团队先统一约定, 保证所有人按照同一种方式编写代码</strong>.</p> <p>代码中的不一致常常是把不同层次的代码写在了一起, 最典型的就是把业务层面的代码和实现细节的代码混在一起. 解决这种问题的方式, 就是通过提取方法, 把不同层次的代码放到不同的函数里, 而这一切的前提还是是分离关注点, 这个代码问题的背后还是设计问题.</p> <p>如果今天的内容你只能记住一件事, 那请记住: <strong>保持代码在各个层面上的一致性</strong>.</p> <h4 id="落后的代码风格-使用-新-的语言特性和程序库升级你的代码"><a href="#落后的代码风格-使用-新-的语言特性和程序库升级你的代码" class="header-anchor">#</a> 落后的代码风格:使用&quot;新&quot;的语言特性和程序库升级你的代码</h4> <p>上一讲提到的 &quot;方案不一致&quot;, 是因为随着时间的流逝, 总会有一些新的方案产生, 替换原有的方案. 这其中, 最明显的一个例子就是程序设计语言. 没有哪门语言是完美的, 所以只要有一个活跃的社区, 这门语言就会不断地演进.</p> <p>从 C++ 11 开始, C++ 开始出现了大规模的演化, 让之前学习 C++ 的人感觉自己就像没学过这门语言一样; Python 2 与 Python 3 甚至是不兼容的演化; Java 也是每隔一段时间就会出现一次大的语言演进.</p> <p>也正是因为语言本身的演化, 在不同时期接触不同版本的程序员写出来的程序, 甚至不像是在用同一门语言在编程. 所以, 我们有机会看到<strong>在同一个代码库中, 各种不同时期风格的代码并存</strong>.</p> <p>通常来说, <strong>新的语言特性都是为了提高代码的表达性, 减少犯错误的几率</strong>. 所以在实践中, 非常鼓励你采用新的语言特性写代码的.</p> <p>这一讲就以 Java 为例, 讲讲如何使用 &quot;新&quot; 语言特性让代码写得更好. 其实, 这里的 &quot;新&quot; 只是相对的, 我准备讨论的是 Java 8 的语言特性, 按照官方的标准, 这是一个已经到了生命周期终点的版本, 只不过, 从语言特性上来说, Java 8 是最近有重大变更的一个版本, 而很多程序员的编码习惯停留在更早的版本.</p> <h5 id="_1-optional"><a href="#_1-optional" class="header-anchor">#</a> 1.Optional</h5> <p>先来看一段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> name <span class="token operator">=</span> book<span class="token punctuation">.</span><span class="token function">getAuthor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这是在讲 &quot;缺乏封装&quot; 时用到的一个例子, 这里暂且不考虑缺乏封装的问题. 即便如此, 严格地说, 这段代码依然是有问题的. 因为它没有考虑对象可能为 null 的场景.</p> <p>所以这段代码更严谨的写法是这样:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Author</span> author <span class="token operator">=</span> book<span class="token punctuation">.</span><span class="token function">getAuthor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token punctuation">(</span>author <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> author<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>然而, 在很多真实的项目中, 这种严格的写法却是稀有的, 所以在实际的运行过程中, 总会惊喜地发现各种空指针异常. 如果你要问程序员为什么不写对象为 null 的判断, 答案很可能出乎你意料: 他们忘了.</p> <p>是的, 忘了, 就是这么简单得令人发指的理由.</p> <p>不用过于责备这些程序员缺乏职业素养, 因为这不是个体问题, 而是行业整体的问题, IT 行业每年都会因此造成巨大的损失. 空指针的发明者 Tony Hoare 将其称为 &quot;自己犯下的十亿美元错误&quot;.</p> <p>对于这个如此常见的问题, Java 8 中已经给出了一个解决方案, 它就是 <strong>Optional</strong>. Optional 提供了一个对象容器, 你需要从中 &quot;取出(get)&quot; 你所需要的对象, 但在<strong>取出之前, 需要判断一下这个对象容器中是否真的存在一个对象</strong>. 用这个思路可以这样改写这段代码:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Book</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Author</span><span class="token punctuation">&gt;</span></span> <span class="token function">getAuthor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Optioanl</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>author<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Author</span><span class="token punctuation">&gt;</span></span> author <span class="token operator">=</span> book<span class="token punctuation">.</span><span class="token function">getAuthor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> name <span class="token operator">=</span> author<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> author<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这种做法和之前做法的最大差别在于, 你不会忘掉判断对象是否存在的过程, 因为需要从 Optional 这个对象容器中取出存在里面的对象. 正是<strong>这多出来的一步, 减少了 &quot;忘了&quot; 的概率</strong>.</p> <p>也是因为多了 Optional 这个类, 这段代码其实还有更简洁的写法:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Author</span><span class="token punctuation">&gt;</span></span> author <span class="token operator">=</span> book<span class="token punctuation">.</span><span class="token function">getAuthor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> name <span class="token operator">=</span> author<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>有了 Optional, 可以在项目中做一个约定, <mark><strong>所有可能为 null 的返回值, 都要返回 Optional, 以此减少犯错的几率</strong></mark>.</p> <p>事实上, 鉴于空对象是一个普遍存在的问题, 一些程序设计语言甚至为此专门设计了语法, 比如, 类似的代码用 Kotlin 或 Groovy 写出来的话, 应该是这下面这样:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>val author <span class="token operator">=</span> book<span class="token punctuation">.</span>author
val name <span class="token operator">=</span> author<span class="token operator">?</span><span class="token punctuation">.</span>name
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h5 id="函数式编程"><a href="#函数式编程" class="header-anchor">#</a> 函数式编程</h5> <p>Optional 是 Java 8 引入的新特性, 它的出现改变了编写 Java 代码的习惯用法. 接下来看看另外一个改变我们代码习惯用法的特性.</p> <p>在讲 &quot;滥用控制语句&quot; 那一讲时, 说循环语句本身就是一个坏味道. 接下来就来说一下这个问题. 还是先从一段代码开始:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ChapterParameters</span> <span class="token function">toParameters</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Chapter</span><span class="token punctuation">&gt;</span></span> chapters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ChapterParameter</span><span class="token punctuation">&gt;</span></span> parameters <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Chapter</span> chapter <span class="token operator">:</span> chapters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>chapter<span class="token punctuation">.</span><span class="token function">isApproved</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            parameters<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">toChapterParameter</span><span class="token punctuation">(</span>chapter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ChapterParameters</span><span class="token punctuation">(</span>parameters<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这是一段向翻译引擎发送章节信息前准备参数的代码, 这里首先筛选出审核通过的章节, 然后再把章节转换成与翻译引擎通信的格式, 最后再把所有得到的单个参数打包成一个完整的章节参数.</p> <p>如果按照 Java 8 之前的版本理解, 这段代码是一段很正常的代码. 当 Java 的时代进入到 8 之后, 这段代码就成了有坏味道的代码.</p> <p>Martin Fowler 在《重构》的第二版中新增的坏味道就包括了循环语句(Loops). 之所以循环语句成了坏味道, 一个重要的原因就是函数式编程的兴起. <strong>不是我们不需要遍历集合, 而是有了更好的遍历集合的方式.</strong></p> <p>函数式编程的一个重要洞见就是, 大部分操作都可以归结成列表转换, 其中最核心的列表转换就是 map, filter 和 reduce. 在函数式编程日益重要的今天, 列表转换已经成为了每个程序员应该必备的基本功.</p> <p>了解了这些, 就知道为什么循环语句是坏味道了, 因为<strong>大部分循环语句都是在对一个元素集合进行操作, 而这些操作基本上都可以用列表操作进行替代</strong>.</p> <p>再者, 一般来说, 采用列表转换写出来的代码相较于传统的循环语句写出来的代码, 表达性更好, 因为它们都是描述做什么, 而传统的循环语句是在描述怎么做. 这是两种不同的抽象层次, 描述做什么比怎么做的代码, 在表达性上要好得多.</p> <p>有了这些基础, 再来看这段代码. 这段代码中有一个循环语句, 正如前面所说, 这个循环语句在处理的是一个集合中的元素, 所以这个循环语句是<strong>可以用列表转换的方式代替</strong>的.</p> <p>具体怎么做呢? 其实, 这里的行为在前面已经分析过了, 就是先筛选出审核通过的章节, 这个过程对应着 filter, 然后,把筛选出来的章节转换成通信中的参数, 这个过程对应着 map, 最后把转换的结果搜集起来, 这个过程对应着 reduce. 所以这段代码可以改写成这样:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ChapterParameters</span> <span class="token function">toParameters</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Chapter</span><span class="token punctuation">&gt;</span></span> chapters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ChapterParameter</span><span class="token punctuation">&gt;</span></span> parameters <span class="token operator">=</span> chapters<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">Chapter</span><span class="token operator">::</span><span class="token function">isApproved</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">::</span><span class="token function">toChapterParameter</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ChapterParameters</span><span class="token punctuation">(</span>parameters<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>经过这样的改造, 一个循环语句就彻底被一个列表转换的操作替换掉了(这里的 collect 函数对应着 reduce 操作). 在这段代码中, 用到了 Java 8 提供的一些基础设施, 比如 Stream, lambda 和方法引用等等.</p> <p>或许有人会说, 这段代码看着还不如原来的循环语句简单. 不过, 你要知道的是, 两种写法根本的差别是侧重点不同, <strong>循环语句是在描述实现细节, 而列表转换的写法是在描述做什么, 二者的抽象层次不同</strong>.</p> <p>对于理解这段代码的人来说, 二者提供的信息量是完全不同的, 循环语句必须要做一次 &quot;阅读理解&quot; 知晓了其中的细节才能把整个场景拼出来, 而列表转换的写法则基本上和用语言叙述的过程一一对应. 所以, 理解的难度是完全不同的.</p> <p>这段代码只是为了说明问题, 而选择了简单的代码, 但在实际工作中, 需求会比这复杂得多. 而且如果要添加新的需求, 循环语句里的代码会随之变得越来越复杂, 原因就是循环语句里都是细节, 而列表转换则是一段一段的描述, 就像在阅读一篇文章.</p> <p>很多人之所以更喜欢使用循环语句而不是列表转换, 一个重要原因是对于列表转换的基础还不了解. 只要多写几次 filter, map 和 reduce, 理解它们就会像理解选择语句和循环语句一样自然.</p> <p>到这里有人会说: &quot;你说得有点道理, 但为什么我的感觉和你不一样, 在实践中, 我也使用了这种风格, 为什么写出来的代码感觉更难理解了?&quot; 对于这一点, 一个常见的原因就是, 你在<strong>列表转换过程中写了太多代码</strong>.</p> <p>自从 Java 里引入了 lambda, 因为写起来实在是太容易了, 很多人就直接在列表转换过程中写 lambda. lambda 本身相当于一个匿名函数, 所以很多人在写函数中犯的错误在 lambda 里也一样出现了, 最典型的当然就是长函数.</p> <p>在各种程序设计语言中, lambda 都是为了写短小代码提供的便利, 所以 lambda 中写出大片的代码, 根本就是违反 lambda 设计初衷的. <strong>最好的 lambda 应该只有一行代码</strong>.</p> <p>那如果一个转换过程中有很多操作怎么办呢? 很简单, <strong>提取出一个函数</strong>, 就像前面代码中的 toChapterParameter, 它负责完成从 Chapter 到 ChapterParameter 的转换. 这样一来, <strong>列表转换的本身就完全变成了一个声明, 这样的写法才是能发挥出列表转换价值的写法</strong>.</p> <p>在这一讲中, 以 Optional 和函数式编程为例, 讲解了用 &quot;新&quot; 的代码风格改进代码, 其实在前面的内容中也已经讲了不少 &quot;新&quot; 的代码风格, 比如使用 Java 8 的时间日期类型, try-with-resource 等等. 在讲解的过程中, 也提到过不少的编码风格实际上是停留在过去, 比如变量初始化的习惯.</p> <p>可以看到, 代码风格有一个逐步演化的过程, 每个程序员对此的理解程度都有所差异, 所以如果不加注意的话, 各种代码风格会并存于代码之中, 加剧代码的理解难度, 这就是上一讲讲到的坏味道: 不一致.</p> <p>一种编程风格会过时, 本质上是因为它存在问题, 新代码风格就是用更好的方案解决它, 就像今天讲到的 Optional. 所以要不断学习新引入的语言特性, 了解它们给语言带来的 &quot;新&quot; 风格, 而不要停留在原地.</p> <h5 id="_2-总结时"><a href="#_2-总结时" class="header-anchor">#</a> 2.总结时</h5> <p>今天讲了 &quot;新&quot; 风格对于代码的改善. 每一种有生命力的语言都会在自己的生命周期中不断地对语言本身进行改进, 无论是引入新的语言特性, 还是引入新的程序库, 都会对代码的编写产生或多或少的影响. 这一讲用来讲解的例子是 Java 8 引入的 <strong>Optional 和函数式编程</strong>.</p> <p>Optional 是一个对象容器, 它的出现是为了规避空对象带来的各种问题. Optional 的引入可以减少由于程序员的忽略而引发对空对象的问题. 团队内部可以约定, 所有可能返回空对象的地方, 都要返回 Optional, 以此降低犯错的几率.</p> <p>函数式编程是一个影响代码整体风格的重要编程范式, 然而对于很多 Java 程序员来说, Java 8 引入的函数式编程支持, 只是引入了一些新的程序库. 缺乏对于函数式编程的理解, 尤其是对于列表转换思维的理解, 让我们虽然有了很多很好的工具, 却完全无法发挥其功效.</p> <p>懂得列表转换思维, 首先要懂得最基本的几个操作: map, filter 和 reduce, 然后就可以把大部分的集合操作转换成列表转换. 想要使用这种思维写好代码, 一方面要懂得声明式代码的重要性, 另一方面, 要懂得写出短小的函数, 不要在 lambda 中写过多的代码.</p> <p>如果今天的内容你只能记住一件事, 那请记住: <strong>不断学习&quot;新&quot;的代码风格, 不断改善自己的代码</strong>.</p> <p>‍</p> <p>‍</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/20.开发/2100.开发/800.代码质量/730.代码之丑(极客时间)🌸.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/474cdf/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">阿里巴巴编程规范</div></a> <a href="/pages/4d4606/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Java业务开发常见错误100例(极客时间)🌸</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/474cdf/" class="prev">阿里巴巴编程规范</a></span> <span class="next"><a href="/pages/4d4606/">Java业务开发常见错误100例(极客时间)🌸</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/140.c5c375d3.js" defer></script>
  </body>
</html>
