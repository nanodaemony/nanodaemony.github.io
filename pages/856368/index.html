<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>DDD实战课(极客时间)🌸 | Pangolin Note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="大道至简">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.56073ad3.css" as="style"><link rel="preload" href="/assets/js/app.3f3e0e10.js" as="script"><link rel="preload" href="/assets/js/2.e9fcb30c.js" as="script"><link rel="preload" href="/assets/js/3.1998f389.js" as="script"><link rel="preload" href="/assets/js/93.6bf5fb66.js" as="script"><link rel="prefetch" href="/assets/js/10.0b55747f.js"><link rel="prefetch" href="/assets/js/100.b8912a99.js"><link rel="prefetch" href="/assets/js/101.a6740c8a.js"><link rel="prefetch" href="/assets/js/102.e31e89b2.js"><link rel="prefetch" href="/assets/js/103.2c5dbdae.js"><link rel="prefetch" href="/assets/js/104.0e9c02f6.js"><link rel="prefetch" href="/assets/js/105.8288396c.js"><link rel="prefetch" href="/assets/js/106.62f43c11.js"><link rel="prefetch" href="/assets/js/107.70c90211.js"><link rel="prefetch" href="/assets/js/108.b488ce56.js"><link rel="prefetch" href="/assets/js/109.12942650.js"><link rel="prefetch" href="/assets/js/11.ac3fd1ca.js"><link rel="prefetch" href="/assets/js/110.1e57ecba.js"><link rel="prefetch" href="/assets/js/111.6e33b4ea.js"><link rel="prefetch" href="/assets/js/112.bd52831b.js"><link rel="prefetch" href="/assets/js/113.868c1ac9.js"><link rel="prefetch" href="/assets/js/114.090549d1.js"><link rel="prefetch" href="/assets/js/115.d97f6c2b.js"><link rel="prefetch" href="/assets/js/116.097c4b4e.js"><link rel="prefetch" href="/assets/js/117.4024cfe2.js"><link rel="prefetch" href="/assets/js/118.e3057cba.js"><link rel="prefetch" href="/assets/js/119.4ef1fa3b.js"><link rel="prefetch" href="/assets/js/12.863eaabe.js"><link rel="prefetch" href="/assets/js/120.78f9df50.js"><link rel="prefetch" href="/assets/js/121.8e16df87.js"><link rel="prefetch" href="/assets/js/122.f21c0107.js"><link rel="prefetch" href="/assets/js/123.ea1cb375.js"><link rel="prefetch" href="/assets/js/124.01c04c6e.js"><link rel="prefetch" href="/assets/js/125.d383e301.js"><link rel="prefetch" href="/assets/js/126.3162cb47.js"><link rel="prefetch" href="/assets/js/127.c6bebae6.js"><link rel="prefetch" href="/assets/js/128.d659db60.js"><link rel="prefetch" href="/assets/js/129.2afdcf48.js"><link rel="prefetch" href="/assets/js/13.4f59ce35.js"><link rel="prefetch" href="/assets/js/130.beb9ed9d.js"><link rel="prefetch" href="/assets/js/131.35b05f8a.js"><link rel="prefetch" href="/assets/js/132.d77f4f93.js"><link rel="prefetch" href="/assets/js/133.4ceda6e5.js"><link rel="prefetch" href="/assets/js/134.11390c5f.js"><link rel="prefetch" href="/assets/js/135.32f9e38f.js"><link rel="prefetch" href="/assets/js/136.6d8bb0f2.js"><link rel="prefetch" href="/assets/js/137.9c0ffeef.js"><link rel="prefetch" href="/assets/js/138.88d86e5f.js"><link rel="prefetch" href="/assets/js/139.8c2c3d6c.js"><link rel="prefetch" href="/assets/js/14.11c82d35.js"><link rel="prefetch" href="/assets/js/140.c5c375d3.js"><link rel="prefetch" href="/assets/js/141.d703f30b.js"><link rel="prefetch" href="/assets/js/142.6a005a44.js"><link rel="prefetch" href="/assets/js/143.9b2edf6f.js"><link rel="prefetch" href="/assets/js/144.3fd013c9.js"><link rel="prefetch" href="/assets/js/145.b05079c5.js"><link rel="prefetch" href="/assets/js/146.ed5360a6.js"><link rel="prefetch" href="/assets/js/147.7408d86f.js"><link rel="prefetch" href="/assets/js/148.f390b370.js"><link rel="prefetch" href="/assets/js/149.95017f0a.js"><link rel="prefetch" href="/assets/js/15.bd143bd5.js"><link rel="prefetch" href="/assets/js/150.f0ede764.js"><link rel="prefetch" href="/assets/js/151.b7093623.js"><link rel="prefetch" href="/assets/js/152.a82a6c83.js"><link rel="prefetch" href="/assets/js/153.965e3fb2.js"><link rel="prefetch" href="/assets/js/154.9e49311e.js"><link rel="prefetch" href="/assets/js/155.cef33ba5.js"><link rel="prefetch" href="/assets/js/156.bcc397ae.js"><link rel="prefetch" href="/assets/js/157.90824739.js"><link rel="prefetch" href="/assets/js/158.efd429b9.js"><link rel="prefetch" href="/assets/js/159.122ff5b7.js"><link rel="prefetch" href="/assets/js/16.2449162b.js"><link rel="prefetch" href="/assets/js/160.0b806535.js"><link rel="prefetch" href="/assets/js/161.835052c6.js"><link rel="prefetch" href="/assets/js/162.ca34e2d2.js"><link rel="prefetch" href="/assets/js/163.08000d04.js"><link rel="prefetch" href="/assets/js/164.a1cc0109.js"><link rel="prefetch" href="/assets/js/165.65444686.js"><link rel="prefetch" href="/assets/js/166.7d73c84f.js"><link rel="prefetch" href="/assets/js/167.009d47a3.js"><link rel="prefetch" href="/assets/js/168.0afeae2a.js"><link rel="prefetch" href="/assets/js/169.7654cb31.js"><link rel="prefetch" href="/assets/js/17.eb7f9def.js"><link rel="prefetch" href="/assets/js/170.58569530.js"><link rel="prefetch" href="/assets/js/171.7db9ed40.js"><link rel="prefetch" href="/assets/js/172.3cb50ed4.js"><link rel="prefetch" href="/assets/js/173.0846425f.js"><link rel="prefetch" href="/assets/js/174.9e95f111.js"><link rel="prefetch" href="/assets/js/175.ef2098f2.js"><link rel="prefetch" href="/assets/js/176.c2635fe9.js"><link rel="prefetch" href="/assets/js/177.4fa38e8e.js"><link rel="prefetch" href="/assets/js/178.2be7037f.js"><link rel="prefetch" href="/assets/js/179.bf3bba28.js"><link rel="prefetch" href="/assets/js/18.0455f4d1.js"><link rel="prefetch" href="/assets/js/180.72c5f597.js"><link rel="prefetch" href="/assets/js/181.42287bcc.js"><link rel="prefetch" href="/assets/js/182.6cd4bf1a.js"><link rel="prefetch" href="/assets/js/183.05dbbfd9.js"><link rel="prefetch" href="/assets/js/184.03de7e00.js"><link rel="prefetch" href="/assets/js/185.42dd210e.js"><link rel="prefetch" href="/assets/js/186.28ee0f8a.js"><link rel="prefetch" href="/assets/js/187.bb58697b.js"><link rel="prefetch" href="/assets/js/188.1bc8be96.js"><link rel="prefetch" href="/assets/js/189.fac747e3.js"><link rel="prefetch" href="/assets/js/19.ae9e35d6.js"><link rel="prefetch" href="/assets/js/190.ea533ac7.js"><link rel="prefetch" href="/assets/js/191.6dc6eb13.js"><link rel="prefetch" href="/assets/js/192.184d249f.js"><link rel="prefetch" href="/assets/js/193.4a06bc12.js"><link rel="prefetch" href="/assets/js/194.8cce60a9.js"><link rel="prefetch" href="/assets/js/195.93231a13.js"><link rel="prefetch" href="/assets/js/196.4a596bde.js"><link rel="prefetch" href="/assets/js/197.96c113cf.js"><link rel="prefetch" href="/assets/js/198.73ba3f67.js"><link rel="prefetch" href="/assets/js/199.74bab595.js"><link rel="prefetch" href="/assets/js/20.b542d0e7.js"><link rel="prefetch" href="/assets/js/200.69a6928a.js"><link rel="prefetch" href="/assets/js/201.9ffa7c5a.js"><link rel="prefetch" href="/assets/js/202.41edb652.js"><link rel="prefetch" href="/assets/js/203.7fabcef3.js"><link rel="prefetch" href="/assets/js/204.b0ae2f62.js"><link rel="prefetch" href="/assets/js/205.add8738b.js"><link rel="prefetch" href="/assets/js/206.f3a712ec.js"><link rel="prefetch" href="/assets/js/207.cd7dd729.js"><link rel="prefetch" href="/assets/js/208.78b33afa.js"><link rel="prefetch" href="/assets/js/209.9d3329ff.js"><link rel="prefetch" href="/assets/js/21.5a050318.js"><link rel="prefetch" href="/assets/js/210.d285d5ac.js"><link rel="prefetch" href="/assets/js/211.8791bb3f.js"><link rel="prefetch" href="/assets/js/212.84ed81a8.js"><link rel="prefetch" href="/assets/js/213.7b990580.js"><link rel="prefetch" href="/assets/js/214.da31f20c.js"><link rel="prefetch" href="/assets/js/215.9eeed659.js"><link rel="prefetch" href="/assets/js/216.9539f0ec.js"><link rel="prefetch" href="/assets/js/217.11b575be.js"><link rel="prefetch" href="/assets/js/218.a67f12f1.js"><link rel="prefetch" href="/assets/js/219.bfbb817a.js"><link rel="prefetch" href="/assets/js/22.2bc6f7e3.js"><link rel="prefetch" href="/assets/js/220.8b01342f.js"><link rel="prefetch" href="/assets/js/221.b450decd.js"><link rel="prefetch" href="/assets/js/222.97468507.js"><link rel="prefetch" href="/assets/js/223.b6dafd73.js"><link rel="prefetch" href="/assets/js/224.c86c18c6.js"><link rel="prefetch" href="/assets/js/225.b0dcf86e.js"><link rel="prefetch" href="/assets/js/226.02cc2999.js"><link rel="prefetch" href="/assets/js/227.8474ef5a.js"><link rel="prefetch" href="/assets/js/228.0298e421.js"><link rel="prefetch" href="/assets/js/229.6aeaf595.js"><link rel="prefetch" href="/assets/js/23.9995fce4.js"><link rel="prefetch" href="/assets/js/230.a5785286.js"><link rel="prefetch" href="/assets/js/231.d791daa4.js"><link rel="prefetch" href="/assets/js/232.97aeeb00.js"><link rel="prefetch" href="/assets/js/233.46e51e28.js"><link rel="prefetch" href="/assets/js/234.2cffe82f.js"><link rel="prefetch" href="/assets/js/235.14965da6.js"><link rel="prefetch" href="/assets/js/236.00a5afc0.js"><link rel="prefetch" href="/assets/js/237.3b73d52f.js"><link rel="prefetch" href="/assets/js/238.6e1db765.js"><link rel="prefetch" href="/assets/js/239.75866c5e.js"><link rel="prefetch" href="/assets/js/24.9141eeb2.js"><link rel="prefetch" href="/assets/js/240.af9c2cc9.js"><link rel="prefetch" href="/assets/js/241.388acab2.js"><link rel="prefetch" href="/assets/js/242.c60f2b48.js"><link rel="prefetch" href="/assets/js/243.d8e81b13.js"><link rel="prefetch" href="/assets/js/244.58b0b21d.js"><link rel="prefetch" href="/assets/js/245.c3768497.js"><link rel="prefetch" href="/assets/js/246.ac8bbe7a.js"><link rel="prefetch" href="/assets/js/247.d095f70a.js"><link rel="prefetch" href="/assets/js/248.e9f210b5.js"><link rel="prefetch" href="/assets/js/249.a9fad023.js"><link rel="prefetch" href="/assets/js/25.98e8593e.js"><link rel="prefetch" href="/assets/js/250.ae7f0ebb.js"><link rel="prefetch" href="/assets/js/251.9a617d55.js"><link rel="prefetch" href="/assets/js/252.ce082446.js"><link rel="prefetch" href="/assets/js/253.4575302d.js"><link rel="prefetch" href="/assets/js/254.5899a61b.js"><link rel="prefetch" href="/assets/js/255.66c69f31.js"><link rel="prefetch" href="/assets/js/256.8fd6c706.js"><link rel="prefetch" href="/assets/js/257.31b77e5e.js"><link rel="prefetch" href="/assets/js/258.eba48891.js"><link rel="prefetch" href="/assets/js/259.edf74b59.js"><link rel="prefetch" href="/assets/js/26.e69924ea.js"><link rel="prefetch" href="/assets/js/260.cf2ed36d.js"><link rel="prefetch" href="/assets/js/261.9e7792d8.js"><link rel="prefetch" href="/assets/js/262.e7b9433e.js"><link rel="prefetch" href="/assets/js/263.1185b25c.js"><link rel="prefetch" href="/assets/js/264.5e0f89cb.js"><link rel="prefetch" href="/assets/js/265.a38d3b94.js"><link rel="prefetch" href="/assets/js/266.2ef170b3.js"><link rel="prefetch" href="/assets/js/267.a7d14651.js"><link rel="prefetch" href="/assets/js/268.05b18748.js"><link rel="prefetch" href="/assets/js/269.dad48d6f.js"><link rel="prefetch" href="/assets/js/27.13612515.js"><link rel="prefetch" href="/assets/js/270.4f5a6b8d.js"><link rel="prefetch" href="/assets/js/271.7ebf6682.js"><link rel="prefetch" href="/assets/js/272.7c2fbfd1.js"><link rel="prefetch" href="/assets/js/273.8ee20732.js"><link rel="prefetch" href="/assets/js/274.d525242a.js"><link rel="prefetch" href="/assets/js/275.a8a19acb.js"><link rel="prefetch" href="/assets/js/276.df3a4eb4.js"><link rel="prefetch" href="/assets/js/277.336debda.js"><link rel="prefetch" href="/assets/js/278.c470625f.js"><link rel="prefetch" href="/assets/js/279.a91e1a64.js"><link rel="prefetch" href="/assets/js/28.ab7ae1df.js"><link rel="prefetch" href="/assets/js/280.87e25c9a.js"><link rel="prefetch" href="/assets/js/281.87c1ba25.js"><link rel="prefetch" href="/assets/js/282.dcd4dce0.js"><link rel="prefetch" href="/assets/js/283.abac2e00.js"><link rel="prefetch" href="/assets/js/284.f6079659.js"><link rel="prefetch" href="/assets/js/285.f1b39879.js"><link rel="prefetch" href="/assets/js/286.f6a79242.js"><link rel="prefetch" href="/assets/js/287.06bebe07.js"><link rel="prefetch" href="/assets/js/288.89e325df.js"><link rel="prefetch" href="/assets/js/289.3aa1bedd.js"><link rel="prefetch" href="/assets/js/29.ebe50f76.js"><link rel="prefetch" href="/assets/js/290.ee059c92.js"><link rel="prefetch" href="/assets/js/291.fa9a921a.js"><link rel="prefetch" href="/assets/js/292.2a8811cd.js"><link rel="prefetch" href="/assets/js/293.eec09cdf.js"><link rel="prefetch" href="/assets/js/294.dfac20dc.js"><link rel="prefetch" href="/assets/js/295.825d2070.js"><link rel="prefetch" href="/assets/js/296.f645861e.js"><link rel="prefetch" href="/assets/js/297.424fdb17.js"><link rel="prefetch" href="/assets/js/298.ebf87cdc.js"><link rel="prefetch" href="/assets/js/299.b8f19cbb.js"><link rel="prefetch" href="/assets/js/30.75237511.js"><link rel="prefetch" href="/assets/js/300.10fb6d4f.js"><link rel="prefetch" href="/assets/js/301.ef77c612.js"><link rel="prefetch" href="/assets/js/302.1b839763.js"><link rel="prefetch" href="/assets/js/303.609f7d98.js"><link rel="prefetch" href="/assets/js/304.1d255f19.js"><link rel="prefetch" href="/assets/js/305.b0234f2c.js"><link rel="prefetch" href="/assets/js/306.48677f64.js"><link rel="prefetch" href="/assets/js/307.14390d4b.js"><link rel="prefetch" href="/assets/js/308.fa730b28.js"><link rel="prefetch" href="/assets/js/309.0496b9e0.js"><link rel="prefetch" href="/assets/js/31.cf3f471a.js"><link rel="prefetch" href="/assets/js/310.a31676dc.js"><link rel="prefetch" href="/assets/js/311.ed53adc5.js"><link rel="prefetch" href="/assets/js/312.1b0ff2f1.js"><link rel="prefetch" href="/assets/js/313.bf123f32.js"><link rel="prefetch" href="/assets/js/314.4e6ce06b.js"><link rel="prefetch" href="/assets/js/315.8eb18560.js"><link rel="prefetch" href="/assets/js/32.74fef842.js"><link rel="prefetch" href="/assets/js/33.bc2d190b.js"><link rel="prefetch" href="/assets/js/34.d23438fc.js"><link rel="prefetch" href="/assets/js/35.7675c4d0.js"><link rel="prefetch" href="/assets/js/36.96a4161b.js"><link rel="prefetch" href="/assets/js/37.d1824f2f.js"><link rel="prefetch" href="/assets/js/38.4effff9e.js"><link rel="prefetch" href="/assets/js/39.6509914b.js"><link rel="prefetch" href="/assets/js/4.4d01750f.js"><link rel="prefetch" href="/assets/js/40.1509d08b.js"><link rel="prefetch" href="/assets/js/41.f2c1124f.js"><link rel="prefetch" href="/assets/js/42.e541d077.js"><link rel="prefetch" href="/assets/js/43.369de999.js"><link rel="prefetch" href="/assets/js/44.43959db0.js"><link rel="prefetch" href="/assets/js/45.282fbd31.js"><link rel="prefetch" href="/assets/js/46.1b83cfe9.js"><link rel="prefetch" href="/assets/js/47.c3a88e41.js"><link rel="prefetch" href="/assets/js/48.bc7c0a1b.js"><link rel="prefetch" href="/assets/js/49.92a4e5ba.js"><link rel="prefetch" href="/assets/js/5.c3991e24.js"><link rel="prefetch" href="/assets/js/50.9c488c6c.js"><link rel="prefetch" href="/assets/js/51.546ea632.js"><link rel="prefetch" href="/assets/js/52.0d2ccee1.js"><link rel="prefetch" href="/assets/js/53.6f52b5b1.js"><link rel="prefetch" href="/assets/js/54.c838b295.js"><link rel="prefetch" href="/assets/js/55.13af99ee.js"><link rel="prefetch" href="/assets/js/56.6be6d1ed.js"><link rel="prefetch" href="/assets/js/57.67c98b39.js"><link rel="prefetch" href="/assets/js/58.107e82ec.js"><link rel="prefetch" href="/assets/js/59.b3e5edc7.js"><link rel="prefetch" href="/assets/js/6.36a535f9.js"><link rel="prefetch" href="/assets/js/60.3b0b4ba5.js"><link rel="prefetch" href="/assets/js/61.3df843df.js"><link rel="prefetch" href="/assets/js/62.1213823d.js"><link rel="prefetch" href="/assets/js/63.e8f3f926.js"><link rel="prefetch" href="/assets/js/64.e1219050.js"><link rel="prefetch" href="/assets/js/65.5bf5bb0b.js"><link rel="prefetch" href="/assets/js/66.a2502afb.js"><link rel="prefetch" href="/assets/js/67.690dd59b.js"><link rel="prefetch" href="/assets/js/68.de7b0915.js"><link rel="prefetch" href="/assets/js/69.ac61dd61.js"><link rel="prefetch" href="/assets/js/7.5d254238.js"><link rel="prefetch" href="/assets/js/70.3edd41b1.js"><link rel="prefetch" href="/assets/js/71.d23407e9.js"><link rel="prefetch" href="/assets/js/72.a5bd01bc.js"><link rel="prefetch" href="/assets/js/73.c9f4dd57.js"><link rel="prefetch" href="/assets/js/74.66323fc1.js"><link rel="prefetch" href="/assets/js/75.e1a72e00.js"><link rel="prefetch" href="/assets/js/76.801268b4.js"><link rel="prefetch" href="/assets/js/77.3a5fda67.js"><link rel="prefetch" href="/assets/js/78.54d84cd4.js"><link rel="prefetch" href="/assets/js/79.fa10f4e3.js"><link rel="prefetch" href="/assets/js/8.e060e47d.js"><link rel="prefetch" href="/assets/js/80.d5b24fea.js"><link rel="prefetch" href="/assets/js/81.0e9da714.js"><link rel="prefetch" href="/assets/js/82.e96ff6d7.js"><link rel="prefetch" href="/assets/js/83.771cced1.js"><link rel="prefetch" href="/assets/js/84.220b69e7.js"><link rel="prefetch" href="/assets/js/85.7dcc5659.js"><link rel="prefetch" href="/assets/js/86.44ba2100.js"><link rel="prefetch" href="/assets/js/87.281da75d.js"><link rel="prefetch" href="/assets/js/88.12d88449.js"><link rel="prefetch" href="/assets/js/89.f28c86d3.js"><link rel="prefetch" href="/assets/js/9.8f9fef32.js"><link rel="prefetch" href="/assets/js/90.715cabb2.js"><link rel="prefetch" href="/assets/js/91.6ced7c82.js"><link rel="prefetch" href="/assets/js/92.c05b33ca.js"><link rel="prefetch" href="/assets/js/94.3561200e.js"><link rel="prefetch" href="/assets/js/95.0f2cf716.js"><link rel="prefetch" href="/assets/js/96.ac8487ea.js"><link rel="prefetch" href="/assets/js/97.48042b5a.js"><link rel="prefetch" href="/assets/js/98.441bb7f8.js"><link rel="prefetch" href="/assets/js/99.4b214d92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56073ad3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/magic.png" alt="Pangolin Note" class="logo"> <span class="site-name can-hide">Pangolin Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatarnew.png"> <div class="blogger-info"><h3>达尔文的猹</h3> <span>大道至简 悟在天成</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/develop/" class="nav-link">开发</a></div><div class="nav-item"><a href="/middleware/" class="nav-link">系统</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/books/" class="nav-link">🍀读书笔记</a></div><div class="nav-item"><a href="/work/" class="nav-link">工作</a></div><div class="nav-item"><a href="/pangolin/" class="nav-link">🌸达尔文的猹</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Java</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/4f30b9/" class="sidebar-link">Java基础</a></li><li><a href="/pages/795eca/" class="sidebar-link">类与继承</a></li><li><a href="/pages/c69152/" class="sidebar-link">抽象类与接口</a></li><li><a href="/pages/d71abb/" class="sidebar-link">内部类</a></li><li><a href="/pages/f06dca/" class="sidebar-link">枚举类</a></li><li><a href="/pages/259f57/" class="sidebar-link">常用类</a></li><li><a href="/pages/84b03b/" class="sidebar-link">关键字</a></li><li><a href="/pages/31b87b/" class="sidebar-link">注解</a></li><li><a href="/pages/f81c0d/" class="sidebar-link">异常</a></li><li><a href="/pages/ae7746/" class="sidebar-link">泛型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>容器类</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/0c88ac/" class="sidebar-link">集合容器类基础</a></li><li><a href="/pages/f805ed/" class="sidebar-link">List与Queue类</a></li><li><a href="/pages/d24b60/" class="sidebar-link">Map与Set类</a></li><li><a href="/pages/54e5d3/" class="sidebar-link">并发容器类</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/67d70f/" class="sidebar-link">多线程基础</a></li><li><a href="/pages/ffc8f7/" class="sidebar-link">Java内置锁</a></li><li><a href="/pages/c43494/" class="sidebar-link">AQS</a></li><li><a href="/pages/eb5b61/" class="sidebar-link">显式锁ReentrantLock</a></li><li><a href="/pages/eb8cbc/" class="sidebar-link">线程协作与JUC组件</a></li><li><a href="/pages/23c79a/" class="sidebar-link">Atomic原子变量与Unsafe类与CAS</a></li><li><a href="/pages/9d6ed4/" class="sidebar-link">线程池与定时任务</a></li><li><a href="/pages/5b787a/" class="sidebar-link">ThreadLocal</a></li><li><a href="/pages/db53d1/" class="sidebar-link">Java并发编程实战(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>IO</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b4d461/" class="sidebar-link">文件操作</a></li><li><a href="/pages/1b9d6c/" class="sidebar-link">IO流操作</a></li><li><a href="/pages/076a47/" class="sidebar-link">Java网络IO模型</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>高级特性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d76905/" class="sidebar-link">Lambda表达式</a></li><li><a href="/pages/f7f0e6/" class="sidebar-link">流Stream</a></li><li><a href="/pages/7cc40a/" class="sidebar-link">反射</a></li><li><a href="/pages/945326/" class="sidebar-link">代理</a></li><li><a href="/pages/7fd9b4/" class="sidebar-link">Javaagent</a></li><li><a href="/pages/a3cee0/" class="sidebar-link">Guava</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>JVM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d308f6/" class="sidebar-link">走进JVM🌼</a></li><li><a href="/pages/be0269/" class="sidebar-link">JVM内存区域与对象解析🌼</a></li><li><a href="/pages/48d1be/" class="sidebar-link">垃圾收集器与内存分配策略🌼</a></li><li><a href="/pages/3a4c8a/" class="sidebar-link">JVM性能监控与故障处理工具🌼</a></li><li><a href="/pages/106680/" class="sidebar-link">调优案例分析与实战🌼</a></li><li><a href="/pages/16a914/" class="sidebar-link">类文件结构🌼</a></li><li><a href="/pages/ea287c/" class="sidebar-link">虚拟机类加载机制🌼</a></li><li><a href="/pages/6367b0/" class="sidebar-link">虚拟机字节码执行引擎🌼</a></li><li><a href="/pages/c6c210/" class="sidebar-link">类加载及执行子系统的案例与实战🌼</a></li><li><a href="/pages/deb8b7/" class="sidebar-link">前端编译与优化🌼</a></li><li><a href="/pages/1f8f72/" class="sidebar-link">后端编译与优化🌼</a></li><li><a href="/pages/3d72db/" class="sidebar-link">Java内存模型与线程实现🌼</a></li><li><a href="/pages/ed086e/" class="sidebar-link">线程安全与内置锁优化🌼</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/56b9dd/" class="sidebar-link">Java性能问题定位分析</a></li><li><a href="/pages/939bf8/" class="sidebar-link">杂记</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>开发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>软件设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/a5f6fe/" class="sidebar-link">设计基础理论</a></li><li><a href="/pages/3b245c/" class="sidebar-link">设计模式之美(极客时间)🌟</a></li><li><a href="/pages/661fa4/" class="sidebar-link">领域驱动设计(DDD)</a></li><li><a href="/pages/856368/" aria-current="page" class="active sidebar-link">DDD实战课(极客时间)🌸</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d3fbd2/" class="sidebar-link">数据库基础</a></li><li><a href="/pages/691fc3/" class="sidebar-link">数据库系统原理</a></li><li><a href="/pages/50f6b7/" class="sidebar-link">MySQL基础必知必会</a></li><li><a href="/pages/fe297e/" class="sidebar-link">MySQL特性</a></li><li><a href="/pages/07bdb6/" class="sidebar-link">MySQL索引🌟</a></li><li><a href="/pages/984715/" class="sidebar-link">MySQL锁🌟</a></li><li><a href="/pages/53b588/" class="sidebar-link">MySQL事务🌟</a></li><li><a href="/pages/becc59/" class="sidebar-link">MySQL高级特性</a></li><li><a href="/pages/056463/" class="sidebar-link">MySQL基础架构与存储引擎🌟</a></li><li><a href="/pages/63b46e/" class="sidebar-link">MySQL架构优化与运维</a></li><li><a href="/pages/9995e5/" class="sidebar-link">MySQL优化</a></li><li><a href="/pages/c1c2f6/" class="sidebar-link">MySQL架构</a></li><li><a href="/pages/8e8e0a/" class="sidebar-link">MySQL设计规范</a></li><li><a href="/pages/0219aa/" class="sidebar-link">MySQL运维</a></li><li><a href="/pages/e288c0/" class="sidebar-link">MySQL中间件</a></li><li><a href="/pages/c6cafa/" class="sidebar-link">MySQL实战45讲(极客时间)🌟</a></li><li><a href="/pages/4a6106/" class="sidebar-link">数据库LeetCode题目</a></li><li><a href="/pages/2827f1/" class="sidebar-link">数据库综合问题</a></li><li><a href="/pages/c616d5/" class="sidebar-link">MongoDB</a></li><li><a href="/pages/075e71/" class="sidebar-link">ClickHouse</a></li><li><a href="/pages/d74f6d/" class="sidebar-link">Doris</a></li><li><a href="/pages/b6bad9/" class="sidebar-link">HBase</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Spring</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bd8eb8/" class="sidebar-link">Spring Boot基础</a></li><li><a href="/pages/d0d797/" class="sidebar-link">Spring Boot应用整合</a></li><li><a href="/pages/314cdc/" class="sidebar-link">Spring MVC基础</a></li><li><a href="/pages/80de47/" class="sidebar-link">Spring AOP基础</a></li><li><a href="/pages/f0d4d6/" class="sidebar-link">Spring事务基础</a></li><li><a href="/pages/db6afe/" class="sidebar-link">Spring IOC源码分析-概览</a></li><li><a href="/pages/672e98/" class="sidebar-link">Spring IOC源码分析-getBean()</a></li><li><a href="/pages/695b90/" class="sidebar-link">Spring IOC源码分析-createBean()</a></li><li><a href="/pages/f89bcf/" class="sidebar-link">Spring AOP源码分析</a></li><li><a href="/pages/3b52f4/" class="sidebar-link">Spring事务源码分析</a></li><li><a href="/pages/186902/" class="sidebar-link">Spring Boot源码分析</a></li><li><a href="/pages/16bd1c/" class="sidebar-link">Spring MVC源码分析</a></li><li><a href="/pages/3d0c1f/" class="sidebar-link">Spring Cloud</a></li><li><a href="/pages/d56156/" class="sidebar-link">Spring编程常见错误50例(极客时间)🌸</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>MyBatis</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bb032d/" class="sidebar-link">基础</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>工具与环境</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c9cb6e/" class="sidebar-link">Arthas</a></li><li><a href="/pages/3172bb/" class="sidebar-link">Maven</a></li><li><a href="/pages/37f79a/" class="sidebar-link">Git</a></li><li><a href="/pages/db9f99/" class="sidebar-link">环境搭建与部署</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c725f5/" class="sidebar-link">测试基础</a></li><li><a href="/pages/7893a4/" class="sidebar-link">单元测试</a></li><li><a href="/pages/af9f25/" class="sidebar-link">压力测试</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>代码质量</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ec2b81/" class="sidebar-link">代码整洁之道</a></li><li><a href="/pages/474cdf/" class="sidebar-link">阿里巴巴编程规范</a></li><li><a href="/pages/c47e15/" class="sidebar-link">代码之丑(极客时间)🌸</a></li><li><a href="/pages/4d4606/" class="sidebar-link">Java业务开发常见错误100例(极客时间)🌸</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/develop/#开发" data-v-06970110>开发</a></li><li data-v-06970110><a href="/develop/#开发" data-v-06970110>开发</a></li><li data-v-06970110><a href="/develop/#软件设计" data-v-06970110>软件设计</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/nanodaemony" target="_blank" title="作者" class="beLink" data-v-06970110>NanoDaemony</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">本文目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">DDD实战课(极客时间)🌸<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_31-ddd实战课-极客时间-🌸"><a href="#_31-ddd实战课-极客时间-🌸" class="header-anchor">#</a> 31.DDD实战课(极客时间)🌸</h1> <h3 id="开篇词"><a href="#开篇词" class="header-anchor">#</a> 开篇词</h3> <h4 id="开篇词-学好了ddd你能做什么"><a href="#开篇词-学好了ddd你能做什么" class="header-anchor">#</a> 开篇词-学好了DDD你能做什么?</h4> <h5 id="我与ddd"><a href="#我与ddd" class="header-anchor">#</a> 我与DDD</h5> <p>说起 DDD 的实践, 那就不得不提微服务了. 2015 年, 我刚开始接触微服务, 那时候和别人去介绍微服务的设计理念, 接受度并不高, 毕竟大家普遍采用的还是集中式架构.</p> <p>但即便是在四年前, 业务的日渐复杂也是可以预见的, 微服务的价值确确实实存在. 我就从那个时候开始深入研究, 作为公司的高级架构师, 我也一直处于公司<strong>中台转型和微服务建设</strong>的一线.</p> <p>这个过程中, 最尖锐的一个问题是: &quot;<strong>微服务到底怎么拆分和设计才算合理, 拆多小才叫微服务?</strong> &quot; 而<mark><strong>微服务的边界</strong></mark>历来也是最容易产生争议的地方.</p> <p>紧接着, 阿里巴巴成功完成了中台战略转型. 于是, 很多大型公司也开启了中台数字化战略转型, 中型公司也根据自身需求跃跃欲试. 但也有很多公司由于历史原因, 存在着大量系统重复建设的问题.</p> <p>作为中台, 需要<strong>将通用的可复用的业务能力沉淀到中台业务模型, 实现企业级能力复用</strong>. 因此中台面临的首要问题就是中台领域模型的重构. 而中台落地时, 依然会面临微服务设计和拆分的问题. 这两个问题一前一后, 放在任何一家公司, 都是一个不小的挑战. 这也是我一直在探索和解决的问题. 这两年, 中台越来越火, 微服务越来越热, 参与的人越来越多. 那是否有好的方法来指导中台和微服务的设计呢?</p> <p>一次偶然的机会我接触到了 DDD, 深入研究后, 我发现, <strong>运用 DDD 设计思想实现的微服务边界确实清晰很多, 业务领域划分也十分合理</strong>. 后来, 我们用 DDD 做了很多的微服务实践.</p> <p>DDD 虽然历史很久了, 但它与微服务和中台设计的结合, 却是一片很新的领域. 早在 2003 年就诞生的 DDD, 怎么来指导 &quot;迟到&quot; 近 20 年才大热的微服务设计呢?</p> <p>我认为, 要想应用 DDD, <strong>首要任务就是要吃透 DDD 的核心设计思想, 搞清楚 DDD, 微服务和中台之间的关系. 中台本质是业务模型, 微服务是业务模型的系统落地, DDD 是一种设计思想, 它可以同时指导中台业务建模和微服务设计, 它们之间就是这样的一个铁三角关系. DDD 强调领域模型和微服务设计的一体性, 先有领域模型然后才有微服务, 而不是脱离领域模型来谈微服务设计</strong>.</p> <p>其次, 就是<strong>通过战略设计, 建立领域模型, 划分微服务边界</strong>. 这步是关键, 你可以借助专栏中的一些经验.</p> <p>最后, 通过战术设计, 我们会从领域模型转向微服务设计和落地. 此时, 边界清晰, 可持续演进的微服务架构雏形就在你面前了.</p> <p>遵循以上过程, 这门课的设计思路也就诞生了.</p> <h5 id="关于课程设计"><a href="#关于课程设计" class="header-anchor">#</a> 关于课程设计</h5> <p>如果你以往对 DDD 的了解并不深入, 甚至是第一次接触, 你一定会觉得 DDD 的术语非常多, 且非常陌生, 这些术语之间的关系都算是个 &quot;拦路虎&quot;.</p> <p>搞懂这些之后呢, 怎么应用它们, 从何下手来设计领域模型等等这些问题又接踵而至.</p> <p>如果你对 DDD 有过研究, 在学会怎么用之后, 你可能还会反过来想: &quot;我费了这么大劲儿去搞懂它, 那它到底会让我的系统变成什么样呢? 可以解决什么具体问题? 是不是真有大家说得那么好?&quot;</p> <p>这些都将是这个专栏要交付给你的内容. 总结一下的话, 我希望这个专栏能带给你这样几点收获:</p> <ol><li>用浅显易懂的案例带你了解 DDD 必知必会的 <strong>10 大核心概念, 深入设计思想</strong>, 厘清各知识域之间的关系;</li> <li>用 DDD 分层架构带你弄懂<strong>微服务架构各层之间的关系, 并完成微服务分层和代码模型设计</strong>;</li> <li>用 DDD 战略设计和事件风暴带你完成<strong>领域建模和企业级中台业务建模</strong>;</li> <li>用一个典型的案例完整走一遍 DDD 战略设计和战术设计的全流程, 学习 DDD 在领域模型和微服务设计过程中的技术要点;</li> <li>深化微服务架构设计原则和注意事项, 建立适应你公司技术能力和文化的微服务, 建立演进式的微服务架构.</li></ol> <p>希望这些收获能够给正在从事或者有兴趣深入了解微服务设计和中台的你, 提供一些实质性的帮助.</p> <p>在具体的课程设计上, 我将内容分为了三大部分: <strong>基础篇, 进阶篇和实战篇</strong>. 下面来逐一介绍一下.</p> <h6 id="基础篇"><a href="#基础篇" class="header-anchor">#</a> 基础篇</h6> <p>基础篇主要<strong>讲解 DDD 的核心知识体系</strong>, 具体包括: <strong>领域, 子域, 核心域, 通用域, 支撑域, 限界上下文, 实体, 值对象, 聚合和聚合根等概念</strong>. 我会用浅显易懂的案例带你理解它们以及它们之间的合作, 依赖关系.</p> <p><img src="/img/e8d92846570675c7c7b0ae083bf110b4-20230731163226-6kkq87r.png" alt=""></p> <h6 id="进阶篇"><a href="#进阶篇" class="header-anchor">#</a> 进阶篇</h6> <p>进阶篇主要讲解<strong>领域事件, DDD 分层架构</strong>, 几种常见的微服务架构模型以及中台设计思想等内容. 具体包括:</p> <ul><li>如何通过领域事件实现微服务解耦?</li> <li>怎样进行微服务分层设计?</li> <li>如何实现层与层之间的服务协作?</li> <li>通过几种微服务架构模型的对比分析, 让你了解领域模型和微服务分层的作用和价值.</li> <li>另外, 还会介绍中台设计的核心思想, 探讨如何实现前中后台的协同和融合. 如何利用 DDD 进行中台设计.</li></ul> <h6 id="实战篇"><a href="#实战篇" class="header-anchor">#</a> 实战篇</h6> <p>实战篇是课程的重点, 这里准备了多个实战小项目.</p> <ul><li><strong>中台和领域建模的实战</strong>: 带你了解如何用 DDD 设计思想构建企业级可复用的中台业务模型, 了解事件风暴以及用事件风暴构建领域模型的过程.</li> <li><strong>微服务设计实战</strong>: 带你了解如何用 DDD 设计微服务代码模型, 如何从领域模型完成微服务设计, 建立领域模型与微服务代码模型的映射关系, 如何完成微服务的架构演进等.</li></ul> <p>然后会用一个典型的案例将 DDD 所有的知识点串联在一起, 深入了解如何用 DDD 的设计思想来完成领域建模和微服务设计的全流程.</p> <p>DDD 看似复杂, 可学习起来并不困难, 多动手参与几次 DDD 事件风暴工作坊, 你就能很快理解 DDD 的核心设计思想和设计过程, 成功进阶了.</p> <h3 id="基础篇-2"><a href="#基础篇-2" class="header-anchor">#</a> 基础篇</h3> <h4 id="_01-领域驱动设计-微服务设计为什么要选择ddd"><a href="#_01-领域驱动设计-微服务设计为什么要选择ddd" class="header-anchor">#</a> 01-领域驱动设计:微服务设计为什么要选择DDD?</h4> <p>微服务设计过程中往往会面临<strong>边界如何划定</strong>的问题, 我经常看到项目团队为微服务到底应该拆多小而争得面红耳赤. 不同的人会根据自己对微服务的理解而拆分出不同的微服务, 于是大家各执一词, 谁也说服不了谁, 都觉得自己很有道理.</p> <p>那在实际落地过程中, 我也确实见过不少项目在面临这种微服务设计困惑时, 是靠拍脑袋硬完成的, 上线后运维的压力就可想而知了. 那是否有合适的理论或设计方法来指导微服务设计呢? 没错, 就是 DDD. <strong>那微服务设计为什么要选择领域驱动设计</strong>?</p> <h5 id="软件架构模式的演进"><a href="#软件架构模式的演进" class="header-anchor">#</a> 软件架构模式的演进</h5> <p>在进入今天的主题之前, 先来了解下背景. 这些年来随着设备和新技术的发展, 软件的架构模式发生了很大的变化. 软件架构模式大体来说经历了从<strong>单机, 集中式到分布式微服务架构</strong>三个阶段的演进. 随着分布式技术的快速兴起, 现在已经进入到了微服务架构时代.</p> <p>​<img src="/img/d9e17c3ebfae17f31d750860a615269f-20230731163226-gt6m6bp.png" alt="">​</p> <p>先来分析一下软件架构模式演进的三个阶段.</p> <ul><li><strong>第一阶段是单机架构:</strong>  采用<strong>面向过程</strong>的设计方法, 系统包括客户端 UI 层和数据库两层, 采用 C/S 架构模式, 整个系统围绕数据库驱动设计和开发, 并且总是从设计数据库和字段开始.</li> <li><strong>第二阶段是集中式架构:</strong>  采用<strong>面向对象</strong>的设计方法, 系统包括业务接入层, 业务逻辑层和数据库层, 采用经典的三层架构, 也有部分应用采用传统的 SOA 架构. 这种架构容易使系统变得臃肿, <strong>可扩展性和弹性伸缩性差</strong>.</li> <li><strong>第三阶段是分布式微服务架构:</strong>  随着微服务架构理念的提出, 集中式架构正向分布式微服务架构演进. 微服务架构可以很好地实现应用之间的解耦, <strong>解决单体应用扩展性和弹性伸缩能力不足的问题</strong>.</li></ul> <p>在单机和集中式架构时代, <strong>系统分析, 设计和开发往往是独立, 分阶段割裂进行</strong>的. 比如, 在系统建设过程中经常会看到这样的情形: A 负责提出需求, B 负责需求分析, C 负责系统设计, D 负责代码实现, 这样的流程很长, 经手的人也很多, 很容易导致信息丢失. 最后, 就很容易导致需求, 设计与代码实现的不一致, 往往到了软件上线后, 才发现很多功能并不是自己想要的, 或者做出来的功能跟自己提出的需求偏差太大.</p> <p>而且在单机和集中式架构这两种模式下, 软件无法快速响应需求和业务的迅速变化, 最终错失发展良机. 此时, 分布式微服务的出现就有点恰逢其时的意思了.</p> <h5 id="微服务设计和拆分的困境"><a href="#微服务设计和拆分的困境" class="header-anchor">#</a> 微服务设计和拆分的困境</h5> <p>那进入微服务架构时代以后, 微服务确实也解决了原来采用集中式架构的单体应用的很多问题, 比如<strong>扩展性, 弹性伸缩能力, 小规模团队的敏捷开发</strong>等等.</p> <p>但在看到这些好处的同时, 微服务实践过程中也产生了不少的争论和疑惑: <mark><strong>微服务的粒度应该多大? 微服务到底应该如何拆分和设计? 微服务的边界应该在哪里</strong></mark>?</p> <p>可以说, 很久以来都没有一套系统的理论和方法可以指导微服务的拆分, 包括微服务架构模式的提出者 Martin Fowler 在提出微服务架构的时候, 也没有告诉我们究竟应该如何拆分微服务.</p> <p>于是, 在这段较长的时间里, 就有不少人对微服务的理解产生了一些曲解. 有人认为: &quot;微服务很简单, 不过就是把原来一个单体包拆分为多个部署包, 或者将原来的单体应用架构替换为一套支持微服务架构的技术框架, 就算是微服务了.&quot; 还有人说: &quot;微服务嘛, 就是要微要小, 拆得越小效果越好.&quot;</p> <p>综合来看, 我认为<mark><strong>微服务拆分困境产生的根本原因就是不知道业务或者微服务的边界到底在什么地方</strong></mark>. 换句话说, 确定了业务边界和应用边界, 这个困境也就迎刃而解了.</p> <p>那如何确定, 是否有相关理论或知识体系支持呢? 在回答这些问题之前, 先来了解一下领域驱动设计与微服务的前世今生.</p> <p>2004 年埃里克·埃文斯(Eric Evans)发表了《领域驱动设计》(Domain-Driven Design –Tackling Complexity in the Heart of Software)这本书, 从此领域驱动设计(Domain Driven Design, 简称 DDD)诞生. <mark><strong>DDD 核心思想是通过领域驱动设计方法定义领域模型, 从而确定业务和应用边界, 保证业务模型与代码模型的一致性</strong></mark>.</p> <p>但 DDD 提出后在软件开发领域一直都是 &quot;雷声大, 雨点小&quot;! 直到 Martin Fowler 提出微服务架构, DDD 才真正迎来了自己的时代.</p> <p>有些熟悉 DDD 设计方法的软件工程师在进行微服务设计时, 发现可以利用 DDD 设计方法来建立领域模型, 划分领域边界, 再根据这些领域边界从业务视角来划分微服务边界. 而按照 DDD 方法设计出的微服务的业务和应用边界都非常合理, 可以很好地实现微服务内部和外部的 &quot;高内聚, 低耦合&quot;. 于是越来越多的人开始把 DDD 作为微服务设计的指导思想.</p> <h5 id="为什么ddd适合微服务"><a href="#为什么ddd适合微服务" class="header-anchor">#</a> 为什么DDD适合微服务?</h5> <p>那 DDD 到底是何方神圣, 拥有什么神器呢?</p> <p><mark><strong>DDD 是一种处理高度复杂领域的设计思想, 它试图分离技术实现的复杂性, 并围绕业务概念构建领域模型来控制业务的复杂性, 以解决软件难以理解, 难以演进的问题</strong></mark>. DDD 不是架构, 而是一种架构设计方法论, 它通过边界划分将复杂业务领域简单化, 帮我们设计出清晰的领域和应用边界, 可以很容易地实现架构演进.</p> <p>**DDD 包括战略设计和战术设计两部分. **</p> <p><strong>战略设计</strong>主要从<strong>业务视角</strong>出发, 建立<strong>业务领域模型, 划分领域边界</strong>, 建立通用语言的限界上下文, 限界上下文可以作为微服务设计的参考边界.</p> <p><strong>战术设计</strong>则从<strong>技术视角</strong>出发, 侧重于领域模型的技术实现, 完成软件开发和落地, 包括: <strong>聚合根, 实体, 值对象, 领域服务, 应用服务和资源库等代码逻辑的设计和实现</strong>.</p> <p>下面来看看 DDD 是如何进行战略设计的.</p> <p><strong>DDD 战略设计会建立领域模型, 领域模型可以用于指导微服务的设计和拆分</strong>. 事件风暴是建立领域模型的主要方法, 它是一个从发散到收敛的过程. 它通常采用用例分析, 场景分析和用户旅程分析, 尽可能全面不遗漏地<strong>分解业务领域</strong>, 并梳理领域对象之间的关系, 这是一个发散的过程. 事件风暴过程会产生很多的实体, 命令, 事件等领域对象, 我们<strong>将这些领域对象从不同的维度进行聚类, 形成如聚合, 限界上下文等边界, 建立领域模型, 这就是一个收敛的过程</strong>.</p> <p><img src="/img/fbbda357639870e532fc935f4ceee397-20230731163226-i1u5i8m.png" alt=""></p> <p><strong>可以用三步来划定领域模型和微服务的边界.</strong></p> <p>第一步: 在事件风暴中梳理业务过程中的<strong>用户操作, 事件以及外部依赖关系</strong>等, 根据这些要素梳理出领域实体等领域对象.</p> <p>第二步: 根据领域实体之间的业务关联性, <strong>将业务紧密相关的实体进行组合形成聚合, 同时确定聚合中的聚合根, 值对象和实体</strong>. 在这个图里, 聚合之间的边界是第一层边界, 它们在同一个微服务实例中运行, 这个边界是逻辑边界, 所以用虚线表示.</p> <p>第三步: 根据业务及语义边界等因素, 将一个或者多个聚合划定在一个限界上下文内, 形成<strong>领域模型</strong>. 在这个图里, 限界上下文之间的边界是第二层边界, 这一层边界可能就是未来微服务的边界, 不同限界上下文内的领域逻辑被隔离在不同的微服务实例中运行, 物理上相互隔离, 所以是物理边界, 边界之间用实线来表示.</p> <p>有了这两层边界, 微服务的设计就不是什么难事了.</p> <p>在战略设计中建立了领域模型, 划定了业务领域的边界, 建立了通用语言和限界上下文, 确定了领域模型中各个领域对象的关系. 到这儿, 业务端领域模型的设计工作基本就完成了, 这个过程同时也基本确定了应用端的微服务边界.</p> <p>在从业务模型向微服务落地的过程中, 也就是从战略设计向战术设计的实施过程中, 会将领域模型中的领域对象与代码模型中的代码对象建立映射关系, 将业务架构和系统架构进行绑定. 当去响应业务变化调整业务架构和领域模型时, 系统架构也会同时发生调整, 并同步建立新的映射关系.</p> <h5 id="ddd与微服务的关系"><a href="#ddd与微服务的关系" class="header-anchor">#</a> DDD与微服务的关系</h5> <p>有了上面的讲解, 现在不妨再次总结下 DDD 与微服务的关系.</p> <p><strong>DDD 是一种架构设计方法, 微服务是一种架构风格, 两者从本质上都是为了追求高响应力, 而从业务视角去分离应用系统建设复杂度的手段</strong>. 两者都强调从业务出发, 其核心要义是强调根据业务发展, 合理划分领域边界, 持续调整现有架构, 优化现有代码, 以保持架构和代码的生命力, 也就是常说的演进式架构.</p> <p><strong>DDD 主要关注: 从业务领域视角划分领域边界, 构建通用语言进行高效沟通, 通过业务抽象, 建立领域模型, 维持业务和代码的逻辑一致性</strong>.</p> <p><strong>微服务主要关注: 运行时的进程间通信, 容错和故障隔离, 实现去中心化数据管理和去中心化服务治理, 关注微服务的独立开发, 测试, 构建和部署</strong>.</p> <h5 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h5> <p>今天主要讨论了微服务设计和拆分的难题. 通过 DDD 战略设计可以建立领域模型, 划定领域边界, 解决微服务设计过程中, 边界难以划定的难题. 如果你的业务焦点在<strong>领域和领域逻辑</strong>, 那么就可以选择 DDD 作为微服务的设计方法!</p> <p>更关键的一点是, DDD 不仅可以用于微服务设计, 还可以很好地应用于<strong>企业中台的设计</strong>. 如果你的企业正在做中台转型, DDD 将会是一把利器, 它可以帮你建立一个非常好的企业级中台业务模型. 有关这点你还会在后面的文章中见到详解.</p> <p>除此之外, DDD 战术设计对设计和开发人员的要求相对较高, 实现起来相对复杂. 不同企业的研发管理能力和个人开发水平可能会存在差异. 尤其对于传统企业而言, 在战术设计落地的过程中, 可能会存在一定挑战和困难, 如果有这方面的想法, 就一定要谨慎评估自己的能力, 选择最合适的方法落地 DDD.</p> <p>也不妨根据收获权衡一下, <strong>总体来说, DDD 可以带来以下收获:</strong></p> <ol><li>DDD 是一套完整而系统的设计方法, 它能带给你从战略设计到战术设计的标准设计过程, 使得你的设计思路能够更加清晰, 设计过程更加规范.</li> <li>DDD 善于处理与领域相关的拥有高复杂度业务的产品开发, 通过它可以建立一个核心而稳定的领域模型, 有利于领域知识的传递与传承.</li> <li>DDD 强调<strong>团队与领域专家的合作</strong>, 能够帮助你的团队建立一个沟通良好的氛围, 构建一致的架构体系.</li> <li>DDD 的设计思想, 原则与模式有助于提高架构设计能力.</li> <li>无论是在新项目中设计微服务, 还是将系统从单体架构演进到微服务, 都可以遵循 DDD 的架构原则.</li> <li>DDD 不仅适用于微服务, 也适用于传统的单体应用.</li></ol> <h4 id="_02-领域-子域-核心域-通用域和支撑域-傻傻分不清"><a href="#_02-领域-子域-核心域-通用域和支撑域-傻傻分不清" class="header-anchor">#</a> 02-领域,子域,核心域,通用域和支撑域:傻傻分不清?</h4> <p>DDD 的知识体系提出了很多的名词, 像: 领域, 子域, 核心域, 通用域, 支撑域, 限界上下文, 聚合, 聚合根, 实体, 值对象等等, 非常多. 这些名词, 都是关键概念, 但它们实在有些晦涩难懂, 可能导致你还没开始实践 DDD 就打起了退堂鼓. 因此, 在基础篇中, 我希望能带着你一起做好实践前的准备工作.</p> <p>除此之外, 我想说的是, 这些名词在微服务设计和开发过程中不一定都用得上, 但它可以帮理解 DDD 的核心设计思想和理念. 而这些思想和理念, 在 IT 战略设计, 业务建模和微服务设计中都是可以借鉴的.</p> <p>从这讲开始就会围绕以上这些 DDD 关键概念进行讲解, 帮助你彻底理清它们与微服务的关系, 了解它们在微服务设计中的作用. 今天重点了解 DDD 的领域, 子域, 核心域, 通用域和支撑域等重要概念.</p> <h5 id="如何理解领域和子域"><a href="#如何理解领域和子域" class="header-anchor">#</a> 如何理解领域和子域?</h5> <p>先看一下汉语词典中对领域的解释: &quot;领域是从事一种专门活动或事业的<strong>范围</strong>, 部类或部门.&quot; 百度百科对领域的解释: &quot;领域具体指一种特定的<strong>范围</strong>或区域.&quot;</p> <p>两个解释有一个共同点---<mark><strong>范围</strong></mark>. 对了! <mark><strong>领域就是用来确定范围的, 范围即边界, 这也是 DDD 在设计中不断强调边界的原因</strong></mark>.</p> <p>在研究和解决业务问题时, DDD 会按照一定的规则将业务领域进行细分, 当领域细分到一定的程度后, DDD 会将问题范围限定在特定的边界内, 在这个边界内建立领域模型, 进而用代码实现该领域模型, 解决相应的业务问题. 简言之, <strong>DDD 的领域就是这个边界内要解决的业务问题域</strong>.</p> <p>既然领域是用来限定业务边界和范围的, 那么就会有大小之分, <strong>领域越大, 业务范围就越大</strong>, 反之则相反.</p> <p>领域可以进一步划分为<strong>子领域</strong>. 划分出来的多个子领域称为<strong>子域</strong>, 每个<strong>子域对应一个更小的问题域或更小的业务范围</strong>.</p> <p>DDD 是一种处理高度复杂领域的设计思想, 它试图<strong>分离技术实现的复杂度</strong>. 那么面对错综复杂的业务领域, DDD 是如何使业务从复杂变得简单, 更容易让人理解, 技术实现更容易呢?</p> <p>其实很好理解, DDD 的研究方法与自然科学的研究方法类似. 当人们在自然科学研究中遇到复杂问题时, 通常的做法就是<strong>将问题一步一步地细分, 再针对细分出来的问题域, 逐个深入研究, 探索和建立所有子域的知识体系</strong>. 当所有问题子域完成研究时, 就建立了全部领域的完整知识体系了.</p> <p><img src="/img/684c8b6e50f8119f6a6d0084a9af857d-20230731163226-k1qyh52.png" alt=""></p> <p>来看一下上面这张图. 这个例子是在讲如何给桃树建立一个完整的生物学知识体系. 初中生物课其实早就告诉我们研究方法了. <strong>它的研究过程是这样的.</strong></p> <ul><li>第一步: 确定研究对象, 即<strong>研究领域</strong>, 这里是一棵桃树.</li> <li>第二步: <strong>对研究对象进行细分</strong>, 将桃树细分为器官, 器官又分为营养器官和生殖器官两种. 其中营养器官包括根, 茎和叶, 生殖器官包括花, 果实和种子. 桃树的知识体系是已经确定要研究的问题域, 对应 DDD 的领域. 根, 茎, 叶, 花, 果实和种子等器官则是细分后的问题子域. 这个过程就是 <strong>DDD 将领域细分为多个子域的过程</strong>.</li> <li>第三步: 对器官进行细分, 将器官细分为组织. 比如, 叶子器官可细分为保护组织, 营养组织和输导组织等. 这个过程就是 <strong>DDD 将子域进一步细分为多个子域的过程</strong>.</li> <li>第四步: 对组织进行细分, 将组织细分为细胞, 细胞成为研究的最小单元. 细胞之间的细胞壁确定了单元的边界, 也确定了<strong>研究的最小边界</strong>.</li></ul> <p>这里先剧透一点聚合, 聚合根, 实体以及值对象的内容, 后面还会详细讲解.</p> <p>我们知道细胞核, 线粒体, 细胞膜等物质共同构成细胞, 这些物质一起协作让细胞具有这类细胞特定的生物功能. 在这里可以<strong>把细胞理解为 DDD 的聚合, 细胞内的这些物质就可以理解为聚合里面的聚合根, 实体以及值对象等, 在聚合内这些实体一起协作完成特定的业务功能</strong>. 这个过程类似 DDD 设计时, 确定微服务内功能要素和边界的过程.</p> <p>这里总结一下, 就是说每一个细分的领域都会有一个知识体系, 也就是 DDD 的领域模型. 在所有子域的研究完成后, 就建立了全域的知识体系了, 也就建立了全域的领域模型.</p> <p>上面用自然科学研究的方法, 说明了<strong>领域可以通过细分为子域的方法, 来降低研究的复杂度</strong>. 现在把这个话题再切换到业务领域, 对比验证下, 二者的细分过程是否是一致的. 这里以保险行业为例.</p> <p>保险是个比较大的领域, 很早以前的保险核心系统把所有的功能都放在一个系统里来实现, 这个系统就是常说的单体系统. 后来单体系统开始无法适应保险业务的发展, 因此保险公司开始了<strong>中台转型</strong>, 引入分布式微服务架构来替换原来的单体系统. 而分布式微服务架构就需要划分业务领域边界, 建立领域模型, 并实现微服务落地了.</p> <p>为实现保险领域建模和微服务建设, 可以根据业务关联度以及流程边界将保险领域细分为: 承保, 收付, 再保以及理赔等子域, 而承保子域还可以继续细分为投保, 保全(寿险), 批改(财险)等子子域.</p> <p>在投保这个限界上下文内可以建立投保的领域模型, 投保的领域模型最后映射到系统就是投保微服务. 这就是一个保险领域的细分和微服务的建设过程.</p> <p>那么你可能会说, 我不是保险行业的人, 我怎么理解这个过程呢? 其实不同行业的业务模型可能会不一样, 但领域建模和微服务建设的过程和方法基本类似, 其<mark><strong>核心思想就是将问题域逐步分解, 降低业务理解和系统实现的复杂度</strong></mark>.</p> <h5 id="如何理解核心域-通用域和支撑域"><a href="#如何理解核心域-通用域和支撑域" class="header-anchor">#</a> 如何理解核心域,通用域和支撑域?</h5> <p>在领域不断划分的过程中, 领域会细分为不同的子域, <strong>子域可以根据自身重要性和功能属性划分为三类子域</strong>, 它们分别是: <mark><strong>核心域, 通用域和支撑域</strong></mark>.</p> <p>决定产品和公司<strong>核心竞争力的子域是核心域</strong>, 它是业务成功的主要因素和公司的核心竞争力. <mark><strong>没有太多个性化的诉求, 同时被多个子域使用的通用功能子域是通用域. 还有一种功能子域是必需的, 但既不包含决定产品和公司核心竞争力的功能, 也不包含通用功能的子域, 它就是支撑域</strong></mark>.</p> <p>这三类子域相较之下, 核心域是最重要的, 下面讲目的的时候还会以核心域为例详细介绍. 通用域和支撑域如果对应到企业系统, 举例来说的话, <strong>通用域则是需要用到的通用系统, 比如认证, 权限等等</strong>, 这类应用很容易买到, 没有企业特点限制, 不需要做太多的定制化. 而<strong>支撑域则具有企业特性, 但不具有通用性, 例如数据代码类的数据字典等系统</strong>.</p> <p><strong>那为什么要划分核心域, 通用域和支撑域, 主要目的是什么呢</strong>?</p> <p>还是拿上图的桃树来说吧. 将桃树细分为了根, 茎, 叶, 花, 果实和种子等六个子域, 那桃树是否有核心域? 有的话, 到底哪个是核心域呢?</p> <p>不同的人对桃树的理解是不同的. 如果这棵桃树生长在公园里, 在园丁的眼里, 他喜欢的是 &quot;人面桃花相映红&quot; 的阳春三月, 这时花就是桃树的核心域. 但如果这棵桃树生长在果园里, 对果农来说, 他则是希望在丰收的季节收获硕果累累的桃子, 这时果实就是桃树的核心域.</p> <p><strong>在不同的场景下, 不同的人对桃树核心域的理解是不同的</strong>, 因此对桃树的处理方式也会不一样. 园丁更关注桃树花期的营养, 而果农则更关注桃树落果期的营养, 有时为了保证果实的营养供给, 还会裁剪掉疯长的茎和叶(通用域或支撑域).</p> <p>同样的道理, <strong>公司在 IT 系统建设过程中, 由于预算和资源有限, 对不同类型的子域应有不同的关注度和资源投入策略</strong>, 记住好钢要用在刀刃上.</p> <p>很多公司的业务, 表面看上去相似, 但商业模式和战略方向是存在很大差异的, <strong>因此公司的关注点会不一样, 在划分核心域, 通用域和支撑域时, 其结果也会出现非常大的差异</strong>.</p> <p>比如同样都是电商平台的淘宝, 天猫, 京东和苏宁易购, 他们的商业模式是不同的. 淘宝是 C2C 网站, 个人卖家对个人买家, 而天猫, 京东和苏宁易购则是 B2C 网站, 是公司卖家对个人买家. 即便是苏宁易购与京东都是 B2C 的模式, 他们的商业模式也是不一样的, 苏宁易购是典型的传统线下卖场转型成为电商, 京东则是直营加部分平台模式.</p> <p><strong>商业模式的不同会导致核心域划分结果的不同</strong>. 有的公司核心域可能在客户服务, 有的可能在产品质量, 有的可能在物流. 在公司领域细分, 建立领域模型和系统建设时, 就要<strong>结合公司战略重点和商业模式, 找到核心域了, 且重点关注核心域</strong>.</p> <p>如果你的公司刚好有意向转型微服务架构的话, 建议技术团队要<strong>将核心域的建设排在首位, 最好是有绝对的掌控能力和自主研发能力</strong>, 如果资源实在有限的话, 可以在支撑域或者通用域上想想办法, 暂时采用外购的方式也未尝不可.</p> <h5 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h5> <p>领域的核心思想就是将问题域逐级细分, 来降低业务理解和系统实现的复杂度. 通过领域细分, 逐步缩小微服务需要解决的问题域, 构建合适的领域模型, 而领域模型映射成系统就是微服务了.</p> <p>核心域, 支撑域和通用域的主要目标是: 通过领域划分, 区分不同子域在公司内的不同功能属性和重要性, 从而公司可对不同子域采取不同的资源投入和建设策略, 其关注度也会不一样.</p> <h4 id="_03-限界上下文-定义领域边界的利器"><a href="#_03-限界上下文-定义领域边界的利器" class="header-anchor">#</a> 03-限界上下文:定义领域边界的利器</h4> <p>在 DDD 领域建模和系统建设过程中, 有很多的参与者, 包括领域专家, 产品经理, 项目经理, 架构师, 开发经理和测试经理等. 对同样的领域知识, 不同的参与角色可能会有不同的理解, 那大家交流起来就会有障碍, 怎么办呢? 因此, 在 DDD 中就出现了  <strong>&quot;通用语言&quot; 和 &quot;限界上下文&quot;</strong>  这两个重要的概念.</p> <p>这两者相辅相成, <strong>通用语言定义上下文含义, 限界上下文则定义领域边界, 以确保每个上下文含义在它特定的边界内都具有唯一的含义, 领域模型则存在于这个边界之内</strong>. 你是不是感觉这么描述很抽象? 没关系, 接下来会一一详细讲解.</p> <p>在这之前, 先看这样两个问题, 这也是今天内容的核心.</p> <ol><li>为什么要提出限界上下文的概念(也就是说除了解决交流障碍这个广义的原因, 还有更具体的吗)?</li> <li>限界上下文在微服务设计中的作用和意义是什么?</li></ol> <h5 id="什么是通用语言"><a href="#什么是通用语言" class="header-anchor">#</a> 什么是通用语言?</h5> <p>为了更好地理解限界上下文, 回答这两个问题, 先从通用语言讲起.</p> <p>怎么理解通用语言这个概念呢? 在事件风暴过程中, <strong>通过团队交流达成共识的, 能够简单, 清晰, 准确描述业务涵义和规则的语言就是通用语言</strong>. 也就是说, 通用语言是团队统一的语言, 不管你在团队中承担什么角色, 在同一个领域的软件生命周期里都使用统一的语言进行交流.</p> <p>那么, 通用语言的价值也就很明了了, 它可以<strong>解决交流障碍</strong>这个问题, 使领域专家和开发人员能够协同合作, 从而确保业务需求的正确表达.</p> <p>但是, 对这个概念的理解, 到这里还不够.</p> <p>通用语言包含术语和用例场景, 并且能够直接反映在代码中. <mark><strong>通用语言中的名词可以给领域对象命名, 如商品, 订单等, 对应实体对象; 而动词则表示一个动作或事件, 如商品已下单, 订单已付款等, 对应领域事件或者命令</strong></mark>.</p> <p>通用语言贯穿 DDD 的整个设计过程. 作为<strong>项目团队沟通和协商形成的统一语言</strong>, 基于它, 就能够开发出可读性更好的代码, 将业务需求准确转化为代码设计.</p> <p>下面看一张图, 这张图描述了从事件风暴建立通用语言到领域对象设计和代码落地的完整过程.</p> <p><img src="/img/ddd0f35334caaee49e17362ffe686fb9-20230731163226-ci1qqqs.png" alt=""></p> <ol><li>在事件风暴的过程中, 领域专家会和设计, 开发人员一起<strong>建立领域模型</strong>, 在领域建模的过程中会形成<strong>通用的业务术语和用户故事</strong>. 事件风暴也是一个项目团队统一语言的过程.</li> <li>通过用户故事分析会形成一个个的<strong>领域对象</strong>, 这些领域对象对应领域模型的业务对象, 每一个业务对象和领域对象都有通用的名词术语, 并且一一映射.</li> <li>微服务代码模型来源于领域模型, <strong>每个代码模型的代码对象跟领域对象一一对应</strong>.</li></ol> <p>这里再分享一条经验, 我自己经常用, 特别有效. 设计过程中<strong>可以用一些表格, 来记录事件风暴和微服务设计过程中产生的领域对象及其属性</strong>. 比如, 领域对象在 DDD 分层架构中的位置, 属性, 依赖关系以及与代码模型对象的映射关系等.</p> <p>下面是一个微服务设计实例的部分数据, 表格中的这些名词术语就是项目团队在事件风暴过程中达成一致, 可用于团队内部交流的通用语言. 在这个表格里面可以看到, DDD 分析过程中所有的领域对象以及它们的属性都被记录下来了, 除了 DDD 的领域对象, 还记录了在微服务设计过程中领域对象所对应的代码对象, 并将它们一一映射.</p> <p><img src="/img/ee2346d3fdfcebe2029442ad6b39eb1d-20230731163226-d46cots.png" alt=""></p> <p>到这里, 要再强调一次. <strong>DDD 分析和设计过程中的每一个环节都需要保证限界上下文内术语的统一, 在代码模型设计的时侯就要建立领域对象和代码对象的一一映射, 从而保证业务模型和代码模型的一致, 实现业务语言与代码语言的统一</strong>.</p> <p>如果做到了这一点, 也就是<strong>建立了领域对象和代码对象的映射关系</strong>, 那就可以指导软件开发人员准确无误地按照设计文档完成微服务开发了. 即使是不熟悉代码的业务人员, 也可以很快找到代码的位置.</p> <h5 id="什么是限界上下文"><a href="#什么是限界上下文" class="header-anchor">#</a> 什么是限界上下文?</h5> <p>那刚刚提到的限界上下文又是用来做什么的呢?</p> <p>我们知道语言都有它的语义环境, 同样, 通用语言也有它的上下文环境. 为了避免同样的概念或语义在不同的上下文环境中产生歧义, DDD 在战略设计上提出了 &quot;限界上下文&quot; 这个概念, 用来<strong>确定语义所在的领域边界</strong>.</p> <p>可以将限界上下文拆解为两个词: 限界和上下文. <strong>限界就是领域的边界, 而上下文则是语义环境</strong>. 通过领域的限界上下文, 就可以在统一的领域边界内用统一的语言进行交流.</p> <p>综合一下, 我认为<strong>限界上下文的定义就是: 用来封装通用语言和领域对象, 提供上下文环境, 保证在领域之内的一些术语, 业务相关对象等(通用语言)有一个确切的含义, 没有二义性</strong>. 这个边界定义了模型的适用范围, 使团队所有成员能够明确地知道什么应该在模型中实现, 什么不应该在模型中实现.</p> <h6 id="进一步理解限界上下文"><a href="#进一步理解限界上下文" class="header-anchor">#</a> 进一步理解限界上下文</h6> <p>可以通过一些例子进一步理解一下这个概念, 不要小看它, 彻底弄懂会给你后面实践 DDD 打下一个坚实的基础.</p> <p>都说中文这门语言非常丰富, 在不同的时空和背景下, 同样的一句话会有不同的涵义. 有一个例子你应该听说过. 在一个明媚的早晨, 孩子起床问妈妈: &quot;今天应该穿几件衣服呀?&quot; 妈妈回答: &quot;能穿多少就穿多少!&quot; 那到底是穿多还是穿少呢?</p> <p>如果没有具体的语义环境, 还真不太好理解. 但如果已经知道了这句话的语义环境, 比如是寒冬腊月或者是炎炎夏日, 那理解这句话的涵义就会很容易了.</p> <p>所以语言离不开它的语义环境.</p> <p>而<strong>业务的通用语言就有它的业务边界</strong>, 我们不大可能用一个简单的术语没有歧义地去描述一个复杂的业务领域. <strong>限界上下文就是用来细分领域, 从而定义通用语言所在的边界</strong>.</p> <p>现在用一个保险领域的例子来说明下术语的边界. 保险业务领域有投保单, 保单, 批单, 赔案等保险术语, 它们分别应用于保险的不同业务流程.</p> <ol><li>客户投保时, 业务人员记录投保信息, 系统对应有投保单实体对象.</li> <li>缴费完成后, 业务人员将投保单转为保单, 系统对应有保单实体对象, 保单实体与投保单实体关联.</li> <li>如客户需要修改保单信息, 保单变为批单, 系统对应有批单实体对象, 批单实体与保单实体关联.</li> <li>如果客户发生理赔, 生成赔案, 系统对应有报案实体对象, 报案实体对象与保单或者批单实体关联.</li></ol> <p>投保单, 保单, 批单, 赔案等, 这些术语虽然都跟保单有关, 但<strong>不能将保单这个术语作用在保险全业务领域</strong>. 因为术语有它的边界, 超出了边界理解上就会出现问题.</p> <p>如果你对保险业不大了解也没关系, 电商肯定再熟悉不过了吧?</p> <p>正如电商领域的商品一样, <strong>商品在不同的阶段有不同的术语, 在销售阶段是商品, 而在运输阶段则变成了货物</strong>. 同样的一个东西, 由于业务领域的不同, 赋予了这些术语不同的涵义和职责边界, 这个边界就可能会成为未来微服务设计的边界. 看到这, 你应该非常清楚了, <strong>领域边界就是通过限界上下文来定义的</strong>.</p> <h5 id="限界上下文和微服务的关系"><a href="#限界上下文和微服务的关系" class="header-anchor">#</a> 限界上下文和微服务的关系</h5> <p>接下来对这个概念做进一步的延伸. 看看限界上下文和微服务具体存在怎样的关系.</p> <p>举个例子. 车险承保的流程包含了投保, 缴费, 出单等几个主要流程. 如果出险了还会有报案, 查勘, 定损, 理算等理赔流程.</p> <p>保险领域还是很复杂的, 在这里用一个简化的保险模型来说明下限界上下文和微服务的关系. 这里还会用到一些基础知识, 比如领域和子域.</p> <p><img src="/img/1761c1c052d2bf3214ecf8f66d5ed121-20230731163226-qgj3n9w.png" alt=""></p> <p>首先, 领域可以拆分为多个子领域. 一个领域相当于一个问题域, 领域拆分为子域的过程就是大问题拆分为小问题的过程. 在这个图里面保险领域被拆分为: <strong>投保, 支付, 保单管理和理赔四个子域</strong>.</p> <p>子域还可根据需要进一步拆分为子子域, 比如, 支付子域可继续拆分为收款和付款子子域. <strong>拆到一定程度后, 有些子子域的领域边界就可能变成限界上下文的边界了</strong>.</p> <p>子域可能会包含多个限界上下文, 如理赔子域就包括报案, 查勘和定损等多个限界上下文(限界上下文与理赔的子子域领域边界重合). 也有可能子域本身的边界就是限界上下文边界, 如投保子域.</p> <p><strong>每个领域模型都有它对应的限界上下文, 团队在限界上下文内用通用语言交流. 领域内所有限界上下文的领域模型构成整个领域的领域模型</strong>.</p> <p>理论上限界上下文就是微服务的边界. 将限界上下文内的领域模型映射到微服务, 就完成了从问题域到软件的解决方案.</p> <p>可以说, 限界上下文是微服务设计和拆分的主要依据. 在领域模型中, 如果不考虑技术异构, 团队沟通等其它外部因素, 一个限界上下文理论上就可以设计为一个微服务.</p> <p>不过, 这里还是要提示一下: 除了理论, 微服务的拆分还是有很多限制因素的, 在设计中不宜过度拆分. 那这个度怎么把握好呢? 有关微服务设计和具体的拆分方法, 会在实战篇中详细讲解.</p> <h5 id="总结-3"><a href="#总结-3" class="header-anchor">#</a> 总结</h5> <p>通用语言确定了项目团队内部交流的统一语言, 而这个语言所在的语义环境则是由限界上下文来限定的, 以确保语义的唯一性. 而领域专家, 架构师和开发人员的主要工作就是通过事件风暴来划分限界上下文. <mark><strong>限界上下文确定了微服务的设计和拆分方向, 是微服务设计和拆分的主要依据</strong></mark>. 如果不考虑技术异构, 团队沟通等其它外部因素, 一个限界上下文理论上就可以设计为一个微服务.</p> <p>可以说, 限界上下文在微服务设计中具有很重要的意义, 如果限界上下文的方向偏离, 那微服务的设计结果也就可想而知了. 因此, 只有理解了限界上下文的真正涵义以及它在微服务设计中的作用, 才能真正发挥 DDD 的价值, 这是基础也是前提.</p> <h4 id="_04-实体和值对象-从领域模型的基础单元看系统设计"><a href="#_04-实体和值对象-从领域模型的基础单元看系统设计" class="header-anchor">#</a> 04-实体和值对象:从领域模型的基础单元看系统设计</h4> <p>今天来学习 DDD 战术设计中的两个重要概念: <strong>实体和值对象</strong>.</p> <p>这两个概念都是领域模型中的<strong>领域对象</strong>. 它们在领域模型中起什么作用, 战术设计时如何将它们映射到代码和数据模型中去? 就是这一讲重点要关注的问题.</p> <p>另外, 在战略设计向战术设计过渡的这个过程中, 理解和区分实体和值对象在不同阶段的形态是很重要的, 毕竟阶段不同, 它们的形态也会发生变化, 这与设计和代码实现密切相关.</p> <p>接下来就分别看看实<strong>体和值对象的这些问题</strong>, 从中找找答案.</p> <h5 id="实体"><a href="#实体" class="header-anchor">#</a> 实体</h5> <p>先来看一下实体是什么东西?</p> <p>在 DDD 中有这样一类对象, 它们<strong>拥有唯一标识符, 且标识符在历经各种状态变更后仍能保持一致</strong>. 对这些对象而言, 重要的不是其属性, 而是其延续性和标识, 对象的延续性和标识会跨越甚至超出软件的生命周期. 我们把这样的对象称为<strong>实体</strong>. 没理解? 没关系! 请继续阅读.</p> <h6 id="_1-实体的业务形态"><a href="#_1-实体的业务形态" class="header-anchor">#</a> 1.实体的业务形态</h6> <p>在 DDD 不同的设计过程中, <strong>实体的形态是不同的</strong>. 在战略设计时, 实体是领域模型的一个重要对象. <strong>领域模型中的实体是多个属性, 操作或行为的载体</strong>. 在事件风暴中, 可以根据命令, 操作或者事件, 找出产生这些行为的业务实体对象, 进而按照一定的业务规则将依存度高和业务关联紧密的多个实体对象和值对象进行聚类, 形成聚合. 可以这么理解, <strong>实体和值对象是组成领域模型的基础单元</strong>.</p> <h6 id="_2-实体的代码形态"><a href="#_2-实体的代码形态" class="header-anchor">#</a> 2.实体的代码形态</h6> <p>在代码模型中, <strong>实体的表现形式是实体类</strong>, 这个类包含了<strong>实体的属性和方法, 通过这些方法实现实体自身的业务逻辑</strong>. 在 DDD 里, 这些实体类通常采用<strong>充血模型</strong>, 与这个实体相关的所有业务逻辑都在实体类的方法中实现, 跨多个实体的领域逻辑则在领域服务中实现.</p> <h6 id="_3-实体的运行形态"><a href="#_3-实体的运行形态" class="header-anchor">#</a> 3.实体的运行形态</h6> <p><strong>实体以 DO(领域对象)的形式存在, 每个实体对象都有唯一的 ID</strong>. 可以对一个实体对象进行多次修改, 修改后的数据和原来的数据可能会大不相同. 但是, 由于它们拥有相同的 ID, 它们依然是同一个实体. 比如商品是商品上下文的一个实体, 通过唯一的商品 ID 来标识, 不管这个商品的数据如何变化, 商品的 ID 一直保持不变, 它始终是同一个商品.</p> <h6 id="_4-实体的数据库形态"><a href="#_4-实体的数据库形态" class="header-anchor">#</a> 4.实体的数据库形态</h6> <p>与传统数据模型设计优先不同, DDD 是先构建领域模型, 针对实际业务场景构建实体对象和行为, 再将实体对象映射到数据持久化对象.</p> <p>在领域模型映射到数据模型时, <strong>一个实体可能对应 0 个, 1 个或者多个数据库持久化对象</strong>. 大多数情况下实体与持久化对象是一对一. 在某些场景中, 有些实体只是暂驻静态内存的一个运行态实体, 它不需要持久化. 比如, 基于多个价格配置数据计算后生成的折扣实体.</p> <p>而在有些复杂场景下, 实体与持久化对象则可能是一对多或者多对一的关系. 比如, 用户 user 与角色 role 两个持久化对象可生成权限实体, 一个实体对应两个持久化对象, 这是一对多的场景. 再比如, 有些场景为了避免数据库的联表查询, 提升系统性能, 会将客户信息 customer 和账户信息 account 两类数据保存到同一张数据库表中, 客户和账户两个实体可根据需要从一个持久化对象中生成, 这就是多对一的场景.</p> <h5 id="值对象"><a href="#值对象" class="header-anchor">#</a> 值对象</h5> <p>值对象相对实体来说, 会更加抽象一些, 概念上会结合例子来讲.</p> <p>先看一下《实现领域驱动设计》一书中对值对象的定义: 通过对象属性值来识别的对象, 它将多个相关属性组合为一个概念整体. 在 DDD 中<strong>用来描述领域的特定方面, 并且是一个没有标识符的对象, 叫作值对象</strong>.</p> <p>也就说, <strong>值对象描述了领域中的一件东西, 这个东西是不可变的, 它将不同的相关属性组合成了一个概念整体</strong>. 当度量和描述改变时, 可以用另外一个值对象予以替换. 它可以和其它值对象进行相等性比较, 且不会对协作对象造成副作用. 这部分在后面讲 &quot;值对象的运行形态&quot; 时还会有例子.</p> <p>上面这两段对于定义的阐述, 如果还是觉得有些晦涩, 不妨 &quot;翻译&quot; 一下, 用更通俗的语言把定义讲清楚.</p> <p>简单来说, <strong>值对象本质上就是一个集</strong>. 那这个集合里面有什么呢? 若干个用于描述目的, 具有整体概念和不可修改的属性. 那这个集合存在的意义又是什么? 在领域建模的过程中, 值对象可以保证属性归类的清晰和概念的完整性, 避免属性零碎.</p> <p>这里举个简单的例子, 请看下面这张图:</p> <p><img src="/img/78c2b602d30e95f09a31d1a35ee260c9-20230731163226-4yplagd.png" alt=""></p> <p>人员实体原本包括: 姓名, 年龄, 性别以及人员所在的省, 市, 县和街道等属性. 这样显示地址相关的属性就很零碎了对不对? 现在可以将 &quot;省, 市, 县和街道等属性&quot; 拿出来构成一个 &quot;地址属性集合&quot;, 这个<strong>集合就是值对象</strong>了.</p> <h6 id="_1-值对象的业务形态"><a href="#_1-值对象的业务形态" class="header-anchor">#</a> 1.值对象的业务形态</h6> <p>值对象是 DDD 领域模型中的一个基础对象, 它跟实体一样都来源于事件风暴所构建的领域模型, 都包含了若干个属性, 它与实体一起构成聚合.</p> <p>不妨对照实体, 来看值对象的业务形态, 这样更好理解. 本质上, <strong>实体是看得到, 摸得着的实实在在的业务对象, 实体具有业务属性, 业务行为和业务逻辑</strong>. 而值对象只是若干个属性的集合, 只有数据初始化操作和有限的不涉及修改数据的行为, <strong>基本不包含业务逻辑</strong>. 值对象的属性集虽然在物理上独立出来了, 但在逻辑上它仍然是实体属性的一部分, 用于描述实体的特征.</p> <p>在值对象中也有部分共享的标准类型的值对象, 它们有自己的限界上下文, 有自己的持久化对象, 可以建立共享的数据类微服务, 比如数据字典.</p> <h6 id="_2-值对象的代码形态"><a href="#_2-值对象的代码形态" class="header-anchor">#</a> 2.值对象的代码形态</h6> <p>值对象在代码中有这样两种形态. 如果值对象是<strong>单一属性</strong>, 则直接定义为实体类的属性; 如果值对象是<strong>属性集合</strong>, 则把它设计为 Class 类, Class 将具有整体概念的多个属性归集到属性集合, 这样的值对象没有 ID, 会被实体整体引用.</p> <p>看一下下面这段代码, person 这个实体有<strong>若干个单一属性的值对象</strong>, 比如 Id, name 等属性; 同时它也包含多个属性的值对象, 比如地址 address.</p> <p><img src="/img/ccc06cfa0a8dad57ce21bf4ddffa812c-20230731163226-lo1jwbm.png" alt=""></p> <h6 id="_3-值对象的运行形态"><a href="#_3-值对象的运行形态" class="header-anchor">#</a> 3.值对象的运行形态</h6> <p>实体实例化后的 DO 对象的业务属性和业务行为非常丰富, 但值对象实例化的对象则相对简单和乏味. 除了值对象数据初始化和整体替换的行为外, 其它业务行为就很少了.</p> <p>值对象嵌入到实体的话, 有这样两种不同的数据格式, 也可以说是两种方式, 分别是<strong>属性嵌入的方式和序列化大对象的方式</strong>.</p> <p>引用单一属性的值对象或只有一条记录的多属性值对象的实体, 可以采用属性嵌入的方式嵌入. 引用一条或多条记录的多属性值对象的实体, 可以采用序列化大对象的方式嵌入. 比如, 人员实体可以有多个通讯地址, 多个地址序列化后可以嵌入人员的地址属性. 值对象创建后就不允许修改了, 只能用另外一个值对象来整体替换.</p> <p>**如果你对这两种方式不够了解, 可以看看下面的例子. **</p> <p>案例 1: <strong>以属性嵌入的方式形成的人员实体对象</strong>, 地址值对象直接以属性值嵌入人员实体中.</p> <p><img src="/img/4c5f353f9e707f1d197edb9758616cd9-20230731163226-d57vcgi.png" alt=""></p> <p>案例 2: <strong>以序列化大对象的方式形成的人员实体对象</strong>, 地址值对象被序列化成大对象 Json 串后, 嵌入人员实体中.</p> <p><img src="/img/3ceb7dbe9b0fef599121831c5d395cd5-20230731163226-r898vni.png" alt=""></p> <h6 id="_4-值对象的数据库形态"><a href="#_4-值对象的数据库形态" class="header-anchor">#</a> 4.值对象的数据库形态</h6> <p><strong>DDD 引入值对象是希望实现从 &quot;数据建模为中心&quot; 向 &quot;领域建模为中心&quot; 转变, 减少数据库表的数量和表与表之间复杂的依赖关系, 尽可能地简化数据库设计, 提升数据库性能</strong>.</p> <p>如何理解用值对象来简化数据库设计呢?</p> <p>传统的数据建模大多是根据数据库范式设计的, 每一个数据库表对应一个实体, 每一个实体的属性值用单独的一列来存储, 一个实体主表会对应 N 个实体从表. 而值对象在数据库持久化方面简化了设计, 它的数据库设计大多采用非数据库范式, 值对象的属性值和实体对象的属性值保存在同一个数据库实体表中.</p> <p>举个例子, 还是基于上述人员和地址那个场景, 实体和数据模型设计通常有两种解决方案: 第一是把地址值对象的所有属性都放到人员实体表中, 创建人员实体, 创建人员数据表; 第二是创建人员和地址两个实体, 同时创建人员和地址两张表.</p> <p>第一个方案会破坏地址的业务涵义和概念完整性, 第二个方案增加了不必要的实体和表, 需要处理多个实体和表的关系, 从而增加了数据库设计的复杂性.</p> <p>**那到底应该怎样设计, 才能让业务含义清楚, 同时又不让数据库变得复杂呢? **</p> <p>可以综合这两个方案的优势, 扬长避短. 在领域建模时, 可以<strong>把地址作为值对象, 人员作为实体</strong>, 这样就可以保留地址的业务涵义和概念完整性. 而在数据建模时, <strong>可以将地址的属性值嵌入人员实体数据库表中, 只创建人员数据库表</strong>. 这样既可以兼顾业务含义和表达, 又不增加数据库的复杂度.</p> <p><strong>值对象就是通过这种方式, 简化了数据库设计</strong>, 总结一下就是: <strong>在领域建模时, 可以将部分对象设计为值对象, 保留对象的业务涵义, 同时又减少了实体的数量; 在数据建模时, 可以将值对象嵌入实体, 减少实体表的数量, 简化数据库设计</strong>.</p> <p>另外, 也有 DDD 专家认为, 要想发挥对象的威力, 就需要优先做领域建模, 弱化数据库的作用, 只把数据库作为一个保存数据的仓库即可. 即使违反数据库设计原则, 也不用大惊小怪, 只要业务能够顺利运行, 就没什么关系.</p> <h6 id="_5-值对象的优势和局限"><a href="#_5-值对象的优势和局限" class="header-anchor">#</a> 5.值对象的优势和局限</h6> <p>值对象是一把双刃剑, 它的优势是<strong>可以简化数据库设计, 提升数据库性能</strong>. 但如果值对象使用不当, 它的优势就会很快变成劣势. &quot;知彼知己, 方能百战不殆&quot;, 需要理解值对象真正适合的场景.</p> <p>值对象采用序列化大对象的方法简化了数据库设计, 减少了实体表的数量, 可以简单, 清晰地表达业务概念. 这种设计方式虽然降低了数据库设计的复杂度, 但却<strong>无法满足基于值对象的快速查询, 会导致搜索值对象属性值变得异常困难</strong>.</p> <p>值对象采用属性嵌入的方法提升了数据库的性能, 但如果实体引用的值对象过多, 则会导致实体堆积一堆缺乏概念完整性的属性, 这样值对象就会失去业务涵义, 操作起来也不方便.</p> <p>所以, 可以对照着以上这些优劣势, 结合业务场景, 好好想一想. 那如果在业务场景中, 值对象的这些劣势都可以避免掉, 那就请放心大胆地使用值对象.</p> <h5 id="实体和值对象的关系"><a href="#实体和值对象的关系" class="header-anchor">#</a> 实体和值对象的关系</h5> <p><strong>实体和值对象</strong>是微服务底层的最基础的对象, 一起实现实体最基本的核心领域逻辑.</p> <p>值对象和实体在某些场景下可以互换, 很多 DDD 专家在这些场景下, 其实也很难判断到底将领域对象设计成实体还是值对象? 可以说, 值对象在某些场景下有很好的价值, 但是并不是所有的场景都适合值对象. 需要根据团队的设计和开发习惯, 以及上面的优势和局限分析, 选择最适合的方法.</p> <p>关于值对象还要多说几句. 其实, DDD 引入值对象还有一个重要的原因, 就是到底<strong>领域建模优先还是数据建模优先</strong>?</p> <p><mark><strong>DDD 提倡从领域模型设计出发, 而不是先设计数据模型</strong></mark>. 前面讲过了, 传统的数据模型设计通常是一个表对应一个实体, 一个主表关联多个从表, 当实体表太多的时候就很容易陷入无穷无尽的复杂的数据库设计, 领域模型就很容易被数据模型绑架. 可以说, 值对象的诞生, 在一定程度上, 和实体是互补的.</p> <p>还是以前面的图示为例:</p> <p><img src="/img/78c2b602d30e95f09a31d1a35ee260c9-20230731163226-ohh17fl.png" alt=""></p> <p>在领域模型中<strong>人员是实体, 地址是值对象, 地址值对象被人员实体引用</strong>. 在数据模型设计时, 地址值对象可以作为一个属性集整体嵌入人员实体中, 组合形成上图这样的数据模型; 也可以以序列化大对象的形式加入到人员的地址属性中, 前面表格有展示.</p> <p>从这个例子中可以看出, 同样的对象在不同的场景下, 可能会设计出不同的结果. 有些场景中, 地址会被某一实体引用, 它只<strong>承担描述实体的作用, 并且它的值只能整体替换, 这时候就可以将地址设计为值对象</strong>, 比如收货地址. 而在<strong>某些业务场景中, 地址会被经常修改, 地址是作为一个独立对象存在的, 这时候它应该设计为实体, 比如行政区划中的地址信息维护</strong>.</p> <h5 id="总结-4"><a href="#总结-4" class="header-anchor">#</a> 总结</h5> <p>今天主要学习了实体和值对象在 DDD 不同设计阶段的形态, 以及它们从战略设计向战术设计演进过程中的设计方法.</p> <p>这个过程是从业务模型向系统模型落地的过程, 比较复杂, 很考验你的设计能力, 很多时候都要结合自己的业务场景, 选择合适的方法来进行微服务设计. 强调一点, 我们不避讳传统的设计方法, 毕竟适合自己的才是最好的.</p> <h4 id="_05-聚合和聚合根-怎样设计聚合"><a href="#_05-聚合和聚合根-怎样设计聚合" class="header-anchor">#</a> 05-聚合和聚合根:怎样设计聚合?</h4> <p>今天来学习聚合(Aggregate)和聚合根(AggregateRoot).</p> <p>先回顾下上一讲, 在事件风暴中, 会根据一些<strong>业务操作和行为找出实体(Entity)或值对象(ValueObject), 进而将业务关联紧密的实体和值对象进行组合, 构成聚合, 再根据业务语义将多个聚合划定到同一个限界上下文(Bounded Context)中, 并在限界上下文内完成领域建模</strong>.</p> <p>那你知道为什么要在限界上下文和实体之间增加聚合和聚合根这两个概念吗? 它们的作用是什么? 怎么设计聚合? 这就是这一讲重点要关注的问题.</p> <h5 id="聚合"><a href="#聚合" class="header-anchor">#</a> 聚合</h5> <p>在 DDD 中, <strong>实体和值对象是很基础的领域对象</strong>. 实体一般对应业务对象, 它具有业务属性和业务行为; 而值对象主要是属性集合, 对实体的状态和特征进行描述. 但实体和值对象都只是个体化的对象, 它们的行为表现出来的是个体的能力.</p> <p>**那聚合在其中起什么作用呢? **</p> <p>举个例子. 社会是由一个个的个体组成的, 象征着每一个人. 随着社会的发展, 慢慢出现了社团, 机构, 部门等组织, 我们开始从个人变成了组织的一员, 大家可以协同一致的工作, 朝着一个最大的目标前进, 发挥出更大的力量.</p> <p><strong>领域模型内的实体和值对象就好比个体, 而能让实体和值对象协同工作的组织就是聚合, 它用来确保这些领域对象在实现共同的业务逻辑时, 能保证数据的一致性</strong>.</p> <p>可以这么理解, <strong>聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的, 聚合是数据修改和持久化的基本单元, 每一个聚合对应一个仓储, 实现数据的持久化</strong>.</p> <p><strong>聚合有一个聚合根和上下文边界, 这个边界根据业务单一职责和高内聚原则, 定义了聚合内部应该包含哪些实体和值对象, 而聚合之间的边界是松耦合的</strong>. 按照这种方式设计出来的微服务很自然就是 &quot;高内聚, 低耦合&quot; 的.</p> <p><strong>聚合在 DDD 分层架构里属于领域层, 领域层包含了多个聚合, 共同实现核心业务逻辑</strong>. 聚合内实体以充血模型实现个体业务能力, 以及业务逻辑的高内聚. 跨多个实体的业务逻辑通过领域服务来实现, 跨多个聚合的业务逻辑通过应用服务来实现. 比如有的业务场景需要同一个聚合的 A 和 B 两个实体来共同完成, 就可以将这段业务逻辑用领域服务来实现; 而有的业务逻辑需要聚合 C 和聚合 D 中的两个服务共同完成, 这时就可以用应用服务来组合这两个服务.</p> <h5 id="聚合根"><a href="#聚合根" class="header-anchor">#</a> 聚合根</h5> <p><strong>聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制, 而导致聚合, 实体之间数据不一致性的问题</strong>.</p> <p>传统数据模型中的每一个实体都是对等的, 如果任由实体进行无控制地调用和数据修改, 很可能会导致实体之间数据逻辑的不一致. 而如果采用锁的方式则会增加软件的复杂度, 也会降低系统的性能.</p> <p>如果<strong>把聚合比作组织, 那聚合根就是这个组织的负责人</strong>. 聚合根也称为根实体, 它不仅是实体, 还是聚合的管理者.</p> <p>首先它作为实体本身, <strong>拥有实体的属性和业务行为</strong>, 实现自身的业务逻辑. 其次它作为聚合的管理者, 在聚合内部负责<strong>协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑</strong>. 最后在聚合之间, 它还是<strong>聚合对外的接口人</strong>, 以聚合根 ID 关联的方式接受外部任务和请求, 在上下文内实现聚合之间的业务协同. 也就是说, 聚合之间通过聚合根 ID 关联引用, 如果需要访问其它聚合的实体, 就要先访问聚合根, 再导航到聚合内部实体, 外部对象不能直接访问聚合内实体.</p> <h5 id="怎样设计聚合"><a href="#怎样设计聚合" class="header-anchor">#</a> 怎样设计聚合?</h5> <p>DDD 领域建模通常采用事件风暴, 它通常采用用例分析, 场景分析和用户旅程分析等方法, 通过头脑风暴列出所有可能的<strong>业务行为和事件</strong>, 然后找出产生这些行为的领域对象, 并梳理领域对象之间的关系, 找出聚合根, 找出与聚合根业务紧密关联的实体和值对象, 再将聚合根, 实体和值对象组合, 构建聚合.</p> <p>下面以保险的投保业务场景为例, 看一下聚合的构建过程主要都包括哪些步骤.</p> <p><img src="/img/dc1cffc51b7648e66bf51c75d82a9254-20230731163226-ds8ua2c.png" alt=""></p> <p><strong>第 1 步:</strong>  采用事件风暴, 根据业务行为, 梳理出在投保过程中发生这些行为的所有的<strong>实体和值对象</strong>, 比如投保单, 标的, 客户, 被保人等等.</p> <p><strong>第 2 步:</strong>  从众多实体中<strong>选出适合作为对象管理者的根实体, 也就是聚合根</strong>. 判断一个实体是否是聚合根, 可以结合以下场景分析: 是否有独立的生命周期? 是否有全局唯一 ID? 是否可以创建或修改其它对象? 是否有专门的模块来管这个实体. 图中的<strong>聚合根分别是投保单和客户实体</strong>.</p> <p><strong>第 3 步:</strong>  根据<strong>业务单一职责和高内聚原则, 找出与聚合根关联的所有紧密依赖的实体和值对象</strong>. 构建出 1 个包含聚合根(唯一), 多个实体和值对象的对象集合, 这个集合就是聚合. 在图中构建了客户和投保这两个聚合.</p> <p><strong>第 4 步:</strong>  在聚合内根据聚合根, 实体和值对象的依赖关系, 画出<strong>对象的引用和依赖模型</strong>. 这里需要说明一下: 投保人和被保人的数据, 是通过关联客户 ID 从客户聚合中获取的, 在投保聚合里它们是投保单的值对象, 这些值对象的数据是客户的冗余数据, 即使未来客户聚合的数据发生了变更, 也不会影响投保单的值对象数据. 从图中还可以看出实体之间的引用关系, 比如在投保聚合里投保单聚合根引用了报价单实体, 报价单实体则引用了报价规则子实体.</p> <p>**第 5 步: **多个聚合根据业务语义和上下文一起划分到同一个限界上下文内.</p> <p>这就是一个聚合诞生的完整过程了.</p> <h5 id="聚合的一些设计原则"><a href="#聚合的一些设计原则" class="header-anchor">#</a> 聚合的一些设计原则</h5> <p>不妨先看一下《实现领域驱动设计》一书中对聚合设计原则的描述, 原文是有点不太好理解的, 来解释一下.</p> <ul><li><strong>在一致性边界内建模真正的不变条件.</strong>  聚合用来封装真正的不变性, 而不是简单地将对象组合在一起. 聚合内有一套不变的业务规则, 各实体和值对象按照统一的业务规则运行, 实现对象数据的一致性, 边界之外的任何东西都与该聚合无关, 这就是聚合能实现业务高内聚的原因.</li> <li><strong>设计小聚合.</strong>  如果聚合设计得过大, 聚合会因为包含过多的实体, 导致实体之间的管理过于复杂, 高频操作时会出现并发冲突或者数据库锁, 最终导致系统可用性变差. 而小聚合设计则可以降低由于业务过大导致聚合重构的可能性, 让领域模型更能适应业务的变化.</li> <li><strong>通过唯一标识引用其它聚合.</strong>  聚合之间是通过关联外部聚合根 ID 的方式引用, 而不是直接对象引用的方式. 外部聚合的对象放在聚合边界内管理, 容易导致聚合的边界不清晰, 也会增加聚合之间的耦合度.</li> <li><strong>在边界之外使用最终一致性.</strong>  聚合内数据强一致性, 而聚合之间数据最终一致性. 在<strong>一次事务中, 最多只能更改一个聚合的状态</strong>. 如果一次业务操作涉及多个聚合状态的更改, 应采用领域事件的方式异步修改相关的聚合, 实现聚合之间的解耦(相关内容我会在领域事件部分详解).</li> <li><strong>通过应用层实现跨聚合的服务调用.</strong>  为实现微服务内聚合之间的解耦, 以及未来以聚合为单位的微服务组合和拆分, 应避免跨聚合的领域服务调用和跨聚合的数据库表关联.</li></ul> <p>上面的这些原则是 DDD 的一些通用的设计原则, 还是那句话: &quot;适合自己的才是最好的.&quot; 在系统设计过程时, 一定要考虑项目的具体情况, 如果面临使用的便利性, 高性能要求, 技术能力缺失和全局事务管理等影响因素, 这些原则也并不是不能突破的, 总之一切以解决实际问题为出发点.</p> <h5 id="总结-5"><a href="#总结-5" class="header-anchor">#</a> 总结</h5> <p>这里总结下聚合, 聚合根, 实体和值对象它们之间的联系和区别.</p> <p><strong>聚合的特点:</strong>  高内聚, 低耦合, 它是领域模型中最底层的边界, 可以作为拆分微服务的最小单位, 但不建议对微服务过度拆分. 但在对性能有极致要求的场景中, 聚合可以独立作为一个微服务, 以满足版本的高频发布和极致的弹性伸缩能力. 一个微服务可以包含多个聚合, 聚合之间的边界是微服务内天然的逻辑边界. 有了这个逻辑边界, 在微服务架构演进时就可以以聚合为单位进行拆分和组合了, 微服务的架构演进也就不再是一件难事了.</p> <p><strong>聚合根的特点:</strong>  聚合根是实体, 有实体的特点, 具有全局唯一标识, 有独立的生命周期. <strong>一个聚合只有一个聚合根</strong>, 聚合根在聚合内对实体和值对象采用直接对象引用的方式进行组织和协调, 聚合根与聚合根之间通过 ID 关联的方式实现聚合之间的协同.</p> <p>**实体的特点: **有 ID 标识, 通过 ID 判断相等性, ID 在聚合内唯一即可. 状态可变, 它依附于聚合根, 其生命周期由聚合根管理. 实体一般会持久化, 但与数据库持久化对象不一定是一对一的关系. 实体可以引用聚合内的聚合根, 实体和值对象.</p> <p>**值对象的特点: **无 ID, 不可变, 无生命周期, 用完即扔. 值对象之间通过属性值判断相等性. 它的核心本质是值, 是一组概念完整的属性组成的集合, 用于描述实体的状态和特征. 值对象尽量只引用值对象.</p> <h3 id="进阶篇-2"><a href="#进阶篇-2" class="header-anchor">#</a> 进阶篇</h3> <h4 id="_06-领域事件-解耦微服务的关键"><a href="#_06-领域事件-解耦微服务的关键" class="header-anchor">#</a> 06-领域事件:解耦微服务的关键</h4> <p>本节来聊一聊 &quot;领域事件(Domain Event)&quot;.</p> <p>在事件风暴(Event Storming)时, 我们发现除了命令和操作等业务行为以外, 还有一种非常重要的事件, 这种<strong>事件发生后通常会导致进一步的业务操作, 在 DDD 中这种事件被称为领域事件</strong>.</p> <p><strong>什么是领域事件? 领域事件的技术实现机制是怎样的</strong>? 这一讲就重点解决这两个大的问题.</p> <h5 id="领域事件"><a href="#领域事件" class="header-anchor">#</a> 领域事件</h5> <p>领域事件是领域模型中非常重要的一部分, 用来表示领域中发生的事件. <strong>一个领域事件将导致进一步的业务操作, 在实现业务解耦的同时, 还有助于形成完整的业务闭环</strong>.</p> <p>举例来说的话, 领域事件可以是业务流程的一个步骤, 比如投保业务缴费完成后, 触发投保单转保单的动作; 也可能是定时批处理过程中发生的事件, 比如批处理生成季缴保费通知单, 触发发送缴费邮件通知操作; 或者一个事件发生后触发的后续动作, 比如密码连续输错三次, 触发锁定账户的动作.</p> <p>**那如何识别领域事件呢? **</p> <p>很简单, 和刚才讲的定义是强关联的. 在做用户旅程或者场景分析时, 要捕捉业务, 需求人员或领域专家口中的关键词: &quot;如果发生..., 则...&quot;, &quot;当做完...的时候, 请通知...&quot;, &quot;发生...时, 则...&quot; 等. 在这些场景中, 如果发生某种事件后, 会触发进一步的操作, 那么这个事件很可能就是领域事件.</p> <p>那<strong>领域事件为什么要用最终一致性</strong>, 而不是传统 SOA 的直接调用的方式呢?</p> <p>回顾一下聚合的一个设计原则: <strong>在边界之外使用最终一致性. 一次事务最多只能更改一个聚合的状态. 如果一次业务操作涉及多个聚合状态的更改, 应采用领域事件的最终一致性</strong>.</p> <p>领域事件驱动设计可以切断领域模型之间的强依赖关系, <mark><strong>事件发布完成后, 发布方不必关心后续订阅方事件处理是否成功, 这样可以实现领域模型的解耦, 维护领域模型的独立性和数据的一致性</strong></mark>. 在领域模型映射到微服务系统架构时, <strong>领域事件可以解耦微服务, 微服务之间的数据不必要求强一致性, 而是基于事件的最终一致性</strong>.</p> <p>回到具体的业务场景, 我们发现有的领域事件发生在微服务内的聚合之间, 有的则发生在微服务之间, 还有两者皆有的场景, 一般来说跨微服务的领域事件处理居多. 在微服务设计时不同领域事件的处理方式会不一样.</p> <h6 id="_1-微服务内的领域事件"><a href="#_1-微服务内的领域事件" class="header-anchor">#</a> 1.微服务内的领域事件</h6> <p><mark><strong>当领域事件发生在微服务内的聚合之间, 领域事件发生后完成事件实体构建和事件数据持久化, 发布方聚合将事件发布到事件总线, 订阅方接收事件数据完成后续业务操作</strong></mark>.</p> <p>微服务内大部分事件的集成, 都发生在同一个进程内, 进程自身可以很好地控制事务, 因此不一定需要引入消息中间件. 但一个事件如果同时更新多个聚合, 按照 DDD &quot;一次事务只更新一个聚合&quot; 的原则, 就要考虑是否引入事件总线. 但微服务内的<strong>事件总线</strong>, 可能会增加开发的复杂度, 因此需要结合应用复杂度和收益进行综合考虑.</p> <p><strong>微服务内应用服务, 可以通过跨聚合的服务编排和组合, 以服务调用的方式完成跨聚合的访问, 这种方式通常应用于实时性和数据一致性要求高的场景</strong>. 这个过程会用到分布式事务, 以保证发布方和订阅方的数据同时更新成功.</p> <h6 id="_2-微服务之间的领域事件"><a href="#_2-微服务之间的领域事件" class="header-anchor">#</a> 2.微服务之间的领域事件</h6> <p>跨微服务的领域事件会在不同的限界上下文或领域模型之间实现业务协作, 其主要目的是<strong>实现微服务解耦, 减轻微服务之间实时服务访问的压力</strong>.</p> <p>领域事件发生在微服务之间的场景比较多, 事件处理的机制也更加复杂. 跨微服务的事件可以推动业务流程或者数据在不同的子域或微服务间直接流转.</p> <p>跨微服务的事件机制要总体考虑<strong>事件构建, 发布和订阅, 事件数据持久化, 消息中间件, 甚至事件数据持久化时还可能需要考虑引入分布式事务机制</strong>等.</p> <p>微服务之间的访问也可以采用应用服务直接调用的方式, 实现数据和服务的实时访问, 弊端就是跨微服务的数据同时变更需要引入分布式事务, 以确保数据的一致性. 分布式事务机制会影响系统性能, 增加微服务之间的耦合, 所以还是要尽量<strong>避免使用分布式事务</strong>.</p> <h5 id="领域事件相关案例"><a href="#领域事件相关案例" class="header-anchor">#</a> 领域事件相关案例</h5> <p>下面介绍一个保险承保业务过程中有关领域事件的案例.</p> <p>一个保单的生成, 经历了很多子域, 业务状态变更和跨微服务业务数据的传递. 这个过程会产生很多的领域事件, 这些<strong>领域事件促成了保险业务数据, 对象在不同的微服务和子域之间的流转和角色转换</strong>.</p> <p>在下面这张图中, 列出了几个关键流程, 用来说明如何用领域事件驱动设计来驱动承保业务流程.</p> <p><img src="/img/7a51c3628e76cc5ff8b853ed24b52fac-20230731163226-a01ksdf.png" alt=""></p> <p>**事件起点: 客户购买保险 - 业务人员完成保单录入 - 生成投保单 - 启动缴费动作. **</p> <ol><li>投保微服务生成缴费通知单, 发布第一个事件: <strong>缴费通知单已生成</strong>, 将缴费通知单数据发布到消息中间件. 收款微服务订阅缴费通知单事件, 完成缴费操作. 缴费通知单已生成, 领域事件结束.</li> <li>收款微服务缴费完成后, 发布第二个领域事件: <strong>缴费已完成</strong>, 将缴费数据发布到消息中间件. 原来的订阅方收款微服务这时则变成了发布方. 原来的事件发布方投保微服务转换为订阅方. 投保微服务在收到缴费信息并确认缴费完成后, 完成投保单转成保单的操作. 缴费已完成, 领域事件结束.</li> <li>投保微服务在投保单转保单完成后, 发布第三个领域事件: <strong>保单已生成</strong>, 将保单数据发布到消息中间件. 保单微服务接收到保单数据后, 完成保单数据保存操作. 保单已生成, 领域事件结束.</li> <li>保单微服务完成保单数据保存后, 后面还会发生一系列的领域事件, 以并发的方式将保单数据通过消息中间件发送到佣金, 收付费和再保等微服务, 一直到财务, 完后保单后续所有业务流程. 这里就不详细说了.</li></ol> <p>总之, 通过<strong>领域事件驱动的异步化机制, 可以推动业务流程和数据在各个不同微服务之间的流转, 实现微服务的解耦, 减轻微服务之间服务调用的压力, 提升用户体验</strong>.</p> <h5 id="领域事件总体架构"><a href="#领域事件总体架构" class="header-anchor">#</a> 领域事件总体架构</h5> <p>领域事件的执行需要一系列的组件和技术来支撑. 来看一下这个领域事件总体技术架构图, 领域事件处理包括: <strong>事件构建和发布, 事件数据持久化, 事件总线, 消息中间件, 事件接收和处理等</strong>. 下面逐一讲一下.</p> <p><img src="/img/eba01289aedbbd76192fea717fba821f-20230731163226-wdb1u7h.png" alt=""></p> <h6 id="_1-事件构建和发布"><a href="#_1-事件构建和发布" class="header-anchor">#</a> 1.事件构建和发布</h6> <p>事件基本属性至少包括: <strong>事件唯一标识, 发生时间, 事件类型和事件源</strong>, 其中事件唯一标识应该是全局唯一的, 以便事件能够无歧义地在多个限界上下文中传递. 事件基本属性主要记录事件自身以及事件发生背景的数据.</p> <p>另外事件中还有一项更重要, 那就是<strong>业务属性, 用于记录事件发生那一刻的业务数据, 这些数据会随事件传输到订阅方, 以开展下一步的业务操作</strong>.</p> <p><strong>事件基本属性和业务属性一起构成事件实体, 事件实体依赖聚合根</strong>. 领域事件发生后, 事件中的业务数据不再修改, 因此业务数据可以以序列化值对象的形式保存, 这种存储格式在消息中间件中也比较容易解析和获取.</p> <p>为了保证事件结构的统一, 还会创建事件基类 DomainEvent(参考下图), 子类可以扩充属性和方法. 由于事件没有太多的业务行为, 实现方法一般比较简单.</p> <p><img src="/img/7a23b23a9823a6d27cd727d7c3edd3d0-20230731163226-udxbu2z.png" alt=""></p> <p><strong>事件发布之前需要先构建事件实体并持久化</strong>. 事件发布的方式有很多种, 可以通过应用服务或者领域服务发布到事件总线或者消息中间件, 也可以从事件表中利用定时程序或数据库日志捕获技术获取增量事件数据, 发布到消息中间件.</p> <h6 id="_2-事件数据持久化"><a href="#_2-事件数据持久化" class="header-anchor">#</a> 2.事件数据持久化</h6> <p><strong>事件数据持久化可用于系统之间的数据对账, 或者实现发布方和订阅方事件数据的审计</strong>. 当遇到消息中间件, 订阅方系统宕机或者网络中断, 在问题解决后仍可继续后续业务流转, 保证数据的一致性.</p> <p>事件数据持久化有两种方案, 在实施过程中可以根据自己的业务场景进行选择.</p> <ol><li><strong>持久化到本地业务数据库的事件表中</strong>, 利用本地事务保证业务和事件数据的一致性.</li> <li><strong>持久化到共享的事件数据库中</strong>. 这里需要注意的是: 业务数据库和事件数据库不在一个数据库中, 它们的数据持久化操作会跨数据库, 因此需要分布式事务机制来保证业务和事件数据的强一致性, 结果就是会对系统性能造成一定的影响.</li></ol> <h6 id="_3-事件总线-eventbus"><a href="#_3-事件总线-eventbus" class="header-anchor">#</a> 3.事件总线 (EventBus)</h6> <p><mark><strong>事件总线是实现微服务内聚合之间领域事件的重要组件, 它提供事件分发和接收等服务</strong></mark>. 事件总线是进程内模型, 它会在微服务内聚合之间遍历订阅者列表, 采取同步或异步的模式传递数据. 事件分发流程大致如下:</p> <ol><li>如果是微服务内的订阅者(其它聚合), 则直接分发到指定订阅者;</li> <li>如果是微服务外的订阅者, 将事件数据保存到事件库(表)并异步发送到消息中间件;</li> <li>如果同时存在微服务内和外订阅者, 则先分发到内部订阅者, 将事件消息保存到事件库(表), 再异步发送到消息中间件.</li></ol> <h6 id="_4-消息中间件"><a href="#_4-消息中间件" class="header-anchor">#</a> 4.消息中间件</h6> <p>跨微服务的领域事件大多会用到消息中间件, <strong>实现跨微服务的事件发布和订阅</strong>. 消息中间件的产品非常成熟, 市场上可选的技术也非常多, 比如 Kafka, RabbitMQ 等.</p> <h6 id="_5-事件接收和处理"><a href="#_5-事件接收和处理" class="header-anchor">#</a> 5.事件接收和处理</h6> <p><strong>微服务订阅方在应用层采用监听机制, 接收消息队列中的事件数据, 完成事件数据的持久化后, 就可以开始进一步的业务处理</strong>. 领域事件处理可在领域服务中实现.</p> <h5 id="领域事件运行机制相关案例"><a href="#领域事件运行机制相关案例" class="header-anchor">#</a> 领域事件运行机制相关案例</h5> <p>这里用承保业务流程的缴费通知单事件, 来解释一下领域事件的运行机制. 这个领域事件发生在投保和收款微服务之间. 发生的领域事件是: <strong>缴费通知单已生成</strong>. 下一步的业务操作是: <strong>缴费</strong>.</p> <p><img src="/img/39cc87d89b6e0bd3dd3c86aea521a2c5-20230731163226-14b0i53.png" alt=""></p> <p><strong>事件起点: 出单员生成投保单, 核保通过后, 发起生成缴费通知单的操作</strong>.  ****</p> <ol><li>投保微服务应用服务, 调用聚合中的领域服务 createPaymentNotice 和 createPaymentNoticeEvent, 分别创建缴费通知单, 缴费通知单事件. 其中缴费通知单事件类 PaymentNoticeEvent 继承基类 DomainEvent.</li> <li>利用仓储服务持久化缴费通知单相关的业务和事件数据. 为了避免分布式事务, 这些业务和事件数据都持久化到本地投保微服务数据库中.</li> <li>通过数据库日志捕获技术或者定时程序, 从数据库事件表中获取事件增量数据, 发布到消息中间件. 这里说明: 事件发布也可以通过应用服务或者领域服务完成发布.</li> <li><strong>收款微服务在应用层从消息中间件订阅缴费通知单事件消息主题, 监听并获取事件数据后, 应用服务调用领域层的领域服务将事件数据持久化到本地数据库中</strong>.</li> <li>收款微服务调用领域层的领域服务 PayPremium, 完成缴费.</li> <li>事件结束.</li></ol> <p>提示: 缴费完成后, 后续流程的微服务还会产生很多新的领域事件, 比如缴费已完成, 保单已保存等等. 这些后续的事件处理基本上跟 1～6 的处理机制类似.</p> <h5 id="总结-6"><a href="#总结-6" class="header-anchor">#</a> 总结</h5> <p>今天主要讲了领域事件以及领域事件的处理机制. <strong>领域事件驱动</strong>是很成熟的技术, 在很多分布式架构中得到了大量的使用. 领域事件是 DDD 的一个重要概念, 在设计时要重点关注领域事件, 用领域事件来驱动业务的流转, 尽量采用<strong>基于事件的最终一致</strong>, 降低微服务之间直接访问的压力, 实现微服务之间的解耦, 维护领域模型的独立性和数据一致性.</p> <p>除此之外, 领域事件驱动机制可以实现一个发布方 N 个订阅方的模式, 这在传统的直接服务调用设计中基本是不可能做到的.</p> <h4 id="_07-ddd分层架构-有效降低层与层之间的依赖"><a href="#_07-ddd分层架构-有效降低层与层之间的依赖" class="header-anchor">#</a> 07-DDD分层架构:有效降低层与层之间的依赖</h4> <p>前面讲了 DDD 的一些重要概念以及领域模型的设计理念. 今天来聊聊 &quot;DDD 分层架构&quot;.</p> <p>微服务架构模型有好多种, 例如整洁架构, CQRS 和六边形架构等等. 每种架构模式虽然提出的时代和背景不同, 但其核心理念都是为了设计出 &quot;高内聚低耦合&quot; 的架构, 轻松实现架构演进. 而 DDD 分层架构的出现, 使<strong>架构边界变得越来越清晰</strong>, 它在微服务架构模型中, 占有非常重要的位置.</p> <p><strong>那 DDD 分层架构到底长什么样? DDD 分层架构如何推动架构演进? 该怎么转向 DDD 分层架构</strong>? 这就是这一讲重点要解决的问题.</p> <h5 id="什么是ddd分层架构"><a href="#什么是ddd分层架构" class="header-anchor">#</a> 什么是DDD分层架构?</h5> <p>DDD 的分层架构在不断发展. 最早是传统的四层架构; 后来四层架构有了进一步的优化, 实现了各层对基础层的解耦; 再后来<strong>领域层和应用层之间增加了上下文环境(Context)层</strong>, 五层架构(DCI)就此形成了.</p> <p><img src="/img/9b36e5aca8b8ccc0527f152e43337585-20230731163226-uw23x74.png" alt=""></p> <p>看一下上面这张图, 在最早的传统四层架构中, 基础层是被其它层依赖的, 它位于最核心的位置, 那按照分层架构的思想, 它应该就是核心, 但实际上<mark><strong>领域层才是软件的核心</strong></mark>, 所以这种依赖是有问题的. 后来采用了依赖倒置(Dependency inversion principle,DIP)的设计, 优化了传统的四层架构, 实现了各层对基础层的解耦.</p> <p>今天讲的 DDD 分层架构就是优化后的四层架构. 在下面这张图中, 从上到下依次是: 用户接口层, 应用层, 领域层和基础层. 那 DDD 各层的主要职责是什么呢? 下面逐一介绍一下.</p> <p><img src="/img/973e9e4f3dfc428c0d93578018a38f48-20230731163226-easokm2.png" alt=""></p> <p>1.<strong>用户接口层</strong></p> <p><strong>用户接口层负责向用户显示信息和解释用户指令</strong>. 这里的用户可能是: 用户, 程序, 自动化测试和批处理脚本等等.</p> <p>2.<strong>应用层</strong></p> <p>应用层是<strong>很薄的一层</strong>, 理论上不应该有业务规则或逻辑, 主要面向用例和流程相关的操作. 但应用层又位于领域层之上, 因为领域层包含多个聚合, 所以它<strong>可以协调多个聚合的服务和领域对象完成服务编排和组合, 协作完成业务操作</strong>.</p> <p>此外, 应用层也是微服务之间交互的通道, 它可以调用其它微服务的应用服务, 完成微服务之间的服务组合和编排.</p> <p>这里要提醒一下: 在设计和开发时, <strong>不要将本该放在领域层的业务逻辑放到应用层中实现</strong>. 因为庞大的应用层会使领域模型失焦, 时间一长微服务就会演化为传统的三层架构, 业务逻辑会变得混乱.</p> <p>另外, <strong>应用服务是在应用层的, 它负责服务的组合, 编排和转发, 负责处理业务用例的执行顺序以及结果的拼装, 以粗粒度的服务通过 API 网关向前端发布</strong>. 还有, 应用服务还可以进行安全认证, 权限校验, 事务控制, 发送或订阅领域事件等.</p> <p>3.<strong>领域层</strong></p> <p><mark><strong>领域层的作用是实现企业核心业务逻辑, 通过各种校验手段保证业务的正确性. 领域层主要体现领域模型的业务能力, 它用来表达业务概念, 业务状态和业务规则</strong></mark>.</p> <p>领域层包含聚合根, 实体, 值对象, 领域服务等领域模型中的领域对象.</p> <p>这里要特别解释一下其中几个领域对象的关系, 以便在设计领域层的时候能更加清楚. 首先, 领域模型的业务逻辑主要是由<strong>实体和领域服务</strong>来实现的, 其中实体会采用充血模型来实现所有与之相关的业务功能. 其次, 要知道, <strong>实体和领域对象在实现业务逻辑上不是同级的</strong>, 当领域中的某些功能, 单一实体(或者值对象)不能实现时, 领域服务就会出马, 它可以组合聚合内的多个实体(或者值对象), 实现复杂的业务逻辑.</p> <p>4.<strong>基础层</strong></p> <p>基础层是贯穿所有层的, 它的作用就是为其它各层提供通用的技术和基础服务, 包括<strong>第三方工具, 驱动, 消息中间件, 网关, 文件, 缓存以及数据库等. 比较常见的功能还是提供数据库持久化</strong>.</p> <p>基础层包含基础服务, 它采用依赖倒置设计, 封装基础资源服务, 实现应用层, 领域层与基础层的解耦, 降低外部资源变化对应用的影响.</p> <p>比如说, 在传统架构设计中, 由于上层应用对数据库的强耦合, 很多公司在架构演进中最担忧的可能就是换数据库了, 因为一旦更换数据库, 就可能需要重写大部分的代码, 这对应用来说是致命的. 那采用依赖倒置的设计以后, <strong>应用层就可以通过解耦来保持独立的核心业务逻辑</strong>. 当数据库变更时, 只需要更换数据库基础服务就可以了, 这样就将资源变更对应用的影响降到了最低.</p> <h6 id="ddd分层架构最重要的原则是什么"><a href="#ddd分层架构最重要的原则是什么" class="header-anchor">#</a> DDD分层架构最重要的原则是什么?</h6> <p>在《实现领域驱动设计》一书中, DDD 分层架构有一个重要的原则: <mark><strong>每层只能与位于其下方的层发生耦合</strong></mark>.</p> <p>而架构根据耦合的紧密程度又可以分为两种: 严格分层架构和松散分层架构. 优化后的 DDD 分层架构模型就属于严格分层架构, 任何层只能对位于其直接下方的层产生依赖. 而传统的 DDD 分层架构则属于松散分层架构, 它允许某层与其任意下方的层发生依赖.</p> <p>那怎么选呢? 综合我的经验, 为了服务的可管理, <strong>建议采用严格分层架构</strong>.</p> <p>在严格分层架构中, <strong>领域服务只能被应用服务调用, 而应用服务只能被用户接口层调用, 服务是逐层对外封装或组合的, 依赖关系清晰</strong>. 而在松散分层架构中, 领域服务可以同时被应用层或用户接口层调用, 服务的依赖关系比较复杂且难管理, 甚至容易使核心业务逻辑外泄.</p> <p>试想下, 如果领域层中的某个服务发生了重大变更, 那该如何通知所有调用方同步调整和升级呢? 但在严格分层架构中, 只需要逐层通知上层服务就可以了.</p> <h5 id="ddd分层架构如何推动架构演进"><a href="#ddd分层架构如何推动架构演进" class="header-anchor">#</a> DDD分层架构如何推动架构演进?</h5> <p>领域模型不是一成不变的, 因为业务的变化会影响领域模型, 而领域模型的变化则会影响微服务的功能和边界. 那该<strong>如何实现领域模型和微服务的同步演进</strong>呢?</p> <h6 id="_1-微服务架构的演进"><a href="#_1-微服务架构的演进" class="header-anchor">#</a> 1.微服务架构的演进</h6> <p>通过基础篇的讲解可以知道: 领域模型中对象的层次从内到外依次是: 值对象, 实体, 聚合和限界上下文.</p> <p>实体或值对象的简单变更, 一般不会让领域模型和微服务发生大的变化. 但<strong>聚合的重组或拆分却可以</strong>. 这是因为聚合内业务功能内聚, 能独立完成特定的业务逻辑. 那聚合的重组或拆分, 势必就会引起业务模块和系统功能的变化了.</p> <p>这里可以以聚合为基础单元, 完成领域模型和微服务架构的演进. <strong>聚合可以作为一个整体, 在不同的领域模型之间重组或者拆分, 或者直接将一个聚合独立为微服务</strong>.</p> <p>​<img src="/img/cf2d99f2aea603246dcb7f3ac60a9054-20230731163226-cskkzwt.png" alt="">结合上图, 以微服务 1 为例, 讲解下微服务架构的演进过程:</p> <ol><li>当你发现微服务 1 中聚合 a 的功能经常被高频访问, 以致拖累整个微服务 1 的性能时, 可以把聚合 a 的代码, 从微服务 1 中剥离出来, 独立为微服务 2. 这样微服务 2 就可轻松应对高性能场景.</li> <li>在业务发展到一定程度以后, 会发现微服务 2 的领域模型有了变化, 聚合 d 会更适合放到微服务 1 的领域模型中. 这时就可以将聚合 d 的代码整体搬迁到微服务 1 中. 如果在设计时已经定义好了聚合之间的代码边界, 这个过程不会太复杂, 也不会花太多时间.</li> <li>最后发现, 在经历模型和架构演进后, 微服务 1 已经从最初包含聚合 a, b, c, 演进为包含聚合 b, c, d 的新领域模型和微服务了.</li></ol> <p>你看, 好的聚合和代码模型的边界设计, 可以让你快速应对业务变化, 轻松实现领域模型和微服务架构的演进. 你可能还会想, 那怎么实现聚合代码快速重组呢? 别急, 后面实战篇会详细讲解, 这里先感知下大的实现流程.</p> <h6 id="_2-微服务内服务的演进"><a href="#_2-微服务内服务的演进" class="header-anchor">#</a> 2.微服务内服务的演进</h6> <p>在微服务内部, <strong>实体的方法被领域服务组合和封装, 领域服务又被应用服务组合和封装</strong>. 在服务逐层组合和封装的过程中, 可以发现这样一个有趣的现象.</p> <p><img src="/img/0a166a58f5d076f3cac431925d175afe-20230731163226-cfljzuj.png" alt=""></p> <p>看下上面这张图. 在服务设计时, 并不一定能完整预测有哪些下层服务会被多少个上层服务组装, 因此<strong>领域层通常只提供一些原子服务</strong>, 比如领域服务 a, b, c. 但随着系统功能增强和外部接入越来越多, 应用服务会不断丰富. 有一天你会发现领域服务 b 和 c 同时多次被多个应用服务调用了, 执行顺序也基本一致. 这时可以考虑将 b 和 c 合并, 再<strong>将应用服务中 b, c 的功能下沉到领域层</strong>, 演进为新的领域服务(b+c). 这样既减少了服务的数量, 也减轻了上层服务组合和编排的复杂度.</p> <p>这就是服务演进的过程, 它是随着系统发展的, 最后会发现你的领域模型会越来越精炼, 越来越能适应需求的快速变化.</p> <h5 id="三层架构如何演进到ddd分层架构"><a href="#三层架构如何演进到ddd分层架构" class="header-anchor">#</a> 三层架构如何演进到DDD分层架构?</h5> <p>综合前面的讲解, 相信 DDD 分层架构的优势, 你心里也有个谱了. 不妨总结一下最最重要两点.</p> <p>首先, <strong>由于层间松耦合, 可以专注于本层的设计, 而不必关心其它层, 也不必担心自己的设计会影响其它层</strong>. 可以说, DDD 成功地降低了层与层之间的依赖.</p> <p>其次, <strong>分层架构使得程序结构变得清晰, 升级和维护更加容易</strong>. 修改某层代码时, 只要本层的接口参数不变, 其它层可以不必修改. 即使本层的接口发生变化, 也只影响相邻的上层, 修改工作量小且错误可以控制, 不会带来意外的风险.</p> <p><strong>那该怎样转向 DDD 分层架构呢? 不妨看看下面这个过程.</strong></p> <p>传统企业应用大多是单体架构, 而单体架构则大多是三层架构. 三层架构解决了程序内代码间调用复杂, 代码职责不清的问题, <strong>但这种分层是逻辑概念, 在物理上它是中心化的集中式架构, 并不适合分布式微服务架构</strong>.</p> <p>DDD 分层架构中的要素其实和三层架构类似, 只是在 DDD 分层架构中, 这些要素被重新归类, 重新划分了层, 确定了层与层之间的交互规则和职责边界.</p> <p><img src="/img/d7203f5336ab3994a14408c3597af545-20230731163226-z6428ai.png" alt=""></p> <p>看一下上面这张图, 分析一下从三层架构向 DDD 分层架构演进的过程.</p> <p>首先,要清楚, 三层架构向 DDD 分层架构演进, 主要发生在<mark><strong>业务逻辑层和数据访问层</strong></mark>.</p> <p><strong>DDD 分层架构在用户接口层引入了 DTO, 给前端提供了更多的可使用数据和更高的展示灵活性</strong>.</p> <p><strong>DDD 分层架构对三层架构的业务逻辑层进行了更清晰的划分, 改善了三层架构核心业务逻辑混乱, 代码改动相互影响大的情况</strong>. DDD 分层架构<strong>将业务逻辑层的服务拆分到了应用层和领域层</strong>. 应用层快速响应前端的变化, 领域层实现领域模型的能力.</p> <p>另外一个重要的变化发生在<strong>数据访问层和基础层</strong>之间. 三层架构数据访问采用 DAO 方式; DDD 分层架构的数据库等基础资源访问, 采用了仓储(Repository)设计模式, 通过依赖倒置实现各层对基础资源的解耦.</p> <p>仓储又分为两部分: <strong>仓储接口和仓储实现</strong>. <mark><strong>仓储接口放在领域层中, 仓储实现放在基础层</strong></mark>. 原来三层架构通用的第三方工具包, 驱动, Common, Utility, Config 等通用的公共的资源类统一放到了基础层.</p> <p>最后, 传统三层架构向 DDD 分层架构的演进, 体现的正是领域驱动设计思想的演进. 希望你也感受到了, 并尝试将其应用在自己的架构设计中.</p> <h5 id="总结-7"><a href="#总结-7" class="header-anchor">#</a> 总结</h5> <p>今天主要讲了 DDD 的分层架构, 它作为微服务的核心框架, 怎么强调其重要性都是不过分的.</p> <p><mark><strong>DDD 分层架构包含用户接口层, 应用层, 领域层和基础层</strong></mark>. 通过这些层次划分, 可以明确微服务各层的职能, 划定各领域对象的边界, 确定各领域对象的协作方式. 这种架构既体现了微服务设计和架构演进的需求, 又很好地融入了领域模型的概念, 二者无缝结合, 相信会给你的微服务设计带来不一样的感觉.</p> <h4 id="_08-微服务架构模型-几种常见模型的对比和分析"><a href="#_08-微服务架构模型-几种常见模型的对比和分析" class="header-anchor">#</a> 08-微服务架构模型:几种常见模型的对比和分析</h4> <p>在上一讲重点介绍了 DDD 分层架构, 同时也提到了微服务架构模型其实还有好多种, 不知道你注意到了没? 这些架构模型在实际应用中都具有很高的借鉴价值.</p> <p>那么今天就把 <strong>DDD 分层架构, 整洁架构, 六边形架构这三种架构模型</strong>放到一起, 对比分析, 看看如何利用好它们, 帮助我们设计出高内聚低耦合的中台以及微服务架构.</p> <h5 id="整洁架构"><a href="#整洁架构" class="header-anchor">#</a> 整洁架构</h5> <p>整洁架构又名 &quot;洋葱架构&quot;. 为什么叫它洋葱架构? 看看下面这张图就明白了. 整洁架构的层就像洋葱片一样, 它体现了分层的设计思想.</p> <p>在整洁架构里, 同心圆代表应用软件的不同部分, <strong>从里到外依次是领域模型, 领域服务, 应用服务和最外围的容易变化的内容</strong>, 比如用户界面和基础设施.</p> <p>整洁架构最主要的原则是依赖原则, 它定义了各层的依赖关系, <strong>越往里依赖越低, 代码级别越高, 越是核心能力</strong>. 外圆代码依赖只能指向内圆, <strong>内圆不需要知道外圆的任何情况</strong>.</p> <p><img src="/img/66f3f4ed71509eefd325705998ddd146-20230731163226-qu7lszb.png" alt=""></p> <p>在洋葱架构中, 各层的职能是这样划分的:</p> <ol><li><strong>领域模型实现领域内核心业务逻辑, 它封装了企业级的业务规则</strong>. 领域模型的主体是实体, 一个实体可以是一个带方法的对象, 也可以是一个数据结构和方法集合.</li> <li><strong>领域服务实现涉及多个实体的复杂业务逻辑</strong>.</li> <li><strong>应用服务实现与用户操作相关的服务组合与编排, 它包含了应用特有的业务流程规则, 封装和实现了系统所有用例</strong>.</li> <li><strong>最外层主要提供适配的能力, 适配能力分为主动适配和被动适配</strong>. 主动适配主要实现外部用户, 网页, 批处理和自动化测试等对内层业务逻辑访问适配. 被动适配主要是实现核心业务逻辑对基础资源访问的适配, 比如数据库, 缓存, 文件系统和消息中间件等.</li> <li>红圈内的领域模型, 领域服务和应用服务一起组成软件核心业务能力.</li></ol> <h5 id="六边形架构"><a href="#六边形架构" class="header-anchor">#</a> 六边形架构</h5> <p>六边形架构又名 &quot;<strong>端口适配器架构</strong>&quot;. 追溯微服务架构的渊源, 一般都会涉及到六边形架构.</p> <p>六边形架构的核心理念是: 应用是通过端口与外部进行交互的. 我想这也是微服务架构下 API 网关盛行的主要原因吧.</p> <p>也就是说, 在下图的六边形架构中, <strong>红圈内的核心业务逻辑(应用程序和领域模型)与外部资源(包括 APP, Web 应用以及数据库资源等)完全隔离, 仅通过适配器进行交互</strong>. 它解决了业务逻辑与用户界面的代码交错问题, 很好地实现了前后端分离. 六边形架构各层的依赖关系与整洁架构一样, 都是由外向内依赖.</p> <p><img src="/img/fb041c0d15f9e7ddc0b356b59f5d215c-20230731163226-u800i9p.png" alt=""></p> <p>六边形架构将系统分为内六边形和外六边形两层, 这两层的职能划分如下:</p> <ol><li><strong>红圈内的六边形实现应用的核心业务逻辑</strong>;</li> <li><strong>外六边形完成外部应用, 驱动和基础资源等的交互和访问, 对前端应用以 API 主动适配的方式提供服务, 对基础资源以依赖倒置被动适配的方式实现资源访问</strong>.</li></ol> <p>六边形架构的一个端口可能对应多个外部系统, 不同的外部系统也可能会使用不同的适配器, 由适配器负责协议转换. 这就使得应用程序能够以一致的方式被用户, 程序, 自动化测试和批处理脚本使用.</p> <h5 id="三种微服务架构模型的对比和分析"><a href="#三种微服务架构模型的对比和分析" class="header-anchor">#</a> 三种微服务架构模型的对比和分析</h5> <p>虽然 DDD 分层架构, 整洁架构, 六边形架构的架构模型表现形式不一样, 但不要被它们的表象所迷惑, 这三种架构模型的设计思想正是<mark><strong>微服务架构高内聚低耦合原则的完美体现</strong></mark>, 而它们身上闪耀的正是以领域模型为中心的设计思想.</p> <p><img src="/img/b21e2c38e3cd6d6b619c3e50db01735b-20230731163226-xaggpb4.png" alt=""></p> <p>看下上面这张图, 结合图示对这三种架构模型做一个分析.</p> <p>重点关注图中的红色线框, 它们是非常重要的分界线, 这三种架构里面都有, 它的作用就是<mark><strong>将核心业务逻辑与外部应用, 基础资源进行隔离</strong></mark>.</p> <p><strong>红色框内部主要实现核心业务逻辑, 但核心业务逻辑也是有差异的, 有的业务逻辑属于领域模型的能力, 有的则属于面向用户的用例和流程编排能力</strong>. 按照这种功能的差异, 在这三种架构中划分了应用层和领域层, 来承担不同的业务逻辑.</p> <p><mark><strong>领域层实现面向领域模型, 实现领域模型的核心业务逻辑, 属于原子模型, 它需要保持领域模型和业务逻辑的稳定, 对外提供稳定的细粒度的领域服务, 所以它处于架构的核心位置</strong></mark>.</p> <p><strong>应用层实现面向用户操作相关的用例和流程, 对外提供粗粒度的 API 服务</strong>. 它就像一个齿轮一样进行前台应用和领域层的适配, 接收前台需求, 随时做出响应和调整, 尽量避免将前台需求传导到领域层. 应用层作为配速齿轮则位于前台应用和领域层之间.</p> <p>可以说, 这三种架构都考虑了<mark><strong>前端需求的多变与领域模型的不变</strong></mark>. 需求变幻无穷, 但变化总是有矩可循的, 用户体验, 操作习惯, 市场环境以及管理流程的变化, 往往会导致界面逻辑和流程的多变. 但总体来说, 不管前端如何变化, 在企业没有大的变革的情况下, 核心领域逻辑基本不会大变, 所以领域模型相对稳定, 而用例和流程则会随着外部应用需求而随时调整. 把握好这个规律, 就知道该如何设计应用层和领域层了.</p> <p><strong>架构模型通过分层的方式来控制需求变化从外到里对系统的影响, 从外向里受需求影响逐步减小</strong>. 面向用户的前端可以快速响应外部需求进行调整和发布, 灵活多变, 应用层通过服务组合和编排来实现业务流程的快速适配上线, 减少传导到领域层的需求, 使领域层保持长期稳定.</p> <p>这样设计的好处很明显了, 就是可以保证领域层的核心业务逻辑不会因为外部需求和流程的变动而调整, 对于建立前台灵活, 中台稳固的架构很有帮助.</p> <p>看到这里, 你是不是已经猜出中台和微服务设计的关键了呢? 我给出的答案是: <strong>领域模型和微服务的合理分层设计</strong>. 那么你的答案呢?</p> <h5 id="从三种架构模型看中台和微服务设计"><a href="#从三种架构模型看中台和微服务设计" class="header-anchor">#</a> 从三种架构模型看中台和微服务设计</h5> <p>结合这三种微服务架构模型的共性, 下面来谈谈<strong>中台和微服务设计</strong>的一些心得体会.</p> <p><strong>中台本质上是领域的子域, 它可能是核心域, 也可能是通用域或支撑域</strong>. 通常大家认为阿里的中台对应 DDD 的通用域, 将通用的公共能力沉淀为中台, 对外提供通用共享服务.</p> <p>中台作为子域还可以继续分解为子子域, 在子域分解到合适大小, 通过事件风暴划分限界上下文以后, 就可以定义微服务了, 微服务用来实现中台的能力. 表面上看, DDD, 中台, 微服务这三者之间似乎没什么关联, 实际上它们的关系是非常紧密的, 组合在一起可以作为一个理论体系用于中台和微服务设计.</p> <h6 id="_1-中台建设要聚焦领域模型"><a href="#_1-中台建设要聚焦领域模型" class="header-anchor">#</a> 1.中台建设要聚焦领域模型</h6> <p>中台需要站在<strong>全企业的高度考虑能力的共享和复用</strong>.</p> <p>中台设计时, 需要建立中台内所有限界上下文的领域模型, DDD 建模过程中会考虑架构演进和功能的重新组合. 领域模型建立的过程会对业务和应用进行清晰的逻辑和物理边界(微服务)划分. <strong>领域模型的结果会影响到后续的系统模型, 架构模型和代码模型, 最终影响到微服务的拆分和项目落地</strong>.</p> <p>因此, 在中台设计中首先要聚焦<strong>领域模型</strong>, 将它放在核心位置.</p> <h6 id="_2-微服务要有合理的架构分层"><a href="#_2-微服务要有合理的架构分层" class="header-anchor">#</a> 2.微服务要有合理的架构分层</h6> <p><strong>微服务设计要有分层的设计思想, 让各层各司其职, 建立松耦合的层间关系</strong>.</p> <p><mark><strong>不要把与领域无关的逻辑放在领域层实现, 保证领域层的纯洁和领域逻辑的稳定, 避免污染领域模型</strong></mark>. 也不要把领域模型的业务逻辑放在应用层, 这样会导致应用层过于庞大, 最终领域模型会失焦. 如果实在无法避免, 可以引入防腐层, 进行新老系统的适配和转换, 过渡期完成后, 可以直接将防腐层代码抛弃.</p> <p>微服务内部的分层方式已经清楚了, 那微服务之间是否也有层次依赖关系呢? 如何实现微服务之间的服务集成?</p> <p>有的微服务可以与前端应用集成, 一起完成特定的业务, 这是项目级微服务. 而有的则是某个职责单一的中台微服务, 企业级的业务流程需要将多个这样的微服务组合起来才能完成, 这是企业级中台微服务. 两类微服务由于复杂度不一样, 集成方式也会有差异.</p> <blockquote><p>项目级微服务</p></blockquote> <p>项目级微服务的内部遵循<strong>分层架构模型</strong>就可以了. <strong>领域模型的核心逻辑在领域层实现, 服务的组合和编排在应用层实现, 通过 API 网关为前台应用提供服务, 实现前后端分离</strong>. 但项目级的微服务可能会调用其它微服务, 看在下面这张图中, 比如某个项目级微服务 B 调用认证微服务 A, 完成登录和权限认证.</p> <p>通常项目级微服务之间的集成, 发生在<strong>微服务的应用层</strong>, 由应用服务调用其它微服务发布在 API 网关上的应用服务. 你看下图中微服务 B 中红色框内的应用服务 B, 它除了可以组合和编排自己的领域服务外, 还可以组合和编排外部微服务的应用服务. 它只要将编排后的服务发布到 API 网关供前端调用, 这样前端就可以直接访问自己的微服务了.</p> <p><img src="/img/c35e8ce83a3a583b8cd00369d1c92f94-20230731163226-e9lmx6r.png" alt=""></p> <blockquote><p>企业级中台微服务</p></blockquote> <p>企业级的业务流程往往是多个中台微服务一起协作完成的, 那跨中台的微服务如何实现集成呢?</p> <p>企业级中台微服务的集成不能像项目级微服务一样, 在某一个微服务内完成跨微服务的服务组合和编排.</p> <p>可以<strong>在中台微服务之上增加一层</strong>, 看下面这张图, 增加的这一层就位于红色框内, 它的主要职能就是<strong>处理跨中台微服务的服务组合和编排, 以及微服务之间的协调, 它还可以完成前端不同渠道应用的适配</strong>. 如果再将它的业务范围扩大一些, 可以将它做成一个面向不同行业和渠道的服务平台.</p> <p>不妨借用 BFF(服务于前端的后端, Backend for Frontends)这个词, 暂且称它为 BFF 微服务. BFF 微服务与其它微服务存在较大的差异, 就是它没有领域模型, 因此这个微服务内也不会有领域层. <strong>BFF 微服务可以承担应用层和用户接口层的主要职能, 完成各个中台微服务的服务组合和编排, 可以适配不同前端和渠道的要求</strong>.</p> <p><img src="/img/c2b1b6c5a14b7f9c3e5f95d3e6d530ae-20230731163226-bobq9yb.png" alt=""></p> <h6 id="_3-应用和资源的解耦与适配"><a href="#_3-应用和资源的解耦与适配" class="header-anchor">#</a> 3.应用和资源的解耦与适配</h6> <p>传统以数据为中心的设计模式, 应用会对数据库, 缓存, 文件系统等基础资源产生严重依赖.</p> <p>正是由于它们之间的这种强依赖的关系, 我们一旦更换基础资源就会对应用产生很大的影响, 因此需要为<strong>应用和资源解耦</strong>.</p> <p>在微服务架构中, 应用层, 领域层和基础层解耦是通过仓储模式, 采用<strong>依赖倒置</strong>的设计方法来实现的. 在应用设计中, 需要同步考虑和基础资源的代码适配, 那么一旦基础设施资源出现变更(比如换数据库), 就可以屏蔽资源变更对业务代码的影响, 切断业务逻辑对基础资源的依赖, 最终降低资源变更对应用的影响.</p> <h5 id="总结-8"><a href="#总结-8" class="header-anchor">#</a> 总结</h5> <p>今天详细讲解了整洁架构和六边形架构, 并对包括 DDD 分层架构在内的三种微服务架构模进行对比分析, 总结出了它们的共同特征, 并从共性出发, 梳理出了中台建模和微服务架构设计的几个要点, 后面还会有更加详细的有关设计落地的讲述.</p> <p>那从今天的内容中不难看出: DDD 分层架构, 整洁架构, 六边形架构都是<mark><strong>以领域模型为核心, 实行分层架构, 内部核心业务逻辑与外部应用, 资源隔离并解耦</strong></mark>. 请务必记好这个设计思想, 今后会有大用处.</p> <h4 id="_09-中台-数字转型后到底应该共享什么"><a href="#_09-中台-数字转型后到底应该共享什么" class="header-anchor">#</a> 09-中台:数字转型后到底应该共享什么?</h4> <p>在上一讲了解了分层架构的设计思想, 并提到了这种设计思想对中台建设十分有利, 今天就来讲一讲中台.</p> <p>中台是数字化转型的一个热门话题. 继阿里提出中台概念后, 很多人又提出了各种各样的中台. 今天主要讨论<strong>业务中台和数据中台</strong>. 作为企业数字化中台转型的整体, 我也会顺带聊一聊前台和后台的一些设计思路.</p> <p>不少企业其实在很多年前就有了建大平台的实践经验, 那在中台被热议时, 我相信你一定听过很多质疑声. 比如, 有人说: &quot;中台就是个怪名词, 它不就是已经做了好多年的平台吗?&quot; 确实, 中台源于平台, 但它的<strong>战略高度</strong>要比平台高很多.</p> <p>学完这一讲, 你就会清楚地知道<strong>平台与中台的差异在什么地方? 中台到底是什么? 传统企业的中台建设方式是否应该和阿里一样</strong>...</p> <h5 id="平台到底是不是中台"><a href="#平台到底是不是中台" class="header-anchor">#</a> 平台到底是不是中台?</h5> <p>阿里提出中台战略后, 很多企业开始拿着自己的系统与阿里的中台对标. 有的企业在十多年前就完成了大一统的集中式系统拆分, 实现了从传统大单体应用向大平台的演进, 他们<strong>将公共能力和核心能力分开建设, 解决了公共模块重复投入和重复建设的问题</strong>.</p> <p>那这是不是阿里所说的中台呢? 在回答这个问题之前, 不妨先了解一下阿里的中台到底是什么样的.</p> <p>阿里业务中台的前身是共享平台, 而原来的共享平台更多的被当作资源团队, 他们承接各业务方的需求, 并为业务方在基础服务上做定制开发. <strong>阿里业务中台的目标是把核心服务链路(会员, 商品, 交易, 营销, 店铺, 资金结算等)整体当作一个平台产品来做, 为前端业务提供的是业务解决方案, 而不是彼此独立的系统</strong>.</p> <p>下面分析一下传统企业大平台战略和阿里中台战略的差异.</p> <p>平台只是将部分通用的公共能力独立为共享平台. 虽然可以通过 API 或者数据对外提供公共共享服务, 解决系统重复建设的问题, 但这类<strong>平台并没有和企业内的其它平台或应用</strong>, 实现页面, 业务流程和数据从前端到后端的全面融合, 并且没有将核心业务服务链路作为一个整体方案考虑, 各平台仍然是分离且独立的.</p> <p><strong>平台解决了公共能力复用的问题</strong>, 但离中台的目标显然还有一段差距!</p> <h5 id="中台到底是什么"><a href="#中台到底是什么" class="header-anchor">#</a> 中台到底是什么?</h5> <p>&quot;一千个读者就有一千个哈姆雷特&quot;, 这句话形容技术圈对中台的定义再合适不过了, 说法很多.</p> <p>先看一下阿里自己人对中台的定义: &quot;中台是一个基础的理念和架构, 我们要把所有的基础服务用中台的思路建设, 进行联通, 共同支持上端的业务. 业务中台更多的是支持在线业务, 数据中台提供了基础数据处理能力和很多的数据产品给所有业务方去用. 业务中台, 数据中台, 算法中台等等一起提供对上层业务的支撑.&quot;</p> <p>再看一下思特沃克对中台的定义: &quot;<strong>中台是企业级能力复用平台</strong>.&quot;</p> <p>综上, 可以提炼出几个关于中台的关键词: 共享, 联通, 融合和创新. 联通是前台以及中台之间的联通, 融合是前台流程和数据的融合, 并以共享的方式支持前端一线业务的发展和创新.</p> <p>我认为, 中台首先体现的是一种企业级的能力, 它提供的是<strong>一套企业级的整体解决方案, 解决小到企业, 集团, 大到生态圈的能力共享, 联通和融合问题, 支持业务和商业模式创新</strong>. 通过平台联通和数据融合为用户提供一致的体验, 更敏捷地支撑前台一线业务.</p> <p>中台来源于平台, 但中台和平台相比, 它更多体现的是一种理念的转变, 它主要体现在这三个关键能力上: <strong>对前台业务的快速响应能力; 企业级复用能力; 从前台, 中台到后台的设计, 研发, 页面操作, 流程服务和数据的无缝联通, 融合能力</strong>.</p> <p>其中最关键的是快速响应能力和企业级的无缝联通和融合能力, 尤其是对于跨业经营的超大型企业来说至关重要.</p> <h5 id="数字化转型中台应该共享什么"><a href="#数字化转型中台应该共享什么" class="header-anchor">#</a> 数字化转型中台应该共享什么?</h5> <p>相对互联网企业而言, 传统企业的渠道应用更多样化, 有面向内部人员的门店类应用, 面向外部用户的互联网电商以及移动 APP 类应用. 这些应用面向的用户和场景可能不同, 但其功能类似, 基本涵盖了核心业务能力. 此外, 传统企业也会将部分核心应用的页面或 API 服务能力开放给生态圈第三方, 相互借力发展.</p> <p>为了适应不同业务和渠道的发展, 过去很多企业的做法是开发很多独立的应用或 APP. 但由于 IT 系统建设初期并没有企业级的整体规划, 平台之间融合不好, 就导致了用户体验不好, 最关键的是用户并不想装那么多 APP.</p> <p>为了提升用户体验, 实现统一运营, 很多企业开始缩减 APP 的数量, 开始通过一个 APP 集成企业内的所有能力, 联通前台所有的核心业务链路.</p> <p>由于传统企业的商业模式和 IT 系统建设发展的历程与互联网企业不是完全一样的, 因此传统企业的中台建设策略与阿里中台战略也应该有所差异, 需要共享的内容也不一样.</p> <p><img src="/img/9e30e106780a0ca24ac0fbdd7d172c92-20230731163226-hln66hi.png" alt=""></p> <p>由于渠道多样化, 传统企业不仅要将通用能力中台化, 以实现通用能力的沉淀, 共享和复用, 这里的通用能力对应 DDD 的通用域或支撑域; 传统企业还需要将核心能力中台化, 以满足不同渠道的核心业务能力共享和复用的需求, 避免传统核心和互联网不同渠道应用出现 &quot;后端双核心, 前端两张皮&quot; 的问题, 这里的核心能力对应 DDD 的核心域.</p> <p>这就属于业务中台的范畴了, 我们需要解决<strong>核心业务链路的联通和不同渠道服务共享的问题</strong>. 除此之外, 还需要解决系统微服务拆分后的数据孤岛, 数据融合和业务创新等问题, 这就属于数据中台的范畴了, 尤其是当采用分布式架构以后, 就更应该关注微服务拆分后的数据融合和共享问题了.</p> <p>综上, 在中台设计和规划时, 需要整体考虑企业内前台, 中台以及后台应用的协同, 实现不同渠道应用的前端页面, 流程和服务的共享, 还有核心业务链路的联通以及前台流程和数据的融合, 共享, 支持业务和商业模式的创新.</p> <h5 id="如何实现前中后台的协同"><a href="#如何实现前中后台的协同" class="header-anchor">#</a> 如何实现前中后台的协同?</h5> <p>企业级能力往往是前中后台协同作战能力的体现.</p> <p>如果把业务中台比作陆军, 火箭军和空军等专业军种的话, 它主要发挥战术专业能力. 前台就是作战部队, 它需要根据前线的战场需求, 对业务中台的能力进行调度, 实现能力融合和效率最大化. 而数据中台就是信息情报中心和联合作战总指挥部, 它能够汇集各种数据, 完成分析, 制定战略和战术计划. 后台就是后勤部队, 提供技术支持. 下面分别来说说.</p> <h6 id="_1-前台"><a href="#_1-前台" class="header-anchor">#</a> 1.前台</h6> <p>传统企业的早期系统有不少是<strong>基于业务领域或组织架构</strong>来建设的, 每个系统都有自己的前端, 相互独立, 用户操作是竖井式, 需要登录多个系统才能完成完整的业务流程.</p> <p><img src="/img/a9f985fe21e2c2d758ecd3494f4c5b47-20230731163226-kz0v3wt.png" alt=""></p> <p>中台后的前台建设要有一套综合考虑业务边界, 流程和平台的整体解决方案, 以实现各不同中台前端操作, 流程和界面的联通, 融合. 不管后端有多少个中台, 前端用户感受到的就是只有一个前台.</p> <p><img src="/img/05f2cca7aa5cec656e84177c444f1077-20230731163226-1s1xfvu.png" alt=""></p> <p>在前台设计中可以借鉴微前端的设计思想, 在企业内不仅实现前端解耦和复用, 还可以根据核心链路和业务流程, 通过对微前端页面的动态组合和流程编排, 实现前台业务的融合.</p> <p>前端页面可以很自然地融合到不同的终端和渠道应用核心业务链路中, 实现前端页面, 流程和功能复用.</p> <h6 id="_2-中台"><a href="#_2-中台" class="header-anchor">#</a> 2.中台</h6> <p>传统企业的核心业务大多是基于集中式架构开发的, 而单体系统存在扩展性和弹性伸缩能力差的问题, 因此无法适应忽高忽低的互联网业务场景. 而数据类应用也多数通过 ETL 工具抽取数据实现数据建模, 统计和报表分析功能, 但由于数据时效和融合能力不够, 再加上传统数据类应用本来就不是为前端而生的, 因此难以快速响应前端一线业务.</p> <p>业务中台的建设可采用领域驱动设计方法, 通过领域建模, 将可复用的公共能力从各个单体剥离, 沉淀并组合, 采用微服务架构模式, 建设成为可共享的通用能力中台.</p> <p>同样的, 可以将核心能力用微服务架构模式, 建设成为可面向不同渠道和场景的可复用的核心能力中台. 业务中台向前台, 第三方和其它中台提供 API 服务, 实现通用能力和核心能力的复用.</p> <p><img src="/img/9f31bb6e87231ceb3510a7e2ca71973a-20230731163226-pmuupf1.png" alt=""></p> <p>但需要记住这一点: 在将传统集中式单体按业务职责和能力细分为微服务, 建设中台的过程中, 会产生越来越多的独立部署的微服务. 这样做虽然提升了应用弹性和高可用能力, <strong>但由于微服务的物理隔离, 原来一些系统内的调用会变成跨微服务调用, 再加上前后端分离, 微服务拆分会导致数据进一步分离, 增加企业级应用集成的难度</strong>.</p> <p>如果没有合适的设计和指导思想, 处理不好前台, 中台和后台的关系, 将会进一步加剧前台流程和数据的孤岛化, 碎片化.</p> <p>**数据中台的主要目标是打通数据孤岛, 实现业务融合和创新, 包括三大主要职能: **</p> <ol><li>一是完成<strong>企业全域数据的采集与存储</strong>, 实现各不同业务类别中台数据的汇总和集中管理.</li> <li>二是<strong>按照标准的数据规范或数据模型, 将数据按照不同主题域或场景进行加工和处理</strong>, 形成面向不同主题和场景的数据应用, 比如客户视图, 代理人视图, 渠道视图, 机构视图等不同数据体系.</li> <li>三是建立业务需求驱动的数据体系, 基于各个维度的数据, 深度萃取数据价值, 支持业务和商业模式的创新.</li></ol> <p><strong>相应的, 数据中台的建设就可分为三步走</strong>:</p> <ol><li>第一步实现各中台业务数据的汇集, 解决数据孤岛和初级数据共享问题.</li> <li>第二步实现企业级实时或非实时全维度数据的深度融合, 加工和共享.</li> <li>第三步萃取数据价值, 支持业务创新, 加速从数据转换为业务价值的过程.</li></ol> <p>数据中台不仅限于分析型场景, 也适用于交易型场景. 它可以建立在数据仓库或数据平台之上, 将数据服务化之后提供给业务系统. 基于数据库日志捕获的技术, 使数据的时效性大大提升, 这样就可以为交易型场景提供很好的支撑.</p> <p>综上, 数据中台主要完成数据的融合和加工, 萃取数据业务价值, 支持业务创新, 对外提供数据共享服务.</p> <h6 id="_3-后台"><a href="#_3-后台" class="header-anchor">#</a> 3.后台</h6> <p>很多人提到中台时自然会问: &quot;既然有前台和中台, 那是否有后台, 后台的职责又是什么?&quot;</p> <p>来看一下阿里对前台, 中台和后台的定位.</p> <p>前台主要面向客户以及终端销售者, 实现营销推广以及交易转化; 中台主要面向运营人员, 完成运营支撑; <strong>后台主要面向后台管理人员, 实现流程审核, 内部管理以及后勤支撑, 比如采购, 人力, 财务和 OA 等系统</strong>.</p> <p>那对于后台, 为了实现内部的管理要求, 很多人习惯性将这些管理要求嵌入到核心业务流程中. 而一般来说这类内控管理需求对权限, 管控规则和流程等要求都比较高, 但是大部分管理人员只是参与了某个局部业务环节的审核. 这类复杂的管理需求, 会凭空增加不同渠道应用前台界面和核心流程的融合难度以及软件开发的复杂度.</p> <p>在设计流程审核和管理类功能的时候, 可以考虑按角色或岗位进行功能聚合, 将复杂的管理需求从通用的核心业务链路中剥离, 参考小程序的建设模式, 通过特定程序入口嵌入前台 APP 或应用中.</p> <p>管理需求从前台核心业务链路剥离后, 前台应用将具有更好的通用性, 它可以更加容易地实现各渠道前台界面和流程的融合. 一个前台应用或 APP 可以无差别地同时面向外部互联网用户和内部业务人员, 从而促进传统渠道与互联网渠道应用前台的融合.</p> <h5 id="总结-9"><a href="#总结-9" class="header-anchor">#</a> 总结</h5> <p>今天主要讨论了中台建设的一些思路. 企业的中台转型不只是中台的工作, 需要整体考虑前台, 中台和后台的协同, 共享, 联通和融合.</p> <p>前台通过页面和流程共享实现不同渠道应用之间的前台融合, 中台通过 API 实现服务共享. 而前台, 业务中台和数据中台的融合可以实现传统应用与互联网应用的融合, 从而解决 &quot;后端双核心, 前端两张皮&quot; 的问题. 能力复用了, 前台流程和数据融合了, 才能更好地支持业务的融合和商业模式的创新.</p> <h4 id="_10-ddd-中台和微服务-它们是如何协作的"><a href="#_10-ddd-中台和微服务-它们是如何协作的" class="header-anchor">#</a> 10-DDD,中台和微服务:它们是如何协作的?</h4> <p>今天来聊聊 DDD, 中台和微服务的关系.</p> <p>DDD 和微服务来源于西方, 而中台诞生于中国的阿里巴巴. DDD 在二十多年前提出后一直默默前行, 中台和微服务的理念近几年才出现, 提出后就非常火爆. 这三者看似风马牛不相及, 实则缘分匪浅. <strong>中台是抽象出来的业务模型, 微服务是业务模型的系统实现, DDD 作为方法论可以同时指导中台业务建模和微服务建设, 三者相辅相成, 完美结合</strong>.</p> <p>你可能会问: 凭什么 DDD 可以指导中台和微服务建设, 究竟起到了什么作用呢?</p> <p>DDD 有两把利器, 那就是它的战略设计和战术设计方法.</p> <p>中台在企业架构上更多偏向业务模型, 形成中台的过程实际上也是业务领域不断细分的过程. 在这个过程中会将同类通用的业务能力进行聚合和业务重构, 再根据限界上下文和业务内聚的原则建立领域模型. 而 DDD 的战略设计最擅长的就是<strong>领域建模</strong>.</p> <p>那在中台完成领域建模后, 就需要通过微服务来完成系统建设. 此时, DDD 的战术设计又恰好可以与微服务的设计完美结合. 可以说, 中台和微服务正是 DDD 实战的最佳场景.</p> <h5 id="ddd的本质"><a href="#ddd的本质" class="header-anchor">#</a> DDD的本质</h5> <p>先简单回顾一下 DDD 领域, 子域, 核心域, 通用域和支撑域等概念, 后面会用到.</p> <p>在研究和解决业务问题时, <strong>DDD 会按照一定的规则将业务领域进行细分, 领域细分到一定的程度后, DDD 会将问题范围限定在特定的边界内, 并在这个边界内建立领域模型, 进而用代码实现该领域模型, 解决相应的业务问题</strong>. 领域可分解为子域, 子域可继续分为子子域, 一直到你认为适合建立领域模型为止.</p> <p>子域还会根据自身重要性和功能属性划分为三类子域, 它们分别是<strong>核心域, 支撑域和通用域</strong>.</p> <p><img src="/img/13014f603eb2b42fafab57fcf8c61782-20230731163226-zo9diwj.png" alt=""></p> <p>一起看下上面这张图, 我选择了保险的几个重要领域, 进行了高阶的领域划分. 当然每个企业的领域定位和职责会有些不一样, 那在核心域的划分上肯定会有一定差异. 因此, 当你去做领域划分的时候, 请务必结合企业战略, 这恰恰也体现了 DDD 领域建模的重要性.</p> <p>通过领域划分和进一步的子域划分, 就可以区分不同子域在企业内的功能属性和重要性, 进而采取不同的资源投入和建设策略, 这在企业 IT 系统的建设过程中十分重要, 并且这样的划分还可以帮助企业进行中台设计.</p> <h5 id="中台的本质"><a href="#中台的本质" class="header-anchor">#</a> 中台的本质</h5> <p>中台来源于阿里的中台战略. 2015 年年底, 阿里巴巴集团对外宣布全面启动中台战略, 构建符合数字时代的更具创新性, 灵活性的 &quot;大中台, 小前台&quot; 组织机制和业务机制, 即作为前台的一线业务会更敏捷, 更快速地适应瞬息万变的市场, 而中台将集合整个集团的运营数据能力, 产品技术能力, 对各前台业务形成强力支撑.</p> <p><strong>中台的本质其实就是提炼各个业务板块的共同需求, 进行业务和系统抽象, 形成通用的可复用的业务模型, 打造成组件化产品, 供前台部门使用</strong>. 前台要做什么业务, 需要什么资源, 可以直接找中台, 不需要每次都去改动自己的底层.</p> <h5 id="ddd-中台和微服务的协作模式"><a href="#ddd-中台和微服务的协作模式" class="header-anchor">#</a> DDD,中台和微服务的协作模式</h5> <p>前面已经说过了传统企业和阿里中台战略的差异, 那实际上更多的企业还是会聚焦在传统企业中台建设的模式, 也就是<strong>将通用能力与核心能力全部中台化, 以满足不同渠道核心业务能力的复用</strong>, 那么接下来就还是把重点放在传统企业上.</p> <p>传统企业可以将需要共享的公共能力进行领域建模, 建设可共享的<strong>通用中台</strong>. 除此之外, 传统企业还会将核心能力进行领域建模, 建设面向不同渠道的可复用的<strong>核心中台</strong>.</p> <p>而这里的通用中台和核心中台都属于上一讲讲到的<strong>业务中台</strong>的范畴.</p> <p>DDD 的子域分为核心域, 通用域和支撑域. 划分这几个子域的主要目的是为了确定战略资源的投入, 一般来说战略投入的重点是核心域, 因此后面就可以暂时不严格区分支撑域和通用域了.</p> <p>领域, 中台以及微服务虽然属于不同层面的东西, 但还是可以将他们分解对照, 整理出来它们之间的关系. 下面这张图是从 DDD 领域建模和中台建设这两个不同的视角对同一个企业的业务架构进行分析.</p> <p><img src="/img/cc04782137a165eaee74afb84051a63d-20230731163226-jsb8enu.png" alt=""></p> <p><strong>如果将企业内整个业务域作为一个问题域的话, 企业内的所有业务就是一个领域</strong>. 在进行领域细分时, 从 DDD 视角来看, 子域可分为核心域, 通用域和支撑域. 从中台建设的视角来看, 业务域细分后的业务中台, 可分为核心中台和通用中台.</p> <p>从领域功能属性和重要性对照来看, 通用中台对应 DDD 的通用域和支撑域, 核心中台对应 DDD 的核心域. 从领域的功能范围来看, 子域与中台是一致的. 领域模型所在的限界上下文对应微服务. 建立了这个映射关系, 就可以用 DDD 来进行中台业务建模了.</p> <p>这里还是以保险领域为例. 保险域的业务中台分为两类: 第一类是提供<strong>保险核心业务能力</strong>的核心中台(比如营销, 承保和理赔等业务); 第二类是<strong>支撑核心业务流程完成保险全流程的通用中台</strong>(比如订单, 支付, 客户和用户等).</p> <p>这里要提醒一下: 根据 DDD 首先要建立通用语言的原则, 在将 DDD 的方法引入中台设计时, 要先建立中台和 DDD 的通用语言. 这里的子域与中台是一致的, 那就可以将子域统一为中台.</p> <p>中台通过事件风暴可以进一步细分, 最终完成业务领域建模. 中台业务领域的功能不同, 限界上下文的数量和大小就会不一样, 领域模型也会不一样. 当完成业务建模后, 就可以采用 DDD 战术设计, 设计出聚合, 实体, 领域事件, 领域服务以及应用服务等领域对象, 再利用分层架构模型完成微服务的设计.</p> <p>以上就是 DDD, 中台和微服务在应用过程中的协作模式.</p> <h5 id="中台如何建模"><a href="#中台如何建模" class="header-anchor">#</a> 中台如何建模?</h5> <p>看完了三者的协作模式, 就顺着上面的话题, 接着来聊聊中台如何建模.</p> <p><strong>中台业务抽象的过程就是业务建模的过程</strong>, 对应 DDD 的战略设计. 系统抽象的过程就是微服务的建设过程, 对应 DDD 的战术设计. 下面就结合 DDD 领域建模的方法, 讲一下中台业务建模的过程.</p> <p><strong>第一步:</strong>  按照业务流程(通常适用于核心域)或者功能属性, 集合(通常适用于通用域或支撑域), <strong>将业务域细分为多个中台, 再根据功能属性或重要性归类到核心中台或通用中台</strong>. 核心中台设计时要考虑核心竞争力, 通用中台要站在企业高度考虑共享和复用能力.</p> <p><strong>第二步:</strong>  选取中台, 根据用例, 业务场景或用户旅程完成事件风暴, 找出实体, 聚合和限界上下文. 依次进行领域分解, 建立领域模型. 由于不同中台独立建模, 某些领域对象或功能可能会重复出现在其它领域模型中, 也有可能本该是同一个聚合的领域对象或功能, 却分散在其它的中台里, 这样会导致领域模型不完整或者业务不内聚. 这里先不要着急, 这一步只需要<strong>初步确定主领域模型</strong>就可以了, 在第三步中还会提炼并重组这些领域对象.</p> <p>**第三步: **以主领域模型为基础, 扫描其它中台领域模型, 检查并确定是否存在重复或者需要重组的领域对象, 功能, 提炼并重构主领域模型, 完成最终的领域模型设计.</p> <p>**第四步: **选择其它主领域模型重复第三步, 直到所有主领域模型完成比对和重构.</p> <p>**第五步: **基于领域模型完成微服务设计, 完成系统落地.</p> <p><img src="/img/ebf9a1a05f831f0c3ddfa91cdce62cb8-20230731163226-at9pylo.png" alt=""></p> <p>结合上面这张图, 可以大致了解到 DDD 中台设计的过程. DDD 战略设计包括上述的第一步到第四步, 主要为: <strong>业务域分解为中台, 对中台归类, 完成领域建模, 建立中台业务模型</strong>. DDD 战术设计是第五步, 领域模型映射为微服务, 完成中台建设.</p> <p><img src="/img/a9e0757d63c3ca6f1d721ab76ce65850-20230731163226-jzct9kd.png" alt=""></p> <p>那么如果还是以保险领域为例的话, 完成领域建模后, 里面的数据就可以填上了. 这里选取了通用中台的用户, 客户和订单三个中台来做示例. 客户中台提炼出了两个领域模型: <strong>客户信息和客户视图模型</strong>. 用户中台提炼出了三个领域模型: <strong>用户管理, 登录认证和权限模型</strong>. 订单中台提炼出了<strong>订单模型</strong>.</p> <p>这就是中台建模的全流程, 当然看似简单的背后, 若是遇上复杂的业务总会出现各种各样的问题, 不然应用起来也不会有那么多的困难.</p> <h5 id="总结-10"><a href="#总结-10" class="header-anchor">#</a> 总结</h5> <p>今天主要讨论了传统企业中台建设的一些思路, 梳理了 DDD, 中台和微服务的关系. DDD 的战略设计可用于中台业务建模, 战术设计可指导中台微服务设计.</p> <p>另外, 这一讲只是开一个头, 在下一讲中还会以一个传统核心业务的中台建设案例, 详细讲解中台的设计过程.</p> <h3 id="实战篇-2"><a href="#实战篇-2" class="header-anchor">#</a> 实战篇</h3> <h4 id="_11-ddd实践-如何用ddd重构中台业务模型"><a href="#_11-ddd实践-如何用ddd重构中台业务模型" class="header-anchor">#</a> 11-DDD实践:如何用DDD重构中台业务模型?</h4> <p>阿里巴巴过去带动了传统企业向互联网电商转型. 而如今又到了一个新的历史时期, 在阿里巴巴提出中台战略后, 很多企业又紧跟它的步伐, 高举中台大旗, 轰轰烈烈地开始了数字化转型之路.</p> <p>那么传统企业在中台转型时, 该如何从错综复杂的业务中构建中台业务模型呢? 今天就用一个<strong>传统企业中台建模的案例</strong>, 一起用 DDD 的设计思想来构建中台业务模型.</p> <h5 id="传统企业应用分析"><a href="#传统企业应用分析" class="header-anchor">#</a> 传统企业应用分析</h5> <p>互联网电商平台和传统核心应用, 两者面向的渠道和客户不一样, 但销售的产品却很相似, 它们之间的业务模型既有相同的地方, 又有不同的地方.</p> <p>现在拿保险行业的互联网电商和传统核心应用来做个对比分析. 看一下下面这张图, 这两者在业务功能上会有很多相似和差异, 这种相似和差异主要体现在四个方面.</p> <p><img src="/img/2892e27e471fc92faa26fcde88b8014a-20230731163226-1c5gpb7.png" alt=""></p> <p><strong>1.核心能力的重复建设.</strong>  由于销售同质保险产品, 二者在核心业务流程和功能上必然相似, 因此在核心业务能力上存在功能重叠是不可避免的. 传统保险核心应用有报价, 投保, 核保和出单功能, 同样在互联网电商平台也有. 这就是核心能力的重复建设.</p> <p><strong>2.通用能力的重复建设.</strong>  传统核心应用的通用平台大而全, 通常会比较重. 而互联网电商平台离不开这些通用能力的支撑, 但为了保持敏捷性, 一般会自己建设缩小版的通用功能, 比如用户, 客户等. 这是通用能力的重复建设.</p> <p><strong>3.业务职能的分离建设.</strong>  有一类业务功能, 在互联网电商平台中建设了一部分, 在传统核心应用中也建设了一部分, 二者功能不重叠而且还互补, 组合在一起是一个完整的业务职能. 比如<strong>缴费</strong>功能, 互联网电商平台主要面向个人客户, 于是采用了支付宝和微信支付的方式. 而传统核心应用主要是柜台操作, 仍在采用移动 POS 机的缴费方式. 二者都是缴费, 为了保证业务模型的完整性, 在构建中台业务模型时, 可以考虑将这两部分模型重组为一个完整的业务模型.</p> <p><strong>4.互联网电商平台和传统核心功能前后完全独立建设.</strong>  传统核心应用主要面向柜台, 不需要互联网电商平台的在线客户, 话务, 订单和购物车等功能. 而互联网电商平台主要面向个人客户, 它不需要后端比较重的再保, 佣金, 打印等功能. 在构建中台业务模型时, 对这种情况应区别对待, 将面向后端业务管理的应用沉淀到后台, 将前端能力构建为面向互联网渠道的通用中台, 比如订单等.</p> <h5 id="如何避免重复造轮子"><a href="#如何避免重复造轮子" class="header-anchor">#</a> 如何避免重复造轮子?</h5> <p>要避免重复建设, 就要理解中台的理念和思想. 前面说了 &quot;<strong>中台是企业级能力复用平台</strong>&quot;, &quot;<strong>复用</strong>&quot; 用白话说就是重复使用, 就是要避免重复造轮子的事情.</p> <p>中台的设计思想与 &quot;高内聚, 低耦合&quot; 的设计原则是高度一致的. <strong>高内聚是把相关的业务行为聚集在一起, 把不相关的行为放在其它地方, 如果你要修改某个业务行为, 只需要修改一处</strong>. 对了! 中台就是要这样做, 按照 &quot;高内聚, 松耦合&quot; 的原则, 实现企业级的能力复用!</p> <p>那如果遇到了重复造轮子的情况, 应该怎么处理? 可以将重复的需要共享的通用能力, 核心能力沉淀到中台, 将分离的业务能力重组为完整的业务板块, 构建可复用的中台业务模型. 前端个性能力归前端, 后端管理能力归后台. 建立前, 中, 后台边界清晰, 融合协作的企业级可复用的业务模型.</p> <h5 id="如何构建中台业务模型"><a href="#如何构建中台业务模型" class="header-anchor">#</a> 如何构建中台业务模型?</h5> <p>可以用 DDD 领域建模的方法来构建中台业务模型. 可以选择两种建模策略: <strong>自顶向下和自底向上的策略</strong>. 具体采用哪种策略, 需要结合公司的具体情况来分析, 下面就来介绍一下这两种策略.</p> <h6 id="_1-自顶向下的策略"><a href="#_1-自顶向下的策略" class="header-anchor">#</a> 1.自顶向下的策略</h6> <p>第一种策略是自顶向下. 这种策略是先做顶层设计, 从最高领域逐级分解为中台, 分别建立领域模型, 根据业务属性分为通用中台或核心中台. 领域建模过程主要基于业务现状, 暂时不考虑系统现状. 自顶向下的策略适用于全新的应用系统建设, 或旧系统推倒重建的情况.</p> <p>由于这种策略不必受限于现有系统, 可以用 DDD 领域逐级分解的领域建模方法. 从下面这张图可以看出它的主要步骤: <strong>第一步是将领域分解为子域, 子域可以分为核心域, 通用域和支撑域; 第二步是对子域建模, 划分领域边界, 建立领域模型和限界上下文; 第三步则是根据限界上下文进行微服务设计</strong>.</p> <p><img src="/img/659135e510640b33e1dad93a0e3bce06-20230731163226-5c9ci7a.png" alt=""></p> <h6 id="_2-自底向上的策略"><a href="#_2-自底向上的策略" class="header-anchor">#</a> 2.自底向上的策略</h6> <p>第二种策略是自底向上. 这种策略是<strong>基于业务和系统现状完成领域建模</strong>. 首先分别完成系统所在业务域的领域建模; 然后对齐业务域, 找出具有同类或相似业务功能的领域模型, 对比分析领域模型的差异, 重组领域对象, 重构领域模型. 这个过程会<strong>沉淀公共和复用的业务能力, 会将分散的业务模型整合</strong>. 自底向上策略<mark><strong>适用于遗留系统业务模型的演进式重构</strong></mark>.</p> <p>下面以互联网电商和传统核心应用的几个典型业务域为例, 带你了解具体如何采用<strong>自底向上的策略</strong>来构建中台业务模型, 主要分为这样三个步骤.</p> <blockquote><p>第一步: 锁定系统所在业务域, 构建领域模型.</p></blockquote> <p>锁定系统所在的业务域, 采用事件风暴, 找出领域对象, 构建聚合, 划分限界上下文, 建立领域模型. 下面这张图选取了传统核心应用的用户, 客户, 传统收付和承保四个业务域以及互联网电商业务域, 共计五个业务域来完成领域建模.</p> <p><img src="/img/35a403c9bbee7993dfd4ff6c517a9296-20230731163226-pa0957x.png" alt=""></p> <p>从上面这张图中, 可以看到传统核心共构建了<strong>八个领域模型</strong>. 其中用户域构建了用户认证和权限两个领域模型, 客户域构建了个人和团体两个领域模型, 传统收付构建了 POS 刷卡领域模型, 承保域构建了定报价, 投保和保单管理三个领域模型. 互联网电商构建了报价, 投保, 订单, 客户, 用户认证和移动收付六个领域模型.</p> <p>在这些领域模型的清单里, 可以看到二者之间有很多<strong>名称相似的领域模型</strong>. 深入分析后你会发现, 这些<strong>名称相似的领域模型存在业务能力重复, 或者业务职能分散(比如移动支付和传统支付)的问题</strong>. 那在构建中台业务模型时, 就需要重点关注它们, <strong>将这些不同领域模型中重复的业务能力沉淀到中台业务模型中, 将分散的领域模型整合到统一的中台业务模型中, 对外提供统一的共享的中台服务</strong>.</p> <blockquote><p>第二步: 对齐业务域, 构建中台业务模型.</p></blockquote> <p>在下面这张图里, 可以看到右侧的传统核心领域模型明显多于左侧的互联网电商, 那是不是就可以得出一个初步的结论: 传统核心面向企业内大部分应用, 大而全, 领域模型相对完备, 而互联网电商面向单一渠道, 领域模型相对单一.</p> <p>这个结论也指明了一个方向: 首先可以<strong>将传统核心的领域模型作为主领域模型, 将互联网电商领域模型作为辅助模型来构建中台业务模型</strong>. 然后再将互联网电商中重复的能力沉淀到传统核心的领域模型中, 只保留自己的个性能力, 比如订单. 中台业务建模时, 既要关注领域模型的完备性, 也要关注不同渠道敏捷响应市场的要求.</p> <p><img src="/img/b0a1f2c5ecfe8076016a272bc4d63cd9-20230731163226-29lhwxc.png" alt=""></p> <p>有了上述这样一个思路, 就可以开始构建中台业务模型了. 从互联网电商和传统核心的领域模型中, 归纳并分离出能覆盖两个域的所有业务子域. 通过分析, 找到了用户, 客户, 承保, 收付和订单五个业务域, 它们是可以用于领域模型对比分析的基准域.</p> <p><strong>下面以客户为例, 来讲一下客户中台业务模型的构建过程</strong>.</p> <p>互联网电商客户主要面向个人客户, 除了有个人客户信息管理功能外, 基于营销目的它还有客户积分功能, 因此它的领域模型有个人和积分两个聚合. 而传统核心客户除了支持个人客户外, 还有单位和组织机构等团体客户, 它有个人和团体两个领域模型. 其中个人领域模型中除了个人客户信息管理功能外, 还有个人客户的评级, 重复客户的归并和客户的统一视图等功能, 因此它的领域模型有个人, 视图, 评级和归并四个聚合.</p> <p>构建多业务域的中台业务模型的过程, 就是找出同一业务域内所有同类业务的领域模型, 对比分析域内领域模型和聚合的差异和共同点, 打破原有的模型, 完成新的中台业务模型重组或归并的过程.</p> <p>将互联网电商和传统核心的领域模型分解后, 找到了五个与个人客户领域相关的聚合, 包括: 个人, 积分, 评级, 归并和视图. 这五个聚合原来分别分散在互联网电商和传统核心的领域模型中, 需要打破原有的领域模型, 进行功能沉淀和聚合的重组, 重新找出这些聚合的限界上下文, 重构领域模型.</p> <p>最终个人客户的领域模型重构为: 个人, 归并和视图三个聚合重构为个人领域模型(客户信息管理), 评级和积分两个聚合重构为评级积分领域模型(面向个人客户). 到这里就完成了个人客户领域模型的构建了.</p> <p>好像还漏掉点什么东西呢? 对了, 还有团队客户领域模型! 其实团体客户很简单. 由于它只在传统核心中出现, 将它在传统核心中的领域模型直接拿过来用就行了.</p> <p>至此就完成了客户中台业务模型的构建了, 客户中台构建了个人, 团体和评级积分三个领域模型.</p> <p>通过客户中台业务模型的构建, 你是否 get 到构建中台业务模型的要点了呢? 总结成一句话就是: &quot;<strong>分域建模型, 找准基准域, 划定上下文, 聚合重归类</strong>.&quot;</p> <p>其它业务域其实也是一样的过程, 在这里就不一一讲述了. 完成后可以对照下面这张图看一下, 这就是其它业务域重构后的中台业务模型.</p> <p><img src="/img/848ade92e8e83052fd4381a4e220956c-20230731163226-waxqa7x.png" alt=""></p> <blockquote><p>第三步: 中台归类, 根据领域模型设计微服务.</p></blockquote> <p>完成中台业务建模后, 就有了下面这张图. 从这张图中可以看到总共构建了多少个中台, 中台下面有哪些领域模型, 哪些中台是<strong>通用中台</strong>, 哪些中台是<strong>核心中台</strong>, 中台的基本信息等等, 都一目了然. 根据中台下的领域模型就可以设计微服务了.</p> <p><img src="/img/9728baaa47c4490fa33ea11081a0eee9-20230731163226-ne94ogr.png" alt=""></p> <h5 id="重构过程中的领域对象"><a href="#重构过程中的领域对象" class="header-anchor">#</a> 重构过程中的领域对象</h5> <p>上面主要是从<strong>聚合</strong>的角度来描述中台业务模型的重组, 是相对高阶的业务模块的重构. 业务模型重构和聚合重组, 往往会带来领域对象和业务行为的变化. 下面了解一下, 在领域模型重组过程中, 发生在更底层的领域对象的活动.</p> <p>还是以客户为例来讲述. 由于对象过多, 所以只选取了部分领域对象和业务行为.</p> <p>传统核心客户领域模型重构之前, 包含个人, 团体和评级三个聚合, 每个聚合内部都有自己的聚合根, 实体, 方法和领域服务等.</p> <p><img src="/img/112093817708e6ca2278f42a2fd97ae5-20230731163226-thrf3ks.png" alt=""></p> <p>互联网电商客户领域模型重构前包含个人和积分两个聚合, 每个聚合包含了自己的领域对象, 方法和领域服务等.</p> <p><img src="/img/095a929d7a548193952d5d7ab613c4ac-20230731163226-7uurgf0.png" alt=""></p> <p>传统核心和互联网电商客户领域模型重构成客户中台后, 建立了<strong>个人, 团体和评级积分三个领域模型</strong>. 其中个人领域模型有个人聚合, 团体领域模型有团体聚合, 评级积分领域模型有评级和积分两个聚合. 这些领域模型的领域对象来自原来的领域模型, 但积分评级是重组后的领域模型, 它们原来的聚合会带着各自的领域对象, 加入到新的领域模型中.</p> <p>这里还要注意: 部分领域对象可能会根据新的业务要求, 从原来的聚合中分离, 重组到其它聚合. 新领域模型的领域对象, 比如实体, 领域服务等, 在重组后可能还会根据新的业务场景和需求进行代码重构.</p> <p><img src="/img/412def422b8bf40d160fa2a64c7466fa-20230731163226-5d4dup0.png" alt=""></p> <h5 id="总结-11"><a href="#总结-11" class="header-anchor">#</a> 总结</h5> <p>今天一起讨论了传统企业中台数字化转型, 在面对多个不同渠道应用重复建设时, 如何用 DDD 领域建模的思想来构建中台业务模型. 中台业务建模有<strong>自顶向下和自底向上</strong>两种策略, 这两种策略有自己的适用场景, 需要结合自己公司的情况选择合适的策略.</p> <p>其实呢, 中台业务模型的重构过程, 也是微服务架构演进的过程. 业务边界即微服务边界, 业务边界做好了, 微服务的边界自然就会很好.</p> <h4 id="_12-领域建模-如何用事件风暴构建领域模型"><a href="#_12-领域建模-如何用事件风暴构建领域模型" class="header-anchor">#</a> 12-领域建模:如何用事件风暴构建领域模型?</h4> <p>还记得前面说过, 微服务设计为什么要选择 DDD 吗? 其中有一个非常重要的原因, 就是采用 DDD 方法建立的领域模型, 可以<strong>清晰地划分微服务的逻辑边界和物理边界</strong>. 可以说, 在 DDD 的实践中, 好的领域模型直接关乎微服务的设计水平. 因此, 我认为 DDD 的战略设计是比战术设计更为重要的, 也正是这个原因, 我们的内容会更侧重于<strong>战略设计</strong>.</p> <p>那么该采用什么样的方法, 才能从错综复杂的业务领域中分析并构建领域模型呢?</p> <p>它就是我在前面多次提到的<strong>事件风暴</strong>. <strong>事件风暴是一项团队活动, 领域专家与项目团队通过头脑风暴的形式, 罗列出领域中所有的领域事件, 整合之后形成最终的领域事件集合, 然后对每一个事件, 标注出导致该事件的命令, 再为每一个事件标注出命令发起方的角色</strong>. 命令可以是用户发起, 也可以是第三方系统调用或者定时器触发等, 最后对事件进行分类, 整理出实体, 聚合, 聚合根以及限界上下文. 而事件风暴正是 DDD 战略设计中经常使用的一种方法, 它可以快速分析和分解复杂的业务领域, 完成领域建模.</p> <p>那到底怎么做事件风暴呢? 事件风暴需要提前准备些什么? 又如何用事件风暴来构建领域模型呢? 今天就来重点解决这些问题, 深入了解事件风暴的全过程.</p> <h5 id="事件风暴需要准备些什么"><a href="#事件风暴需要准备些什么" class="header-anchor">#</a> 事件风暴需要准备些什么?</h5> <h6 id="_1-事件风暴的参与者"><a href="#_1-事件风暴的参与者" class="header-anchor">#</a> 1.事件风暴的参与者</h6> <p><strong>事件风暴采用工作坊的方式, 将项目团队和领域专家聚集在一起, 通过可视化, 高互动的方式一步一步将领域模型设计出来</strong>. 领域专家是事件风暴中必不可少的核心参与者. 很多公司可能并没有这个角色, 那该寻找什么样的人来担当领域专家呢?</p> <p>领域专家就是对业务或问题域有深刻见解的主题专家, 他们非常了解业务和系统是怎么做的, 同时也深刻理解为什么要这样设计. 如果你的公司里并没有这个角色, 那也没关系, 你可以从业务人员, 需求分析人员, 产品经理或者在这个领域有多年经验的开发人员里, 按照这个标准去选择合适的人选.</p> <p>除了领域专家, 事件风暴的其他参与者可以是 DDD 专家, 架构师, 产品经理, 项目经理, 开发人员和测试人员等项目团队成员.</p> <p>领域建模是统一团队语言的过程, 因此项目团队应尽早地参与到领域建模中, 这样才能高效建立起团队的通用语言. 到了微服务建设时, 领域模型也更容易和系统架构保持一致.</p> <h6 id="_2-事件风暴要准备的材料"><a href="#_2-事件风暴要准备的材料" class="header-anchor">#</a> 2.事件风暴要准备的材料</h6> <p>事件风暴参与者会将自己的想法和意见写在即时贴上, 并将贴纸贴在墙上的合适位置, 我们戏称这个过程是 &quot;刷墙&quot;. 所以即时贴和水笔是必备材料, 另外, 还可以准备一些胶带或者磁扣, 以便贴纸随时能更换位置.</p> <p>值得提醒一下的是, 在这个过程中, 要用不同颜色的贴纸区分领域行为. 如下图, 可以用蓝色表示命令, 用绿色表示实体, 橙色表示领域事件, 黄色表示补充信息等. 补充信息主要用来说明注意事项, 比如外部依赖等. 颜色并不固定, 这只是我的习惯, 团队内统一才是重点.</p> <p><img src="/img/3f2569e0a520042b430af83ae34eeca4-20230731163226-zdynhnx.png" alt=""></p> <h6 id="_3-事件风暴的场地"><a href="#_3-事件风暴的场地" class="header-anchor">#</a> 3.事件风暴的场地</h6> <p>什么样的场地适合做事件风暴呢? 是不是需要跟组织会议一样, 准备会议室, 投影, 还有椅子? 这些都不需要! 你只需要一堵足够长的墙和足够大的空间就可以了. 墙是用来贴纸的, 大空间可以让人四处走动, 方便合作. 撤掉会议桌和椅子的事件风暴, 你会发现参与者们的效率更高.</p> <p>事件风暴的发明者曾经建议要准备八米长的墙, 这样设计就不会受到空间的限制了. 当然, 这个不是必要条件, 看各自的现实条件吧, 不要让思维受限就好.</p> <h6 id="_4-事件风暴分析的关注点"><a href="#_4-事件风暴分析的关注点" class="header-anchor">#</a> 4.事件风暴分析的关注点</h6> <p>在领域建模的过程中, 需要重点关注这类业务的语言和行为. 比如某些业务动作或行为(事件)是否会触发下一个业务动作, 这个动作(事件)的输入和输出是什么? 是谁(实体)发出的什么动作(命令), 触发了这个动作(事件)... 可以从这些暗藏的词汇中, 分析出领域模型中的事件, 命令和实体等领域对象.</p> <h5 id="如何用事件风暴构建领域模型"><a href="#如何用事件风暴构建领域模型" class="header-anchor">#</a> 如何用事件风暴构建领域模型?</h5> <p>领域建模的过程主要包括产品愿景, 业务场景分析, 领域建模和微服务拆分与设计这几个重要阶段. 下面以用户中台为例, 介绍一下<strong>如何用事件风暴构建领域模型.</strong></p> <h6 id="_1-产品愿景"><a href="#_1-产品愿景" class="header-anchor">#</a> 1.产品愿景</h6> <p><strong>产品愿景的主要目的是对产品顶层价值的设计, 使产品目标用户, 核心价值, 差异化竞争点等信息达成一致, 避免产品偏离方向</strong>.</p> <p>产品愿景的参与角色: 领域专家, 业务需求方, 产品经理, 项目经理和开发经理.</p> <p>在建模之前, 项目团队要思考这样两点:</p> <ol><li>用户中台到底能够做什么?</li> <li>它的业务范围, 目标用户, 核心价值和愿景, 与其它同类产品的差异和优势在哪里?</li></ol> <p>这个过程也是明确用户中台建设方向和统一团队思想的过程. 参与者要对每一个点(下图最左侧列的内容)发表意见, 用水笔写在贴纸上, 贴在黄色贴纸的位置. 这个过程会让参与者充分发表意见, 最后会将发散的意见统一为通用语言, 建立如下图的产品愿景墙. 如果你的团队的产品愿景和目标已经很清晰了, 那这个步骤你可以忽略.</p> <p><img src="/img/c1eadf0fe93ad16377dbb3727a52a978-20230731163226-4t8u9a5.png" alt=""></p> <h6 id="_2-业务场景分析"><a href="#_2-业务场景分析" class="header-anchor">#</a> 2.业务场景分析</h6> <p><strong>场景分析是从用户视角出发的, 根据业务流程或用户旅程, 采用用例和场景分析, 探索领域中的典型场景, 找出领域事件, 实体和命令等领域对象, 支撑领域建模</strong>. 事件风暴参与者要尽可能地遍历所有业务细节, 充分发表意见, 不要遗漏业务要点.</p> <p>场景分析的参与角色: 领域专家, 产品经理, 需求分析人员, 架构师, 项目经理, 开发经理和测试经理.</p> <p>用户中台有这样三个典型的业务场景:</p> <ol><li>第一个是<strong>系统和岗位设置</strong>, 设置系统中岗位的菜单权限;</li> <li>第二个是<strong>用户权限配置</strong>, 为用户建立账户和密码, 设置用户岗位;</li> <li>第三个是<strong>用户登录系统和权限校验</strong>, 生成用户登录和操作日志.</li></ol> <p>可以按照业务流程, 一步一步搜寻用户业务流程中的关键领域事件, 比如岗位已创建, 用户已创建等事件. 再找出什么行为会引起这些领域事件, 这些行为可能是一个或若干个命令组合在一起产生的, 比如创建用户时, 第一个命令是从公司 HR 系统中获取用户信息, 第二个命令是根据 HR 的员工信息在用户中台创建用户, 创建完用户后就会产生用户已创建的领域事件. 当然这个领域事件可能会触发下一步的操作, 比如发布到邮件系统通知用户已创建, 但也可能到此就结束了, 需要根据具体情况来分析是否还有下一步的操作.</p> <p>场景分析时会产生很多的命令和领域事件. 我用蓝色来表示命令, 用橙色表示领域事件, 用黄色表示补充信息, 比如用户信息数据来源于 HR 系统的说明.</p> <p><img src="/img/e3a14324bc1b393955824e2d30d2236e-20230731163226-l6cxiqj.png" alt=""></p> <h6 id="_3-领域建模"><a href="#_3-领域建模" class="header-anchor">#</a> 3.领域建模</h6> <p>领域建模时, 我们会<strong>根据场景分析过程中产生的领域对象, 比如命令, 事件等之间关系, 找出产生命令的实体, 分析实体之间的依赖关系组成聚合, 为聚合划定限界上下文, 建立领域模型以及模型之间的依赖</strong>. 领域模型利用限界上下文向上可以指导微服务设计, 通过聚合向下可以指导聚合根, 实体和值对象的设计.</p> <p>领域建模的参与角色: 领域专家, 产品经理, 需求分析人员, 架构师, 项目经理, 开发经理和测试经理.</p> <p>具体可以分为这样三步.</p> <p>第一步: <strong>从命令和事件中提取产生这些行为的实体</strong>. 用绿色贴纸表示实体. 通过分析用户中台的命令和事件等行为数据, 提取了产生这些行为的用户, 账户, 认证票据, 系统, 菜单, 岗位和用户日志七个实体.</p> <p><img src="/img/340ab9e665b180c221d0793a9126153d-20230731163226-kb44p7o.png" alt=""></p> <p>第二步: <strong>根据聚合根的管理性质从七个实体中找出聚合根</strong>, 比如, 用户管理用户相关实体以及值对象, 系统可以管理与系统相关的菜单等实体等, 可以找出用户和系统等聚合根. 然后根据业务依赖和业务内聚原则, 将聚合根以及它关联的实体和值对象组合为聚合, 比如系统和菜单实体可以组合为 &quot;系统功能&quot; 聚合. 按照上述方法, 用户中台就有了系统功能, 岗位, 用户信息, 用户日志, 账户和认证票据六个聚合.</p> <p>第三步: <strong>划定限界上下文, 根据上下文语义将聚合归类</strong>. 根据用户域的上下文语境, 用户基本信息和用户日志信息这两个聚合共同构成用户信息域, 分别管理用户基本信息, 用户登录和操作日志. 认证票据和账户这两个聚合共同构成认证域, 分别实现不同方式的登录和认证. 系统功能和岗位这两个聚合共同构成权限域, 分别实现系统和菜单管理以及系统的岗位配置. 根据业务边界, 可以将用户中台划分为三个限界上下文: 用户信息, 认证和权限.</p> <p><img src="/img/b93df95936cbef9a59de2d20fbfc5f10-20230731163226-udct7wv.png" alt=""></p> <p>到这里就完成了用户中台领域模型的构建了. 那由于领域建模的过程中产生的领域对象实在太多了, 我们可以借助表格来记录.</p> <p><img src="/img/1b3b979f5b6cfccb3ddd556101afe4ed-20230731163226-wmd3l3q.png" alt=""></p> <h6 id="_4-微服务拆分与设计"><a href="#_4-微服务拆分与设计" class="header-anchor">#</a> 4.微服务拆分与设计</h6> <p>在基础篇讲过, 原则上一个领域模型就可以设计为一个微服务, 但由于领域建模时只考虑了业务因素, 没有考虑微服务落地时的技术, 团队以及运行环境等非业务因素, 因此在微服务拆分与设计时, 不能简单地将领域模型作为拆分微服务的唯一标准, 它只能作为微服务拆分的一个重要依据.</p> <p><strong>微服务的设计还需要考虑服务的粒度, 分层, 边界划分, 依赖关系和集成关系</strong>. 除了考虑业务职责单一外, 还需要考虑将敏态与稳态业务的分离, 非功能性需求(如弹性伸缩要求, 安全性等要求), 团队组织和沟通效率, 软件包大小以及技术异构等非业务因素.</p> <p>微服务设计建议参与的角色: 领域专家, 产品经理, 需求分析人员, 架构师, 项目经理, 开发经理和测试经理.</p> <p>用户中台微服务设计如果不考虑非业务因素, 完全可以按照领域模型与微服务一对一的关系来设计, 将用户中台设计为: 用户, 认证和权限三个微服务. 但如果用户日志数据量巨大, 大到需要采用大数据技术来实现, 这时用户信息聚合与用户日志聚合就会有技术异构. 虽然在领域建模时, 我们将他们放在一个了领域模型内, 但如果考虑技术异构, 这两个聚合就不适合放到同一个微服务里了. 我们可以以聚合作为拆分单位, 将用户基本信息管理和用户日志管理拆分为两个技术异构的微服务, 分别用不同的技术来实现它们.</p> <h5 id="总结-12"><a href="#总结-12" class="header-anchor">#</a> 总结</h5> <p>今天讲了事件风暴的设计方法以及如何用事件风暴来构建领域模型. 事件风暴是一种不同于传统需求分析和系统设计的方法, 最好的学习方法就是找几个业务场景多做几次.</p> <p>综合我的经验, 一般来说一个中型规模的项目, 领域建模的时间大概在两周左右, 这与传统的需求分析和系统设计的时间基本差不多. 但是如果在领域建模的过程中, 团队成员全员参与, 在项目开发之前就建立了共同语言, 这对于后续的微服务设计与开发是很有帮助的, 时间成本也可以视情况降低.</p> <p>其实我也了解到了, 很多开发人员在初次学习 DDD 时, 似乎并不太关心领域建模, 而只是想学学 DDD 的战术设计思想, 快速上手, 开发微服务. 我想这是对 DDD 的一个误解, 这已经偏离了 DDD 的核心设计思想, 即先有边界清晰的领域模型, 才能设计出清晰的微服务边界, 这两个阶段一前一后是刚需, 不能忽略.</p> <h4 id="_13-代码模型-上-如何使用ddd设计微服务代码模型"><a href="#_13-代码模型-上-如何使用ddd设计微服务代码模型" class="header-anchor">#</a> 13-代码模型(上):如何使用DDD设计微服务代码模型?</h4> <p>上一讲完成了领域模型的设计, 接下来就要开始<strong>微服务的设计和落地</strong>了. 那微服务落地时首先要确定的就是<mark><strong>微服务的代码结构</strong></mark>, 也就是今天要讲的微服务代码模型.</p> <p>只有建立了标准的微服务代码模型和代码规范后, 才可以将领域对象所对应的代码对象放在合适的软件包的目录结构中. <strong>标准的代码模型可以让项目团队成员更好地理解代码, 根据代码规范实现团队协作; 还可以让微服务各层的逻辑互不干扰, 分工协作, 各据其位, 各司其职, 避免不必要的代码混淆. 另外, 标准的代码模型还可以让你在微服务架构演进时, 轻松完成代码重构</strong>.</p> <p>那在 DDD 里, 微服务的代码结构长什么样子呢? 又是依据什么来建立微服务代码模型? 这就是今天重点要解决的两个问题.</p> <h5 id="ddd分层架构与微服务代码模型"><a href="#ddd分层架构与微服务代码模型" class="header-anchor">#</a> DDD分层架构与微服务代码模型</h5> <p>参考 DDD 分层架构模型来设计微服务代码模型. 没错! 微服务代码模型就是依据 DDD 分层架构模型设计出来的. 那为什么是 DDD 分层架构模型呢?</p> <p><img src="/img/973e9e4f3dfc428c0d93578018a38f48-20230731163226-1z274xn.png" alt=""></p> <p>先简单回顾一下前面介绍过的 DDD 分层架构模型. 它包括<strong>用户接口层, 应用层, 领域层和基础层</strong>, 分层架构各层的职责边界非常清晰, 又能有条不紊地分层协作.</p> <ol><li><strong>用户接口层</strong>: 面向前端提供服务适配, 面向资源层提供资源适配. 这一层聚集了接口适配相关的功能.</li> <li><strong>应用层职责</strong>: 实现服务组合和编排, 适应业务流程快速变化的需求. 这一层聚集了应用服务和事件相关的功能.</li> <li><strong>领域层</strong>: 实现领域的核心业务逻辑. 这一层聚集了领域模型的聚合, 聚合根, 实体, 值对象, 领域服务和事件等领域对象, 以及它们组合所形成的业务能力.</li> <li><strong>基础层</strong>: 贯穿所有层, 为各层提供基础资源服务. 这一层聚集了各种底层资源相关的服务和能力.</li></ol> <p>业务逻辑从领域层, 应用层到用户接口层逐层封装和协作, 对外提供灵活的服务, 既实现了各层的分工, 又实现了各层的协作. 因此, 毋庸置疑, <strong>DDD 分层架构模型就是设计微服务代码模型的最佳依据</strong>.</p> <h5 id="微服务代码模型"><a href="#微服务代码模型" class="header-anchor">#</a> 微服务代码模型</h5> <p>现在来看一下, 按照 DDD 分层架构模型设计出来的微服务代码模型到底长什么样子呢?</p> <p>其实, DDD 并没有给出标准的代码模型, 不同的人可能会有不同理解. 下面要说的这个微服务代码模型是我经过思考和实践后建立起来的, 主要考虑的是<strong>微服务的边界, 分层以及架构演进</strong>.</p> <h6 id="微服务一级目录结构"><a href="#微服务一级目录结构" class="header-anchor">#</a> 微服务一级目录结构</h6> <p>微服务一级目录是按照 DDD 分层架构的分层职责来定义的. 从下面这张图中可以看到, 在代码模型里分别为用户接口层, 应用层, 领域层和基础层, 建立了 <mark><strong>interfaces, application, domain 和 infrastructure</strong></mark> 四个一级代码目录.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>微服务目录结构
<span class="token operator">*</span> application
<span class="token operator">*</span> domain
<span class="token operator">*</span> infrastructure
<span class="token operator">*</span> interfaces
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这些目录的职能和代码形态是这样的.</p> <ul><li><strong>Interfaces(用户接口层):</strong>  它主要存放<strong>用户接口层与前端交互, 展现数据相关的代码</strong>. 前端应用通过这一层的接口, 向应用服务获取展现所需的数据. 这一层主要用来处理用户发送的 Restful 请求, 解析用户输入的配置文件, 并将数据传递给 Application 层. 数据的组装, 数据传输格式以及 Facade 接口等代码都会放在这一层目录里.</li> <li><strong>Application(应用层):</strong>  它主要存放<strong>应用层服务组合和编排相关的代码</strong>. 应用服务向下基于微服务内的领域服务或外部微服务的应用服务完成服务的编排和组合, 向上为用户接口层提供各种应用数据展现支持服务. 应用服务和事件等代码会放在这一层目录里.</li> <li><strong>Domain(领域层):</strong>  它主要存放<strong>领域层核心业务逻辑相关的代码</strong>. 领域层可以包含多个聚合代码包, 它们共同实现领域模型的核心业务逻辑. 聚合以及聚合内的<strong>实体, 方法, 领域服务和事件</strong>等代码会放在这一层目录里.</li> <li><strong>Infrastructure(基础层):</strong>  它主要存放<strong>基础资源服务相关的代码</strong>, 为其它各层提供的通用技术能力, 三方软件包, 数据库服务, 配置和基础资源服务的代码都会放在这一层目录里.</li></ul> <h6 id="各层目录结构"><a href="#各层目录结构" class="header-anchor">#</a> 各层目录结构</h6> <blockquote><p>1.用户接口层</p></blockquote> <p>Interfaces 的代码目录结构有: assembler, dto 和 façade 三类.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>interfaces
<span class="token operator">-</span> assembler
<span class="token operator">-</span> dto
<span class="token operator">-</span> facade
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><strong>Assembler:</strong>  实现 DTO 与领域对象之间的相互转换和数据交换. 一般来说 Assembler 与 DTO 总是一同出现.</li> <li><strong>Dto:</strong>  它是数据传输的载体, 内部不存在任何业务逻辑, 可以通过 DTO <strong>把内部的领域对象与外界隔离</strong>.</li> <li><strong>Facade:</strong>  提供较粗粒度的调用接口, 将用户请求委派给一个或多个应用服务进行处理.</li></ul> <blockquote><p>2.应用层</p></blockquote> <p>Application 的代码目录结构有: event 和 service.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>application
<span class="token operator">-</span> event
    <span class="token operator">-</span> publish
    <span class="token operator">-</span> subscribe
<span class="token operator">-</span> service
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li><strong>Event(事件)</strong> : 这层目录主要存放<strong>事件相关的代码</strong>. 它包括两个子目录: publish 和 subscribe. 前者主要存放事件<strong>发布相关代码</strong>, 后者主要存放事件<strong>订阅相关代码</strong>(事件处理相关的核心业务逻辑在领域层实现). 这里提示一下: 虽然应用层和领域层都可以进行事件的发布和处理, 但为了实现事件的统一管理, 建议将微服务内所有事件的发布和订阅的处理都统一放到应用层, 事件相关的核心业务逻辑实现放在领域层. 通过应用层调用领域层服务, 来实现完整的事件发布和订阅处理流程.</li> <li><strong>Service(应用服务)</strong> : 这层的服务是应用服务. <strong>应用服务会对多个领域服务或外部应用服务进行封装, 编排和组合, 对外提供粗粒度的服务. 应用服务主要实现服务组合和编排, 是一段独立的业务逻辑</strong>. 可以将所有应用服务放在一个应用服务类里, 也可以把一个应用服务设计为一个应用服务类, 以防应用服务类代码量过大.</li></ul> <blockquote><p>3.领域层</p></blockquote> <p>Domain 是由一个或多个<strong>聚合包</strong>构成, 共同实现领域模型的<strong>核心业务逻辑</strong>. 聚合内的代码模型是标准和统一的, 包括: entity, event, repository 和 service 四个子目录.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>domain
<span class="token operator">-</span> aggregate00
    <span class="token operator">-</span> entity
    <span class="token operator">-</span> event
    <span class="token operator">-</span> repository
    <span class="token operator">-</span> service
<span class="token operator">-</span> aggregate01
    <span class="token operator">-</span> entity
    <span class="token operator">-</span> event
    <span class="token operator">-</span> repository
    <span class="token operator">-</span> service
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>而领域层聚合内部的代码目录结构是这样的.</p> <ul><li><strong>Aggregate(聚合):</strong>  它是聚合软件包的根目录, 可以根据实际项目的聚合名称命名, 比如权限聚合. 在聚合内定义聚合根, 实体和值对象以及领域服务之间的关系和边界. 聚合内实现高内聚的业务逻辑, 它的代码可以独立拆分为微服务. 以聚合为单位的代码放在一个包里的主要目的是为了业务内聚, 而更大的目的是为了以后微服务之间聚合的重组. 聚合之间清晰的代码边界, 可以让你轻松地实现以聚合为单位的微服务重组, 在微服务架构演进中有着很重要的作用.</li> <li><strong>Entity(实体):</strong>  它存放聚合根, 实体, 值对象以及工厂模式(Factory)相关代码. <strong>实体类采用充血模型, 同一实体相关的业务逻辑都在实体类代码中实现. 跨实体的业务逻辑代码在领域服务中实现</strong>.</li> <li><strong>Event(事件):</strong>  它存放事件实体以及与事件活动相关的业务逻辑代码.</li> <li><strong>Service(领域服务):</strong>  它存放领域服务代码. <strong>一个领域服务是多个实体组合出来的一段业务逻辑</strong>. 可以将聚合内所有领域服务都放在一个领域服务类中, 也可以把每一个领域服务设计为一个类. 如果领域服务内的业务逻辑相对复杂, 建议将一个领域服务设计为一个领域服务类, 避免由于所有领域服务代码都放在一个领域服务类中, 而出现代码臃肿的问题. 领域服务封装多个实体或方法后向上层提供应用服务调用.</li> <li><strong>Repository(仓储):</strong>  它存放所在聚合的查询或持久化领域对象的代码, 通常包括仓储接口和仓储实现方法. 为了方便聚合的拆分和组合, 我们设定了一个原则: <strong>一个聚合对应一个仓储</strong>. 特别说明: 按照 DDD 分层架构, 仓储实现本应该属于基础层代码, 但为了在微服务架构演进时, 保证代码拆分和重组的便利性, 我是把聚合仓储实现的代码放到了聚合包内. 这样, 如果需求或者设计发生变化导致聚合需要拆分或重组时, 就可以将包括核心业务逻辑和仓储代码的聚合包整体迁移, 轻松实现微服务架构演进.</li></ul> <blockquote><p>4.基础层</p></blockquote> <p>Infrastructure 的代码目录结构有: config 和 util 两个子目录.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>infrastructure
<span class="token operator">-</span> config
<span class="token operator">-</span> util
    <span class="token operator">-</span> api
    <span class="token operator">-</span> driver
    <span class="token operator">-</span> eventbus
    <span class="token operator">-</span> mq
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li><strong>Config:</strong>  主要存放配置相关代码.</li> <li><strong>Util:</strong>  主要存放平台, 开发框架, 消息, 数据库, 缓存, 文件, 总线, 网关, 第三方类库, 通用算法等基础代码, 可以为不同的资源类别建立不同的子目录.</li></ul> <h6 id="代码模型总目录结构"><a href="#代码模型总目录结构" class="header-anchor">#</a> 代码模型总目录结构</h6> <p>在完成一级和二级代码模型设计后, 就可以看到下图这样的微服务代码模型的总目录结构了.</p> <p>​<img src="/img/8c6fa201c7e3e27018b813aa168d94be-20230731163226-a4pfheh.png" alt="">​</p> <h5 id="总结-13"><a href="#总结-13" class="header-anchor">#</a> 总结</h5> <p>今天根据 DDD 分层架构模型建立了标准的微服务代码模型, 在代码模型里面, <strong>各代码对象各据其位, 各司其职, 共同协作完成微服务的业务逻辑</strong>.</p> <p>那关于代码模型还需要强调两点内容.</p> <p>第一点: <strong>聚合之间的代码边界一定要清晰</strong>. 聚合之间的服务调用和数据关联应该是尽可能的松耦合和低关联, 聚合之间的服务调用应该通过上层的应用层组合实现调用, <strong>原则上不允许聚合之间直接调用领域服务</strong>. 这种松耦合的代码关联, 在以后业务发展和需求变更时, 可以很方便地实现业务功能和聚合代码的重组, 在微服务架构演进中将会起到非常重要的作用.</p> <p>第二点: <strong>一定要有代码分层的概念</strong>. 写代码时一定要搞清楚代码的职责, 将它放在职责对应的代码目录内. <strong>应用层代码主要完成服务组合和编排, 以及聚合之间的协作, 它是很薄的一层, 不应该有核心领域逻辑代码</strong>. 领域层是业务的核心, 领域模型的核心逻辑代码一定要在领域层实现. 如果将核心领域逻辑代码放到应用层, 你的基于 DDD 分层架构模型的微服务慢慢就会演变成传统的三层架构模型了.</p> <h4 id="_14-代码模型-下-如何保证领域模型与代码模型的一致性"><a href="#_14-代码模型-下-如何保证领域模型与代码模型的一致性" class="header-anchor">#</a> 14-代码模型(下):如何保证领域模型与代码模型的一致性?</h4> <p>前面了解了如何用事件风暴来构建领域模型, 在构建领域模型的过程中, 会提取出很多的领域对象, 比如聚合, 实体, 命令和领域事件等. 后面又根据 DDD 分层架构模型, 建立了标准的微服务代码模型, 为代码对象定义好了分层和目录结构.</p> <p>那要想完成微服务的设计和落地, 这之后其实还有一步, 也就是今天的重点——将领域对象映射到微服务代码模型中. 那为什么这一步如此重要呢?</p> <p>DDD 强调先构建领域模型然后设计微服务, 以保证领域模型和微服务的一体性, 因此不能脱离领域模型来谈微服务的设计和落地. 但在构建领域模型时, 我们往往是站在业务视角的, 并且有些领域对象还带着业务语言. 还需要<strong>将领域模型作为微服务设计的输入, 对领域对象进行设计和转换, 让领域对象与代码对象建立映射关系</strong>.</p> <p>接下来围绕今天的重点, 详细来讲一讲.</p> <h5 id="领域对象的整理"><a href="#领域对象的整理" class="header-anchor">#</a> 领域对象的整理</h5> <p>完成微服务拆分后, 领域模型的边界和领域对象就基本确定了.</p> <p>第一个重要的工作就是, <strong>整理事件风暴过程中产生的各个领域对象</strong>, 比如: 聚合, 实体, 命令和领域事件等内容, 将这些领域对象和业务行为记录到下面的表格中.</p> <p>可以看到, 这张表格里包含了: <mark><strong>领域模型, 聚合, 领域对象和领域类型四个维度</strong></mark>. 一个领域模型会包含多个聚合, 一个聚合包含多个领域对象, 每个领域对象都有自己的领域类型. 领域类型主要标识领域对象的属性, 比如: <strong>聚合根, 实体, 命令和领域事件</strong>等类型.</p> <p><img src="/img/44cfb944c492578ac578297e71898ff7-20230731163226-7kv6lbn.png" alt=""></p> <h5 id="从领域模型到微服务的设计"><a href="#从领域模型到微服务的设计" class="header-anchor">#</a> 从领域模型到微服务的设计</h5> <p>从领域模型到微服务落地, 还需要做进一步的<strong>设计和分析</strong>. 事件风暴中提取的领域对象, 还需要经过用户故事或领域故事分析, 以及微服务设计, 才能用于微服务系统开发.</p> <p>这个过程会比事件风暴来的更深入和细致. 主要关注内容如下:</p> <ol><li><strong>分析微服务内有哪些服务</strong>?</li> <li><strong>服务所在的分层</strong>?</li> <li><strong>应用服务由哪些服务组合和编排完成</strong>?</li> <li><strong>领域服务包括哪些实体的业务逻辑</strong>?</li> <li><strong>采用充血模型的实体有哪些属性和方法</strong>?</li> <li><strong>有哪些值对象</strong>?</li> <li><strong>哪个实体是聚合根等</strong>?</li> <li>最后梳理出所有的领域对象和它们之间的依赖关系, 会给每个领域对象设计对应的代码对象, 定义它们所在的软件包和代码目录.</li></ol> <p>这个设计过程建议参与的角色有: DDD 专家, 架构师, 设计人员和开发经理.</p> <h6 id="领域层的领域对象"><a href="#领域层的领域对象" class="header-anchor">#</a> 领域层的领域对象</h6> <p>事件风暴结束时, 领域模型聚合内一般会有: <strong>聚合, 实体, 命令和领域事件等领域对象</strong>. 在完成故事分析和微服务设计后, 微服务的聚合内一般会有: 聚合, 聚合根, 实体, 值对象, 领域事件, 领域服务和仓储等领域对象.</p> <p>下面就来看一下这些领域对象是怎么得来的?</p> <blockquote><p>1.设计实体</p></blockquote> <p>大多数情况下, 领域模型的业务实体与微服务的数据库实体是一一对应的. 但某些领域模型的实体在微服务设计时, 可能会被设计为多个数据实体, 或者实体的某些属性被设计为值对象.</p> <p>分析个人客户时, 还需要有地址, 电话和银行账号等实体, 它们被聚合根引用, 不容易在领域建模时发现, 需要在微服务设计过程中识别和设计出来.</p> <p>在分层架构里, <strong>实体采用充血模型, 在实体类内实现实体的全部业务逻辑</strong>. 这些不同的实体都有自己的方法和业务行为, 比如地址实体有新增和修改地址的方法, 银行账号实体有新增和修改银行账号的方法.</p> <p>实体类放在领域层的 Entity 目录结构下.</p> <blockquote><p>2.找出聚合根</p></blockquote> <p>聚合根来源于领域模型, 在个人客户聚合里, 个人客户这个实体是聚合根, 它负责管理地址, 电话以及银行账号的生命周期. 个人客户聚合根通过工厂和仓储模式, 实现聚合内地址, 银行账号等实体和值对象数据的初始化和持久化.</p> <p>聚合根是一种特殊的实体, 它有自己的属性和方法. <strong>聚合根可以实现聚合之间的对象引用, 还可以引用聚合内的所有实体. 聚合根类放在代码模型的 Entity 目录结构下</strong>. 聚合根有自己的实现方法, 比如生成客户编码, 新增和修改客户信息等方法.</p> <blockquote><p>3.设计值对象</p></blockquote> <p><strong>根据需要将某些实体的某些属性或属性集设计为值对象</strong>. 值对象类放在代码模型的 Entity 目录结构下. 在个人客户聚合中, 客户拥有客户证件类型, 它是以枚举值的形式存在, 所以将它设计为值对象.</p> <p>有些领域对象可以设计为值对象, 也可以设计为实体, 需要根据具体情况来分析. 如果这个领域对象在其它聚合内维护生命周期, 且在它依附的实体对象中只允许整体替换, 就可以将它设计为值对象. 如果这个对象是多条且需要基于它做查询统计, 我建议将它设计为实体.</p> <blockquote><p>4.设计领域事件</p></blockquote> <p>如果领域模型中领域事件会触发下一步的业务操作, 就需要设计领域事件. 首先<strong>确定领域事件发生在微服务内还是微服务之间. 然后设计事件实体对象, 事件的发布和订阅机制, 以及事件的处理机制</strong>. 判断是否需要引入事件总线或消息中间件.</p> <p>在个人客户聚合中有客户已创建的领域事件, 因此它有客户创建事件这个实体.</p> <p>领域事件实体和处理类放在领域层的 Event 目录结构下. 领域事件的发布和订阅类建议放在应用层的 Event 目录结构下.</p> <blockquote><p>5.设计领域服务</p></blockquote> <p>如果一个业务动作或行为跨多个实体, 就需要设计<strong>领域服务</strong>. 领域服务通过<strong>对多个实体和实体方法进行组合, 完成核心业务逻辑</strong>. 可以认为领域服务是位于实体方法之上和应用服务之下的一层业务逻辑.</p> <p>按照严格分层架构层的依赖关系, 如果实体的方法需要暴露给应用层, 它需要封装成领域服务后才可以被应用服务调用. 所以如果有的实体方法需要被前端应用调用, 我们会将它封装成领域服务, 然后再封装为应用服务.</p> <p>个人客户聚合根这个实体创建个人客户信息的方法, 被封装为创建个人客户信息领域服务. 然后再被封装为创建个人客户信息应用服务, 向前端应用暴露.</p> <p>领域服务类放在领域层的 Service 目录结构下.</p> <blockquote><p>6.设计仓储</p></blockquote> <p>每一个聚合都有一个仓储, 仓储主要用来完成数据查询和持久化操作. 仓储包括仓储的接口和仓储实现, 通过依赖倒置实现应用业务逻辑与数据库资源逻辑的解耦.</p> <p>仓储代码放在领域层的 Repository 目录结构下.</p> <h6 id="应用层的领域对象"><a href="#应用层的领域对象" class="header-anchor">#</a> 应用层的领域对象</h6> <p>应用层的<strong>主要领域对象是应用服务和事件的发布以及订阅</strong>.</p> <p>在事件风暴或领域故事分析时, 往往会根据用户或系统发起的命令, 来设计服务或实体方法. 为了响应这个命令, 需要分析和记录:</p> <ol><li><strong>在应用层和领域层分别会发生哪些业务行为</strong>;</li> <li><strong>各层分别需要设计哪些服务或者方法</strong>;</li> <li>这些方法和服务的分层以及领域类型(比如实体方法, 领域服务和应用服务等), 它们之间的调用和组合的依赖关系.</li></ol> <p>在严格分层架构模式下, 不允许服务的跨层调用, 每个服务只能调用它的下一层服务. 服务从下到上依次为: <strong>实体方法, 领域服务和应用服务</strong>.</p> <p>如果需要实现服务的跨层调用, 应该怎么办? 建议采用<strong>服务逐层封装</strong>的方式.</p> <p><img src="/img/1052153662934c54a658648bf05fa21c-20230731163226-61hjd20.png" alt=""></p> <p>看一下上面这张图, 服务的封装和调用主要有以下几种方式.</p> <blockquote><p>1.实体方法的封装</p></blockquote> <p>实体方法是最底层的原子业务逻辑. 如果单一实体的方法需要被跨层调用, 可以将它<strong>封装成领域服务</strong>, 这样封装的领域服务就可以被应用服务调用和编排了. 如果它还需要被用户接口层调用, 还需要将这个领域服务封装成应用服务. <strong>经过逐层服务封装, 实体方法就可以暴露给上面不同的层, 实现跨层调用</strong>.</p> <p>封装时服务前面的名字可以保持一致, 可以用 *DomainService 或 *AppService 后缀来区分领域服务或应用服务.</p> <blockquote><p>2.领域服务的组合和封装</p></blockquote> <p><strong>领域服务会对多个实体和实体方法进行组合和编排, 供应用服务调用</strong>. 如果它需要暴露给用户接口层, 领域服务就需要封装成应用服务.</p> <blockquote><p>3.应用服务的组合和编排</p></blockquote> <p>应用服务会对多个领域服务进行组合和编排, 暴露给用户接口层, 供前端应用调用.</p> <p>在应用服务组合和编排时, 需要关注一个现象: 多个应用服务可能会对多个同样的领域服务重复进行同样业务逻辑的组合和编排. 当出现这种情况时, 就需要分析是不是领域服务可以整合了. 可以将这几个不断重复组合的领域服务, 合并到一个领域服务中实现. 这样既省去了应用服务的反复编排, 也实现了服务的演进. 这样领域模型将会越来越精炼, 更能适应业务的要求.</p> <p>应用服务类放在应用层 Service 目录结构下. 领域事件的发布和订阅类放在应用层 Event 目录结构下.</p> <h5 id="领域对象与微服务代码对象的映射"><a href="#领域对象与微服务代码对象的映射" class="header-anchor">#</a> 领域对象与微服务代码对象的映射</h5> <p>在完成上面的分析和设计后, 就可以建立像下图一样的, <strong>领域对象与微服务代码对象的映射关系</strong>了.</p> <h6 id="典型的领域模型"><a href="#典型的领域模型" class="header-anchor">#</a> 典型的领域模型</h6> <p>个人客户领域模型中的个人客户聚合, 就是典型的领域模型, 从聚合内可以提取出多个实体和值对象以及它的聚合根.</p> <p>下面这个图对个人客户聚合做了进一步的分析. 提取了个人客户表单这个聚合根, 形成了客户类型值对象, 以及电话, 地址, 银行账号等实体, 为实体方法和服务做了封装和分层, 建立了领域对象的关联和依赖关系, 还有仓储等设计. 关键是这个过程, 我们建立了领域对象与微服务代码对象的映射关系.</p> <p><img src="/img/cf08b66aa1a542c36a1ae2d2d1d60fe6-20230731163226-vcycadt.png" alt=""></p> <p>下面对表格的各栏做一个简要的说明.</p> <ol><li><strong>层</strong>: 定义领域对象位于分层架构中的哪一层, 比如: 接口层, 应用层, 领域层以及基础层等.</li> <li><strong>领域对象</strong>: 领域模型中领域对象的具体名称.</li> <li><strong>领域类型</strong>: 根据 DDD 知识体系定义的领域对象的类型, 包括: 限界上下文, 聚合, 聚合根, 实体, 值对象, 领域事件, 应用服务, 领域服务和仓储服务等领域类型.</li> <li><strong>依赖的领域对象</strong>: 根据业务对象依赖或分层调用的依赖关系, 建立的领域对象的依赖关系, 比如: 服务调用依赖, 关联对象聚合等.</li> <li><strong>包名</strong>: 代码模型中的包名, 对应领域对象所在的软件包.</li> <li><strong>类名</strong>: 代码模型中的类名, 对应领域对象的类名.</li> <li><strong>方法名</strong>: 代码模型中的方法名, 对应领域对象实现或操作的方法名.</li></ol> <p>在建立这种映射关系后, 就可以得到如下图的微服务代码结构了.</p> <p><img src="/img/6ca1c0de8d309c167f1005fb540a6e4d-20230731163226-gsakfdl.png" alt=""></p> <h6 id="非典型领域模型"><a href="#非典型领域模型" class="header-anchor">#</a> 非典型领域模型</h6> <p>有些业务场景可能并不能如你所愿, 可能无法设计出典型的领域模型. 这类业务中有多个实体, 实体之间相互独立, 是松耦合的关系, 这些实体主要参与分析或者计算, 你找不出聚合根, 但就业务本身来说它们是高内聚的. 而它们所组合的业务与其它聚合是在一个限界上下文内, 你也不大可能将它单独设计为一个微服务.</p> <p>这种业务场景其实很常见. 比如在个人客户领域模型内有客户归并的聚合, 它扫描所有客户, 按照身份证号码, 电话号码等是否重复的业务规则, 判断是否是重复的客户, 然后对重复的客户进行归并. 这种业务场景就找不到聚合根.</p> <p>那对于这类非典型模型怎么办?</p> <p>还是可以借鉴聚合的思想, 仍然用聚合来定义这部分功能, 并采用与典型领域模型同样的分析方法, 建立实体的属性和方法, 对方法和服务进行封装和分层设计, 设计仓储, 建立领域对象之间的依赖关系. 唯一可惜的就是依然找不到聚合根, 不过也没关系, 除了聚合根管理功能外, 还可以用 DDD 的其它设计方法.</p> <h5 id="总结-14"><a href="#总结-14" class="header-anchor">#</a> 总结</h5> <p>今天学习了从领域模型到微服务的设计过程, 这个过程在微服务设计过程中非常的关键. 需要从微服务系统的角度, <strong>对领域模型做深入, 细致的分析, 为领域对象分层, 找出各个领域对象的依赖关系, 建立领域对象与微服务代码对象的映射关系, 从而保证领域模型与代码模型的一致性, 最终完成微服务的设计</strong>.</p> <p>在建立这种业务模型与微服务系统架构的关系后, 整个项目团队就可以在统一的通用语言下工作, 即使不熟悉业务的开发人员, 或者不熟悉代码的业务人员, 也可以很快就定位到代码位置.</p> <h4 id="_15-边界-微服务的各种边界在架构演进中的作用"><a href="#_15-边界-微服务的各种边界在架构演进中的作用" class="header-anchor">#</a> 15-边界:微服务的各种边界在架构演进中的作用?</h4> <p>前几讲已经介绍过了, 在用 DDD 进行微服务设计时, 可以通过事件风暴来确定领域模型边界, 划定微服务边界, 定义业务和系统运行边界, 从而保证微服务的单一职责和随需而变的架构演进能力.</p> <p>那重点落到边界的时候, 总结一下就是, <strong>微服务的设计要涉及到逻辑边界, 物理边界和代码边界</strong>等等.</p> <p>那么这些边界在微服务架构演进中到底起到什么样的作用? 又该如何理解这些边界呢? 这就是今天重点要解决的问题.</p> <h5 id="演进式架构"><a href="#演进式架构" class="header-anchor">#</a> 演进式架构</h5> <p>在微服务设计和实施的过程中, 很多人认为: &quot;将单体拆分成多少个微服务, 是微服务的设计重点.&quot; 可事实真的是这样吗? 其实并非如此!</p> <p>Martin Fowler 在提出微服务时, 他提到了微服务的一个重要特征--演进式架构. 那什么是演进式架构呢? 演进式架构就是以支持增量的, 非破坏的变更作为第一原则, 同时支持在应用程序结构层面的多维度变化.</p> <p>那如何判断微服务设计是否合理呢? 其实很简单, 只需要看它是否满足这样的情形就可以了: <strong>随着业务的发展或需求的变更, 在不断重新拆分或者组合成新的微服务的过程中, 不会大幅增加软件开发和维护的成本, 并且这个架构演进的过程是非常轻松, 简单的</strong>.</p> <p>这也是微服务设计的重点, 就是看<strong>微服务设计是否能够支持架构长期, 轻松的演进</strong>.</p> <p>那用 DDD 方法设计的微服务, 不仅可以通过限界上下文和聚合实现微服务内外的解耦, 同时也可以很容易地实现业务功能积木式模块的重组和更新, 从而实现架构演进.</p> <h5 id="微服务还是小单体"><a href="#微服务还是小单体" class="header-anchor">#</a> 微服务还是小单体?</h5> <p>有些项目团队在将集中式单体应用拆分为微服务时, 首先进行的往往不是建立领域模型, 而只是按照业务功能将原来单体应用的一个软件包拆分成多个所谓的 &quot;微服务&quot; 软件包, 而这些 &quot;微服务&quot; 内的代码仍然是集中式三层架构的模式, &quot;微服务&quot;内的代码高度耦合, 逻辑边界不清晰, 这里暂且称它为 &quot;小单体微服务&quot;.</p> <p>下面这张图也很好地展示了这个过程.</p> <p><img src="/img/3d72a9faa49c84cf6df5f78ee81d2e33-20230731163226-9u3u2xv.png" alt=""></p> <p>而随着新需求的提出和业务的发展, 这些小单体微服务会慢慢膨胀起来. 当有一天你发现这些<strong>膨胀了的微服务</strong>, 有一部分业务功能需要拆分出去, 或者部分功能需要与其它微服务进行重组时, 会发现原来这些看似清晰的微服务, 不知不觉已经摇身一变, 变成了臃肿油腻的大单体了, 而这个大单体内的代码依然是高度耦合且边界不清的.</p> <p>&quot;辛辛苦苦好多年, 一夜回到解放前啊!&quot; 这个时候你就需要一遍又一遍地重复着从大单体向单体微服务重构的过程. 想想, 这个代价是不是有点高了呢?</p> <p>其实这个问题已经很明显了, 那就是<mark><strong>边界</strong></mark>.</p> <p>这种单体式微服务<strong>只定义了一个维度的边界, 也就是微服务之间的物理边界, 本质上还是单体架构模式</strong>. 微服务设计时要考虑的不仅仅只有这一个边界, 别忘了还要定义好微服务内的逻辑边界和代码边界, 这样才能得到想要的结果.</p> <p>现在知道了一定要避免将微服务设计为小单体微服务, 那具体该如何避免呢? 清晰的边界人人想要, 可该如何保证呢? DDD 已然给出了答案.</p> <h5 id="微服务边界的作用"><a href="#微服务边界的作用" class="header-anchor">#</a> 微服务边界的作用</h5> <p>你应该还记得 DDD 设计方法里的<strong>限界上下文和聚合</strong>吧? 它们就是<strong>用来定义领域模型和微服务边界</strong>的.</p> <p>再来回顾一下 DDD 的设计过程.</p> <p>在事件风暴中, 会梳理出业务过程中的用户操作, 事件以及外部依赖关系等, 根据这些要素梳理出实体等领域对象. 根据实体对象之间的业务关联性, 将业务紧密相关的多个实体进行组合形成聚合, 聚合之间是第一层边界. 根据业务及语义边界等因素将一个或者多个聚合划定在一个限界上下文内, 形成领域模型, 限界上下文之间的边界是第二层边界.</p> <p>为了方便理解, 将这些边界分为: <strong>逻辑边界, 物理边界和代码边界</strong>.</p> <p><mark><strong>逻辑边界主要定义同一业务领域或应用内紧密关联的对象所组成的不同聚类的组合之间的边界</strong></mark>. 事件风暴对不同实体对象进行关联和聚类分析后, 会产生多个聚合和限界上下文, 它们一起组成这个领域的领域模型. 微服务内聚合之间的边界就是逻辑边界. 一般来说微服务会有一个以上的聚合, 在开发过程中不同聚合的代码隔离在不同的聚合代码目录中.</p> <p>逻辑边界在微服务设计和架构演进中具有非常重要的意义!</p> <p><strong>微服务的架构演进并不是随心所欲的, 需要遵循一定的规则, 这个规则就是逻辑边界</strong>. 微服务架构演进时, 在业务端以聚合为单位进行业务能力的重组, 在微服务端以聚合的代码目录为单位进行微服务代码的重组. 由于按照 DDD 方法设计的微服务逻辑边界清晰, 业务高内聚, 聚合之间代码松耦合, 因此在领域模型和微服务代码重构时, 就不需要花费太多的时间和精力了.</p> <p>现在来看一个微服务实例, 在下面这张图中, 可以看到微服务里包含了<strong>两个聚合的业务逻辑</strong>, 两个聚合分别内聚了各自不同的业务能力, 聚合内的代码分别归到了不同的聚合目录下.</p> <p>那随着业务的快速发展, 如果某一个微服务遇到了高性能挑战, 需要将部分业务能力独立出去, 就可以<strong>以聚合为单位, 将聚合代码拆分独立为一个新的微服务, 这样就可以很容易地实现微服务的拆分</strong>.</p> <p><img src="/img/dc8d4c4860f0812c2e9725132d038276-20230731163226-qjjjof5.png" alt=""></p> <p>另外也可以<strong>对多个微服务内有相似功能的聚合进行功能和代码重组, 组合为新的聚合和微服务, 独立为通用微服务</strong>. 现在你是不是有点做中台的感觉呢?</p> <p><mark><strong>物理边界主要从部署和运行的视角来定义微服务之间的边界</strong></mark>. 不同微服务部署位置和运行环境是相互物理隔离的, 分别运行在不同的进程中. 这种边界就是微服务之间的物理边界.</p> <p><mark><strong>代码边界主要用于微服务内的不同职能代码之间的隔离</strong></mark>. 微服务开发过程中会根据代码模型建立相应的代码目录, 实现不同功能代码的隔离. 由于领域模型与代码模型的映射关系, <strong>代码边界直接体现出业务边界</strong>. 代码边界可以控制代码重组的影响范围, 避免业务和服务之间的相互影响. 微服务如果需要进行功能重组, 只需要以聚合代码为单位进行重组就可以了.</p> <h5 id="正确理解微服务的边界"><a href="#正确理解微服务的边界" class="header-anchor">#</a> 正确理解微服务的边界</h5> <p>从上述内容中, 可以知道了, 按照 DDD 设计出来的逻辑边界和代码边界, 让微服务架构演进变得不那么费劲了.</p> <p><strong>微服务的拆分可以参考领域模型, 也可以参考聚合, 因为聚合是可以拆分为微服务的最小单位的</strong>. 但实施过程是否一定要做到逻辑边界与物理边界一致性呢? 也就是说聚合是否也一定要设计成微服务呢? 答案是不一定的, 这里就涉及到微服务过度拆分的问题了.</p> <p>微服务的过度拆分会使软件维护成本上升, 比如: 集成成本, 发布成本, 运维成本以及监控和定位问题的成本等. 在项目建设初期, 如果不具备较强的微服务管理能力, 那就不宜将微服务拆分过细. 当具备一定的能力以后, 且微服务内部的逻辑和代码边界也很清晰, 就可以随时根据需要, 拆分出新的微服务, 实现微服务的架构演进了.</p> <p>当然, 还要记住一点, 微服务内聚合之间的服务调用和数据依赖需要符合高内聚松耦合的设计原则和开发规范, 否则你也不能很快完成微服务的架构演进.</p> <h5 id="总结-15"><a href="#总结-15" class="header-anchor">#</a> 总结</h5> <p>今天主要讨论了微服务架构设计中的各种边界在架构演进中的作用.</p> <ul><li><strong>逻辑边界:</strong>  微服务内聚合之间的边界是逻辑边界. 它是一个虚拟的边界, 强调业务的内聚, 可根据需要变成物理边界, 也就是说聚合也可以独立为微服务.</li> <li><strong>物理边界:</strong>  微服务之间的边界是物理边界. 它强调微服务部署和运行的隔离, 关注微服务的服务调用, 容错和运行等.</li> <li><strong>代码边界:</strong>  不同层或者聚合之间代码目录的边界是代码边界. 它强调的是代码之间的隔离, 方便架构演进时代码的重组.</li></ul> <p>通过以上边界, 可以让业务能力高内聚, 代码松耦合, 且清晰的边界, 可以快速实现微服务代码的拆分和组合, 轻松实现微服务架构演进. 但有一点一定要格外注意, 边界清晰的微服务, 不是大单体向小单体的演进.</p> <h4 id="_16-视图-如何实现服务和数据在微服务各层的协作"><a href="#_16-视图-如何实现服务和数据在微服务各层的协作" class="header-anchor">#</a> 16-视图:如何实现服务和数据在微服务各层的协作?</h4> <p>在 DDD 分层架构和微服务代码模型里, 根据领域对象的属性和依赖关系, 将领域对象进行<strong>分层</strong>, 定义了与之对应的代码对象和代码目录结构. 分层架构确定了微服务的总体架构, 微服务内的主要对象有服务和实体等, 它们一起协作完成业务逻辑.</p> <p>那在运行过程中, <strong>这些服务和实体在微服务各层是如何协作的呢</strong>? 今天就来解剖一下基于 DDD 分层架构的微服务, 看看它的内部结构到底是什么样的.</p> <h5 id="服务的协作"><a href="#服务的协作" class="header-anchor">#</a> 服务的协作</h5> <h6 id="_1-服务的类型"><a href="#_1-服务的类型" class="header-anchor">#</a> 1.服务的类型</h6> <p>先来回顾一下分层架构中的服务. 按照分层架构设计出来的微服务, 其内部有 <strong>Facade 服务, 应用服务, 领域服务和基础服务</strong>. 各层服务的主要功能和职责如下.</p> <ul><li><strong>Facade 服务</strong>: 位于用户接口层, 包括<strong>接口和实现</strong>两部分. 用于处理用户发送的 Restful 请求和解析用户输入的配置文件等, 并将数据传递给应用层. 或者在获取到应用层数据后, <strong>将 DO 组装成 DTO, 将数据传输到前端应用</strong>.</li> <li><strong>应用服务</strong>: 位于应用层. 用来表述应用和用户行为, 负责<strong>服务的组合, 编排和转发</strong>, 负责处理业务用例的执行顺序以及结果拼装, 对外提供粗粒度的服务.</li> <li><strong>领域服务</strong>: 位于领域层. 领域服务封装核心的业务逻辑, 实现需要多个实体协作的核心领域逻辑. 它对多个实体或方法的业务逻辑进行组合或编排, 或者在严格分层架构中对实体方法进行封装, 以领域服务的方式供应用层调用.</li> <li><strong>基础服务</strong>: 位于基础层. 提供<strong>基础资源服务</strong>(比如数据库, 缓存等), 实现各层的解耦, 降低外部资源变化对业务应用逻辑的影响. 基础服务主要为仓储服务, 通过依赖倒置提供基础资源服务. 领域服务和应用服务都可以调用仓储服务接口, 通过仓储服务实现数据持久化.</li></ul> <h6 id="_2-服务的调用"><a href="#_2-服务的调用" class="header-anchor">#</a> 2.服务的调用</h6> <p>看一下下面这张图. 微服务的服务调用包括三类主要场景: <strong>微服务内跨层服务调用, 微服务之间服务调用和领域事件驱动</strong>.</p> <p><img src="/img/5570e12284aa82934e7ec09f1e06fc25-20230731163226-bmyc7lm.png" alt=""></p> <blockquote><p>微服务内跨层服务调用</p></blockquote> <p>微服务架构下往往采用前后端分离的设计模式, 前端应用独立部署. 前端应用调用发布在 API 网关上的 Facade 服务, <strong>Facade 定向到应用服务</strong>. 应用服务作为服务组织和编排者, 它的服务调用有这样两种路径:</p> <ol><li>第一种是应用服务调用并组装领域服务. 此时领域服务会组装实体和实体方法, 实现核心领域逻辑. 领域服务通过仓储服务获取持久化数据对象, 完成实体数据初始化.</li> <li>第二种是应用服务直接调用仓储服务. 这种方式主要针对像缓存, 文件等类型的基础层数据访问. 这类数据主要是查询操作, 没有太多的领域逻辑, 不经过领域层, 不涉及数据库持久化对象.</li></ol> <blockquote><p>微服务之间的服务调用</p></blockquote> <p>微服务之间的应用服务可以直接访问, 也可以通过 API 网关访问. 由于跨微服务操作, 在进行数据新增和修改操作时, 需关注分布式事务, 保证数据的一致性.</p> <blockquote><p>领域事件驱动</p></blockquote> <p><strong>领域事件驱动包括微服务内和微服务之间的事件</strong>. 微服务内通过<strong>事件总线(EventBus)完成聚合之间的异步处理</strong>. 微服务之间通过消息中间件完成. 异步化的领域事件驱动机制是一种<strong>间接的服务访问方式</strong>.</p> <p>当应用服务业务逻辑处理完成后, 如果<strong>发生领域事件, 可调用事件发布服务, 完成事件发布</strong>.</p> <p>当接收到订阅的主题数据时, <strong>事件订阅服务会调用事件处理领域服务, 完成进一步的业务操作</strong>.</p> <h6 id="_3-服务的封装与组合"><a href="#_3-服务的封装与组合" class="header-anchor">#</a> 3.服务的封装与组合</h6> <p>看一下下面这张图. 微服务的服务是<strong>从领域层逐级向上封装, 组合和暴露</strong>的.</p> <p><img src="/img/f3590758c7bdef33e6443577dbc7bcab-20230731163226-pgcxwrk.png" alt=""></p> <blockquote><p>基础层</p></blockquote> <p>基础层的服务形态主要是<strong>仓储服务</strong>. 仓储服务包括<strong>接口和实现</strong>两部分. 仓储接口服务供应用层或者领域层服务调用, 仓储实现服务, 完成领域对象的<strong>持久化或数据初始化</strong>.</p> <blockquote><p>领域层</p></blockquote> <p><strong>领域层实现核心业务逻辑, 负责表达领域模型业务概念, 业务状态和业务规则</strong>. 主要的服务形态有实体方法和领域服务.</p> <p>实体采用<strong>充血模型</strong>, 在实体类内部实现实体相关的所有业务逻辑, 实现的形式是<strong>实体类中的方法</strong>. 实体是微服务的原子业务逻辑单元. 在设计时主要考虑实体自身的属性和业务行为, 实现领域模型的核心基础能力. 不必过多考虑外部操作和业务流程, 这样才能保证领域模型的稳定性.</p> <p><mark><strong>DDD 提倡富领域模型, 尽量将业务逻辑归属到实体对象上, 实在无法归属的部分则设计成领域服务. 领域服务会对多个实体或实体方法进行组装和编排, 实现跨多个实体的复杂核心业务逻辑</strong></mark>.</p> <p>对于严格分层架构, 如果单个实体的方法需要对应用层暴露, 则需要通过领域服务封装后才能暴露给应用服务.</p> <blockquote><p>应用层</p></blockquote> <p>应用层用来表述应用和用户行为, 负责服务的<strong>组合, 编排和转发, 负责处理业务用例的执行顺序以及结果的拼装</strong>, 负责不同聚合之间的服务和数据协调, 负责微服务之间的事件发布和订阅.</p> <p>通过应用服务对外暴露微服务的内部功能, 这样就可以隐藏领域层核心业务逻辑的复杂性以及内部实现机制. 应用层的主要服务形态有: <strong>应用服务, 事件发布和订阅服务</strong>.</p> <p>应用服务内用于组合和编排的服务, 主要来源于领域服务, 也可以是外部微服务的应用服务. 除了完成服务的组合和编排外, 应用服务内还可以完成安全认证, 权限校验, 初步的数据校验和分布式事务控制等功能.</p> <p><strong>为了实现微服务内聚合之间的解耦, 聚合之间的服务调用和数据交互应通过应用服务来完成</strong>. 原则上应该禁止聚合之间的领域服务直接调用和聚合之间的数据表关联.</p> <blockquote><p>用户接口层</p></blockquote> <p><strong>用户接口层是前端应用和微服务之间服务访问和数据交换的桥梁</strong>. 它处理前端发送的 Restful 请求和解析用户输入的配置文件等, 将数据传递给应用层. 或获取应用服务的数据后, 进行数据组装, 向前端提供数据服务. 主要服务形态是 Facade 服务.</p> <p>Facade 服务分为<strong>接口和实现</strong>两个部分. 完成服务定向, DO 与 DTO 数据的转换和组装, 实现前端与应用层数据的转换和交换.</p> <h6 id="_4-两种分层架构的服务依赖关系"><a href="#_4-两种分层架构的服务依赖关系" class="header-anchor">#</a> 4.两种分层架构的服务依赖关系</h6> <p>现在回顾一下 DDD 分层架构, 分层架构有一个重要的原则就是: <strong>每层只能与位于其下方的层发生耦合</strong>.</p> <p>那根据耦合的紧密程度, 分层架构可以分为两种: <strong>严格分层架构和松散分层架构</strong>. 在严格分层架构中, 任何层只能与位于其直接下方的层发生依赖. <strong>在松散分层架构中, 任何层可以与其任意下方的层发生依赖</strong>.</p> <p>下面来详细分析和比较一下这两种分层架构.</p> <blockquote><p>松散分层架构的服务依赖</p></blockquote> <p>看一下下面这张图, <mark><strong>在松散分层架构中, 领域层的实体方法和领域服务可以直接暴露给应用层和用户接口层</strong></mark>. 松散分层架构的服务依赖关系, 无需逐级封装, 可以快速暴露给上层.</p> <p>但它存在<strong>一些问题, 第一个是容易暴露领域层核心业务的实现逻辑; 第二个是当实体方法或领域服务发生服务变更时, 由于服务同时被多层服务调用和组合, 不容易找出哪些上层服务调用和组合了它, 不方便通知到所有的服务调用方</strong>.</p> <p><img src="/img/30cf6eb78eda20c8c41e1da8a970fdda-20230731163226-oeyo2ku.png" alt=""></p> <p>再来看一张图, 在松散分层架构中, 实体 A 的方法在应用层组合后, 暴露给用户接口层 aFacade. abDomainService 领域服务直接越过应用层, 暴露给用户接口层 abFacade 服务. 松散分层架构中任意下层服务都可以暴露给上层服务.</p> <p><img src="/img/ca9010b06ccbdece8d427c85ac0317df-20230731163226-cwfcxme.png" alt=""></p> <blockquote><p>严格分层架构的服务依赖</p></blockquote> <p>看一下下面这张图, <mark><strong>在严格分层架构中, 每一层服务只能向紧邻的上一层提供服务</strong></mark>. 虽然实体, 实体方法和领域服务都在领域层, 但实体和实体方法只能暴露给领域服务, 领域服务只能暴露给应用服务.</p> <p>在严格分层架构中, <strong>服务如果需要跨层调用, 下层服务需要在上层封装后, 才可以提供跨层服务</strong>. 比如实体方法需要向应用服务提供服务, 它需要封装成领域服务.</p> <p>这是因为<strong>通过封装可以避免将核心业务逻辑的实现暴露给外部</strong>, 将实体和方法封装成领域服务, 也可以避免在应用层沉淀过多的本该属于领域层的核心业务逻辑, 避免应用层变得臃肿. 还有就是当服务发生变更时, 由于服务只被紧邻上层的服务调用和组合, 只需要逐级告知紧邻上层就可以了, 服务可管理性比松散分层架构要好是一定的.</p> <p><img src="/img/e52823f924b5e15b1cd5f9b2d525d574-20230731163226-o1gxdih.png" alt=""></p> <p>还是看图, A 实体方法需封装成领域服务 aDomainService 才能暴露给应用服务 aAppService. abDomainService 领域服务组合和封装 A 和 B 实体的方法后, 暴露给应用服务 abAppService.</p> <p><img src="/img/5ee89a44a1d648c587226933476de247-20230731163226-nnfvln0.png" alt=""></p> <h5 id="数据对象视图"><a href="#数据对象视图" class="header-anchor">#</a> 数据对象视图</h5> <p>在 DDD 中有很多的数据对象, 这些对象分布在不同的层里. 它们<strong>在不同的阶段有不同的形态</strong>. 可以再回顾一下 [第 04 讲], 这一讲有详细的讲解.</p> <p>先来看一下微服务内有哪些类型的数据对象? 它们是如何协作和转换的?</p> <ol><li><strong>数据持久化对象</strong> PO(Persistent Object), <strong>与数据库结构一一映射, 是数据持久化过程中的数据载体</strong>.</li> <li><strong>领域对象</strong> DO(Domain Object), <strong>微服务运行时的实体, 是核心业务的载体</strong>.</li> <li><strong>数据传输对象 DTO</strong>(Data Transfer Object), <strong>用于前端与应用层或者微服务之间的数据组装和传输, 是应用之间数据传输的载体</strong>.</li> <li><strong>视图对象 VO</strong>(View Object), 用于<strong>封装展示层指定页面或组件的数据</strong>.</li></ol> <p>结合下面这张图, 看看微服务各层数据对象的职责和转换过程.</p> <p><img src="/img/596eb0a19522e1f8417884ca3c37793c-20230731163226-b9ktmrt.png" alt=""></p> <blockquote><p>基础层</p></blockquote> <p>基础层的主要对象是 PO 对象. <strong>需要先建立 DO 和 PO 的映射关系. 当 DO 数据需要持久化时, 仓储服务会将 DO 转换为 PO 对象, 完成数据库持久化操作. 当 DO 数据需要初始化时, 仓储服务从数据库获取数据形成 PO 对象, 并将 PO 转换为 DO, 完成数据初始化</strong>.</p> <p><strong>大多数情况下 PO 和 DO 是一一对应的</strong>. 但也有 DO 和 PO 多对多的情况, 在 DO 和 PO 数据转换时, 需要进行数据重组.</p> <blockquote><p>领域层</p></blockquote> <p><strong>领域层的主要对象是 DO 对象</strong>. DO 是实体和值对象的数据和业务行为载体, 承载着基础的核心业务逻辑. 通过 DO 和 PO 转换, 可以完成数据持久化和初始化.</p> <blockquote><p>应用层</p></blockquote> <p><strong>应用层的主要对象是 DO 对象</strong>. 如果需要调用其它微服务的应用服务, DO 会转换为 DTO, 完成跨微服务的数据组装和传输. 用户接口层先完成 DTO 到 DO 的转换, 然后应用服务接收 DO 进行业务处理. 如果 DTO 与 DO 是一对多的关系, 这时就需要进行 DO 数据重组.</p> <blockquote><p>用户接口层</p></blockquote> <p><strong>用户接口层会完成 DO 和 DTO 的互转, 完成微服务与前端应用数据交互及转换</strong>. Facade 服务会对多个 DO 对象进行组装, 转换为 DTO 对象, 向前端应用完成数据转换和传输.</p> <blockquote><p>前端应用</p></blockquote> <p><strong>前端应用主要是 VO 对象</strong>. 展现层使用 VO 进行界面展示, 通过用户接口层与应用层采用 DTO 对象进行数据交互.</p> <h5 id="总结-16"><a href="#总结-16" class="header-anchor">#</a> 总结</h5> <p>今天分析了 DDD 分层架构下微服务的服务和数据的协作关系. 为了实现聚合之间以及微服务各层之间的解耦, 在每层定义了不同职责的服务和数据对象. 在软件开发过程中, 需要严格遵守各层服务和数据的职责要求, 各据其位, 各司其职. 这样才能保证核心领域模型的稳定, 同时也可以灵活应对外部需求的快速变化.</p> <h4 id="_17-从后端到前端-微服务后-前端如何设计"><a href="#_17-从后端到前端-微服务后-前端如何设计" class="header-anchor">#</a> 17-从后端到前端:微服务后,前端如何设计?</h4> <p>微服务架构通常采用前后端分离的设计方式. 作为企业级的中台, 在完成单体应用拆分和微服务建设后, 前端项目团队会同时面对多个中台微服务项目团队, 这时候的前端人员就犹如维修电工一样了.</p> <p>面对如此多的微服务暴露出来的 API 服务, 如何进行正确的连接和拼装, 才能保证不出错? 这显然不是一件很容易的事情. 而当服务出现变更时, 又如何通知所有受影响的项目团队, 这里面的沟通成本相信也不小.</p> <p>相应的, 要从一定程度上解决上述问题, 是不是可以考虑先有效<strong>降低前端集成的复杂度</strong>呢? 先做到前端聚合, 后端解耦——这是一个很有意思的话题. 今天就一起来聊聊<strong>微前端(Micro Frontend)的设计思想, 探讨一下中台微服务后, 前后端的设计和集成方式</strong>.</p> <h5 id="单体前端的困境"><a href="#单体前端的困境" class="header-anchor">#</a> 单体前端的困境</h5> <p>传统企业在完成中台转型后, 虽然后台的业务完成了微服务架构的升级, 但前端仍然是单体模式, 由一个团队创建并维护一个前端应用. 随着时间推移和业务发展, 前端会变得越来越臃肿, 越来越难维护. 而随着 5G 和移动互联技术的应用, 企业业务活动将会进一步移动化和线上化. 过去很多企业的做法是为不同的业务开发出独立的 APP. 但很显然用户并不想装那么多的 APP!</p> <p>为了提高用户体验, 实现统一运营, 很多企业开始缩减和整合 APP, <strong>将企业内所有的业务能力都尽量集中到一个 APP 中</strong>. 试想如果仍然沿用单体前端的设计模式. 前端项目团队将面对多个中台微服务团队, 需要集成成千上万的 API 服务, 这就需要相当高的沟通成本和技术要求. 这绝对会是一场灾难.</p> <p>相对互联网企业而言, 传统企业的渠道应用更加多样化, 有面向内部人员的门店类应用, 面向外部客户的互联网电商平台或移动 APP, 还有面向第三方的 API 集成. 由于渠道的差异, 前端将更加多样化和复杂化. 那如何有效降低前端集成的复杂度呢?</p> <h5 id="从单体前端到微前端"><a href="#从单体前端到微前端" class="header-anchor">#</a> 从单体前端到微前端</h5> <p>为了解决单体前端的问题, 可以借鉴微服务的设计思想, 引入<strong>微前端概念</strong>. 将微服务理念扩展到前端, 解决中台微服务化后, 前端由于仍为单体而存在的逻辑复杂和臃肿的问题.</p> <p>在前端设计时我们需要遵循单一职责和复用原则, 按照领域模型和微服务边界, 将前端页面进行拆分. 同时构建多个可以独立部署, 完全自治, 松耦合的页面组合, 其中每个组合只负责特定业务单元的 UI 元素和功能, 这些页面组合就是微前端.</p> <p>微前端与微服务一样, 都是希望将单体应用, 按照规则拆分, 并重组为多个可以独立开发, 独立测试, 独立部署和独立运维, 松耦合的微前端或者微服务. 以适应业务快速变化及分布式多团队并行开发的要求.</p> <p>微前端页面只包括业务单元前端操作必需的页面要素, 它只是企业级完整业务流程中的一个业务拼图块, 不包含页面导航等内容. 微前端除了可以实现前端页面的解耦外, 还可实现页面复用, 这也与中台服务共享理念是一脉相承的.</p> <h5 id="业务单元的组合形态"><a href="#业务单元的组合形态" class="header-anchor">#</a> 业务单元的组合形态</h5> <p><strong>可以参照领域模型和微服务边界, 建立与微服务对应的前端操作界面, 将它与微服务组成业务单元, 以业务组件的方式对外提供服务. 业务单元包括微前端和微服务, 可以独立开发, 测试, 部署和运维, 可以自包含地完成领域模型中部分或全部的业务功能</strong>.</p> <p>看一下下面这个图. 一个虚框就是一个业务单元, 微前端和微服务独立部署, 业务单元内的微前端和微服务已完成前后端集成. 可以将这个业务单元理解为一个特定业务领域的组件. 业务单元可以有多种组合方式, 以实现不同的业务目标.</p> <p><img src="/img/da8658ae734e5471bdcf5cf2ff2e659c-20230731163226-3hmkqdg.png" alt=""></p> <h6 id="_1-单一业务单元"><a href="#_1-单一业务单元" class="header-anchor">#</a> 1.单一业务单元</h6> <p><strong>一个微前端和一个微服务组成单一业务单元</strong>. 微前端和微服务分别实现同一个领域模型从前端到后端的功能.</p> <h6 id="_2-组合业务单元"><a href="#_2-组合业务单元" class="header-anchor">#</a> 2.组合业务单元</h6> <p>一个微前端与多个微服务组成组合业务单元. 微前端具有多个微服务的前端功能, 完成较复杂的页面和操作. 多个微服务实现各自领域模型的功能, 向微前端提供可组合的服务.</p> <p>记住一点: 微前端不宜与过多的微服务组合, 否则容易变成单体前端.</p> <h6 id="_3-通用共享业务单元"><a href="#_3-通用共享业务单元" class="header-anchor">#</a> 3.通用共享业务单元</h6> <p>一个微前端与一个或多个通用中台微服务组合为通用共享业务单元. 通用共享微前端以共享页面的方式与其它微前端页面协作, 完成业务流程. 很多通用中台微服务的微前端是共享的, 比如订单和支付等微服务对应的订单和支付微前端界面.</p> <p>所有业务单元的功能都应该自包含, 业务单元之间的边界清晰. 业务单元之间要避免功能交叉而出现耦合, 一旦出现就会影响项目团队职责边界, 进而影响到业务单元独立开发, 测试, 部署和运维等.</p> <h5 id="微前端的集成方式"><a href="#微前端的集成方式" class="header-anchor">#</a> 微前端的集成方式</h5> <p>看一下下面这个图, 微前端位于前端主页面和微服务之间, 它需要与两者完成集成.</p> <p><img src="/img/37faea8b05146526f04c2396d3086e2b-20230731163226-flizc6k.png" alt=""></p> <h6 id="_1-微前端与前端主页面的集成"><a href="#_1-微前端与前端主页面的集成" class="header-anchor">#</a> 1.微前端与前端主页面的集成</h6> <p><strong>前端主页面是企业级的前端页面, 微前端是业务单元的前端页面</strong>. 微前端通过主页面的微前端加载器, 利用页面路由和动态加载等技术, 将特定业务单元的微前端页面动态加载到前端主页面, 实现前端主页面与微前端页面的&quot;拼图式&quot;集成.</p> <p>微前端完成开发, 集成和部署后, 在前端主页面完成微前端注册以及页面路由配置, 即可实现动态加载微前端页面.</p> <h6 id="_2-微前端与微服务的集成"><a href="#_2-微前端与微服务的集成" class="header-anchor">#</a> 2.微前端与微服务的集成</h6> <p><strong>微前端与微服务独立开发, 独立部署</strong>. 在微前端注册到前端主页面前, 微前端需要与微服务完成集成. 它的集成方式与传统前后端分离的集成方式没有差异. 微服务将服务发布到 API 网关, 微前端调用发布在 API 网关中的服务, 即完成业务单元内的前后端集成.</p> <h5 id="团队职责边界"><a href="#团队职责边界" class="header-anchor">#</a> 团队职责边界</h5> <p>当采用业务单元化的开发方式后, 前后端项目团队职责和应用边界会更清晰, 可以降低前后端集成的复杂度. 看一下前中台团队的职责分工.</p> <p><strong>前端项目团队专注于前端集成主页面与微前端的集成, 完成前端主页面的企业级主流程的页面和流程编排以及微前端页面的动态加载, 确保主流程业务逻辑和流程正确</strong>. 前端项目除了要负责企业内页面风格的整体风格设计, 业务流程的流转和控制外, 还需要负责微前端页面动态加载, 微前端注册, 页面路由和页面数据共享等前端技术的实现.</p> <p><strong>中台项目团队完成业务单元组件的开发, 测试和集成, 确保业务单元内的业务逻辑, 页面和流程正确, 向外提供包含页面逻辑和业务逻辑的业务单元组件</strong>.</p> <p>这样, 前端项目团队只需要完成企业级前端主页面与业务单元的融合, 前端只关注前端主页面与微前端页面之间的集成. 这样就可以降低前端团队的技术敏感度, 团队的沟通成本和集成复杂度, 提高交付效率和用户体验.</p> <p>中台项目团队关注业务单元功能的完整性和自包含能力, 完成业务单元内微服务和微前端开发, 集成和部署, 提供业务单元组件. 这样, 业务单元的微前端与微服务的集成就会由一个中台团队完成, 熟悉的人干熟悉的事情, 可以降低集成过程中的沟通和技术成本, 加快开发效率.</p> <h5 id="一个有关保险微前端设计的案例"><a href="#一个有关保险微前端设计的案例" class="header-anchor">#</a> 一个有关保险微前端设计的案例</h5> <p>保险公司有很多面向不同场景的保险产品, 由于业务场景不同, 其核心领域模型就会有差异, 在页面要素, 业务规则和流程等方面前端界面也会不同. 为了避免领域模型差异较大的产品之间的相互影响和干扰, 可以将相似的领域模型的保险产品聚合在一起, 完成核心中台设计.</p> <p>那有的保险集团为了统一运营, 会实现寿险, 财险等集团化的全险种销售. 这样前端项目团队就需要用一个前端应用, 集成非常多的不同产品的核心中台微服务, 前端应用与中台微服务之间的集成将会更复杂.</p> <p>**如果仍然采用传统的单体前端模式, 将会面临比较大的困难. **</p> <p>第一是前端页面开发和设计的复杂性. 以录单前端为例, 如果用一个前端页面来适配全险种, 由于不同产品的前端页面要素不同, 需要妥协并兼容所有产品界面的差异, 这会增加前端开发的复杂度, 也影响用户体验. 而如果为每类产品开发不同的前端, 前端项目团队需要在页面开发和设计上, 投入巨大的工作量.</p> <p>第二是前端与微服务集成的复杂性. 在前端与微服务集成时, 前端项目团队需要了解所有产品的 API 详细信息, 完成前端与微服务的集成, 还要根据主页面流程, 实现不同产品的 API 服务路由. 大量的 API 服务集成和服务路由, 会增加系统集成的复杂度和出错的概率.</p> <p>第三是前后端软件版本的协同发布. 关联的应用多了以后, 一旦某一个中台微服务的 API 服务出现重大调整, 就需要协调所有受影响的应用同时完成版本发布, 频繁的版本发布会影响不同产品的正常运营.</p> <p>那如何用一个前端应用实现全险种产品销售呢? 怎样设计才能降低集成的复杂度, 实现前端界面融合, 后端中台解耦呢?</p> <p>看一下下面这个图. 我们借鉴了电商的订单模式实现保险产品的全险种订单化销售, <strong>在一个前端主页面可以将所有业务流程和业务操作无缝串联起来</strong>. 虽然后端有很多业务单元(包含微服务和微前端), 但用户始终感觉是在一个前端应用中操作.</p> <p>要在一个前端应用中实现全险种销售, 需要完成以下内容的设计.</p> <p><img src="/img/bc7be914dfe30d385b2b8cf7ba87af7d-20230731163226-h5542y9.png" alt=""></p> <h6 id="_1-微服务"><a href="#_1-微服务" class="header-anchor">#</a> 1.微服务</h6> <p>微服务分为两类, 一类是核心中台微服务, 包括: 投保微服务, 实现核心出单业务逻辑; 另一类是通用中台微服务, 包括如: 商品, 订单, 购物车和支付等微服务, 实现通用共享业务逻辑.</p> <h6 id="_2-微前端"><a href="#_2-微前端" class="header-anchor">#</a> 2.微前端</h6> <p><strong>每个微服务都有自己的微前端页面, 实现领域模型的微服务前端页面操作</strong>. 核心中台投保微服务有出单微前端. 订单, 商品以及支付微服务都有自己的微前端页面.</p> <h6 id="_3-业务单元"><a href="#_3-业务单元" class="header-anchor">#</a> 3.业务单元</h6> <p><strong>微服务与微前端组合为一个业务单元</strong>. 由一个中台团队完成业务单元的开发, 集成, 测试和部署, 确保业务单元内页面操作和业务逻辑正确. 比如: 投保微服务和出单微前端组合为投保业务单元, 独立完成保险产品从前端到后端的投保业务.</p> <h6 id="_4-前端主页面"><a href="#_4-前端主页面" class="header-anchor">#</a> 4.前端主页面</h6> <p>前端主页面类似门户, 包括页面导航以及部分通用的常驻主页面的共享页面, 比如购物车. 前端主页面和所有微前端应统一界面风格, 符合统一的前端集成规范. 按照正确的业务逻辑和规则, 动态加载不同业务单元的微前端页面. 前端主页面作为一个整体, 协调核心和通用业务单元的微前端页面, 完成业务操作和业务流程, 提供全险种销售接触界面, 包括商品目录, 录单, 购物车, 订单, 支付等操作.</p> <h6 id="_5-业务流程说明"><a href="#_5-业务流程说明" class="header-anchor">#</a> 5.业务流程说明</h6> <p>简要说明一下用户在前端主页面的投保的主要业务流程.</p> <ol><li>第 1 步: 用户在前端主页面, 从商品目录微前端页面, 选择保险产品.</li> <li>第 2 步: 前端主页面根据选择的产品, 从主页面配置数据中, 获取产品出单微前端路由地址. 加载出单微前端页面, 完成录单, 投保微服务实现投保业务逻辑, 在业务单元内生成投保单.</li> <li>第 3 步: 加载购物车微前端, 将投保单加入购物车.</li> <li>第 4 步: 重复 1-3 步, 生成多个投保单.</li> <li>第 5 步: 从购物车微前端中选择多个投保单, 加载订单微前端, 生成订单.</li> <li>第 6 步: 加载支付微前端, 完成支付.</li> <li>第 7 步: 在投保微服务中, 将订单中的投保单生成保单.</li></ol> <p>虽然后端有很多业务单元在支持, 但用户所有的页面操作和流转是在一个前端主页面完成的. 在进行全险种的订单化销售时, 用户始终感觉是在操作一个系统. 这种设计方式很好地体现了前端的融合和中台的解耦.</p> <h5 id="总结-17"><a href="#总结-17" class="header-anchor">#</a> 总结</h5> <p>今天主要探讨了微前端的设计方法. 虽然微前端和微服务也采用前后端分离的设计方式, 但在业务单元内, 它们是在<strong>同一个领域模型下, 分别实现前端和后端的业务逻辑, 对外提供组件化的服务</strong>.</p> <p>微前端和业务单元化的设计模式可以减轻企业级中台, 前后端应用开发和集成的复杂度, 真正实现前端融合和中台解耦. 它的主要价值和意义如下:</p> <ul><li><strong>1.前端集成简单</strong>: 前端项目只需关注前端集成主页面与微前端的集成, 实现模块化集成和拼图式的开发, 降低前端集成的复杂度和成本.</li> <li><strong>2.项目职责专一</strong>: 中台项目从数据库, 中台微服务到微前端界面, 端到端地完成领域逻辑功能开发, 以业务组件的方式整体提供服务. 在业务单元内, 由团队自己完成前后端集成, 可以降低开发和集成团队的沟通成本和集成复杂度.</li> <li><strong>3.隔离和依赖性</strong>: 业务单元在代码, 逻辑和物理边界都是隔离的, 可降低应用之间的依赖性. 出现问题时可快速定位和修复, 问题可以控制在一个业务单元内. 业务单元之间相互无影响.</li> <li><strong>4.降低沟通和测试成本</strong>: 中台团队实现从微前端页面到中台微服务的业务单元逻辑, 实现业务单元的开发, 测试, 集成和部署的全流程和全生命周期管理, 降低前后端集成的测试和沟通成本.</li> <li><strong>5.更敏捷地发布</strong>: 业务单元之间有很好的隔离性和依赖性低, 业务单元的变化都可以被控制在业务单元内. 项目团队可以独立按照自己的步调进行迭代开发, 实现更快的发布周期. 版本发布时不会影响其它业务单元的正常运行.</li> <li><strong>6.降低技术敏感性</strong>: 前端项目关注前端主页面与微前端的集成. 降低了前端项目团队对中台微服务技术的敏感性. 中台项目团队可以更独立地尝试新技术和架构, 实现架构的演进.</li> <li><strong>7.高度复用性</strong>: 微前端和中台微服务都有高度的复用性. 微前端可快速加载到多个 APP, 还可以将一个微前端直接发布为 APP 或微信小程序, 实现灵活的前端组合, 复用和快速发布.</li></ul> <h4 id="_18-知识点串讲-基于ddd的微服务设计实例"><a href="#_18-知识点串讲-基于ddd的微服务设计实例" class="header-anchor">#</a> 18-知识点串讲:基于DDD的微服务设计实例</h4> <p>为了更好地理解 DDD 的设计流程, 今天会用一个项目来带你了解 DDD 的战略设计和战术设计, <strong>走一遍从领域建模到微服务设计的全过程, 一起掌握 DDD 的主要设计流程和关键点</strong>.</p> <h5 id="项目基本信息"><a href="#项目基本信息" class="header-anchor">#</a> 项目基本信息</h5> <p>项目的目标是实现<strong>在线请假和考勤管理</strong>. 功能描述如下:</p> <ul><li>请假人填写请假单提交审批, 根据请假人身份, 请假类型和请假天数进行校验, 根据审批规则逐级递交上级审批, 逐级核批通过则完成审批, 否则审批不通过退回申请人.</li> <li>根据考勤规则, 核销请假数据后, 对考勤数据进行校验, 输出考勤统计.</li></ul> <h5 id="战略设计"><a href="#战略设计" class="header-anchor">#</a> 战略设计</h5> <p>战略设计是根据用户旅程分析, 找出领域对象和聚合根, 对实体和值对象进行聚类组成聚合, 划分限界上下文, 建立领域模型的过程.</p> <p>战略设计采用的方法是事件风暴, 包括: <strong>产品愿景, 场景分析, 领域建模和微服务拆分</strong>等几个主要过程.</p> <p>战略设计阶段建议参与人员: 领域专家, 业务需求方, 产品经理, 架构师, 项目经理, 开发经理和测试经理.</p> <h6 id="_1-产品愿景-2"><a href="#_1-产品愿景-2" class="header-anchor">#</a> 1.产品愿景</h6> <p>产品愿景是对产品顶层价值设计, 对产品目标用户, 核心价值, 差异化竞争点等信息达成一致, 避免产品偏离方向.</p> <p>事件风暴时, 所有参与者针对每一个要点, 在贴纸上写出自己的意见, 贴到白板上. 事件风暴主持者会对每个贴纸, 讨论并对发散的意见进行收敛和统一, 形成下面的产品愿景图.</p> <p><img src="/img/caec0d9262a1c0038a7799a49784dedc-20230731163226-amzbvu0.png" alt=""></p> <p><strong>把这个产品愿景图整理成一段文字就是:</strong>  为了满足内外部人员, 他们的在线请假, 自动考勤统计和外部人员管理的需求, 我们建设这个在线请假考勤系统, 它是一个在线请假平台, 可以自动考勤统计. 它可以同时支持内外网请假, 同时管理内外部人员请假和定期考勤分析, 而不像 HR 系统, 只管理内部人员, 且只能内网使用. 我们的产品内外网皆可使用, 可实现内外部人员无差异管理.</p> <p>通过产品愿景分析, 项目团队统一了系统名称---在线请假考勤系统, 明确了项目目标和关键功能, 与竞品(HR)的关键差异以及自己的优势和核心竞争力等.</p> <p>产品愿景分析对于初创系统明确系统建设重点, 统一团队建设目标和建立通用语言是很有价值的. 但如果你的系统目标和需求非常清晰, 这一步可以忽略.</p> <h6 id="_2-场景分析"><a href="#_2-场景分析" class="header-anchor">#</a> 2.场景分析</h6> <p>场景分析是从用户视角出发, 探索业务领域中的典型场景, 产出领域中需要支撑的场景分类, 用例操作以及不同子域之间的依赖关系, 用以支撑领域建模.</p> <p>项目团队成员一起用事件风暴分析请假和考勤的用户旅程. <strong>根据不同角色的旅程和场景分析, 尽可能全面地梳理从前端操作到后端业务逻辑发生的所有操作, 命令, 领域事件以及外部依赖关系</strong>等信息.</p> <p><strong>下面就以请假和人员两个场景作为示例.</strong></p> <p>第一个场景: 请假</p> <p>用户: 请假人</p> <ol><li>请假人登录系统: 从权限微服务获取请假人信息和权限数据, 完成登录认证.</li> <li>创建请假单: 打开请假页面, 选择请假类型和起始时间, 录入请假信息. 保存并创建请假单, 提交请假审批.</li> <li>修改请假单: 查询请假单, 打开请假页面, 修改请假单, 提交请假审批.</li> <li>提交审批: 获取审批规则, 根据审批规则, 从人员组织关系中获取审批人, 给请假单分配审批人.</li></ol> <p>第二个场景: 审批</p> <p>用户: 审批人</p> <ol><li>审批人登录系统: 从权限微服务获取审批人信息和权限数据, 完成登录认证.</li> <li>获取请假单: 获取审批人名下请假单, 选择请假单.</li> <li>审批: 填写审批意见.</li> <li>逐级审批: 如果还需要上级审批, 根据审批规则, 从人员组织关系中获取审批人, 给请假单分配审批人. 重复以上 4 步.</li> <li>最后审批人完成审批.</li></ol> <p>完成审批后, 产生请假审批已通过<strong>领域事件</strong>. 后续有两个进一步的业务操作: <strong>发送请假审批已通过的通知, 通知邮件系统告知请假人; 将请假数据发送到考勤以便核销</strong>.</p> <p><img src="/img/8be84242c56f73b4cf119484c0ee8f57-20230731163226-gfr18io.png" alt=""></p> <p>下面这个图是人员组织关系场景分析结果图, 详细的分析过程以及考勤的场景分析就不描述了.</p> <p><img src="/img/7c4a17d6aff1ff445e10f75e1978f9ad-20230731163226-wukuc8u.png" alt=""></p> <h6 id="_3-领域建模-2"><a href="#_3-领域建模-2" class="header-anchor">#</a> 3.领域建模</h6> <p><strong>领域建模是通过对业务和问题域进行分析, 建立领域模型</strong>. 向上通过限界上下文指导微服务边界设计, 向下通过聚合指导实体对象设计.</p> <p>领域建模是一个收敛的过程, 分三步:</p> <ol><li>第一步找出<strong>领域实体和值对象等领域对象</strong>;</li> <li>第二步找出<strong>聚合根, 根据实体, 值对象与聚合根的依赖关系, 建立聚合</strong>;</li> <li>第三步根据业务及语义边界等因素, 定义限界上下文.</li></ol> <p>下面就逐步详细讲解一下.</p> <blockquote><p>第一步: 找出实体和值对象等领域对象</p></blockquote> <p>根据场景分析, 分析并找出发起或产生这些<strong>命令或领域事件的实体和值对象</strong>. 将与实体或值对象有关的命令和事件聚集到实体.</p> <p>下面这个图是分析后的实体与命令的关系. 通过分析找到了: 请假单, 审批意见, 审批规则, 人员, 组织关系, 刷卡明细, 考勤明细以及考勤统计等<strong>实体和值对象</strong>.</p> <p><img src="/img/d615a8fdffcbfd13629e00cd096877b8-20230731163226-5kk7n2s.png" alt=""></p> <blockquote><p>第二步: 定义聚合</p></blockquote> <p><strong>定义聚合前, 先找出聚合根</strong>. 从上面的实体中, 可以找出 &quot;请假单&quot; 和 &quot;人员&quot; 两个聚合根. 然后找出与聚合根紧密依赖的实体和值对象. 可以发现审批意见, 审批规则和请假单紧密关联, 组织关系和人员紧密关联.</p> <p>找出这些实体的关系后, 发现还有刷卡明细, 考勤明细和考勤统计, 这几个实体没有聚合根. 这种情形在领域建模时你会经常遇到, 对于这类场景需要分情况特殊处理.</p> <p>刷卡明细, 考勤明细和考勤统计这几个实体, 它们之间<strong>相互独立, 找不出聚合根, 不是富领域模型</strong>, 但它们一起完成考勤业务逻辑, 具有很高的<strong>业务内聚性</strong>. 可以将这几个业务关联紧密的实体, 放在一个<strong>考勤聚合内</strong>. 在微服务设计时, 依然采用 DDD 的设计和分析方法. 由于没有聚合根来管理聚合内的实体, 可以用传统的方法来管理实体.</p> <p>经过分析, 我们建立了<strong>请假, 人员组织关系和考勤</strong>三个聚合. 其中请假聚合有请假单, 审批意见实体和审批规则等值对象. 人员组织关系聚合有人员和组织关系等实体. 考勤聚合有刷卡明细, 考勤明细和考勤统计等实体.</p> <p><img src="/img/420d7365e5b8165dda4a80f111fffa0b-20230731163226-p6cnkom.png" alt=""></p> <blockquote><p>第三步: 定义限界上下文</p></blockquote> <p>由于人员组织关系聚合与请假聚合, 共同完成请假的业务功能, 两者在请假的限界上下文内. 考勤聚合则单独构成考勤统计限界上下文. 因此为业务划分<strong>请假和考勤统计两个限界上下文, 建立请假和考勤两个领域模型</strong>.</p> <h6 id="_4-微服务的拆分"><a href="#_4-微服务的拆分" class="header-anchor">#</a> 4.微服务的拆分</h6> <p>理论上一个限界上下文就可以设计为一个微服务, 但还需要综合考虑多种外部因素, 比如: 职责单一性, 敏态与稳态业务分离, 非功能性需求(如弹性伸缩, 版本发布频率和安全等要求), 软件包大小, 团队沟通效率和技术异构等非业务要素.</p> <p>在这个项目, 划分微服务主要考虑<strong>职责单一性原则</strong>. 因此根据限界上下文就可以拆分为<strong>请假和考勤两个微服务</strong>. 其中请假微服务包含人员组织关系和请假两个聚合, 考勤微服务包含考勤聚合.</p> <p>到这里, 战略设计就结束了. 通过战略设计, 建立了领域模型, 划分了微服务边界. 下一步就是<strong>战术设计</strong>了, 也就是微服务设计. 下面以请假微服务为例, 讲解其设计过程.</p> <h5 id="战术设计"><a href="#战术设计" class="header-anchor">#</a> 战术设计</h5> <p><strong>战术设计是根据领域模型进行微服务设计的过程</strong>. 这个阶段主要梳理微服务内的领域对象, 梳理领域对象之间的关系, 确定它们在代码模型和分层架构中的位置, 建立领域模型与微服务模型的映射关系, 以及服务之间的依赖关系.</p> <p>战术设计阶段建议参与人员: 领域专家, 产品经理, 架构师, 项目经理, 开发经理和测试经理等.</p> <p>战术设计包括以下两个阶段: 分析微服务领域对象和设计微服务代码结构.</p> <h6 id="_1-分析微服务领域对象"><a href="#_1-分析微服务领域对象" class="header-anchor">#</a> 1.分析微服务领域对象</h6> <p>领域模型有很多领域对象, 但是这些对象带有比较重的业务属性. 要完成从领域模型到微服务的落地, 还需要进一步的分析和设计. 在事件风暴基础上, 进一步细化领域对象以及它们的关系, 补充事件风暴可能遗漏的业务和技术细节.</p> <p>我们分析微服务内应该<strong>有哪些服务? 服务的分层? 应用服务由哪些服务组合和编排完成? 领域服务包括哪些实体和实体方法? 哪个实体是聚合根? 实体有哪些属性和方法? 哪些对象应该设计为值对象</strong>等.</p> <blockquote><p>服务的识别和设计</p></blockquote> <p>事件风暴的命令是外部的一些操作和业务行为, 也是微服务对外提供的能力. 它往往与微服务的应用服务或者领域服务对应. 可以将命令作为服务识别和设计的起点. 具体步骤如下:</p> <ol><li>根据命令设计应用服务, 确定应用服务的功能, 服务集合, 组合和编排方式. 服务集合中的服务包括领域服务或其它微服务的应用服务.</li> <li>根据应用服务功能要求设计领域服务, 定义领域服务. 这里需要注意: 应用服务可能是由多个聚合的领域服务组合而成的.</li> <li>根据领域服务的功能, 确定领域服务内的实体以及功能.</li> <li>设计实体基本属性和方法.</li></ol> <p>另外, 还要考虑<strong>领域事件的异步化处理</strong>.</p> <p>以提交审批这个动作为例, 来说明服务的识别和设计. 提交审批的大体流程是:</p> <ol><li>根据请假类型和时长, 查询请假审批规则, 获取下一步审批人的角色.</li> <li>根据审批角色从人员组织关系中查询下一审批人.</li> <li>为请假单分配审批人, 并将审批规则保存至请假单.</li> <li>通过分析, 我们需要在应用层和领域层设计以下服务和方法.</li></ol> <p>**应用层: **提交审批应用服务.</p> <p><strong>领域层:</strong>  领域服务有查询审批规则, 修改请假流程信息服务以及根据审批规则查询审批人服务, 分别位于请假和人员组织关系聚合. 请假单实体有修改请假流程信息方法, 审批规则值对象有查询审批规则方法. 人员实体有根据审批规则查询审批人方法. 下图是分析出来的服务以及它们之间的依赖关系.</p> <p><img src="/img/c120f902fb7e1623f2982b488444cf12-20230731163226-7pe8249.png" alt=""></p> <p>服务的识别和设计过程就是这样了, 再来设计一下聚合内的对象.</p> <blockquote><p>聚合中的对象</p></blockquote> <p>在请假单聚合中, 聚合根是请假单.</p> <p>请假单经多级审核后, 会产生多条审批意见, 为了方便查询, 可以将审批意见设计为实体. 请假审批通过后, 会产生请假审批通过的领域事件, 因此还会有请假事件实体. 请假聚合有以下实体: 审批意见(记录审批人, 审批状态和审批意见)和请假事件实体.</p> <p>再来分析一下请假单聚合的值对象. 请假人和下一审批人数据来源于人员组织关系聚合中的人员实体, 可设计为值对象. 人员类型, 请假类型和审批状态是枚举值类型, 可设计为值对象. 确定请假审批规则后, 审批规则也可作为请假单的值对象. 请假单聚合将包含以下值对象: 请假人, 人员类型, 请假类型, 下一审批人, 审批状态和审批规则.</p> <p>综上, 就可以画出请假聚合对象关系图了.</p> <p><img src="/img/51913eed9374d832197964549b4dceb7-20230731163226-ghd4m2e.png" alt=""></p> <p>在人员组织关系聚合中, 可以建立人员之间的组织关系, 通过组织关系类型找到上级审批领导. 它的<strong>聚合根是人员</strong>. 实体有组织关系(包括组织关系类型和上级审批领导). 其中组织关系类型(如项目经理, 处长, 总经理等)是值对象. 上级审批领导来源于人员聚合根, 可设计为值对象. 人员组织关系聚合将包含以下值对象: 组织关系类型, 上级审批领导.</p> <p>综上, 又可以画出人员组织关系聚合对象关系图了.</p> <p><img src="/img/32fc4e6840127ed1fb6cadfef449f156-20230731163226-rl6liaj.png" alt=""></p> <blockquote><p>微服务内的对象清单</p></blockquote> <p>在确定各领域对象的属性后, 就可以设计各领域对象在代码模型中的<strong>代码对象</strong>(包括代码对象的包名, 类名和方法名), 建立<strong>领域对象与代码对象的一一映射关系</strong>了. 根据这种映射关系, 相关人员可快速定位到业务逻辑所在的代码位置. 在经过以上分析后, 在微服务内就可以分析出如下图的对象清单.</p> <p><img src="/img/d22c6f4d80ea55fb68038035ef2afd64-20230731163226-7fugge9.png" alt=""></p> <h6 id="_2-设计微服务代码结构"><a href="#_2-设计微服务代码结构" class="header-anchor">#</a> 2.设计微服务代码结构</h6> <p>根据 DDD 的代码模型和各领域对象所在的包, 类和方法, 可以定义出请假微服务的代码结构, 设计代码对象.</p> <blockquote><p>应用层代码结构</p></blockquote> <p>应用层包括: 应用服务, DTO 以及事件发布相关代码. 在 LeaveApplicationService 类内实现与聚合相关的应用服务, 在 LoginApplicationService 封装外部微服务认证和权限的应用服务.</p> <p>这里提醒一下: 如果应用服务逻辑复杂的话, 一个应用服务就可以构建一个类, 这样可以避免一个类的代码过于庞大, 不利于维护.</p> <p><img src="/img/e0a677f5a1d1660ddce1b3a1b5fd7280-20230731163226-vkzgthe.png" alt=""></p> <blockquote><p>领域层代码结构</p></blockquote> <p><strong>领域层包括一个或多个聚合的实体类, 事件实体类, 领域服务以及工厂, 仓储相关代码</strong>. 一个聚合对应一个聚合代码目录, 聚合之间在代码上完全隔离, 聚合之间通过应用层协调.</p> <p>请假微服务领域层包含请假和人员两个聚合. 人员和请假代码都放在各自的聚合所在目录结构的代码包中. 如果随着业务发展, 人员相关功能需要从请假微服务中拆分出来, 只需将人员聚合代码包稍加改造, 独立部署, 即可快速发布为人员微服务. 到这里, 微服务内的领域对象, 分层以及依赖关系就梳理清晰了. 微服务的总体架构和代码模型也基本搭建完成了.</p> <p><img src="/img/42d9bcebd4cfb2ee0534d6f77f4cb6c7-20230731163226-yxa4n8g.png" alt=""></p> <h5 id="后续的工作"><a href="#后续的工作" class="header-anchor">#</a> 后续的工作</h5> <h6 id="_1-详细设计"><a href="#_1-详细设计" class="header-anchor">#</a> 1.详细设计</h6> <p>在完成领域模型和微服务设计后, 还需要对微服务进行详细的设计. 主要设计以下内容: <strong>实体属性, 数据库表和字段, 实体与数据库表映射, 服务参数规约及功能实现等</strong>.</p> <h6 id="_2-代码开发和测试"><a href="#_2-代码开发和测试" class="header-anchor">#</a> 2.代码开发和测试</h6> <p>开发人员只需要按照详细的设计文档和功能要求, 找到业务功能对应的代码位置, 完成代码开发就可以了. 代码开发完成后, 开发人员要编写单元测试用例, 基于挡板模拟依赖对象完成服务测试.</p> <h5 id="总结-18"><a href="#总结-18" class="header-anchor">#</a> 总结</h5> <p>今天通过在线请假考勤项目, 把 DDD 设计过程完整地走了一遍.</p> <p>DDD 战略设计从事件风暴开始, 然后要找出实体等领域对象, 找出聚合根构建聚合, 划分限界上下文, 建立领域模型.</p> <p>战术设计从事件风暴的命令开始, 识别和设计服务, 建立各层服务的依赖关系, 设计微服务内的实体和值对象, 找出微服务中所有的领域对象, 并建立领域对象与代码对象的映射关系.</p> <p>这样就可以很好地指导项目团队进行微服务开发和测试了.</p> <h4 id="_19-总结-一-微服务设计和拆分要坚持哪些原则"><a href="#_19-总结-一-微服务设计和拆分要坚持哪些原则" class="header-anchor">#</a> 19-总结(一):微服务设计和拆分要坚持哪些原则?</h4> <p>前面已经讲了很多 DDD 的设计方法和实践案例. 虽然 DDD 的设计思想和方法很好, 但由于企业发展历程以及企业技术和文化的不同, DDD 和微服务的实施策略也会有差异. 那么面对这种差异, 应该<strong>如何落地 DDD 和微服务</strong>呢? 今天就来聊聊<strong>微服务的设计原则和演进策略</strong>.</p> <h5 id="微服务的演进策略"><a href="#微服务的演进策略" class="header-anchor">#</a> 微服务的演进策略</h5> <p>在从单体向微服务演进时, 演进策略大体分为两种: 绞杀者策略和修缮者策略.</p> <h6 id="_1-绞杀者策略"><a href="#_1-绞杀者策略" class="header-anchor">#</a> 1.绞杀者策略</h6> <p>绞杀者策略是一种<strong>逐步剥离业务</strong>能力, 用微服务逐步替代原有单体系统的策略. 它对单体系统进行领域建模, 根据领域边界, 在单体系统之外, 将新功能和部分业务能力独立出来, 建设独立的微服务. 新微服务与单体系统保持松耦合关系.</p> <p>随着时间的推移, 大部分单体系统的功能将被独立为微服务, 这样就慢慢绞杀掉了原来的单体系统. 绞杀者策略类似建筑拆迁, 完成部分新建筑物后, 然后拆除部分旧建筑物.</p> <h6 id="_2-修缮者策略"><a href="#_2-修缮者策略" class="header-anchor">#</a> 2.修缮者策略</h6> <p>修缮者策略是一种维持原有系统整体能力不变, 逐步优化系统整体能力的策略. 它是<strong>在现有系统的基础上, 剥离影响整体业务的部分功能, 独立为微服务, 比如高性能要求的功能, 代码质量不高或者版本发布频率不一致的功能等</strong>.</p> <p>通过这些功能的剥离, 就可以兼顾整体和局部, 解决系统整体不协调的问题. 修缮者策略类似古建筑修复, 将存在问题的部分功能重建或者修复后, 重新加入到原有的建筑中, 保持建筑原貌和功能不变. 一般人从外表感觉不到这个变化, 但是建筑物质量却得到了很大的提升.</p> <p>其实还有第三种策略, 就是另起炉灶, 顾名思义就是将原有的系统推倒重做. 建设期间, 原有单体系统照常运行, 一般会停止开发新需求. 而新系统则会组织新的项目团队, 按照原有系统的功能域, 重新做领域建模, 开发新的微服务. 在完成数据迁移后, 进行新旧系统切换.</p> <p>对于大型核心系统一般不建议采用这种策略, 这是因为系统重构后的不稳定性, 大量未知的潜在技术风险和新的开发模式下项目团队磨合等不确定性因素, 会导致项目实施难度大大增加.</p> <h5 id="不同场景下的领域建模策略"><a href="#不同场景下的领域建模策略" class="header-anchor">#</a> 不同场景下的领域建模策略</h5> <p>由于企业内情况千差万别, 发展历程也不一样, 有遗留单体系统的微服务改造, 也有全新未知领域的业务建模和系统设计, 还有遗留系统局部优化的情况. 不同场景下, 领域建模的策略也会有差异. 下面就分几类场景来看看如何进行领域建模.</p> <h6 id="_1-新建系统"><a href="#_1-新建系统" class="header-anchor">#</a> 1.新建系统</h6> <p>新建系统又分为简单和复杂领域建模两种场景.</p> <blockquote><p>简单领域建模</p></blockquote> <p>简单的业务领域, 一个领域就是一个小的子域. 在这个小的问题域内, 领域建模过程相对简单, 直接采用事件风暴的方法构建领域模型就可以了.</p> <blockquote><p>复杂领域建模</p></blockquote> <p>对于复杂的业务领域, <strong>领域可能需要多级拆分后才能开始领域建模</strong>. 领域拆分为子域, 甚至子域还需要进一步拆分. 比如: 保险它需要拆分为承保, 理赔, 收付费和再保等子域, 承保子域再拆分为投保, 保单管理等子子域. 复杂领域如果不做进一步细分, 由于问题域太大, 领域建模的工程量会非常浩大. 你不太容易通过事件风暴, 完成一个很大的领域建模, 即使勉强完成, 效果也不一定好.</p> <p><strong>对于复杂领域, 可以分三步来完成领域建模和微服务设计.</strong></p> <p>第一步, 拆分子域建立领域模型</p> <p>根据业务领域的特点, 参考流程节点边界或功能聚合模块等边界因素. 结合领域专家和项目团队的讨论, 将领域逐级分解为大小合适的子域, 针对子域采用事件风暴, 划分聚合和限界上下文, 初步确定子域内的领域模型.</p> <p>第二步, 领域模型微调</p> <p>梳理领域内所有子域的领域模型, 对各子域领域模型进行微调. 微调的过程重点考虑不同领域模型中聚合的重组. 同步考虑领域模型和聚合的边界, 服务以及事件之间的依赖关系, 确定最终的领域模型.</p> <p>第三步, 微服务的设计和拆分</p> <p>根据领域模型和微服务拆分原则, 完成微服务的拆分和设计.</p> <h6 id="_2-单体遗留系统"><a href="#_2-单体遗留系统" class="header-anchor">#</a> 2.单体遗留系统</h6> <p>如果面对的是一个单体遗留系统, 只需要将部分功能独立为微服务, 而其余仍为单体, 整体保持不变, 比如将面临性能瓶颈的模块拆分为微服务. 只需要将这一特定功能, 理解为一个简单子领域, 参考简单领域建模的方式就可以了. 在微服务设计中, 还要考虑新老系统之间服务和业务的兼容, 必要时可引入防腐层.</p> <h5 id="ddd使用的误区"><a href="#ddd使用的误区" class="header-anchor">#</a> DDD使用的误区</h5> <p>很多人在接触微服务后, 但凡是系统, 一概都想设计成微服务架构. 其实有些业务场景, 单体架构的开发成本会更低, 开发效率更高, 采用单体架构也不失为好的选择. 同样, 虽然 DDD 很好, 但有些传统设计方法在微服务设计时依然有它的用武之地. 下面就来聊聊 DDD 使用的几个误区.</p> <h6 id="_1-所有的领域都用ddd"><a href="#_1-所有的领域都用ddd" class="header-anchor">#</a> 1.所有的领域都用DDD</h6> <p>很多人在学会 DDD 后, 可能会将其用在所有业务域, 即全部使用 DDD 来设计. DDD 从战略设计到战术设计, 是一个相对复杂的过程, 首先企业内要培养 DDD 的文化, 其次对团队成员的设计和技术能力要求相对比较高. <strong>在资源有限的情况下, 应聚焦核心域, 建议先从富领域模型的核心域开始, 而不必一下就在全业务域推开</strong>.</p> <h6 id="_2-全部采用ddd战术设计方法"><a href="#_2-全部采用ddd战术设计方法" class="header-anchor">#</a> 2.全部采用DDD战术设计方法</h6> <p>不同的设计方法有它的适用环境, 应选择它最擅长的场景. DDD 有很多的概念和战术设计方法, 比如聚合根和值对象等. 聚合根利用仓储管理聚合内实体数据之间的一致性, 这种方法对于管理新建和修改数据非常有效, 比如在修改订单数据时, 它可以保证订单总金额与所有商品明细金额的一致, 但它<strong>并不擅长较大数据量的查询处理, 甚至有延迟加载进而影响效率的问题</strong>.</p> <p>而传统的设计方法, 可能一条简单的 SQL 语句就可以很快地解决问题. 而很多贫领域模型的业务, 比如<strong>数据统计和分析</strong>, DDD 很多方法可能都用不上, 或用得并不顺手, 而传统的方法很容易就解决了.</p> <p>因此, <strong>在遵守领域边界和微服务分层等大原则下, 在进行战术层面设计时, 应该选择最适合的方法, 不只是 DDD 设计方法, 当然还应该包括传统的设计方法</strong>. 这里要以快速, 高效解决实际问题为最佳, 不要为做 DDD 而做 DDD.</p> <h6 id="_3-重战术设计而轻战略设计"><a href="#_3-重战术设计而轻战略设计" class="header-anchor">#</a> 3.重战术设计而轻战略设计</h6> <p>很多 DDD 初学者, 学习 DDD 的主要目的, 可能是为了开发微服务, 因此更看重 DDD 的战术设计实现. 殊不知 DDD 是一种从领域建模到微服务落地的全方位的解决方案.</p> <p>战略设计时构建的领域模型, 是微服务设计和开发的输入, 它确定了微服务的边界, 聚合, 代码对象以及服务等关键领域对象. 领域模型边界划分得清不清晰, 领域对象定义得明不明确, 会决定微服务的设计和开发质量. 没有领域模型的输入, 基于 DDD 的微服务的设计和开发将无从谈起. 因此我们不仅要重视战术设计, 更要重视战略设计.</p> <h6 id="_4-ddd只适用于微服务"><a href="#_4-ddd只适用于微服务" class="header-anchor">#</a> 4.DDD只适用于微服务</h6> <p>DDD 是在微服务出现后才真正火爆起来的, 很多人会认为 DDD 只适用于微服务. 在 DDD 沉默的二十多年里, 其实它一直也被应用在单体应用的设计中.</p> <p>具体项目实施时, 要吸取 DDD 的核心设计思想和理念, 结合具体的业务场景和团队技术特点, 多种方法组合, 灵活运用, 用正确的方式解决实际问题.</p> <h5 id="微服务设计原则"><a href="#微服务设计原则" class="header-anchor">#</a> 微服务设计原则</h5> <p>微服务设计原则中, 如高内聚低耦合, 复用, 单一职责等这些常见的设计原则在此就不赘述了, 主要强调下面这几条:</p> <blockquote><p>第一条: 要领域驱动设计, 而不是数据驱动设计, 也不是界面驱动设计.</p></blockquote> <p><strong>微服务设计首先应建立领域模型, 确定逻辑和物理边界以及领域对象后, 然后才开始微服务的拆分和设计</strong>. 而不是先定义数据模型和库表结构, 也不是前端界面需要什么, 就去调整核心领域逻辑代码. 在设计时应该将外部需求从外到内逐级消化, 尽量降低对核心领域层逻辑的影响.</p> <blockquote><p>第二条: 要边界清晰的微服务, 而不是泥球小单体.</p></blockquote> <p><strong>微服务上线后其功能和代码也不是一成不变的. 随着需求或设计变化, 领域模型会迭代, 微服务的代码也会分分合合. 边界清晰的微服务, 可快速实现微服务代码的重组</strong>. 微服务内聚合之间的领域服务和数据库实体原则上应杜绝相互依赖. 可通过应用服务编排或者事件驱动, 实现聚合之间的解耦, 以便微服务的架构演进.</p> <blockquote><p>第三条: 要职能清晰的分层, 而不是什么都放的大箩筐.</p></blockquote> <p>分层架构中各层职能定位清晰, 且都只能与其下方的层发生依赖, 也就是说只能从外层调用内层服务, 内层通过封装, 组合或编排对外逐层暴露, 服务粒度也由细到粗. 应用层负责服务的组合和编排, 不应有太多的核心业务逻辑, 领域层负责核心领域业务逻辑的实现. 各层应各司其职, 职责边界不要混乱. 在服务演进时, 应尽量将可复用的能力向下层沉淀.</p> <blockquote><p>第四条: 要做自己能 hold 住的微服务, 而不是过度拆分的微服务.</p></blockquote> <p>微服务过度拆分必然会带来软件维护成本的上升, 比如: 集成成本, 运维成本, 监控和定位问题的成本. 企业在微服务转型过程中还需要有云计算, DevOps, 自动化监控等能力, 而一般企业很难在短时间内提升这些能力, 如果项目团队没有这些能力, 将很难 hold 住这些微服务.</p> <p>如果在微服务设计之初按照 DDD 的战略设计方法, 定义好了微服务内的逻辑边界, 做好了架构的分层, 其实不必拆分太多的微服务, 即使是单体也未尝不可. 随着技术积累和能力提升, 当有了这些能力后, 由于应用内有清晰的逻辑边界, 可以随时轻松地重组出新的微服务, 而这个过程不会花费太多的时间和精力.</p> <h5 id="微服务拆分需要考虑哪些因素"><a href="#微服务拆分需要考虑哪些因素" class="header-anchor">#</a> 微服务拆分需要考虑哪些因素?</h5> <p>理论上一个限界上下文内的领域模型可以被设计为微服务, 但是由于领域建模主要从业务视角出发, 没有考虑非业务因素, 比如需求变更频率, 高性能, 安全, 团队以及技术异构等因素, 而这些非业务因素对于领域模型的系统落地也会起到决定性作用, 因此在微服务拆分时需要重点考虑它们. 下面列出了以下主要因素供你参考.</p> <blockquote><p>1.基于领域模型</p></blockquote> <p><strong>基于领域模型进行拆分, 围绕业务领域按职责单一性, 功能完整性拆分</strong>.</p> <blockquote><p>2.基于业务需求变化频率</p></blockquote> <p>识别领域模型中的业务需求变动频繁的功能, 考虑业务变更频率与相关度, 将业务需求变动较高和功能相对稳定的业务进行分离. 这是因为需求的经常性变动必然会导致代码的频繁修改和版本发布, 这种分离可以有效降低频繁变动的敏态业务对稳态业务的影响.</p> <blockquote><p>3.基于应用性能</p></blockquote> <p><strong>识别领域模型中性能压力较大的功能</strong>. 因为性能要求高的功能可能会拖累其它功能, 在资源要求上也会有区别, 为了避免对整体性能和资源的影响, 可以把在性能方面有较高要求的功能拆分出去.</p> <blockquote><p>4.基于组织架构和团队规模</p></blockquote> <p>除非有意识地优化组织架构, 否则微服务的拆分应尽量避免带来团队和组织架构的调整, 避免由于功能的重新划分, 而增加大量且不必要的团队之间的沟通成本. 拆分后的微服务项目团队规模保持在 10～12 人左右为宜.</p> <blockquote><p>5.基于安全边界</p></blockquote> <p>有特殊安全要求的功能, 应从领域模型中拆分独立, 避免相互影响.</p> <blockquote><p>6.基于技术异构等因素</p></blockquote> <p>领域模型中有些功能虽然在同一个业务域内, 但在技术实现时可能会存在较大的差异, 也就是说领域模型内部不同的功能存在技术异构的问题. 由于业务场景或者技术条件的限制, 有的可能用.NET, 有的则是 Java, 有的甚至大数据架构. 对于这些存在技术异构的功能, 可以考虑按照技术边界进行拆分.</p> <h5 id="总结-19"><a href="#总结-19" class="header-anchor">#</a> 总结</h5> <p>相信你在微服务落地的时候会有很多的收获和感悟. 对于 DDD 和微服务, 我想总结的就是: <mark><strong>深刻理解 DDD 的设计思想和内涵, 把握好边界和分层这个大原则, 结合企业文化和技术特点, 灵活运用战术设计方法, 选择最适合的技术和方法解决实际问题, 切勿为了 DDD 而做 DDD</strong></mark>!</p> <h4 id="_20-总结-二-分布式架构关键设计10问"><a href="#_20-总结-二-分布式架构关键设计10问" class="header-anchor">#</a> 20-总结(二):分布式架构关键设计10问</h4> <p>前面重点讲述了领域建模, 微服务设计和前端设计方法, 它们组合在一起就可以形成中台建设的整体解决方案. 而中台大多基于分布式微服务架构, 这种企业级的数字化转型有很多地方值得我们关注和思考.</p> <p>我们不仅要关注企业商业模式, 业务边界以及前中台的融合, 还要关注数据技术体系, 微服务设计, 多活等多领域的设计和协同. 结合实施经验和思考, 今天就来聊聊<strong>分布式架构下的几个关键问题</strong>.</p> <h5 id="一-选择什么样的分布式数据库"><a href="#一-选择什么样的分布式数据库" class="header-anchor">#</a> 一,选择什么样的分布式数据库?</h5> <p>分布式架构下的数据应用场景远比集中式架构复杂, 会产生很多数据相关的问题. 谈到数据, 首先就是要选择合适的分布式数据库.</p> <p>分布式数据库大多采用数据多副本的方式, 实现数据访问的高性能, 多活和容灾. 目前主要有三种不同的分布式数据库解决方案. 它们的主要差异是<strong>数据多副本的处理方式和数据库中间件</strong>.</p> <h6 id="_1-一体化分布式数据库方案"><a href="#_1-一体化分布式数据库方案" class="header-anchor">#</a> 1.一体化分布式数据库方案</h6> <p>它支持数据多副本, 高可用. 多采用 Paxos 协议, 一次写入多数据副本, 多数副本写入成功即算成功. 代表产品是 OceanBase 和高斯数据库.</p> <h6 id="_2-集中式数据库-数据库中间件方案"><a href="#_2-集中式数据库-数据库中间件方案" class="header-anchor">#</a> 2.集中式数据库+数据库中间件方案</h6> <p>它是<strong>集中式数据库与数据库中间件</strong>结合的方案, 通过数据库中间件实现数据路由和全局数据管理. 数据库中间件和数据库独立部署, 采用数据库自身的同步机制实现主副本数据的一致性. 集中式数据库主要有 MySQL 和 PostgreSQL 数据库, 基于这两种数据库衍生出了很多的解决方案, 比如开源数据库中间件 <strong>MyCat+MySQL 方案</strong>, TBase(基于 PostgreSQL, 但做了比较大的封装和改动)等方案.</p> <h6 id="_3-集中式数据库-分库类库方案"><a href="#_3-集中式数据库-分库类库方案" class="header-anchor">#</a> 3.集中式数据库+分库类库方案</h6> <p>它是一种轻量级的数据库中间件方案, 分库类库实际上是一个基础 JAR 包, 与应用软件部署在一起, 实现数据路由和数据归集. 它适合比较简单的读写交易场景, 在强一致性和聚合分析查询方面相对较弱. 典型分库基础组件有 <strong>ShardingSphere</strong>.</p> <p><strong>小结:</strong>  这三种方案实施成本不一样, 业务支持能力差异也比较大. 一体化分布式数据库主要由互联网大厂开发, 具有超强的数据处理能力, 大多需要云计算底座, 实施成本和技术能力要求比较高. 集中式数据库 + 数据库中间件方案, 实施成本和技术能力要求适中, 可满足中大型企业业务要求. 第三种分库类库的方案可处理简单的业务场景, 成本和技能要求相对较低. 在选择数据库的时候, 要考虑自身能力, 成本以及业务需要, 从而选择合适的方案.</p> <h5 id="二-如何设计数据库分库主键"><a href="#二-如何设计数据库分库主键" class="header-anchor">#</a> 二,如何设计数据库分库主键?</h5> <p>选择了分布式数据库, 第二步就要考虑<strong>数据分库, 这时分库主键</strong>的设计就很关键了.</p> <p>与客户接触的关键业务, 建议以客户 ID 作为分库主键. 这样可以确保同一个客户的数据分布在同一个数据单元内, 避免出现跨数据单元的频繁数据访问. 跨数据中心的频繁服务调用或跨数据单元的查询, 会对系统性能造成致命的影响.</p> <p>将客户的所有数据放在同一个数据单元, 对客户来说也更容易提供客户一致性服务. 而对企业来说, &quot;以客户为中心&quot; 的业务能力, 首先就要做到数据上的 &quot;以客户为中心&quot;.</p> <p>当然也可以根据业务需要用其它的业务属性作为分库主键, 比如机构, 用户等.</p> <h5 id="三-数据库的数据同步和复制"><a href="#三-数据库的数据同步和复制" class="header-anchor">#</a> 三,数据库的数据同步和复制</h5> <p>在微服务架构中, 数据被进一步分割. 为了实现数据的整合, 数据库之间批量数据同步与复制是必不可少的. 数据同步与复制主要用于数据库之间的数据同步, 实现业务数据迁移, 数据备份, 不同渠道核心业务数据向数据平台或数据中台的数据复制, 以及不同主题数据的整合等.</p> <p>传统的数据传输方式有 ETL 工具和定时提数程序, 但数据在时效性方面存在短板. 分布式架构一般采用基于数据库逻辑日志增量数据捕获(CDC)技术, 它可以实现准实时的数据复制和传输, 实现数据处理与应用逻辑解耦, 使用起来更加简单便捷.</p> <p>现在主流的 PostgreSQL 和 MySQL 数据库外围, 有很多<strong>数据库日志捕获技术组件</strong>. CDC 也可以用在领域事件驱动设计中, 作为领域事件增量数据的获取技术.</p> <h5 id="四-跨库关联查询如何处理"><a href="#四-跨库关联查询如何处理" class="header-anchor">#</a> 四,跨库关联查询如何处理?</h5> <p>跨库关联查询是分布式数据库的一个短板, 会影响查询性能. 在领域建模时, 很多实体会分散到不同的微服务中, 但很多时候会因为业务需求, 它们之间需要关联查询.</p> <p>关联查询的业务场景包括两类: 第一类是基于某一维度或某一主题域的数据查询, 比如基于客户全业务视图的数据查询, 这种查询会跨多个业务线的微服务; 第二类是表与表之间的关联查询, 比如机构表与业务表的联表查询, 但机构表和业务表分散在不同的微服务.</p> <p>**如何解决这两类关联查询呢? **</p> <p>对于第一类场景, 由于数据分散在不同微服务里, 无法跨多个微服务来统计这些数据. 可以建立面向主题的分布式数据库, 它的数据来源于不同业务的微服务. 采用数据库日志捕获技术, 从各业务端微服务将数据准实时汇集到主题数据库. 在数据汇集时, 提前做好数据关联(如将多表数据合并为一个宽表)或者建立数据模型. 面向主题数据库建设查询微服务. 这样一次查询就可以获取客户所有维度的业务数据了. 还可以根据主题或场景设计合适的分库主键, 提高查询效率.</p> <p>对于第二类场景, 对于不在同一个数据库的表与表之间的关联查询场景, 可以采用小表广播, 在业务库中增加一张冗余的代码副表. 当主表数据发生变化时, 可以通过消息发布和订阅的领域事件驱动模式, 异步刷新所有副表数据. 这样既可以解决表与表的关联查询, 还可以提高数据的查询效率.</p> <h5 id="五-如何处理高频热点数据"><a href="#五-如何处理高频热点数据" class="header-anchor">#</a> 五,如何处理高频热点数据?</h5> <p>对于高频热点数据, 比如商品, 机构等代码类数据, 它们同时面向多个应用, 要有很高的并发响应能力. 它们会给数据库带来巨大的访问压力, 影响系统的性能.</p> <p>常见的做法是将这些高频热点数据, 从数据库加载到如 Redis 等缓存中, 通过<strong>缓存提供数据访问服务</strong>. 这样既可以降低数据库的压力, 还可以提高数据的访问性能. 另外, 对需要模糊查询的高频数据, 也可以选用 ElasticSearch 等搜索引擎.</p> <p>缓存就像调味料一样, 投入小, 见效快, 用户体验提升快.</p> <h5 id="六-前后序业务数据的处理"><a href="#六-前后序业务数据的处理" class="header-anchor">#</a> 六,前后序业务数据的处理</h5> <p>在微服务设计时你会经常发现, 某些数据需要关联前序微服务的数据. 比如: 在保险业务中, 投保微服务生成投保单后, 保单会关联前序投保单数据等. 在电商业务中, 货物运输单会关联前序订单数据. 由于关联的数据分散在业务的前序微服务中, 你无法通过不同微服务的数据库来给它们建立数据关联.</p> <p>**如何解决这种前后序的实体关联呢? **</p> <p>一般来说, 前后序的数据都跟领域事件有关. 可以通过领域事件处理机制, 按需将前序数据通过领域事件实体, 传输并冗余到当前的微服务数据库中.</p> <p>可以将前序数据设计为实体或者值对象, 并被当前实体引用. 在设计时需要关注以下内容: 如果前序数据在当前微服务只可整体修改, 并且不会对它做查询和统计分析, 可以将它设计为值对象; 当前序数据是多条, 并且需要做查询和统计分析, 可以将它设计为实体.</p> <p>这样, 可以在货物运输微服务, 一次获取前序订单的清单数据和货物运输单数据, 将所有数据一次反馈给前端应用, 降低跨微服务的调用. 如果前序数据被设计为实体, 还可以将前序数据作为查询条件, 在本地微服务完成多维度的综合数据查询. 只有必要时才从前序微服务, 获取前序实体的明细数据. 这样, 既可以保证数据的完整性, 还可以降低微服务的依赖, 减少跨微服务调用, 提升系统性能.</p> <h5 id="七-数据中台与企业级数据集成"><a href="#七-数据中台与企业级数据集成" class="header-anchor">#</a> 七,数据中台与企业级数据集成</h5> <p>分布式微服务架构虽然提升了应用弹性和高可用能力, 但原来集中的数据会随着微服务拆分而形成很多数据孤岛, 增加<strong>数据集成和企业级数据使用的难度</strong>. 可以通过数据中台来实现数据融合, 解决分布式架构下的数据应用和集成问题.</p> <p><strong>可以分三步来建设数据中台.</strong></p> <p>第一, 按照统一数据标准, 完成不同微服务和渠道业务数据的汇集和存储, 解决数据孤岛和初级数据共享的问题.</p> <p>第二, 建立主题数据模型, 按照不同主题和场景对数据进行加工处理, 建立面向不同主题的数据视图, 比如客户统一视图, 代理人视图和渠道视图等.</p> <p>第三, 建立业务需求驱动的数据体系, 支持业务和商业模式创新.</p> <p>数据中台不仅限于分析场景, 也适用于交易型场景. 可以建立在数据仓库和数据平台上, 将数据平台化之后提供给前台业务使用, 为交易场景提供支持.</p> <h5 id="八-bff与企业级业务编排和协同"><a href="#八-bff与企业级业务编排和协同" class="header-anchor">#</a> 八,BFF与企业级业务编排和协同</h5> <p>企业级业务流程往往是多个微服务一起协作完成的, 每个单一职责的微服务就像积木块, 它们只完成自己特定的功能. 那如何组织这些微服务, 完成企业级业务编排和协同呢?</p> <p>可以在微服务和前端应用之间, 增加一层 <strong>BFF 微服务</strong>(Backend for Frontends). <strong>BFF 主要职责是处理微服务之间的服务组合和编排</strong>, 微服务内的应用服务也是处理服务的组合和编排, 那这二者有什么差异呢?</p> <p>BFF 位于中台微服务之上, 主要职责是微服务之间的服务协调; <strong>应用服务主要处理微服务内的服务组合和编排.</strong>  在设计时应尽可能地将可复用的服务能力往下层沉淀, 在实现能力复用的同时, 还可以避免跨中心的服务调用.</p> <p><strong>BFF 像齿轮一样, 来适配前端应用与微服务之间的步调</strong>. 它通过 Façade 服务适配不同的前端, 通过服务组合和编排, 组织和协调微服务. BFF 微服务可根据需求和流程变化, 与前端应用版本协同发布, 避免中台微服务为适配前端需求的变化, 而频繁地修改和发布版本, 从而保证微服务核心领域逻辑的稳定.</p> <p>如果你的 BFF 做得足够强大, 它就是一个集成了不同中台微服务能力, 面向多渠道应用的业务能力平台.</p> <h5 id="九-分布式事务还是事件驱动机制"><a href="#九-分布式事务还是事件驱动机制" class="header-anchor">#</a> 九,分布式事务还是事件驱动机制?</h5> <p>分布式架构下, 原来单体的内部调用, 会变成分布式调用. 如果一个操作涉及多个微服务的数据修改, 就会产生数据一致性的问题. 数据一致性有强一致性和最终一致性两种, 它们实现方案不一样, 实施代价也不一样.</p> <p>对于实时性要求高的强一致性业务场景, 可以采用分布式事务, 但分布式事务有性能代价, <strong>在设计时需平衡考虑业务拆分, 数据一致性, 性能和实现的复杂度, 尽量避免分布式事务的产生</strong>.</p> <p><strong>领域事件驱动的异步方式是分布式架构常用的设计方法, 它可以解决非实时场景的数据最终一致性问题</strong>. 基于消息中间件的领域事件发布和订阅, 可以很好地解耦微服务. 通过削峰填谷, 可以减轻数据库实时访问压力, 提高业务吞吐量和处理能力. 还可以通过事件驱动实现读写分离, 提高数据库访问性能. <strong>对最终一致性的场景, 建议采用领域事件驱动的设计方法</strong>.</p> <h5 id="十-多中心多活的设计"><a href="#十-多中心多活的设计" class="header-anchor">#</a> 十,多中心多活的设计</h5> <p>分布式架构的高可用主要通过多活设计来实现, 多中心多活是一个非常复杂的工程, 下面主要列出以下几个关键的设计.</p> <ol><li><strong>选择合适的分布式数据库</strong>. 数据库应该支持多数据中心部署, 满足数据多副本以及数据底层复制和同步技术要求, 以及数据恢复的时效性要求.</li> <li><strong>单元化架构设计</strong>. 将若干个应用组成的业务单元作为部署的基本单位, 实现同城和异地多活部署, 以及跨中心弹性扩容. 各单元业务功能自包含, 所有业务流程都可在本单元完成; 任意单元的数据在多个数据中心有副本, 不会因故障而造成数据丢失; 任何单元故障不影响其它同类单元的正常运行. 单元化设计时要尽量避免跨数据中心和单元的调用.</li> <li><strong>访问路由</strong>. 访问路由包括接入层, 应用层和数据层的路由, 确保前端访问能够按照路由准确到达数据中心和业务单元, 准确写入或获取业务数据所在的数据库.</li> <li><strong>全局配置数据管理</strong>. 实现各数据中心全局配置数据的统一管理, 每个数据中心全局配置数据实时同步, 保证数据的一致性.</li></ol> <h3 id="结束语"><a href="#结束语" class="header-anchor">#</a> 结束语</h3> <h4 id="结束语-所谓高手-就是跨过坑和大海"><a href="#结束语-所谓高手-就是跨过坑和大海" class="header-anchor">#</a> 结束语-所谓高手,就是跨过坑和大海!</h4> <p>很多人接触 DDD, 可能是从 DDD 战术设计开始的, 因此不知道如何开始 DDD 实践. 这个专栏开启后, 咱们就可以从领域建模开始了. 有了领域模型, 就可以划分出合理的微服务的逻辑和物理边界; 也是因为有了它, 才能识别出微服务内各关键对象, 并建立它们之间的依赖关系, 然后开始微服务的设计和开发.</p> <p>而很多 DDD 和微服务设计的书籍, 大多侧重于讲述 DDD 战术设计或者一些通用的微服务设计模式. 这些书籍大多没有告诉我们: 如何从业务领域开始, 去构建领域模型? 如何用 DDD 的思想, 来指导中台和微服务设计? 如何将领域模型作为输入, 来设计和拆分微服务? 如何将 DDD 知识体系组合起来, 应用到中台和微服务的设计和开发中...</p> <p>这也是本专栏与这些书籍的不同点. 当然, 我并不是说它们不好, 只是各有侧重. 在真正实践的时候, 强大的知识基础自然也是刚需, 你可以把专栏和书籍结合起来学习, 从而发挥最大效能.</p> <p><strong>下面是推荐的几本书, 这些内容是可以和本专栏互补的, 如果你有意愿进一步学习 DDD, 它们是非常好的学习资料.</strong></p> <p><img src="/img/f84f0c37f679f66d00e3200ef9a564b3-20230731163226-ikvmw9p.png" alt=""></p> <p>DDD 是一个相对复杂的方法体系, 它与传统的软件开发模式或者流程存在一定的差异. 在实践 DDD 时, 你可能会遇到一些困难. 企业需要在研发模式上有一定的调整, 同时项目团队也需要提升 DDD 的设计和技术能力, 培养适合 DDD 成长的土壤. 拔高一点看的话, 我觉得你可能会遇到这样<strong>三个大坑</strong>, 下面来说一说我的看法.</p> <h5 id="_1-业务专家或领域专家的问题"><a href="#_1-业务专家或领域专家的问题" class="header-anchor">#</a> 1.业务专家或领域专家的问题</h5> <p>传统企业中业务人员是需求的主要提出者, 但由于部门墙, 他们很少会参与到软件设计和开发过程中. 如果研发模式不调整, 你不要奢望业务人员会主动加入到项目团队中, 一起来完成领域建模. 没有业务人员的参与, 是不是就会觉得没有领域专家, 不能领域建模了呢? 其实并不是这样的.</p> <p>对于成熟业务的领域建模, 可以从团队需求人员或者经验丰富的设计或开发人员中, 挑选出能够深刻理解业务内涵和业务管理要求的人员, 担任领域专家完成领域建模. 对于同时熟悉业务和面向对象设计的项目人员, 这种设计经验尤其重要, 他们可以利用面向对象的设计经验, 更深刻地理解和识别出领域模型的领域对象和业务行为, 有助于推进领域模型的设计.</p> <p>而对于新的创业企业, 他们面对的是从来没人做过的全新的业务和领域, 没有任何可借鉴的经验, 更不要提什么领域专家. 对于这种情况, 就需要团队一起经过更多次更细致的事件风暴, 才能建立领域模型. 当然建模过程离不开产品愿景分析, 这个过程是确定和统一系统建设目标以及项目的核心竞争力在哪里. 这种初创业务的领域模型往往需要经过多次迭代才能成型, 不要奢望一次就可以建立一个完美的领域模型.</p> <h5 id="_2-团队ddd的理念和技术能力问题"><a href="#_2-团队ddd的理念和技术能力问题" class="header-anchor">#</a> 2.团队DDD的理念和技术能力问题</h5> <p>完成领域建模和微服务设计后, 就要投入开发和测试了. 这时你可能会发现一些开发人员, 并不理解 DDD 设计方法, 不知道什么是聚合, 分层以及边界? 也不知道服务的依赖以及层与层之间的职责边界是什么?</p> <p>这样容易出现设计很精妙, 而开发很糟糕的状况. 遇到这种情况, 除了要在项目团队普及 DDD 的知识和设计理念外, 还要<strong>让所有的项目成员尽早地参与到领域建模中</strong>, 事件风暴的过程除了统一团队语言外, 还可以让团队成员提前了解领域模型, 设计要点和注意事项.</p> <h5 id="_3-ddd设计原则问题"><a href="#_3-ddd设计原则问题" class="header-anchor">#</a> 3.DDD设计原则问题</h5> <p>DDD 基于各种考虑, 有很多的设计原则, 也用到了很多的设计模式. 条条框框多了, 很多人可能就会被束缚住, 总是担心或犹豫这是不是原汁原味的 DDD. 其实不必追求极致的 DDD, 这样做反而会导致过度设计, 增加开发复杂度和项目成本.</p> <p>DDD 的设计原则或模式, 是考虑了很多具体场景或者前提的. 有的是为了解耦, 如仓储服务, 边界以及分层, 有的则是为了保证数据一致性, 如聚合根管理等. 在理解了这些设计原则的根本原因后, 有些场景就可以灵活把握设计方法了, 可以突破一些原则, 不必受限于条条框框, 大胆选择最合适的方法.</p> <p><strong>以上就是我对这三个问题的理解了.</strong></p> <p>用好 DDD 的关键, 首先要领悟 DDD 的核心设计思想和理念, 了解它为什么适合微服务架构, 然后慢慢体会, 消化, 吸收和实践. DDD 体系虽然复杂, 但也是有矩可循的, 照着样例多做几个事件风暴, 完成领域建模和微服务设计, 体会 DDD 的整个设计过程. 相信你很快就能领悟到 DDD 的核心设计理念了, 这样就可以做到收放自如, 趟出一条适合自己的 DDD 实践之路.</p> <p>好了, 到了该说再见的时候了. 再次感谢你的陪伴, 期待再相遇! 愿我们都能跨过坑和大海, 开辟出一片广阔新天地!</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/main/docs/20.开发/2100.开发/100.软件设计/31.DDD实战课(极客时间)🌸.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/661fa4/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">领域驱动设计(DDD)</div></a> <a href="/pages/d3fbd2/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">数据库基础</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/661fa4/" class="prev">领域驱动设计(DDD)</a></span> <span class="next"><a href="/pages/d3fbd2/">数据库基础</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1174520425@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/nanodaemony" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>达尔文的猹 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3f3e0e10.js" defer></script><script src="/assets/js/2.e9fcb30c.js" defer></script><script src="/assets/js/3.1998f389.js" defer></script><script src="/assets/js/93.6bf5fb66.js" defer></script>
  </body>
</html>
